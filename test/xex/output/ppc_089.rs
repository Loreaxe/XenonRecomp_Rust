pub fn sub_829E5670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E5670 size=60
    let mut pc: u32 = 0x829E5670;
    'dispatch: loop {
        match pc {
            0x829E5670 => {
    //   block [0x829E5670..0x829E56AC)
	// 829E5670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E5674: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E5678: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E567C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E5680: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 829E5684: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E5688: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829E568C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E5690: 48001539  bl 0x829e6bc8
	ctx.lr = 0x829E5694;
	sub_829E6BC8(ctx, base);
	// 829E5694: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5698: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E569C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E56A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E56A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E56A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E56B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E56B0 size=60
    let mut pc: u32 = 0x829E56B0;
    'dispatch: loop {
        match pc {
            0x829E56B0 => {
    //   block [0x829E56B0..0x829E56EC)
	// 829E56B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E56B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E56B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E56BC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E56C0: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 829E56C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E56C8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829E56CC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E56D0: 480016A9  bl 0x829e6d78
	ctx.lr = 0x829E56D4;
	sub_829E6D78(ctx, base);
	// 829E56D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E56D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E56DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E56E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E56E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E56E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E56F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E56F0 size=60
    let mut pc: u32 = 0x829E56F0;
    'dispatch: loop {
        match pc {
            0x829E56F0 => {
    //   block [0x829E56F0..0x829E572C)
	// 829E56F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E56F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E56F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E56FC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E5700: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 829E5704: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E5708: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829E570C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E5710: 48001819  bl 0x829e6f28
	ctx.lr = 0x829E5714;
	sub_829E6F28(ctx, base);
	// 829E5714: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5718: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E571C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E5720: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E5724: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E5728: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E5730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E5730 size=120
    let mut pc: u32 = 0x829E5730;
    'dispatch: loop {
        match pc {
            0x829E5730 => {
    //   block [0x829E5730..0x829E57A8)
	// 829E5730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E5734: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E5738: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E573C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E5740: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 829E5744: EC010072  fmuls f0, f1, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[1].f64) as f32) as f64);
	// 829E5748: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 829E574C: EDA200B2  fmuls f13, f2, f2
	ctx.f[13].f64 = (((ctx.f[2].f64 * ctx.f[2].f64) as f32) as f64);
	// 829E5750: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829E5754: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 829E5758: D1A10080  stfs f13, 0x80(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 829E575C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E5760: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E57A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E57A8 size=108
    let mut pc: u32 = 0x829E57A8;
    'dispatch: loop {
        match pc {
            0x829E57A8 => {
    //   block [0x829E57A8..0x829E57D8)
	// 829E57A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E57AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E57B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E57B4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E57B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E57BC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 829E57C0: 419A0018  beq cr6, 0x829e57d8
	if ctx.cr[6].eq {
	pc = 0x829E57D8; continue 'dispatch;
	}
	// 829E57C4: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E57C8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E57CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E57D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E57D4: 409A0008  bne cr6, 0x829e57dc
	if !ctx.cr[6].eq {
	pc = 0x829E57DC; continue 'dispatch;
	}
	pc = 0x829E57D8; continue 'dispatch;
            }
            0x829E57D8 => {
    //   block [0x829E57D8..0x829E57DC)
	// 829E57D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829E57DC; continue 'dispatch;
            }
            0x829E57DC => {
    //   block [0x829E57DC..0x829E57FC)
	// 829E57DC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E57E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E57E4: 419A0018  beq cr6, 0x829e57fc
	if ctx.cr[6].eq {
	pc = 0x829E57FC; continue 'dispatch;
	}
	// 829E57E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E57EC: 4BB2BE8D  bl 0x82511678
	ctx.lr = 0x829E57F0;
	sub_82511678(ctx, base);
	// 829E57F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829E57F4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E57F8: 48001A91  bl 0x829e7288
	ctx.lr = 0x829E57FC;
	sub_829E7288(ctx, base);
	pc = 0x829E57FC; continue 'dispatch;
            }
            0x829E57FC => {
    //   block [0x829E57FC..0x829E5814)
	// 829E57FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5800: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829E5804: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E5808: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E580C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E5810: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E5818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E5818 size=108
    let mut pc: u32 = 0x829E5818;
    'dispatch: loop {
        match pc {
            0x829E5818 => {
    //   block [0x829E5818..0x829E5848)
	// 829E5818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E581C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E5820: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E5824: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E5828: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E582C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 829E5830: 419A0018  beq cr6, 0x829e5848
	if ctx.cr[6].eq {
	pc = 0x829E5848; continue 'dispatch;
	}
	// 829E5834: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E5838: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E583C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E5840: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E5844: 409A0008  bne cr6, 0x829e584c
	if !ctx.cr[6].eq {
	pc = 0x829E584C; continue 'dispatch;
	}
	pc = 0x829E5848; continue 'dispatch;
            }
            0x829E5848 => {
    //   block [0x829E5848..0x829E584C)
	// 829E5848: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829E584C; continue 'dispatch;
            }
            0x829E584C => {
    //   block [0x829E584C..0x829E586C)
	// 829E584C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E5850: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E5854: 419A0018  beq cr6, 0x829e586c
	if ctx.cr[6].eq {
	pc = 0x829E586C; continue 'dispatch;
	}
	// 829E5858: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E585C: 4BB2C035  bl 0x82511890
	ctx.lr = 0x829E5860;
	sub_82511890(ctx, base);
	// 829E5860: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829E5864: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E5868: 48001BD1  bl 0x829e7438
	ctx.lr = 0x829E586C;
	sub_829E7438(ctx, base);
	pc = 0x829E586C; continue 'dispatch;
            }
            0x829E586C => {
    //   block [0x829E586C..0x829E5884)
	// 829E586C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5870: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E5874: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E5878: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E587C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E5880: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E5888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E5888 size=48
    let mut pc: u32 = 0x829E5888;
    'dispatch: loop {
        match pc {
            0x829E5888 => {
    //   block [0x829E5888..0x829E58B8)
	// 829E5888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E588C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E5890: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E5894: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829E5898: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E589C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E58B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E58B8 size=48
    let mut pc: u32 = 0x829E58B8;
    'dispatch: loop {
        match pc {
            0x829E58B8 => {
    //   block [0x829E58B8..0x829E58E8)
	// 829E58B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E58BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E58C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E58C4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829E58C8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E58CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E58E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E58E8 size=104
    let mut pc: u32 = 0x829E58E8;
    'dispatch: loop {
        match pc {
            0x829E58E8 => {
    //   block [0x829E58E8..0x829E5918)
	// 829E58E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E58EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E58F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E58F4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E58F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E58FC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 829E5900: 419A0018  beq cr6, 0x829e5918
	if ctx.cr[6].eq {
	pc = 0x829E5918; continue 'dispatch;
	}
	// 829E5904: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E5908: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E590C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E5910: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E5914: 409A0008  bne cr6, 0x829e591c
	if !ctx.cr[6].eq {
	pc = 0x829E591C; continue 'dispatch;
	}
	pc = 0x829E5918; continue 'dispatch;
            }
            0x829E5918 => {
    //   block [0x829E5918..0x829E591C)
	// 829E5918: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829E591C; continue 'dispatch;
            }
            0x829E591C => {
    //   block [0x829E591C..0x829E5938)
	// 829E591C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E5920: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E5924: 419A0014  beq cr6, 0x829e5938
	if ctx.cr[6].eq {
	pc = 0x829E5938; continue 'dispatch;
	}
	// 829E5928: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 829E592C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829E5930: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E5934: 48001F6D  bl 0x829e78a0
	ctx.lr = 0x829E5938;
	sub_829E78A0(ctx, base);
	pc = 0x829E5938; continue 'dispatch;
            }
            0x829E5938 => {
    //   block [0x829E5938..0x829E5950)
	// 829E5938: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E593C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E5940: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E5944: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E5948: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E594C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E5950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E5950 size=60
    let mut pc: u32 = 0x829E5950;
    'dispatch: loop {
        match pc {
            0x829E5950 => {
    //   block [0x829E5950..0x829E598C)
	// 829E5950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E5954: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E5958: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E595C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E5960: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 829E5964: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E5968: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829E596C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E5970: 480020D9  bl 0x829e7a48
	ctx.lr = 0x829E5974;
	sub_829E7A48(ctx, base);
	// 829E5974: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5978: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E597C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E5980: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E5984: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E5988: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E5990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E5990 size=80
    let mut pc: u32 = 0x829E5990;
    'dispatch: loop {
        match pc {
            0x829E5990 => {
    //   block [0x829E5990..0x829E59E0)
	// 829E5990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E5994: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E5998: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E599C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E59A0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E59A4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829E59A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E59AC: 99410054  stb r10, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u8 ) };
	// 829E59B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829E59B4: C00BCB94  lfs f0, -0x346c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13420 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829E59B8: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 829E59BC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829E59C0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E59C4: 48002235  bl 0x829e7bf8
	ctx.lr = 0x829E59C8;
	sub_829E7BF8(ctx, base);
	// 829E59C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E59CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E59D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E59D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E59D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E59DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E59E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E59E0 size=80
    let mut pc: u32 = 0x829E59E0;
    'dispatch: loop {
        match pc {
            0x829E59E0 => {
    //   block [0x829E59E0..0x829E5A30)
	// 829E59E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E59E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E59E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E59EC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E59F0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E59F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829E59F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E59FC: 99410054  stb r10, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u8 ) };
	// 829E5A00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829E5A04: C00BCB94  lfs f0, -0x346c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13420 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829E5A08: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 829E5A0C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829E5A10: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E5A14: 480021E5  bl 0x829e7bf8
	ctx.lr = 0x829E5A18;
	sub_829E7BF8(ctx, base);
	// 829E5A18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5A1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E5A20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E5A24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E5A28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E5A2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E5A30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E5A30 size=104
    let mut pc: u32 = 0x829E5A30;
    'dispatch: loop {
        match pc {
            0x829E5A30 => {
    //   block [0x829E5A30..0x829E5A60)
	// 829E5A30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E5A34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E5A38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E5A3C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E5A40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E5A44: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 829E5A48: 419A0018  beq cr6, 0x829e5a60
	if ctx.cr[6].eq {
	pc = 0x829E5A60; continue 'dispatch;
	}
	// 829E5A4C: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E5A50: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E5A54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E5A58: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E5A5C: 409A0008  bne cr6, 0x829e5a64
	if !ctx.cr[6].eq {
	pc = 0x829E5A64; continue 'dispatch;
	}
	pc = 0x829E5A60; continue 'dispatch;
            }
            0x829E5A60 => {
    //   block [0x829E5A60..0x829E5A64)
	// 829E5A60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829E5A64; continue 'dispatch;
            }
            0x829E5A64 => {
    //   block [0x829E5A64..0x829E5A80)
	// 829E5A64: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E5A68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E5A6C: 419A0014  beq cr6, 0x829e5a80
	if ctx.cr[6].eq {
	pc = 0x829E5A80; continue 'dispatch;
	}
	// 829E5A70: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 829E5A74: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829E5A78: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E5A7C: 4800232D  bl 0x829e7da8
	ctx.lr = 0x829E5A80;
	sub_829E7DA8(ctx, base);
	pc = 0x829E5A80; continue 'dispatch;
            }
            0x829E5A80 => {
    //   block [0x829E5A80..0x829E5A98)
	// 829E5A80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5A84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E5A88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E5A8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E5A90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E5A94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E5A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E5A98 size=248
    let mut pc: u32 = 0x829E5A98;
    'dispatch: loop {
        match pc {
            0x829E5A98 => {
    //   block [0x829E5A98..0x829E5AD8)
	// 829E5A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E5A9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E5AA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E5AA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E5AA8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 829E5AAC: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E5AB0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829E5AB4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829E5AB8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E5ABC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829E5AC0: 419A0018  beq cr6, 0x829e5ad8
	if ctx.cr[6].eq {
	pc = 0x829E5AD8; continue 'dispatch;
	}
	// 829E5AC4: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E5AC8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E5ACC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E5AD0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E5AD4: 409A0008  bne cr6, 0x829e5adc
	if !ctx.cr[6].eq {
	pc = 0x829E5ADC; continue 'dispatch;
	}
	pc = 0x829E5AD8; continue 'dispatch;
            }
            0x829E5AD8 => {
    //   block [0x829E5AD8..0x829E5ADC)
	// 829E5AD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829E5ADC; continue 'dispatch;
            }
            0x829E5ADC => {
    //   block [0x829E5ADC..0x829E5B70)
	// 829E5ADC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E5AE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E5AE4: 419A008C  beq cr6, 0x829e5b70
	if ctx.cr[6].eq {
	pc = 0x829E5B70; continue 'dispatch;
	}
	// 829E5AE8: 809F007C  lwz r4, 0x7c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E5AEC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829E5AF0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E5AF4: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 829E5AF8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829E5AFC: 4E800421  bctrl
	ctx.lr = 0x829E5B00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829E5B00: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 829E5B04: 38E100A0  addi r7, r1, 0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + 160;
	// 829E5B08: EC1F07F2  fmuls f0, f31, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[31].f64) as f32) as f64);
	// 829E5B0C: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 829E5B10: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 829E5B14: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 829E5B18: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829E5B1C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 829E5B20: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x829E5B70 => {
    //   block [0x829E5B70..0x829E5B90)
	// 829E5B70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E5B74: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 829E5B78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E5B7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E5B80: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 829E5B84: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E5B88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E5B8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E5B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E5B90 size=112
    let mut pc: u32 = 0x829E5B90;
    'dispatch: loop {
        match pc {
            0x829E5B90 => {
    //   block [0x829E5B90..0x829E5BC0)
	// 829E5B90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E5B94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E5B98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E5B9C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E5BA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E5BA4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 829E5BA8: 419A0018  beq cr6, 0x829e5bc0
	if ctx.cr[6].eq {
	pc = 0x829E5BC0; continue 'dispatch;
	}
	// 829E5BAC: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E5BB0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E5BB4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E5BB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E5BBC: 409A0008  bne cr6, 0x829e5bc4
	if !ctx.cr[6].eq {
	pc = 0x829E5BC4; continue 'dispatch;
	}
	pc = 0x829E5BC0; continue 'dispatch;
            }
            0x829E5BC0 => {
    //   block [0x829E5BC0..0x829E5BC4)
	// 829E5BC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829E5BC4; continue 'dispatch;
            }
            0x829E5BC4 => {
    //   block [0x829E5BC4..0x829E5BE8)
	// 829E5BC4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E5BC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E5BCC: 419A001C  beq cr6, 0x829e5be8
	if ctx.cr[6].eq {
	pc = 0x829E5BE8; continue 'dispatch;
	}
	// 829E5BD0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E5BD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E5BD8: 4BB2BF81  bl 0x82511b58
	ctx.lr = 0x829E5BDC;
	sub_82511B58(ctx, base);
	// 829E5BDC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829E5BE0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E5BE4: 4800255D  bl 0x829e8140
	ctx.lr = 0x829E5BE8;
	sub_829E8140(ctx, base);
	pc = 0x829E5BE8; continue 'dispatch;
            }
            0x829E5BE8 => {
    //   block [0x829E5BE8..0x829E5C00)
	// 829E5BE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5BEC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 829E5BF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E5BF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E5BF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E5BFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E5C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E5C00 size=276
    let mut pc: u32 = 0x829E5C00;
    'dispatch: loop {
        match pc {
            0x829E5C00 => {
    //   block [0x829E5C00..0x829E5CF8)
	// 829E5C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E5C04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E5C08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E5C0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E5C10: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E5C14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E5C18: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E5C1C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E5C20: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 829E5C24: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 829E5C28: 2F080010  cmpwi cr6, r8, 0x10
	ctx.cr[6].compare_i32(ctx.r[8].s32, 16, &mut ctx.xer);
	// 829E5C2C: 409A00CC  bne cr6, 0x829e5cf8
	if !ctx.cr[6].eq {
	pc = 0x829E5CF8; continue 'dispatch;
	}
	// 829E5C30: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829E5C34: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829E5C38: 38ABC38C  addi r5, r11, -0x3c74
	ctx.r[5].s64 = ctx.r[11].s64 + -15476;
	// 829E5C3C: 4B84238D  bl 0x82227fc8
	ctx.lr = 0x829E5C40;
	sub_82227FC8(ctx, base);
	// 829E5C40: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E5C44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E5C48: 419A00B0  beq cr6, 0x829e5cf8
	if ctx.cr[6].eq {
	pc = 0x829E5CF8; continue 'dispatch;
	}
	// 829E5C4C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829E5C50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5C54: 4B8424A5  bl 0x822280f8
	ctx.lr = 0x829E5C58;
	sub_822280F8(ctx, base);
	// 829E5C58: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E5C5C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E5C60: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 829E5C64: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E5C68: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829E5C6C: 4098008C  bge cr6, 0x829e5cf8
	if !ctx.cr[6].lt {
	pc = 0x829E5CF8; continue 'dispatch;
	}
	// 829E5C70: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829E5C74: 392A9700  addi r9, r10, -0x6900
	ctx.r[9].s64 = ctx.r[10].s64 + -26880;
	// 829E5C78: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 829E5C7C: 419A007C  beq cr6, 0x829e5cf8
	if ctx.cr[6].eq {
	pc = 0x829E5CF8; continue 'dispatch;
	}
	// 829E5C80: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E5C84: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 829E5C88: 409A0070  bne cr6, 0x829e5cf8
	if !ctx.cr[6].eq {
	pc = 0x829E5CF8; continue 'dispatch;
	}
	// 829E5C8C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829E5C90: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829E5C94: 388B10F0  addi r4, r11, 0x10f0
	ctx.r[4].s64 = ctx.r[11].s64 + 4336;
	// 829E5C98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E5C9C: 4B847235  bl 0x8222ced0
	ctx.lr = 0x829E5CA0;
	sub_8222CED0(ctx, base);
	// 829E5CA0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829E5CA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E5CA8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829E5CAC: 4BA726A5  bl 0x82458350
	ctx.lr = 0x829E5CB0;
	sub_82458350(ctx, base);
	// 829E5CB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E5CB4: 4B82F125  bl 0x82214dd8
	ctx.lr = 0x829E5CB8;
	sub_82214DD8(ctx, base);
	// 829E5CB8: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 829E5CBC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E5CC0: 4BA7EF91  bl 0x82464c50
	ctx.lr = 0x829E5CC4;
	sub_82464C50(ctx, base);
	// 829E5CC4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829E5CC8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E5CCC: 48002625  bl 0x829e82f0
	ctx.lr = 0x829E5CD0;
	sub_829E82F0(ctx, base);
	// 829E5CD0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829E5CD4: 4B82F105  bl 0x82214dd8
	ctx.lr = 0x829E5CD8;
	sub_82214DD8(ctx, base);
	// 829E5CD8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E5CDC: 4B7D1E3D  bl 0x821b7b18
	ctx.lr = 0x829E5CE0;
	sub_821B7B18(ctx, base);
	// 829E5CE0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829E5CE4: 4B82F0F5  bl 0x82214dd8
	ctx.lr = 0x829E5CE8;
	sub_82214DD8(ctx, base);
	// 829E5CE8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829E5CEC: 4B7D1E2D  bl 0x821b7b18
	ctx.lr = 0x829E5CF0;
	sub_821B7B18(ctx, base);
	// 829E5CF0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829E5CF4: 48000008  b 0x829e5cfc
	pc = 0x829E5CFC; continue 'dispatch;
            }
            0x829E5CF8 => {
    //   block [0x829E5CF8..0x829E5CFC)
	// 829E5CF8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x829E5CFC; continue 'dispatch;
            }
            0x829E5CFC => {
    //   block [0x829E5CFC..0x829E5D14)
	// 829E5CFC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829E5D00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E5D04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E5D08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E5D0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E5D10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E5D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E5D18 size=1120
    let mut pc: u32 = 0x829E5D18;
    'dispatch: loop {
        match pc {
            0x829E5D18 => {
    //   block [0x829E5D18..0x829E5DC8)
	// 829E5D18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E5D1C: 482C36F1  bl 0x82ca940c
	ctx.lr = 0x829E5D20;
	sub_82CA93D0(ctx, base);
	// 829E5D20: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E5D24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E5D28: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E5D2C: 4B9E8895  bl 0x823ce5c0
	ctx.lr = 0x829E5D30;
	sub_823CE5C0(ctx, base);
	// 829E5D30: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 829E5D34: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829E5D38: 38AB0DBC  addi r5, r11, 0xdbc
	ctx.r[5].s64 = ctx.r[11].s64 + 3516;
	// 829E5D3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E5D40: 4B9E84C1  bl 0x823ce200
	ctx.lr = 0x829E5D44;
	sub_823CE200(ctx, base);
	// 829E5D44: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E5D48: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829E5D4C: 419A007C  beq cr6, 0x829e5dc8
	if ctx.cr[6].eq {
	pc = 0x829E5DC8; continue 'dispatch;
	}
	// 829E5D50: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E5D54: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 829E5D58: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E5D5C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E5D60: 4B8433A9  bl 0x82229108
	ctx.lr = 0x829E5D64;
	sub_82229108(ctx, base);
	// 829E5D64: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 829E5D68: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 829E5D6C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E5D70: 3BCB54D0  addi r30, r11, 0x54d0
	ctx.r[30].s64 = ctx.r[11].s64 + 21712;
	// 829E5D74: 4B841B0D  bl 0x82227880
	ctx.lr = 0x829E5D78;
	sub_82227880(ctx, base);
	// 829E5D78: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829E5D7C: 3D40829F  lis r10, -0x7d61
	ctx.r[10].s64 = -2103508992;
	// 829E5D80: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829E5D84: 388AA590  addi r4, r10, -0x5a70
	ctx.r[4].s64 = ctx.r[10].s64 + -23152;
	// 829E5D88: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E5D8C: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829E5D90: 4B7B4CF1  bl 0x8219aa80
	ctx.lr = 0x829E5D94;
	sub_8219AA80(ctx, base);
	// 829E5D94: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 829E5D98: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E5D9C: 3BC91100  addi r30, r9, 0x1100
	ctx.r[30].s64 = ctx.r[9].s64 + 4352;
	// 829E5DA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E5DA4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829E5DA8: 4B9E8679  bl 0x823ce420
	ctx.lr = 0x829E5DAC;
	sub_823CE420(ctx, base);
	// 829E5DAC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829E5DB0: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 829E5DB4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E5DB8: 4803E911  bl 0x82a246c8
	ctx.lr = 0x829E5DBC;
	sub_82A246C8(ctx, base);
	// 829E5DBC: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E5DC0: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 829E5DC4: 911D0008  stw r8, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x829E5DC8; continue 'dispatch;
            }
            0x829E5DC8 => {
    //   block [0x829E5DC8..0x829E5E78)
	// 829E5DC8: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 829E5DCC: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 829E5DD0: 38AB5540  addi r5, r11, 0x5540
	ctx.r[5].s64 = ctx.r[11].s64 + 21824;
	// 829E5DD4: 388A111C  addi r4, r10, 0x111c
	ctx.r[4].s64 = ctx.r[10].s64 + 4380;
	// 829E5DD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E5DDC: 480026C5  bl 0x829e84a0
	ctx.lr = 0x829E5DE0;
	sub_829E84A0(ctx, base);
	// 829E5DE0: 3D20829E  lis r9, -0x7d62
	ctx.r[9].s64 = -2103574528;
	// 829E5DE4: 3D00820F  lis r8, -0x7df1
	ctx.r[8].s64 = -2112946176;
	// 829E5DE8: 38A95638  addi r5, r9, 0x5638
	ctx.r[5].s64 = ctx.r[9].s64 + 22072;
	// 829E5DEC: 3888112C  addi r4, r8, 0x112c
	ctx.r[4].s64 = ctx.r[8].s64 + 4396;
	// 829E5DF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E5DF4: 48002745  bl 0x829e8538
	ctx.lr = 0x829E5DF8;
	sub_829E8538(ctx, base);
	// 829E5DF8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829E5DFC: 419A007C  beq cr6, 0x829e5e78
	if ctx.cr[6].eq {
	pc = 0x829E5E78; continue 'dispatch;
	}
	// 829E5E00: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E5E04: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 829E5E08: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E5E0C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E5E10: 4B8432F9  bl 0x82229108
	ctx.lr = 0x829E5E14;
	sub_82229108(ctx, base);
	// 829E5E14: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 829E5E18: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 829E5E1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E5E20: 3BCB5580  addi r30, r11, 0x5580
	ctx.r[30].s64 = ctx.r[11].s64 + 21888;
	// 829E5E24: 4B841A5D  bl 0x82227880
	ctx.lr = 0x829E5E28;
	sub_82227880(ctx, base);
	// 829E5E28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829E5E2C: 3D40829F  lis r10, -0x7d61
	ctx.r[10].s64 = -2103508992;
	// 829E5E30: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829E5E34: 388AA690  addi r4, r10, -0x5970
	ctx.r[4].s64 = ctx.r[10].s64 + -22896;
	// 829E5E38: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E5E3C: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829E5E40: 4B7B4C41  bl 0x8219aa80
	ctx.lr = 0x829E5E44;
	sub_8219AA80(ctx, base);
	// 829E5E44: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 829E5E48: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E5E4C: 3BC91144  addi r30, r9, 0x1144
	ctx.r[30].s64 = ctx.r[9].s64 + 4420;
	// 829E5E50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E5E54: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829E5E58: 4B9E85C9  bl 0x823ce420
	ctx.lr = 0x829E5E5C;
	sub_823CE420(ctx, base);
	// 829E5E5C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829E5E60: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 829E5E64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E5E68: 4803E861  bl 0x82a246c8
	ctx.lr = 0x829E5E6C;
	sub_82A246C8(ctx, base);
	// 829E5E6C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E5E70: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 829E5E74: 911D0008  stw r8, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x829E5E78; continue 'dispatch;
            }
            0x829E5E78 => {
    //   block [0x829E5E78..0x829E5F88)
	// 829E5E78: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 829E5E7C: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 829E5E80: 38AB55C8  addi r5, r11, 0x55c8
	ctx.r[5].s64 = ctx.r[11].s64 + 21960;
	// 829E5E84: 388A1154  addi r4, r10, 0x1154
	ctx.r[4].s64 = ctx.r[10].s64 + 4436;
	// 829E5E88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E5E8C: 480026AD  bl 0x829e8538
	ctx.lr = 0x829E5E90;
	sub_829E8538(ctx, base);
	// 829E5E90: 3D20829E  lis r9, -0x7d62
	ctx.r[9].s64 = -2103574528;
	// 829E5E94: 3D00820F  lis r8, -0x7df1
	ctx.r[8].s64 = -2112946176;
	// 829E5E98: 38A95600  addi r5, r9, 0x5600
	ctx.r[5].s64 = ctx.r[9].s64 + 22016;
	// 829E5E9C: 38881168  addi r4, r8, 0x1168
	ctx.r[4].s64 = ctx.r[8].s64 + 4456;
	// 829E5EA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E5EA4: 48002695  bl 0x829e8538
	ctx.lr = 0x829E5EA8;
	sub_829E8538(ctx, base);
	// 829E5EA8: 3CE0829E  lis r7, -0x7d62
	ctx.r[7].s64 = -2103574528;
	// 829E5EAC: 3CC0820F  lis r6, -0x7df1
	ctx.r[6].s64 = -2112946176;
	// 829E5EB0: 38A75C00  addi r5, r7, 0x5c00
	ctx.r[5].s64 = ctx.r[7].s64 + 23552;
	// 829E5EB4: 38861180  addi r4, r6, 0x1180
	ctx.r[4].s64 = ctx.r[6].s64 + 4480;
	// 829E5EB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E5EBC: 4B9E8425  bl 0x823ce2e0
	ctx.lr = 0x829E5EC0;
	sub_823CE2E0(ctx, base);
	// 829E5EC0: 3CA0829E  lis r5, -0x7d62
	ctx.r[5].s64 = -2103574528;
	// 829E5EC4: 3C80820F  lis r4, -0x7df1
	ctx.r[4].s64 = -2112946176;
	// 829E5EC8: 38A55670  addi r5, r5, 0x5670
	ctx.r[5].s64 = ctx.r[5].s64 + 22128;
	// 829E5ECC: 38841198  addi r4, r4, 0x1198
	ctx.r[4].s64 = ctx.r[4].s64 + 4504;
	// 829E5ED0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E5ED4: 480025CD  bl 0x829e84a0
	ctx.lr = 0x829E5ED8;
	sub_829E84A0(ctx, base);
	// 829E5ED8: 3C60829E  lis r3, -0x7d62
	ctx.r[3].s64 = -2103574528;
	// 829E5EDC: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829E5EE0: 38A356B0  addi r5, r3, 0x56b0
	ctx.r[5].s64 = ctx.r[3].s64 + 22192;
	// 829E5EE4: 388B11B0  addi r4, r11, 0x11b0
	ctx.r[4].s64 = ctx.r[11].s64 + 4528;
	// 829E5EE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E5EEC: 480025B5  bl 0x829e84a0
	ctx.lr = 0x829E5EF0;
	sub_829E84A0(ctx, base);
	// 829E5EF0: 3D40829E  lis r10, -0x7d62
	ctx.r[10].s64 = -2103574528;
	// 829E5EF4: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 829E5EF8: 38AA56F0  addi r5, r10, 0x56f0
	ctx.r[5].s64 = ctx.r[10].s64 + 22256;
	// 829E5EFC: 388911C4  addi r4, r9, 0x11c4
	ctx.r[4].s64 = ctx.r[9].s64 + 4548;
	// 829E5F00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E5F04: 4800259D  bl 0x829e84a0
	ctx.lr = 0x829E5F08;
	sub_829E84A0(ctx, base);
	// 829E5F08: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829E5F0C: 419A007C  beq cr6, 0x829e5f88
	if ctx.cr[6].eq {
	pc = 0x829E5F88; continue 'dispatch;
	}
	// 829E5F10: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E5F14: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 829E5F18: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E5F1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E5F20: 4B8431E9  bl 0x82229108
	ctx.lr = 0x829E5F24;
	sub_82229108(ctx, base);
	// 829E5F24: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 829E5F28: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 829E5F2C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E5F30: 3BCB5730  addi r30, r11, 0x5730
	ctx.r[30].s64 = ctx.r[11].s64 + 22320;
	// 829E5F34: 4B84194D  bl 0x82227880
	ctx.lr = 0x829E5F38;
	sub_82227880(ctx, base);
	// 829E5F38: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829E5F3C: 3D40829F  lis r10, -0x7d61
	ctx.r[10].s64 = -2103508992;
	// 829E5F40: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829E5F44: 388AA718  addi r4, r10, -0x58e8
	ctx.r[4].s64 = ctx.r[10].s64 + -22760;
	// 829E5F48: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E5F4C: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829E5F50: 4B7B4B31  bl 0x8219aa80
	ctx.lr = 0x829E5F54;
	sub_8219AA80(ctx, base);
	// 829E5F54: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 829E5F58: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E5F5C: 3BC911E8  addi r30, r9, 0x11e8
	ctx.r[30].s64 = ctx.r[9].s64 + 4584;
	// 829E5F60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E5F64: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829E5F68: 4B9E84B9  bl 0x823ce420
	ctx.lr = 0x829E5F6C;
	sub_823CE420(ctx, base);
	// 829E5F6C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829E5F70: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 829E5F74: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E5F78: 4803E751  bl 0x82a246c8
	ctx.lr = 0x829E5F7C;
	sub_82A246C8(ctx, base);
	// 829E5F7C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E5F80: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 829E5F84: 911D0008  stw r8, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x829E5F88; continue 'dispatch;
            }
            0x829E5F88 => {
    //   block [0x829E5F88..0x829E6020)
	// 829E5F88: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 829E5F8C: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 829E5F90: 38AB57A8  addi r5, r11, 0x57a8
	ctx.r[5].s64 = ctx.r[11].s64 + 22440;
	// 829E5F94: 388A1208  addi r4, r10, 0x1208
	ctx.r[4].s64 = ctx.r[10].s64 + 4616;
	// 829E5F98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E5F9C: 48002635  bl 0x829e85d0
	ctx.lr = 0x829E5FA0;
	sub_829E85D0(ctx, base);
	// 829E5FA0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829E5FA4: 419A007C  beq cr6, 0x829e6020
	if ctx.cr[6].eq {
	pc = 0x829E6020; continue 'dispatch;
	}
	// 829E5FA8: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E5FAC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 829E5FB0: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E5FB4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E5FB8: 4B843151  bl 0x82229108
	ctx.lr = 0x829E5FBC;
	sub_82229108(ctx, base);
	// 829E5FBC: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 829E5FC0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 829E5FC4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E5FC8: 3BCB5818  addi r30, r11, 0x5818
	ctx.r[30].s64 = ctx.r[11].s64 + 22552;
	// 829E5FCC: 4B8418B5  bl 0x82227880
	ctx.lr = 0x829E5FD0;
	sub_82227880(ctx, base);
	// 829E5FD0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829E5FD4: 3D40829F  lis r10, -0x7d61
	ctx.r[10].s64 = -2103508992;
	// 829E5FD8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829E5FDC: 388AA870  addi r4, r10, -0x5790
	ctx.r[4].s64 = ctx.r[10].s64 + -22416;
	// 829E5FE0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E5FE4: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829E5FE8: 4B7B4A99  bl 0x8219aa80
	ctx.lr = 0x829E5FEC;
	sub_8219AA80(ctx, base);
	// 829E5FEC: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 829E5FF0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E5FF4: 3BC91230  addi r30, r9, 0x1230
	ctx.r[30].s64 = ctx.r[9].s64 + 4656;
	// 829E5FF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E5FFC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829E6000: 4B9E8421  bl 0x823ce420
	ctx.lr = 0x829E6004;
	sub_823CE420(ctx, base);
	// 829E6004: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829E6008: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 829E600C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E6010: 4803E6B9  bl 0x82a246c8
	ctx.lr = 0x829E6014;
	sub_82A246C8(ctx, base);
	// 829E6014: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E6018: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 829E601C: 911D0008  stw r8, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x829E6020; continue 'dispatch;
            }
            0x829E6020 => {
    //   block [0x829E6020..0x829E6118)
	// 829E6020: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 829E6024: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 829E6028: 38AB58E8  addi r5, r11, 0x58e8
	ctx.r[5].s64 = ctx.r[11].s64 + 22760;
	// 829E602C: 388A1248  addi r4, r10, 0x1248
	ctx.r[4].s64 = ctx.r[10].s64 + 4680;
	// 829E6030: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E6034: 48002635  bl 0x829e8668
	ctx.lr = 0x829E6038;
	sub_829E8668(ctx, base);
	// 829E6038: 3D20829E  lis r9, -0x7d62
	ctx.r[9].s64 = -2103574528;
	// 829E603C: 3D00820F  lis r8, -0x7df1
	ctx.r[8].s64 = -2112946176;
	// 829E6040: 38A95990  addi r5, r9, 0x5990
	ctx.r[5].s64 = ctx.r[9].s64 + 22928;
	// 829E6044: 3888125C  addi r4, r8, 0x125c
	ctx.r[4].s64 = ctx.r[8].s64 + 4700;
	// 829E6048: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E604C: 480026B5  bl 0x829e8700
	ctx.lr = 0x829E6050;
	sub_829E8700(ctx, base);
	// 829E6050: 3CE0829E  lis r7, -0x7d62
	ctx.r[7].s64 = -2103574528;
	// 829E6054: 3CC0820F  lis r6, -0x7df1
	ctx.r[6].s64 = -2112946176;
	// 829E6058: 38A759E0  addi r5, r7, 0x59e0
	ctx.r[5].s64 = ctx.r[7].s64 + 23008;
	// 829E605C: 3886126C  addi r4, r6, 0x126c
	ctx.r[4].s64 = ctx.r[6].s64 + 4716;
	// 829E6060: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E6064: 4800269D  bl 0x829e8700
	ctx.lr = 0x829E6068;
	sub_829E8700(ctx, base);
	// 829E6068: 3CA0829E  lis r5, -0x7d62
	ctx.r[5].s64 = -2103574528;
	// 829E606C: 3C80820F  lis r4, -0x7df1
	ctx.r[4].s64 = -2112946176;
	// 829E6070: 38A55A98  addi r5, r5, 0x5a98
	ctx.r[5].s64 = ctx.r[5].s64 + 23192;
	// 829E6074: 38841284  addi r4, r4, 0x1284
	ctx.r[4].s64 = ctx.r[4].s64 + 4740;
	// 829E6078: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E607C: 48002555  bl 0x829e85d0
	ctx.lr = 0x829E6080;
	sub_829E85D0(ctx, base);
	// 829E6080: 3C60829E  lis r3, -0x7d62
	ctx.r[3].s64 = -2103574528;
	// 829E6084: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829E6088: 38A35B90  addi r5, r3, 0x5b90
	ctx.r[5].s64 = ctx.r[3].s64 + 23440;
	// 829E608C: 388B129C  addi r4, r11, 0x129c
	ctx.r[4].s64 = ctx.r[11].s64 + 4764;
	// 829E6090: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E6094: 4800253D  bl 0x829e85d0
	ctx.lr = 0x829E6098;
	sub_829E85D0(ctx, base);
	// 829E6098: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829E609C: 419A007C  beq cr6, 0x829e6118
	if ctx.cr[6].eq {
	pc = 0x829E6118; continue 'dispatch;
	}
	// 829E60A0: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E60A4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 829E60A8: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E60AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E60B0: 4B843059  bl 0x82229108
	ctx.lr = 0x829E60B4;
	sub_82229108(ctx, base);
	// 829E60B4: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 829E60B8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 829E60BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E60C0: 3BEB5950  addi r31, r11, 0x5950
	ctx.r[31].s64 = ctx.r[11].s64 + 22864;
	// 829E60C4: 4B8417BD  bl 0x82227880
	ctx.lr = 0x829E60C8;
	sub_82227880(ctx, base);
	// 829E60C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829E60CC: 3D40829F  lis r10, -0x7d61
	ctx.r[10].s64 = -2103508992;
	// 829E60D0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829E60D4: 388AA970  addi r4, r10, -0x5690
	ctx.r[4].s64 = ctx.r[10].s64 + -22160;
	// 829E60D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E60DC: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829E60E0: 4B7B49A1  bl 0x8219aa80
	ctx.lr = 0x829E60E4;
	sub_8219AA80(ctx, base);
	// 829E60E4: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 829E60E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829E60EC: 3BE912B8  addi r31, r9, 0x12b8
	ctx.r[31].s64 = ctx.r[9].s64 + 4792;
	// 829E60F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E60F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829E60F8: 4B9E8329  bl 0x823ce420
	ctx.lr = 0x829E60FC;
	sub_823CE420(ctx, base);
	// 829E60FC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829E6100: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 829E6104: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E6108: 4803E5C1  bl 0x82a246c8
	ctx.lr = 0x829E610C;
	sub_82A246C8(ctx, base);
	// 829E610C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E6110: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 829E6114: 911E0008  stw r8, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x829E6118; continue 'dispatch;
            }
            0x829E6118 => {
    //   block [0x829E6118..0x829E6178)
	// 829E6118: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 829E611C: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 829E6120: 38AB5A30  addi r5, r11, 0x5a30
	ctx.r[5].s64 = ctx.r[11].s64 + 23088;
	// 829E6124: 388A12D0  addi r4, r10, 0x12d0
	ctx.r[4].s64 = ctx.r[10].s64 + 4816;
	// 829E6128: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E612C: 4800253D  bl 0x829e8668
	ctx.lr = 0x829E6130;
	sub_829E8668(ctx, base);
	// 829E6130: 3D20829E  lis r9, -0x7d62
	ctx.r[9].s64 = -2103574528;
	// 829E6134: 3D00820F  lis r8, -0x7df1
	ctx.r[8].s64 = -2112946176;
	// 829E6138: 38A95888  addi r5, r9, 0x5888
	ctx.r[5].s64 = ctx.r[9].s64 + 22664;
	// 829E613C: 388812E0  addi r4, r8, 0x12e0
	ctx.r[4].s64 = ctx.r[8].s64 + 4832;
	// 829E6140: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E6144: 48002655  bl 0x829e8798
	ctx.lr = 0x829E6148;
	sub_829E8798(ctx, base);
	// 829E6148: 3CE0829E  lis r7, -0x7d62
	ctx.r[7].s64 = -2103574528;
	// 829E614C: 3CC0820F  lis r6, -0x7df1
	ctx.r[6].s64 = -2112946176;
	// 829E6150: 38A758B8  addi r5, r7, 0x58b8
	ctx.r[5].s64 = ctx.r[7].s64 + 22712;
	// 829E6154: 388612F4  addi r4, r6, 0x12f4
	ctx.r[4].s64 = ctx.r[6].s64 + 4852;
	// 829E6158: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E615C: 4800263D  bl 0x829e8798
	ctx.lr = 0x829E6160;
	sub_829E8798(ctx, base);
	// 829E6160: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E6164: 4B7D19B5  bl 0x821b7b18
	ctx.lr = 0x829E6168;
	sub_821B7B18(ctx, base);
	// 829E6168: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E616C: 4B7D19AD  bl 0x821b7b18
	ctx.lr = 0x829E6170;
	sub_821B7B18(ctx, base);
	// 829E6170: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829E6174: 482C32E8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E6178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E6178 size=432
    let mut pc: u32 = 0x829E6178;
    'dispatch: loop {
        match pc {
            0x829E6178 => {
    //   block [0x829E6178..0x829E61A8)
	// 829E6178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E617C: 482C3289  bl 0x82ca9404
	ctx.lr = 0x829E6180;
	sub_82CA93D0(ctx, base);
	// 829E6180: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E6184: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E6188: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 829E618C: 897D0024  lbz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 829E6190: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6194: 419A0138  beq cr6, 0x829e62cc
	if ctx.cr[6].eq {
	pc = 0x829E62CC; continue 'dispatch;
	}
	// 829E6198: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E619C: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E61A0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829E61A4: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829E61A8; continue 'dispatch;
            }
            0x829E61A8 => {
    //   block [0x829E61A8..0x829E61AC)
	// 829E61A8: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	pc = 0x829E61AC; continue 'dispatch;
            }
            0x829E61AC => {
    //   block [0x829E61AC..0x829E61C0)
	// 829E61AC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E61B0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E61B4: 419A000C  beq cr6, 0x829e61c0
	if ctx.cr[6].eq {
	pc = 0x829E61C0; continue 'dispatch;
	}
	// 829E61B8: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829E61BC: 419A0008  beq cr6, 0x829e61c4
	if ctx.cr[6].eq {
	pc = 0x829E61C4; continue 'dispatch;
	}
	pc = 0x829E61C0; continue 'dispatch;
            }
            0x829E61C0 => {
    //   block [0x829E61C0..0x829E61C4)
	// 829E61C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E61C4; continue 'dispatch;
            }
            0x829E61C4 => {
    //   block [0x829E61C4..0x829E61D8)
	// 829E61C4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E61C8: 419A0158  beq cr6, 0x829e6320
	if ctx.cr[6].eq {
	pc = 0x829E6320; continue 'dispatch;
	}
	// 829E61CC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E61D0: 409A0008  bne cr6, 0x829e61d8
	if !ctx.cr[6].eq {
	pc = 0x829E61D8; continue 'dispatch;
	}
	// 829E61D4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E61D8; continue 'dispatch;
            }
            0x829E61D8 => {
    //   block [0x829E61D8..0x829E61E8)
	// 829E61D8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E61DC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E61E0: 409A0008  bne cr6, 0x829e61e8
	if !ctx.cr[6].eq {
	pc = 0x829E61E8; continue 'dispatch;
	}
	// 829E61E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E61E8; continue 'dispatch;
            }
            0x829E61E8 => {
    //   block [0x829E61E8..0x829E6224)
	// 829E61E8: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E61EC: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 829E61F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E61F4: 419A0030  beq cr6, 0x829e6224
	if ctx.cr[6].eq {
	pc = 0x829E6224; continue 'dispatch;
	}
	// 829E61F8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E61FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E6200: 419A0064  beq cr6, 0x829e6264
	if ctx.cr[6].eq {
	pc = 0x829E6264; continue 'dispatch;
	}
	// 829E6204: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E6208: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E620C: 419A0018  beq cr6, 0x829e6224
	if ctx.cr[6].eq {
	pc = 0x829E6224; continue 'dispatch;
	}
	// 829E6210: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E6214: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E6218: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E621C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E6220: 409A0008  bne cr6, 0x829e6228
	if !ctx.cr[6].eq {
	pc = 0x829E6228; continue 'dispatch;
	}
	pc = 0x829E6224; continue 'dispatch;
            }
            0x829E6224 => {
    //   block [0x829E6224..0x829E6228)
	// 829E6224: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829E6228; continue 'dispatch;
            }
            0x829E6228 => {
    //   block [0x829E6228..0x829E6244)
	// 829E6228: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E622C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6230: 419A0078  beq cr6, 0x829e62a8
	if ctx.cr[6].eq {
	pc = 0x829E62A8; continue 'dispatch;
	}
	// 829E6234: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6238: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E623C: 409A0008  bne cr6, 0x829e6244
	if !ctx.cr[6].eq {
	pc = 0x829E6244; continue 'dispatch;
	}
	// 829E6240: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6244; continue 'dispatch;
            }
            0x829E6244 => {
    //   block [0x829E6244..0x829E6264)
	// 829E6244: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6248: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E624C: 419A002C  beq cr6, 0x829e6278
	if ctx.cr[6].eq {
	pc = 0x829E6278; continue 'dispatch;
	}
	// 829E6250: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E6254: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E6258: 419A0018  beq cr6, 0x829e6270
	if ctx.cr[6].eq {
	pc = 0x829E6270; continue 'dispatch;
	}
	// 829E625C: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 829E6260: 4800001C  b 0x829e627c
	pc = 0x829E627C; continue 'dispatch;
            }
            0x829E6264 => {
    //   block [0x829E6264..0x829E6270)
	// 829E6264: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E6268: 4B7ADBD1  bl 0x82193e38
	ctx.lr = 0x829E626C;
	sub_82193E38(ctx, base);
	// 829E626C: 4BFFFFB8  b 0x829e6224
	pc = 0x829E6224; continue 'dispatch;
            }
            0x829E6270 => {
    //   block [0x829E6270..0x829E6278)
	// 829E6270: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E6274: 4B7ADBC5  bl 0x82193e38
	ctx.lr = 0x829E6278;
	sub_82193E38(ctx, base);
	pc = 0x829E6278; continue 'dispatch;
            }
            0x829E6278 => {
    //   block [0x829E6278..0x829E627C)
	// 829E6278: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829E627C; continue 'dispatch;
            }
            0x829E627C => {
    //   block [0x829E627C..0x829E62A0)
	// 829E627C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829E6280: 4B819E69  bl 0x822000e8
	ctx.lr = 0x829E6284;
	sub_822000E8(ctx, base);
	// 829E6284: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E6288: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E628C: 419A001C  beq cr6, 0x829e62a8
	if ctx.cr[6].eq {
	pc = 0x829E62A8; continue 'dispatch;
	}
	// 829E6290: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6294: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E6298: 409A0008  bne cr6, 0x829e62a0
	if !ctx.cr[6].eq {
	pc = 0x829E62A0; continue 'dispatch;
	}
	// 829E629C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E62A0; continue 'dispatch;
            }
            0x829E62A0 => {
    //   block [0x829E62A0..0x829E62A8)
	// 829E62A0: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E62A4: 4BFFFF04  b 0x829e61a8
	pc = 0x829E61A8; continue 'dispatch;
            }
            0x829E62A8 => {
    //   block [0x829E62A8..0x829E62CC)
	// 829E62A8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E62AC: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829E62B0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E62B4: 4B7A49BD  bl 0x8218ac70
	ctx.lr = 0x829E62B8;
	sub_8218AC70(ctx, base);
	// 829E62B8: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 829E62BC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829E62C0: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E62C4: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E62C8: 4BFFFEE4  b 0x829e61ac
	pc = 0x829E61AC; continue 'dispatch;
            }
            0x829E62CC => {
    //   block [0x829E62CC..0x829E6308)
	// 829E62CC: 897D0025  lbz r11, 0x25(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(37 as u32) ) } as u64;
	// 829E62D0: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E62D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E62D8: 419A0030  beq cr6, 0x829e6308
	if ctx.cr[6].eq {
	pc = 0x829E6308; continue 'dispatch;
	}
	// 829E62DC: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E62E0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829E62E4: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 829E62E8: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 829E62EC: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 829E62F0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829E62F4: 4800476D  bl 0x829eaa60
	ctx.lr = 0x829E62F8;
	sub_829EAA60(ctx, base);
	// 829E62F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E62FC: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 829E6300: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E6304: 482C3150  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x829E6308 => {
    //   block [0x829E6308..0x829E6320)
	// 829E6308: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829E630C: 80BD0020  lwz r5, 0x20(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E6310: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829E6314: 4800251D  bl 0x829e8830
	ctx.lr = 0x829E6318;
	sub_829E8830(ctx, base);
	// 829E6318: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E631C: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	pc = 0x829E6320; continue 'dispatch;
            }
            0x829E6320 => {
    //   block [0x829E6320..0x829E6328)
	// 829E6320: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E6324: 482C3130  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E6328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E6328 size=432
    let mut pc: u32 = 0x829E6328;
    'dispatch: loop {
        match pc {
            0x829E6328 => {
    //   block [0x829E6328..0x829E6358)
	// 829E6328: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E632C: 482C30D9  bl 0x82ca9404
	ctx.lr = 0x829E6330;
	sub_82CA93D0(ctx, base);
	// 829E6330: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E6334: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E6338: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 829E633C: 897D0024  lbz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 829E6340: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6344: 419A0138  beq cr6, 0x829e647c
	if ctx.cr[6].eq {
	pc = 0x829E647C; continue 'dispatch;
	}
	// 829E6348: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E634C: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E6350: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829E6354: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829E6358; continue 'dispatch;
            }
            0x829E6358 => {
    //   block [0x829E6358..0x829E635C)
	// 829E6358: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	pc = 0x829E635C; continue 'dispatch;
            }
            0x829E635C => {
    //   block [0x829E635C..0x829E6370)
	// 829E635C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6360: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E6364: 419A000C  beq cr6, 0x829e6370
	if ctx.cr[6].eq {
	pc = 0x829E6370; continue 'dispatch;
	}
	// 829E6368: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829E636C: 419A0008  beq cr6, 0x829e6374
	if ctx.cr[6].eq {
	pc = 0x829E6374; continue 'dispatch;
	}
	pc = 0x829E6370; continue 'dispatch;
            }
            0x829E6370 => {
    //   block [0x829E6370..0x829E6374)
	// 829E6370: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6374; continue 'dispatch;
            }
            0x829E6374 => {
    //   block [0x829E6374..0x829E6388)
	// 829E6374: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E6378: 419A0158  beq cr6, 0x829e64d0
	if ctx.cr[6].eq {
	pc = 0x829E64D0; continue 'dispatch;
	}
	// 829E637C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E6380: 409A0008  bne cr6, 0x829e6388
	if !ctx.cr[6].eq {
	pc = 0x829E6388; continue 'dispatch;
	}
	// 829E6384: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6388; continue 'dispatch;
            }
            0x829E6388 => {
    //   block [0x829E6388..0x829E6398)
	// 829E6388: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E638C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E6390: 409A0008  bne cr6, 0x829e6398
	if !ctx.cr[6].eq {
	pc = 0x829E6398; continue 'dispatch;
	}
	// 829E6394: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6398; continue 'dispatch;
            }
            0x829E6398 => {
    //   block [0x829E6398..0x829E63D4)
	// 829E6398: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E639C: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 829E63A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E63A4: 419A0030  beq cr6, 0x829e63d4
	if ctx.cr[6].eq {
	pc = 0x829E63D4; continue 'dispatch;
	}
	// 829E63A8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E63AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E63B0: 419A0064  beq cr6, 0x829e6414
	if ctx.cr[6].eq {
	pc = 0x829E6414; continue 'dispatch;
	}
	// 829E63B4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E63B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E63BC: 419A0018  beq cr6, 0x829e63d4
	if ctx.cr[6].eq {
	pc = 0x829E63D4; continue 'dispatch;
	}
	// 829E63C0: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E63C4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E63C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E63CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E63D0: 409A0008  bne cr6, 0x829e63d8
	if !ctx.cr[6].eq {
	pc = 0x829E63D8; continue 'dispatch;
	}
	pc = 0x829E63D4; continue 'dispatch;
            }
            0x829E63D4 => {
    //   block [0x829E63D4..0x829E63D8)
	// 829E63D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829E63D8; continue 'dispatch;
            }
            0x829E63D8 => {
    //   block [0x829E63D8..0x829E63F4)
	// 829E63D8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E63DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E63E0: 419A0078  beq cr6, 0x829e6458
	if ctx.cr[6].eq {
	pc = 0x829E6458; continue 'dispatch;
	}
	// 829E63E4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E63E8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E63EC: 409A0008  bne cr6, 0x829e63f4
	if !ctx.cr[6].eq {
	pc = 0x829E63F4; continue 'dispatch;
	}
	// 829E63F0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E63F4; continue 'dispatch;
            }
            0x829E63F4 => {
    //   block [0x829E63F4..0x829E6414)
	// 829E63F4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E63F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E63FC: 419A002C  beq cr6, 0x829e6428
	if ctx.cr[6].eq {
	pc = 0x829E6428; continue 'dispatch;
	}
	// 829E6400: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E6404: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E6408: 419A0018  beq cr6, 0x829e6420
	if ctx.cr[6].eq {
	pc = 0x829E6420; continue 'dispatch;
	}
	// 829E640C: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 829E6410: 4800001C  b 0x829e642c
	pc = 0x829E642C; continue 'dispatch;
            }
            0x829E6414 => {
    //   block [0x829E6414..0x829E6420)
	// 829E6414: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E6418: 4B7ADA21  bl 0x82193e38
	ctx.lr = 0x829E641C;
	sub_82193E38(ctx, base);
	// 829E641C: 4BFFFFB8  b 0x829e63d4
	pc = 0x829E63D4; continue 'dispatch;
            }
            0x829E6420 => {
    //   block [0x829E6420..0x829E6428)
	// 829E6420: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E6424: 4B7ADA15  bl 0x82193e38
	ctx.lr = 0x829E6428;
	sub_82193E38(ctx, base);
	pc = 0x829E6428; continue 'dispatch;
            }
            0x829E6428 => {
    //   block [0x829E6428..0x829E642C)
	// 829E6428: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829E642C; continue 'dispatch;
            }
            0x829E642C => {
    //   block [0x829E642C..0x829E6450)
	// 829E642C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829E6430: 4BB298F1  bl 0x8250fd20
	ctx.lr = 0x829E6434;
	sub_8250FD20(ctx, base);
	// 829E6434: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E6438: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E643C: 419A001C  beq cr6, 0x829e6458
	if ctx.cr[6].eq {
	pc = 0x829E6458; continue 'dispatch;
	}
	// 829E6440: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6444: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E6448: 409A0008  bne cr6, 0x829e6450
	if !ctx.cr[6].eq {
	pc = 0x829E6450; continue 'dispatch;
	}
	// 829E644C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6450; continue 'dispatch;
            }
            0x829E6450 => {
    //   block [0x829E6450..0x829E6458)
	// 829E6450: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E6454: 4BFFFF04  b 0x829e6358
	pc = 0x829E6358; continue 'dispatch;
            }
            0x829E6458 => {
    //   block [0x829E6458..0x829E647C)
	// 829E6458: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E645C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829E6460: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E6464: 4B7A480D  bl 0x8218ac70
	ctx.lr = 0x829E6468;
	sub_8218AC70(ctx, base);
	// 829E6468: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 829E646C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829E6470: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E6474: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E6478: 4BFFFEE4  b 0x829e635c
	pc = 0x829E635C; continue 'dispatch;
            }
            0x829E647C => {
    //   block [0x829E647C..0x829E64B8)
	// 829E647C: 897D0025  lbz r11, 0x25(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(37 as u32) ) } as u64;
	// 829E6480: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E6484: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6488: 419A0030  beq cr6, 0x829e64b8
	if ctx.cr[6].eq {
	pc = 0x829E64B8; continue 'dispatch;
	}
	// 829E648C: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E6490: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829E6494: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 829E6498: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 829E649C: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 829E64A0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829E64A4: 480047DD  bl 0x829eac80
	ctx.lr = 0x829E64A8;
	sub_829EAC80(ctx, base);
	// 829E64A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E64AC: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 829E64B0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E64B4: 482C2FA0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x829E64B8 => {
    //   block [0x829E64B8..0x829E64D0)
	// 829E64B8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829E64BC: 80BD0020  lwz r5, 0x20(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E64C0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829E64C4: 480024E5  bl 0x829e89a8
	ctx.lr = 0x829E64C8;
	sub_829E89A8(ctx, base);
	// 829E64C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E64CC: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	pc = 0x829E64D0; continue 'dispatch;
            }
            0x829E64D0 => {
    //   block [0x829E64D0..0x829E64D8)
	// 829E64D0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E64D4: 482C2F80  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E64D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E64D8 size=476
    let mut pc: u32 = 0x829E64D8;
    'dispatch: loop {
        match pc {
            0x829E64D8 => {
    //   block [0x829E64D8..0x829E6508)
	// 829E64D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E64DC: 482C2F29  bl 0x82ca9404
	ctx.lr = 0x829E64E0;
	sub_82CA93D0(ctx, base);
	// 829E64E0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E64E4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E64E8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 829E64EC: 897D0024  lbz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 829E64F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E64F4: 419A0164  beq cr6, 0x829e6658
	if ctx.cr[6].eq {
	pc = 0x829E6658; continue 'dispatch;
	}
	// 829E64F8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E64FC: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E6500: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829E6504: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829E6508; continue 'dispatch;
            }
            0x829E6508 => {
    //   block [0x829E6508..0x829E650C)
	// 829E6508: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	pc = 0x829E650C; continue 'dispatch;
            }
            0x829E650C => {
    //   block [0x829E650C..0x829E6520)
	// 829E650C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6510: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E6514: 419A000C  beq cr6, 0x829e6520
	if ctx.cr[6].eq {
	pc = 0x829E6520; continue 'dispatch;
	}
	// 829E6518: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829E651C: 419A0008  beq cr6, 0x829e6524
	if ctx.cr[6].eq {
	pc = 0x829E6524; continue 'dispatch;
	}
	pc = 0x829E6520; continue 'dispatch;
            }
            0x829E6520 => {
    //   block [0x829E6520..0x829E6524)
	// 829E6520: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6524; continue 'dispatch;
            }
            0x829E6524 => {
    //   block [0x829E6524..0x829E6538)
	// 829E6524: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E6528: 419A0184  beq cr6, 0x829e66ac
	if ctx.cr[6].eq {
	pc = 0x829E66AC; continue 'dispatch;
	}
	// 829E652C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E6530: 409A0008  bne cr6, 0x829e6538
	if !ctx.cr[6].eq {
	pc = 0x829E6538; continue 'dispatch;
	}
	// 829E6534: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6538; continue 'dispatch;
            }
            0x829E6538 => {
    //   block [0x829E6538..0x829E6548)
	// 829E6538: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E653C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E6540: 409A0008  bne cr6, 0x829e6548
	if !ctx.cr[6].eq {
	pc = 0x829E6548; continue 'dispatch;
	}
	// 829E6544: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6548; continue 'dispatch;
            }
            0x829E6548 => {
    //   block [0x829E6548..0x829E6584)
	// 829E6548: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E654C: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 829E6550: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6554: 419A0030  beq cr6, 0x829e6584
	if ctx.cr[6].eq {
	pc = 0x829E6584; continue 'dispatch;
	}
	// 829E6558: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E655C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E6560: 419A0064  beq cr6, 0x829e65c4
	if ctx.cr[6].eq {
	pc = 0x829E65C4; continue 'dispatch;
	}
	// 829E6564: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E6568: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E656C: 419A0018  beq cr6, 0x829e6584
	if ctx.cr[6].eq {
	pc = 0x829E6584; continue 'dispatch;
	}
	// 829E6570: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E6574: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E6578: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E657C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E6580: 409A0008  bne cr6, 0x829e6588
	if !ctx.cr[6].eq {
	pc = 0x829E6588; continue 'dispatch;
	}
	pc = 0x829E6584; continue 'dispatch;
            }
            0x829E6584 => {
    //   block [0x829E6584..0x829E6588)
	// 829E6584: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829E6588; continue 'dispatch;
            }
            0x829E6588 => {
    //   block [0x829E6588..0x829E65A4)
	// 829E6588: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E658C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6590: 419A00A4  beq cr6, 0x829e6634
	if ctx.cr[6].eq {
	pc = 0x829E6634; continue 'dispatch;
	}
	// 829E6594: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6598: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E659C: 409A0008  bne cr6, 0x829e65a4
	if !ctx.cr[6].eq {
	pc = 0x829E65A4; continue 'dispatch;
	}
	// 829E65A0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E65A4; continue 'dispatch;
            }
            0x829E65A4 => {
    //   block [0x829E65A4..0x829E65C4)
	// 829E65A4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E65A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E65AC: 419A002C  beq cr6, 0x829e65d8
	if ctx.cr[6].eq {
	pc = 0x829E65D8; continue 'dispatch;
	}
	// 829E65B0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E65B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E65B8: 419A0018  beq cr6, 0x829e65d0
	if ctx.cr[6].eq {
	pc = 0x829E65D0; continue 'dispatch;
	}
	// 829E65BC: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E65C0: 4800001C  b 0x829e65dc
	pc = 0x829E65DC; continue 'dispatch;
            }
            0x829E65C4 => {
    //   block [0x829E65C4..0x829E65D0)
	// 829E65C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E65C8: 4B7AD871  bl 0x82193e38
	ctx.lr = 0x829E65CC;
	sub_82193E38(ctx, base);
	// 829E65CC: 4BFFFFB8  b 0x829e6584
	pc = 0x829E6584; continue 'dispatch;
            }
            0x829E65D0 => {
    //   block [0x829E65D0..0x829E65D8)
	// 829E65D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E65D4: 4B7AD865  bl 0x82193e38
	ctx.lr = 0x829E65D8;
	sub_82193E38(ctx, base);
	pc = 0x829E65D8; continue 'dispatch;
            }
            0x829E65D8 => {
    //   block [0x829E65D8..0x829E65DC)
	// 829E65D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829E65DC; continue 'dispatch;
            }
            0x829E65DC => {
    //   block [0x829E65DC..0x829E65F4)
	// 829E65DC: 806B0080  lwz r3, 0x80(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 829E65E0: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E65E4: 7F032040  cmplw cr6, r3, r4
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[4].u32, &mut ctx.xer);
	// 829E65E8: 409A000C  bne cr6, 0x829e65f4
	if !ctx.cr[6].eq {
	pc = 0x829E65F4; continue 'dispatch;
	}
	// 829E65EC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829E65F0: 48000020  b 0x829e6610
	pc = 0x829E6610; continue 'dispatch;
            }
            0x829E65F4 => {
    //   block [0x829E65F4..0x829E660C)
	// 829E65F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E65F8: 419A0014  beq cr6, 0x829e660c
	if ctx.cr[6].eq {
	pc = 0x829E660C; continue 'dispatch;
	}
	// 829E65FC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 829E6600: 419A000C  beq cr6, 0x829e660c
	if ctx.cr[6].eq {
	pc = 0x829E660C; continue 'dispatch;
	}
	// 829E6604: 4B88718D  bl 0x8226d790
	ctx.lr = 0x829E6608;
	sub_8226D790(ctx, base);
	// 829E6608: 48000008  b 0x829e6610
	pc = 0x829E6610; continue 'dispatch;
            }
            0x829E660C => {
    //   block [0x829E660C..0x829E6610)
	// 829E660C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x829E6610; continue 'dispatch;
            }
            0x829E6610 => {
    //   block [0x829E6610..0x829E662C)
	// 829E6610: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E6614: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6618: 419A001C  beq cr6, 0x829e6634
	if ctx.cr[6].eq {
	pc = 0x829E6634; continue 'dispatch;
	}
	// 829E661C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6620: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E6624: 409A0008  bne cr6, 0x829e662c
	if !ctx.cr[6].eq {
	pc = 0x829E662C; continue 'dispatch;
	}
	// 829E6628: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E662C; continue 'dispatch;
            }
            0x829E662C => {
    //   block [0x829E662C..0x829E6634)
	// 829E662C: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E6630: 4BFFFED8  b 0x829e6508
	pc = 0x829E6508; continue 'dispatch;
            }
            0x829E6634 => {
    //   block [0x829E6634..0x829E6658)
	// 829E6634: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E6638: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829E663C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E6640: 4B7A4631  bl 0x8218ac70
	ctx.lr = 0x829E6644;
	sub_8218AC70(ctx, base);
	// 829E6644: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 829E6648: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829E664C: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E6650: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E6654: 4BFFFEB8  b 0x829e650c
	pc = 0x829E650C; continue 'dispatch;
            }
            0x829E6658 => {
    //   block [0x829E6658..0x829E6694)
	// 829E6658: 897D0025  lbz r11, 0x25(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(37 as u32) ) } as u64;
	// 829E665C: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E6660: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6664: 419A0030  beq cr6, 0x829e6694
	if ctx.cr[6].eq {
	pc = 0x829E6694; continue 'dispatch;
	}
	// 829E6668: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E666C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829E6670: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 829E6674: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 829E6678: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 829E667C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829E6680: 48004851  bl 0x829eaed0
	ctx.lr = 0x829E6684;
	sub_829EAED0(ctx, base);
	// 829E6684: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E6688: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 829E668C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E6690: 482C2DC4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x829E6694 => {
    //   block [0x829E6694..0x829E66AC)
	// 829E6694: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829E6698: 80BD0020  lwz r5, 0x20(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E669C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829E66A0: 48002481  bl 0x829e8b20
	ctx.lr = 0x829E66A4;
	sub_829E8B20(ctx, base);
	// 829E66A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E66A8: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	pc = 0x829E66AC; continue 'dispatch;
            }
            0x829E66AC => {
    //   block [0x829E66AC..0x829E66B4)
	// 829E66AC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E66B0: 482C2DA4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E66B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E66B8 size=432
    let mut pc: u32 = 0x829E66B8;
    'dispatch: loop {
        match pc {
            0x829E66B8 => {
    //   block [0x829E66B8..0x829E66E8)
	// 829E66B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E66BC: 482C2D49  bl 0x82ca9404
	ctx.lr = 0x829E66C0;
	sub_82CA93D0(ctx, base);
	// 829E66C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E66C4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E66C8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 829E66CC: 897D0024  lbz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 829E66D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E66D4: 419A0138  beq cr6, 0x829e680c
	if ctx.cr[6].eq {
	pc = 0x829E680C; continue 'dispatch;
	}
	// 829E66D8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E66DC: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E66E0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829E66E4: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829E66E8; continue 'dispatch;
            }
            0x829E66E8 => {
    //   block [0x829E66E8..0x829E66EC)
	// 829E66E8: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	pc = 0x829E66EC; continue 'dispatch;
            }
            0x829E66EC => {
    //   block [0x829E66EC..0x829E6700)
	// 829E66EC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E66F0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E66F4: 419A000C  beq cr6, 0x829e6700
	if ctx.cr[6].eq {
	pc = 0x829E6700; continue 'dispatch;
	}
	// 829E66F8: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829E66FC: 419A0008  beq cr6, 0x829e6704
	if ctx.cr[6].eq {
	pc = 0x829E6704; continue 'dispatch;
	}
	pc = 0x829E6700; continue 'dispatch;
            }
            0x829E6700 => {
    //   block [0x829E6700..0x829E6704)
	// 829E6700: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6704; continue 'dispatch;
            }
            0x829E6704 => {
    //   block [0x829E6704..0x829E6718)
	// 829E6704: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E6708: 419A0158  beq cr6, 0x829e6860
	if ctx.cr[6].eq {
	pc = 0x829E6860; continue 'dispatch;
	}
	// 829E670C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E6710: 409A0008  bne cr6, 0x829e6718
	if !ctx.cr[6].eq {
	pc = 0x829E6718; continue 'dispatch;
	}
	// 829E6714: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6718; continue 'dispatch;
            }
            0x829E6718 => {
    //   block [0x829E6718..0x829E6728)
	// 829E6718: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E671C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E6720: 409A0008  bne cr6, 0x829e6728
	if !ctx.cr[6].eq {
	pc = 0x829E6728; continue 'dispatch;
	}
	// 829E6724: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6728; continue 'dispatch;
            }
            0x829E6728 => {
    //   block [0x829E6728..0x829E6764)
	// 829E6728: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E672C: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 829E6730: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6734: 419A0030  beq cr6, 0x829e6764
	if ctx.cr[6].eq {
	pc = 0x829E6764; continue 'dispatch;
	}
	// 829E6738: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E673C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E6740: 419A0064  beq cr6, 0x829e67a4
	if ctx.cr[6].eq {
	pc = 0x829E67A4; continue 'dispatch;
	}
	// 829E6744: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E6748: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E674C: 419A0018  beq cr6, 0x829e6764
	if ctx.cr[6].eq {
	pc = 0x829E6764; continue 'dispatch;
	}
	// 829E6750: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E6754: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E6758: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E675C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E6760: 409A0008  bne cr6, 0x829e6768
	if !ctx.cr[6].eq {
	pc = 0x829E6768; continue 'dispatch;
	}
	pc = 0x829E6764; continue 'dispatch;
            }
            0x829E6764 => {
    //   block [0x829E6764..0x829E6768)
	// 829E6764: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829E6768; continue 'dispatch;
            }
            0x829E6768 => {
    //   block [0x829E6768..0x829E6784)
	// 829E6768: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E676C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6770: 419A0078  beq cr6, 0x829e67e8
	if ctx.cr[6].eq {
	pc = 0x829E67E8; continue 'dispatch;
	}
	// 829E6774: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6778: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E677C: 409A0008  bne cr6, 0x829e6784
	if !ctx.cr[6].eq {
	pc = 0x829E6784; continue 'dispatch;
	}
	// 829E6780: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6784; continue 'dispatch;
            }
            0x829E6784 => {
    //   block [0x829E6784..0x829E67A4)
	// 829E6784: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6788: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E678C: 419A002C  beq cr6, 0x829e67b8
	if ctx.cr[6].eq {
	pc = 0x829E67B8; continue 'dispatch;
	}
	// 829E6790: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E6794: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E6798: 419A0018  beq cr6, 0x829e67b0
	if ctx.cr[6].eq {
	pc = 0x829E67B0; continue 'dispatch;
	}
	// 829E679C: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 829E67A0: 4800001C  b 0x829e67bc
	pc = 0x829E67BC; continue 'dispatch;
            }
            0x829E67A4 => {
    //   block [0x829E67A4..0x829E67B0)
	// 829E67A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E67A8: 4B7AD691  bl 0x82193e38
	ctx.lr = 0x829E67AC;
	sub_82193E38(ctx, base);
	// 829E67AC: 4BFFFFB8  b 0x829e6764
	pc = 0x829E6764; continue 'dispatch;
            }
            0x829E67B0 => {
    //   block [0x829E67B0..0x829E67B8)
	// 829E67B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E67B4: 4B7AD685  bl 0x82193e38
	ctx.lr = 0x829E67B8;
	sub_82193E38(ctx, base);
	pc = 0x829E67B8; continue 'dispatch;
            }
            0x829E67B8 => {
    //   block [0x829E67B8..0x829E67BC)
	// 829E67B8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829E67BC; continue 'dispatch;
            }
            0x829E67BC => {
    //   block [0x829E67BC..0x829E67E0)
	// 829E67BC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829E67C0: 4B818B71  bl 0x821ff330
	ctx.lr = 0x829E67C4;
	sub_821FF330(ctx, base);
	// 829E67C4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E67C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E67CC: 419A001C  beq cr6, 0x829e67e8
	if ctx.cr[6].eq {
	pc = 0x829E67E8; continue 'dispatch;
	}
	// 829E67D0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E67D4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E67D8: 409A0008  bne cr6, 0x829e67e0
	if !ctx.cr[6].eq {
	pc = 0x829E67E0; continue 'dispatch;
	}
	// 829E67DC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E67E0; continue 'dispatch;
            }
            0x829E67E0 => {
    //   block [0x829E67E0..0x829E67E8)
	// 829E67E0: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E67E4: 4BFFFF04  b 0x829e66e8
	pc = 0x829E66E8; continue 'dispatch;
            }
            0x829E67E8 => {
    //   block [0x829E67E8..0x829E680C)
	// 829E67E8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E67EC: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829E67F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E67F4: 4B7A447D  bl 0x8218ac70
	ctx.lr = 0x829E67F8;
	sub_8218AC70(ctx, base);
	// 829E67F8: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 829E67FC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829E6800: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E6804: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E6808: 4BFFFEE4  b 0x829e66ec
	pc = 0x829E66EC; continue 'dispatch;
            }
            0x829E680C => {
    //   block [0x829E680C..0x829E6848)
	// 829E680C: 897D0025  lbz r11, 0x25(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(37 as u32) ) } as u64;
	// 829E6810: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E6814: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6818: 419A0030  beq cr6, 0x829e6848
	if ctx.cr[6].eq {
	pc = 0x829E6848; continue 'dispatch;
	}
	// 829E681C: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E6820: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829E6824: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 829E6828: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 829E682C: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 829E6830: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829E6834: 4800482D  bl 0x829eb060
	ctx.lr = 0x829E6838;
	sub_829EB060(ctx, base);
	// 829E6838: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E683C: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 829E6840: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E6844: 482C2C10  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x829E6848 => {
    //   block [0x829E6848..0x829E6860)
	// 829E6848: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829E684C: 80BD0020  lwz r5, 0x20(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E6850: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829E6854: 4800246D  bl 0x829e8cc0
	ctx.lr = 0x829E6858;
	sub_829E8CC0(ctx, base);
	// 829E6858: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E685C: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	pc = 0x829E6860; continue 'dispatch;
            }
            0x829E6860 => {
    //   block [0x829E6860..0x829E6868)
	// 829E6860: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E6864: 482C2BF0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E6868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E6868 size=432
    let mut pc: u32 = 0x829E6868;
    'dispatch: loop {
        match pc {
            0x829E6868 => {
    //   block [0x829E6868..0x829E6898)
	// 829E6868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E686C: 482C2B99  bl 0x82ca9404
	ctx.lr = 0x829E6870;
	sub_82CA93D0(ctx, base);
	// 829E6870: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E6874: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E6878: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 829E687C: 897D0024  lbz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 829E6880: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6884: 419A0138  beq cr6, 0x829e69bc
	if ctx.cr[6].eq {
	pc = 0x829E69BC; continue 'dispatch;
	}
	// 829E6888: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E688C: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E6890: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829E6894: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829E6898; continue 'dispatch;
            }
            0x829E6898 => {
    //   block [0x829E6898..0x829E689C)
	// 829E6898: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	pc = 0x829E689C; continue 'dispatch;
            }
            0x829E689C => {
    //   block [0x829E689C..0x829E68B0)
	// 829E689C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E68A0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E68A4: 419A000C  beq cr6, 0x829e68b0
	if ctx.cr[6].eq {
	pc = 0x829E68B0; continue 'dispatch;
	}
	// 829E68A8: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829E68AC: 419A0008  beq cr6, 0x829e68b4
	if ctx.cr[6].eq {
	pc = 0x829E68B4; continue 'dispatch;
	}
	pc = 0x829E68B0; continue 'dispatch;
            }
            0x829E68B0 => {
    //   block [0x829E68B0..0x829E68B4)
	// 829E68B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E68B4; continue 'dispatch;
            }
            0x829E68B4 => {
    //   block [0x829E68B4..0x829E68C8)
	// 829E68B4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E68B8: 419A0158  beq cr6, 0x829e6a10
	if ctx.cr[6].eq {
	pc = 0x829E6A10; continue 'dispatch;
	}
	// 829E68BC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E68C0: 409A0008  bne cr6, 0x829e68c8
	if !ctx.cr[6].eq {
	pc = 0x829E68C8; continue 'dispatch;
	}
	// 829E68C4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E68C8; continue 'dispatch;
            }
            0x829E68C8 => {
    //   block [0x829E68C8..0x829E68D8)
	// 829E68C8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E68CC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E68D0: 409A0008  bne cr6, 0x829e68d8
	if !ctx.cr[6].eq {
	pc = 0x829E68D8; continue 'dispatch;
	}
	// 829E68D4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E68D8; continue 'dispatch;
            }
            0x829E68D8 => {
    //   block [0x829E68D8..0x829E6914)
	// 829E68D8: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E68DC: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 829E68E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E68E4: 419A0030  beq cr6, 0x829e6914
	if ctx.cr[6].eq {
	pc = 0x829E6914; continue 'dispatch;
	}
	// 829E68E8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E68EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E68F0: 419A0064  beq cr6, 0x829e6954
	if ctx.cr[6].eq {
	pc = 0x829E6954; continue 'dispatch;
	}
	// 829E68F4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E68F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E68FC: 419A0018  beq cr6, 0x829e6914
	if ctx.cr[6].eq {
	pc = 0x829E6914; continue 'dispatch;
	}
	// 829E6900: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E6904: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E6908: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E690C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E6910: 409A0008  bne cr6, 0x829e6918
	if !ctx.cr[6].eq {
	pc = 0x829E6918; continue 'dispatch;
	}
	pc = 0x829E6914; continue 'dispatch;
            }
            0x829E6914 => {
    //   block [0x829E6914..0x829E6918)
	// 829E6914: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829E6918; continue 'dispatch;
            }
            0x829E6918 => {
    //   block [0x829E6918..0x829E6934)
	// 829E6918: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E691C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6920: 419A0078  beq cr6, 0x829e6998
	if ctx.cr[6].eq {
	pc = 0x829E6998; continue 'dispatch;
	}
	// 829E6924: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6928: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E692C: 409A0008  bne cr6, 0x829e6934
	if !ctx.cr[6].eq {
	pc = 0x829E6934; continue 'dispatch;
	}
	// 829E6930: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6934; continue 'dispatch;
            }
            0x829E6934 => {
    //   block [0x829E6934..0x829E6954)
	// 829E6934: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6938: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E693C: 419A002C  beq cr6, 0x829e6968
	if ctx.cr[6].eq {
	pc = 0x829E6968; continue 'dispatch;
	}
	// 829E6940: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E6944: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E6948: 419A0018  beq cr6, 0x829e6960
	if ctx.cr[6].eq {
	pc = 0x829E6960; continue 'dispatch;
	}
	// 829E694C: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 829E6950: 4800001C  b 0x829e696c
	pc = 0x829E696C; continue 'dispatch;
            }
            0x829E6954 => {
    //   block [0x829E6954..0x829E6960)
	// 829E6954: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E6958: 4B7AD4E1  bl 0x82193e38
	ctx.lr = 0x829E695C;
	sub_82193E38(ctx, base);
	// 829E695C: 4BFFFFB8  b 0x829e6914
	pc = 0x829E6914; continue 'dispatch;
            }
            0x829E6960 => {
    //   block [0x829E6960..0x829E6968)
	// 829E6960: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E6964: 4B7AD4D5  bl 0x82193e38
	ctx.lr = 0x829E6968;
	sub_82193E38(ctx, base);
	pc = 0x829E6968; continue 'dispatch;
            }
            0x829E6968 => {
    //   block [0x829E6968..0x829E696C)
	// 829E6968: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829E696C; continue 'dispatch;
            }
            0x829E696C => {
    //   block [0x829E696C..0x829E6990)
	// 829E696C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829E6970: 4BB29749  bl 0x825100b8
	ctx.lr = 0x829E6974;
	sub_825100B8(ctx, base);
	// 829E6974: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E6978: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E697C: 419A001C  beq cr6, 0x829e6998
	if ctx.cr[6].eq {
	pc = 0x829E6998; continue 'dispatch;
	}
	// 829E6980: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6984: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E6988: 409A0008  bne cr6, 0x829e6990
	if !ctx.cr[6].eq {
	pc = 0x829E6990; continue 'dispatch;
	}
	// 829E698C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6990; continue 'dispatch;
            }
            0x829E6990 => {
    //   block [0x829E6990..0x829E6998)
	// 829E6990: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E6994: 4BFFFF04  b 0x829e6898
	pc = 0x829E6898; continue 'dispatch;
            }
            0x829E6998 => {
    //   block [0x829E6998..0x829E69BC)
	// 829E6998: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E699C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829E69A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E69A4: 4B7A42CD  bl 0x8218ac70
	ctx.lr = 0x829E69A8;
	sub_8218AC70(ctx, base);
	// 829E69A8: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 829E69AC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829E69B0: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E69B4: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E69B8: 4BFFFEE4  b 0x829e689c
	pc = 0x829E689C; continue 'dispatch;
            }
            0x829E69BC => {
    //   block [0x829E69BC..0x829E69F8)
	// 829E69BC: 897D0025  lbz r11, 0x25(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(37 as u32) ) } as u64;
	// 829E69C0: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E69C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E69C8: 419A0030  beq cr6, 0x829e69f8
	if ctx.cr[6].eq {
	pc = 0x829E69F8; continue 'dispatch;
	}
	// 829E69CC: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E69D0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829E69D4: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 829E69D8: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 829E69DC: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 829E69E0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829E69E4: 4800489D  bl 0x829eb280
	ctx.lr = 0x829E69E8;
	sub_829EB280(ctx, base);
	// 829E69E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E69EC: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 829E69F0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E69F4: 482C2A60  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x829E69F8 => {
    //   block [0x829E69F8..0x829E6A10)
	// 829E69F8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829E69FC: 80BD0020  lwz r5, 0x20(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E6A00: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829E6A04: 48002435  bl 0x829e8e38
	ctx.lr = 0x829E6A08;
	sub_829E8E38(ctx, base);
	// 829E6A08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E6A0C: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	pc = 0x829E6A10; continue 'dispatch;
            }
            0x829E6A10 => {
    //   block [0x829E6A10..0x829E6A18)
	// 829E6A10: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E6A14: 482C2A40  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E6A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E6A18 size=432
    let mut pc: u32 = 0x829E6A18;
    'dispatch: loop {
        match pc {
            0x829E6A18 => {
    //   block [0x829E6A18..0x829E6A48)
	// 829E6A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E6A1C: 482C29E9  bl 0x82ca9404
	ctx.lr = 0x829E6A20;
	sub_82CA93D0(ctx, base);
	// 829E6A20: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E6A24: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E6A28: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 829E6A2C: 897D0024  lbz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 829E6A30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6A34: 419A0138  beq cr6, 0x829e6b6c
	if ctx.cr[6].eq {
	pc = 0x829E6B6C; continue 'dispatch;
	}
	// 829E6A38: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6A3C: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E6A40: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829E6A44: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829E6A48; continue 'dispatch;
            }
            0x829E6A48 => {
    //   block [0x829E6A48..0x829E6A4C)
	// 829E6A48: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	pc = 0x829E6A4C; continue 'dispatch;
            }
            0x829E6A4C => {
    //   block [0x829E6A4C..0x829E6A60)
	// 829E6A4C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6A50: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E6A54: 419A000C  beq cr6, 0x829e6a60
	if ctx.cr[6].eq {
	pc = 0x829E6A60; continue 'dispatch;
	}
	// 829E6A58: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829E6A5C: 419A0008  beq cr6, 0x829e6a64
	if ctx.cr[6].eq {
	pc = 0x829E6A64; continue 'dispatch;
	}
	pc = 0x829E6A60; continue 'dispatch;
            }
            0x829E6A60 => {
    //   block [0x829E6A60..0x829E6A64)
	// 829E6A60: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6A64; continue 'dispatch;
            }
            0x829E6A64 => {
    //   block [0x829E6A64..0x829E6A78)
	// 829E6A64: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E6A68: 419A0158  beq cr6, 0x829e6bc0
	if ctx.cr[6].eq {
	pc = 0x829E6BC0; continue 'dispatch;
	}
	// 829E6A6C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E6A70: 409A0008  bne cr6, 0x829e6a78
	if !ctx.cr[6].eq {
	pc = 0x829E6A78; continue 'dispatch;
	}
	// 829E6A74: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6A78; continue 'dispatch;
            }
            0x829E6A78 => {
    //   block [0x829E6A78..0x829E6A88)
	// 829E6A78: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6A7C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E6A80: 409A0008  bne cr6, 0x829e6a88
	if !ctx.cr[6].eq {
	pc = 0x829E6A88; continue 'dispatch;
	}
	// 829E6A84: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6A88; continue 'dispatch;
            }
            0x829E6A88 => {
    //   block [0x829E6A88..0x829E6AC4)
	// 829E6A88: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E6A8C: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 829E6A90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6A94: 419A0030  beq cr6, 0x829e6ac4
	if ctx.cr[6].eq {
	pc = 0x829E6AC4; continue 'dispatch;
	}
	// 829E6A98: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E6A9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E6AA0: 419A0064  beq cr6, 0x829e6b04
	if ctx.cr[6].eq {
	pc = 0x829E6B04; continue 'dispatch;
	}
	// 829E6AA4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E6AA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6AAC: 419A0018  beq cr6, 0x829e6ac4
	if ctx.cr[6].eq {
	pc = 0x829E6AC4; continue 'dispatch;
	}
	// 829E6AB0: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E6AB4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E6AB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E6ABC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E6AC0: 409A0008  bne cr6, 0x829e6ac8
	if !ctx.cr[6].eq {
	pc = 0x829E6AC8; continue 'dispatch;
	}
	pc = 0x829E6AC4; continue 'dispatch;
            }
            0x829E6AC4 => {
    //   block [0x829E6AC4..0x829E6AC8)
	// 829E6AC4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829E6AC8; continue 'dispatch;
            }
            0x829E6AC8 => {
    //   block [0x829E6AC8..0x829E6AE4)
	// 829E6AC8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E6ACC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6AD0: 419A0078  beq cr6, 0x829e6b48
	if ctx.cr[6].eq {
	pc = 0x829E6B48; continue 'dispatch;
	}
	// 829E6AD4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6AD8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E6ADC: 409A0008  bne cr6, 0x829e6ae4
	if !ctx.cr[6].eq {
	pc = 0x829E6AE4; continue 'dispatch;
	}
	// 829E6AE0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6AE4; continue 'dispatch;
            }
            0x829E6AE4 => {
    //   block [0x829E6AE4..0x829E6B04)
	// 829E6AE4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6AE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6AEC: 419A002C  beq cr6, 0x829e6b18
	if ctx.cr[6].eq {
	pc = 0x829E6B18; continue 'dispatch;
	}
	// 829E6AF0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E6AF4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E6AF8: 419A0018  beq cr6, 0x829e6b10
	if ctx.cr[6].eq {
	pc = 0x829E6B10; continue 'dispatch;
	}
	// 829E6AFC: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 829E6B00: 4800001C  b 0x829e6b1c
	pc = 0x829E6B1C; continue 'dispatch;
            }
            0x829E6B04 => {
    //   block [0x829E6B04..0x829E6B10)
	// 829E6B04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E6B08: 4B7AD331  bl 0x82193e38
	ctx.lr = 0x829E6B0C;
	sub_82193E38(ctx, base);
	// 829E6B0C: 4BFFFFB8  b 0x829e6ac4
	pc = 0x829E6AC4; continue 'dispatch;
            }
            0x829E6B10 => {
    //   block [0x829E6B10..0x829E6B18)
	// 829E6B10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E6B14: 4B7AD325  bl 0x82193e38
	ctx.lr = 0x829E6B18;
	sub_82193E38(ctx, base);
	pc = 0x829E6B18; continue 'dispatch;
            }
            0x829E6B18 => {
    //   block [0x829E6B18..0x829E6B1C)
	// 829E6B18: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829E6B1C; continue 'dispatch;
            }
            0x829E6B1C => {
    //   block [0x829E6B1C..0x829E6B40)
	// 829E6B1C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829E6B20: 4BB296B1  bl 0x825101d0
	ctx.lr = 0x829E6B24;
	sub_825101D0(ctx, base);
	// 829E6B24: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E6B28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6B2C: 419A001C  beq cr6, 0x829e6b48
	if ctx.cr[6].eq {
	pc = 0x829E6B48; continue 'dispatch;
	}
	// 829E6B30: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6B34: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E6B38: 409A0008  bne cr6, 0x829e6b40
	if !ctx.cr[6].eq {
	pc = 0x829E6B40; continue 'dispatch;
	}
	// 829E6B3C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6B40; continue 'dispatch;
            }
            0x829E6B40 => {
    //   block [0x829E6B40..0x829E6B48)
	// 829E6B40: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E6B44: 4BFFFF04  b 0x829e6a48
	pc = 0x829E6A48; continue 'dispatch;
            }
            0x829E6B48 => {
    //   block [0x829E6B48..0x829E6B6C)
	// 829E6B48: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E6B4C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829E6B50: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E6B54: 4B7A411D  bl 0x8218ac70
	ctx.lr = 0x829E6B58;
	sub_8218AC70(ctx, base);
	// 829E6B58: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 829E6B5C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829E6B60: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E6B64: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E6B68: 4BFFFEE4  b 0x829e6a4c
	pc = 0x829E6A4C; continue 'dispatch;
            }
            0x829E6B6C => {
    //   block [0x829E6B6C..0x829E6BA8)
	// 829E6B6C: 897D0025  lbz r11, 0x25(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(37 as u32) ) } as u64;
	// 829E6B70: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E6B74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6B78: 419A0030  beq cr6, 0x829e6ba8
	if ctx.cr[6].eq {
	pc = 0x829E6BA8; continue 'dispatch;
	}
	// 829E6B7C: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E6B80: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829E6B84: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 829E6B88: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 829E6B8C: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 829E6B90: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829E6B94: 48004905  bl 0x829eb498
	ctx.lr = 0x829E6B98;
	sub_829EB498(ctx, base);
	// 829E6B98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E6B9C: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 829E6BA0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E6BA4: 482C28B0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x829E6BA8 => {
    //   block [0x829E6BA8..0x829E6BC0)
	// 829E6BA8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829E6BAC: 80BD0020  lwz r5, 0x20(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E6BB0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829E6BB4: 480023F5  bl 0x829e8fa8
	ctx.lr = 0x829E6BB8;
	sub_829E8FA8(ctx, base);
	// 829E6BB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E6BBC: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	pc = 0x829E6BC0; continue 'dispatch;
            }
            0x829E6BC0 => {
    //   block [0x829E6BC0..0x829E6BC8)
	// 829E6BC0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E6BC4: 482C2890  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E6BC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E6BC8 size=432
    let mut pc: u32 = 0x829E6BC8;
    'dispatch: loop {
        match pc {
            0x829E6BC8 => {
    //   block [0x829E6BC8..0x829E6BF8)
	// 829E6BC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E6BCC: 482C2839  bl 0x82ca9404
	ctx.lr = 0x829E6BD0;
	sub_82CA93D0(ctx, base);
	// 829E6BD0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E6BD4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E6BD8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 829E6BDC: 897D0024  lbz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 829E6BE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6BE4: 419A0138  beq cr6, 0x829e6d1c
	if ctx.cr[6].eq {
	pc = 0x829E6D1C; continue 'dispatch;
	}
	// 829E6BE8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6BEC: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E6BF0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829E6BF4: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829E6BF8; continue 'dispatch;
            }
            0x829E6BF8 => {
    //   block [0x829E6BF8..0x829E6BFC)
	// 829E6BF8: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	pc = 0x829E6BFC; continue 'dispatch;
            }
            0x829E6BFC => {
    //   block [0x829E6BFC..0x829E6C10)
	// 829E6BFC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6C00: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E6C04: 419A000C  beq cr6, 0x829e6c10
	if ctx.cr[6].eq {
	pc = 0x829E6C10; continue 'dispatch;
	}
	// 829E6C08: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829E6C0C: 419A0008  beq cr6, 0x829e6c14
	if ctx.cr[6].eq {
	pc = 0x829E6C14; continue 'dispatch;
	}
	pc = 0x829E6C10; continue 'dispatch;
            }
            0x829E6C10 => {
    //   block [0x829E6C10..0x829E6C14)
	// 829E6C10: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6C14; continue 'dispatch;
            }
            0x829E6C14 => {
    //   block [0x829E6C14..0x829E6C28)
	// 829E6C14: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E6C18: 419A0158  beq cr6, 0x829e6d70
	if ctx.cr[6].eq {
	pc = 0x829E6D70; continue 'dispatch;
	}
	// 829E6C1C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E6C20: 409A0008  bne cr6, 0x829e6c28
	if !ctx.cr[6].eq {
	pc = 0x829E6C28; continue 'dispatch;
	}
	// 829E6C24: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6C28; continue 'dispatch;
            }
            0x829E6C28 => {
    //   block [0x829E6C28..0x829E6C38)
	// 829E6C28: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6C2C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E6C30: 409A0008  bne cr6, 0x829e6c38
	if !ctx.cr[6].eq {
	pc = 0x829E6C38; continue 'dispatch;
	}
	// 829E6C34: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6C38; continue 'dispatch;
            }
            0x829E6C38 => {
    //   block [0x829E6C38..0x829E6C74)
	// 829E6C38: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E6C3C: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 829E6C40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6C44: 419A0030  beq cr6, 0x829e6c74
	if ctx.cr[6].eq {
	pc = 0x829E6C74; continue 'dispatch;
	}
	// 829E6C48: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E6C4C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E6C50: 419A0064  beq cr6, 0x829e6cb4
	if ctx.cr[6].eq {
	pc = 0x829E6CB4; continue 'dispatch;
	}
	// 829E6C54: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E6C58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6C5C: 419A0018  beq cr6, 0x829e6c74
	if ctx.cr[6].eq {
	pc = 0x829E6C74; continue 'dispatch;
	}
	// 829E6C60: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E6C64: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E6C68: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E6C6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E6C70: 409A0008  bne cr6, 0x829e6c78
	if !ctx.cr[6].eq {
	pc = 0x829E6C78; continue 'dispatch;
	}
	pc = 0x829E6C74; continue 'dispatch;
            }
            0x829E6C74 => {
    //   block [0x829E6C74..0x829E6C78)
	// 829E6C74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829E6C78; continue 'dispatch;
            }
            0x829E6C78 => {
    //   block [0x829E6C78..0x829E6C94)
	// 829E6C78: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E6C7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6C80: 419A0078  beq cr6, 0x829e6cf8
	if ctx.cr[6].eq {
	pc = 0x829E6CF8; continue 'dispatch;
	}
	// 829E6C84: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6C88: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E6C8C: 409A0008  bne cr6, 0x829e6c94
	if !ctx.cr[6].eq {
	pc = 0x829E6C94; continue 'dispatch;
	}
	// 829E6C90: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6C94; continue 'dispatch;
            }
            0x829E6C94 => {
    //   block [0x829E6C94..0x829E6CB4)
	// 829E6C94: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6C98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6C9C: 419A002C  beq cr6, 0x829e6cc8
	if ctx.cr[6].eq {
	pc = 0x829E6CC8; continue 'dispatch;
	}
	// 829E6CA0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E6CA4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E6CA8: 419A0018  beq cr6, 0x829e6cc0
	if ctx.cr[6].eq {
	pc = 0x829E6CC0; continue 'dispatch;
	}
	// 829E6CAC: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 829E6CB0: 4800001C  b 0x829e6ccc
	pc = 0x829E6CCC; continue 'dispatch;
            }
            0x829E6CB4 => {
    //   block [0x829E6CB4..0x829E6CC0)
	// 829E6CB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E6CB8: 4B7AD181  bl 0x82193e38
	ctx.lr = 0x829E6CBC;
	sub_82193E38(ctx, base);
	// 829E6CBC: 4BFFFFB8  b 0x829e6c74
	pc = 0x829E6C74; continue 'dispatch;
            }
            0x829E6CC0 => {
    //   block [0x829E6CC0..0x829E6CC8)
	// 829E6CC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E6CC4: 4B7AD175  bl 0x82193e38
	ctx.lr = 0x829E6CC8;
	sub_82193E38(ctx, base);
	pc = 0x829E6CC8; continue 'dispatch;
            }
            0x829E6CC8 => {
    //   block [0x829E6CC8..0x829E6CCC)
	// 829E6CC8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829E6CCC; continue 'dispatch;
            }
            0x829E6CCC => {
    //   block [0x829E6CCC..0x829E6CF0)
	// 829E6CCC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829E6CD0: 4BB29629  bl 0x825102f8
	ctx.lr = 0x829E6CD4;
	sub_825102F8(ctx, base);
	// 829E6CD4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E6CD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6CDC: 419A001C  beq cr6, 0x829e6cf8
	if ctx.cr[6].eq {
	pc = 0x829E6CF8; continue 'dispatch;
	}
	// 829E6CE0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6CE4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E6CE8: 409A0008  bne cr6, 0x829e6cf0
	if !ctx.cr[6].eq {
	pc = 0x829E6CF0; continue 'dispatch;
	}
	// 829E6CEC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6CF0; continue 'dispatch;
            }
            0x829E6CF0 => {
    //   block [0x829E6CF0..0x829E6CF8)
	// 829E6CF0: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E6CF4: 4BFFFF04  b 0x829e6bf8
	pc = 0x829E6BF8; continue 'dispatch;
            }
            0x829E6CF8 => {
    //   block [0x829E6CF8..0x829E6D1C)
	// 829E6CF8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E6CFC: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829E6D00: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E6D04: 4B7A3F6D  bl 0x8218ac70
	ctx.lr = 0x829E6D08;
	sub_8218AC70(ctx, base);
	// 829E6D08: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 829E6D0C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829E6D10: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E6D14: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E6D18: 4BFFFEE4  b 0x829e6bfc
	pc = 0x829E6BFC; continue 'dispatch;
            }
            0x829E6D1C => {
    //   block [0x829E6D1C..0x829E6D58)
	// 829E6D1C: 897D0025  lbz r11, 0x25(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(37 as u32) ) } as u64;
	// 829E6D20: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E6D24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6D28: 419A0030  beq cr6, 0x829e6d58
	if ctx.cr[6].eq {
	pc = 0x829E6D58; continue 'dispatch;
	}
	// 829E6D2C: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E6D30: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829E6D34: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 829E6D38: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 829E6D3C: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 829E6D40: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829E6D44: 4800496D  bl 0x829eb6b0
	ctx.lr = 0x829E6D48;
	sub_829EB6B0(ctx, base);
	// 829E6D48: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E6D4C: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 829E6D50: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E6D54: 482C2700  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x829E6D58 => {
    //   block [0x829E6D58..0x829E6D70)
	// 829E6D58: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829E6D5C: 80BD0020  lwz r5, 0x20(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E6D60: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829E6D64: 480023B5  bl 0x829e9118
	ctx.lr = 0x829E6D68;
	sub_829E9118(ctx, base);
	// 829E6D68: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E6D6C: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	pc = 0x829E6D70; continue 'dispatch;
            }
            0x829E6D70 => {
    //   block [0x829E6D70..0x829E6D78)
	// 829E6D70: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E6D74: 482C26E0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E6D78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E6D78 size=432
    let mut pc: u32 = 0x829E6D78;
    'dispatch: loop {
        match pc {
            0x829E6D78 => {
    //   block [0x829E6D78..0x829E6DA8)
	// 829E6D78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E6D7C: 482C2689  bl 0x82ca9404
	ctx.lr = 0x829E6D80;
	sub_82CA93D0(ctx, base);
	// 829E6D80: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E6D84: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E6D88: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 829E6D8C: 897D0024  lbz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 829E6D90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6D94: 419A0138  beq cr6, 0x829e6ecc
	if ctx.cr[6].eq {
	pc = 0x829E6ECC; continue 'dispatch;
	}
	// 829E6D98: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6D9C: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E6DA0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829E6DA4: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829E6DA8; continue 'dispatch;
            }
            0x829E6DA8 => {
    //   block [0x829E6DA8..0x829E6DAC)
	// 829E6DA8: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	pc = 0x829E6DAC; continue 'dispatch;
            }
            0x829E6DAC => {
    //   block [0x829E6DAC..0x829E6DC0)
	// 829E6DAC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6DB0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E6DB4: 419A000C  beq cr6, 0x829e6dc0
	if ctx.cr[6].eq {
	pc = 0x829E6DC0; continue 'dispatch;
	}
	// 829E6DB8: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829E6DBC: 419A0008  beq cr6, 0x829e6dc4
	if ctx.cr[6].eq {
	pc = 0x829E6DC4; continue 'dispatch;
	}
	pc = 0x829E6DC0; continue 'dispatch;
            }
            0x829E6DC0 => {
    //   block [0x829E6DC0..0x829E6DC4)
	// 829E6DC0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6DC4; continue 'dispatch;
            }
            0x829E6DC4 => {
    //   block [0x829E6DC4..0x829E6DD8)
	// 829E6DC4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E6DC8: 419A0158  beq cr6, 0x829e6f20
	if ctx.cr[6].eq {
	pc = 0x829E6F20; continue 'dispatch;
	}
	// 829E6DCC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E6DD0: 409A0008  bne cr6, 0x829e6dd8
	if !ctx.cr[6].eq {
	pc = 0x829E6DD8; continue 'dispatch;
	}
	// 829E6DD4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6DD8; continue 'dispatch;
            }
            0x829E6DD8 => {
    //   block [0x829E6DD8..0x829E6DE8)
	// 829E6DD8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6DDC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E6DE0: 409A0008  bne cr6, 0x829e6de8
	if !ctx.cr[6].eq {
	pc = 0x829E6DE8; continue 'dispatch;
	}
	// 829E6DE4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6DE8; continue 'dispatch;
            }
            0x829E6DE8 => {
    //   block [0x829E6DE8..0x829E6E24)
	// 829E6DE8: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E6DEC: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 829E6DF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6DF4: 419A0030  beq cr6, 0x829e6e24
	if ctx.cr[6].eq {
	pc = 0x829E6E24; continue 'dispatch;
	}
	// 829E6DF8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E6DFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E6E00: 419A0064  beq cr6, 0x829e6e64
	if ctx.cr[6].eq {
	pc = 0x829E6E64; continue 'dispatch;
	}
	// 829E6E04: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E6E08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6E0C: 419A0018  beq cr6, 0x829e6e24
	if ctx.cr[6].eq {
	pc = 0x829E6E24; continue 'dispatch;
	}
	// 829E6E10: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E6E14: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E6E18: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E6E1C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E6E20: 409A0008  bne cr6, 0x829e6e28
	if !ctx.cr[6].eq {
	pc = 0x829E6E28; continue 'dispatch;
	}
	pc = 0x829E6E24; continue 'dispatch;
            }
            0x829E6E24 => {
    //   block [0x829E6E24..0x829E6E28)
	// 829E6E24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829E6E28; continue 'dispatch;
            }
            0x829E6E28 => {
    //   block [0x829E6E28..0x829E6E44)
	// 829E6E28: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E6E2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6E30: 419A0078  beq cr6, 0x829e6ea8
	if ctx.cr[6].eq {
	pc = 0x829E6EA8; continue 'dispatch;
	}
	// 829E6E34: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6E38: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E6E3C: 409A0008  bne cr6, 0x829e6e44
	if !ctx.cr[6].eq {
	pc = 0x829E6E44; continue 'dispatch;
	}
	// 829E6E40: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6E44; continue 'dispatch;
            }
            0x829E6E44 => {
    //   block [0x829E6E44..0x829E6E64)
	// 829E6E44: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6E48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6E4C: 419A002C  beq cr6, 0x829e6e78
	if ctx.cr[6].eq {
	pc = 0x829E6E78; continue 'dispatch;
	}
	// 829E6E50: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E6E54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E6E58: 419A0018  beq cr6, 0x829e6e70
	if ctx.cr[6].eq {
	pc = 0x829E6E70; continue 'dispatch;
	}
	// 829E6E5C: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 829E6E60: 4800001C  b 0x829e6e7c
	pc = 0x829E6E7C; continue 'dispatch;
            }
            0x829E6E64 => {
    //   block [0x829E6E64..0x829E6E70)
	// 829E6E64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E6E68: 4B7ACFD1  bl 0x82193e38
	ctx.lr = 0x829E6E6C;
	sub_82193E38(ctx, base);
	// 829E6E6C: 4BFFFFB8  b 0x829e6e24
	pc = 0x829E6E24; continue 'dispatch;
            }
            0x829E6E70 => {
    //   block [0x829E6E70..0x829E6E78)
	// 829E6E70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E6E74: 4B7ACFC5  bl 0x82193e38
	ctx.lr = 0x829E6E78;
	sub_82193E38(ctx, base);
	pc = 0x829E6E78; continue 'dispatch;
            }
            0x829E6E78 => {
    //   block [0x829E6E78..0x829E6E7C)
	// 829E6E78: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829E6E7C; continue 'dispatch;
            }
            0x829E6E7C => {
    //   block [0x829E6E7C..0x829E6EA0)
	// 829E6E7C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829E6E80: 4BB28F09  bl 0x8250fd88
	ctx.lr = 0x829E6E84;
	sub_8250FD88(ctx, base);
	// 829E6E84: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E6E88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6E8C: 419A001C  beq cr6, 0x829e6ea8
	if ctx.cr[6].eq {
	pc = 0x829E6EA8; continue 'dispatch;
	}
	// 829E6E90: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6E94: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E6E98: 409A0008  bne cr6, 0x829e6ea0
	if !ctx.cr[6].eq {
	pc = 0x829E6EA0; continue 'dispatch;
	}
	// 829E6E9C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6EA0; continue 'dispatch;
            }
            0x829E6EA0 => {
    //   block [0x829E6EA0..0x829E6EA8)
	// 829E6EA0: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E6EA4: 4BFFFF04  b 0x829e6da8
	pc = 0x829E6DA8; continue 'dispatch;
            }
            0x829E6EA8 => {
    //   block [0x829E6EA8..0x829E6ECC)
	// 829E6EA8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E6EAC: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829E6EB0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E6EB4: 4B7A3DBD  bl 0x8218ac70
	ctx.lr = 0x829E6EB8;
	sub_8218AC70(ctx, base);
	// 829E6EB8: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 829E6EBC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829E6EC0: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E6EC4: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E6EC8: 4BFFFEE4  b 0x829e6dac
	pc = 0x829E6DAC; continue 'dispatch;
            }
            0x829E6ECC => {
    //   block [0x829E6ECC..0x829E6F08)
	// 829E6ECC: 897D0025  lbz r11, 0x25(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(37 as u32) ) } as u64;
	// 829E6ED0: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E6ED4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6ED8: 419A0030  beq cr6, 0x829e6f08
	if ctx.cr[6].eq {
	pc = 0x829E6F08; continue 'dispatch;
	}
	// 829E6EDC: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E6EE0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829E6EE4: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 829E6EE8: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 829E6EEC: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 829E6EF0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829E6EF4: 480049D5  bl 0x829eb8c8
	ctx.lr = 0x829E6EF8;
	sub_829EB8C8(ctx, base);
	// 829E6EF8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E6EFC: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 829E6F00: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E6F04: 482C2550  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x829E6F08 => {
    //   block [0x829E6F08..0x829E6F20)
	// 829E6F08: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829E6F0C: 80BD0020  lwz r5, 0x20(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E6F10: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829E6F14: 48002375  bl 0x829e9288
	ctx.lr = 0x829E6F18;
	sub_829E9288(ctx, base);
	// 829E6F18: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E6F1C: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	pc = 0x829E6F20; continue 'dispatch;
            }
            0x829E6F20 => {
    //   block [0x829E6F20..0x829E6F28)
	// 829E6F20: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E6F24: 482C2530  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E6F28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E6F28 size=432
    let mut pc: u32 = 0x829E6F28;
    'dispatch: loop {
        match pc {
            0x829E6F28 => {
    //   block [0x829E6F28..0x829E6F58)
	// 829E6F28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E6F2C: 482C24D9  bl 0x82ca9404
	ctx.lr = 0x829E6F30;
	sub_82CA93D0(ctx, base);
	// 829E6F30: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E6F34: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E6F38: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 829E6F3C: 897D0024  lbz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 829E6F40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6F44: 419A0138  beq cr6, 0x829e707c
	if ctx.cr[6].eq {
	pc = 0x829E707C; continue 'dispatch;
	}
	// 829E6F48: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6F4C: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E6F50: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829E6F54: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829E6F58; continue 'dispatch;
            }
            0x829E6F58 => {
    //   block [0x829E6F58..0x829E6F5C)
	// 829E6F58: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	pc = 0x829E6F5C; continue 'dispatch;
            }
            0x829E6F5C => {
    //   block [0x829E6F5C..0x829E6F70)
	// 829E6F5C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6F60: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E6F64: 419A000C  beq cr6, 0x829e6f70
	if ctx.cr[6].eq {
	pc = 0x829E6F70; continue 'dispatch;
	}
	// 829E6F68: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829E6F6C: 419A0008  beq cr6, 0x829e6f74
	if ctx.cr[6].eq {
	pc = 0x829E6F74; continue 'dispatch;
	}
	pc = 0x829E6F70; continue 'dispatch;
            }
            0x829E6F70 => {
    //   block [0x829E6F70..0x829E6F74)
	// 829E6F70: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6F74; continue 'dispatch;
            }
            0x829E6F74 => {
    //   block [0x829E6F74..0x829E6F88)
	// 829E6F74: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E6F78: 419A0158  beq cr6, 0x829e70d0
	if ctx.cr[6].eq {
	pc = 0x829E70D0; continue 'dispatch;
	}
	// 829E6F7C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E6F80: 409A0008  bne cr6, 0x829e6f88
	if !ctx.cr[6].eq {
	pc = 0x829E6F88; continue 'dispatch;
	}
	// 829E6F84: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6F88; continue 'dispatch;
            }
            0x829E6F88 => {
    //   block [0x829E6F88..0x829E6F98)
	// 829E6F88: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6F8C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E6F90: 409A0008  bne cr6, 0x829e6f98
	if !ctx.cr[6].eq {
	pc = 0x829E6F98; continue 'dispatch;
	}
	// 829E6F94: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6F98; continue 'dispatch;
            }
            0x829E6F98 => {
    //   block [0x829E6F98..0x829E6FD4)
	// 829E6F98: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E6F9C: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 829E6FA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6FA4: 419A0030  beq cr6, 0x829e6fd4
	if ctx.cr[6].eq {
	pc = 0x829E6FD4; continue 'dispatch;
	}
	// 829E6FA8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E6FAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E6FB0: 419A0064  beq cr6, 0x829e7014
	if ctx.cr[6].eq {
	pc = 0x829E7014; continue 'dispatch;
	}
	// 829E6FB4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E6FB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6FBC: 419A0018  beq cr6, 0x829e6fd4
	if ctx.cr[6].eq {
	pc = 0x829E6FD4; continue 'dispatch;
	}
	// 829E6FC0: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E6FC4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E6FC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E6FCC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E6FD0: 409A0008  bne cr6, 0x829e6fd8
	if !ctx.cr[6].eq {
	pc = 0x829E6FD8; continue 'dispatch;
	}
	pc = 0x829E6FD4; continue 'dispatch;
            }
            0x829E6FD4 => {
    //   block [0x829E6FD4..0x829E6FD8)
	// 829E6FD4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829E6FD8; continue 'dispatch;
            }
            0x829E6FD8 => {
    //   block [0x829E6FD8..0x829E6FF4)
	// 829E6FD8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E6FDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6FE0: 419A0078  beq cr6, 0x829e7058
	if ctx.cr[6].eq {
	pc = 0x829E7058; continue 'dispatch;
	}
	// 829E6FE4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6FE8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E6FEC: 409A0008  bne cr6, 0x829e6ff4
	if !ctx.cr[6].eq {
	pc = 0x829E6FF4; continue 'dispatch;
	}
	// 829E6FF0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E6FF4; continue 'dispatch;
            }
            0x829E6FF4 => {
    //   block [0x829E6FF4..0x829E7014)
	// 829E6FF4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6FF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E6FFC: 419A002C  beq cr6, 0x829e7028
	if ctx.cr[6].eq {
	pc = 0x829E7028; continue 'dispatch;
	}
	// 829E7000: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E7004: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E7008: 419A0018  beq cr6, 0x829e7020
	if ctx.cr[6].eq {
	pc = 0x829E7020; continue 'dispatch;
	}
	// 829E700C: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 829E7010: 4800001C  b 0x829e702c
	pc = 0x829E702C; continue 'dispatch;
            }
            0x829E7014 => {
    //   block [0x829E7014..0x829E7020)
	// 829E7014: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E7018: 4B7ACE21  bl 0x82193e38
	ctx.lr = 0x829E701C;
	sub_82193E38(ctx, base);
	// 829E701C: 4BFFFFB8  b 0x829e6fd4
	pc = 0x829E6FD4; continue 'dispatch;
            }
            0x829E7020 => {
    //   block [0x829E7020..0x829E7028)
	// 829E7020: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E7024: 4B7ACE15  bl 0x82193e38
	ctx.lr = 0x829E7028;
	sub_82193E38(ctx, base);
	pc = 0x829E7028; continue 'dispatch;
            }
            0x829E7028 => {
    //   block [0x829E7028..0x829E702C)
	// 829E7028: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829E702C; continue 'dispatch;
            }
            0x829E702C => {
    //   block [0x829E702C..0x829E7050)
	// 829E702C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829E7030: 4BB28E81  bl 0x8250feb0
	ctx.lr = 0x829E7034;
	sub_8250FEB0(ctx, base);
	// 829E7034: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E7038: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E703C: 419A001C  beq cr6, 0x829e7058
	if ctx.cr[6].eq {
	pc = 0x829E7058; continue 'dispatch;
	}
	// 829E7040: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7044: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E7048: 409A0008  bne cr6, 0x829e7050
	if !ctx.cr[6].eq {
	pc = 0x829E7050; continue 'dispatch;
	}
	// 829E704C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7050; continue 'dispatch;
            }
            0x829E7050 => {
    //   block [0x829E7050..0x829E7058)
	// 829E7050: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E7054: 4BFFFF04  b 0x829e6f58
	pc = 0x829E6F58; continue 'dispatch;
            }
            0x829E7058 => {
    //   block [0x829E7058..0x829E707C)
	// 829E7058: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E705C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829E7060: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E7064: 4B7A3C0D  bl 0x8218ac70
	ctx.lr = 0x829E7068;
	sub_8218AC70(ctx, base);
	// 829E7068: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 829E706C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829E7070: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E7074: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E7078: 4BFFFEE4  b 0x829e6f5c
	pc = 0x829E6F5C; continue 'dispatch;
            }
            0x829E707C => {
    //   block [0x829E707C..0x829E70B8)
	// 829E707C: 897D0025  lbz r11, 0x25(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(37 as u32) ) } as u64;
	// 829E7080: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E7084: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7088: 419A0030  beq cr6, 0x829e70b8
	if ctx.cr[6].eq {
	pc = 0x829E70B8; continue 'dispatch;
	}
	// 829E708C: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E7090: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829E7094: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 829E7098: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 829E709C: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 829E70A0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829E70A4: 48004A3D  bl 0x829ebae0
	ctx.lr = 0x829E70A8;
	sub_829EBAE0(ctx, base);
	// 829E70A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E70AC: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 829E70B0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E70B4: 482C23A0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x829E70B8 => {
    //   block [0x829E70B8..0x829E70D0)
	// 829E70B8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829E70BC: 80BD0020  lwz r5, 0x20(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E70C0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829E70C4: 48002335  bl 0x829e93f8
	ctx.lr = 0x829E70C8;
	sub_829E93F8(ctx, base);
	// 829E70C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E70CC: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	pc = 0x829E70D0; continue 'dispatch;
            }
            0x829E70D0 => {
    //   block [0x829E70D0..0x829E70D8)
	// 829E70D0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E70D4: 482C2380  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E70D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E70D8 size=432
    let mut pc: u32 = 0x829E70D8;
    'dispatch: loop {
        match pc {
            0x829E70D8 => {
    //   block [0x829E70D8..0x829E7108)
	// 829E70D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E70DC: 482C2329  bl 0x82ca9404
	ctx.lr = 0x829E70E0;
	sub_82CA93D0(ctx, base);
	// 829E70E0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E70E4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E70E8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 829E70EC: 897D0024  lbz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 829E70F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E70F4: 419A0138  beq cr6, 0x829e722c
	if ctx.cr[6].eq {
	pc = 0x829E722C; continue 'dispatch;
	}
	// 829E70F8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E70FC: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E7100: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829E7104: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829E7108; continue 'dispatch;
            }
            0x829E7108 => {
    //   block [0x829E7108..0x829E710C)
	// 829E7108: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	pc = 0x829E710C; continue 'dispatch;
            }
            0x829E710C => {
    //   block [0x829E710C..0x829E7120)
	// 829E710C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7110: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E7114: 419A000C  beq cr6, 0x829e7120
	if ctx.cr[6].eq {
	pc = 0x829E7120; continue 'dispatch;
	}
	// 829E7118: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829E711C: 419A0008  beq cr6, 0x829e7124
	if ctx.cr[6].eq {
	pc = 0x829E7124; continue 'dispatch;
	}
	pc = 0x829E7120; continue 'dispatch;
            }
            0x829E7120 => {
    //   block [0x829E7120..0x829E7124)
	// 829E7120: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7124; continue 'dispatch;
            }
            0x829E7124 => {
    //   block [0x829E7124..0x829E7138)
	// 829E7124: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E7128: 419A0158  beq cr6, 0x829e7280
	if ctx.cr[6].eq {
	pc = 0x829E7280; continue 'dispatch;
	}
	// 829E712C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E7130: 409A0008  bne cr6, 0x829e7138
	if !ctx.cr[6].eq {
	pc = 0x829E7138; continue 'dispatch;
	}
	// 829E7134: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7138; continue 'dispatch;
            }
            0x829E7138 => {
    //   block [0x829E7138..0x829E7148)
	// 829E7138: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E713C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E7140: 409A0008  bne cr6, 0x829e7148
	if !ctx.cr[6].eq {
	pc = 0x829E7148; continue 'dispatch;
	}
	// 829E7144: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7148; continue 'dispatch;
            }
            0x829E7148 => {
    //   block [0x829E7148..0x829E7184)
	// 829E7148: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E714C: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 829E7150: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7154: 419A0030  beq cr6, 0x829e7184
	if ctx.cr[6].eq {
	pc = 0x829E7184; continue 'dispatch;
	}
	// 829E7158: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E715C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E7160: 419A0064  beq cr6, 0x829e71c4
	if ctx.cr[6].eq {
	pc = 0x829E71C4; continue 'dispatch;
	}
	// 829E7164: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E7168: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E716C: 419A0018  beq cr6, 0x829e7184
	if ctx.cr[6].eq {
	pc = 0x829E7184; continue 'dispatch;
	}
	// 829E7170: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E7174: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E7178: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E717C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E7180: 409A0008  bne cr6, 0x829e7188
	if !ctx.cr[6].eq {
	pc = 0x829E7188; continue 'dispatch;
	}
	pc = 0x829E7184; continue 'dispatch;
            }
            0x829E7184 => {
    //   block [0x829E7184..0x829E7188)
	// 829E7184: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829E7188; continue 'dispatch;
            }
            0x829E7188 => {
    //   block [0x829E7188..0x829E71A4)
	// 829E7188: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E718C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7190: 419A0078  beq cr6, 0x829e7208
	if ctx.cr[6].eq {
	pc = 0x829E7208; continue 'dispatch;
	}
	// 829E7194: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7198: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E719C: 409A0008  bne cr6, 0x829e71a4
	if !ctx.cr[6].eq {
	pc = 0x829E71A4; continue 'dispatch;
	}
	// 829E71A0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E71A4; continue 'dispatch;
            }
            0x829E71A4 => {
    //   block [0x829E71A4..0x829E71C4)
	// 829E71A4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E71A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E71AC: 419A002C  beq cr6, 0x829e71d8
	if ctx.cr[6].eq {
	pc = 0x829E71D8; continue 'dispatch;
	}
	// 829E71B0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E71B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E71B8: 419A0018  beq cr6, 0x829e71d0
	if ctx.cr[6].eq {
	pc = 0x829E71D0; continue 'dispatch;
	}
	// 829E71BC: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 829E71C0: 4800001C  b 0x829e71dc
	pc = 0x829E71DC; continue 'dispatch;
            }
            0x829E71C4 => {
    //   block [0x829E71C4..0x829E71D0)
	// 829E71C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E71C8: 4B7ACC71  bl 0x82193e38
	ctx.lr = 0x829E71CC;
	sub_82193E38(ctx, base);
	// 829E71CC: 4BFFFFB8  b 0x829e7184
	pc = 0x829E7184; continue 'dispatch;
            }
            0x829E71D0 => {
    //   block [0x829E71D0..0x829E71D8)
	// 829E71D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E71D4: 4B7ACC65  bl 0x82193e38
	ctx.lr = 0x829E71D8;
	sub_82193E38(ctx, base);
	pc = 0x829E71D8; continue 'dispatch;
            }
            0x829E71D8 => {
    //   block [0x829E71D8..0x829E71DC)
	// 829E71D8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829E71DC; continue 'dispatch;
            }
            0x829E71DC => {
    //   block [0x829E71DC..0x829E7200)
	// 829E71DC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829E71E0: 4BB2A3B9  bl 0x82511598
	ctx.lr = 0x829E71E4;
	sub_82511598(ctx, base);
	// 829E71E4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E71E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E71EC: 419A001C  beq cr6, 0x829e7208
	if ctx.cr[6].eq {
	pc = 0x829E7208; continue 'dispatch;
	}
	// 829E71F0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E71F4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E71F8: 409A0008  bne cr6, 0x829e7200
	if !ctx.cr[6].eq {
	pc = 0x829E7200; continue 'dispatch;
	}
	// 829E71FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7200; continue 'dispatch;
            }
            0x829E7200 => {
    //   block [0x829E7200..0x829E7208)
	// 829E7200: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E7204: 4BFFFF04  b 0x829e7108
	pc = 0x829E7108; continue 'dispatch;
            }
            0x829E7208 => {
    //   block [0x829E7208..0x829E722C)
	// 829E7208: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E720C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829E7210: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E7214: 4B7A3A5D  bl 0x8218ac70
	ctx.lr = 0x829E7218;
	sub_8218AC70(ctx, base);
	// 829E7218: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 829E721C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829E7220: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E7224: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E7228: 4BFFFEE4  b 0x829e710c
	pc = 0x829E710C; continue 'dispatch;
            }
            0x829E722C => {
    //   block [0x829E722C..0x829E7268)
	// 829E722C: 897D0025  lbz r11, 0x25(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(37 as u32) ) } as u64;
	// 829E7230: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E7234: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7238: 419A0030  beq cr6, 0x829e7268
	if ctx.cr[6].eq {
	pc = 0x829E7268; continue 'dispatch;
	}
	// 829E723C: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E7240: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829E7244: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 829E7248: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 829E724C: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 829E7250: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829E7254: 48004AA5  bl 0x829ebcf8
	ctx.lr = 0x829E7258;
	sub_829EBCF8(ctx, base);
	// 829E7258: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E725C: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 829E7260: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E7264: 482C21F0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x829E7268 => {
    //   block [0x829E7268..0x829E7280)
	// 829E7268: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829E726C: 80BD0020  lwz r5, 0x20(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E7270: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829E7274: 480022F5  bl 0x829e9568
	ctx.lr = 0x829E7278;
	sub_829E9568(ctx, base);
	// 829E7278: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E727C: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	pc = 0x829E7280; continue 'dispatch;
            }
            0x829E7280 => {
    //   block [0x829E7280..0x829E7288)
	// 829E7280: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E7284: 482C21D0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E7288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E7288 size=432
    let mut pc: u32 = 0x829E7288;
    'dispatch: loop {
        match pc {
            0x829E7288 => {
    //   block [0x829E7288..0x829E72B8)
	// 829E7288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E728C: 482C2179  bl 0x82ca9404
	ctx.lr = 0x829E7290;
	sub_82CA93D0(ctx, base);
	// 829E7290: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E7294: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E7298: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 829E729C: 897D0024  lbz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 829E72A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E72A4: 419A0138  beq cr6, 0x829e73dc
	if ctx.cr[6].eq {
	pc = 0x829E73DC; continue 'dispatch;
	}
	// 829E72A8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E72AC: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E72B0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829E72B4: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829E72B8; continue 'dispatch;
            }
            0x829E72B8 => {
    //   block [0x829E72B8..0x829E72BC)
	// 829E72B8: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	pc = 0x829E72BC; continue 'dispatch;
            }
            0x829E72BC => {
    //   block [0x829E72BC..0x829E72D0)
	// 829E72BC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E72C0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E72C4: 419A000C  beq cr6, 0x829e72d0
	if ctx.cr[6].eq {
	pc = 0x829E72D0; continue 'dispatch;
	}
	// 829E72C8: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829E72CC: 419A0008  beq cr6, 0x829e72d4
	if ctx.cr[6].eq {
	pc = 0x829E72D4; continue 'dispatch;
	}
	pc = 0x829E72D0; continue 'dispatch;
            }
            0x829E72D0 => {
    //   block [0x829E72D0..0x829E72D4)
	// 829E72D0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E72D4; continue 'dispatch;
            }
            0x829E72D4 => {
    //   block [0x829E72D4..0x829E72E8)
	// 829E72D4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E72D8: 419A0158  beq cr6, 0x829e7430
	if ctx.cr[6].eq {
	pc = 0x829E7430; continue 'dispatch;
	}
	// 829E72DC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E72E0: 409A0008  bne cr6, 0x829e72e8
	if !ctx.cr[6].eq {
	pc = 0x829E72E8; continue 'dispatch;
	}
	// 829E72E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E72E8; continue 'dispatch;
            }
            0x829E72E8 => {
    //   block [0x829E72E8..0x829E72F8)
	// 829E72E8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E72EC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E72F0: 409A0008  bne cr6, 0x829e72f8
	if !ctx.cr[6].eq {
	pc = 0x829E72F8; continue 'dispatch;
	}
	// 829E72F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E72F8; continue 'dispatch;
            }
            0x829E72F8 => {
    //   block [0x829E72F8..0x829E7334)
	// 829E72F8: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E72FC: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 829E7300: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7304: 419A0030  beq cr6, 0x829e7334
	if ctx.cr[6].eq {
	pc = 0x829E7334; continue 'dispatch;
	}
	// 829E7308: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E730C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E7310: 419A0064  beq cr6, 0x829e7374
	if ctx.cr[6].eq {
	pc = 0x829E7374; continue 'dispatch;
	}
	// 829E7314: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E7318: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E731C: 419A0018  beq cr6, 0x829e7334
	if ctx.cr[6].eq {
	pc = 0x829E7334; continue 'dispatch;
	}
	// 829E7320: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E7324: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E7328: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E732C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E7330: 409A0008  bne cr6, 0x829e7338
	if !ctx.cr[6].eq {
	pc = 0x829E7338; continue 'dispatch;
	}
	pc = 0x829E7334; continue 'dispatch;
            }
            0x829E7334 => {
    //   block [0x829E7334..0x829E7338)
	// 829E7334: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829E7338; continue 'dispatch;
            }
            0x829E7338 => {
    //   block [0x829E7338..0x829E7354)
	// 829E7338: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E733C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7340: 419A0078  beq cr6, 0x829e73b8
	if ctx.cr[6].eq {
	pc = 0x829E73B8; continue 'dispatch;
	}
	// 829E7344: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7348: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E734C: 409A0008  bne cr6, 0x829e7354
	if !ctx.cr[6].eq {
	pc = 0x829E7354; continue 'dispatch;
	}
	// 829E7350: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7354; continue 'dispatch;
            }
            0x829E7354 => {
    //   block [0x829E7354..0x829E7374)
	// 829E7354: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7358: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E735C: 419A002C  beq cr6, 0x829e7388
	if ctx.cr[6].eq {
	pc = 0x829E7388; continue 'dispatch;
	}
	// 829E7360: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E7364: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E7368: 419A0018  beq cr6, 0x829e7380
	if ctx.cr[6].eq {
	pc = 0x829E7380; continue 'dispatch;
	}
	// 829E736C: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 829E7370: 4800001C  b 0x829e738c
	pc = 0x829E738C; continue 'dispatch;
            }
            0x829E7374 => {
    //   block [0x829E7374..0x829E7380)
	// 829E7374: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E7378: 4B7ACAC1  bl 0x82193e38
	ctx.lr = 0x829E737C;
	sub_82193E38(ctx, base);
	// 829E737C: 4BFFFFB8  b 0x829e7334
	pc = 0x829E7334; continue 'dispatch;
            }
            0x829E7380 => {
    //   block [0x829E7380..0x829E7388)
	// 829E7380: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E7384: 4B7ACAB5  bl 0x82193e38
	ctx.lr = 0x829E7388;
	sub_82193E38(ctx, base);
	pc = 0x829E7388; continue 'dispatch;
            }
            0x829E7388 => {
    //   block [0x829E7388..0x829E738C)
	// 829E7388: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829E738C; continue 'dispatch;
            }
            0x829E738C => {
    //   block [0x829E738C..0x829E73B0)
	// 829E738C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829E7390: 4BB2A439  bl 0x825117c8
	ctx.lr = 0x829E7394;
	sub_825117C8(ctx, base);
	// 829E7394: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E7398: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E739C: 419A001C  beq cr6, 0x829e73b8
	if ctx.cr[6].eq {
	pc = 0x829E73B8; continue 'dispatch;
	}
	// 829E73A0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E73A4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E73A8: 409A0008  bne cr6, 0x829e73b0
	if !ctx.cr[6].eq {
	pc = 0x829E73B0; continue 'dispatch;
	}
	// 829E73AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E73B0; continue 'dispatch;
            }
            0x829E73B0 => {
    //   block [0x829E73B0..0x829E73B8)
	// 829E73B0: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E73B4: 4BFFFF04  b 0x829e72b8
	pc = 0x829E72B8; continue 'dispatch;
            }
            0x829E73B8 => {
    //   block [0x829E73B8..0x829E73DC)
	// 829E73B8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E73BC: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829E73C0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E73C4: 4B7A38AD  bl 0x8218ac70
	ctx.lr = 0x829E73C8;
	sub_8218AC70(ctx, base);
	// 829E73C8: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 829E73CC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829E73D0: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E73D4: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E73D8: 4BFFFEE4  b 0x829e72bc
	pc = 0x829E72BC; continue 'dispatch;
            }
            0x829E73DC => {
    //   block [0x829E73DC..0x829E7418)
	// 829E73DC: 897D0025  lbz r11, 0x25(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(37 as u32) ) } as u64;
	// 829E73E0: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E73E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E73E8: 419A0030  beq cr6, 0x829e7418
	if ctx.cr[6].eq {
	pc = 0x829E7418; continue 'dispatch;
	}
	// 829E73EC: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E73F0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829E73F4: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 829E73F8: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 829E73FC: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 829E7400: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829E7404: 48004B15  bl 0x829ebf18
	ctx.lr = 0x829E7408;
	sub_829EBF18(ctx, base);
	// 829E7408: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E740C: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 829E7410: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E7414: 482C2040  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x829E7418 => {
    //   block [0x829E7418..0x829E7430)
	// 829E7418: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829E741C: 80BD0020  lwz r5, 0x20(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E7420: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829E7424: 480022BD  bl 0x829e96e0
	ctx.lr = 0x829E7428;
	sub_829E96E0(ctx, base);
	// 829E7428: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E742C: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	pc = 0x829E7430; continue 'dispatch;
            }
            0x829E7430 => {
    //   block [0x829E7430..0x829E7438)
	// 829E7430: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E7434: 482C2020  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E7438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E7438 size=440
    let mut pc: u32 = 0x829E7438;
    'dispatch: loop {
        match pc {
            0x829E7438 => {
    //   block [0x829E7438..0x829E7468)
	// 829E7438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E743C: 482C1FC9  bl 0x82ca9404
	ctx.lr = 0x829E7440;
	sub_82CA93D0(ctx, base);
	// 829E7440: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E7444: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E7448: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 829E744C: 897D0024  lbz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 829E7450: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7454: 419A0140  beq cr6, 0x829e7594
	if ctx.cr[6].eq {
	pc = 0x829E7594; continue 'dispatch;
	}
	// 829E7458: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E745C: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E7460: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829E7464: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829E7468; continue 'dispatch;
            }
            0x829E7468 => {
    //   block [0x829E7468..0x829E746C)
	// 829E7468: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	pc = 0x829E746C; continue 'dispatch;
            }
            0x829E746C => {
    //   block [0x829E746C..0x829E7480)
	// 829E746C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7470: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E7474: 419A000C  beq cr6, 0x829e7480
	if ctx.cr[6].eq {
	pc = 0x829E7480; continue 'dispatch;
	}
	// 829E7478: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829E747C: 419A0008  beq cr6, 0x829e7484
	if ctx.cr[6].eq {
	pc = 0x829E7484; continue 'dispatch;
	}
	pc = 0x829E7480; continue 'dispatch;
            }
            0x829E7480 => {
    //   block [0x829E7480..0x829E7484)
	// 829E7480: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7484; continue 'dispatch;
            }
            0x829E7484 => {
    //   block [0x829E7484..0x829E7498)
	// 829E7484: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E7488: 419A0160  beq cr6, 0x829e75e8
	if ctx.cr[6].eq {
	pc = 0x829E75E8; continue 'dispatch;
	}
	// 829E748C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E7490: 409A0008  bne cr6, 0x829e7498
	if !ctx.cr[6].eq {
	pc = 0x829E7498; continue 'dispatch;
	}
	// 829E7494: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7498; continue 'dispatch;
            }
            0x829E7498 => {
    //   block [0x829E7498..0x829E74A8)
	// 829E7498: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E749C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E74A0: 409A0008  bne cr6, 0x829e74a8
	if !ctx.cr[6].eq {
	pc = 0x829E74A8; continue 'dispatch;
	}
	// 829E74A4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E74A8; continue 'dispatch;
            }
            0x829E74A8 => {
    //   block [0x829E74A8..0x829E74E4)
	// 829E74A8: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E74AC: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 829E74B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E74B4: 419A0030  beq cr6, 0x829e74e4
	if ctx.cr[6].eq {
	pc = 0x829E74E4; continue 'dispatch;
	}
	// 829E74B8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E74BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E74C0: 419A0064  beq cr6, 0x829e7524
	if ctx.cr[6].eq {
	pc = 0x829E7524; continue 'dispatch;
	}
	// 829E74C4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E74C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E74CC: 419A0018  beq cr6, 0x829e74e4
	if ctx.cr[6].eq {
	pc = 0x829E74E4; continue 'dispatch;
	}
	// 829E74D0: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E74D4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E74D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E74DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E74E0: 409A0008  bne cr6, 0x829e74e8
	if !ctx.cr[6].eq {
	pc = 0x829E74E8; continue 'dispatch;
	}
	pc = 0x829E74E4; continue 'dispatch;
            }
            0x829E74E4 => {
    //   block [0x829E74E4..0x829E74E8)
	// 829E74E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829E74E8; continue 'dispatch;
            }
            0x829E74E8 => {
    //   block [0x829E74E8..0x829E7504)
	// 829E74E8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E74EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E74F0: 419A0080  beq cr6, 0x829e7570
	if ctx.cr[6].eq {
	pc = 0x829E7570; continue 'dispatch;
	}
	// 829E74F4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E74F8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E74FC: 409A0008  bne cr6, 0x829e7504
	if !ctx.cr[6].eq {
	pc = 0x829E7504; continue 'dispatch;
	}
	// 829E7500: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7504; continue 'dispatch;
            }
            0x829E7504 => {
    //   block [0x829E7504..0x829E7524)
	// 829E7504: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7508: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E750C: 419A002C  beq cr6, 0x829e7538
	if ctx.cr[6].eq {
	pc = 0x829E7538; continue 'dispatch;
	}
	// 829E7510: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E7514: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E7518: 419A0018  beq cr6, 0x829e7530
	if ctx.cr[6].eq {
	pc = 0x829E7530; continue 'dispatch;
	}
	// 829E751C: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 829E7520: 4800001C  b 0x829e753c
	pc = 0x829E753C; continue 'dispatch;
            }
            0x829E7524 => {
    //   block [0x829E7524..0x829E7530)
	// 829E7524: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E7528: 4B7AC911  bl 0x82193e38
	ctx.lr = 0x829E752C;
	sub_82193E38(ctx, base);
	// 829E752C: 4BFFFFB8  b 0x829e74e4
	pc = 0x829E74E4; continue 'dispatch;
            }
            0x829E7530 => {
    //   block [0x829E7530..0x829E7538)
	// 829E7530: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E7534: 4B7AC905  bl 0x82193e38
	ctx.lr = 0x829E7538;
	sub_82193E38(ctx, base);
	pc = 0x829E7538; continue 'dispatch;
            }
            0x829E7538 => {
    //   block [0x829E7538..0x829E753C)
	// 829E7538: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829E753C; continue 'dispatch;
            }
            0x829E753C => {
    //   block [0x829E753C..0x829E7568)
	// 829E753C: 80DB0008  lwz r6, 8(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E7540: 80BB0004  lwz r5, 4(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7544: 807B000C  lwz r3, 0xc(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E7548: 4B889E21  bl 0x82271368
	ctx.lr = 0x829E754C;
	sub_82271368(ctx, base);
	// 829E754C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E7550: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7554: 419A001C  beq cr6, 0x829e7570
	if ctx.cr[6].eq {
	pc = 0x829E7570; continue 'dispatch;
	}
	// 829E7558: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E755C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E7560: 409A0008  bne cr6, 0x829e7568
	if !ctx.cr[6].eq {
	pc = 0x829E7568; continue 'dispatch;
	}
	// 829E7564: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7568; continue 'dispatch;
            }
            0x829E7568 => {
    //   block [0x829E7568..0x829E7570)
	// 829E7568: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E756C: 4BFFFEFC  b 0x829e7468
	pc = 0x829E7468; continue 'dispatch;
            }
            0x829E7570 => {
    //   block [0x829E7570..0x829E7594)
	// 829E7570: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E7574: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829E7578: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E757C: 4B7A36F5  bl 0x8218ac70
	ctx.lr = 0x829E7580;
	sub_8218AC70(ctx, base);
	// 829E7580: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 829E7584: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829E7588: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E758C: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E7590: 4BFFFEDC  b 0x829e746c
	pc = 0x829E746C; continue 'dispatch;
            }
            0x829E7594 => {
    //   block [0x829E7594..0x829E75D0)
	// 829E7594: 897D0025  lbz r11, 0x25(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(37 as u32) ) } as u64;
	// 829E7598: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E759C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E75A0: 419A0030  beq cr6, 0x829e75d0
	if ctx.cr[6].eq {
	pc = 0x829E75D0; continue 'dispatch;
	}
	// 829E75A4: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E75A8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829E75AC: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 829E75B0: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 829E75B4: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 829E75B8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829E75BC: 48004B7D  bl 0x829ec138
	ctx.lr = 0x829E75C0;
	sub_829EC138(ctx, base);
	// 829E75C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E75C4: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 829E75C8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E75CC: 482C1E88  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x829E75D0 => {
    //   block [0x829E75D0..0x829E75E8)
	// 829E75D0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829E75D4: 80BD0020  lwz r5, 0x20(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E75D8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829E75DC: 4800227D  bl 0x829e9858
	ctx.lr = 0x829E75E0;
	sub_829E9858(ctx, base);
	// 829E75E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E75E4: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	pc = 0x829E75E8; continue 'dispatch;
            }
            0x829E75E8 => {
    //   block [0x829E75E8..0x829E75F0)
	// 829E75E8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E75EC: 482C1E68  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E75F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E75F0 size=344
    let mut pc: u32 = 0x829E75F0;
    'dispatch: loop {
        match pc {
            0x829E75F0 => {
    //   block [0x829E75F0..0x829E7644)
	// 829E75F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E75F4: 482C1E11  bl 0x82ca9404
	ctx.lr = 0x829E75F8;
	sub_82CA93D0(ctx, base);
	// 829E75F8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E75FC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E7600: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 829E7604: 897D0024  lbz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 829E7608: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E760C: 409A0050  bne cr6, 0x829e765c
	if !ctx.cr[6].eq {
	pc = 0x829E765C; continue 'dispatch;
	}
	// 829E7610: 897D0025  lbz r11, 0x25(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(37 as u32) ) } as u64;
	// 829E7614: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E7618: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E761C: 419A0028  beq cr6, 0x829e7644
	if ctx.cr[6].eq {
	pc = 0x829E7644; continue 'dispatch;
	}
	// 829E7620: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E7624: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 829E7628: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 829E762C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829E7630: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 829E7634: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 829E7638: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829E763C: 48004D25  bl 0x829ec360
	ctx.lr = 0x829E7640;
	sub_829EC360(ctx, base);
	// 829E7640: 48000014  b 0x829e7654
	pc = 0x829E7654; continue 'dispatch;
            }
            0x829E7644 => {
    //   block [0x829E7644..0x829E7654)
	// 829E7644: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829E7648: 80BD0020  lwz r5, 0x20(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E764C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829E7650: 48002389  bl 0x829e99d8
	ctx.lr = 0x829E7654;
	sub_829E99D8(ctx, base);
	pc = 0x829E7654; continue 'dispatch;
            }
            0x829E7654 => {
    //   block [0x829E7654..0x829E765C)
	// 829E7654: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E7658: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	pc = 0x829E765C; continue 'dispatch;
            }
            0x829E765C => {
    //   block [0x829E765C..0x829E7680)
	// 829E765C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7660: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829E7664: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 829E7668: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E766C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 829E7670: E9210058  ld r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829E7674: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 829E7678: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829E767C: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	pc = 0x829E7680; continue 'dispatch;
            }
            0x829E7680 => {
    //   block [0x829E7680..0x829E7694)
	// 829E7680: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7684: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829E7688: 419A000C  beq cr6, 0x829e7694
	if ctx.cr[6].eq {
	pc = 0x829E7694; continue 'dispatch;
	}
	// 829E768C: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829E7690: 419A0008  beq cr6, 0x829e7698
	if ctx.cr[6].eq {
	pc = 0x829E7698; continue 'dispatch;
	}
	pc = 0x829E7694; continue 'dispatch;
            }
            0x829E7694 => {
    //   block [0x829E7694..0x829E7698)
	// 829E7694: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7698; continue 'dispatch;
            }
            0x829E7698 => {
    //   block [0x829E7698..0x829E76AC)
	// 829E7698: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E769C: 419A00A0  beq cr6, 0x829e773c
	if ctx.cr[6].eq {
	pc = 0x829E773C; continue 'dispatch;
	}
	// 829E76A0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829E76A4: 409A0008  bne cr6, 0x829e76ac
	if !ctx.cr[6].eq {
	pc = 0x829E76AC; continue 'dispatch;
	}
	// 829E76A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E76AC; continue 'dispatch;
            }
            0x829E76AC => {
    //   block [0x829E76AC..0x829E76BC)
	// 829E76AC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E76B0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E76B4: 409A0008  bne cr6, 0x829e76bc
	if !ctx.cr[6].eq {
	pc = 0x829E76BC; continue 'dispatch;
	}
	// 829E76B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E76BC; continue 'dispatch;
            }
            0x829E76BC => {
    //   block [0x829E76BC..0x829E76F8)
	// 829E76BC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E76C0: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 829E76C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E76C8: 419A006C  beq cr6, 0x829e7734
	if ctx.cr[6].eq {
	pc = 0x829E7734; continue 'dispatch;
	}
	// 829E76CC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E76D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E76D4: 419A005C  beq cr6, 0x829e7730
	if ctx.cr[6].eq {
	pc = 0x829E7730; continue 'dispatch;
	}
	// 829E76D8: 5545003E  slwi r5, r10, 0
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 829E76DC: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 829E76E0: 419A0018  beq cr6, 0x829e76f8
	if ctx.cr[6].eq {
	pc = 0x829E76F8; continue 'dispatch;
	}
	// 829E76E4: 89650090  lbz r11, 0x90(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E76E8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E76EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E76F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E76F4: 409A0008  bne cr6, 0x829e76fc
	if !ctx.cr[6].eq {
	pc = 0x829E76FC; continue 'dispatch;
	}
	pc = 0x829E76F8; continue 'dispatch;
            }
            0x829E76F8 => {
    //   block [0x829E76F8..0x829E76FC)
	// 829E76F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829E76FC; continue 'dispatch;
            }
            0x829E76FC => {
    //   block [0x829E76FC..0x829E7718)
	// 829E76FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E7700: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7704: 419A0014  beq cr6, 0x829e7718
	if ctx.cr[6].eq {
	pc = 0x829E7718; continue 'dispatch;
	}
	// 829E7708: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829E770C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829E7710: 4BBB9B59  bl 0x825a1268
	ctx.lr = 0x829E7714;
	sub_825A1268(ctx, base);
	// 829E7714: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	pc = 0x829E7718; continue 'dispatch;
            }
            0x829E7718 => {
    //   block [0x829E7718..0x829E7728)
	// 829E7718: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E771C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E7720: 409A0008  bne cr6, 0x829e7728
	if !ctx.cr[6].eq {
	pc = 0x829E7728; continue 'dispatch;
	}
	// 829E7724: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7728; continue 'dispatch;
            }
            0x829E7728 => {
    //   block [0x829E7728..0x829E7730)
	// 829E7728: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E772C: 4BFFFF54  b 0x829e7680
	pc = 0x829E7680; continue 'dispatch;
            }
            0x829E7730 => {
    //   block [0x829E7730..0x829E7734)
	// 829E7730: 4B7AC709  bl 0x82193e38
	ctx.lr = 0x829E7734;
	sub_82193E38(ctx, base);
	pc = 0x829E7734; continue 'dispatch;
            }
            0x829E7734 => {
    //   block [0x829E7734..0x829E773C)
	// 829E7734: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829E7738: 4BFFFFC0  b 0x829e76f8
	pc = 0x829E76F8; continue 'dispatch;
            }
            0x829E773C => {
    //   block [0x829E773C..0x829E7748)
	// 829E773C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E7740: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E7744: 482C1D10  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E7748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E7748 size=344
    let mut pc: u32 = 0x829E7748;
    'dispatch: loop {
        match pc {
            0x829E7748 => {
    //   block [0x829E7748..0x829E779C)
	// 829E7748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E774C: 482C1CB9  bl 0x82ca9404
	ctx.lr = 0x829E7750;
	sub_82CA93D0(ctx, base);
	// 829E7750: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E7754: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E7758: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 829E775C: 897D0024  lbz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 829E7760: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7764: 409A0050  bne cr6, 0x829e77b4
	if !ctx.cr[6].eq {
	pc = 0x829E77B4; continue 'dispatch;
	}
	// 829E7768: 897D0025  lbz r11, 0x25(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(37 as u32) ) } as u64;
	// 829E776C: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E7770: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7774: 419A0028  beq cr6, 0x829e779c
	if ctx.cr[6].eq {
	pc = 0x829E779C; continue 'dispatch;
	}
	// 829E7778: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E777C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 829E7780: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 829E7784: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829E7788: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 829E778C: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 829E7790: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829E7794: 48004BCD  bl 0x829ec360
	ctx.lr = 0x829E7798;
	sub_829EC360(ctx, base);
	// 829E7798: 48000014  b 0x829e77ac
	pc = 0x829E77AC; continue 'dispatch;
            }
            0x829E779C => {
    //   block [0x829E779C..0x829E77AC)
	// 829E779C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829E77A0: 80BD0020  lwz r5, 0x20(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E77A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829E77A8: 48002231  bl 0x829e99d8
	ctx.lr = 0x829E77AC;
	sub_829E99D8(ctx, base);
	pc = 0x829E77AC; continue 'dispatch;
            }
            0x829E77AC => {
    //   block [0x829E77AC..0x829E77B4)
	// 829E77AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E77B0: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	pc = 0x829E77B4; continue 'dispatch;
            }
            0x829E77B4 => {
    //   block [0x829E77B4..0x829E77D8)
	// 829E77B4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E77B8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829E77BC: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 829E77C0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E77C4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 829E77C8: E9210058  ld r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829E77CC: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 829E77D0: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829E77D4: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	pc = 0x829E77D8; continue 'dispatch;
            }
            0x829E77D8 => {
    //   block [0x829E77D8..0x829E77EC)
	// 829E77D8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E77DC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829E77E0: 419A000C  beq cr6, 0x829e77ec
	if ctx.cr[6].eq {
	pc = 0x829E77EC; continue 'dispatch;
	}
	// 829E77E4: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829E77E8: 419A0008  beq cr6, 0x829e77f0
	if ctx.cr[6].eq {
	pc = 0x829E77F0; continue 'dispatch;
	}
	pc = 0x829E77EC; continue 'dispatch;
            }
            0x829E77EC => {
    //   block [0x829E77EC..0x829E77F0)
	// 829E77EC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E77F0; continue 'dispatch;
            }
            0x829E77F0 => {
    //   block [0x829E77F0..0x829E7804)
	// 829E77F0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E77F4: 419A00A0  beq cr6, 0x829e7894
	if ctx.cr[6].eq {
	pc = 0x829E7894; continue 'dispatch;
	}
	// 829E77F8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829E77FC: 409A0008  bne cr6, 0x829e7804
	if !ctx.cr[6].eq {
	pc = 0x829E7804; continue 'dispatch;
	}
	// 829E7800: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7804; continue 'dispatch;
            }
            0x829E7804 => {
    //   block [0x829E7804..0x829E7814)
	// 829E7804: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7808: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E780C: 409A0008  bne cr6, 0x829e7814
	if !ctx.cr[6].eq {
	pc = 0x829E7814; continue 'dispatch;
	}
	// 829E7810: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7814; continue 'dispatch;
            }
            0x829E7814 => {
    //   block [0x829E7814..0x829E7850)
	// 829E7814: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E7818: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 829E781C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7820: 419A006C  beq cr6, 0x829e788c
	if ctx.cr[6].eq {
	pc = 0x829E788C; continue 'dispatch;
	}
	// 829E7824: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E7828: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E782C: 419A005C  beq cr6, 0x829e7888
	if ctx.cr[6].eq {
	pc = 0x829E7888; continue 'dispatch;
	}
	// 829E7830: 5545003E  slwi r5, r10, 0
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 829E7834: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 829E7838: 419A0018  beq cr6, 0x829e7850
	if ctx.cr[6].eq {
	pc = 0x829E7850; continue 'dispatch;
	}
	// 829E783C: 89650090  lbz r11, 0x90(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E7840: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E7844: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E7848: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E784C: 409A0008  bne cr6, 0x829e7854
	if !ctx.cr[6].eq {
	pc = 0x829E7854; continue 'dispatch;
	}
	pc = 0x829E7850; continue 'dispatch;
            }
            0x829E7850 => {
    //   block [0x829E7850..0x829E7854)
	// 829E7850: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829E7854; continue 'dispatch;
            }
            0x829E7854 => {
    //   block [0x829E7854..0x829E7870)
	// 829E7854: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E7858: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E785C: 419A0014  beq cr6, 0x829e7870
	if ctx.cr[6].eq {
	pc = 0x829E7870; continue 'dispatch;
	}
	// 829E7860: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829E7864: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829E7868: 4BBB9B09  bl 0x825a1370
	ctx.lr = 0x829E786C;
	sub_825A1370(ctx, base);
	// 829E786C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	pc = 0x829E7870; continue 'dispatch;
            }
            0x829E7870 => {
    //   block [0x829E7870..0x829E7880)
	// 829E7870: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7874: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E7878: 409A0008  bne cr6, 0x829e7880
	if !ctx.cr[6].eq {
	pc = 0x829E7880; continue 'dispatch;
	}
	// 829E787C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7880; continue 'dispatch;
            }
            0x829E7880 => {
    //   block [0x829E7880..0x829E7888)
	// 829E7880: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E7884: 4BFFFF54  b 0x829e77d8
	pc = 0x829E77D8; continue 'dispatch;
            }
            0x829E7888 => {
    //   block [0x829E7888..0x829E788C)
	// 829E7888: 4B7AC5B1  bl 0x82193e38
	ctx.lr = 0x829E788C;
	sub_82193E38(ctx, base);
	pc = 0x829E788C; continue 'dispatch;
            }
            0x829E788C => {
    //   block [0x829E788C..0x829E7894)
	// 829E788C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829E7890: 4BFFFFC0  b 0x829e7850
	pc = 0x829E7850; continue 'dispatch;
            }
            0x829E7894 => {
    //   block [0x829E7894..0x829E78A0)
	// 829E7894: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E7898: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E789C: 482C1BB8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E78A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E78A0 size=424
    let mut pc: u32 = 0x829E78A0;
    'dispatch: loop {
        match pc {
            0x829E78A0 => {
    //   block [0x829E78A0..0x829E78D0)
	// 829E78A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E78A4: 482C1B61  bl 0x82ca9404
	ctx.lr = 0x829E78A8;
	sub_82CA93D0(ctx, base);
	// 829E78A8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E78AC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E78B0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 829E78B4: 897D0024  lbz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 829E78B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E78BC: 419A0130  beq cr6, 0x829e79ec
	if ctx.cr[6].eq {
	pc = 0x829E79EC; continue 'dispatch;
	}
	// 829E78C0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E78C4: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E78C8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829E78CC: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829E78D0; continue 'dispatch;
            }
            0x829E78D0 => {
    //   block [0x829E78D0..0x829E78D4)
	// 829E78D0: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	pc = 0x829E78D4; continue 'dispatch;
            }
            0x829E78D4 => {
    //   block [0x829E78D4..0x829E78E8)
	// 829E78D4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E78D8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E78DC: 419A000C  beq cr6, 0x829e78e8
	if ctx.cr[6].eq {
	pc = 0x829E78E8; continue 'dispatch;
	}
	// 829E78E0: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829E78E4: 419A0008  beq cr6, 0x829e78ec
	if ctx.cr[6].eq {
	pc = 0x829E78EC; continue 'dispatch;
	}
	pc = 0x829E78E8; continue 'dispatch;
            }
            0x829E78E8 => {
    //   block [0x829E78E8..0x829E78EC)
	// 829E78E8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E78EC; continue 'dispatch;
            }
            0x829E78EC => {
    //   block [0x829E78EC..0x829E7900)
	// 829E78EC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E78F0: 419A0150  beq cr6, 0x829e7a40
	if ctx.cr[6].eq {
	pc = 0x829E7A40; continue 'dispatch;
	}
	// 829E78F4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E78F8: 409A0008  bne cr6, 0x829e7900
	if !ctx.cr[6].eq {
	pc = 0x829E7900; continue 'dispatch;
	}
	// 829E78FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7900; continue 'dispatch;
            }
            0x829E7900 => {
    //   block [0x829E7900..0x829E7910)
	// 829E7900: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7904: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E7908: 409A0008  bne cr6, 0x829e7910
	if !ctx.cr[6].eq {
	pc = 0x829E7910; continue 'dispatch;
	}
	// 829E790C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7910; continue 'dispatch;
            }
            0x829E7910 => {
    //   block [0x829E7910..0x829E794C)
	// 829E7910: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E7914: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 829E7918: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E791C: 419A0030  beq cr6, 0x829e794c
	if ctx.cr[6].eq {
	pc = 0x829E794C; continue 'dispatch;
	}
	// 829E7920: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E7924: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E7928: 419A0064  beq cr6, 0x829e798c
	if ctx.cr[6].eq {
	pc = 0x829E798C; continue 'dispatch;
	}
	// 829E792C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E7930: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7934: 419A0018  beq cr6, 0x829e794c
	if ctx.cr[6].eq {
	pc = 0x829E794C; continue 'dispatch;
	}
	// 829E7938: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E793C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E7940: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E7944: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E7948: 409A0008  bne cr6, 0x829e7950
	if !ctx.cr[6].eq {
	pc = 0x829E7950; continue 'dispatch;
	}
	pc = 0x829E794C; continue 'dispatch;
            }
            0x829E794C => {
    //   block [0x829E794C..0x829E7950)
	// 829E794C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829E7950; continue 'dispatch;
            }
            0x829E7950 => {
    //   block [0x829E7950..0x829E796C)
	// 829E7950: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E7954: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7958: 419A0070  beq cr6, 0x829e79c8
	if ctx.cr[6].eq {
	pc = 0x829E79C8; continue 'dispatch;
	}
	// 829E795C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7960: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E7964: 409A0008  bne cr6, 0x829e796c
	if !ctx.cr[6].eq {
	pc = 0x829E796C; continue 'dispatch;
	}
	// 829E7968: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E796C; continue 'dispatch;
            }
            0x829E796C => {
    //   block [0x829E796C..0x829E798C)
	// 829E796C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7970: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7974: 419A002C  beq cr6, 0x829e79a0
	if ctx.cr[6].eq {
	pc = 0x829E79A0; continue 'dispatch;
	}
	// 829E7978: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E797C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E7980: 419A0018  beq cr6, 0x829e7998
	if ctx.cr[6].eq {
	pc = 0x829E7998; continue 'dispatch;
	}
	// 829E7984: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E7988: 4800001C  b 0x829e79a4
	pc = 0x829E79A4; continue 'dispatch;
            }
            0x829E798C => {
    //   block [0x829E798C..0x829E7998)
	// 829E798C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E7990: 4B7AC4A9  bl 0x82193e38
	ctx.lr = 0x829E7994;
	sub_82193E38(ctx, base);
	// 829E7994: 4BFFFFB8  b 0x829e794c
	pc = 0x829E794C; continue 'dispatch;
            }
            0x829E7998 => {
    //   block [0x829E7998..0x829E79A0)
	// 829E7998: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E799C: 4B7AC49D  bl 0x82193e38
	ctx.lr = 0x829E79A0;
	sub_82193E38(ctx, base);
	pc = 0x829E79A0; continue 'dispatch;
            }
            0x829E79A0 => {
    //   block [0x829E79A0..0x829E79A4)
	// 829E79A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829E79A4; continue 'dispatch;
            }
            0x829E79A4 => {
    //   block [0x829E79A4..0x829E79C0)
	// 829E79A4: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E79A8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829E79AC: 419A001C  beq cr6, 0x829e79c8
	if ctx.cr[6].eq {
	pc = 0x829E79C8; continue 'dispatch;
	}
	// 829E79B0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E79B4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E79B8: 409A0008  bne cr6, 0x829e79c0
	if !ctx.cr[6].eq {
	pc = 0x829E79C0; continue 'dispatch;
	}
	// 829E79BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E79C0; continue 'dispatch;
            }
            0x829E79C0 => {
    //   block [0x829E79C0..0x829E79C8)
	// 829E79C0: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E79C4: 4BFFFF0C  b 0x829e78d0
	pc = 0x829E78D0; continue 'dispatch;
            }
            0x829E79C8 => {
    //   block [0x829E79C8..0x829E79EC)
	// 829E79C8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E79CC: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829E79D0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E79D4: 4B7A329D  bl 0x8218ac70
	ctx.lr = 0x829E79D8;
	sub_8218AC70(ctx, base);
	// 829E79D8: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 829E79DC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829E79E0: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E79E4: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E79E8: 4BFFFEEC  b 0x829e78d4
	pc = 0x829E78D4; continue 'dispatch;
            }
            0x829E79EC => {
    //   block [0x829E79EC..0x829E7A28)
	// 829E79EC: 897D0025  lbz r11, 0x25(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(37 as u32) ) } as u64;
	// 829E79F0: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E79F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E79F8: 419A0030  beq cr6, 0x829e7a28
	if ctx.cr[6].eq {
	pc = 0x829E7A28; continue 'dispatch;
	}
	// 829E79FC: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E7A00: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829E7A04: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 829E7A08: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 829E7A0C: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 829E7A10: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829E7A14: 48004B55  bl 0x829ec568
	ctx.lr = 0x829E7A18;
	sub_829EC568(ctx, base);
	// 829E7A18: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E7A1C: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 829E7A20: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E7A24: 482C1A30  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x829E7A28 => {
    //   block [0x829E7A28..0x829E7A40)
	// 829E7A28: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829E7A2C: 80BD0020  lwz r5, 0x20(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E7A30: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829E7A34: 480020FD  bl 0x829e9b30
	ctx.lr = 0x829E7A38;
	sub_829E9B30(ctx, base);
	// 829E7A38: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E7A3C: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	pc = 0x829E7A40; continue 'dispatch;
            }
            0x829E7A40 => {
    //   block [0x829E7A40..0x829E7A48)
	// 829E7A40: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E7A44: 482C1A10  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E7A48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E7A48 size=432
    let mut pc: u32 = 0x829E7A48;
    'dispatch: loop {
        match pc {
            0x829E7A48 => {
    //   block [0x829E7A48..0x829E7A78)
	// 829E7A48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E7A4C: 482C19B9  bl 0x82ca9404
	ctx.lr = 0x829E7A50;
	sub_82CA93D0(ctx, base);
	// 829E7A50: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E7A54: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E7A58: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 829E7A5C: 897D0024  lbz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 829E7A60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7A64: 419A0138  beq cr6, 0x829e7b9c
	if ctx.cr[6].eq {
	pc = 0x829E7B9C; continue 'dispatch;
	}
	// 829E7A68: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7A6C: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E7A70: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829E7A74: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829E7A78; continue 'dispatch;
            }
            0x829E7A78 => {
    //   block [0x829E7A78..0x829E7A7C)
	// 829E7A78: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	pc = 0x829E7A7C; continue 'dispatch;
            }
            0x829E7A7C => {
    //   block [0x829E7A7C..0x829E7A90)
	// 829E7A7C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7A80: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E7A84: 419A000C  beq cr6, 0x829e7a90
	if ctx.cr[6].eq {
	pc = 0x829E7A90; continue 'dispatch;
	}
	// 829E7A88: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829E7A8C: 419A0008  beq cr6, 0x829e7a94
	if ctx.cr[6].eq {
	pc = 0x829E7A94; continue 'dispatch;
	}
	pc = 0x829E7A90; continue 'dispatch;
            }
            0x829E7A90 => {
    //   block [0x829E7A90..0x829E7A94)
	// 829E7A90: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7A94; continue 'dispatch;
            }
            0x829E7A94 => {
    //   block [0x829E7A94..0x829E7AA8)
	// 829E7A94: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E7A98: 419A0158  beq cr6, 0x829e7bf0
	if ctx.cr[6].eq {
	pc = 0x829E7BF0; continue 'dispatch;
	}
	// 829E7A9C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E7AA0: 409A0008  bne cr6, 0x829e7aa8
	if !ctx.cr[6].eq {
	pc = 0x829E7AA8; continue 'dispatch;
	}
	// 829E7AA4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7AA8; continue 'dispatch;
            }
            0x829E7AA8 => {
    //   block [0x829E7AA8..0x829E7AB8)
	// 829E7AA8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7AAC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E7AB0: 409A0008  bne cr6, 0x829e7ab8
	if !ctx.cr[6].eq {
	pc = 0x829E7AB8; continue 'dispatch;
	}
	// 829E7AB4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7AB8; continue 'dispatch;
            }
            0x829E7AB8 => {
    //   block [0x829E7AB8..0x829E7AF4)
	// 829E7AB8: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E7ABC: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 829E7AC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7AC4: 419A0030  beq cr6, 0x829e7af4
	if ctx.cr[6].eq {
	pc = 0x829E7AF4; continue 'dispatch;
	}
	// 829E7AC8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E7ACC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E7AD0: 419A0064  beq cr6, 0x829e7b34
	if ctx.cr[6].eq {
	pc = 0x829E7B34; continue 'dispatch;
	}
	// 829E7AD4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E7AD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7ADC: 419A0018  beq cr6, 0x829e7af4
	if ctx.cr[6].eq {
	pc = 0x829E7AF4; continue 'dispatch;
	}
	// 829E7AE0: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E7AE4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E7AE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E7AEC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E7AF0: 409A0008  bne cr6, 0x829e7af8
	if !ctx.cr[6].eq {
	pc = 0x829E7AF8; continue 'dispatch;
	}
	pc = 0x829E7AF4; continue 'dispatch;
            }
            0x829E7AF4 => {
    //   block [0x829E7AF4..0x829E7AF8)
	// 829E7AF4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829E7AF8; continue 'dispatch;
            }
            0x829E7AF8 => {
    //   block [0x829E7AF8..0x829E7B14)
	// 829E7AF8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E7AFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7B00: 419A0078  beq cr6, 0x829e7b78
	if ctx.cr[6].eq {
	pc = 0x829E7B78; continue 'dispatch;
	}
	// 829E7B04: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7B08: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E7B0C: 409A0008  bne cr6, 0x829e7b14
	if !ctx.cr[6].eq {
	pc = 0x829E7B14; continue 'dispatch;
	}
	// 829E7B10: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7B14; continue 'dispatch;
            }
            0x829E7B14 => {
    //   block [0x829E7B14..0x829E7B34)
	// 829E7B14: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7B18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7B1C: 419A002C  beq cr6, 0x829e7b48
	if ctx.cr[6].eq {
	pc = 0x829E7B48; continue 'dispatch;
	}
	// 829E7B20: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E7B24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E7B28: 419A0018  beq cr6, 0x829e7b40
	if ctx.cr[6].eq {
	pc = 0x829E7B40; continue 'dispatch;
	}
	// 829E7B2C: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 829E7B30: 4800001C  b 0x829e7b4c
	pc = 0x829E7B4C; continue 'dispatch;
            }
            0x829E7B34 => {
    //   block [0x829E7B34..0x829E7B40)
	// 829E7B34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E7B38: 4B7AC301  bl 0x82193e38
	ctx.lr = 0x829E7B3C;
	sub_82193E38(ctx, base);
	// 829E7B3C: 4BFFFFB8  b 0x829e7af4
	pc = 0x829E7AF4; continue 'dispatch;
            }
            0x829E7B40 => {
    //   block [0x829E7B40..0x829E7B48)
	// 829E7B40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E7B44: 4B7AC2F5  bl 0x82193e38
	ctx.lr = 0x829E7B48;
	sub_82193E38(ctx, base);
	pc = 0x829E7B48; continue 'dispatch;
            }
            0x829E7B48 => {
    //   block [0x829E7B48..0x829E7B4C)
	// 829E7B48: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829E7B4C; continue 'dispatch;
            }
            0x829E7B4C => {
    //   block [0x829E7B4C..0x829E7B70)
	// 829E7B4C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829E7B50: 4BB29579  bl 0x825110c8
	ctx.lr = 0x829E7B54;
	sub_825110C8(ctx, base);
	// 829E7B54: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E7B58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7B5C: 419A001C  beq cr6, 0x829e7b78
	if ctx.cr[6].eq {
	pc = 0x829E7B78; continue 'dispatch;
	}
	// 829E7B60: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7B64: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E7B68: 409A0008  bne cr6, 0x829e7b70
	if !ctx.cr[6].eq {
	pc = 0x829E7B70; continue 'dispatch;
	}
	// 829E7B6C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7B70; continue 'dispatch;
            }
            0x829E7B70 => {
    //   block [0x829E7B70..0x829E7B78)
	// 829E7B70: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E7B74: 4BFFFF04  b 0x829e7a78
	pc = 0x829E7A78; continue 'dispatch;
            }
            0x829E7B78 => {
    //   block [0x829E7B78..0x829E7B9C)
	// 829E7B78: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E7B7C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829E7B80: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E7B84: 4B7A30ED  bl 0x8218ac70
	ctx.lr = 0x829E7B88;
	sub_8218AC70(ctx, base);
	// 829E7B88: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 829E7B8C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829E7B90: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E7B94: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E7B98: 4BFFFEE4  b 0x829e7a7c
	pc = 0x829E7A7C; continue 'dispatch;
            }
            0x829E7B9C => {
    //   block [0x829E7B9C..0x829E7BD8)
	// 829E7B9C: 897D0025  lbz r11, 0x25(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(37 as u32) ) } as u64;
	// 829E7BA0: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E7BA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7BA8: 419A0030  beq cr6, 0x829e7bd8
	if ctx.cr[6].eq {
	pc = 0x829E7BD8; continue 'dispatch;
	}
	// 829E7BAC: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E7BB0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829E7BB4: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 829E7BB8: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 829E7BBC: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 829E7BC0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829E7BC4: 48004BBD  bl 0x829ec780
	ctx.lr = 0x829E7BC8;
	sub_829EC780(ctx, base);
	// 829E7BC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E7BCC: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 829E7BD0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E7BD4: 482C1880  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x829E7BD8 => {
    //   block [0x829E7BD8..0x829E7BF0)
	// 829E7BD8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829E7BDC: 80BD0020  lwz r5, 0x20(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E7BE0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829E7BE4: 480020B5  bl 0x829e9c98
	ctx.lr = 0x829E7BE8;
	sub_829E9C98(ctx, base);
	// 829E7BE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E7BEC: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	pc = 0x829E7BF0; continue 'dispatch;
            }
            0x829E7BF0 => {
    //   block [0x829E7BF0..0x829E7BF8)
	// 829E7BF0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E7BF4: 482C1860  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E7BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E7BF8 size=432
    let mut pc: u32 = 0x829E7BF8;
    'dispatch: loop {
        match pc {
            0x829E7BF8 => {
    //   block [0x829E7BF8..0x829E7C28)
	// 829E7BF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E7BFC: 482C1809  bl 0x82ca9404
	ctx.lr = 0x829E7C00;
	sub_82CA93D0(ctx, base);
	// 829E7C00: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E7C04: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E7C08: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 829E7C0C: 897D0024  lbz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 829E7C10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7C14: 419A0138  beq cr6, 0x829e7d4c
	if ctx.cr[6].eq {
	pc = 0x829E7D4C; continue 'dispatch;
	}
	// 829E7C18: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7C1C: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E7C20: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829E7C24: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829E7C28; continue 'dispatch;
            }
            0x829E7C28 => {
    //   block [0x829E7C28..0x829E7C2C)
	// 829E7C28: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	pc = 0x829E7C2C; continue 'dispatch;
            }
            0x829E7C2C => {
    //   block [0x829E7C2C..0x829E7C40)
	// 829E7C2C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7C30: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E7C34: 419A000C  beq cr6, 0x829e7c40
	if ctx.cr[6].eq {
	pc = 0x829E7C40; continue 'dispatch;
	}
	// 829E7C38: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829E7C3C: 419A0008  beq cr6, 0x829e7c44
	if ctx.cr[6].eq {
	pc = 0x829E7C44; continue 'dispatch;
	}
	pc = 0x829E7C40; continue 'dispatch;
            }
            0x829E7C40 => {
    //   block [0x829E7C40..0x829E7C44)
	// 829E7C40: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7C44; continue 'dispatch;
            }
            0x829E7C44 => {
    //   block [0x829E7C44..0x829E7C58)
	// 829E7C44: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E7C48: 419A0158  beq cr6, 0x829e7da0
	if ctx.cr[6].eq {
	pc = 0x829E7DA0; continue 'dispatch;
	}
	// 829E7C4C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E7C50: 409A0008  bne cr6, 0x829e7c58
	if !ctx.cr[6].eq {
	pc = 0x829E7C58; continue 'dispatch;
	}
	// 829E7C54: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7C58; continue 'dispatch;
            }
            0x829E7C58 => {
    //   block [0x829E7C58..0x829E7C68)
	// 829E7C58: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7C5C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E7C60: 409A0008  bne cr6, 0x829e7c68
	if !ctx.cr[6].eq {
	pc = 0x829E7C68; continue 'dispatch;
	}
	// 829E7C64: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7C68; continue 'dispatch;
            }
            0x829E7C68 => {
    //   block [0x829E7C68..0x829E7CA4)
	// 829E7C68: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E7C6C: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 829E7C70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7C74: 419A0030  beq cr6, 0x829e7ca4
	if ctx.cr[6].eq {
	pc = 0x829E7CA4; continue 'dispatch;
	}
	// 829E7C78: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E7C7C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E7C80: 419A0064  beq cr6, 0x829e7ce4
	if ctx.cr[6].eq {
	pc = 0x829E7CE4; continue 'dispatch;
	}
	// 829E7C84: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E7C88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7C8C: 419A0018  beq cr6, 0x829e7ca4
	if ctx.cr[6].eq {
	pc = 0x829E7CA4; continue 'dispatch;
	}
	// 829E7C90: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E7C94: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E7C98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E7C9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E7CA0: 409A0008  bne cr6, 0x829e7ca8
	if !ctx.cr[6].eq {
	pc = 0x829E7CA8; continue 'dispatch;
	}
	pc = 0x829E7CA4; continue 'dispatch;
            }
            0x829E7CA4 => {
    //   block [0x829E7CA4..0x829E7CA8)
	// 829E7CA4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829E7CA8; continue 'dispatch;
            }
            0x829E7CA8 => {
    //   block [0x829E7CA8..0x829E7CC4)
	// 829E7CA8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E7CAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7CB0: 419A0078  beq cr6, 0x829e7d28
	if ctx.cr[6].eq {
	pc = 0x829E7D28; continue 'dispatch;
	}
	// 829E7CB4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7CB8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E7CBC: 409A0008  bne cr6, 0x829e7cc4
	if !ctx.cr[6].eq {
	pc = 0x829E7CC4; continue 'dispatch;
	}
	// 829E7CC0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7CC4; continue 'dispatch;
            }
            0x829E7CC4 => {
    //   block [0x829E7CC4..0x829E7CE4)
	// 829E7CC4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7CC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7CCC: 419A002C  beq cr6, 0x829e7cf8
	if ctx.cr[6].eq {
	pc = 0x829E7CF8; continue 'dispatch;
	}
	// 829E7CD0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E7CD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E7CD8: 419A0018  beq cr6, 0x829e7cf0
	if ctx.cr[6].eq {
	pc = 0x829E7CF0; continue 'dispatch;
	}
	// 829E7CDC: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 829E7CE0: 4800001C  b 0x829e7cfc
	pc = 0x829E7CFC; continue 'dispatch;
            }
            0x829E7CE4 => {
    //   block [0x829E7CE4..0x829E7CF0)
	// 829E7CE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E7CE8: 4B7AC151  bl 0x82193e38
	ctx.lr = 0x829E7CEC;
	sub_82193E38(ctx, base);
	// 829E7CEC: 4BFFFFB8  b 0x829e7ca4
	pc = 0x829E7CA4; continue 'dispatch;
            }
            0x829E7CF0 => {
    //   block [0x829E7CF0..0x829E7CF8)
	// 829E7CF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E7CF4: 4B7AC145  bl 0x82193e38
	ctx.lr = 0x829E7CF8;
	sub_82193E38(ctx, base);
	pc = 0x829E7CF8; continue 'dispatch;
            }
            0x829E7CF8 => {
    //   block [0x829E7CF8..0x829E7CFC)
	// 829E7CF8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829E7CFC; continue 'dispatch;
            }
            0x829E7CFC => {
    //   block [0x829E7CFC..0x829E7D20)
	// 829E7CFC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829E7D00: 4BB289F1  bl 0x825106f0
	ctx.lr = 0x829E7D04;
	sub_825106F0(ctx, base);
	// 829E7D04: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E7D08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7D0C: 419A001C  beq cr6, 0x829e7d28
	if ctx.cr[6].eq {
	pc = 0x829E7D28; continue 'dispatch;
	}
	// 829E7D10: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7D14: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E7D18: 409A0008  bne cr6, 0x829e7d20
	if !ctx.cr[6].eq {
	pc = 0x829E7D20; continue 'dispatch;
	}
	// 829E7D1C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7D20; continue 'dispatch;
            }
            0x829E7D20 => {
    //   block [0x829E7D20..0x829E7D28)
	// 829E7D20: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E7D24: 4BFFFF04  b 0x829e7c28
	pc = 0x829E7C28; continue 'dispatch;
            }
            0x829E7D28 => {
    //   block [0x829E7D28..0x829E7D4C)
	// 829E7D28: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E7D2C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829E7D30: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E7D34: 4B7A2F3D  bl 0x8218ac70
	ctx.lr = 0x829E7D38;
	sub_8218AC70(ctx, base);
	// 829E7D38: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 829E7D3C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829E7D40: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E7D44: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E7D48: 4BFFFEE4  b 0x829e7c2c
	pc = 0x829E7C2C; continue 'dispatch;
            }
            0x829E7D4C => {
    //   block [0x829E7D4C..0x829E7D88)
	// 829E7D4C: 897D0025  lbz r11, 0x25(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(37 as u32) ) } as u64;
	// 829E7D50: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E7D54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7D58: 419A0030  beq cr6, 0x829e7d88
	if ctx.cr[6].eq {
	pc = 0x829E7D88; continue 'dispatch;
	}
	// 829E7D5C: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E7D60: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829E7D64: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 829E7D68: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 829E7D6C: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 829E7D70: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829E7D74: 48004C25  bl 0x829ec998
	ctx.lr = 0x829E7D78;
	sub_829EC998(ctx, base);
	// 829E7D78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E7D7C: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 829E7D80: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E7D84: 482C16D0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x829E7D88 => {
    //   block [0x829E7D88..0x829E7DA0)
	// 829E7D88: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829E7D8C: 80BD0020  lwz r5, 0x20(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E7D90: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829E7D94: 48002075  bl 0x829e9e08
	ctx.lr = 0x829E7D98;
	sub_829E9E08(ctx, base);
	// 829E7D98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E7D9C: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	pc = 0x829E7DA0; continue 'dispatch;
            }
            0x829E7DA0 => {
    //   block [0x829E7DA0..0x829E7DA8)
	// 829E7DA0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E7DA4: 482C16B0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E7DA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E7DA8 size=432
    let mut pc: u32 = 0x829E7DA8;
    'dispatch: loop {
        match pc {
            0x829E7DA8 => {
    //   block [0x829E7DA8..0x829E7DD8)
	// 829E7DA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E7DAC: 482C1659  bl 0x82ca9404
	ctx.lr = 0x829E7DB0;
	sub_82CA93D0(ctx, base);
	// 829E7DB0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E7DB4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E7DB8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 829E7DBC: 897D0024  lbz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 829E7DC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7DC4: 419A0138  beq cr6, 0x829e7efc
	if ctx.cr[6].eq {
	pc = 0x829E7EFC; continue 'dispatch;
	}
	// 829E7DC8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7DCC: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E7DD0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829E7DD4: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829E7DD8; continue 'dispatch;
            }
            0x829E7DD8 => {
    //   block [0x829E7DD8..0x829E7DDC)
	// 829E7DD8: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	pc = 0x829E7DDC; continue 'dispatch;
            }
            0x829E7DDC => {
    //   block [0x829E7DDC..0x829E7DF0)
	// 829E7DDC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7DE0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E7DE4: 419A000C  beq cr6, 0x829e7df0
	if ctx.cr[6].eq {
	pc = 0x829E7DF0; continue 'dispatch;
	}
	// 829E7DE8: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829E7DEC: 419A0008  beq cr6, 0x829e7df4
	if ctx.cr[6].eq {
	pc = 0x829E7DF4; continue 'dispatch;
	}
	pc = 0x829E7DF0; continue 'dispatch;
            }
            0x829E7DF0 => {
    //   block [0x829E7DF0..0x829E7DF4)
	// 829E7DF0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7DF4; continue 'dispatch;
            }
            0x829E7DF4 => {
    //   block [0x829E7DF4..0x829E7E08)
	// 829E7DF4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E7DF8: 419A0158  beq cr6, 0x829e7f50
	if ctx.cr[6].eq {
	pc = 0x829E7F50; continue 'dispatch;
	}
	// 829E7DFC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E7E00: 409A0008  bne cr6, 0x829e7e08
	if !ctx.cr[6].eq {
	pc = 0x829E7E08; continue 'dispatch;
	}
	// 829E7E04: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7E08; continue 'dispatch;
            }
            0x829E7E08 => {
    //   block [0x829E7E08..0x829E7E18)
	// 829E7E08: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7E0C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E7E10: 409A0008  bne cr6, 0x829e7e18
	if !ctx.cr[6].eq {
	pc = 0x829E7E18; continue 'dispatch;
	}
	// 829E7E14: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7E18; continue 'dispatch;
            }
            0x829E7E18 => {
    //   block [0x829E7E18..0x829E7E54)
	// 829E7E18: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E7E1C: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 829E7E20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7E24: 419A0030  beq cr6, 0x829e7e54
	if ctx.cr[6].eq {
	pc = 0x829E7E54; continue 'dispatch;
	}
	// 829E7E28: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E7E2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E7E30: 419A0064  beq cr6, 0x829e7e94
	if ctx.cr[6].eq {
	pc = 0x829E7E94; continue 'dispatch;
	}
	// 829E7E34: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E7E38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7E3C: 419A0018  beq cr6, 0x829e7e54
	if ctx.cr[6].eq {
	pc = 0x829E7E54; continue 'dispatch;
	}
	// 829E7E40: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E7E44: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E7E48: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E7E4C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E7E50: 409A0008  bne cr6, 0x829e7e58
	if !ctx.cr[6].eq {
	pc = 0x829E7E58; continue 'dispatch;
	}
	pc = 0x829E7E54; continue 'dispatch;
            }
            0x829E7E54 => {
    //   block [0x829E7E54..0x829E7E58)
	// 829E7E54: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829E7E58; continue 'dispatch;
            }
            0x829E7E58 => {
    //   block [0x829E7E58..0x829E7E74)
	// 829E7E58: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E7E5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7E60: 419A0078  beq cr6, 0x829e7ed8
	if ctx.cr[6].eq {
	pc = 0x829E7ED8; continue 'dispatch;
	}
	// 829E7E64: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7E68: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E7E6C: 409A0008  bne cr6, 0x829e7e74
	if !ctx.cr[6].eq {
	pc = 0x829E7E74; continue 'dispatch;
	}
	// 829E7E70: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7E74; continue 'dispatch;
            }
            0x829E7E74 => {
    //   block [0x829E7E74..0x829E7E94)
	// 829E7E74: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7E78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7E7C: 419A002C  beq cr6, 0x829e7ea8
	if ctx.cr[6].eq {
	pc = 0x829E7EA8; continue 'dispatch;
	}
	// 829E7E80: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E7E84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E7E88: 419A0018  beq cr6, 0x829e7ea0
	if ctx.cr[6].eq {
	pc = 0x829E7EA0; continue 'dispatch;
	}
	// 829E7E8C: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 829E7E90: 4800001C  b 0x829e7eac
	pc = 0x829E7EAC; continue 'dispatch;
            }
            0x829E7E94 => {
    //   block [0x829E7E94..0x829E7EA0)
	// 829E7E94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E7E98: 4B7ABFA1  bl 0x82193e38
	ctx.lr = 0x829E7E9C;
	sub_82193E38(ctx, base);
	// 829E7E9C: 4BFFFFB8  b 0x829e7e54
	pc = 0x829E7E54; continue 'dispatch;
            }
            0x829E7EA0 => {
    //   block [0x829E7EA0..0x829E7EA8)
	// 829E7EA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E7EA4: 4B7ABF95  bl 0x82193e38
	ctx.lr = 0x829E7EA8;
	sub_82193E38(ctx, base);
	pc = 0x829E7EA8; continue 'dispatch;
            }
            0x829E7EA8 => {
    //   block [0x829E7EA8..0x829E7EAC)
	// 829E7EA8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829E7EAC; continue 'dispatch;
            }
            0x829E7EAC => {
    //   block [0x829E7EAC..0x829E7ED0)
	// 829E7EAC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829E7EB0: 4BB2A2C9  bl 0x82512178
	ctx.lr = 0x829E7EB4;
	sub_82512178(ctx, base);
	// 829E7EB4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E7EB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7EBC: 419A001C  beq cr6, 0x829e7ed8
	if ctx.cr[6].eq {
	pc = 0x829E7ED8; continue 'dispatch;
	}
	// 829E7EC0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7EC4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E7EC8: 409A0008  bne cr6, 0x829e7ed0
	if !ctx.cr[6].eq {
	pc = 0x829E7ED0; continue 'dispatch;
	}
	// 829E7ECC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7ED0; continue 'dispatch;
            }
            0x829E7ED0 => {
    //   block [0x829E7ED0..0x829E7ED8)
	// 829E7ED0: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E7ED4: 4BFFFF04  b 0x829e7dd8
	pc = 0x829E7DD8; continue 'dispatch;
            }
            0x829E7ED8 => {
    //   block [0x829E7ED8..0x829E7EFC)
	// 829E7ED8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E7EDC: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829E7EE0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E7EE4: 4B7A2D8D  bl 0x8218ac70
	ctx.lr = 0x829E7EE8;
	sub_8218AC70(ctx, base);
	// 829E7EE8: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 829E7EEC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829E7EF0: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E7EF4: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E7EF8: 4BFFFEE4  b 0x829e7ddc
	pc = 0x829E7DDC; continue 'dispatch;
            }
            0x829E7EFC => {
    //   block [0x829E7EFC..0x829E7F38)
	// 829E7EFC: 897D0025  lbz r11, 0x25(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(37 as u32) ) } as u64;
	// 829E7F00: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E7F04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7F08: 419A0030  beq cr6, 0x829e7f38
	if ctx.cr[6].eq {
	pc = 0x829E7F38; continue 'dispatch;
	}
	// 829E7F0C: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E7F10: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829E7F14: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 829E7F18: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 829E7F1C: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 829E7F20: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829E7F24: 48004C8D  bl 0x829ecbb0
	ctx.lr = 0x829E7F28;
	sub_829ECBB0(ctx, base);
	// 829E7F28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E7F2C: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 829E7F30: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E7F34: 482C1520  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x829E7F38 => {
    //   block [0x829E7F38..0x829E7F50)
	// 829E7F38: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829E7F3C: 80BD0020  lwz r5, 0x20(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E7F40: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829E7F44: 48002035  bl 0x829e9f78
	ctx.lr = 0x829E7F48;
	sub_829E9F78(ctx, base);
	// 829E7F48: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E7F4C: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	pc = 0x829E7F50; continue 'dispatch;
            }
            0x829E7F50 => {
    //   block [0x829E7F50..0x829E7F58)
	// 829E7F50: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E7F54: 482C1500  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E7F58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E7F58 size=488
    let mut pc: u32 = 0x829E7F58;
    'dispatch: loop {
        match pc {
            0x829E7F58 => {
    //   block [0x829E7F58..0x829E7F88)
	// 829E7F58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E7F5C: 482C14A9  bl 0x82ca9404
	ctx.lr = 0x829E7F60;
	sub_82CA93D0(ctx, base);
	// 829E7F60: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E7F64: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E7F68: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 829E7F6C: 897D0024  lbz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 829E7F70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7F74: 419A0170  beq cr6, 0x829e80e4
	if ctx.cr[6].eq {
	pc = 0x829E80E4; continue 'dispatch;
	}
	// 829E7F78: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7F7C: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E7F80: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829E7F84: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829E7F88; continue 'dispatch;
            }
            0x829E7F88 => {
    //   block [0x829E7F88..0x829E7F8C)
	// 829E7F88: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	pc = 0x829E7F8C; continue 'dispatch;
            }
            0x829E7F8C => {
    //   block [0x829E7F8C..0x829E7FA0)
	// 829E7F8C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7F90: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E7F94: 419A000C  beq cr6, 0x829e7fa0
	if ctx.cr[6].eq {
	pc = 0x829E7FA0; continue 'dispatch;
	}
	// 829E7F98: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829E7F9C: 419A0008  beq cr6, 0x829e7fa4
	if ctx.cr[6].eq {
	pc = 0x829E7FA4; continue 'dispatch;
	}
	pc = 0x829E7FA0; continue 'dispatch;
            }
            0x829E7FA0 => {
    //   block [0x829E7FA0..0x829E7FA4)
	// 829E7FA0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7FA4; continue 'dispatch;
            }
            0x829E7FA4 => {
    //   block [0x829E7FA4..0x829E7FB8)
	// 829E7FA4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E7FA8: 419A0190  beq cr6, 0x829e8138
	if ctx.cr[6].eq {
	pc = 0x829E8138; continue 'dispatch;
	}
	// 829E7FAC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E7FB0: 409A0008  bne cr6, 0x829e7fb8
	if !ctx.cr[6].eq {
	pc = 0x829E7FB8; continue 'dispatch;
	}
	// 829E7FB4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7FB8; continue 'dispatch;
            }
            0x829E7FB8 => {
    //   block [0x829E7FB8..0x829E7FC8)
	// 829E7FB8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7FBC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E7FC0: 409A0008  bne cr6, 0x829e7fc8
	if !ctx.cr[6].eq {
	pc = 0x829E7FC8; continue 'dispatch;
	}
	// 829E7FC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E7FC8; continue 'dispatch;
            }
            0x829E7FC8 => {
    //   block [0x829E7FC8..0x829E8004)
	// 829E7FC8: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E7FCC: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 829E7FD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7FD4: 419A0030  beq cr6, 0x829e8004
	if ctx.cr[6].eq {
	pc = 0x829E8004; continue 'dispatch;
	}
	// 829E7FD8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E7FDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E7FE0: 419A0064  beq cr6, 0x829e8044
	if ctx.cr[6].eq {
	pc = 0x829E8044; continue 'dispatch;
	}
	// 829E7FE4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E7FE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7FEC: 419A0018  beq cr6, 0x829e8004
	if ctx.cr[6].eq {
	pc = 0x829E8004; continue 'dispatch;
	}
	// 829E7FF0: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E7FF4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E7FF8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E7FFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E8000: 409A0008  bne cr6, 0x829e8008
	if !ctx.cr[6].eq {
	pc = 0x829E8008; continue 'dispatch;
	}
	pc = 0x829E8004; continue 'dispatch;
            }
            0x829E8004 => {
    //   block [0x829E8004..0x829E8008)
	// 829E8004: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829E8008; continue 'dispatch;
            }
            0x829E8008 => {
    //   block [0x829E8008..0x829E8024)
	// 829E8008: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E800C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8010: 419A00B0  beq cr6, 0x829e80c0
	if ctx.cr[6].eq {
	pc = 0x829E80C0; continue 'dispatch;
	}
	// 829E8014: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E8018: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E801C: 409A0008  bne cr6, 0x829e8024
	if !ctx.cr[6].eq {
	pc = 0x829E8024; continue 'dispatch;
	}
	// 829E8020: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E8024; continue 'dispatch;
            }
            0x829E8024 => {
    //   block [0x829E8024..0x829E8044)
	// 829E8024: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E8028: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E802C: 419A002C  beq cr6, 0x829e8058
	if ctx.cr[6].eq {
	pc = 0x829E8058; continue 'dispatch;
	}
	// 829E8030: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8034: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E8038: 419A0018  beq cr6, 0x829e8050
	if ctx.cr[6].eq {
	pc = 0x829E8050; continue 'dispatch;
	}
	// 829E803C: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 829E8040: 4800001C  b 0x829e805c
	pc = 0x829E805C; continue 'dispatch;
            }
            0x829E8044 => {
    //   block [0x829E8044..0x829E8050)
	// 829E8044: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E8048: 4B7ABDF1  bl 0x82193e38
	ctx.lr = 0x829E804C;
	sub_82193E38(ctx, base);
	// 829E804C: 4BFFFFB8  b 0x829e8004
	pc = 0x829E8004; continue 'dispatch;
            }
            0x829E8050 => {
    //   block [0x829E8050..0x829E8058)
	// 829E8050: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E8054: 4B7ABDE5  bl 0x82193e38
	ctx.lr = 0x829E8058;
	sub_82193E38(ctx, base);
	pc = 0x829E8058; continue 'dispatch;
            }
            0x829E8058 => {
    //   block [0x829E8058..0x829E805C)
	// 829E8058: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829E805C; continue 'dispatch;
            }
            0x829E805C => {
    //   block [0x829E805C..0x829E8098)
	// 829E805C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8060: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8064: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829E8068: 419A0030  beq cr6, 0x829e8098
	if ctx.cr[6].eq {
	pc = 0x829E8098; continue 'dispatch;
	}
	// 829E806C: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E8070: 4BB28F31  bl 0x82510fa0
	ctx.lr = 0x829E8074;
	sub_82510FA0(ctx, base);
	// 829E8074: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E8078: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E807C: 419A001C  beq cr6, 0x829e8098
	if ctx.cr[6].eq {
	pc = 0x829E8098; continue 'dispatch;
	}
	// 829E8080: 807B0008  lwz r3, 8(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E8084: 4B818065  bl 0x822000e8
	ctx.lr = 0x829E8088;
	sub_822000E8(ctx, base);
	// 829E8088: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E808C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8090: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E8094: 409A0008  bne cr6, 0x829e809c
	if !ctx.cr[6].eq {
	pc = 0x829E809C; continue 'dispatch;
	}
	pc = 0x829E8098; continue 'dispatch;
            }
            0x829E8098 => {
    //   block [0x829E8098..0x829E809C)
	// 829E8098: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829E809C; continue 'dispatch;
            }
            0x829E809C => {
    //   block [0x829E809C..0x829E80B8)
	// 829E809C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E80A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E80A4: 419A001C  beq cr6, 0x829e80c0
	if ctx.cr[6].eq {
	pc = 0x829E80C0; continue 'dispatch;
	}
	// 829E80A8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E80AC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E80B0: 409A0008  bne cr6, 0x829e80b8
	if !ctx.cr[6].eq {
	pc = 0x829E80B8; continue 'dispatch;
	}
	// 829E80B4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E80B8; continue 'dispatch;
            }
            0x829E80B8 => {
    //   block [0x829E80B8..0x829E80C0)
	// 829E80B8: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E80BC: 4BFFFECC  b 0x829e7f88
	pc = 0x829E7F88; continue 'dispatch;
            }
            0x829E80C0 => {
    //   block [0x829E80C0..0x829E80E4)
	// 829E80C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E80C4: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829E80C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E80CC: 4B7A2BA5  bl 0x8218ac70
	ctx.lr = 0x829E80D0;
	sub_8218AC70(ctx, base);
	// 829E80D0: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 829E80D4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829E80D8: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E80DC: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E80E0: 4BFFFEAC  b 0x829e7f8c
	pc = 0x829E7F8C; continue 'dispatch;
            }
            0x829E80E4 => {
    //   block [0x829E80E4..0x829E8120)
	// 829E80E4: 897D0025  lbz r11, 0x25(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(37 as u32) ) } as u64;
	// 829E80E8: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E80EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E80F0: 419A0030  beq cr6, 0x829e8120
	if ctx.cr[6].eq {
	pc = 0x829E8120; continue 'dispatch;
	}
	// 829E80F4: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E80F8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829E80FC: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 829E8100: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 829E8104: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 829E8108: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829E810C: 48004CC5  bl 0x829ecdd0
	ctx.lr = 0x829E8110;
	sub_829ECDD0(ctx, base);
	// 829E8110: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E8114: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 829E8118: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E811C: 482C1338  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x829E8120 => {
    //   block [0x829E8120..0x829E8138)
	// 829E8120: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829E8124: 80BD0020  lwz r5, 0x20(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E8128: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829E812C: 48001FC5  bl 0x829ea0f0
	ctx.lr = 0x829E8130;
	sub_829EA0F0(ctx, base);
	// 829E8130: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E8134: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	pc = 0x829E8138; continue 'dispatch;
            }
            0x829E8138 => {
    //   block [0x829E8138..0x829E8140)
	// 829E8138: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E813C: 482C1318  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E8140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E8140 size=432
    let mut pc: u32 = 0x829E8140;
    'dispatch: loop {
        match pc {
            0x829E8140 => {
    //   block [0x829E8140..0x829E8170)
	// 829E8140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E8144: 482C12C1  bl 0x82ca9404
	ctx.lr = 0x829E8148;
	sub_82CA93D0(ctx, base);
	// 829E8148: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E814C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E8150: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 829E8154: 897D0024  lbz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 829E8158: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E815C: 419A0138  beq cr6, 0x829e8294
	if ctx.cr[6].eq {
	pc = 0x829E8294; continue 'dispatch;
	}
	// 829E8160: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E8164: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E8168: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829E816C: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829E8170; continue 'dispatch;
            }
            0x829E8170 => {
    //   block [0x829E8170..0x829E8174)
	// 829E8170: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	pc = 0x829E8174; continue 'dispatch;
            }
            0x829E8174 => {
    //   block [0x829E8174..0x829E8188)
	// 829E8174: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E8178: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E817C: 419A000C  beq cr6, 0x829e8188
	if ctx.cr[6].eq {
	pc = 0x829E8188; continue 'dispatch;
	}
	// 829E8180: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829E8184: 419A0008  beq cr6, 0x829e818c
	if ctx.cr[6].eq {
	pc = 0x829E818C; continue 'dispatch;
	}
	pc = 0x829E8188; continue 'dispatch;
            }
            0x829E8188 => {
    //   block [0x829E8188..0x829E818C)
	// 829E8188: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E818C; continue 'dispatch;
            }
            0x829E818C => {
    //   block [0x829E818C..0x829E81A0)
	// 829E818C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E8190: 419A0158  beq cr6, 0x829e82e8
	if ctx.cr[6].eq {
	pc = 0x829E82E8; continue 'dispatch;
	}
	// 829E8194: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E8198: 409A0008  bne cr6, 0x829e81a0
	if !ctx.cr[6].eq {
	pc = 0x829E81A0; continue 'dispatch;
	}
	// 829E819C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E81A0; continue 'dispatch;
            }
            0x829E81A0 => {
    //   block [0x829E81A0..0x829E81B0)
	// 829E81A0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E81A4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E81A8: 409A0008  bne cr6, 0x829e81b0
	if !ctx.cr[6].eq {
	pc = 0x829E81B0; continue 'dispatch;
	}
	// 829E81AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E81B0; continue 'dispatch;
            }
            0x829E81B0 => {
    //   block [0x829E81B0..0x829E81EC)
	// 829E81B0: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E81B4: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 829E81B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E81BC: 419A0030  beq cr6, 0x829e81ec
	if ctx.cr[6].eq {
	pc = 0x829E81EC; continue 'dispatch;
	}
	// 829E81C0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E81C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E81C8: 419A0064  beq cr6, 0x829e822c
	if ctx.cr[6].eq {
	pc = 0x829E822C; continue 'dispatch;
	}
	// 829E81CC: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E81D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E81D4: 419A0018  beq cr6, 0x829e81ec
	if ctx.cr[6].eq {
	pc = 0x829E81EC; continue 'dispatch;
	}
	// 829E81D8: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E81DC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E81E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E81E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E81E8: 409A0008  bne cr6, 0x829e81f0
	if !ctx.cr[6].eq {
	pc = 0x829E81F0; continue 'dispatch;
	}
	pc = 0x829E81EC; continue 'dispatch;
            }
            0x829E81EC => {
    //   block [0x829E81EC..0x829E81F0)
	// 829E81EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829E81F0; continue 'dispatch;
            }
            0x829E81F0 => {
    //   block [0x829E81F0..0x829E820C)
	// 829E81F0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E81F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E81F8: 419A0078  beq cr6, 0x829e8270
	if ctx.cr[6].eq {
	pc = 0x829E8270; continue 'dispatch;
	}
	// 829E81FC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E8200: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E8204: 409A0008  bne cr6, 0x829e820c
	if !ctx.cr[6].eq {
	pc = 0x829E820C; continue 'dispatch;
	}
	// 829E8208: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E820C; continue 'dispatch;
            }
            0x829E820C => {
    //   block [0x829E820C..0x829E822C)
	// 829E820C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E8210: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8214: 419A002C  beq cr6, 0x829e8240
	if ctx.cr[6].eq {
	pc = 0x829E8240; continue 'dispatch;
	}
	// 829E8218: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E821C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E8220: 419A0018  beq cr6, 0x829e8238
	if ctx.cr[6].eq {
	pc = 0x829E8238; continue 'dispatch;
	}
	// 829E8224: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 829E8228: 4800001C  b 0x829e8244
	pc = 0x829E8244; continue 'dispatch;
            }
            0x829E822C => {
    //   block [0x829E822C..0x829E8238)
	// 829E822C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E8230: 4B7ABC09  bl 0x82193e38
	ctx.lr = 0x829E8234;
	sub_82193E38(ctx, base);
	// 829E8234: 4BFFFFB8  b 0x829e81ec
	pc = 0x829E81EC; continue 'dispatch;
            }
            0x829E8238 => {
    //   block [0x829E8238..0x829E8240)
	// 829E8238: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E823C: 4B7ABBFD  bl 0x82193e38
	ctx.lr = 0x829E8240;
	sub_82193E38(ctx, base);
	pc = 0x829E8240; continue 'dispatch;
            }
            0x829E8240 => {
    //   block [0x829E8240..0x829E8244)
	// 829E8240: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829E8244; continue 'dispatch;
            }
            0x829E8244 => {
    //   block [0x829E8244..0x829E8268)
	// 829E8244: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829E8248: 4BB29AC9  bl 0x82511d10
	ctx.lr = 0x829E824C;
	sub_82511D10(ctx, base);
	// 829E824C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E8250: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8254: 419A001C  beq cr6, 0x829e8270
	if ctx.cr[6].eq {
	pc = 0x829E8270; continue 'dispatch;
	}
	// 829E8258: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E825C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E8260: 409A0008  bne cr6, 0x829e8268
	if !ctx.cr[6].eq {
	pc = 0x829E8268; continue 'dispatch;
	}
	// 829E8264: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E8268; continue 'dispatch;
            }
            0x829E8268 => {
    //   block [0x829E8268..0x829E8270)
	// 829E8268: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E826C: 4BFFFF04  b 0x829e8170
	pc = 0x829E8170; continue 'dispatch;
            }
            0x829E8270 => {
    //   block [0x829E8270..0x829E8294)
	// 829E8270: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E8274: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829E8278: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E827C: 4B7A29F5  bl 0x8218ac70
	ctx.lr = 0x829E8280;
	sub_8218AC70(ctx, base);
	// 829E8280: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 829E8284: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829E8288: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E828C: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E8290: 4BFFFEE4  b 0x829e8174
	pc = 0x829E8174; continue 'dispatch;
            }
            0x829E8294 => {
    //   block [0x829E8294..0x829E82D0)
	// 829E8294: 897D0025  lbz r11, 0x25(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(37 as u32) ) } as u64;
	// 829E8298: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E829C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E82A0: 419A0030  beq cr6, 0x829e82d0
	if ctx.cr[6].eq {
	pc = 0x829E82D0; continue 'dispatch;
	}
	// 829E82A4: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E82A8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829E82AC: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 829E82B0: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 829E82B4: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 829E82B8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829E82BC: 48004CA5  bl 0x829ecf60
	ctx.lr = 0x829E82C0;
	sub_829ECF60(ctx, base);
	// 829E82C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E82C4: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 829E82C8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E82CC: 482C1188  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x829E82D0 => {
    //   block [0x829E82D0..0x829E82E8)
	// 829E82D0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829E82D4: 80BD0020  lwz r5, 0x20(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E82D8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829E82DC: 48001FC5  bl 0x829ea2a0
	ctx.lr = 0x829E82E0;
	sub_829EA2A0(ctx, base);
	// 829E82E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E82E4: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	pc = 0x829E82E8; continue 'dispatch;
            }
            0x829E82E8 => {
    //   block [0x829E82E8..0x829E82F0)
	// 829E82E8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E82EC: 482C1168  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E82F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E82F0 size=432
    let mut pc: u32 = 0x829E82F0;
    'dispatch: loop {
        match pc {
            0x829E82F0 => {
    //   block [0x829E82F0..0x829E8320)
	// 829E82F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E82F4: 482C1111  bl 0x82ca9404
	ctx.lr = 0x829E82F8;
	sub_82CA93D0(ctx, base);
	// 829E82F8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E82FC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E8300: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 829E8304: 897D0024  lbz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 829E8308: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E830C: 419A0138  beq cr6, 0x829e8444
	if ctx.cr[6].eq {
	pc = 0x829E8444; continue 'dispatch;
	}
	// 829E8310: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E8314: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E8318: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829E831C: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829E8320; continue 'dispatch;
            }
            0x829E8320 => {
    //   block [0x829E8320..0x829E8324)
	// 829E8320: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	pc = 0x829E8324; continue 'dispatch;
            }
            0x829E8324 => {
    //   block [0x829E8324..0x829E8338)
	// 829E8324: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E8328: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E832C: 419A000C  beq cr6, 0x829e8338
	if ctx.cr[6].eq {
	pc = 0x829E8338; continue 'dispatch;
	}
	// 829E8330: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829E8334: 419A0008  beq cr6, 0x829e833c
	if ctx.cr[6].eq {
	pc = 0x829E833C; continue 'dispatch;
	}
	pc = 0x829E8338; continue 'dispatch;
            }
            0x829E8338 => {
    //   block [0x829E8338..0x829E833C)
	// 829E8338: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E833C; continue 'dispatch;
            }
            0x829E833C => {
    //   block [0x829E833C..0x829E8350)
	// 829E833C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E8340: 419A0158  beq cr6, 0x829e8498
	if ctx.cr[6].eq {
	pc = 0x829E8498; continue 'dispatch;
	}
	// 829E8344: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E8348: 409A0008  bne cr6, 0x829e8350
	if !ctx.cr[6].eq {
	pc = 0x829E8350; continue 'dispatch;
	}
	// 829E834C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E8350; continue 'dispatch;
            }
            0x829E8350 => {
    //   block [0x829E8350..0x829E8360)
	// 829E8350: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E8354: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E8358: 409A0008  bne cr6, 0x829e8360
	if !ctx.cr[6].eq {
	pc = 0x829E8360; continue 'dispatch;
	}
	// 829E835C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E8360; continue 'dispatch;
            }
            0x829E8360 => {
    //   block [0x829E8360..0x829E839C)
	// 829E8360: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E8364: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 829E8368: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E836C: 419A0030  beq cr6, 0x829e839c
	if ctx.cr[6].eq {
	pc = 0x829E839C; continue 'dispatch;
	}
	// 829E8370: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8374: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E8378: 419A0064  beq cr6, 0x829e83dc
	if ctx.cr[6].eq {
	pc = 0x829E83DC; continue 'dispatch;
	}
	// 829E837C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E8380: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8384: 419A0018  beq cr6, 0x829e839c
	if ctx.cr[6].eq {
	pc = 0x829E839C; continue 'dispatch;
	}
	// 829E8388: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E838C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E8390: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E8394: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E8398: 409A0008  bne cr6, 0x829e83a0
	if !ctx.cr[6].eq {
	pc = 0x829E83A0; continue 'dispatch;
	}
	pc = 0x829E839C; continue 'dispatch;
            }
            0x829E839C => {
    //   block [0x829E839C..0x829E83A0)
	// 829E839C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829E83A0; continue 'dispatch;
            }
            0x829E83A0 => {
    //   block [0x829E83A0..0x829E83BC)
	// 829E83A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E83A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E83A8: 419A0078  beq cr6, 0x829e8420
	if ctx.cr[6].eq {
	pc = 0x829E8420; continue 'dispatch;
	}
	// 829E83AC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E83B0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E83B4: 409A0008  bne cr6, 0x829e83bc
	if !ctx.cr[6].eq {
	pc = 0x829E83BC; continue 'dispatch;
	}
	// 829E83B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E83BC; continue 'dispatch;
            }
            0x829E83BC => {
    //   block [0x829E83BC..0x829E83DC)
	// 829E83BC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E83C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E83C4: 419A002C  beq cr6, 0x829e83f0
	if ctx.cr[6].eq {
	pc = 0x829E83F0; continue 'dispatch;
	}
	// 829E83C8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E83CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E83D0: 419A0018  beq cr6, 0x829e83e8
	if ctx.cr[6].eq {
	pc = 0x829E83E8; continue 'dispatch;
	}
	// 829E83D4: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 829E83D8: 4800001C  b 0x829e83f4
	pc = 0x829E83F4; continue 'dispatch;
            }
            0x829E83DC => {
    //   block [0x829E83DC..0x829E83E8)
	// 829E83DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E83E0: 4B7ABA59  bl 0x82193e38
	ctx.lr = 0x829E83E4;
	sub_82193E38(ctx, base);
	// 829E83E4: 4BFFFFB8  b 0x829e839c
	pc = 0x829E839C; continue 'dispatch;
            }
            0x829E83E8 => {
    //   block [0x829E83E8..0x829E83F0)
	// 829E83E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E83EC: 4B7ABA4D  bl 0x82193e38
	ctx.lr = 0x829E83F0;
	sub_82193E38(ctx, base);
	pc = 0x829E83F0; continue 'dispatch;
            }
            0x829E83F0 => {
    //   block [0x829E83F0..0x829E83F4)
	// 829E83F0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829E83F4; continue 'dispatch;
            }
            0x829E83F4 => {
    //   block [0x829E83F4..0x829E8418)
	// 829E83F4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829E83F8: 4BBFE499  bl 0x825e6890
	ctx.lr = 0x829E83FC;
	sub_825E6890(ctx, base);
	// 829E83FC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E8400: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8404: 419A001C  beq cr6, 0x829e8420
	if ctx.cr[6].eq {
	pc = 0x829E8420; continue 'dispatch;
	}
	// 829E8408: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E840C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E8410: 409A0008  bne cr6, 0x829e8418
	if !ctx.cr[6].eq {
	pc = 0x829E8418; continue 'dispatch;
	}
	// 829E8414: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829E8418; continue 'dispatch;
            }
            0x829E8418 => {
    //   block [0x829E8418..0x829E8420)
	// 829E8418: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E841C: 4BFFFF04  b 0x829e8320
	pc = 0x829E8320; continue 'dispatch;
            }
            0x829E8420 => {
    //   block [0x829E8420..0x829E8444)
	// 829E8420: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E8424: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829E8428: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E842C: 4B7A2845  bl 0x8218ac70
	ctx.lr = 0x829E8430;
	sub_8218AC70(ctx, base);
	// 829E8430: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 829E8434: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829E8438: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E843C: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E8440: 4BFFFEE4  b 0x829e8324
	pc = 0x829E8324; continue 'dispatch;
            }
            0x829E8444 => {
    //   block [0x829E8444..0x829E8480)
	// 829E8444: 897D0025  lbz r11, 0x25(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(37 as u32) ) } as u64;
	// 829E8448: 807D000C  lwz r3, 0xc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E844C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8450: 419A0030  beq cr6, 0x829e8480
	if ctx.cr[6].eq {
	pc = 0x829E8480; continue 'dispatch;
	}
	// 829E8454: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E8458: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829E845C: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 829E8460: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 829E8464: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 829E8468: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829E846C: 48004D15  bl 0x829ed180
	ctx.lr = 0x829E8470;
	sub_829ED180(ctx, base);
	// 829E8470: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E8474: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 829E8478: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E847C: 482C0FD8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x829E8480 => {
    //   block [0x829E8480..0x829E8498)
	// 829E8480: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829E8484: 80BD0020  lwz r5, 0x20(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E8488: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829E848C: 48001F8D  bl 0x829ea418
	ctx.lr = 0x829E8490;
	sub_829EA418(ctx, base);
	// 829E8490: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E8494: 997D0024  stb r11, 0x24(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	pc = 0x829E8498; continue 'dispatch;
            }
            0x829E8498 => {
    //   block [0x829E8498..0x829E84A0)
	// 829E8498: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E849C: 482C0FB8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E84A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E84A0 size=148
    let mut pc: u32 = 0x829E84A0;
    'dispatch: loop {
        match pc {
            0x829E84A0 => {
    //   block [0x829E84A0..0x829E852C)
	// 829E84A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E84A4: 482C0F65  bl 0x82ca9408
	ctx.lr = 0x829E84A8;
	sub_82CA93D0(ctx, base);
	// 829E84A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E84AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E84B0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829E84B4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829E84B8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E84BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E84C0: 419A006C  beq cr6, 0x829e852c
	if ctx.cr[6].eq {
	pc = 0x829E852C; continue 'dispatch;
	}
	// 829E84C4: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E84C8: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 829E84CC: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E84D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E84D4: 4B840C35  bl 0x82229108
	ctx.lr = 0x829E84D8;
	sub_82229108(ctx, base);
	// 829E84D8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 829E84DC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E84E0: 4B83F3A1  bl 0x82227880
	ctx.lr = 0x829E84E4;
	sub_82227880(ctx, base);
	// 829E84E4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829E84E8: 3D40829F  lis r10, -0x7d61
	ctx.r[10].s64 = -2103508992;
	// 829E84EC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829E84F0: 388AA970  addi r4, r10, -0x5690
	ctx.r[4].s64 = ctx.r[10].s64 + -22160;
	// 829E84F4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E84F8: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 829E84FC: 4B7B2585  bl 0x8219aa80
	ctx.lr = 0x829E8500;
	sub_8219AA80(ctx, base);
	// 829E8500: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829E8504: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829E8508: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E850C: 4B9E5F15  bl 0x823ce420
	ctx.lr = 0x829E8510;
	sub_823CE420(ctx, base);
	// 829E8510: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829E8514: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 829E8518: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E851C: 4803C1AD  bl 0x82a246c8
	ctx.lr = 0x829E8520;
	sub_82A246C8(ctx, base);
	// 829E8520: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E8524: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 829E8528: 913C0008  stw r9, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x829E852C; continue 'dispatch;
            }
            0x829E852C => {
    //   block [0x829E852C..0x829E8534)
	// 829E852C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829E8530: 482C0F28  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E8538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E8538 size=148
    let mut pc: u32 = 0x829E8538;
    'dispatch: loop {
        match pc {
            0x829E8538 => {
    //   block [0x829E8538..0x829E85C4)
	// 829E8538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E853C: 482C0ECD  bl 0x82ca9408
	ctx.lr = 0x829E8540;
	sub_82CA93D0(ctx, base);
	// 829E8540: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E8544: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E8548: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829E854C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829E8550: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8554: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8558: 419A006C  beq cr6, 0x829e85c4
	if ctx.cr[6].eq {
	pc = 0x829E85C4; continue 'dispatch;
	}
	// 829E855C: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8560: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 829E8564: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E8568: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E856C: 4B840B9D  bl 0x82229108
	ctx.lr = 0x829E8570;
	sub_82229108(ctx, base);
	// 829E8570: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 829E8574: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E8578: 4B83F309  bl 0x82227880
	ctx.lr = 0x829E857C;
	sub_82227880(ctx, base);
	// 829E857C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829E8580: 3D40829F  lis r10, -0x7d61
	ctx.r[10].s64 = -2103508992;
	// 829E8584: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829E8588: 388AA630  addi r4, r10, -0x59d0
	ctx.r[4].s64 = ctx.r[10].s64 + -22992;
	// 829E858C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E8590: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 829E8594: 4B7B24ED  bl 0x8219aa80
	ctx.lr = 0x829E8598;
	sub_8219AA80(ctx, base);
	// 829E8598: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829E859C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829E85A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E85A4: 4B9E5E7D  bl 0x823ce420
	ctx.lr = 0x829E85A8;
	sub_823CE420(ctx, base);
	// 829E85A8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829E85AC: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 829E85B0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E85B4: 4803C115  bl 0x82a246c8
	ctx.lr = 0x829E85B8;
	sub_82A246C8(ctx, base);
	// 829E85B8: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E85BC: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 829E85C0: 913C0008  stw r9, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x829E85C4; continue 'dispatch;
            }
            0x829E85C4 => {
    //   block [0x829E85C4..0x829E85CC)
	// 829E85C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829E85C8: 482C0E90  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E85D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E85D0 size=148
    let mut pc: u32 = 0x829E85D0;
    'dispatch: loop {
        match pc {
            0x829E85D0 => {
    //   block [0x829E85D0..0x829E865C)
	// 829E85D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E85D4: 482C0E35  bl 0x82ca9408
	ctx.lr = 0x829E85D8;
	sub_82CA93D0(ctx, base);
	// 829E85D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E85DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E85E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829E85E4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829E85E8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E85EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E85F0: 419A006C  beq cr6, 0x829e865c
	if ctx.cr[6].eq {
	pc = 0x829E865C; continue 'dispatch;
	}
	// 829E85F4: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E85F8: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 829E85FC: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E8600: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E8604: 4B840B05  bl 0x82229108
	ctx.lr = 0x829E8608;
	sub_82229108(ctx, base);
	// 829E8608: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 829E860C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E8610: 4B83F271  bl 0x82227880
	ctx.lr = 0x829E8614;
	sub_82227880(ctx, base);
	// 829E8614: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829E8618: 3D40829F  lis r10, -0x7d61
	ctx.r[10].s64 = -2103508992;
	// 829E861C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829E8620: 388AA7E0  addi r4, r10, -0x5820
	ctx.r[4].s64 = ctx.r[10].s64 + -22560;
	// 829E8624: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E8628: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 829E862C: 4B7B2455  bl 0x8219aa80
	ctx.lr = 0x829E8630;
	sub_8219AA80(ctx, base);
	// 829E8630: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829E8634: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829E8638: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E863C: 4B9E5DE5  bl 0x823ce420
	ctx.lr = 0x829E8640;
	sub_823CE420(ctx, base);
	// 829E8640: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829E8644: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 829E8648: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E864C: 4803C07D  bl 0x82a246c8
	ctx.lr = 0x829E8650;
	sub_82A246C8(ctx, base);
	// 829E8650: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E8654: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 829E8658: 913C0008  stw r9, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x829E865C; continue 'dispatch;
            }
            0x829E865C => {
    //   block [0x829E865C..0x829E8664)
	// 829E865C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829E8660: 482C0DF8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E8668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E8668 size=148
    let mut pc: u32 = 0x829E8668;
    'dispatch: loop {
        match pc {
            0x829E8668 => {
    //   block [0x829E8668..0x829E86F4)
	// 829E8668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E866C: 482C0D9D  bl 0x82ca9408
	ctx.lr = 0x829E8670;
	sub_82CA93D0(ctx, base);
	// 829E8670: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E8674: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E8678: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829E867C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829E8680: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8684: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8688: 419A006C  beq cr6, 0x829e86f4
	if ctx.cr[6].eq {
	pc = 0x829E86F4; continue 'dispatch;
	}
	// 829E868C: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8690: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 829E8694: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E8698: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E869C: 4B840A6D  bl 0x82229108
	ctx.lr = 0x829E86A0;
	sub_82229108(ctx, base);
	// 829E86A0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 829E86A4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E86A8: 4B83F1D9  bl 0x82227880
	ctx.lr = 0x829E86AC;
	sub_82227880(ctx, base);
	// 829E86AC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829E86B0: 3D40829F  lis r10, -0x7d61
	ctx.r[10].s64 = -2103508992;
	// 829E86B4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829E86B8: 388AA870  addi r4, r10, -0x5790
	ctx.r[4].s64 = ctx.r[10].s64 + -22416;
	// 829E86BC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E86C0: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 829E86C4: 4B7B23BD  bl 0x8219aa80
	ctx.lr = 0x829E86C8;
	sub_8219AA80(ctx, base);
	// 829E86C8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829E86CC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829E86D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E86D4: 4B9E5D4D  bl 0x823ce420
	ctx.lr = 0x829E86D8;
	sub_823CE420(ctx, base);
	// 829E86D8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829E86DC: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 829E86E0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E86E4: 4803BFE5  bl 0x82a246c8
	ctx.lr = 0x829E86E8;
	sub_82A246C8(ctx, base);
	// 829E86E8: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E86EC: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 829E86F0: 913C0008  stw r9, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x829E86F4; continue 'dispatch;
            }
            0x829E86F4 => {
    //   block [0x829E86F4..0x829E86FC)
	// 829E86F4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829E86F8: 482C0D60  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E8700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E8700 size=148
    let mut pc: u32 = 0x829E8700;
    'dispatch: loop {
        match pc {
            0x829E8700 => {
    //   block [0x829E8700..0x829E878C)
	// 829E8700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E8704: 482C0D05  bl 0x82ca9408
	ctx.lr = 0x829E8708;
	sub_82CA93D0(ctx, base);
	// 829E8708: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E870C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E8710: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829E8714: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829E8718: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E871C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8720: 419A006C  beq cr6, 0x829e878c
	if ctx.cr[6].eq {
	pc = 0x829E878C; continue 'dispatch;
	}
	// 829E8724: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8728: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 829E872C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E8730: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E8734: 4B8409D5  bl 0x82229108
	ctx.lr = 0x829E8738;
	sub_82229108(ctx, base);
	// 829E8738: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 829E873C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E8740: 4B83F141  bl 0x82227880
	ctx.lr = 0x829E8744;
	sub_82227880(ctx, base);
	// 829E8744: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829E8748: 3D40829F  lis r10, -0x7d61
	ctx.r[10].s64 = -2103508992;
	// 829E874C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829E8750: 388AA8F8  addi r4, r10, -0x5708
	ctx.r[4].s64 = ctx.r[10].s64 + -22280;
	// 829E8754: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E8758: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 829E875C: 4B7B2325  bl 0x8219aa80
	ctx.lr = 0x829E8760;
	sub_8219AA80(ctx, base);
	// 829E8760: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829E8764: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829E8768: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E876C: 4B9E5CB5  bl 0x823ce420
	ctx.lr = 0x829E8770;
	sub_823CE420(ctx, base);
	// 829E8770: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829E8774: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 829E8778: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E877C: 4803BF4D  bl 0x82a246c8
	ctx.lr = 0x829E8780;
	sub_82A246C8(ctx, base);
	// 829E8780: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E8784: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 829E8788: 913C0008  stw r9, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x829E878C; continue 'dispatch;
            }
            0x829E878C => {
    //   block [0x829E878C..0x829E8794)
	// 829E878C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829E8790: 482C0CC8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E8798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E8798 size=148
    let mut pc: u32 = 0x829E8798;
    'dispatch: loop {
        match pc {
            0x829E8798 => {
    //   block [0x829E8798..0x829E8824)
	// 829E8798: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E879C: 482C0C6D  bl 0x82ca9408
	ctx.lr = 0x829E87A0;
	sub_82CA93D0(ctx, base);
	// 829E87A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E87A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E87A8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829E87AC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829E87B0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E87B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E87B8: 419A006C  beq cr6, 0x829e8824
	if ctx.cr[6].eq {
	pc = 0x829E8824; continue 'dispatch;
	}
	// 829E87BC: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E87C0: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 829E87C4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E87C8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E87CC: 4B84093D  bl 0x82229108
	ctx.lr = 0x829E87D0;
	sub_82229108(ctx, base);
	// 829E87D0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 829E87D4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E87D8: 4B83F0A9  bl 0x82227880
	ctx.lr = 0x829E87DC;
	sub_82227880(ctx, base);
	// 829E87DC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829E87E0: 3D40829F  lis r10, -0x7d61
	ctx.r[10].s64 = -2103508992;
	// 829E87E4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829E87E8: 388AA9E8  addi r4, r10, -0x5618
	ctx.r[4].s64 = ctx.r[10].s64 + -22040;
	// 829E87EC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E87F0: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 829E87F4: 4B7B228D  bl 0x8219aa80
	ctx.lr = 0x829E87F8;
	sub_8219AA80(ctx, base);
	// 829E87F8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829E87FC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829E8800: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E8804: 4B9E5C1D  bl 0x823ce420
	ctx.lr = 0x829E8808;
	sub_823CE420(ctx, base);
	// 829E8808: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829E880C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 829E8810: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E8814: 4803BEB5  bl 0x82a246c8
	ctx.lr = 0x829E8818;
	sub_82A246C8(ctx, base);
	// 829E8818: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E881C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 829E8820: 913C0008  stw r9, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x829E8824; continue 'dispatch;
            }
            0x829E8824 => {
    //   block [0x829E8824..0x829E882C)
	// 829E8824: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829E8828: 482C0C30  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E8830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E8830 size=372
    let mut pc: u32 = 0x829E8830;
    'dispatch: loop {
        match pc {
            0x829E8830 => {
    //   block [0x829E8830..0x829E8884)
	// 829E8830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E8834: 482C0BBD  bl 0x82ca93f0
	ctx.lr = 0x829E8838;
	sub_82CA93D0(ctx, base);
	// 829E8838: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E883C: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 829E8840: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 829E8844: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 829E8848: 2F170007  cmpwi cr6, r23, 7
	ctx.cr[6].compare_i32(ctx.r[23].s32, 7, &mut ctx.xer);
	// 829E884C: 419A0048  beq cr6, 0x829e8894
	if ctx.cr[6].eq {
	pc = 0x829E8894; continue 'dispatch;
	}
	// 829E8850: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 829E8854: 419A0040  beq cr6, 0x829e8894
	if ctx.cr[6].eq {
	pc = 0x829E8894; continue 'dispatch;
	}
	// 829E8858: 2F170009  cmpwi cr6, r23, 9
	ctx.cr[6].compare_i32(ctx.r[23].s32, 9, &mut ctx.xer);
	// 829E885C: 419A0028  beq cr6, 0x829e8884
	if ctx.cr[6].eq {
	pc = 0x829E8884; continue 'dispatch;
	}
	// 829E8860: 2F170008  cmpwi cr6, r23, 8
	ctx.cr[6].compare_i32(ctx.r[23].s32, 8, &mut ctx.xer);
	// 829E8864: 419A0020  beq cr6, 0x829e8884
	if ctx.cr[6].eq {
	pc = 0x829E8884; continue 'dispatch;
	}
	// 829E8868: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E886C: 56EB083C  slwi r11, r23, 1
	ctx.r[11].u32 = ctx.r[23].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E8870: 7D175A14  add r8, r23, r11
	ctx.r[8].u64 = ctx.r[23].u64 + ctx.r[11].u64;
	// 829E8874: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829E8878: 8169007C  lwz r11, 0x7c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E887C: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829E8880: 4800001C  b 0x829e889c
	pc = 0x829E889C; continue 'dispatch;
            }
            0x829E8884 => {
    //   block [0x829E8884..0x829E8894)
	// 829E8884: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8888: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E888C: 3B2B0018  addi r25, r11, 0x18
	ctx.r[25].s64 = ctx.r[11].s64 + 24;
	// 829E8890: 4800000C  b 0x829e889c
	pc = 0x829E889C; continue 'dispatch;
            }
            0x829E8894 => {
    //   block [0x829E8894..0x829E889C)
	// 829E8894: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8898: 3B2B0008  addi r25, r11, 8
	ctx.r[25].s64 = ctx.r[11].s64 + 8;
	pc = 0x829E889C; continue 'dispatch;
            }
            0x829E889C => {
    //   block [0x829E889C..0x829E88B8)
	// 829E889C: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E88A0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829E88A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E88A8: 419A0010  beq cr6, 0x829e88b8
	if ctx.cr[6].eq {
	pc = 0x829E88B8; continue 'dispatch;
	}
	// 829E88AC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E88B0: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E88B4: 4800000C  b 0x829e88c0
	pc = 0x829E88C0; continue 'dispatch;
            }
            0x829E88B8 => {
    //   block [0x829E88B8..0x829E88C0)
	// 829E88B8: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E88BC: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x829E88C0; continue 'dispatch;
            }
            0x829E88C0 => {
    //   block [0x829E88C0..0x829E88D0)
	// 829E88C0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829E88C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E88C8: 3B6A0B7C  addi r27, r10, 0xb7c
	ctx.r[27].s64 = ctx.r[10].s64 + 2940;
	// 829E88CC: 3B4B0B7C  addi r26, r11, 0xb7c
	ctx.r[26].s64 = ctx.r[11].s64 + 2940;
	pc = 0x829E88D0; continue 'dispatch;
            }
            0x829E88D0 => {
    //   block [0x829E88D0..0x829E88EC)
	// 829E88D0: 578A063E  clrlwi r10, r28, 0x18
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 829E88D4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E88D8: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 829E88DC: 409A0010  bne cr6, 0x829e88ec
	if !ctx.cr[6].eq {
	pc = 0x829E88EC; continue 'dispatch;
	}
	// 829E88E0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E88E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E88E8: 419A0008  beq cr6, 0x829e88f0
	if ctx.cr[6].eq {
	pc = 0x829E88F0; continue 'dispatch;
	}
	pc = 0x829E88EC; continue 'dispatch;
            }
            0x829E88EC => {
    //   block [0x829E88EC..0x829E88F0)
	// 829E88EC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829E88F0; continue 'dispatch;
            }
            0x829E88F0 => {
    //   block [0x829E88F0..0x829E8980)
	// 829E88F0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E88F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E88F8: 409A00A4  bne cr6, 0x829e899c
	if !ctx.cr[6].eq {
	pc = 0x829E899C; continue 'dispatch;
	}
	// 829E88FC: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E8900: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E8904: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E8908: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E890C: 419A0074  beq cr6, 0x829e8980
	if ctx.cr[6].eq {
	pc = 0x829E8980; continue 'dispatch;
	}
	// 829E8910: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 829E8914: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E8918: 4B81ACC9  bl 0x822035e0
	ctx.lr = 0x829E891C;
	sub_822035E0(ctx, base);
	// 829E891C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E8920: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8924: 419A005C  beq cr6, 0x829e8980
	if ctx.cr[6].eq {
	pc = 0x829E8980; continue 'dispatch;
	}
	// 829E8928: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E892C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 829E8930: 4B8177B9  bl 0x822000e8
	ctx.lr = 0x829E8934;
	sub_822000E8(ctx, base);
	// 829E8934: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E8938: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E893C: 419A0044  beq cr6, 0x829e8980
	if ctx.cr[6].eq {
	pc = 0x829E8980; continue 'dispatch;
	}
	// 829E8940: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 829E8944: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E8948: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829E894C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E8950: 4B82BF49  bl 0x82214898
	ctx.lr = 0x829E8954;
	sub_82214898(ctx, base);
	// 829E8954: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E8958: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829E895C: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 829E8960: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829E8964: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829E8968: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829E896C: 4BA6D7AD  bl 0x82456118
	ctx.lr = 0x829E8970;
	sub_82456118(ctx, base);
	// 829E8970: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 829E8974: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E8978: 4B7AB4C1  bl 0x82193e38
	ctx.lr = 0x829E897C;
	sub_82193E38(ctx, base);
	// 829E897C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	pc = 0x829E8980; continue 'dispatch;
            }
            0x829E8980 => {
    //   block [0x829E8980..0x829E8994)
	// 829E8980: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8984: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8988: 409A000C  bne cr6, 0x829e8994
	if !ctx.cr[6].eq {
	pc = 0x829E8994; continue 'dispatch;
	}
	// 829E898C: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E8990: 4BFFFF40  b 0x829e88d0
	pc = 0x829E88D0; continue 'dispatch;
            }
            0x829E8994 => {
    //   block [0x829E8994..0x829E899C)
	// 829E8994: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E8998: 4BFFFF38  b 0x829e88d0
	pc = 0x829E88D0; continue 'dispatch;
            }
            0x829E899C => {
    //   block [0x829E899C..0x829E89A4)
	// 829E899C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829E89A0: 482C0AA0  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E89A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E89A8 size=372
    let mut pc: u32 = 0x829E89A8;
    'dispatch: loop {
        match pc {
            0x829E89A8 => {
    //   block [0x829E89A8..0x829E89FC)
	// 829E89A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E89AC: 482C0A45  bl 0x82ca93f0
	ctx.lr = 0x829E89B0;
	sub_82CA93D0(ctx, base);
	// 829E89B0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E89B4: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 829E89B8: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 829E89BC: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 829E89C0: 2F170007  cmpwi cr6, r23, 7
	ctx.cr[6].compare_i32(ctx.r[23].s32, 7, &mut ctx.xer);
	// 829E89C4: 419A0048  beq cr6, 0x829e8a0c
	if ctx.cr[6].eq {
	pc = 0x829E8A0C; continue 'dispatch;
	}
	// 829E89C8: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 829E89CC: 419A0040  beq cr6, 0x829e8a0c
	if ctx.cr[6].eq {
	pc = 0x829E8A0C; continue 'dispatch;
	}
	// 829E89D0: 2F170009  cmpwi cr6, r23, 9
	ctx.cr[6].compare_i32(ctx.r[23].s32, 9, &mut ctx.xer);
	// 829E89D4: 419A0028  beq cr6, 0x829e89fc
	if ctx.cr[6].eq {
	pc = 0x829E89FC; continue 'dispatch;
	}
	// 829E89D8: 2F170008  cmpwi cr6, r23, 8
	ctx.cr[6].compare_i32(ctx.r[23].s32, 8, &mut ctx.xer);
	// 829E89DC: 419A0020  beq cr6, 0x829e89fc
	if ctx.cr[6].eq {
	pc = 0x829E89FC; continue 'dispatch;
	}
	// 829E89E0: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E89E4: 56EB083C  slwi r11, r23, 1
	ctx.r[11].u32 = ctx.r[23].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E89E8: 7D175A14  add r8, r23, r11
	ctx.r[8].u64 = ctx.r[23].u64 + ctx.r[11].u64;
	// 829E89EC: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829E89F0: 8169007C  lwz r11, 0x7c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E89F4: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829E89F8: 4800001C  b 0x829e8a14
	pc = 0x829E8A14; continue 'dispatch;
            }
            0x829E89FC => {
    //   block [0x829E89FC..0x829E8A0C)
	// 829E89FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8A00: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E8A04: 3B2B0018  addi r25, r11, 0x18
	ctx.r[25].s64 = ctx.r[11].s64 + 24;
	// 829E8A08: 4800000C  b 0x829e8a14
	pc = 0x829E8A14; continue 'dispatch;
            }
            0x829E8A0C => {
    //   block [0x829E8A0C..0x829E8A14)
	// 829E8A0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8A10: 3B2B0008  addi r25, r11, 8
	ctx.r[25].s64 = ctx.r[11].s64 + 8;
	pc = 0x829E8A14; continue 'dispatch;
            }
            0x829E8A14 => {
    //   block [0x829E8A14..0x829E8A30)
	// 829E8A14: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8A18: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829E8A1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8A20: 419A0010  beq cr6, 0x829e8a30
	if ctx.cr[6].eq {
	pc = 0x829E8A30; continue 'dispatch;
	}
	// 829E8A24: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E8A28: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E8A2C: 4800000C  b 0x829e8a38
	pc = 0x829E8A38; continue 'dispatch;
            }
            0x829E8A30 => {
    //   block [0x829E8A30..0x829E8A38)
	// 829E8A30: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E8A34: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x829E8A38; continue 'dispatch;
            }
            0x829E8A38 => {
    //   block [0x829E8A38..0x829E8A48)
	// 829E8A38: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829E8A3C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E8A40: 3B6A0B7C  addi r27, r10, 0xb7c
	ctx.r[27].s64 = ctx.r[10].s64 + 2940;
	// 829E8A44: 3B4B0B7C  addi r26, r11, 0xb7c
	ctx.r[26].s64 = ctx.r[11].s64 + 2940;
	pc = 0x829E8A48; continue 'dispatch;
            }
            0x829E8A48 => {
    //   block [0x829E8A48..0x829E8A64)
	// 829E8A48: 578A063E  clrlwi r10, r28, 0x18
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 829E8A4C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E8A50: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 829E8A54: 409A0010  bne cr6, 0x829e8a64
	if !ctx.cr[6].eq {
	pc = 0x829E8A64; continue 'dispatch;
	}
	// 829E8A58: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E8A5C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E8A60: 419A0008  beq cr6, 0x829e8a68
	if ctx.cr[6].eq {
	pc = 0x829E8A68; continue 'dispatch;
	}
	pc = 0x829E8A64; continue 'dispatch;
            }
            0x829E8A64 => {
    //   block [0x829E8A64..0x829E8A68)
	// 829E8A64: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829E8A68; continue 'dispatch;
            }
            0x829E8A68 => {
    //   block [0x829E8A68..0x829E8AF8)
	// 829E8A68: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E8A6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8A70: 409A00A4  bne cr6, 0x829e8b14
	if !ctx.cr[6].eq {
	pc = 0x829E8B14; continue 'dispatch;
	}
	// 829E8A74: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E8A78: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E8A7C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E8A80: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E8A84: 419A0074  beq cr6, 0x829e8af8
	if ctx.cr[6].eq {
	pc = 0x829E8AF8; continue 'dispatch;
	}
	// 829E8A88: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 829E8A8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E8A90: 4B81AB51  bl 0x822035e0
	ctx.lr = 0x829E8A94;
	sub_822035E0(ctx, base);
	// 829E8A94: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E8A98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8A9C: 419A005C  beq cr6, 0x829e8af8
	if ctx.cr[6].eq {
	pc = 0x829E8AF8; continue 'dispatch;
	}
	// 829E8AA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E8AA4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 829E8AA8: 4BB27279  bl 0x8250fd20
	ctx.lr = 0x829E8AAC;
	sub_8250FD20(ctx, base);
	// 829E8AAC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E8AB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8AB4: 419A0044  beq cr6, 0x829e8af8
	if ctx.cr[6].eq {
	pc = 0x829E8AF8; continue 'dispatch;
	}
	// 829E8AB8: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 829E8ABC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E8AC0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829E8AC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E8AC8: 4B82BDD1  bl 0x82214898
	ctx.lr = 0x829E8ACC;
	sub_82214898(ctx, base);
	// 829E8ACC: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E8AD0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829E8AD4: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 829E8AD8: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829E8ADC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829E8AE0: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829E8AE4: 4BA6D635  bl 0x82456118
	ctx.lr = 0x829E8AE8;
	sub_82456118(ctx, base);
	// 829E8AE8: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 829E8AEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E8AF0: 4B7AB349  bl 0x82193e38
	ctx.lr = 0x829E8AF4;
	sub_82193E38(ctx, base);
	// 829E8AF4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	pc = 0x829E8AF8; continue 'dispatch;
            }
            0x829E8AF8 => {
    //   block [0x829E8AF8..0x829E8B0C)
	// 829E8AF8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8AFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8B00: 409A000C  bne cr6, 0x829e8b0c
	if !ctx.cr[6].eq {
	pc = 0x829E8B0C; continue 'dispatch;
	}
	// 829E8B04: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E8B08: 4BFFFF40  b 0x829e8a48
	pc = 0x829E8A48; continue 'dispatch;
            }
            0x829E8B0C => {
    //   block [0x829E8B0C..0x829E8B14)
	// 829E8B0C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E8B10: 4BFFFF38  b 0x829e8a48
	pc = 0x829E8A48; continue 'dispatch;
            }
            0x829E8B14 => {
    //   block [0x829E8B14..0x829E8B1C)
	// 829E8B14: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829E8B18: 482C0928  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E8B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E8B20 size=412
    let mut pc: u32 = 0x829E8B20;
    'dispatch: loop {
        match pc {
            0x829E8B20 => {
    //   block [0x829E8B20..0x829E8B74)
	// 829E8B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E8B24: 482C08CD  bl 0x82ca93f0
	ctx.lr = 0x829E8B28;
	sub_82CA93D0(ctx, base);
	// 829E8B28: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E8B2C: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 829E8B30: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 829E8B34: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 829E8B38: 2F170007  cmpwi cr6, r23, 7
	ctx.cr[6].compare_i32(ctx.r[23].s32, 7, &mut ctx.xer);
	// 829E8B3C: 419A0048  beq cr6, 0x829e8b84
	if ctx.cr[6].eq {
	pc = 0x829E8B84; continue 'dispatch;
	}
	// 829E8B40: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 829E8B44: 419A0040  beq cr6, 0x829e8b84
	if ctx.cr[6].eq {
	pc = 0x829E8B84; continue 'dispatch;
	}
	// 829E8B48: 2F170009  cmpwi cr6, r23, 9
	ctx.cr[6].compare_i32(ctx.r[23].s32, 9, &mut ctx.xer);
	// 829E8B4C: 419A0028  beq cr6, 0x829e8b74
	if ctx.cr[6].eq {
	pc = 0x829E8B74; continue 'dispatch;
	}
	// 829E8B50: 2F170008  cmpwi cr6, r23, 8
	ctx.cr[6].compare_i32(ctx.r[23].s32, 8, &mut ctx.xer);
	// 829E8B54: 419A0020  beq cr6, 0x829e8b74
	if ctx.cr[6].eq {
	pc = 0x829E8B74; continue 'dispatch;
	}
	// 829E8B58: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8B5C: 56EB083C  slwi r11, r23, 1
	ctx.r[11].u32 = ctx.r[23].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E8B60: 7D175A14  add r8, r23, r11
	ctx.r[8].u64 = ctx.r[23].u64 + ctx.r[11].u64;
	// 829E8B64: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829E8B68: 8169007C  lwz r11, 0x7c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E8B6C: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829E8B70: 4800001C  b 0x829e8b8c
	pc = 0x829E8B8C; continue 'dispatch;
            }
            0x829E8B74 => {
    //   block [0x829E8B74..0x829E8B84)
	// 829E8B74: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8B78: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E8B7C: 3B2B0018  addi r25, r11, 0x18
	ctx.r[25].s64 = ctx.r[11].s64 + 24;
	// 829E8B80: 4800000C  b 0x829e8b8c
	pc = 0x829E8B8C; continue 'dispatch;
            }
            0x829E8B84 => {
    //   block [0x829E8B84..0x829E8B8C)
	// 829E8B84: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8B88: 3B2B0008  addi r25, r11, 8
	ctx.r[25].s64 = ctx.r[11].s64 + 8;
	pc = 0x829E8B8C; continue 'dispatch;
            }
            0x829E8B8C => {
    //   block [0x829E8B8C..0x829E8BA8)
	// 829E8B8C: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8B90: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829E8B94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8B98: 419A0010  beq cr6, 0x829e8ba8
	if ctx.cr[6].eq {
	pc = 0x829E8BA8; continue 'dispatch;
	}
	// 829E8B9C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E8BA0: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E8BA4: 4800000C  b 0x829e8bb0
	pc = 0x829E8BB0; continue 'dispatch;
            }
            0x829E8BA8 => {
    //   block [0x829E8BA8..0x829E8BB0)
	// 829E8BA8: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E8BAC: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x829E8BB0; continue 'dispatch;
            }
            0x829E8BB0 => {
    //   block [0x829E8BB0..0x829E8BC0)
	// 829E8BB0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829E8BB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E8BB8: 3B6A0B7C  addi r27, r10, 0xb7c
	ctx.r[27].s64 = ctx.r[10].s64 + 2940;
	// 829E8BBC: 3B4B0B7C  addi r26, r11, 0xb7c
	ctx.r[26].s64 = ctx.r[11].s64 + 2940;
	pc = 0x829E8BC0; continue 'dispatch;
            }
            0x829E8BC0 => {
    //   block [0x829E8BC0..0x829E8BDC)
	// 829E8BC0: 578A063E  clrlwi r10, r28, 0x18
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 829E8BC4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E8BC8: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 829E8BCC: 409A0010  bne cr6, 0x829e8bdc
	if !ctx.cr[6].eq {
	pc = 0x829E8BDC; continue 'dispatch;
	}
	// 829E8BD0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E8BD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E8BD8: 419A0008  beq cr6, 0x829e8be0
	if ctx.cr[6].eq {
	pc = 0x829E8BE0; continue 'dispatch;
	}
	pc = 0x829E8BDC; continue 'dispatch;
            }
            0x829E8BDC => {
    //   block [0x829E8BDC..0x829E8BE0)
	// 829E8BDC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829E8BE0; continue 'dispatch;
            }
            0x829E8BE0 => {
    //   block [0x829E8BE0..0x829E8C30)
	// 829E8BE0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E8BE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8BE8: 409A00CC  bne cr6, 0x829e8cb4
	if !ctx.cr[6].eq {
	pc = 0x829E8CB4; continue 'dispatch;
	}
	// 829E8BEC: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E8BF0: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E8BF4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E8BF8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E8BFC: 419A009C  beq cr6, 0x829e8c98
	if ctx.cr[6].eq {
	pc = 0x829E8C98; continue 'dispatch;
	}
	// 829E8C00: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 829E8C04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E8C08: 4B81A9D9  bl 0x822035e0
	ctx.lr = 0x829E8C0C;
	sub_822035E0(ctx, base);
	// 829E8C0C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E8C10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8C14: 419A0084  beq cr6, 0x829e8c98
	if ctx.cr[6].eq {
	pc = 0x829E8C98; continue 'dispatch;
	}
	// 829E8C18: 807F0080  lwz r3, 0x80(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 829E8C1C: 80960000  lwz r4, 0(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8C20: 7F032040  cmplw cr6, r3, r4
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[4].u32, &mut ctx.xer);
	// 829E8C24: 409A000C  bne cr6, 0x829e8c30
	if !ctx.cr[6].eq {
	pc = 0x829E8C30; continue 'dispatch;
	}
	// 829E8C28: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829E8C2C: 48000020  b 0x829e8c4c
	pc = 0x829E8C4C; continue 'dispatch;
            }
            0x829E8C30 => {
    //   block [0x829E8C30..0x829E8C48)
	// 829E8C30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E8C34: 419A0014  beq cr6, 0x829e8c48
	if ctx.cr[6].eq {
	pc = 0x829E8C48; continue 'dispatch;
	}
	// 829E8C38: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 829E8C3C: 419A000C  beq cr6, 0x829e8c48
	if ctx.cr[6].eq {
	pc = 0x829E8C48; continue 'dispatch;
	}
	// 829E8C40: 4B884B51  bl 0x8226d790
	ctx.lr = 0x829E8C44;
	sub_8226D790(ctx, base);
	// 829E8C44: 48000008  b 0x829e8c4c
	pc = 0x829E8C4C; continue 'dispatch;
            }
            0x829E8C48 => {
    //   block [0x829E8C48..0x829E8C4C)
	// 829E8C48: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	pc = 0x829E8C4C; continue 'dispatch;
            }
            0x829E8C4C => {
    //   block [0x829E8C4C..0x829E8C98)
	// 829E8C4C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E8C50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8C54: 419A0044  beq cr6, 0x829e8c98
	if ctx.cr[6].eq {
	pc = 0x829E8C98; continue 'dispatch;
	}
	// 829E8C58: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 829E8C5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E8C60: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829E8C64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E8C68: 4B82BC31  bl 0x82214898
	ctx.lr = 0x829E8C6C;
	sub_82214898(ctx, base);
	// 829E8C6C: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E8C70: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829E8C74: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 829E8C78: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829E8C7C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829E8C80: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829E8C84: 4BA6D495  bl 0x82456118
	ctx.lr = 0x829E8C88;
	sub_82456118(ctx, base);
	// 829E8C88: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 829E8C8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E8C90: 4B7AB1A9  bl 0x82193e38
	ctx.lr = 0x829E8C94;
	sub_82193E38(ctx, base);
	// 829E8C94: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	pc = 0x829E8C98; continue 'dispatch;
            }
            0x829E8C98 => {
    //   block [0x829E8C98..0x829E8CAC)
	// 829E8C98: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8C9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8CA0: 409A000C  bne cr6, 0x829e8cac
	if !ctx.cr[6].eq {
	pc = 0x829E8CAC; continue 'dispatch;
	}
	// 829E8CA4: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E8CA8: 4BFFFF18  b 0x829e8bc0
	pc = 0x829E8BC0; continue 'dispatch;
            }
            0x829E8CAC => {
    //   block [0x829E8CAC..0x829E8CB4)
	// 829E8CAC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E8CB0: 4BFFFF10  b 0x829e8bc0
	pc = 0x829E8BC0; continue 'dispatch;
            }
            0x829E8CB4 => {
    //   block [0x829E8CB4..0x829E8CBC)
	// 829E8CB4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829E8CB8: 482C0788  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E8CC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E8CC0 size=372
    let mut pc: u32 = 0x829E8CC0;
    'dispatch: loop {
        match pc {
            0x829E8CC0 => {
    //   block [0x829E8CC0..0x829E8D14)
	// 829E8CC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E8CC4: 482C072D  bl 0x82ca93f0
	ctx.lr = 0x829E8CC8;
	sub_82CA93D0(ctx, base);
	// 829E8CC8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E8CCC: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 829E8CD0: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 829E8CD4: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 829E8CD8: 2F170007  cmpwi cr6, r23, 7
	ctx.cr[6].compare_i32(ctx.r[23].s32, 7, &mut ctx.xer);
	// 829E8CDC: 419A0048  beq cr6, 0x829e8d24
	if ctx.cr[6].eq {
	pc = 0x829E8D24; continue 'dispatch;
	}
	// 829E8CE0: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 829E8CE4: 419A0040  beq cr6, 0x829e8d24
	if ctx.cr[6].eq {
	pc = 0x829E8D24; continue 'dispatch;
	}
	// 829E8CE8: 2F170009  cmpwi cr6, r23, 9
	ctx.cr[6].compare_i32(ctx.r[23].s32, 9, &mut ctx.xer);
	// 829E8CEC: 419A0028  beq cr6, 0x829e8d14
	if ctx.cr[6].eq {
	pc = 0x829E8D14; continue 'dispatch;
	}
	// 829E8CF0: 2F170008  cmpwi cr6, r23, 8
	ctx.cr[6].compare_i32(ctx.r[23].s32, 8, &mut ctx.xer);
	// 829E8CF4: 419A0020  beq cr6, 0x829e8d14
	if ctx.cr[6].eq {
	pc = 0x829E8D14; continue 'dispatch;
	}
	// 829E8CF8: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8CFC: 56EB083C  slwi r11, r23, 1
	ctx.r[11].u32 = ctx.r[23].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E8D00: 7D175A14  add r8, r23, r11
	ctx.r[8].u64 = ctx.r[23].u64 + ctx.r[11].u64;
	// 829E8D04: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829E8D08: 8169007C  lwz r11, 0x7c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E8D0C: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829E8D10: 4800001C  b 0x829e8d2c
	pc = 0x829E8D2C; continue 'dispatch;
            }
            0x829E8D14 => {
    //   block [0x829E8D14..0x829E8D24)
	// 829E8D14: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8D18: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E8D1C: 3B2B0018  addi r25, r11, 0x18
	ctx.r[25].s64 = ctx.r[11].s64 + 24;
	// 829E8D20: 4800000C  b 0x829e8d2c
	pc = 0x829E8D2C; continue 'dispatch;
            }
            0x829E8D24 => {
    //   block [0x829E8D24..0x829E8D2C)
	// 829E8D24: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8D28: 3B2B0008  addi r25, r11, 8
	ctx.r[25].s64 = ctx.r[11].s64 + 8;
	pc = 0x829E8D2C; continue 'dispatch;
            }
            0x829E8D2C => {
    //   block [0x829E8D2C..0x829E8D48)
	// 829E8D2C: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8D30: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829E8D34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8D38: 419A0010  beq cr6, 0x829e8d48
	if ctx.cr[6].eq {
	pc = 0x829E8D48; continue 'dispatch;
	}
	// 829E8D3C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E8D40: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E8D44: 4800000C  b 0x829e8d50
	pc = 0x829E8D50; continue 'dispatch;
            }
            0x829E8D48 => {
    //   block [0x829E8D48..0x829E8D50)
	// 829E8D48: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E8D4C: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x829E8D50; continue 'dispatch;
            }
            0x829E8D50 => {
    //   block [0x829E8D50..0x829E8D60)
	// 829E8D50: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829E8D54: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E8D58: 3B6A0B7C  addi r27, r10, 0xb7c
	ctx.r[27].s64 = ctx.r[10].s64 + 2940;
	// 829E8D5C: 3B4B0B7C  addi r26, r11, 0xb7c
	ctx.r[26].s64 = ctx.r[11].s64 + 2940;
	pc = 0x829E8D60; continue 'dispatch;
            }
            0x829E8D60 => {
    //   block [0x829E8D60..0x829E8D7C)
	// 829E8D60: 578A063E  clrlwi r10, r28, 0x18
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 829E8D64: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E8D68: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 829E8D6C: 409A0010  bne cr6, 0x829e8d7c
	if !ctx.cr[6].eq {
	pc = 0x829E8D7C; continue 'dispatch;
	}
	// 829E8D70: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E8D74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E8D78: 419A0008  beq cr6, 0x829e8d80
	if ctx.cr[6].eq {
	pc = 0x829E8D80; continue 'dispatch;
	}
	pc = 0x829E8D7C; continue 'dispatch;
            }
            0x829E8D7C => {
    //   block [0x829E8D7C..0x829E8D80)
	// 829E8D7C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829E8D80; continue 'dispatch;
            }
            0x829E8D80 => {
    //   block [0x829E8D80..0x829E8E10)
	// 829E8D80: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E8D84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8D88: 409A00A4  bne cr6, 0x829e8e2c
	if !ctx.cr[6].eq {
	pc = 0x829E8E2C; continue 'dispatch;
	}
	// 829E8D8C: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E8D90: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E8D94: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E8D98: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E8D9C: 419A0074  beq cr6, 0x829e8e10
	if ctx.cr[6].eq {
	pc = 0x829E8E10; continue 'dispatch;
	}
	// 829E8DA0: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 829E8DA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E8DA8: 4B81A839  bl 0x822035e0
	ctx.lr = 0x829E8DAC;
	sub_822035E0(ctx, base);
	// 829E8DAC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E8DB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8DB4: 419A005C  beq cr6, 0x829e8e10
	if ctx.cr[6].eq {
	pc = 0x829E8E10; continue 'dispatch;
	}
	// 829E8DB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E8DBC: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 829E8DC0: 4B816571  bl 0x821ff330
	ctx.lr = 0x829E8DC4;
	sub_821FF330(ctx, base);
	// 829E8DC4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E8DC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8DCC: 419A0044  beq cr6, 0x829e8e10
	if ctx.cr[6].eq {
	pc = 0x829E8E10; continue 'dispatch;
	}
	// 829E8DD0: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 829E8DD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E8DD8: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829E8DDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E8DE0: 4B82BAB9  bl 0x82214898
	ctx.lr = 0x829E8DE4;
	sub_82214898(ctx, base);
	// 829E8DE4: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E8DE8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829E8DEC: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 829E8DF0: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829E8DF4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829E8DF8: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829E8DFC: 4BA6D31D  bl 0x82456118
	ctx.lr = 0x829E8E00;
	sub_82456118(ctx, base);
	// 829E8E00: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 829E8E04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E8E08: 4B7AB031  bl 0x82193e38
	ctx.lr = 0x829E8E0C;
	sub_82193E38(ctx, base);
	// 829E8E0C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	pc = 0x829E8E10; continue 'dispatch;
            }
            0x829E8E10 => {
    //   block [0x829E8E10..0x829E8E24)
	// 829E8E10: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8E14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8E18: 409A000C  bne cr6, 0x829e8e24
	if !ctx.cr[6].eq {
	pc = 0x829E8E24; continue 'dispatch;
	}
	// 829E8E1C: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E8E20: 4BFFFF40  b 0x829e8d60
	pc = 0x829E8D60; continue 'dispatch;
            }
            0x829E8E24 => {
    //   block [0x829E8E24..0x829E8E2C)
	// 829E8E24: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E8E28: 4BFFFF38  b 0x829e8d60
	pc = 0x829E8D60; continue 'dispatch;
            }
            0x829E8E2C => {
    //   block [0x829E8E2C..0x829E8E34)
	// 829E8E2C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829E8E30: 482C0610  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E8E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E8E38 size=368
    let mut pc: u32 = 0x829E8E38;
    'dispatch: loop {
        match pc {
            0x829E8E38 => {
    //   block [0x829E8E38..0x829E8E8C)
	// 829E8E38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E8E3C: 482C05B5  bl 0x82ca93f0
	ctx.lr = 0x829E8E40;
	sub_82CA93D0(ctx, base);
	// 829E8E40: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E8E44: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 829E8E48: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 829E8E4C: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 829E8E50: 2F170007  cmpwi cr6, r23, 7
	ctx.cr[6].compare_i32(ctx.r[23].s32, 7, &mut ctx.xer);
	// 829E8E54: 419A0048  beq cr6, 0x829e8e9c
	if ctx.cr[6].eq {
	pc = 0x829E8E9C; continue 'dispatch;
	}
	// 829E8E58: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 829E8E5C: 419A0040  beq cr6, 0x829e8e9c
	if ctx.cr[6].eq {
	pc = 0x829E8E9C; continue 'dispatch;
	}
	// 829E8E60: 2F170009  cmpwi cr6, r23, 9
	ctx.cr[6].compare_i32(ctx.r[23].s32, 9, &mut ctx.xer);
	// 829E8E64: 419A0028  beq cr6, 0x829e8e8c
	if ctx.cr[6].eq {
	pc = 0x829E8E8C; continue 'dispatch;
	}
	// 829E8E68: 2F170008  cmpwi cr6, r23, 8
	ctx.cr[6].compare_i32(ctx.r[23].s32, 8, &mut ctx.xer);
	// 829E8E6C: 419A0020  beq cr6, 0x829e8e8c
	if ctx.cr[6].eq {
	pc = 0x829E8E8C; continue 'dispatch;
	}
	// 829E8E70: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8E74: 56EB083C  slwi r11, r23, 1
	ctx.r[11].u32 = ctx.r[23].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E8E78: 7D175A14  add r8, r23, r11
	ctx.r[8].u64 = ctx.r[23].u64 + ctx.r[11].u64;
	// 829E8E7C: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829E8E80: 8169007C  lwz r11, 0x7c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E8E84: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829E8E88: 4800001C  b 0x829e8ea4
	pc = 0x829E8EA4; continue 'dispatch;
            }
            0x829E8E8C => {
    //   block [0x829E8E8C..0x829E8E9C)
	// 829E8E8C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8E90: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E8E94: 3B2B0018  addi r25, r11, 0x18
	ctx.r[25].s64 = ctx.r[11].s64 + 24;
	// 829E8E98: 4800000C  b 0x829e8ea4
	pc = 0x829E8EA4; continue 'dispatch;
            }
            0x829E8E9C => {
    //   block [0x829E8E9C..0x829E8EA4)
	// 829E8E9C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8EA0: 3B2B0008  addi r25, r11, 8
	ctx.r[25].s64 = ctx.r[11].s64 + 8;
	pc = 0x829E8EA4; continue 'dispatch;
            }
            0x829E8EA4 => {
    //   block [0x829E8EA4..0x829E8EC0)
	// 829E8EA4: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8EA8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829E8EAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8EB0: 419A0010  beq cr6, 0x829e8ec0
	if ctx.cr[6].eq {
	pc = 0x829E8EC0; continue 'dispatch;
	}
	// 829E8EB4: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E8EB8: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E8EBC: 4800000C  b 0x829e8ec8
	pc = 0x829E8EC8; continue 'dispatch;
            }
            0x829E8EC0 => {
    //   block [0x829E8EC0..0x829E8EC8)
	// 829E8EC0: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E8EC4: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x829E8EC8; continue 'dispatch;
            }
            0x829E8EC8 => {
    //   block [0x829E8EC8..0x829E8ED8)
	// 829E8EC8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829E8ECC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E8ED0: 3B6A0B7C  addi r27, r10, 0xb7c
	ctx.r[27].s64 = ctx.r[10].s64 + 2940;
	// 829E8ED4: 3B4B0B7C  addi r26, r11, 0xb7c
	ctx.r[26].s64 = ctx.r[11].s64 + 2940;
	pc = 0x829E8ED8; continue 'dispatch;
            }
            0x829E8ED8 => {
    //   block [0x829E8ED8..0x829E8EF4)
	// 829E8ED8: 578A063E  clrlwi r10, r28, 0x18
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 829E8EDC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E8EE0: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 829E8EE4: 409A0010  bne cr6, 0x829e8ef4
	if !ctx.cr[6].eq {
	pc = 0x829E8EF4; continue 'dispatch;
	}
	// 829E8EE8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E8EEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E8EF0: 419A0008  beq cr6, 0x829e8ef8
	if ctx.cr[6].eq {
	pc = 0x829E8EF8; continue 'dispatch;
	}
	pc = 0x829E8EF4; continue 'dispatch;
            }
            0x829E8EF4 => {
    //   block [0x829E8EF4..0x829E8EF8)
	// 829E8EF4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829E8EF8; continue 'dispatch;
            }
            0x829E8EF8 => {
    //   block [0x829E8EF8..0x829E8F84)
	// 829E8EF8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E8EFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8F00: 409A00A0  bne cr6, 0x829e8fa0
	if !ctx.cr[6].eq {
	pc = 0x829E8FA0; continue 'dispatch;
	}
	// 829E8F04: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E8F08: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E8F0C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E8F10: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E8F14: 419A0070  beq cr6, 0x829e8f84
	if ctx.cr[6].eq {
	pc = 0x829E8F84; continue 'dispatch;
	}
	// 829E8F18: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 829E8F1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E8F20: 4B81A6C1  bl 0x822035e0
	ctx.lr = 0x829E8F24;
	sub_822035E0(ctx, base);
	// 829E8F24: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E8F28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8F2C: 419A0058  beq cr6, 0x829e8f84
	if ctx.cr[6].eq {
	pc = 0x829E8F84; continue 'dispatch;
	}
	// 829E8F30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E8F34: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 829E8F38: 4BB27181  bl 0x825100b8
	ctx.lr = 0x829E8F3C;
	sub_825100B8(ctx, base);
	// 829E8F3C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E8F40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8F44: 419A0040  beq cr6, 0x829e8f84
	if ctx.cr[6].eq {
	pc = 0x829E8F84; continue 'dispatch;
	}
	// 829E8F48: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 829E8F4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E8F50: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829E8F54: 4B82B945  bl 0x82214898
	ctx.lr = 0x829E8F58;
	sub_82214898(ctx, base);
	// 829E8F58: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E8F5C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829E8F60: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 829E8F64: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829E8F68: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829E8F6C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829E8F70: 4BA6D1A9  bl 0x82456118
	ctx.lr = 0x829E8F74;
	sub_82456118(ctx, base);
	// 829E8F74: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 829E8F78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E8F7C: 4B7AAEBD  bl 0x82193e38
	ctx.lr = 0x829E8F80;
	sub_82193E38(ctx, base);
	// 829E8F80: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	pc = 0x829E8F84; continue 'dispatch;
            }
            0x829E8F84 => {
    //   block [0x829E8F84..0x829E8F98)
	// 829E8F84: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8F88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8F8C: 409A000C  bne cr6, 0x829e8f98
	if !ctx.cr[6].eq {
	pc = 0x829E8F98; continue 'dispatch;
	}
	// 829E8F90: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E8F94: 4BFFFF44  b 0x829e8ed8
	pc = 0x829E8ED8; continue 'dispatch;
            }
            0x829E8F98 => {
    //   block [0x829E8F98..0x829E8FA0)
	// 829E8F98: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E8F9C: 4BFFFF3C  b 0x829e8ed8
	pc = 0x829E8ED8; continue 'dispatch;
            }
            0x829E8FA0 => {
    //   block [0x829E8FA0..0x829E8FA8)
	// 829E8FA0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829E8FA4: 482C049C  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E8FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E8FA8 size=368
    let mut pc: u32 = 0x829E8FA8;
    'dispatch: loop {
        match pc {
            0x829E8FA8 => {
    //   block [0x829E8FA8..0x829E8FFC)
	// 829E8FA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E8FAC: 482C0445  bl 0x82ca93f0
	ctx.lr = 0x829E8FB0;
	sub_82CA93D0(ctx, base);
	// 829E8FB0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E8FB4: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 829E8FB8: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 829E8FBC: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 829E8FC0: 2F170007  cmpwi cr6, r23, 7
	ctx.cr[6].compare_i32(ctx.r[23].s32, 7, &mut ctx.xer);
	// 829E8FC4: 419A0048  beq cr6, 0x829e900c
	if ctx.cr[6].eq {
	pc = 0x829E900C; continue 'dispatch;
	}
	// 829E8FC8: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 829E8FCC: 419A0040  beq cr6, 0x829e900c
	if ctx.cr[6].eq {
	pc = 0x829E900C; continue 'dispatch;
	}
	// 829E8FD0: 2F170009  cmpwi cr6, r23, 9
	ctx.cr[6].compare_i32(ctx.r[23].s32, 9, &mut ctx.xer);
	// 829E8FD4: 419A0028  beq cr6, 0x829e8ffc
	if ctx.cr[6].eq {
	pc = 0x829E8FFC; continue 'dispatch;
	}
	// 829E8FD8: 2F170008  cmpwi cr6, r23, 8
	ctx.cr[6].compare_i32(ctx.r[23].s32, 8, &mut ctx.xer);
	// 829E8FDC: 419A0020  beq cr6, 0x829e8ffc
	if ctx.cr[6].eq {
	pc = 0x829E8FFC; continue 'dispatch;
	}
	// 829E8FE0: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8FE4: 56EB083C  slwi r11, r23, 1
	ctx.r[11].u32 = ctx.r[23].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E8FE8: 7D175A14  add r8, r23, r11
	ctx.r[8].u64 = ctx.r[23].u64 + ctx.r[11].u64;
	// 829E8FEC: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829E8FF0: 8169007C  lwz r11, 0x7c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E8FF4: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829E8FF8: 4800001C  b 0x829e9014
	pc = 0x829E9014; continue 'dispatch;
            }
            0x829E8FFC => {
    //   block [0x829E8FFC..0x829E900C)
	// 829E8FFC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9000: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E9004: 3B2B0018  addi r25, r11, 0x18
	ctx.r[25].s64 = ctx.r[11].s64 + 24;
	// 829E9008: 4800000C  b 0x829e9014
	pc = 0x829E9014; continue 'dispatch;
            }
            0x829E900C => {
    //   block [0x829E900C..0x829E9014)
	// 829E900C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9010: 3B2B0008  addi r25, r11, 8
	ctx.r[25].s64 = ctx.r[11].s64 + 8;
	pc = 0x829E9014; continue 'dispatch;
            }
            0x829E9014 => {
    //   block [0x829E9014..0x829E9030)
	// 829E9014: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9018: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829E901C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9020: 419A0010  beq cr6, 0x829e9030
	if ctx.cr[6].eq {
	pc = 0x829E9030; continue 'dispatch;
	}
	// 829E9024: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E9028: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E902C: 4800000C  b 0x829e9038
	pc = 0x829E9038; continue 'dispatch;
            }
            0x829E9030 => {
    //   block [0x829E9030..0x829E9038)
	// 829E9030: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E9034: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x829E9038; continue 'dispatch;
            }
            0x829E9038 => {
    //   block [0x829E9038..0x829E9048)
	// 829E9038: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829E903C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E9040: 3B6A0B7C  addi r27, r10, 0xb7c
	ctx.r[27].s64 = ctx.r[10].s64 + 2940;
	// 829E9044: 3B4B0B7C  addi r26, r11, 0xb7c
	ctx.r[26].s64 = ctx.r[11].s64 + 2940;
	pc = 0x829E9048; continue 'dispatch;
            }
            0x829E9048 => {
    //   block [0x829E9048..0x829E9064)
	// 829E9048: 578A063E  clrlwi r10, r28, 0x18
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 829E904C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E9050: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 829E9054: 409A0010  bne cr6, 0x829e9064
	if !ctx.cr[6].eq {
	pc = 0x829E9064; continue 'dispatch;
	}
	// 829E9058: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E905C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E9060: 419A0008  beq cr6, 0x829e9068
	if ctx.cr[6].eq {
	pc = 0x829E9068; continue 'dispatch;
	}
	pc = 0x829E9064; continue 'dispatch;
            }
            0x829E9064 => {
    //   block [0x829E9064..0x829E9068)
	// 829E9064: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829E9068; continue 'dispatch;
            }
            0x829E9068 => {
    //   block [0x829E9068..0x829E90F4)
	// 829E9068: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E906C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9070: 409A00A0  bne cr6, 0x829e9110
	if !ctx.cr[6].eq {
	pc = 0x829E9110; continue 'dispatch;
	}
	// 829E9074: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E9078: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E907C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E9080: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E9084: 419A0070  beq cr6, 0x829e90f4
	if ctx.cr[6].eq {
	pc = 0x829E90F4; continue 'dispatch;
	}
	// 829E9088: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 829E908C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E9090: 4B81A551  bl 0x822035e0
	ctx.lr = 0x829E9094;
	sub_822035E0(ctx, base);
	// 829E9094: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E9098: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E909C: 419A0058  beq cr6, 0x829e90f4
	if ctx.cr[6].eq {
	pc = 0x829E90F4; continue 'dispatch;
	}
	// 829E90A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E90A4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 829E90A8: 4BB27129  bl 0x825101d0
	ctx.lr = 0x829E90AC;
	sub_825101D0(ctx, base);
	// 829E90AC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E90B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E90B4: 419A0040  beq cr6, 0x829e90f4
	if ctx.cr[6].eq {
	pc = 0x829E90F4; continue 'dispatch;
	}
	// 829E90B8: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 829E90BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E90C0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829E90C4: 4B82B7D5  bl 0x82214898
	ctx.lr = 0x829E90C8;
	sub_82214898(ctx, base);
	// 829E90C8: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E90CC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829E90D0: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 829E90D4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829E90D8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829E90DC: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829E90E0: 4BA6D039  bl 0x82456118
	ctx.lr = 0x829E90E4;
	sub_82456118(ctx, base);
	// 829E90E4: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 829E90E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E90EC: 4B7AAD4D  bl 0x82193e38
	ctx.lr = 0x829E90F0;
	sub_82193E38(ctx, base);
	// 829E90F0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	pc = 0x829E90F4; continue 'dispatch;
            }
            0x829E90F4 => {
    //   block [0x829E90F4..0x829E9108)
	// 829E90F4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E90F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E90FC: 409A000C  bne cr6, 0x829e9108
	if !ctx.cr[6].eq {
	pc = 0x829E9108; continue 'dispatch;
	}
	// 829E9100: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E9104: 4BFFFF44  b 0x829e9048
	pc = 0x829E9048; continue 'dispatch;
            }
            0x829E9108 => {
    //   block [0x829E9108..0x829E9110)
	// 829E9108: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E910C: 4BFFFF3C  b 0x829e9048
	pc = 0x829E9048; continue 'dispatch;
            }
            0x829E9110 => {
    //   block [0x829E9110..0x829E9118)
	// 829E9110: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829E9114: 482C032C  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E9118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E9118 size=368
    let mut pc: u32 = 0x829E9118;
    'dispatch: loop {
        match pc {
            0x829E9118 => {
    //   block [0x829E9118..0x829E916C)
	// 829E9118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E911C: 482C02D5  bl 0x82ca93f0
	ctx.lr = 0x829E9120;
	sub_82CA93D0(ctx, base);
	// 829E9120: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E9124: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 829E9128: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 829E912C: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 829E9130: 2F170007  cmpwi cr6, r23, 7
	ctx.cr[6].compare_i32(ctx.r[23].s32, 7, &mut ctx.xer);
	// 829E9134: 419A0048  beq cr6, 0x829e917c
	if ctx.cr[6].eq {
	pc = 0x829E917C; continue 'dispatch;
	}
	// 829E9138: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 829E913C: 419A0040  beq cr6, 0x829e917c
	if ctx.cr[6].eq {
	pc = 0x829E917C; continue 'dispatch;
	}
	// 829E9140: 2F170009  cmpwi cr6, r23, 9
	ctx.cr[6].compare_i32(ctx.r[23].s32, 9, &mut ctx.xer);
	// 829E9144: 419A0028  beq cr6, 0x829e916c
	if ctx.cr[6].eq {
	pc = 0x829E916C; continue 'dispatch;
	}
	// 829E9148: 2F170008  cmpwi cr6, r23, 8
	ctx.cr[6].compare_i32(ctx.r[23].s32, 8, &mut ctx.xer);
	// 829E914C: 419A0020  beq cr6, 0x829e916c
	if ctx.cr[6].eq {
	pc = 0x829E916C; continue 'dispatch;
	}
	// 829E9150: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9154: 56EB083C  slwi r11, r23, 1
	ctx.r[11].u32 = ctx.r[23].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E9158: 7D175A14  add r8, r23, r11
	ctx.r[8].u64 = ctx.r[23].u64 + ctx.r[11].u64;
	// 829E915C: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829E9160: 8169007C  lwz r11, 0x7c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E9164: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829E9168: 4800001C  b 0x829e9184
	pc = 0x829E9184; continue 'dispatch;
            }
            0x829E916C => {
    //   block [0x829E916C..0x829E917C)
	// 829E916C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9170: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E9174: 3B2B0018  addi r25, r11, 0x18
	ctx.r[25].s64 = ctx.r[11].s64 + 24;
	// 829E9178: 4800000C  b 0x829e9184
	pc = 0x829E9184; continue 'dispatch;
            }
            0x829E917C => {
    //   block [0x829E917C..0x829E9184)
	// 829E917C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9180: 3B2B0008  addi r25, r11, 8
	ctx.r[25].s64 = ctx.r[11].s64 + 8;
	pc = 0x829E9184; continue 'dispatch;
            }
            0x829E9184 => {
    //   block [0x829E9184..0x829E91A0)
	// 829E9184: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9188: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829E918C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9190: 419A0010  beq cr6, 0x829e91a0
	if ctx.cr[6].eq {
	pc = 0x829E91A0; continue 'dispatch;
	}
	// 829E9194: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E9198: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E919C: 4800000C  b 0x829e91a8
	pc = 0x829E91A8; continue 'dispatch;
            }
            0x829E91A0 => {
    //   block [0x829E91A0..0x829E91A8)
	// 829E91A0: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E91A4: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x829E91A8; continue 'dispatch;
            }
            0x829E91A8 => {
    //   block [0x829E91A8..0x829E91B8)
	// 829E91A8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829E91AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E91B0: 3B6A0B7C  addi r27, r10, 0xb7c
	ctx.r[27].s64 = ctx.r[10].s64 + 2940;
	// 829E91B4: 3B4B0B7C  addi r26, r11, 0xb7c
	ctx.r[26].s64 = ctx.r[11].s64 + 2940;
	pc = 0x829E91B8; continue 'dispatch;
            }
            0x829E91B8 => {
    //   block [0x829E91B8..0x829E91D4)
	// 829E91B8: 578A063E  clrlwi r10, r28, 0x18
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 829E91BC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E91C0: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 829E91C4: 409A0010  bne cr6, 0x829e91d4
	if !ctx.cr[6].eq {
	pc = 0x829E91D4; continue 'dispatch;
	}
	// 829E91C8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E91CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E91D0: 419A0008  beq cr6, 0x829e91d8
	if ctx.cr[6].eq {
	pc = 0x829E91D8; continue 'dispatch;
	}
	pc = 0x829E91D4; continue 'dispatch;
            }
            0x829E91D4 => {
    //   block [0x829E91D4..0x829E91D8)
	// 829E91D4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829E91D8; continue 'dispatch;
            }
            0x829E91D8 => {
    //   block [0x829E91D8..0x829E9264)
	// 829E91D8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E91DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E91E0: 409A00A0  bne cr6, 0x829e9280
	if !ctx.cr[6].eq {
	pc = 0x829E9280; continue 'dispatch;
	}
	// 829E91E4: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E91E8: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E91EC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E91F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E91F4: 419A0070  beq cr6, 0x829e9264
	if ctx.cr[6].eq {
	pc = 0x829E9264; continue 'dispatch;
	}
	// 829E91F8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 829E91FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E9200: 4B81A3E1  bl 0x822035e0
	ctx.lr = 0x829E9204;
	sub_822035E0(ctx, base);
	// 829E9204: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E9208: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E920C: 419A0058  beq cr6, 0x829e9264
	if ctx.cr[6].eq {
	pc = 0x829E9264; continue 'dispatch;
	}
	// 829E9210: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E9214: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 829E9218: 4BB270E1  bl 0x825102f8
	ctx.lr = 0x829E921C;
	sub_825102F8(ctx, base);
	// 829E921C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E9220: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9224: 419A0040  beq cr6, 0x829e9264
	if ctx.cr[6].eq {
	pc = 0x829E9264; continue 'dispatch;
	}
	// 829E9228: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 829E922C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E9230: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829E9234: 4B82B665  bl 0x82214898
	ctx.lr = 0x829E9238;
	sub_82214898(ctx, base);
	// 829E9238: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E923C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829E9240: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 829E9244: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829E9248: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829E924C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829E9250: 4BA6CEC9  bl 0x82456118
	ctx.lr = 0x829E9254;
	sub_82456118(ctx, base);
	// 829E9254: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 829E9258: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E925C: 4B7AABDD  bl 0x82193e38
	ctx.lr = 0x829E9260;
	sub_82193E38(ctx, base);
	// 829E9260: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	pc = 0x829E9264; continue 'dispatch;
            }
            0x829E9264 => {
    //   block [0x829E9264..0x829E9278)
	// 829E9264: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9268: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E926C: 409A000C  bne cr6, 0x829e9278
	if !ctx.cr[6].eq {
	pc = 0x829E9278; continue 'dispatch;
	}
	// 829E9270: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E9274: 4BFFFF44  b 0x829e91b8
	pc = 0x829E91B8; continue 'dispatch;
            }
            0x829E9278 => {
    //   block [0x829E9278..0x829E9280)
	// 829E9278: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E927C: 4BFFFF3C  b 0x829e91b8
	pc = 0x829E91B8; continue 'dispatch;
            }
            0x829E9280 => {
    //   block [0x829E9280..0x829E9288)
	// 829E9280: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829E9284: 482C01BC  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E9288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E9288 size=368
    let mut pc: u32 = 0x829E9288;
    'dispatch: loop {
        match pc {
            0x829E9288 => {
    //   block [0x829E9288..0x829E92DC)
	// 829E9288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E928C: 482C0165  bl 0x82ca93f0
	ctx.lr = 0x829E9290;
	sub_82CA93D0(ctx, base);
	// 829E9290: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E9294: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 829E9298: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 829E929C: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 829E92A0: 2F170007  cmpwi cr6, r23, 7
	ctx.cr[6].compare_i32(ctx.r[23].s32, 7, &mut ctx.xer);
	// 829E92A4: 419A0048  beq cr6, 0x829e92ec
	if ctx.cr[6].eq {
	pc = 0x829E92EC; continue 'dispatch;
	}
	// 829E92A8: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 829E92AC: 419A0040  beq cr6, 0x829e92ec
	if ctx.cr[6].eq {
	pc = 0x829E92EC; continue 'dispatch;
	}
	// 829E92B0: 2F170009  cmpwi cr6, r23, 9
	ctx.cr[6].compare_i32(ctx.r[23].s32, 9, &mut ctx.xer);
	// 829E92B4: 419A0028  beq cr6, 0x829e92dc
	if ctx.cr[6].eq {
	pc = 0x829E92DC; continue 'dispatch;
	}
	// 829E92B8: 2F170008  cmpwi cr6, r23, 8
	ctx.cr[6].compare_i32(ctx.r[23].s32, 8, &mut ctx.xer);
	// 829E92BC: 419A0020  beq cr6, 0x829e92dc
	if ctx.cr[6].eq {
	pc = 0x829E92DC; continue 'dispatch;
	}
	// 829E92C0: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E92C4: 56EB083C  slwi r11, r23, 1
	ctx.r[11].u32 = ctx.r[23].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E92C8: 7D175A14  add r8, r23, r11
	ctx.r[8].u64 = ctx.r[23].u64 + ctx.r[11].u64;
	// 829E92CC: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829E92D0: 8169007C  lwz r11, 0x7c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E92D4: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829E92D8: 4800001C  b 0x829e92f4
	pc = 0x829E92F4; continue 'dispatch;
            }
            0x829E92DC => {
    //   block [0x829E92DC..0x829E92EC)
	// 829E92DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E92E0: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E92E4: 3B2B0018  addi r25, r11, 0x18
	ctx.r[25].s64 = ctx.r[11].s64 + 24;
	// 829E92E8: 4800000C  b 0x829e92f4
	pc = 0x829E92F4; continue 'dispatch;
            }
            0x829E92EC => {
    //   block [0x829E92EC..0x829E92F4)
	// 829E92EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E92F0: 3B2B0008  addi r25, r11, 8
	ctx.r[25].s64 = ctx.r[11].s64 + 8;
	pc = 0x829E92F4; continue 'dispatch;
            }
            0x829E92F4 => {
    //   block [0x829E92F4..0x829E9310)
	// 829E92F4: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E92F8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829E92FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9300: 419A0010  beq cr6, 0x829e9310
	if ctx.cr[6].eq {
	pc = 0x829E9310; continue 'dispatch;
	}
	// 829E9304: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E9308: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E930C: 4800000C  b 0x829e9318
	pc = 0x829E9318; continue 'dispatch;
            }
            0x829E9310 => {
    //   block [0x829E9310..0x829E9318)
	// 829E9310: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E9314: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x829E9318; continue 'dispatch;
            }
            0x829E9318 => {
    //   block [0x829E9318..0x829E9328)
	// 829E9318: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829E931C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E9320: 3B6A0B7C  addi r27, r10, 0xb7c
	ctx.r[27].s64 = ctx.r[10].s64 + 2940;
	// 829E9324: 3B4B0B7C  addi r26, r11, 0xb7c
	ctx.r[26].s64 = ctx.r[11].s64 + 2940;
	pc = 0x829E9328; continue 'dispatch;
            }
            0x829E9328 => {
    //   block [0x829E9328..0x829E9344)
	// 829E9328: 578A063E  clrlwi r10, r28, 0x18
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 829E932C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E9330: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 829E9334: 409A0010  bne cr6, 0x829e9344
	if !ctx.cr[6].eq {
	pc = 0x829E9344; continue 'dispatch;
	}
	// 829E9338: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E933C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E9340: 419A0008  beq cr6, 0x829e9348
	if ctx.cr[6].eq {
	pc = 0x829E9348; continue 'dispatch;
	}
	pc = 0x829E9344; continue 'dispatch;
            }
            0x829E9344 => {
    //   block [0x829E9344..0x829E9348)
	// 829E9344: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829E9348; continue 'dispatch;
            }
            0x829E9348 => {
    //   block [0x829E9348..0x829E93D4)
	// 829E9348: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E934C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9350: 409A00A0  bne cr6, 0x829e93f0
	if !ctx.cr[6].eq {
	pc = 0x829E93F0; continue 'dispatch;
	}
	// 829E9354: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E9358: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E935C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E9360: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E9364: 419A0070  beq cr6, 0x829e93d4
	if ctx.cr[6].eq {
	pc = 0x829E93D4; continue 'dispatch;
	}
	// 829E9368: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 829E936C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E9370: 4B81A271  bl 0x822035e0
	ctx.lr = 0x829E9374;
	sub_822035E0(ctx, base);
	// 829E9374: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E9378: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E937C: 419A0058  beq cr6, 0x829e93d4
	if ctx.cr[6].eq {
	pc = 0x829E93D4; continue 'dispatch;
	}
	// 829E9380: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E9384: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 829E9388: 4BB26A01  bl 0x8250fd88
	ctx.lr = 0x829E938C;
	sub_8250FD88(ctx, base);
	// 829E938C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E9390: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9394: 419A0040  beq cr6, 0x829e93d4
	if ctx.cr[6].eq {
	pc = 0x829E93D4; continue 'dispatch;
	}
	// 829E9398: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 829E939C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E93A0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829E93A4: 4B82B4F5  bl 0x82214898
	ctx.lr = 0x829E93A8;
	sub_82214898(ctx, base);
	// 829E93A8: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E93AC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829E93B0: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 829E93B4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829E93B8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829E93BC: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829E93C0: 4BA6CD59  bl 0x82456118
	ctx.lr = 0x829E93C4;
	sub_82456118(ctx, base);
	// 829E93C4: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 829E93C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E93CC: 4B7AAA6D  bl 0x82193e38
	ctx.lr = 0x829E93D0;
	sub_82193E38(ctx, base);
	// 829E93D0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	pc = 0x829E93D4; continue 'dispatch;
            }
            0x829E93D4 => {
    //   block [0x829E93D4..0x829E93E8)
	// 829E93D4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E93D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E93DC: 409A000C  bne cr6, 0x829e93e8
	if !ctx.cr[6].eq {
	pc = 0x829E93E8; continue 'dispatch;
	}
	// 829E93E0: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E93E4: 4BFFFF44  b 0x829e9328
	pc = 0x829E9328; continue 'dispatch;
            }
            0x829E93E8 => {
    //   block [0x829E93E8..0x829E93F0)
	// 829E93E8: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E93EC: 4BFFFF3C  b 0x829e9328
	pc = 0x829E9328; continue 'dispatch;
            }
            0x829E93F0 => {
    //   block [0x829E93F0..0x829E93F8)
	// 829E93F0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829E93F4: 482C004C  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E93F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E93F8 size=368
    let mut pc: u32 = 0x829E93F8;
    'dispatch: loop {
        match pc {
            0x829E93F8 => {
    //   block [0x829E93F8..0x829E944C)
	// 829E93F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E93FC: 482BFFF5  bl 0x82ca93f0
	ctx.lr = 0x829E9400;
	sub_82CA93D0(ctx, base);
	// 829E9400: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E9404: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 829E9408: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 829E940C: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 829E9410: 2F170007  cmpwi cr6, r23, 7
	ctx.cr[6].compare_i32(ctx.r[23].s32, 7, &mut ctx.xer);
	// 829E9414: 419A0048  beq cr6, 0x829e945c
	if ctx.cr[6].eq {
	pc = 0x829E945C; continue 'dispatch;
	}
	// 829E9418: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 829E941C: 419A0040  beq cr6, 0x829e945c
	if ctx.cr[6].eq {
	pc = 0x829E945C; continue 'dispatch;
	}
	// 829E9420: 2F170009  cmpwi cr6, r23, 9
	ctx.cr[6].compare_i32(ctx.r[23].s32, 9, &mut ctx.xer);
	// 829E9424: 419A0028  beq cr6, 0x829e944c
	if ctx.cr[6].eq {
	pc = 0x829E944C; continue 'dispatch;
	}
	// 829E9428: 2F170008  cmpwi cr6, r23, 8
	ctx.cr[6].compare_i32(ctx.r[23].s32, 8, &mut ctx.xer);
	// 829E942C: 419A0020  beq cr6, 0x829e944c
	if ctx.cr[6].eq {
	pc = 0x829E944C; continue 'dispatch;
	}
	// 829E9430: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9434: 56EB083C  slwi r11, r23, 1
	ctx.r[11].u32 = ctx.r[23].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E9438: 7D175A14  add r8, r23, r11
	ctx.r[8].u64 = ctx.r[23].u64 + ctx.r[11].u64;
	// 829E943C: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829E9440: 8169007C  lwz r11, 0x7c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E9444: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829E9448: 4800001C  b 0x829e9464
	pc = 0x829E9464; continue 'dispatch;
            }
            0x829E944C => {
    //   block [0x829E944C..0x829E945C)
	// 829E944C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9450: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E9454: 3B2B0018  addi r25, r11, 0x18
	ctx.r[25].s64 = ctx.r[11].s64 + 24;
	// 829E9458: 4800000C  b 0x829e9464
	pc = 0x829E9464; continue 'dispatch;
            }
            0x829E945C => {
    //   block [0x829E945C..0x829E9464)
	// 829E945C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9460: 3B2B0008  addi r25, r11, 8
	ctx.r[25].s64 = ctx.r[11].s64 + 8;
	pc = 0x829E9464; continue 'dispatch;
            }
            0x829E9464 => {
    //   block [0x829E9464..0x829E9480)
	// 829E9464: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9468: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829E946C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9470: 419A0010  beq cr6, 0x829e9480
	if ctx.cr[6].eq {
	pc = 0x829E9480; continue 'dispatch;
	}
	// 829E9474: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E9478: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E947C: 4800000C  b 0x829e9488
	pc = 0x829E9488; continue 'dispatch;
            }
            0x829E9480 => {
    //   block [0x829E9480..0x829E9488)
	// 829E9480: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E9484: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x829E9488; continue 'dispatch;
            }
            0x829E9488 => {
    //   block [0x829E9488..0x829E9498)
	// 829E9488: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829E948C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E9490: 3B6A0B7C  addi r27, r10, 0xb7c
	ctx.r[27].s64 = ctx.r[10].s64 + 2940;
	// 829E9494: 3B4B0B7C  addi r26, r11, 0xb7c
	ctx.r[26].s64 = ctx.r[11].s64 + 2940;
	pc = 0x829E9498; continue 'dispatch;
            }
            0x829E9498 => {
    //   block [0x829E9498..0x829E94B4)
	// 829E9498: 578A063E  clrlwi r10, r28, 0x18
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 829E949C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E94A0: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 829E94A4: 409A0010  bne cr6, 0x829e94b4
	if !ctx.cr[6].eq {
	pc = 0x829E94B4; continue 'dispatch;
	}
	// 829E94A8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E94AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E94B0: 419A0008  beq cr6, 0x829e94b8
	if ctx.cr[6].eq {
	pc = 0x829E94B8; continue 'dispatch;
	}
	pc = 0x829E94B4; continue 'dispatch;
            }
            0x829E94B4 => {
    //   block [0x829E94B4..0x829E94B8)
	// 829E94B4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829E94B8; continue 'dispatch;
            }
            0x829E94B8 => {
    //   block [0x829E94B8..0x829E9544)
	// 829E94B8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E94BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E94C0: 409A00A0  bne cr6, 0x829e9560
	if !ctx.cr[6].eq {
	pc = 0x829E9560; continue 'dispatch;
	}
	// 829E94C4: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E94C8: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E94CC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E94D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E94D4: 419A0070  beq cr6, 0x829e9544
	if ctx.cr[6].eq {
	pc = 0x829E9544; continue 'dispatch;
	}
	// 829E94D8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 829E94DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E94E0: 4B81A101  bl 0x822035e0
	ctx.lr = 0x829E94E4;
	sub_822035E0(ctx, base);
	// 829E94E4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E94E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E94EC: 419A0058  beq cr6, 0x829e9544
	if ctx.cr[6].eq {
	pc = 0x829E9544; continue 'dispatch;
	}
	// 829E94F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E94F4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 829E94F8: 4BB269B9  bl 0x8250feb0
	ctx.lr = 0x829E94FC;
	sub_8250FEB0(ctx, base);
	// 829E94FC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E9500: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9504: 419A0040  beq cr6, 0x829e9544
	if ctx.cr[6].eq {
	pc = 0x829E9544; continue 'dispatch;
	}
	// 829E9508: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 829E950C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E9510: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829E9514: 4B82B385  bl 0x82214898
	ctx.lr = 0x829E9518;
	sub_82214898(ctx, base);
	// 829E9518: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E951C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829E9520: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 829E9524: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829E9528: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829E952C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829E9530: 4BA6CBE9  bl 0x82456118
	ctx.lr = 0x829E9534;
	sub_82456118(ctx, base);
	// 829E9534: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 829E9538: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E953C: 4B7AA8FD  bl 0x82193e38
	ctx.lr = 0x829E9540;
	sub_82193E38(ctx, base);
	// 829E9540: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	pc = 0x829E9544; continue 'dispatch;
            }
            0x829E9544 => {
    //   block [0x829E9544..0x829E9558)
	// 829E9544: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9548: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E954C: 409A000C  bne cr6, 0x829e9558
	if !ctx.cr[6].eq {
	pc = 0x829E9558; continue 'dispatch;
	}
	// 829E9550: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E9554: 4BFFFF44  b 0x829e9498
	pc = 0x829E9498; continue 'dispatch;
            }
            0x829E9558 => {
    //   block [0x829E9558..0x829E9560)
	// 829E9558: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E955C: 4BFFFF3C  b 0x829e9498
	pc = 0x829E9498; continue 'dispatch;
            }
            0x829E9560 => {
    //   block [0x829E9560..0x829E9568)
	// 829E9560: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829E9564: 482BFEDC  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E9568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E9568 size=372
    let mut pc: u32 = 0x829E9568;
    'dispatch: loop {
        match pc {
            0x829E9568 => {
    //   block [0x829E9568..0x829E95BC)
	// 829E9568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E956C: 482BFE85  bl 0x82ca93f0
	ctx.lr = 0x829E9570;
	sub_82CA93D0(ctx, base);
	// 829E9570: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E9574: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 829E9578: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 829E957C: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 829E9580: 2F170007  cmpwi cr6, r23, 7
	ctx.cr[6].compare_i32(ctx.r[23].s32, 7, &mut ctx.xer);
	// 829E9584: 419A0048  beq cr6, 0x829e95cc
	if ctx.cr[6].eq {
	pc = 0x829E95CC; continue 'dispatch;
	}
	// 829E9588: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 829E958C: 419A0040  beq cr6, 0x829e95cc
	if ctx.cr[6].eq {
	pc = 0x829E95CC; continue 'dispatch;
	}
	// 829E9590: 2F170009  cmpwi cr6, r23, 9
	ctx.cr[6].compare_i32(ctx.r[23].s32, 9, &mut ctx.xer);
	// 829E9594: 419A0028  beq cr6, 0x829e95bc
	if ctx.cr[6].eq {
	pc = 0x829E95BC; continue 'dispatch;
	}
	// 829E9598: 2F170008  cmpwi cr6, r23, 8
	ctx.cr[6].compare_i32(ctx.r[23].s32, 8, &mut ctx.xer);
	// 829E959C: 419A0020  beq cr6, 0x829e95bc
	if ctx.cr[6].eq {
	pc = 0x829E95BC; continue 'dispatch;
	}
	// 829E95A0: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E95A4: 56EB083C  slwi r11, r23, 1
	ctx.r[11].u32 = ctx.r[23].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E95A8: 7D175A14  add r8, r23, r11
	ctx.r[8].u64 = ctx.r[23].u64 + ctx.r[11].u64;
	// 829E95AC: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829E95B0: 8169007C  lwz r11, 0x7c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E95B4: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829E95B8: 4800001C  b 0x829e95d4
	pc = 0x829E95D4; continue 'dispatch;
            }
            0x829E95BC => {
    //   block [0x829E95BC..0x829E95CC)
	// 829E95BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E95C0: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E95C4: 3B2B0018  addi r25, r11, 0x18
	ctx.r[25].s64 = ctx.r[11].s64 + 24;
	// 829E95C8: 4800000C  b 0x829e95d4
	pc = 0x829E95D4; continue 'dispatch;
            }
            0x829E95CC => {
    //   block [0x829E95CC..0x829E95D4)
	// 829E95CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E95D0: 3B2B0008  addi r25, r11, 8
	ctx.r[25].s64 = ctx.r[11].s64 + 8;
	pc = 0x829E95D4; continue 'dispatch;
            }
            0x829E95D4 => {
    //   block [0x829E95D4..0x829E95F0)
	// 829E95D4: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E95D8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829E95DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E95E0: 419A0010  beq cr6, 0x829e95f0
	if ctx.cr[6].eq {
	pc = 0x829E95F0; continue 'dispatch;
	}
	// 829E95E4: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E95E8: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E95EC: 4800000C  b 0x829e95f8
	pc = 0x829E95F8; continue 'dispatch;
            }
            0x829E95F0 => {
    //   block [0x829E95F0..0x829E95F8)
	// 829E95F0: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E95F4: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x829E95F8; continue 'dispatch;
            }
            0x829E95F8 => {
    //   block [0x829E95F8..0x829E9608)
	// 829E95F8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829E95FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E9600: 3B6A0B7C  addi r27, r10, 0xb7c
	ctx.r[27].s64 = ctx.r[10].s64 + 2940;
	// 829E9604: 3B4B0B7C  addi r26, r11, 0xb7c
	ctx.r[26].s64 = ctx.r[11].s64 + 2940;
	pc = 0x829E9608; continue 'dispatch;
            }
            0x829E9608 => {
    //   block [0x829E9608..0x829E9624)
	// 829E9608: 578A063E  clrlwi r10, r28, 0x18
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 829E960C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E9610: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 829E9614: 409A0010  bne cr6, 0x829e9624
	if !ctx.cr[6].eq {
	pc = 0x829E9624; continue 'dispatch;
	}
	// 829E9618: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E961C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E9620: 419A0008  beq cr6, 0x829e9628
	if ctx.cr[6].eq {
	pc = 0x829E9628; continue 'dispatch;
	}
	pc = 0x829E9624; continue 'dispatch;
            }
            0x829E9624 => {
    //   block [0x829E9624..0x829E9628)
	// 829E9624: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829E9628; continue 'dispatch;
            }
            0x829E9628 => {
    //   block [0x829E9628..0x829E96B8)
	// 829E9628: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E962C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9630: 409A00A4  bne cr6, 0x829e96d4
	if !ctx.cr[6].eq {
	pc = 0x829E96D4; continue 'dispatch;
	}
	// 829E9634: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E9638: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E963C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E9640: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E9644: 419A0074  beq cr6, 0x829e96b8
	if ctx.cr[6].eq {
	pc = 0x829E96B8; continue 'dispatch;
	}
	// 829E9648: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 829E964C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E9650: 4B819F91  bl 0x822035e0
	ctx.lr = 0x829E9654;
	sub_822035E0(ctx, base);
	// 829E9654: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E9658: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E965C: 419A005C  beq cr6, 0x829e96b8
	if ctx.cr[6].eq {
	pc = 0x829E96B8; continue 'dispatch;
	}
	// 829E9660: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E9664: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 829E9668: 4BB27F31  bl 0x82511598
	ctx.lr = 0x829E966C;
	sub_82511598(ctx, base);
	// 829E966C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E9670: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9674: 419A0044  beq cr6, 0x829e96b8
	if ctx.cr[6].eq {
	pc = 0x829E96B8; continue 'dispatch;
	}
	// 829E9678: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 829E967C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E9680: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829E9684: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E9688: 4B82B211  bl 0x82214898
	ctx.lr = 0x829E968C;
	sub_82214898(ctx, base);
	// 829E968C: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E9690: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829E9694: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 829E9698: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829E969C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829E96A0: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829E96A4: 4BA6CA75  bl 0x82456118
	ctx.lr = 0x829E96A8;
	sub_82456118(ctx, base);
	// 829E96A8: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 829E96AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E96B0: 4B7AA789  bl 0x82193e38
	ctx.lr = 0x829E96B4;
	sub_82193E38(ctx, base);
	// 829E96B4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	pc = 0x829E96B8; continue 'dispatch;
            }
            0x829E96B8 => {
    //   block [0x829E96B8..0x829E96CC)
	// 829E96B8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E96BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E96C0: 409A000C  bne cr6, 0x829e96cc
	if !ctx.cr[6].eq {
	pc = 0x829E96CC; continue 'dispatch;
	}
	// 829E96C4: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E96C8: 4BFFFF40  b 0x829e9608
	pc = 0x829E9608; continue 'dispatch;
            }
            0x829E96CC => {
    //   block [0x829E96CC..0x829E96D4)
	// 829E96CC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E96D0: 4BFFFF38  b 0x829e9608
	pc = 0x829E9608; continue 'dispatch;
            }
            0x829E96D4 => {
    //   block [0x829E96D4..0x829E96DC)
	// 829E96D4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829E96D8: 482BFD68  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E96E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E96E0 size=372
    let mut pc: u32 = 0x829E96E0;
    'dispatch: loop {
        match pc {
            0x829E96E0 => {
    //   block [0x829E96E0..0x829E9734)
	// 829E96E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E96E4: 482BFD0D  bl 0x82ca93f0
	ctx.lr = 0x829E96E8;
	sub_82CA93D0(ctx, base);
	// 829E96E8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E96EC: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 829E96F0: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 829E96F4: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 829E96F8: 2F170007  cmpwi cr6, r23, 7
	ctx.cr[6].compare_i32(ctx.r[23].s32, 7, &mut ctx.xer);
	// 829E96FC: 419A0048  beq cr6, 0x829e9744
	if ctx.cr[6].eq {
	pc = 0x829E9744; continue 'dispatch;
	}
	// 829E9700: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 829E9704: 419A0040  beq cr6, 0x829e9744
	if ctx.cr[6].eq {
	pc = 0x829E9744; continue 'dispatch;
	}
	// 829E9708: 2F170009  cmpwi cr6, r23, 9
	ctx.cr[6].compare_i32(ctx.r[23].s32, 9, &mut ctx.xer);
	// 829E970C: 419A0028  beq cr6, 0x829e9734
	if ctx.cr[6].eq {
	pc = 0x829E9734; continue 'dispatch;
	}
	// 829E9710: 2F170008  cmpwi cr6, r23, 8
	ctx.cr[6].compare_i32(ctx.r[23].s32, 8, &mut ctx.xer);
	// 829E9714: 419A0020  beq cr6, 0x829e9734
	if ctx.cr[6].eq {
	pc = 0x829E9734; continue 'dispatch;
	}
	// 829E9718: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E971C: 56EB083C  slwi r11, r23, 1
	ctx.r[11].u32 = ctx.r[23].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E9720: 7D175A14  add r8, r23, r11
	ctx.r[8].u64 = ctx.r[23].u64 + ctx.r[11].u64;
	// 829E9724: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829E9728: 8169007C  lwz r11, 0x7c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E972C: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829E9730: 4800001C  b 0x829e974c
	pc = 0x829E974C; continue 'dispatch;
            }
            0x829E9734 => {
    //   block [0x829E9734..0x829E9744)
	// 829E9734: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9738: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E973C: 3B2B0018  addi r25, r11, 0x18
	ctx.r[25].s64 = ctx.r[11].s64 + 24;
	// 829E9740: 4800000C  b 0x829e974c
	pc = 0x829E974C; continue 'dispatch;
            }
            0x829E9744 => {
    //   block [0x829E9744..0x829E974C)
	// 829E9744: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9748: 3B2B0008  addi r25, r11, 8
	ctx.r[25].s64 = ctx.r[11].s64 + 8;
	pc = 0x829E974C; continue 'dispatch;
            }
            0x829E974C => {
    //   block [0x829E974C..0x829E9768)
	// 829E974C: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9750: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829E9754: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9758: 419A0010  beq cr6, 0x829e9768
	if ctx.cr[6].eq {
	pc = 0x829E9768; continue 'dispatch;
	}
	// 829E975C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E9760: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E9764: 4800000C  b 0x829e9770
	pc = 0x829E9770; continue 'dispatch;
            }
            0x829E9768 => {
    //   block [0x829E9768..0x829E9770)
	// 829E9768: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E976C: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x829E9770; continue 'dispatch;
            }
            0x829E9770 => {
    //   block [0x829E9770..0x829E9780)
	// 829E9770: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829E9774: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E9778: 3B6A0B7C  addi r27, r10, 0xb7c
	ctx.r[27].s64 = ctx.r[10].s64 + 2940;
	// 829E977C: 3B4B0B7C  addi r26, r11, 0xb7c
	ctx.r[26].s64 = ctx.r[11].s64 + 2940;
	pc = 0x829E9780; continue 'dispatch;
            }
            0x829E9780 => {
    //   block [0x829E9780..0x829E979C)
	// 829E9780: 578A063E  clrlwi r10, r28, 0x18
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 829E9784: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E9788: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 829E978C: 409A0010  bne cr6, 0x829e979c
	if !ctx.cr[6].eq {
	pc = 0x829E979C; continue 'dispatch;
	}
	// 829E9790: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E9794: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E9798: 419A0008  beq cr6, 0x829e97a0
	if ctx.cr[6].eq {
	pc = 0x829E97A0; continue 'dispatch;
	}
	pc = 0x829E979C; continue 'dispatch;
            }
            0x829E979C => {
    //   block [0x829E979C..0x829E97A0)
	// 829E979C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829E97A0; continue 'dispatch;
            }
            0x829E97A0 => {
    //   block [0x829E97A0..0x829E9830)
	// 829E97A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E97A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E97A8: 409A00A4  bne cr6, 0x829e984c
	if !ctx.cr[6].eq {
	pc = 0x829E984C; continue 'dispatch;
	}
	// 829E97AC: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E97B0: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E97B4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E97B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E97BC: 419A0074  beq cr6, 0x829e9830
	if ctx.cr[6].eq {
	pc = 0x829E9830; continue 'dispatch;
	}
	// 829E97C0: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 829E97C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E97C8: 4B819E19  bl 0x822035e0
	ctx.lr = 0x829E97CC;
	sub_822035E0(ctx, base);
	// 829E97CC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E97D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E97D4: 419A005C  beq cr6, 0x829e9830
	if ctx.cr[6].eq {
	pc = 0x829E9830; continue 'dispatch;
	}
	// 829E97D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E97DC: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 829E97E0: 4BB27FE9  bl 0x825117c8
	ctx.lr = 0x829E97E4;
	sub_825117C8(ctx, base);
	// 829E97E4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E97E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E97EC: 419A0044  beq cr6, 0x829e9830
	if ctx.cr[6].eq {
	pc = 0x829E9830; continue 'dispatch;
	}
	// 829E97F0: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 829E97F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E97F8: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829E97FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E9800: 4B82B099  bl 0x82214898
	ctx.lr = 0x829E9804;
	sub_82214898(ctx, base);
	// 829E9804: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E9808: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829E980C: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 829E9810: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829E9814: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829E9818: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829E981C: 4BA6C8FD  bl 0x82456118
	ctx.lr = 0x829E9820;
	sub_82456118(ctx, base);
	// 829E9820: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 829E9824: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E9828: 4B7AA611  bl 0x82193e38
	ctx.lr = 0x829E982C;
	sub_82193E38(ctx, base);
	// 829E982C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	pc = 0x829E9830; continue 'dispatch;
            }
            0x829E9830 => {
    //   block [0x829E9830..0x829E9844)
	// 829E9830: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9834: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9838: 409A000C  bne cr6, 0x829e9844
	if !ctx.cr[6].eq {
	pc = 0x829E9844; continue 'dispatch;
	}
	// 829E983C: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E9840: 4BFFFF40  b 0x829e9780
	pc = 0x829E9780; continue 'dispatch;
            }
            0x829E9844 => {
    //   block [0x829E9844..0x829E984C)
	// 829E9844: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E9848: 4BFFFF38  b 0x829e9780
	pc = 0x829E9780; continue 'dispatch;
            }
            0x829E984C => {
    //   block [0x829E984C..0x829E9854)
	// 829E984C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829E9850: 482BFBF0  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E9858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E9858 size=380
    let mut pc: u32 = 0x829E9858;
    'dispatch: loop {
        match pc {
            0x829E9858 => {
    //   block [0x829E9858..0x829E98AC)
	// 829E9858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E985C: 482BFB95  bl 0x82ca93f0
	ctx.lr = 0x829E9860;
	sub_82CA93D0(ctx, base);
	// 829E9860: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E9864: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 829E9868: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 829E986C: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 829E9870: 2F170007  cmpwi cr6, r23, 7
	ctx.cr[6].compare_i32(ctx.r[23].s32, 7, &mut ctx.xer);
	// 829E9874: 419A0048  beq cr6, 0x829e98bc
	if ctx.cr[6].eq {
	pc = 0x829E98BC; continue 'dispatch;
	}
	// 829E9878: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 829E987C: 419A0040  beq cr6, 0x829e98bc
	if ctx.cr[6].eq {
	pc = 0x829E98BC; continue 'dispatch;
	}
	// 829E9880: 2F170009  cmpwi cr6, r23, 9
	ctx.cr[6].compare_i32(ctx.r[23].s32, 9, &mut ctx.xer);
	// 829E9884: 419A0028  beq cr6, 0x829e98ac
	if ctx.cr[6].eq {
	pc = 0x829E98AC; continue 'dispatch;
	}
	// 829E9888: 2F170008  cmpwi cr6, r23, 8
	ctx.cr[6].compare_i32(ctx.r[23].s32, 8, &mut ctx.xer);
	// 829E988C: 419A0020  beq cr6, 0x829e98ac
	if ctx.cr[6].eq {
	pc = 0x829E98AC; continue 'dispatch;
	}
	// 829E9890: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9894: 56EB083C  slwi r11, r23, 1
	ctx.r[11].u32 = ctx.r[23].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E9898: 7D175A14  add r8, r23, r11
	ctx.r[8].u64 = ctx.r[23].u64 + ctx.r[11].u64;
	// 829E989C: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829E98A0: 8169007C  lwz r11, 0x7c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E98A4: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829E98A8: 4800001C  b 0x829e98c4
	pc = 0x829E98C4; continue 'dispatch;
            }
            0x829E98AC => {
    //   block [0x829E98AC..0x829E98BC)
	// 829E98AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E98B0: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E98B4: 3B2B0018  addi r25, r11, 0x18
	ctx.r[25].s64 = ctx.r[11].s64 + 24;
	// 829E98B8: 4800000C  b 0x829e98c4
	pc = 0x829E98C4; continue 'dispatch;
            }
            0x829E98BC => {
    //   block [0x829E98BC..0x829E98C4)
	// 829E98BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E98C0: 3B2B0008  addi r25, r11, 8
	ctx.r[25].s64 = ctx.r[11].s64 + 8;
	pc = 0x829E98C4; continue 'dispatch;
            }
            0x829E98C4 => {
    //   block [0x829E98C4..0x829E98E0)
	// 829E98C4: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E98C8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829E98CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E98D0: 419A0010  beq cr6, 0x829e98e0
	if ctx.cr[6].eq {
	pc = 0x829E98E0; continue 'dispatch;
	}
	// 829E98D4: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E98D8: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E98DC: 4800000C  b 0x829e98e8
	pc = 0x829E98E8; continue 'dispatch;
            }
            0x829E98E0 => {
    //   block [0x829E98E0..0x829E98E8)
	// 829E98E0: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E98E4: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x829E98E8; continue 'dispatch;
            }
            0x829E98E8 => {
    //   block [0x829E98E8..0x829E98F8)
	// 829E98E8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829E98EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E98F0: 3B6A0B7C  addi r27, r10, 0xb7c
	ctx.r[27].s64 = ctx.r[10].s64 + 2940;
	// 829E98F4: 3B4B0B7C  addi r26, r11, 0xb7c
	ctx.r[26].s64 = ctx.r[11].s64 + 2940;
	pc = 0x829E98F8; continue 'dispatch;
            }
            0x829E98F8 => {
    //   block [0x829E98F8..0x829E9914)
	// 829E98F8: 578A063E  clrlwi r10, r28, 0x18
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 829E98FC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E9900: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 829E9904: 409A0010  bne cr6, 0x829e9914
	if !ctx.cr[6].eq {
	pc = 0x829E9914; continue 'dispatch;
	}
	// 829E9908: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E990C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E9910: 419A0008  beq cr6, 0x829e9918
	if ctx.cr[6].eq {
	pc = 0x829E9918; continue 'dispatch;
	}
	pc = 0x829E9914; continue 'dispatch;
            }
            0x829E9914 => {
    //   block [0x829E9914..0x829E9918)
	// 829E9914: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829E9918; continue 'dispatch;
            }
            0x829E9918 => {
    //   block [0x829E9918..0x829E99B0)
	// 829E9918: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E991C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9920: 409A00AC  bne cr6, 0x829e99cc
	if !ctx.cr[6].eq {
	pc = 0x829E99CC; continue 'dispatch;
	}
	// 829E9924: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E9928: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E992C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E9930: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E9934: 419A007C  beq cr6, 0x829e99b0
	if ctx.cr[6].eq {
	pc = 0x829E99B0; continue 'dispatch;
	}
	// 829E9938: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 829E993C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E9940: 4B819CA1  bl 0x822035e0
	ctx.lr = 0x829E9944;
	sub_822035E0(ctx, base);
	// 829E9944: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E9948: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E994C: 419A0064  beq cr6, 0x829e99b0
	if ctx.cr[6].eq {
	pc = 0x829E99B0; continue 'dispatch;
	}
	// 829E9950: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E9954: 80D60008  lwz r6, 8(r22)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E9958: 80B60004  lwz r5, 4(r22)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E995C: 8076000C  lwz r3, 0xc(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(12 as u32) ) } as u64;
	// 829E9960: 4B887A09  bl 0x82271368
	ctx.lr = 0x829E9964;
	sub_82271368(ctx, base);
	// 829E9964: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E9968: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E996C: 419A0044  beq cr6, 0x829e99b0
	if ctx.cr[6].eq {
	pc = 0x829E99B0; continue 'dispatch;
	}
	// 829E9970: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 829E9974: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E9978: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829E997C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E9980: 4B82AF19  bl 0x82214898
	ctx.lr = 0x829E9984;
	sub_82214898(ctx, base);
	// 829E9984: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E9988: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829E998C: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 829E9990: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829E9994: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829E9998: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829E999C: 4BA6C77D  bl 0x82456118
	ctx.lr = 0x829E99A0;
	sub_82456118(ctx, base);
	// 829E99A0: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 829E99A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E99A8: 4B7AA491  bl 0x82193e38
	ctx.lr = 0x829E99AC;
	sub_82193E38(ctx, base);
	// 829E99AC: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	pc = 0x829E99B0; continue 'dispatch;
            }
            0x829E99B0 => {
    //   block [0x829E99B0..0x829E99C4)
	// 829E99B0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E99B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E99B8: 409A000C  bne cr6, 0x829e99c4
	if !ctx.cr[6].eq {
	pc = 0x829E99C4; continue 'dispatch;
	}
	// 829E99BC: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E99C0: 4BFFFF38  b 0x829e98f8
	pc = 0x829E98F8; continue 'dispatch;
            }
            0x829E99C4 => {
    //   block [0x829E99C4..0x829E99CC)
	// 829E99C4: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E99C8: 4BFFFF30  b 0x829e98f8
	pc = 0x829E98F8; continue 'dispatch;
            }
            0x829E99CC => {
    //   block [0x829E99CC..0x829E99D4)
	// 829E99CC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829E99D0: 482BFA70  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E99D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E99D8 size=344
    let mut pc: u32 = 0x829E99D8;
    'dispatch: loop {
        match pc {
            0x829E99D8 => {
    //   block [0x829E99D8..0x829E9A28)
	// 829E99D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E99DC: 482BFA19  bl 0x82ca93f4
	ctx.lr = 0x829E99E0;
	sub_82CA93D0(ctx, base);
	// 829E99E0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E99E4: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 829E99E8: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 829E99EC: 2F170007  cmpwi cr6, r23, 7
	ctx.cr[6].compare_i32(ctx.r[23].s32, 7, &mut ctx.xer);
	// 829E99F0: 419A0048  beq cr6, 0x829e9a38
	if ctx.cr[6].eq {
	pc = 0x829E9A38; continue 'dispatch;
	}
	// 829E99F4: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 829E99F8: 419A0040  beq cr6, 0x829e9a38
	if ctx.cr[6].eq {
	pc = 0x829E9A38; continue 'dispatch;
	}
	// 829E99FC: 2F170009  cmpwi cr6, r23, 9
	ctx.cr[6].compare_i32(ctx.r[23].s32, 9, &mut ctx.xer);
	// 829E9A00: 419A0028  beq cr6, 0x829e9a28
	if ctx.cr[6].eq {
	pc = 0x829E9A28; continue 'dispatch;
	}
	// 829E9A04: 2F170008  cmpwi cr6, r23, 8
	ctx.cr[6].compare_i32(ctx.r[23].s32, 8, &mut ctx.xer);
	// 829E9A08: 419A0020  beq cr6, 0x829e9a28
	if ctx.cr[6].eq {
	pc = 0x829E9A28; continue 'dispatch;
	}
	// 829E9A0C: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9A10: 56EB083C  slwi r11, r23, 1
	ctx.r[11].u32 = ctx.r[23].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E9A14: 7D175A14  add r8, r23, r11
	ctx.r[8].u64 = ctx.r[23].u64 + ctx.r[11].u64;
	// 829E9A18: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829E9A1C: 8169007C  lwz r11, 0x7c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E9A20: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829E9A24: 4800001C  b 0x829e9a40
	pc = 0x829E9A40; continue 'dispatch;
            }
            0x829E9A28 => {
    //   block [0x829E9A28..0x829E9A38)
	// 829E9A28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9A2C: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E9A30: 3B2B0018  addi r25, r11, 0x18
	ctx.r[25].s64 = ctx.r[11].s64 + 24;
	// 829E9A34: 4800000C  b 0x829e9a40
	pc = 0x829E9A40; continue 'dispatch;
            }
            0x829E9A38 => {
    //   block [0x829E9A38..0x829E9A40)
	// 829E9A38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9A3C: 3B2B0008  addi r25, r11, 8
	ctx.r[25].s64 = ctx.r[11].s64 + 8;
	pc = 0x829E9A40; continue 'dispatch;
            }
            0x829E9A40 => {
    //   block [0x829E9A40..0x829E9A5C)
	// 829E9A40: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9A44: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829E9A48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9A4C: 419A0010  beq cr6, 0x829e9a5c
	if ctx.cr[6].eq {
	pc = 0x829E9A5C; continue 'dispatch;
	}
	// 829E9A50: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E9A54: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E9A58: 4800000C  b 0x829e9a64
	pc = 0x829E9A64; continue 'dispatch;
            }
            0x829E9A5C => {
    //   block [0x829E9A5C..0x829E9A64)
	// 829E9A5C: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E9A60: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x829E9A64; continue 'dispatch;
            }
            0x829E9A64 => {
    //   block [0x829E9A64..0x829E9A74)
	// 829E9A64: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829E9A68: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E9A6C: 3B6A0B7C  addi r27, r10, 0xb7c
	ctx.r[27].s64 = ctx.r[10].s64 + 2940;
	// 829E9A70: 3B4B0B7C  addi r26, r11, 0xb7c
	ctx.r[26].s64 = ctx.r[11].s64 + 2940;
	pc = 0x829E9A74; continue 'dispatch;
            }
            0x829E9A74 => {
    //   block [0x829E9A74..0x829E9A90)
	// 829E9A74: 578A063E  clrlwi r10, r28, 0x18
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 829E9A78: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E9A7C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 829E9A80: 409A0010  bne cr6, 0x829e9a90
	if !ctx.cr[6].eq {
	pc = 0x829E9A90; continue 'dispatch;
	}
	// 829E9A84: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E9A88: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E9A8C: 419A0008  beq cr6, 0x829e9a94
	if ctx.cr[6].eq {
	pc = 0x829E9A94; continue 'dispatch;
	}
	pc = 0x829E9A90; continue 'dispatch;
            }
            0x829E9A90 => {
    //   block [0x829E9A90..0x829E9A94)
	// 829E9A90: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829E9A94; continue 'dispatch;
            }
            0x829E9A94 => {
    //   block [0x829E9A94..0x829E9B0C)
	// 829E9A94: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E9A98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9A9C: 409A008C  bne cr6, 0x829e9b28
	if !ctx.cr[6].eq {
	pc = 0x829E9B28; continue 'dispatch;
	}
	// 829E9AA0: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E9AA4: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E9AA8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E9AAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E9AB0: 419A005C  beq cr6, 0x829e9b0c
	if ctx.cr[6].eq {
	pc = 0x829E9B0C; continue 'dispatch;
	}
	// 829E9AB4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 829E9AB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E9ABC: 4B819B25  bl 0x822035e0
	ctx.lr = 0x829E9AC0;
	sub_822035E0(ctx, base);
	// 829E9AC0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E9AC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9AC8: 419A0044  beq cr6, 0x829e9b0c
	if ctx.cr[6].eq {
	pc = 0x829E9B0C; continue 'dispatch;
	}
	// 829E9ACC: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 829E9AD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E9AD4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829E9AD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E9ADC: 4B82ADBD  bl 0x82214898
	ctx.lr = 0x829E9AE0;
	sub_82214898(ctx, base);
	// 829E9AE0: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E9AE4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829E9AE8: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 829E9AEC: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829E9AF0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829E9AF4: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829E9AF8: 4BA6C621  bl 0x82456118
	ctx.lr = 0x829E9AFC;
	sub_82456118(ctx, base);
	// 829E9AFC: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 829E9B00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E9B04: 4B7AA335  bl 0x82193e38
	ctx.lr = 0x829E9B08;
	sub_82193E38(ctx, base);
	// 829E9B08: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	pc = 0x829E9B0C; continue 'dispatch;
            }
            0x829E9B0C => {
    //   block [0x829E9B0C..0x829E9B20)
	// 829E9B0C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9B10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9B14: 409A000C  bne cr6, 0x829e9b20
	if !ctx.cr[6].eq {
	pc = 0x829E9B20; continue 'dispatch;
	}
	// 829E9B18: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E9B1C: 4BFFFF58  b 0x829e9a74
	pc = 0x829E9A74; continue 'dispatch;
            }
            0x829E9B20 => {
    //   block [0x829E9B20..0x829E9B28)
	// 829E9B20: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E9B24: 4BFFFF50  b 0x829e9a74
	pc = 0x829E9A74; continue 'dispatch;
            }
            0x829E9B28 => {
    //   block [0x829E9B28..0x829E9B30)
	// 829E9B28: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 829E9B2C: 482BF918  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E9B30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E9B30 size=360
    let mut pc: u32 = 0x829E9B30;
    'dispatch: loop {
        match pc {
            0x829E9B30 => {
    //   block [0x829E9B30..0x829E9B84)
	// 829E9B30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E9B34: 482BF8BD  bl 0x82ca93f0
	ctx.lr = 0x829E9B38;
	sub_82CA93D0(ctx, base);
	// 829E9B38: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E9B3C: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 829E9B40: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 829E9B44: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 829E9B48: 2F170007  cmpwi cr6, r23, 7
	ctx.cr[6].compare_i32(ctx.r[23].s32, 7, &mut ctx.xer);
	// 829E9B4C: 419A0048  beq cr6, 0x829e9b94
	if ctx.cr[6].eq {
	pc = 0x829E9B94; continue 'dispatch;
	}
	// 829E9B50: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 829E9B54: 419A0040  beq cr6, 0x829e9b94
	if ctx.cr[6].eq {
	pc = 0x829E9B94; continue 'dispatch;
	}
	// 829E9B58: 2F170009  cmpwi cr6, r23, 9
	ctx.cr[6].compare_i32(ctx.r[23].s32, 9, &mut ctx.xer);
	// 829E9B5C: 419A0028  beq cr6, 0x829e9b84
	if ctx.cr[6].eq {
	pc = 0x829E9B84; continue 'dispatch;
	}
	// 829E9B60: 2F170008  cmpwi cr6, r23, 8
	ctx.cr[6].compare_i32(ctx.r[23].s32, 8, &mut ctx.xer);
	// 829E9B64: 419A0020  beq cr6, 0x829e9b84
	if ctx.cr[6].eq {
	pc = 0x829E9B84; continue 'dispatch;
	}
	// 829E9B68: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9B6C: 56EB083C  slwi r11, r23, 1
	ctx.r[11].u32 = ctx.r[23].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E9B70: 7D175A14  add r8, r23, r11
	ctx.r[8].u64 = ctx.r[23].u64 + ctx.r[11].u64;
	// 829E9B74: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829E9B78: 8169007C  lwz r11, 0x7c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E9B7C: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829E9B80: 4800001C  b 0x829e9b9c
	pc = 0x829E9B9C; continue 'dispatch;
            }
            0x829E9B84 => {
    //   block [0x829E9B84..0x829E9B94)
	// 829E9B84: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9B88: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E9B8C: 3B2B0018  addi r25, r11, 0x18
	ctx.r[25].s64 = ctx.r[11].s64 + 24;
	// 829E9B90: 4800000C  b 0x829e9b9c
	pc = 0x829E9B9C; continue 'dispatch;
            }
            0x829E9B94 => {
    //   block [0x829E9B94..0x829E9B9C)
	// 829E9B94: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9B98: 3B2B0008  addi r25, r11, 8
	ctx.r[25].s64 = ctx.r[11].s64 + 8;
	pc = 0x829E9B9C; continue 'dispatch;
            }
            0x829E9B9C => {
    //   block [0x829E9B9C..0x829E9BB8)
	// 829E9B9C: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9BA0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829E9BA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9BA8: 419A0010  beq cr6, 0x829e9bb8
	if ctx.cr[6].eq {
	pc = 0x829E9BB8; continue 'dispatch;
	}
	// 829E9BAC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E9BB0: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E9BB4: 4800000C  b 0x829e9bc0
	pc = 0x829E9BC0; continue 'dispatch;
            }
            0x829E9BB8 => {
    //   block [0x829E9BB8..0x829E9BC0)
	// 829E9BB8: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E9BBC: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x829E9BC0; continue 'dispatch;
            }
            0x829E9BC0 => {
    //   block [0x829E9BC0..0x829E9BD0)
	// 829E9BC0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829E9BC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E9BC8: 3B6A0B7C  addi r27, r10, 0xb7c
	ctx.r[27].s64 = ctx.r[10].s64 + 2940;
	// 829E9BCC: 3B4B0B7C  addi r26, r11, 0xb7c
	ctx.r[26].s64 = ctx.r[11].s64 + 2940;
	pc = 0x829E9BD0; continue 'dispatch;
            }
            0x829E9BD0 => {
    //   block [0x829E9BD0..0x829E9BEC)
	// 829E9BD0: 578A063E  clrlwi r10, r28, 0x18
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 829E9BD4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E9BD8: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 829E9BDC: 409A0010  bne cr6, 0x829e9bec
	if !ctx.cr[6].eq {
	pc = 0x829E9BEC; continue 'dispatch;
	}
	// 829E9BE0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E9BE4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E9BE8: 419A0008  beq cr6, 0x829e9bf0
	if ctx.cr[6].eq {
	pc = 0x829E9BF0; continue 'dispatch;
	}
	pc = 0x829E9BEC; continue 'dispatch;
            }
            0x829E9BEC => {
    //   block [0x829E9BEC..0x829E9BF0)
	// 829E9BEC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829E9BF0; continue 'dispatch;
            }
            0x829E9BF0 => {
    //   block [0x829E9BF0..0x829E9C74)
	// 829E9BF0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E9BF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9BF8: 409A0098  bne cr6, 0x829e9c90
	if !ctx.cr[6].eq {
	pc = 0x829E9C90; continue 'dispatch;
	}
	// 829E9BFC: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E9C00: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E9C04: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E9C08: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E9C0C: 419A0068  beq cr6, 0x829e9c74
	if ctx.cr[6].eq {
	pc = 0x829E9C74; continue 'dispatch;
	}
	// 829E9C10: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 829E9C14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E9C18: 4B8199C9  bl 0x822035e0
	ctx.lr = 0x829E9C1C;
	sub_822035E0(ctx, base);
	// 829E9C1C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E9C20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9C24: 419A0050  beq cr6, 0x829e9c74
	if ctx.cr[6].eq {
	pc = 0x829E9C74; continue 'dispatch;
	}
	// 829E9C28: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9C2C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E9C30: 419A0044  beq cr6, 0x829e9c74
	if ctx.cr[6].eq {
	pc = 0x829E9C74; continue 'dispatch;
	}
	// 829E9C34: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 829E9C38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E9C3C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829E9C40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E9C44: 4B82AC55  bl 0x82214898
	ctx.lr = 0x829E9C48;
	sub_82214898(ctx, base);
	// 829E9C48: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E9C4C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829E9C50: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 829E9C54: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829E9C58: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829E9C5C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829E9C60: 4BA6C4B9  bl 0x82456118
	ctx.lr = 0x829E9C64;
	sub_82456118(ctx, base);
	// 829E9C64: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 829E9C68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E9C6C: 4B7AA1CD  bl 0x82193e38
	ctx.lr = 0x829E9C70;
	sub_82193E38(ctx, base);
	// 829E9C70: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	pc = 0x829E9C74; continue 'dispatch;
            }
            0x829E9C74 => {
    //   block [0x829E9C74..0x829E9C88)
	// 829E9C74: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9C78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9C7C: 409A000C  bne cr6, 0x829e9c88
	if !ctx.cr[6].eq {
	pc = 0x829E9C88; continue 'dispatch;
	}
	// 829E9C80: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E9C84: 4BFFFF4C  b 0x829e9bd0
	pc = 0x829E9BD0; continue 'dispatch;
            }
            0x829E9C88 => {
    //   block [0x829E9C88..0x829E9C90)
	// 829E9C88: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E9C8C: 4BFFFF44  b 0x829e9bd0
	pc = 0x829E9BD0; continue 'dispatch;
            }
            0x829E9C90 => {
    //   block [0x829E9C90..0x829E9C98)
	// 829E9C90: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829E9C94: 482BF7AC  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E9C98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E9C98 size=368
    let mut pc: u32 = 0x829E9C98;
    'dispatch: loop {
        match pc {
            0x829E9C98 => {
    //   block [0x829E9C98..0x829E9CEC)
	// 829E9C98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E9C9C: 482BF755  bl 0x82ca93f0
	ctx.lr = 0x829E9CA0;
	sub_82CA93D0(ctx, base);
	// 829E9CA0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E9CA4: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 829E9CA8: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 829E9CAC: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 829E9CB0: 2F170007  cmpwi cr6, r23, 7
	ctx.cr[6].compare_i32(ctx.r[23].s32, 7, &mut ctx.xer);
	// 829E9CB4: 419A0048  beq cr6, 0x829e9cfc
	if ctx.cr[6].eq {
	pc = 0x829E9CFC; continue 'dispatch;
	}
	// 829E9CB8: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 829E9CBC: 419A0040  beq cr6, 0x829e9cfc
	if ctx.cr[6].eq {
	pc = 0x829E9CFC; continue 'dispatch;
	}
	// 829E9CC0: 2F170009  cmpwi cr6, r23, 9
	ctx.cr[6].compare_i32(ctx.r[23].s32, 9, &mut ctx.xer);
	// 829E9CC4: 419A0028  beq cr6, 0x829e9cec
	if ctx.cr[6].eq {
	pc = 0x829E9CEC; continue 'dispatch;
	}
	// 829E9CC8: 2F170008  cmpwi cr6, r23, 8
	ctx.cr[6].compare_i32(ctx.r[23].s32, 8, &mut ctx.xer);
	// 829E9CCC: 419A0020  beq cr6, 0x829e9cec
	if ctx.cr[6].eq {
	pc = 0x829E9CEC; continue 'dispatch;
	}
	// 829E9CD0: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9CD4: 56EB083C  slwi r11, r23, 1
	ctx.r[11].u32 = ctx.r[23].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E9CD8: 7D175A14  add r8, r23, r11
	ctx.r[8].u64 = ctx.r[23].u64 + ctx.r[11].u64;
	// 829E9CDC: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829E9CE0: 8169007C  lwz r11, 0x7c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E9CE4: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829E9CE8: 4800001C  b 0x829e9d04
	pc = 0x829E9D04; continue 'dispatch;
            }
            0x829E9CEC => {
    //   block [0x829E9CEC..0x829E9CFC)
	// 829E9CEC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9CF0: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E9CF4: 3B2B0018  addi r25, r11, 0x18
	ctx.r[25].s64 = ctx.r[11].s64 + 24;
	// 829E9CF8: 4800000C  b 0x829e9d04
	pc = 0x829E9D04; continue 'dispatch;
            }
            0x829E9CFC => {
    //   block [0x829E9CFC..0x829E9D04)
	// 829E9CFC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9D00: 3B2B0008  addi r25, r11, 8
	ctx.r[25].s64 = ctx.r[11].s64 + 8;
	pc = 0x829E9D04; continue 'dispatch;
            }
            0x829E9D04 => {
    //   block [0x829E9D04..0x829E9D20)
	// 829E9D04: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9D08: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829E9D0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9D10: 419A0010  beq cr6, 0x829e9d20
	if ctx.cr[6].eq {
	pc = 0x829E9D20; continue 'dispatch;
	}
	// 829E9D14: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E9D18: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E9D1C: 4800000C  b 0x829e9d28
	pc = 0x829E9D28; continue 'dispatch;
            }
            0x829E9D20 => {
    //   block [0x829E9D20..0x829E9D28)
	// 829E9D20: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E9D24: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x829E9D28; continue 'dispatch;
            }
            0x829E9D28 => {
    //   block [0x829E9D28..0x829E9D38)
	// 829E9D28: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829E9D2C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E9D30: 3B6A0B7C  addi r27, r10, 0xb7c
	ctx.r[27].s64 = ctx.r[10].s64 + 2940;
	// 829E9D34: 3B4B0B7C  addi r26, r11, 0xb7c
	ctx.r[26].s64 = ctx.r[11].s64 + 2940;
	pc = 0x829E9D38; continue 'dispatch;
            }
            0x829E9D38 => {
    //   block [0x829E9D38..0x829E9D54)
	// 829E9D38: 578A063E  clrlwi r10, r28, 0x18
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 829E9D3C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E9D40: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 829E9D44: 409A0010  bne cr6, 0x829e9d54
	if !ctx.cr[6].eq {
	pc = 0x829E9D54; continue 'dispatch;
	}
	// 829E9D48: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E9D4C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E9D50: 419A0008  beq cr6, 0x829e9d58
	if ctx.cr[6].eq {
	pc = 0x829E9D58; continue 'dispatch;
	}
	pc = 0x829E9D54; continue 'dispatch;
            }
            0x829E9D54 => {
    //   block [0x829E9D54..0x829E9D58)
	// 829E9D54: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829E9D58; continue 'dispatch;
            }
            0x829E9D58 => {
    //   block [0x829E9D58..0x829E9DE4)
	// 829E9D58: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E9D5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9D60: 409A00A0  bne cr6, 0x829e9e00
	if !ctx.cr[6].eq {
	pc = 0x829E9E00; continue 'dispatch;
	}
	// 829E9D64: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E9D68: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E9D6C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E9D70: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E9D74: 419A0070  beq cr6, 0x829e9de4
	if ctx.cr[6].eq {
	pc = 0x829E9DE4; continue 'dispatch;
	}
	// 829E9D78: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 829E9D7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E9D80: 4B819861  bl 0x822035e0
	ctx.lr = 0x829E9D84;
	sub_822035E0(ctx, base);
	// 829E9D84: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E9D88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9D8C: 419A0058  beq cr6, 0x829e9de4
	if ctx.cr[6].eq {
	pc = 0x829E9DE4; continue 'dispatch;
	}
	// 829E9D90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E9D94: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 829E9D98: 4BB27331  bl 0x825110c8
	ctx.lr = 0x829E9D9C;
	sub_825110C8(ctx, base);
	// 829E9D9C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E9DA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9DA4: 419A0040  beq cr6, 0x829e9de4
	if ctx.cr[6].eq {
	pc = 0x829E9DE4; continue 'dispatch;
	}
	// 829E9DA8: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 829E9DAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E9DB0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829E9DB4: 4B82AAE5  bl 0x82214898
	ctx.lr = 0x829E9DB8;
	sub_82214898(ctx, base);
	// 829E9DB8: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E9DBC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829E9DC0: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 829E9DC4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829E9DC8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829E9DCC: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829E9DD0: 4BA6C349  bl 0x82456118
	ctx.lr = 0x829E9DD4;
	sub_82456118(ctx, base);
	// 829E9DD4: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 829E9DD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E9DDC: 4B7AA05D  bl 0x82193e38
	ctx.lr = 0x829E9DE0;
	sub_82193E38(ctx, base);
	// 829E9DE0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	pc = 0x829E9DE4; continue 'dispatch;
            }
            0x829E9DE4 => {
    //   block [0x829E9DE4..0x829E9DF8)
	// 829E9DE4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9DE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9DEC: 409A000C  bne cr6, 0x829e9df8
	if !ctx.cr[6].eq {
	pc = 0x829E9DF8; continue 'dispatch;
	}
	// 829E9DF0: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E9DF4: 4BFFFF44  b 0x829e9d38
	pc = 0x829E9D38; continue 'dispatch;
            }
            0x829E9DF8 => {
    //   block [0x829E9DF8..0x829E9E00)
	// 829E9DF8: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E9DFC: 4BFFFF3C  b 0x829e9d38
	pc = 0x829E9D38; continue 'dispatch;
            }
            0x829E9E00 => {
    //   block [0x829E9E00..0x829E9E08)
	// 829E9E00: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829E9E04: 482BF63C  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E9E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E9E08 size=368
    let mut pc: u32 = 0x829E9E08;
    'dispatch: loop {
        match pc {
            0x829E9E08 => {
    //   block [0x829E9E08..0x829E9E5C)
	// 829E9E08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E9E0C: 482BF5E5  bl 0x82ca93f0
	ctx.lr = 0x829E9E10;
	sub_82CA93D0(ctx, base);
	// 829E9E10: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E9E14: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 829E9E18: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 829E9E1C: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 829E9E20: 2F170007  cmpwi cr6, r23, 7
	ctx.cr[6].compare_i32(ctx.r[23].s32, 7, &mut ctx.xer);
	// 829E9E24: 419A0048  beq cr6, 0x829e9e6c
	if ctx.cr[6].eq {
	pc = 0x829E9E6C; continue 'dispatch;
	}
	// 829E9E28: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 829E9E2C: 419A0040  beq cr6, 0x829e9e6c
	if ctx.cr[6].eq {
	pc = 0x829E9E6C; continue 'dispatch;
	}
	// 829E9E30: 2F170009  cmpwi cr6, r23, 9
	ctx.cr[6].compare_i32(ctx.r[23].s32, 9, &mut ctx.xer);
	// 829E9E34: 419A0028  beq cr6, 0x829e9e5c
	if ctx.cr[6].eq {
	pc = 0x829E9E5C; continue 'dispatch;
	}
	// 829E9E38: 2F170008  cmpwi cr6, r23, 8
	ctx.cr[6].compare_i32(ctx.r[23].s32, 8, &mut ctx.xer);
	// 829E9E3C: 419A0020  beq cr6, 0x829e9e5c
	if ctx.cr[6].eq {
	pc = 0x829E9E5C; continue 'dispatch;
	}
	// 829E9E40: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9E44: 56EB083C  slwi r11, r23, 1
	ctx.r[11].u32 = ctx.r[23].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E9E48: 7D175A14  add r8, r23, r11
	ctx.r[8].u64 = ctx.r[23].u64 + ctx.r[11].u64;
	// 829E9E4C: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829E9E50: 8169007C  lwz r11, 0x7c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E9E54: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829E9E58: 4800001C  b 0x829e9e74
	pc = 0x829E9E74; continue 'dispatch;
            }
            0x829E9E5C => {
    //   block [0x829E9E5C..0x829E9E6C)
	// 829E9E5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9E60: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E9E64: 3B2B0018  addi r25, r11, 0x18
	ctx.r[25].s64 = ctx.r[11].s64 + 24;
	// 829E9E68: 4800000C  b 0x829e9e74
	pc = 0x829E9E74; continue 'dispatch;
            }
            0x829E9E6C => {
    //   block [0x829E9E6C..0x829E9E74)
	// 829E9E6C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9E70: 3B2B0008  addi r25, r11, 8
	ctx.r[25].s64 = ctx.r[11].s64 + 8;
	pc = 0x829E9E74; continue 'dispatch;
            }
            0x829E9E74 => {
    //   block [0x829E9E74..0x829E9E90)
	// 829E9E74: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9E78: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829E9E7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9E80: 419A0010  beq cr6, 0x829e9e90
	if ctx.cr[6].eq {
	pc = 0x829E9E90; continue 'dispatch;
	}
	// 829E9E84: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E9E88: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E9E8C: 4800000C  b 0x829e9e98
	pc = 0x829E9E98; continue 'dispatch;
            }
            0x829E9E90 => {
    //   block [0x829E9E90..0x829E9E98)
	// 829E9E90: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E9E94: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x829E9E98; continue 'dispatch;
            }
            0x829E9E98 => {
    //   block [0x829E9E98..0x829E9EA8)
	// 829E9E98: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829E9E9C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E9EA0: 3B6A0B7C  addi r27, r10, 0xb7c
	ctx.r[27].s64 = ctx.r[10].s64 + 2940;
	// 829E9EA4: 3B4B0B7C  addi r26, r11, 0xb7c
	ctx.r[26].s64 = ctx.r[11].s64 + 2940;
	pc = 0x829E9EA8; continue 'dispatch;
            }
            0x829E9EA8 => {
    //   block [0x829E9EA8..0x829E9EC4)
	// 829E9EA8: 578A063E  clrlwi r10, r28, 0x18
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 829E9EAC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E9EB0: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 829E9EB4: 409A0010  bne cr6, 0x829e9ec4
	if !ctx.cr[6].eq {
	pc = 0x829E9EC4; continue 'dispatch;
	}
	// 829E9EB8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E9EBC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E9EC0: 419A0008  beq cr6, 0x829e9ec8
	if ctx.cr[6].eq {
	pc = 0x829E9EC8; continue 'dispatch;
	}
	pc = 0x829E9EC4; continue 'dispatch;
            }
            0x829E9EC4 => {
    //   block [0x829E9EC4..0x829E9EC8)
	// 829E9EC4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829E9EC8; continue 'dispatch;
            }
            0x829E9EC8 => {
    //   block [0x829E9EC8..0x829E9F54)
	// 829E9EC8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829E9ECC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9ED0: 409A00A0  bne cr6, 0x829e9f70
	if !ctx.cr[6].eq {
	pc = 0x829E9F70; continue 'dispatch;
	}
	// 829E9ED4: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E9ED8: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 829E9EDC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829E9EE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E9EE4: 419A0070  beq cr6, 0x829e9f54
	if ctx.cr[6].eq {
	pc = 0x829E9F54; continue 'dispatch;
	}
	// 829E9EE8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 829E9EEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E9EF0: 4B8196F1  bl 0x822035e0
	ctx.lr = 0x829E9EF4;
	sub_822035E0(ctx, base);
	// 829E9EF4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E9EF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9EFC: 419A0058  beq cr6, 0x829e9f54
	if ctx.cr[6].eq {
	pc = 0x829E9F54; continue 'dispatch;
	}
	// 829E9F00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E9F04: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 829E9F08: 4BB267E9  bl 0x825106f0
	ctx.lr = 0x829E9F0C;
	sub_825106F0(ctx, base);
	// 829E9F0C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829E9F10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9F14: 419A0040  beq cr6, 0x829e9f54
	if ctx.cr[6].eq {
	pc = 0x829E9F54; continue 'dispatch;
	}
	// 829E9F18: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 829E9F1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E9F20: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829E9F24: 4B82A975  bl 0x82214898
	ctx.lr = 0x829E9F28;
	sub_82214898(ctx, base);
	// 829E9F28: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E9F2C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829E9F30: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 829E9F34: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829E9F38: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829E9F3C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829E9F40: 4BA6C1D9  bl 0x82456118
	ctx.lr = 0x829E9F44;
	sub_82456118(ctx, base);
	// 829E9F44: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 829E9F48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E9F4C: 4B7A9EED  bl 0x82193e38
	ctx.lr = 0x829E9F50;
	sub_82193E38(ctx, base);
	// 829E9F50: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	pc = 0x829E9F54; continue 'dispatch;
            }
            0x829E9F54 => {
    //   block [0x829E9F54..0x829E9F68)
	// 829E9F54: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9F58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9F5C: 409A000C  bne cr6, 0x829e9f68
	if !ctx.cr[6].eq {
	pc = 0x829E9F68; continue 'dispatch;
	}
	// 829E9F60: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E9F64: 4BFFFF44  b 0x829e9ea8
	pc = 0x829E9EA8; continue 'dispatch;
            }
            0x829E9F68 => {
    //   block [0x829E9F68..0x829E9F70)
	// 829E9F68: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E9F6C: 4BFFFF3C  b 0x829e9ea8
	pc = 0x829E9EA8; continue 'dispatch;
            }
            0x829E9F70 => {
    //   block [0x829E9F70..0x829E9F78)
	// 829E9F70: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829E9F74: 482BF4CC  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E9F78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E9F78 size=372
    let mut pc: u32 = 0x829E9F78;
    'dispatch: loop {
        match pc {
            0x829E9F78 => {
    //   block [0x829E9F78..0x829E9FCC)
	// 829E9F78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E9F7C: 482BF475  bl 0x82ca93f0
	ctx.lr = 0x829E9F80;
	sub_82CA93D0(ctx, base);
	// 829E9F80: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E9F84: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 829E9F88: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 829E9F8C: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 829E9F90: 2F170007  cmpwi cr6, r23, 7
	ctx.cr[6].compare_i32(ctx.r[23].s32, 7, &mut ctx.xer);
	// 829E9F94: 419A0048  beq cr6, 0x829e9fdc
	if ctx.cr[6].eq {
	pc = 0x829E9FDC; continue 'dispatch;
	}
	// 829E9F98: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 829E9F9C: 419A0040  beq cr6, 0x829e9fdc
	if ctx.cr[6].eq {
	pc = 0x829E9FDC; continue 'dispatch;
	}
	// 829E9FA0: 2F170009  cmpwi cr6, r23, 9
	ctx.cr[6].compare_i32(ctx.r[23].s32, 9, &mut ctx.xer);
	// 829E9FA4: 419A0028  beq cr6, 0x829e9fcc
	if ctx.cr[6].eq {
	pc = 0x829E9FCC; continue 'dispatch;
	}
	// 829E9FA8: 2F170008  cmpwi cr6, r23, 8
	ctx.cr[6].compare_i32(ctx.r[23].s32, 8, &mut ctx.xer);
	// 829E9FAC: 419A0020  beq cr6, 0x829e9fcc
	if ctx.cr[6].eq {
	pc = 0x829E9FCC; continue 'dispatch;
	}
	// 829E9FB0: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9FB4: 56EB083C  slwi r11, r23, 1
	ctx.r[11].u32 = ctx.r[23].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829E9FB8: 7D175A14  add r8, r23, r11
	ctx.r[8].u64 = ctx.r[23].u64 + ctx.r[11].u64;
	// 829E9FBC: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829E9FC0: 8169007C  lwz r11, 0x7c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E9FC4: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829E9FC8: 4800001C  b 0x829e9fe4
	pc = 0x829E9FE4; continue 'dispatch;
            }
            0x829E9FCC => {
    //   block [0x829E9FCC..0x829E9FDC)
	// 829E9FCC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9FD0: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E9FD4: 3B2B0018  addi r25, r11, 0x18
	ctx.r[25].s64 = ctx.r[11].s64 + 24;
	// 829E9FD8: 4800000C  b 0x829e9fe4
	pc = 0x829E9FE4; continue 'dispatch;
            }
            0x829E9FDC => {
    //   block [0x829E9FDC..0x829E9FE4)
	// 829E9FDC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9FE0: 3B2B0008  addi r25, r11, 8
	ctx.r[25].s64 = ctx.r[11].s64 + 8;
	pc = 0x829E9FE4; continue 'dispatch;
            }
            0x829E9FE4 => {
    //   block [0x829E9FE4..0x829EA000)
	// 829E9FE4: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9FE8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829E9FEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9FF0: 419A0010  beq cr6, 0x829ea000
	if ctx.cr[6].eq {
	pc = 0x829EA000; continue 'dispatch;
	}
	// 829E9FF4: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829E9FF8: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829E9FFC: 4800000C  b 0x829ea008
	pc = 0x829EA008; continue 'dispatch;
            }
            0x829EA000 => {
    //   block [0x829EA000..0x829EA008)
	// 829EA000: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829EA004: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x829EA008; continue 'dispatch;
            }
            0x829EA008 => {
    //   block [0x829EA008..0x829EA018)
	// 829EA008: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EA00C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EA010: 3B6A0B7C  addi r27, r10, 0xb7c
	ctx.r[27].s64 = ctx.r[10].s64 + 2940;
	// 829EA014: 3B4B0B7C  addi r26, r11, 0xb7c
	ctx.r[26].s64 = ctx.r[11].s64 + 2940;
	pc = 0x829EA018; continue 'dispatch;
            }
            0x829EA018 => {
    //   block [0x829EA018..0x829EA034)
	// 829EA018: 578A063E  clrlwi r10, r28, 0x18
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 829EA01C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EA020: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 829EA024: 409A0010  bne cr6, 0x829ea034
	if !ctx.cr[6].eq {
	pc = 0x829EA034; continue 'dispatch;
	}
	// 829EA028: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829EA02C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829EA030: 419A0008  beq cr6, 0x829ea038
	if ctx.cr[6].eq {
	pc = 0x829EA038; continue 'dispatch;
	}
	pc = 0x829EA034; continue 'dispatch;
            }
            0x829EA034 => {
    //   block [0x829EA034..0x829EA038)
	// 829EA034: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829EA038; continue 'dispatch;
            }
            0x829EA038 => {
    //   block [0x829EA038..0x829EA0C8)
	// 829EA038: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829EA03C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EA040: 409A00A4  bne cr6, 0x829ea0e4
	if !ctx.cr[6].eq {
	pc = 0x829EA0E4; continue 'dispatch;
	}
	// 829EA044: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EA048: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 829EA04C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829EA050: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829EA054: 419A0074  beq cr6, 0x829ea0c8
	if ctx.cr[6].eq {
	pc = 0x829EA0C8; continue 'dispatch;
	}
	// 829EA058: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 829EA05C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EA060: 4B819581  bl 0x822035e0
	ctx.lr = 0x829EA064;
	sub_822035E0(ctx, base);
	// 829EA064: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EA068: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EA06C: 419A005C  beq cr6, 0x829ea0c8
	if ctx.cr[6].eq {
	pc = 0x829EA0C8; continue 'dispatch;
	}
	// 829EA070: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EA074: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 829EA078: 4BB28101  bl 0x82512178
	ctx.lr = 0x829EA07C;
	sub_82512178(ctx, base);
	// 829EA07C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EA080: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EA084: 419A0044  beq cr6, 0x829ea0c8
	if ctx.cr[6].eq {
	pc = 0x829EA0C8; continue 'dispatch;
	}
	// 829EA088: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 829EA08C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EA090: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829EA094: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EA098: 4B82A801  bl 0x82214898
	ctx.lr = 0x829EA09C;
	sub_82214898(ctx, base);
	// 829EA09C: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EA0A0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829EA0A4: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 829EA0A8: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829EA0AC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829EA0B0: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829EA0B4: 4BA6C065  bl 0x82456118
	ctx.lr = 0x829EA0B8;
	sub_82456118(ctx, base);
	// 829EA0B8: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 829EA0BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EA0C0: 4B7A9D79  bl 0x82193e38
	ctx.lr = 0x829EA0C4;
	sub_82193E38(ctx, base);
	// 829EA0C4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	pc = 0x829EA0C8; continue 'dispatch;
            }
            0x829EA0C8 => {
    //   block [0x829EA0C8..0x829EA0DC)
	// 829EA0C8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA0CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EA0D0: 409A000C  bne cr6, 0x829ea0dc
	if !ctx.cr[6].eq {
	pc = 0x829EA0DC; continue 'dispatch;
	}
	// 829EA0D4: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829EA0D8: 4BFFFF40  b 0x829ea018
	pc = 0x829EA018; continue 'dispatch;
            }
            0x829EA0DC => {
    //   block [0x829EA0DC..0x829EA0E4)
	// 829EA0DC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829EA0E0: 4BFFFF38  b 0x829ea018
	pc = 0x829EA018; continue 'dispatch;
            }
            0x829EA0E4 => {
    //   block [0x829EA0E4..0x829EA0EC)
	// 829EA0E4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829EA0E8: 482BF358  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EA0F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EA0F0 size=428
    let mut pc: u32 = 0x829EA0F0;
    'dispatch: loop {
        match pc {
            0x829EA0F0 => {
    //   block [0x829EA0F0..0x829EA144)
	// 829EA0F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EA0F4: 482BF2FD  bl 0x82ca93f0
	ctx.lr = 0x829EA0F8;
	sub_82CA93D0(ctx, base);
	// 829EA0F8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EA0FC: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 829EA100: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 829EA104: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 829EA108: 2F170007  cmpwi cr6, r23, 7
	ctx.cr[6].compare_i32(ctx.r[23].s32, 7, &mut ctx.xer);
	// 829EA10C: 419A0048  beq cr6, 0x829ea154
	if ctx.cr[6].eq {
	pc = 0x829EA154; continue 'dispatch;
	}
	// 829EA110: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 829EA114: 419A0040  beq cr6, 0x829ea154
	if ctx.cr[6].eq {
	pc = 0x829EA154; continue 'dispatch;
	}
	// 829EA118: 2F170009  cmpwi cr6, r23, 9
	ctx.cr[6].compare_i32(ctx.r[23].s32, 9, &mut ctx.xer);
	// 829EA11C: 419A0028  beq cr6, 0x829ea144
	if ctx.cr[6].eq {
	pc = 0x829EA144; continue 'dispatch;
	}
	// 829EA120: 2F170008  cmpwi cr6, r23, 8
	ctx.cr[6].compare_i32(ctx.r[23].s32, 8, &mut ctx.xer);
	// 829EA124: 419A0020  beq cr6, 0x829ea144
	if ctx.cr[6].eq {
	pc = 0x829EA144; continue 'dispatch;
	}
	// 829EA128: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA12C: 56EB083C  slwi r11, r23, 1
	ctx.r[11].u32 = ctx.r[23].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EA130: 7D175A14  add r8, r23, r11
	ctx.r[8].u64 = ctx.r[23].u64 + ctx.r[11].u64;
	// 829EA134: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829EA138: 8169007C  lwz r11, 0x7c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 829EA13C: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829EA140: 4800001C  b 0x829ea15c
	pc = 0x829EA15C; continue 'dispatch;
            }
            0x829EA144 => {
    //   block [0x829EA144..0x829EA154)
	// 829EA144: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA148: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829EA14C: 3B2B0018  addi r25, r11, 0x18
	ctx.r[25].s64 = ctx.r[11].s64 + 24;
	// 829EA150: 4800000C  b 0x829ea15c
	pc = 0x829EA15C; continue 'dispatch;
            }
            0x829EA154 => {
    //   block [0x829EA154..0x829EA15C)
	// 829EA154: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA158: 3B2B0008  addi r25, r11, 8
	ctx.r[25].s64 = ctx.r[11].s64 + 8;
	pc = 0x829EA15C; continue 'dispatch;
            }
            0x829EA15C => {
    //   block [0x829EA15C..0x829EA178)
	// 829EA15C: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA160: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829EA164: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EA168: 419A0010  beq cr6, 0x829ea178
	if ctx.cr[6].eq {
	pc = 0x829EA178; continue 'dispatch;
	}
	// 829EA16C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829EA170: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829EA174: 4800000C  b 0x829ea180
	pc = 0x829EA180; continue 'dispatch;
            }
            0x829EA178 => {
    //   block [0x829EA178..0x829EA180)
	// 829EA178: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829EA17C: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x829EA180; continue 'dispatch;
            }
            0x829EA180 => {
    //   block [0x829EA180..0x829EA190)
	// 829EA180: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EA184: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EA188: 3B6A0B7C  addi r27, r10, 0xb7c
	ctx.r[27].s64 = ctx.r[10].s64 + 2940;
	// 829EA18C: 3B4B0B7C  addi r26, r11, 0xb7c
	ctx.r[26].s64 = ctx.r[11].s64 + 2940;
	pc = 0x829EA190; continue 'dispatch;
            }
            0x829EA190 => {
    //   block [0x829EA190..0x829EA1AC)
	// 829EA190: 578A063E  clrlwi r10, r28, 0x18
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 829EA194: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EA198: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 829EA19C: 409A0010  bne cr6, 0x829ea1ac
	if !ctx.cr[6].eq {
	pc = 0x829EA1AC; continue 'dispatch;
	}
	// 829EA1A0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829EA1A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829EA1A8: 419A0008  beq cr6, 0x829ea1b0
	if ctx.cr[6].eq {
	pc = 0x829EA1B0; continue 'dispatch;
	}
	pc = 0x829EA1AC; continue 'dispatch;
            }
            0x829EA1AC => {
    //   block [0x829EA1AC..0x829EA1B0)
	// 829EA1AC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829EA1B0; continue 'dispatch;
            }
            0x829EA1B0 => {
    //   block [0x829EA1B0..0x829EA228)
	// 829EA1B0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829EA1B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EA1B8: 409A00DC  bne cr6, 0x829ea294
	if !ctx.cr[6].eq {
	pc = 0x829EA294; continue 'dispatch;
	}
	// 829EA1BC: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EA1C0: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 829EA1C4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829EA1C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829EA1CC: 419A00AC  beq cr6, 0x829ea278
	if ctx.cr[6].eq {
	pc = 0x829EA278; continue 'dispatch;
	}
	// 829EA1D0: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 829EA1D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EA1D8: 4B819409  bl 0x822035e0
	ctx.lr = 0x829EA1DC;
	sub_822035E0(ctx, base);
	// 829EA1DC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EA1E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EA1E4: 419A0094  beq cr6, 0x829ea278
	if ctx.cr[6].eq {
	pc = 0x829EA278; continue 'dispatch;
	}
	// 829EA1E8: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA1EC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA1F0: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829EA1F4: 419A0034  beq cr6, 0x829ea228
	if ctx.cr[6].eq {
	pc = 0x829EA228; continue 'dispatch;
	}
	// 829EA1F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EA1FC: 80760004  lwz r3, 4(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EA200: 4BB26DA1  bl 0x82510fa0
	ctx.lr = 0x829EA204;
	sub_82510FA0(ctx, base);
	// 829EA204: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EA208: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EA20C: 419A001C  beq cr6, 0x829ea228
	if ctx.cr[6].eq {
	pc = 0x829EA228; continue 'dispatch;
	}
	// 829EA210: 80760008  lwz r3, 8(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EA214: 4B815ED5  bl 0x822000e8
	ctx.lr = 0x829EA218;
	sub_822000E8(ctx, base);
	// 829EA218: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EA21C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EA220: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829EA224: 409A0008  bne cr6, 0x829ea22c
	if !ctx.cr[6].eq {
	pc = 0x829EA22C; continue 'dispatch;
	}
	pc = 0x829EA228; continue 'dispatch;
            }
            0x829EA228 => {
    //   block [0x829EA228..0x829EA22C)
	// 829EA228: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829EA22C; continue 'dispatch;
            }
            0x829EA22C => {
    //   block [0x829EA22C..0x829EA278)
	// 829EA22C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829EA230: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EA234: 419A0044  beq cr6, 0x829ea278
	if ctx.cr[6].eq {
	pc = 0x829EA278; continue 'dispatch;
	}
	// 829EA238: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 829EA23C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EA240: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829EA244: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EA248: 4B82A651  bl 0x82214898
	ctx.lr = 0x829EA24C;
	sub_82214898(ctx, base);
	// 829EA24C: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EA250: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829EA254: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 829EA258: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829EA25C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829EA260: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829EA264: 4BA6BEB5  bl 0x82456118
	ctx.lr = 0x829EA268;
	sub_82456118(ctx, base);
	// 829EA268: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 829EA26C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EA270: 4B7A9BC9  bl 0x82193e38
	ctx.lr = 0x829EA274;
	sub_82193E38(ctx, base);
	// 829EA274: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	pc = 0x829EA278; continue 'dispatch;
            }
            0x829EA278 => {
    //   block [0x829EA278..0x829EA28C)
	// 829EA278: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA27C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EA280: 409A000C  bne cr6, 0x829ea28c
	if !ctx.cr[6].eq {
	pc = 0x829EA28C; continue 'dispatch;
	}
	// 829EA284: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829EA288: 4BFFFF08  b 0x829ea190
	pc = 0x829EA190; continue 'dispatch;
            }
            0x829EA28C => {
    //   block [0x829EA28C..0x829EA294)
	// 829EA28C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829EA290: 4BFFFF00  b 0x829ea190
	pc = 0x829EA190; continue 'dispatch;
            }
            0x829EA294 => {
    //   block [0x829EA294..0x829EA29C)
	// 829EA294: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829EA298: 482BF1A8  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EA2A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EA2A0 size=372
    let mut pc: u32 = 0x829EA2A0;
    'dispatch: loop {
        match pc {
            0x829EA2A0 => {
    //   block [0x829EA2A0..0x829EA2F4)
	// 829EA2A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EA2A4: 482BF14D  bl 0x82ca93f0
	ctx.lr = 0x829EA2A8;
	sub_82CA93D0(ctx, base);
	// 829EA2A8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EA2AC: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 829EA2B0: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 829EA2B4: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 829EA2B8: 2F170007  cmpwi cr6, r23, 7
	ctx.cr[6].compare_i32(ctx.r[23].s32, 7, &mut ctx.xer);
	// 829EA2BC: 419A0048  beq cr6, 0x829ea304
	if ctx.cr[6].eq {
	pc = 0x829EA304; continue 'dispatch;
	}
	// 829EA2C0: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 829EA2C4: 419A0040  beq cr6, 0x829ea304
	if ctx.cr[6].eq {
	pc = 0x829EA304; continue 'dispatch;
	}
	// 829EA2C8: 2F170009  cmpwi cr6, r23, 9
	ctx.cr[6].compare_i32(ctx.r[23].s32, 9, &mut ctx.xer);
	// 829EA2CC: 419A0028  beq cr6, 0x829ea2f4
	if ctx.cr[6].eq {
	pc = 0x829EA2F4; continue 'dispatch;
	}
	// 829EA2D0: 2F170008  cmpwi cr6, r23, 8
	ctx.cr[6].compare_i32(ctx.r[23].s32, 8, &mut ctx.xer);
	// 829EA2D4: 419A0020  beq cr6, 0x829ea2f4
	if ctx.cr[6].eq {
	pc = 0x829EA2F4; continue 'dispatch;
	}
	// 829EA2D8: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA2DC: 56EB083C  slwi r11, r23, 1
	ctx.r[11].u32 = ctx.r[23].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EA2E0: 7D175A14  add r8, r23, r11
	ctx.r[8].u64 = ctx.r[23].u64 + ctx.r[11].u64;
	// 829EA2E4: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829EA2E8: 8169007C  lwz r11, 0x7c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 829EA2EC: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829EA2F0: 4800001C  b 0x829ea30c
	pc = 0x829EA30C; continue 'dispatch;
            }
            0x829EA2F4 => {
    //   block [0x829EA2F4..0x829EA304)
	// 829EA2F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA2F8: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829EA2FC: 3B2B0018  addi r25, r11, 0x18
	ctx.r[25].s64 = ctx.r[11].s64 + 24;
	// 829EA300: 4800000C  b 0x829ea30c
	pc = 0x829EA30C; continue 'dispatch;
            }
            0x829EA304 => {
    //   block [0x829EA304..0x829EA30C)
	// 829EA304: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA308: 3B2B0008  addi r25, r11, 8
	ctx.r[25].s64 = ctx.r[11].s64 + 8;
	pc = 0x829EA30C; continue 'dispatch;
            }
            0x829EA30C => {
    //   block [0x829EA30C..0x829EA328)
	// 829EA30C: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA310: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829EA314: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EA318: 419A0010  beq cr6, 0x829ea328
	if ctx.cr[6].eq {
	pc = 0x829EA328; continue 'dispatch;
	}
	// 829EA31C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829EA320: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829EA324: 4800000C  b 0x829ea330
	pc = 0x829EA330; continue 'dispatch;
            }
            0x829EA328 => {
    //   block [0x829EA328..0x829EA330)
	// 829EA328: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829EA32C: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x829EA330; continue 'dispatch;
            }
            0x829EA330 => {
    //   block [0x829EA330..0x829EA340)
	// 829EA330: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EA334: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EA338: 3B6A0B7C  addi r27, r10, 0xb7c
	ctx.r[27].s64 = ctx.r[10].s64 + 2940;
	// 829EA33C: 3B4B0B7C  addi r26, r11, 0xb7c
	ctx.r[26].s64 = ctx.r[11].s64 + 2940;
	pc = 0x829EA340; continue 'dispatch;
            }
            0x829EA340 => {
    //   block [0x829EA340..0x829EA35C)
	// 829EA340: 578A063E  clrlwi r10, r28, 0x18
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 829EA344: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EA348: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 829EA34C: 409A0010  bne cr6, 0x829ea35c
	if !ctx.cr[6].eq {
	pc = 0x829EA35C; continue 'dispatch;
	}
	// 829EA350: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829EA354: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829EA358: 419A0008  beq cr6, 0x829ea360
	if ctx.cr[6].eq {
	pc = 0x829EA360; continue 'dispatch;
	}
	pc = 0x829EA35C; continue 'dispatch;
            }
            0x829EA35C => {
    //   block [0x829EA35C..0x829EA360)
	// 829EA35C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829EA360; continue 'dispatch;
            }
            0x829EA360 => {
    //   block [0x829EA360..0x829EA3F0)
	// 829EA360: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829EA364: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EA368: 409A00A4  bne cr6, 0x829ea40c
	if !ctx.cr[6].eq {
	pc = 0x829EA40C; continue 'dispatch;
	}
	// 829EA36C: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EA370: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 829EA374: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829EA378: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829EA37C: 419A0074  beq cr6, 0x829ea3f0
	if ctx.cr[6].eq {
	pc = 0x829EA3F0; continue 'dispatch;
	}
	// 829EA380: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 829EA384: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EA388: 4B819259  bl 0x822035e0
	ctx.lr = 0x829EA38C;
	sub_822035E0(ctx, base);
	// 829EA38C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EA390: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EA394: 419A005C  beq cr6, 0x829ea3f0
	if ctx.cr[6].eq {
	pc = 0x829EA3F0; continue 'dispatch;
	}
	// 829EA398: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EA39C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 829EA3A0: 4BB27971  bl 0x82511d10
	ctx.lr = 0x829EA3A4;
	sub_82511D10(ctx, base);
	// 829EA3A4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EA3A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EA3AC: 419A0044  beq cr6, 0x829ea3f0
	if ctx.cr[6].eq {
	pc = 0x829EA3F0; continue 'dispatch;
	}
	// 829EA3B0: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 829EA3B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EA3B8: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829EA3BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EA3C0: 4B82A4D9  bl 0x82214898
	ctx.lr = 0x829EA3C4;
	sub_82214898(ctx, base);
	// 829EA3C4: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EA3C8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829EA3CC: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 829EA3D0: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829EA3D4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829EA3D8: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829EA3DC: 4BA6BD3D  bl 0x82456118
	ctx.lr = 0x829EA3E0;
	sub_82456118(ctx, base);
	// 829EA3E0: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 829EA3E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EA3E8: 4B7A9A51  bl 0x82193e38
	ctx.lr = 0x829EA3EC;
	sub_82193E38(ctx, base);
	// 829EA3EC: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	pc = 0x829EA3F0; continue 'dispatch;
            }
            0x829EA3F0 => {
    //   block [0x829EA3F0..0x829EA404)
	// 829EA3F0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA3F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EA3F8: 409A000C  bne cr6, 0x829ea404
	if !ctx.cr[6].eq {
	pc = 0x829EA404; continue 'dispatch;
	}
	// 829EA3FC: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829EA400: 4BFFFF40  b 0x829ea340
	pc = 0x829EA340; continue 'dispatch;
            }
            0x829EA404 => {
    //   block [0x829EA404..0x829EA40C)
	// 829EA404: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829EA408: 4BFFFF38  b 0x829ea340
	pc = 0x829EA340; continue 'dispatch;
            }
            0x829EA40C => {
    //   block [0x829EA40C..0x829EA414)
	// 829EA40C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829EA410: 482BF030  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EA418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EA418 size=372
    let mut pc: u32 = 0x829EA418;
    'dispatch: loop {
        match pc {
            0x829EA418 => {
    //   block [0x829EA418..0x829EA46C)
	// 829EA418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EA41C: 482BEFD5  bl 0x82ca93f0
	ctx.lr = 0x829EA420;
	sub_82CA93D0(ctx, base);
	// 829EA420: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EA424: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 829EA428: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 829EA42C: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 829EA430: 2F170007  cmpwi cr6, r23, 7
	ctx.cr[6].compare_i32(ctx.r[23].s32, 7, &mut ctx.xer);
	// 829EA434: 419A0048  beq cr6, 0x829ea47c
	if ctx.cr[6].eq {
	pc = 0x829EA47C; continue 'dispatch;
	}
	// 829EA438: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 829EA43C: 419A0040  beq cr6, 0x829ea47c
	if ctx.cr[6].eq {
	pc = 0x829EA47C; continue 'dispatch;
	}
	// 829EA440: 2F170009  cmpwi cr6, r23, 9
	ctx.cr[6].compare_i32(ctx.r[23].s32, 9, &mut ctx.xer);
	// 829EA444: 419A0028  beq cr6, 0x829ea46c
	if ctx.cr[6].eq {
	pc = 0x829EA46C; continue 'dispatch;
	}
	// 829EA448: 2F170008  cmpwi cr6, r23, 8
	ctx.cr[6].compare_i32(ctx.r[23].s32, 8, &mut ctx.xer);
	// 829EA44C: 419A0020  beq cr6, 0x829ea46c
	if ctx.cr[6].eq {
	pc = 0x829EA46C; continue 'dispatch;
	}
	// 829EA450: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA454: 56EB083C  slwi r11, r23, 1
	ctx.r[11].u32 = ctx.r[23].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EA458: 7D175A14  add r8, r23, r11
	ctx.r[8].u64 = ctx.r[23].u64 + ctx.r[11].u64;
	// 829EA45C: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829EA460: 8169007C  lwz r11, 0x7c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 829EA464: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829EA468: 4800001C  b 0x829ea484
	pc = 0x829EA484; continue 'dispatch;
            }
            0x829EA46C => {
    //   block [0x829EA46C..0x829EA47C)
	// 829EA46C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA470: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829EA474: 3B2B0018  addi r25, r11, 0x18
	ctx.r[25].s64 = ctx.r[11].s64 + 24;
	// 829EA478: 4800000C  b 0x829ea484
	pc = 0x829EA484; continue 'dispatch;
            }
            0x829EA47C => {
    //   block [0x829EA47C..0x829EA484)
	// 829EA47C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA480: 3B2B0008  addi r25, r11, 8
	ctx.r[25].s64 = ctx.r[11].s64 + 8;
	pc = 0x829EA484; continue 'dispatch;
            }
            0x829EA484 => {
    //   block [0x829EA484..0x829EA4A0)
	// 829EA484: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA488: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829EA48C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EA490: 419A0010  beq cr6, 0x829ea4a0
	if ctx.cr[6].eq {
	pc = 0x829EA4A0; continue 'dispatch;
	}
	// 829EA494: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829EA498: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 829EA49C: 4800000C  b 0x829ea4a8
	pc = 0x829EA4A8; continue 'dispatch;
            }
            0x829EA4A0 => {
    //   block [0x829EA4A0..0x829EA4A8)
	// 829EA4A0: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829EA4A4: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x829EA4A8; continue 'dispatch;
            }
            0x829EA4A8 => {
    //   block [0x829EA4A8..0x829EA4B8)
	// 829EA4A8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EA4AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EA4B0: 3B6A0B7C  addi r27, r10, 0xb7c
	ctx.r[27].s64 = ctx.r[10].s64 + 2940;
	// 829EA4B4: 3B4B0B7C  addi r26, r11, 0xb7c
	ctx.r[26].s64 = ctx.r[11].s64 + 2940;
	pc = 0x829EA4B8; continue 'dispatch;
            }
            0x829EA4B8 => {
    //   block [0x829EA4B8..0x829EA4D4)
	// 829EA4B8: 578A063E  clrlwi r10, r28, 0x18
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 829EA4BC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EA4C0: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 829EA4C4: 409A0010  bne cr6, 0x829ea4d4
	if !ctx.cr[6].eq {
	pc = 0x829EA4D4; continue 'dispatch;
	}
	// 829EA4C8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829EA4CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829EA4D0: 419A0008  beq cr6, 0x829ea4d8
	if ctx.cr[6].eq {
	pc = 0x829EA4D8; continue 'dispatch;
	}
	pc = 0x829EA4D4; continue 'dispatch;
            }
            0x829EA4D4 => {
    //   block [0x829EA4D4..0x829EA4D8)
	// 829EA4D4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829EA4D8; continue 'dispatch;
            }
            0x829EA4D8 => {
    //   block [0x829EA4D8..0x829EA568)
	// 829EA4D8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829EA4DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EA4E0: 409A00A4  bne cr6, 0x829ea584
	if !ctx.cr[6].eq {
	pc = 0x829EA584; continue 'dispatch;
	}
	// 829EA4E4: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EA4E8: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 829EA4EC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829EA4F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829EA4F4: 419A0074  beq cr6, 0x829ea568
	if ctx.cr[6].eq {
	pc = 0x829EA568; continue 'dispatch;
	}
	// 829EA4F8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 829EA4FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EA500: 4B8190E1  bl 0x822035e0
	ctx.lr = 0x829EA504;
	sub_822035E0(ctx, base);
	// 829EA504: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EA508: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EA50C: 419A005C  beq cr6, 0x829ea568
	if ctx.cr[6].eq {
	pc = 0x829EA568; continue 'dispatch;
	}
	// 829EA510: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EA514: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 829EA518: 4BBFC379  bl 0x825e6890
	ctx.lr = 0x829EA51C;
	sub_825E6890(ctx, base);
	// 829EA51C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EA520: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EA524: 419A0044  beq cr6, 0x829ea568
	if ctx.cr[6].eq {
	pc = 0x829EA568; continue 'dispatch;
	}
	// 829EA528: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 829EA52C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EA530: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829EA534: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EA538: 4B82A361  bl 0x82214898
	ctx.lr = 0x829EA53C;
	sub_82214898(ctx, base);
	// 829EA53C: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EA540: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829EA544: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 829EA548: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829EA54C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829EA550: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829EA554: 4BA6BBC5  bl 0x82456118
	ctx.lr = 0x829EA558;
	sub_82456118(ctx, base);
	// 829EA558: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 829EA55C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EA560: 4B7A98D9  bl 0x82193e38
	ctx.lr = 0x829EA564;
	sub_82193E38(ctx, base);
	// 829EA564: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	pc = 0x829EA568; continue 'dispatch;
            }
            0x829EA568 => {
    //   block [0x829EA568..0x829EA57C)
	// 829EA568: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA56C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EA570: 409A000C  bne cr6, 0x829ea57c
	if !ctx.cr[6].eq {
	pc = 0x829EA57C; continue 'dispatch;
	}
	// 829EA574: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829EA578: 4BFFFF40  b 0x829ea4b8
	pc = 0x829EA4B8; continue 'dispatch;
            }
            0x829EA57C => {
    //   block [0x829EA57C..0x829EA584)
	// 829EA57C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829EA580: 4BFFFF38  b 0x829ea4b8
	pc = 0x829EA4B8; continue 'dispatch;
            }
            0x829EA584 => {
    //   block [0x829EA584..0x829EA58C)
	// 829EA584: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829EA588: 482BEEB8  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EA590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829EA590 size=160
    let mut pc: u32 = 0x829EA590;
    'dispatch: loop {
        match pc {
            0x829EA590 => {
    //   block [0x829EA590..0x829EA630)
	// 829EA590: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EA594: 482BEE79  bl 0x82ca940c
	ctx.lr = 0x829EA598;
	sub_82CA93D0(ctx, base);
	// 829EA598: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EA630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EA630 size=96
    let mut pc: u32 = 0x829EA630;
    'dispatch: loop {
        match pc {
            0x829EA630 => {
    //   block [0x829EA630..0x829EA690)
	// 829EA630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EA634: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EA638: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EA63C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EA640: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 829EA644: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EA648: 4B83DAB1  bl 0x822280f8
	ctx.lr = 0x829EA64C;
	sub_822280F8(ctx, base);
	// 829EA64C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829EA650: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EA654: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829EA658: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA65C: 4B83DA9D  bl 0x822280f8
	ctx.lr = 0x829EA660;
	sub_822280F8(ctx, base);
	// 829EA660: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA664: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 829EA668: 4E800421  bctrl
	ctx.lr = 0x829EA66C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EA66C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EA670: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EA674: 4BE9BDFD  bl 0x82886470
	ctx.lr = 0x829EA678;
	sub_82886470(ctx, base);
	// 829EA678: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829EA67C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829EA680: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EA684: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EA688: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EA68C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EA690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EA690 size=136
    let mut pc: u32 = 0x829EA690;
    'dispatch: loop {
        match pc {
            0x829EA690 => {
    //   block [0x829EA690..0x829EA718)
	// 829EA690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EA694: 482BED79  bl 0x82ca940c
	ctx.lr = 0x829EA698;
	sub_82CA93D0(ctx, base);
	// 829EA698: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EA69C: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 829EA6A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EA6A4: 4B83DA55  bl 0x822280f8
	ctx.lr = 0x829EA6A8;
	sub_822280F8(ctx, base);
	// 829EA6A8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829EA6AC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 829EA6B0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 829EA6B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EA6B8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829EA6BC: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 829EA6C0: 83CA0000  lwz r30, 0(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA6C4: 4B83DA35  bl 0x822280f8
	ctx.lr = 0x829EA6C8;
	sub_822280F8(ctx, base);
	// 829EA6C8: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 829EA6CC: 88810050  lbz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829EA6D0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829EA6D4: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 829EA6D8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829EA6DC: 83A80000  lwz r29, 0(r8)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA6E0: 4B917909  bl 0x82301fe8
	ctx.lr = 0x829EA6E4;
	sub_82301FE8(ctx, base);
	// 829EA6E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EA6E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829EA6EC: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 829EA6F0: 4E800421  bctrl
	ctx.lr = 0x829EA6F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EA6F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EA6F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829EA6FC: 4B82A6DD  bl 0x82214dd8
	ctx.lr = 0x829EA700;
	sub_82214DD8(ctx, base);
	// 829EA700: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829EA704: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EA708: 4BE9BD69  bl 0x82886470
	ctx.lr = 0x829EA70C;
	sub_82886470(ctx, base);
	// 829EA70C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829EA710: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829EA714: 482BED48  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EA718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829EA718 size=200
    let mut pc: u32 = 0x829EA718;
    'dispatch: loop {
        match pc {
            0x829EA718 => {
    //   block [0x829EA718..0x829EA7E0)
	// 829EA718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EA71C: 482BECF1  bl 0x82ca940c
	ctx.lr = 0x829EA720;
	sub_82CA93D0(ctx, base);
	// 829EA720: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 829EA724: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EA7E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EA7E0 size=144
    let mut pc: u32 = 0x829EA7E0;
    'dispatch: loop {
        match pc {
            0x829EA7E0 => {
    //   block [0x829EA7E0..0x829EA870)
	// 829EA7E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EA7E4: 482BEC25  bl 0x82ca9408
	ctx.lr = 0x829EA7E8;
	sub_82CA93D0(ctx, base);
	// 829EA7E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EA7EC: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 829EA7F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EA7F4: 4B83D905  bl 0x822280f8
	ctx.lr = 0x829EA7F8;
	sub_822280F8(ctx, base);
	// 829EA7F8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829EA7FC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 829EA800: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 829EA804: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EA808: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 829EA80C: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 829EA810: 83CA0000  lwz r30, 0(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA814: 4B83D8E5  bl 0x822280f8
	ctx.lr = 0x829EA818;
	sub_822280F8(ctx, base);
	// 829EA818: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA81C: 4B83CD45  bl 0x82227560
	ctx.lr = 0x829EA820;
	sub_82227560(ctx, base);
	// 829EA820: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829EA824: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EA828: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829EA82C: 4B83D8CD  bl 0x822280f8
	ctx.lr = 0x829EA830;
	sub_822280F8(ctx, base);
	// 829EA830: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 829EA834: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EA838: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829EA83C: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 829EA840: 83880000  lwz r28, 0(r8)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA844: 4B9176B5  bl 0x82301ef8
	ctx.lr = 0x829EA848;
	sub_82301EF8(ctx, base);
	// 829EA848: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829EA84C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829EA850: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 829EA854: 4E800421  bctrl
	ctx.lr = 0x829EA858;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EA858: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EA85C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EA860: 4BE9BC11  bl 0x82886470
	ctx.lr = 0x829EA864;
	sub_82886470(ctx, base);
	// 829EA864: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829EA868: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829EA86C: 482BEBEC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EA870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EA870 size=132
    let mut pc: u32 = 0x829EA870;
    'dispatch: loop {
        match pc {
            0x829EA870 => {
    //   block [0x829EA870..0x829EA8F4)
	// 829EA870: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EA874: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EA878: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EA87C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EA880: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EA884: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 829EA888: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EA88C: 4B83D86D  bl 0x822280f8
	ctx.lr = 0x829EA890;
	sub_822280F8(ctx, base);
	// 829EA890: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829EA894: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EA898: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 829EA89C: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA8A0: 4B83D859  bl 0x822280f8
	ctx.lr = 0x829EA8A4;
	sub_822280F8(ctx, base);
	// 829EA8A4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA8A8: 4B83CCB9  bl 0x82227560
	ctx.lr = 0x829EA8AC;
	sub_82227560(ctx, base);
	// 829EA8AC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829EA8B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EA8B4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829EA8B8: 4B83D841  bl 0x822280f8
	ctx.lr = 0x829EA8BC;
	sub_822280F8(ctx, base);
	// 829EA8BC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA8C0: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 829EA8C4: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 829EA8C8: 4E800421  bctrl
	ctx.lr = 0x829EA8CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EA8CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EA8D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EA8D4: 4BE9BB9D  bl 0x82886470
	ctx.lr = 0x829EA8D8;
	sub_82886470(ctx, base);
	// 829EA8D8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829EA8DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EA8E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EA8E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EA8E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EA8EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EA8F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EA8F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EA8F8 size=116
    let mut pc: u32 = 0x829EA8F8;
    'dispatch: loop {
        match pc {
            0x829EA8F8 => {
    //   block [0x829EA8F8..0x829EA96C)
	// 829EA8F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EA8FC: 482BEB11  bl 0x82ca940c
	ctx.lr = 0x829EA900;
	sub_82CA93D0(ctx, base);
	// 829EA900: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EA904: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 829EA908: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EA90C: 4B83D7ED  bl 0x822280f8
	ctx.lr = 0x829EA910;
	sub_822280F8(ctx, base);
	// 829EA910: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829EA914: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 829EA918: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 829EA91C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EA920: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829EA924: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 829EA928: 83CA0000  lwz r30, 0(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA92C: 4B83D7CD  bl 0x822280f8
	ctx.lr = 0x829EA930;
	sub_822280F8(ctx, base);
	// 829EA930: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 829EA934: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829EA938: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EA93C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 829EA940: 83A80000  lwz r29, 0(r8)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA944: 4B9175B5  bl 0x82301ef8
	ctx.lr = 0x829EA948;
	sub_82301EF8(ctx, base);
	// 829EA948: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829EA94C: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 829EA950: 4E800421  bctrl
	ctx.lr = 0x829EA954;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EA954: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EA958: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EA95C: 4BE9BB15  bl 0x82886470
	ctx.lr = 0x829EA960;
	sub_82886470(ctx, base);
	// 829EA960: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829EA964: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829EA968: 482BEAF4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EA970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EA970 size=120
    let mut pc: u32 = 0x829EA970;
    'dispatch: loop {
        match pc {
            0x829EA970 => {
    //   block [0x829EA970..0x829EA9E8)
	// 829EA970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EA974: 482BEA99  bl 0x82ca940c
	ctx.lr = 0x829EA978;
	sub_82CA93D0(ctx, base);
	// 829EA978: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EA97C: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 829EA980: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EA984: 4B83D775  bl 0x822280f8
	ctx.lr = 0x829EA988;
	sub_822280F8(ctx, base);
	// 829EA988: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829EA98C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 829EA990: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 829EA994: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EA998: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829EA99C: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 829EA9A0: 83CA0000  lwz r30, 0(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA9A4: 4B83D755  bl 0x822280f8
	ctx.lr = 0x829EA9A8;
	sub_822280F8(ctx, base);
	// 829EA9A8: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 829EA9AC: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829EA9B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EA9B4: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 829EA9B8: 83A80000  lwz r29, 0(r8)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA9BC: 4BE07CB5  bl 0x827f2670
	ctx.lr = 0x829EA9C0;
	sub_827F2670(ctx, base);
	// 829EA9C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EA9C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829EA9C8: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 829EA9CC: 4E800421  bctrl
	ctx.lr = 0x829EA9D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EA9D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EA9D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EA9D8: 4BE9BA99  bl 0x82886470
	ctx.lr = 0x829EA9DC;
	sub_82886470(ctx, base);
	// 829EA9DC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829EA9E0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829EA9E4: 482BEA78  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EA9E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EA9E8 size=120
    let mut pc: u32 = 0x829EA9E8;
    'dispatch: loop {
        match pc {
            0x829EA9E8 => {
    //   block [0x829EA9E8..0x829EAA60)
	// 829EA9E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EA9EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EA9F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EA9F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EA9F8: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 829EA9FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EAA00: 4B83D6F9  bl 0x822280f8
	ctx.lr = 0x829EAA04;
	sub_822280F8(ctx, base);
	// 829EAA04: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829EAA08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EAA0C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 829EAA10: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EAA14: 4B83D6E5  bl 0x822280f8
	ctx.lr = 0x829EAA18;
	sub_822280F8(ctx, base);
	// 829EAA18: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829EAA1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EAA20: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829EAA24: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EAA60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EAA60 size=540
    let mut pc: u32 = 0x829EAA60;
    'dispatch: loop {
        match pc {
            0x829EAA60 => {
    //   block [0x829EAA60..0x829EAB14)
	// 829EAA60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EAA64: 482BE96D  bl 0x82ca93d0
	ctx.lr = 0x829EAA68;
	sub_82CA93D0(ctx, base);
	// 829EAA68: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EAA6C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EAA70: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829EAA74: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 829EAA78: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829EAA7C: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 829EAA80: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 829EAA84: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EAA88: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 829EAA8C: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 829EAA90: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 829EAA94: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EAA98: 813B6C10  lwz r9, 0x6c10(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	// 829EAA9C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829EAAA0: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 829EAAA4: 3BE90001  addi r31, r9, 1
	ctx.r[31].s64 = ctx.r[9].s64 + 1;
	// 829EAAA8: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 829EAAAC: 93FB6C10  stw r31, 0x6c10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(27664 as u32), ctx.r[31].u32 ) };
	// 829EAAB0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EAAB4: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EAAB8: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 829EAABC: 82490064  lwz r18, 0x64(r9)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 829EAAC0: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 829EAAC4: 4B87AF65  bl 0x82265a28
	ctx.lr = 0x829EAAC8;
	sub_82265A28(ctx, base);
	// 829EAAC8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EAACC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829EAAD0: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 829EAAD4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 829EAAD8: 4099019C  ble cr6, 0x829eac74
	if !ctx.cr[6].gt {
	pc = 0x829EAC74; continue 'dispatch;
	}
	// 829EAADC: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 829EAAE0: 7F93E378  mr r19, r28
	ctx.r[19].u64 = ctx.r[28].u64;
	// 829EAAE4: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829EAAE8: 7F91E378  mr r17, r28
	ctx.r[17].u64 = ctx.r[28].u64;
	// 829EAAEC: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 829EAAF0: 38EAFFFF  addi r7, r10, -1
	ctx.r[7].s64 = ctx.r[10].s64 + -1;
	// 829EAAF4: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 829EAAF8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EAAFC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EAB00: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 829EAB04: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 829EAB08: 3B0B0B7C  addi r24, r11, 0xb7c
	ctx.r[24].s64 = ctx.r[11].s64 + 2940;
	// 829EAB0C: 3AEA0B7C  addi r23, r10, 0xb7c
	ctx.r[23].s64 = ctx.r[10].s64 + 2940;
	// 829EAB10: 39C9A2F8  addi r14, r9, -0x5d08
	ctx.r[14].s64 = ctx.r[9].s64 + -23816;
	pc = 0x829EAB14; continue 'dispatch;
            }
            0x829EAB14 => {
    //   block [0x829EAB14..0x829EAB60)
	// 829EAB14: 396E0004  addi r11, r14, 4
	ctx.r[11].s64 = ctx.r[14].s64 + 4;
	// 829EAB18: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 829EAB1C: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829EAB20: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829EAB24: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829EAB28: 7CB3582E  lwzx r5, r19, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829EAB2C: 7D5A2E30  sraw r26, r10, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[26].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 829EAB30: 7D2A2E30  sraw r10, r9, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> tmp.u32) as i64;
	// 829EAB34: 7CEB2E30  sraw r11, r7, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> tmp.u32) as i64;
	// 829EAB38: 3ACB0001  addi r22, r11, 1
	ctx.r[22].s64 = ctx.r[11].s64 + 1;
	// 829EAB3C: 7CCB2E30  sraw r11, r6, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[6].s32 >> tmp.u32) as i64;
	// 829EAB40: 7E1AB051  subf. r16, r26, r22
	ctx.r[16].s64 = ctx.r[22].s64 - ctx.r[26].s64;
	ctx.cr[0].compare_i32(ctx.r[16].s32, 0, &mut ctx.xer);
	// 829EAB44: 39EB0001  addi r15, r11, 1
	ctx.r[15].s64 = ctx.r[11].s64 + 1;
	// 829EAB48: 41820110  beq 0x829eac58
	if ctx.cr[0].eq {
	pc = 0x829EAC58; continue 'dispatch;
	}
	// 829EAB4C: 7D6A7851  subf. r11, r10, r15
	ctx.r[11].s64 = ctx.r[15].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EAB50: 41820108  beq 0x829eac58
	if ctx.cr[0].eq {
	pc = 0x829EAC58; continue 'dispatch;
	}
	// 829EAB54: 7D545378  mr r20, r10
	ctx.r[20].u64 = ctx.r[10].u64;
	// 829EAB58: 7F0A7800  cmpw cr6, r10, r15
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829EAB5C: 409800FC  bge cr6, 0x829eac58
	if !ctx.cr[6].lt {
	pc = 0x829EAC58; continue 'dispatch;
	}
	pc = 0x829EAB60; continue 'dispatch;
            }
            0x829EAB60 => {
    //   block [0x829EAB60..0x829EAB94)
	// 829EAB60: 81520008  lwz r10, 8(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EAB64: 7F1AB000  cmpw cr6, r26, r22
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[22].s32, &mut ctx.xer);
	// 829EAB68: 81720018  lwz r11, 0x18(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24 as u32) ) } as u64;
	// 829EAB6C: 7D515214  add r10, r17, r10
	ctx.r[10].u64 = ctx.r[17].u64 + ctx.r[10].u64;
	// 829EAB70: 7D2B9A14  add r9, r11, r19
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[19].u64;
	// 829EAB74: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EAB78: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EAB7C: 7D68A1D6  mullw r11, r8, r20
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * ctx.r[20].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 829EAB80: 7CEBD214  add r7, r11, r26
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 829EAB84: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EAB88: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829EAB8C: 409800B8  bge cr6, 0x829eac44
	if !ctx.cr[6].lt {
	pc = 0x829EAC44; continue 'dispatch;
	}
	// 829EAB90: 7E158378  mr r21, r16
	ctx.r[21].u64 = ctx.r[16].u64;
	pc = 0x829EAB94; continue 'dispatch;
            }
            0x829EAB94 => {
    //   block [0x829EAB94..0x829EABA0)
	// 829EAB94: 83B90000  lwz r29, 0(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EAB98: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829EAB9C: 419A009C  beq cr6, 0x829eac38
	if ctx.cr[6].eq {
	pc = 0x829EAC38; continue 'dispatch;
	}
	pc = 0x829EABA0; continue 'dispatch;
            }
            0x829EABA0 => {
    //   block [0x829EABA0..0x829EAC28)
	// 829EABA0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EABA4: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829EABA8: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 829EABAC: 40980080  bge cr6, 0x829eac2c
	if !ctx.cr[6].lt {
	pc = 0x829EAC2C; continue 'dispatch;
	}
	// 829EABB0: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 829EABB4: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EABB8: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EABBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EABC0: 4B818A21  bl 0x822035e0
	ctx.lr = 0x829EABC4;
	sub_822035E0(ctx, base);
	// 829EABC4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EABC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EABCC: 419A005C  beq cr6, 0x829eac28
	if ctx.cr[6].eq {
	pc = 0x829EAC28; continue 'dispatch;
	}
	// 829EABD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EABD4: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EABD8: 4B815511  bl 0x822000e8
	ctx.lr = 0x829EABDC;
	sub_822000E8(ctx, base);
	// 829EABDC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EABE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EABE4: 419A0044  beq cr6, 0x829eac28
	if ctx.cr[6].eq {
	pc = 0x829EAC28; continue 'dispatch;
	}
	// 829EABE8: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 829EABEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EABF0: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 829EABF4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EABF8: 4B829CA1  bl 0x82214898
	ctx.lr = 0x829EABFC;
	sub_82214898(ctx, base);
	// 829EABFC: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EAC00: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829EAC04: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EAC08: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 829EAC0C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 829EAC10: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 829EAC14: 4BA6B505  bl 0x82456118
	ctx.lr = 0x829EAC18;
	sub_82456118(ctx, base);
	// 829EAC18: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 829EAC1C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EAC20: 4B7A9219  bl 0x82193e38
	ctx.lr = 0x829EAC24;
	sub_82193E38(ctx, base);
	// 829EAC24: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	pc = 0x829EAC28; continue 'dispatch;
            }
            0x829EAC28 => {
    //   block [0x829EAC28..0x829EAC2C)
	// 829EAC28: 83FB6C10  lwz r31, 0x6c10(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	pc = 0x829EAC2C; continue 'dispatch;
            }
            0x829EAC2C => {
    //   block [0x829EAC2C..0x829EAC38)
	// 829EAC2C: 83BD0004  lwz r29, 4(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EAC30: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829EAC34: 409AFF6C  bne cr6, 0x829eaba0
	if !ctx.cr[6].eq {
	pc = 0x829EABA0; continue 'dispatch;
	}
	pc = 0x829EAC38; continue 'dispatch;
            }
            0x829EAC38 => {
    //   block [0x829EAC38..0x829EAC44)
	// 829EAC38: 36B5FFFF  addic. r21, r21, -1
	ctx.xer.ca = (ctx.r[21].u32 > (!(-1 as u32)));
	ctx.r[21].s64 = ctx.r[21].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[21].s32, 0, &mut ctx.xer);
	// 829EAC3C: 3B390004  addi r25, r25, 4
	ctx.r[25].s64 = ctx.r[25].s64 + 4;
	// 829EAC40: 4082FF54  bne 0x829eab94
	if !ctx.cr[0].eq {
	pc = 0x829EAB94; continue 'dispatch;
	}
	pc = 0x829EAC44; continue 'dispatch;
            }
            0x829EAC44 => {
    //   block [0x829EAC44..0x829EAC58)
	// 829EAC44: 3A940001  addi r20, r20, 1
	ctx.r[20].s64 = ctx.r[20].s64 + 1;
	// 829EAC48: 7F147800  cmpw cr6, r20, r15
	ctx.cr[6].compare_i32(ctx.r[20].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829EAC4C: 4198FF14  blt cr6, 0x829eab60
	if ctx.cr[6].lt {
	pc = 0x829EAB60; continue 'dispatch;
	}
	// 829EAC50: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EAC54: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	pc = 0x829EAC58; continue 'dispatch;
            }
            0x829EAC58 => {
    //   block [0x829EAC58..0x829EAC74)
	// 829EAC58: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829EAC5C: 3A310014  addi r17, r17, 0x14
	ctx.r[17].s64 = ctx.r[17].s64 + 20;
	// 829EAC60: 3A730010  addi r19, r19, 0x10
	ctx.r[19].s64 = ctx.r[19].s64 + 16;
	// 829EAC64: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EAC68: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829EAC6C: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 829EAC70: 4198FEA4  blt cr6, 0x829eab14
	if ctx.cr[6].lt {
	pc = 0x829EAB14; continue 'dispatch;
	}
	pc = 0x829EAC74; continue 'dispatch;
            }
            0x829EAC74 => {
    //   block [0x829EAC74..0x829EAC7C)
	// 829EAC74: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 829EAC78: 482BE7A8  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EAC80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EAC80 size=592
    let mut pc: u32 = 0x829EAC80;
    'dispatch: loop {
        match pc {
            0x829EAC80 => {
    //   block [0x829EAC80..0x829EAD38)
	// 829EAC80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EAC84: 482BE74D  bl 0x82ca93d0
	ctx.lr = 0x829EAC88;
	sub_82CA93D0(ctx, base);
	// 829EAC88: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EAC8C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EAC90: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 829EAC94: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 829EAC98: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 829EAC9C: 3F208349  lis r25, -0x7cb7
	ctx.r[25].s64 = -2092367872;
	// 829EACA0: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 829EACA4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EACA8: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 829EACAC: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 829EACB0: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 829EACB4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EACB8: 81396C10  lwz r9, 0x6c10(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27664 as u32) ) } as u64;
	// 829EACBC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829EACC0: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 829EACC4: 3BE90001  addi r31, r9, 1
	ctx.r[31].s64 = ctx.r[9].s64 + 1;
	// 829EACC8: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 829EACCC: 93F96C10  stw r31, 0x6c10(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(27664 as u32), ctx.r[31].u32 ) };
	// 829EACD0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EACD4: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EACD8: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 829EACDC: 82090064  lwz r16, 0x64(r9)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 829EACE0: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 829EACE4: 4B87AD45  bl 0x82265a28
	ctx.lr = 0x829EACE8;
	sub_82265A28(ctx, base);
	// 829EACE8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EACEC: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 829EACF0: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 829EACF4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 829EACF8: 409901D0  ble cr6, 0x829eaec8
	if !ctx.cr[6].gt {
	pc = 0x829EAEC8; continue 'dispatch;
	}
	// 829EACFC: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 829EAD00: 7F51D378  mr r17, r26
	ctx.r[17].u64 = ctx.r[26].u64;
	// 829EAD04: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829EAD08: 7F4FD378  mr r15, r26
	ctx.r[15].u64 = ctx.r[26].u64;
	// 829EAD0C: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 829EAD10: 38EAFFFF  addi r7, r10, -1
	ctx.r[7].s64 = ctx.r[10].s64 + -1;
	// 829EAD14: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 829EAD18: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 829EAD1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EAD20: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 829EAD24: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EAD28: 3929A2F8  addi r9, r9, -0x5d08
	ctx.r[9].s64 = ctx.r[9].s64 + -23816;
	// 829EAD2C: 3AEB0B7C  addi r23, r11, 0xb7c
	ctx.r[23].s64 = ctx.r[11].s64 + 2940;
	// 829EAD30: 3ACA0B7C  addi r22, r10, 0xb7c
	ctx.r[22].s64 = ctx.r[10].s64 + 2940;
	// 829EAD34: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	pc = 0x829EAD38; continue 'dispatch;
            }
            0x829EAD38 => {
    //   block [0x829EAD38..0x829EAD8C)
	// 829EAD38: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829EAD3C: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 829EAD40: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 829EAD44: 80E10074  lwz r7, 0x74(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829EAD48: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829EAD4C: 80A1005C  lwz r5, 0x5c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829EAD50: 7C91482E  lwzx r4, r17, r9
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[17].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 829EAD54: 7D582630  sraw r24, r10, r4
	tmp.u32 = ctx.r[4].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[24].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 829EAD58: 7CEA2630  sraw r10, r7, r4
	tmp.u32 = ctx.r[4].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[7].s32 >> tmp.u32) as i64;
	// 829EAD5C: 7CCB2630  sraw r11, r6, r4
	tmp.u32 = ctx.r[4].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[6].s32 >> tmp.u32) as i64;
	// 829EAD60: 3A8B0001  addi r20, r11, 1
	ctx.r[20].s64 = ctx.r[11].s64 + 1;
	// 829EAD64: 7CAB2630  sraw r11, r5, r4
	tmp.u32 = ctx.r[4].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[5].s32 >> tmp.u32) as i64;
	// 829EAD68: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 829EAD6C: 7DD8A051  subf. r14, r24, r20
	ctx.r[14].s64 = ctx.r[20].s64 - ctx.r[24].s64;
	ctx.cr[0].compare_i32(ctx.r[14].s32, 0, &mut ctx.xer);
	// 829EAD70: 9121008C  stw r9, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[9].u32 ) };
	// 829EAD74: 41820138  beq 0x829eaeac
	if ctx.cr[0].eq {
	pc = 0x829EAEAC; continue 'dispatch;
	}
	// 829EAD78: 7D6A4851  subf. r11, r10, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EAD7C: 41820130  beq 0x829eaeac
	if ctx.cr[0].eq {
	pc = 0x829EAEAC; continue 'dispatch;
	}
	// 829EAD80: 7D525378  mr r18, r10
	ctx.r[18].u64 = ctx.r[10].u64;
	// 829EAD84: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 829EAD88: 40980124  bge cr6, 0x829eaeac
	if !ctx.cr[6].lt {
	pc = 0x829EAEAC; continue 'dispatch;
	}
	pc = 0x829EAD8C; continue 'dispatch;
            }
            0x829EAD8C => {
    //   block [0x829EAD8C..0x829EADC0)
	// 829EAD8C: 81500008  lwz r10, 8(r16)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EAD90: 7F18A000  cmpw cr6, r24, r20
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[20].s32, &mut ctx.xer);
	// 829EAD94: 81700018  lwz r11, 0x18(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(24 as u32) ) } as u64;
	// 829EAD98: 7D4F5214  add r10, r15, r10
	ctx.r[10].u64 = ctx.r[15].u64 + ctx.r[10].u64;
	// 829EAD9C: 7D0B8A14  add r8, r11, r17
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[17].u64;
	// 829EADA0: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EADA4: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EADA8: 7D6791D6  mullw r11, r7, r18
	ctx.r[11].s32 = ((ctx.r[7].s32 as i64 * ctx.r[18].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 829EADAC: 7CCBC214  add r6, r11, r24
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 829EADB0: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EADB4: 7EAB5214  add r21, r11, r10
	ctx.r[21].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829EADB8: 409800E0  bge cr6, 0x829eae98
	if !ctx.cr[6].lt {
	pc = 0x829EAE98; continue 'dispatch;
	}
	// 829EADBC: 7DD37378  mr r19, r14
	ctx.r[19].u64 = ctx.r[14].u64;
	pc = 0x829EADC0; continue 'dispatch;
            }
            0x829EADC0 => {
    //   block [0x829EADC0..0x829EADCC)
	// 829EADC0: 83750000  lwz r27, 0(r21)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EADC4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 829EADC8: 419A00C0  beq cr6, 0x829eae88
	if ctx.cr[6].eq {
	pc = 0x829EAE88; continue 'dispatch;
	}
	pc = 0x829EADCC; continue 'dispatch;
            }
            0x829EADCC => {
    //   block [0x829EADCC..0x829EAE18)
	// 829EADCC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EADD0: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829EADD4: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 829EADD8: 409800A4  bge cr6, 0x829eae7c
	if !ctx.cr[6].lt {
	pc = 0x829EAE7C; continue 'dispatch;
	}
	// 829EADDC: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 829EADE0: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EADE4: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EADE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EADEC: 4B8187F5  bl 0x822035e0
	ctx.lr = 0x829EADF0;
	sub_822035E0(ctx, base);
	// 829EADF0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EADF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EADF8: 419A0080  beq cr6, 0x829eae78
	if ctx.cr[6].eq {
	pc = 0x829EAE78; continue 'dispatch;
	}
	// 829EADFC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EAE00: 3BBF0024  addi r29, r31, 0x24
	ctx.r[29].s64 = ctx.r[31].s64 + 36;
	// 829EAE04: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EAE08: 2B1E00FE  cmplwi cr6, r30, 0xfe
	ctx.cr[6].compare_u32(ctx.r[30].u32, 254 as u32, &mut ctx.xer);
	// 829EAE0C: 4198000C  blt cr6, 0x829eae18
	if ctx.cr[6].lt {
	pc = 0x829EAE18; continue 'dispatch;
	}
	// 829EAE10: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829EAE14: 4B905E3D  bl 0x822f0c50
	ctx.lr = 0x829EAE18;
	sub_822F0C50(ctx, base);
	pc = 0x829EAE18; continue 'dispatch;
            }
            0x829EAE18 => {
    //   block [0x829EAE18..0x829EAE78)
	// 829EAE18: 57CBE8FA  rlwinm r11, r30, 0x1d, 3, 0x1d
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000007u64;
	// 829EAE1C: 57CA06FE  clrlwi r10, r30, 0x1b
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x0000001Fu64;
	// 829EAE20: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 829EAE24: 7D285030  slw r8, r9, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[9].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 829EAE28: 7CEBE82E  lwzx r7, r11, r29
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 829EAE2C: 7D063838  and r6, r8, r7
	ctx.r[6].u64 = ctx.r[8].u64 & ctx.r[7].u64;
	// 829EAE30: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 829EAE34: 419A0044  beq cr6, 0x829eae78
	if ctx.cr[6].eq {
	pc = 0x829EAE78; continue 'dispatch;
	}
	// 829EAE38: 92C10060  stw r22, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[22].u32 ) };
	// 829EAE3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EAE40: 93410064  stw r26, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[26].u32 ) };
	// 829EAE44: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EAE48: 4B829A51  bl 0x82214898
	ctx.lr = 0x829EAE4C;
	sub_82214898(ctx, base);
	// 829EAE4C: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EAE50: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829EAE54: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EAE58: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 829EAE5C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 829EAE60: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 829EAE64: 4BA6B2B5  bl 0x82456118
	ctx.lr = 0x829EAE68;
	sub_82456118(ctx, base);
	// 829EAE68: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 829EAE6C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EAE70: 4B7A8FC9  bl 0x82193e38
	ctx.lr = 0x829EAE74;
	sub_82193E38(ctx, base);
	// 829EAE74: 93410064  stw r26, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[26].u32 ) };
	pc = 0x829EAE78; continue 'dispatch;
            }
            0x829EAE78 => {
    //   block [0x829EAE78..0x829EAE7C)
	// 829EAE78: 83F96C10  lwz r31, 0x6c10(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27664 as u32) ) } as u64;
	pc = 0x829EAE7C; continue 'dispatch;
            }
            0x829EAE7C => {
    //   block [0x829EAE7C..0x829EAE88)
	// 829EAE7C: 837B0004  lwz r27, 4(r27)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EAE80: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 829EAE84: 409AFF48  bne cr6, 0x829eadcc
	if !ctx.cr[6].eq {
	pc = 0x829EADCC; continue 'dispatch;
	}
	pc = 0x829EAE88; continue 'dispatch;
            }
            0x829EAE88 => {
    //   block [0x829EAE88..0x829EAE98)
	// 829EAE88: 3673FFFF  addic. r19, r19, -1
	ctx.xer.ca = (ctx.r[19].u32 > (!(-1 as u32)));
	ctx.r[19].s64 = ctx.r[19].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[19].s32, 0, &mut ctx.xer);
	// 829EAE8C: 3AB50004  addi r21, r21, 4
	ctx.r[21].s64 = ctx.r[21].s64 + 4;
	// 829EAE90: 4082FF30  bne 0x829eadc0
	if !ctx.cr[0].eq {
	pc = 0x829EADC0; continue 'dispatch;
	}
	// 829EAE94: 8121008C  lwz r9, 0x8c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	pc = 0x829EAE98; continue 'dispatch;
            }
            0x829EAE98 => {
    //   block [0x829EAE98..0x829EAEAC)
	// 829EAE98: 3A520001  addi r18, r18, 1
	ctx.r[18].s64 = ctx.r[18].s64 + 1;
	// 829EAE9C: 7F124800  cmpw cr6, r18, r9
	ctx.cr[6].compare_i32(ctx.r[18].s32, ctx.r[9].s32, &mut ctx.xer);
	// 829EAEA0: 4198FEEC  blt cr6, 0x829ead8c
	if ctx.cr[6].lt {
	pc = 0x829EAD8C; continue 'dispatch;
	}
	// 829EAEA4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EAEA8: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	pc = 0x829EAEAC; continue 'dispatch;
            }
            0x829EAEAC => {
    //   block [0x829EAEAC..0x829EAEC8)
	// 829EAEAC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829EAEB0: 39EF0014  addi r15, r15, 0x14
	ctx.r[15].s64 = ctx.r[15].s64 + 20;
	// 829EAEB4: 3A310010  addi r17, r17, 0x10
	ctx.r[17].s64 = ctx.r[17].s64 + 16;
	// 829EAEB8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EAEBC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829EAEC0: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 829EAEC4: 4198FE74  blt cr6, 0x829ead38
	if ctx.cr[6].lt {
	pc = 0x829EAD38; continue 'dispatch;
	}
	pc = 0x829EAEC8; continue 'dispatch;
            }
            0x829EAEC8 => {
    //   block [0x829EAEC8..0x829EAED0)
	// 829EAEC8: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 829EAECC: 482BE554  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EAED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EAED0 size=400
    let mut pc: u32 = 0x829EAED0;
    'dispatch: loop {
        match pc {
            0x829EAED0 => {
    //   block [0x829EAED0..0x829EAF6C)
	// 829EAED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EAED4: 482BE4FD  bl 0x82ca93d0
	ctx.lr = 0x829EAED8;
	sub_82CA93D0(ctx, base);
	// 829EAED8: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EAEDC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EAEE0: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 829EAEE4: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 829EAEE8: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 829EAEEC: 3EC08349  lis r22, -0x7cb7
	ctx.r[22].s64 = -2092367872;
	// 829EAEF0: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
	// 829EAEF4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EAEF8: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 829EAEFC: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 829EAF00: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 829EAF04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EAF08: 81366C10  lwz r9, 0x6c10(r22)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(27664 as u32) ) } as u64;
	// 829EAF0C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EAF10: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 829EAF14: 3BC90001  addi r30, r9, 1
	ctx.r[30].s64 = ctx.r[9].s64 + 1;
	// 829EAF18: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 829EAF1C: 93D66C10  stw r30, 0x6c10(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(27664 as u32), ctx.r[30].u32 ) };
	// 829EAF20: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EAF24: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EAF28: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 829EAF2C: 82E90064  lwz r23, 0x64(r9)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 829EAF30: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 829EAF34: 4B87AAF5  bl 0x82265a28
	ctx.lr = 0x829EAF38;
	sub_82265A28(ctx, base);
	// 829EAF38: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EAF3C: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 829EAF40: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 829EAF44: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829EAF48: 40990110  ble cr6, 0x829eb058
	if !ctx.cr[6].gt {
	pc = 0x829EB058; continue 'dispatch;
	}
	// 829EAF4C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 829EAF50: 7E98A378  mr r24, r20
	ctx.r[24].u64 = ctx.r[20].u64;
	// 829EAF54: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829EAF58: 3A0BFFFF  addi r16, r11, -1
	ctx.r[16].s64 = ctx.r[11].s64 + -1;
	// 829EAF5C: 81C10064  lwz r14, 0x64(r1)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829EAF60: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 829EAF64: 39EAFFFF  addi r15, r10, -1
	ctx.r[15].s64 = ctx.r[10].s64 + -1;
	// 829EAF68: 3A2BA2F8  addi r17, r11, -0x5d08
	ctx.r[17].s64 = ctx.r[11].s64 + -23816;
	pc = 0x829EAF6C; continue 'dispatch;
            }
            0x829EAF6C => {
    //   block [0x829EAF6C..0x829EAFAC)
	// 829EAF6C: 39710004  addi r11, r17, 4
	ctx.r[11].s64 = ctx.r[17].s64 + 4;
	// 829EAF70: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 829EAF74: 7D18582E  lwzx r8, r24, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829EAF78: 7D5D4630  sraw r29, r10, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 829EAF7C: 7DCA4630  sraw r10, r14, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[14].s32 < 0) && ((ctx.r[14].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[14].s32 >> tmp.u32) as i64;
	// 829EAF80: 7E0B4630  sraw r11, r16, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[16].s32 < 0) && ((ctx.r[16].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[16].s32 >> tmp.u32) as i64;
	// 829EAF84: 3B6B0001  addi r27, r11, 1
	ctx.r[27].s64 = ctx.r[11].s64 + 1;
	// 829EAF88: 7DEB4630  sraw r11, r15, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[15].s32 < 0) && ((ctx.r[15].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[15].s32 >> tmp.u32) as i64;
	// 829EAF8C: 7E7DD851  subf. r19, r29, r27
	ctx.r[19].s64 = ctx.r[27].s64 - ctx.r[29].s64;
	ctx.cr[0].compare_i32(ctx.r[19].s32, 0, &mut ctx.xer);
	// 829EAF90: 3A4B0001  addi r18, r11, 1
	ctx.r[18].s64 = ctx.r[11].s64 + 1;
	// 829EAF94: 418200A8  beq 0x829eb03c
	if ctx.cr[0].eq {
	pc = 0x829EB03C; continue 'dispatch;
	}
	// 829EAF98: 7D6A9051  subf. r11, r10, r18
	ctx.r[11].s64 = ctx.r[18].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EAF9C: 418200A0  beq 0x829eb03c
	if ctx.cr[0].eq {
	pc = 0x829EB03C; continue 'dispatch;
	}
	// 829EAFA0: 7D595378  mr r25, r10
	ctx.r[25].u64 = ctx.r[10].u64;
	// 829EAFA4: 7F0A9000  cmpw cr6, r10, r18
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[18].s32, &mut ctx.xer);
	// 829EAFA8: 40980094  bge cr6, 0x829eb03c
	if !ctx.cr[6].lt {
	pc = 0x829EB03C; continue 'dispatch;
	}
	pc = 0x829EAFAC; continue 'dispatch;
            }
            0x829EAFAC => {
    //   block [0x829EAFAC..0x829EAFE0)
	// 829EAFAC: 81770008  lwz r11, 8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EAFB0: 7F1DD800  cmpw cr6, r29, r27
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[27].s32, &mut ctx.xer);
	// 829EAFB4: 81570018  lwz r10, 0x18(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(24 as u32) ) } as u64;
	// 829EAFB8: 7D745A14  add r11, r20, r11
	ctx.r[11].u64 = ctx.r[20].u64 + ctx.r[11].u64;
	// 829EAFBC: 7D4AC214  add r10, r10, r24
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[24].u64;
	// 829EAFC0: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EAFC4: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EAFC8: 7D69C9D6  mullw r11, r9, r25
	ctx.r[11].s32 = ((ctx.r[9].s32 as i64 * ctx.r[25].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 829EAFCC: 7D0BEA14  add r8, r11, r29
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 829EAFD0: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EAFD4: 7F8B5214  add r28, r11, r10
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829EAFD8: 40980050  bge cr6, 0x829eb028
	if !ctx.cr[6].lt {
	pc = 0x829EB028; continue 'dispatch;
	}
	// 829EAFDC: 7E7A9B78  mr r26, r19
	ctx.r[26].u64 = ctx.r[19].u64;
	pc = 0x829EAFE0; continue 'dispatch;
            }
            0x829EAFE0 => {
    //   block [0x829EAFE0..0x829EAFEC)
	// 829EAFE0: 83FC0000  lwz r31, 0(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EAFE4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EAFE8: 419A0034  beq cr6, 0x829eb01c
	if ctx.cr[6].eq {
	pc = 0x829EB01C; continue 'dispatch;
	}
	pc = 0x829EAFEC; continue 'dispatch;
            }
            0x829EAFEC => {
    //   block [0x829EAFEC..0x829EB010)
	// 829EAFEC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EAFF0: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829EAFF4: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829EAFF8: 40980018  bge cr6, 0x829eb010
	if !ctx.cr[6].lt {
	pc = 0x829EB010; continue 'dispatch;
	}
	// 829EAFFC: 93CB004C  stw r30, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[30].u32 ) };
	// 829EB000: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 829EB004: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB008: 48002399  bl 0x829ed3a0
	ctx.lr = 0x829EB00C;
	sub_829ED3A0(ctx, base);
	// 829EB00C: 83D66C10  lwz r30, 0x6c10(r22)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(27664 as u32) ) } as u64;
	pc = 0x829EB010; continue 'dispatch;
            }
            0x829EB010 => {
    //   block [0x829EB010..0x829EB01C)
	// 829EB010: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB014: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EB018: 409AFFD4  bne cr6, 0x829eafec
	if !ctx.cr[6].eq {
	pc = 0x829EAFEC; continue 'dispatch;
	}
	pc = 0x829EB01C; continue 'dispatch;
            }
            0x829EB01C => {
    //   block [0x829EB01C..0x829EB028)
	// 829EB01C: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 829EB020: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 829EB024: 4082FFBC  bne 0x829eafe0
	if !ctx.cr[0].eq {
	pc = 0x829EAFE0; continue 'dispatch;
	}
	pc = 0x829EB028; continue 'dispatch;
            }
            0x829EB028 => {
    //   block [0x829EB028..0x829EB03C)
	// 829EB028: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 829EB02C: 7F199000  cmpw cr6, r25, r18
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[18].s32, &mut ctx.xer);
	// 829EB030: 4198FF7C  blt cr6, 0x829eafac
	if ctx.cr[6].lt {
	pc = 0x829EAFAC; continue 'dispatch;
	}
	// 829EB034: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EB038: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	pc = 0x829EB03C; continue 'dispatch;
            }
            0x829EB03C => {
    //   block [0x829EB03C..0x829EB058)
	// 829EB03C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829EB040: 3A940014  addi r20, r20, 0x14
	ctx.r[20].s64 = ctx.r[20].s64 + 20;
	// 829EB044: 3B180010  addi r24, r24, 0x10
	ctx.r[24].s64 = ctx.r[24].s64 + 16;
	// 829EB048: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EB04C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829EB050: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 829EB054: 4198FF18  blt cr6, 0x829eaf6c
	if ctx.cr[6].lt {
	pc = 0x829EAF6C; continue 'dispatch;
	}
	pc = 0x829EB058; continue 'dispatch;
            }
            0x829EB058 => {
    //   block [0x829EB058..0x829EB060)
	// 829EB058: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 829EB05C: 482BE3C4  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EB060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EB060 size=540
    let mut pc: u32 = 0x829EB060;
    'dispatch: loop {
        match pc {
            0x829EB060 => {
    //   block [0x829EB060..0x829EB114)
	// 829EB060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EB064: 482BE36D  bl 0x82ca93d0
	ctx.lr = 0x829EB068;
	sub_82CA93D0(ctx, base);
	// 829EB068: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EB06C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB070: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829EB074: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 829EB078: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829EB07C: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 829EB080: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 829EB084: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB088: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 829EB08C: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 829EB090: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 829EB094: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EB098: 813B6C10  lwz r9, 0x6c10(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	// 829EB09C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829EB0A0: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 829EB0A4: 3BE90001  addi r31, r9, 1
	ctx.r[31].s64 = ctx.r[9].s64 + 1;
	// 829EB0A8: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 829EB0AC: 93FB6C10  stw r31, 0x6c10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(27664 as u32), ctx.r[31].u32 ) };
	// 829EB0B0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EB0B4: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB0B8: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 829EB0BC: 82490064  lwz r18, 0x64(r9)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 829EB0C0: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 829EB0C4: 4B87A965  bl 0x82265a28
	ctx.lr = 0x829EB0C8;
	sub_82265A28(ctx, base);
	// 829EB0C8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EB0CC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829EB0D0: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 829EB0D4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 829EB0D8: 4099019C  ble cr6, 0x829eb274
	if !ctx.cr[6].gt {
	pc = 0x829EB274; continue 'dispatch;
	}
	// 829EB0DC: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 829EB0E0: 7F93E378  mr r19, r28
	ctx.r[19].u64 = ctx.r[28].u64;
	// 829EB0E4: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829EB0E8: 7F91E378  mr r17, r28
	ctx.r[17].u64 = ctx.r[28].u64;
	// 829EB0EC: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 829EB0F0: 38EAFFFF  addi r7, r10, -1
	ctx.r[7].s64 = ctx.r[10].s64 + -1;
	// 829EB0F4: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 829EB0F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EB0FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EB100: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 829EB104: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 829EB108: 3B0B0B7C  addi r24, r11, 0xb7c
	ctx.r[24].s64 = ctx.r[11].s64 + 2940;
	// 829EB10C: 3AEA0B7C  addi r23, r10, 0xb7c
	ctx.r[23].s64 = ctx.r[10].s64 + 2940;
	// 829EB110: 39C9A2F8  addi r14, r9, -0x5d08
	ctx.r[14].s64 = ctx.r[9].s64 + -23816;
	pc = 0x829EB114; continue 'dispatch;
            }
            0x829EB114 => {
    //   block [0x829EB114..0x829EB160)
	// 829EB114: 396E0004  addi r11, r14, 4
	ctx.r[11].s64 = ctx.r[14].s64 + 4;
	// 829EB118: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 829EB11C: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829EB120: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829EB124: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829EB128: 7CB3582E  lwzx r5, r19, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829EB12C: 7D5A2E30  sraw r26, r10, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[26].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 829EB130: 7D2A2E30  sraw r10, r9, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> tmp.u32) as i64;
	// 829EB134: 7CEB2E30  sraw r11, r7, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> tmp.u32) as i64;
	// 829EB138: 3ACB0001  addi r22, r11, 1
	ctx.r[22].s64 = ctx.r[11].s64 + 1;
	// 829EB13C: 7CCB2E30  sraw r11, r6, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[6].s32 >> tmp.u32) as i64;
	// 829EB140: 7E1AB051  subf. r16, r26, r22
	ctx.r[16].s64 = ctx.r[22].s64 - ctx.r[26].s64;
	ctx.cr[0].compare_i32(ctx.r[16].s32, 0, &mut ctx.xer);
	// 829EB144: 39EB0001  addi r15, r11, 1
	ctx.r[15].s64 = ctx.r[11].s64 + 1;
	// 829EB148: 41820110  beq 0x829eb258
	if ctx.cr[0].eq {
	pc = 0x829EB258; continue 'dispatch;
	}
	// 829EB14C: 7D6A7851  subf. r11, r10, r15
	ctx.r[11].s64 = ctx.r[15].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EB150: 41820108  beq 0x829eb258
	if ctx.cr[0].eq {
	pc = 0x829EB258; continue 'dispatch;
	}
	// 829EB154: 7D545378  mr r20, r10
	ctx.r[20].u64 = ctx.r[10].u64;
	// 829EB158: 7F0A7800  cmpw cr6, r10, r15
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829EB15C: 409800FC  bge cr6, 0x829eb258
	if !ctx.cr[6].lt {
	pc = 0x829EB258; continue 'dispatch;
	}
	pc = 0x829EB160; continue 'dispatch;
            }
            0x829EB160 => {
    //   block [0x829EB160..0x829EB194)
	// 829EB160: 81520008  lwz r10, 8(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EB164: 7F1AB000  cmpw cr6, r26, r22
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[22].s32, &mut ctx.xer);
	// 829EB168: 81720018  lwz r11, 0x18(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24 as u32) ) } as u64;
	// 829EB16C: 7D515214  add r10, r17, r10
	ctx.r[10].u64 = ctx.r[17].u64 + ctx.r[10].u64;
	// 829EB170: 7D2B9A14  add r9, r11, r19
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[19].u64;
	// 829EB174: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB178: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB17C: 7D68A1D6  mullw r11, r8, r20
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * ctx.r[20].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 829EB180: 7CEBD214  add r7, r11, r26
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 829EB184: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EB188: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829EB18C: 409800B8  bge cr6, 0x829eb244
	if !ctx.cr[6].lt {
	pc = 0x829EB244; continue 'dispatch;
	}
	// 829EB190: 7E158378  mr r21, r16
	ctx.r[21].u64 = ctx.r[16].u64;
	pc = 0x829EB194; continue 'dispatch;
            }
            0x829EB194 => {
    //   block [0x829EB194..0x829EB1A0)
	// 829EB194: 83B90000  lwz r29, 0(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EB198: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829EB19C: 419A009C  beq cr6, 0x829eb238
	if ctx.cr[6].eq {
	pc = 0x829EB238; continue 'dispatch;
	}
	pc = 0x829EB1A0; continue 'dispatch;
            }
            0x829EB1A0 => {
    //   block [0x829EB1A0..0x829EB228)
	// 829EB1A0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EB1A4: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829EB1A8: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 829EB1AC: 40980080  bge cr6, 0x829eb22c
	if !ctx.cr[6].lt {
	pc = 0x829EB22C; continue 'dispatch;
	}
	// 829EB1B0: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 829EB1B4: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB1B8: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EB1BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EB1C0: 4B818421  bl 0x822035e0
	ctx.lr = 0x829EB1C4;
	sub_822035E0(ctx, base);
	// 829EB1C4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EB1C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EB1CC: 419A005C  beq cr6, 0x829eb228
	if ctx.cr[6].eq {
	pc = 0x829EB228; continue 'dispatch;
	}
	// 829EB1D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EB1D4: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB1D8: 4B814159  bl 0x821ff330
	ctx.lr = 0x829EB1DC;
	sub_821FF330(ctx, base);
	// 829EB1DC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EB1E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EB1E4: 419A0044  beq cr6, 0x829eb228
	if ctx.cr[6].eq {
	pc = 0x829EB228; continue 'dispatch;
	}
	// 829EB1E8: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 829EB1EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EB1F0: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 829EB1F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EB1F8: 4B8296A1  bl 0x82214898
	ctx.lr = 0x829EB1FC;
	sub_82214898(ctx, base);
	// 829EB1FC: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EB200: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829EB204: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB208: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 829EB20C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 829EB210: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 829EB214: 4BA6AF05  bl 0x82456118
	ctx.lr = 0x829EB218;
	sub_82456118(ctx, base);
	// 829EB218: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 829EB21C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EB220: 4B7A8C19  bl 0x82193e38
	ctx.lr = 0x829EB224;
	sub_82193E38(ctx, base);
	// 829EB224: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	pc = 0x829EB228; continue 'dispatch;
            }
            0x829EB228 => {
    //   block [0x829EB228..0x829EB22C)
	// 829EB228: 83FB6C10  lwz r31, 0x6c10(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	pc = 0x829EB22C; continue 'dispatch;
            }
            0x829EB22C => {
    //   block [0x829EB22C..0x829EB238)
	// 829EB22C: 83BD0004  lwz r29, 4(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB230: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829EB234: 409AFF6C  bne cr6, 0x829eb1a0
	if !ctx.cr[6].eq {
	pc = 0x829EB1A0; continue 'dispatch;
	}
	pc = 0x829EB238; continue 'dispatch;
            }
            0x829EB238 => {
    //   block [0x829EB238..0x829EB244)
	// 829EB238: 36B5FFFF  addic. r21, r21, -1
	ctx.xer.ca = (ctx.r[21].u32 > (!(-1 as u32)));
	ctx.r[21].s64 = ctx.r[21].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[21].s32, 0, &mut ctx.xer);
	// 829EB23C: 3B390004  addi r25, r25, 4
	ctx.r[25].s64 = ctx.r[25].s64 + 4;
	// 829EB240: 4082FF54  bne 0x829eb194
	if !ctx.cr[0].eq {
	pc = 0x829EB194; continue 'dispatch;
	}
	pc = 0x829EB244; continue 'dispatch;
            }
            0x829EB244 => {
    //   block [0x829EB244..0x829EB258)
	// 829EB244: 3A940001  addi r20, r20, 1
	ctx.r[20].s64 = ctx.r[20].s64 + 1;
	// 829EB248: 7F147800  cmpw cr6, r20, r15
	ctx.cr[6].compare_i32(ctx.r[20].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829EB24C: 4198FF14  blt cr6, 0x829eb160
	if ctx.cr[6].lt {
	pc = 0x829EB160; continue 'dispatch;
	}
	// 829EB250: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EB254: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	pc = 0x829EB258; continue 'dispatch;
            }
            0x829EB258 => {
    //   block [0x829EB258..0x829EB274)
	// 829EB258: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829EB25C: 3A310014  addi r17, r17, 0x14
	ctx.r[17].s64 = ctx.r[17].s64 + 20;
	// 829EB260: 3A730010  addi r19, r19, 0x10
	ctx.r[19].s64 = ctx.r[19].s64 + 16;
	// 829EB264: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EB268: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829EB26C: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 829EB270: 4198FEA4  blt cr6, 0x829eb114
	if ctx.cr[6].lt {
	pc = 0x829EB114; continue 'dispatch;
	}
	pc = 0x829EB274; continue 'dispatch;
            }
            0x829EB274 => {
    //   block [0x829EB274..0x829EB27C)
	// 829EB274: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 829EB278: 482BE1A8  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EB280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EB280 size=536
    let mut pc: u32 = 0x829EB280;
    'dispatch: loop {
        match pc {
            0x829EB280 => {
    //   block [0x829EB280..0x829EB334)
	// 829EB280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EB284: 482BE14D  bl 0x82ca93d0
	ctx.lr = 0x829EB288;
	sub_82CA93D0(ctx, base);
	// 829EB288: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EB28C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB290: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829EB294: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 829EB298: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829EB29C: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 829EB2A0: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 829EB2A4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB2A8: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 829EB2AC: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 829EB2B0: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 829EB2B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EB2B8: 813B6C10  lwz r9, 0x6c10(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	// 829EB2BC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829EB2C0: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 829EB2C4: 3BE90001  addi r31, r9, 1
	ctx.r[31].s64 = ctx.r[9].s64 + 1;
	// 829EB2C8: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 829EB2CC: 93FB6C10  stw r31, 0x6c10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(27664 as u32), ctx.r[31].u32 ) };
	// 829EB2D0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EB2D4: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB2D8: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 829EB2DC: 82490064  lwz r18, 0x64(r9)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 829EB2E0: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 829EB2E4: 4B87A745  bl 0x82265a28
	ctx.lr = 0x829EB2E8;
	sub_82265A28(ctx, base);
	// 829EB2E8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EB2EC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829EB2F0: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 829EB2F4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 829EB2F8: 40990198  ble cr6, 0x829eb490
	if !ctx.cr[6].gt {
	pc = 0x829EB490; continue 'dispatch;
	}
	// 829EB2FC: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 829EB300: 7F93E378  mr r19, r28
	ctx.r[19].u64 = ctx.r[28].u64;
	// 829EB304: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829EB308: 7F91E378  mr r17, r28
	ctx.r[17].u64 = ctx.r[28].u64;
	// 829EB30C: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 829EB310: 38EAFFFF  addi r7, r10, -1
	ctx.r[7].s64 = ctx.r[10].s64 + -1;
	// 829EB314: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 829EB318: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EB31C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EB320: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 829EB324: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 829EB328: 3B0B0B7C  addi r24, r11, 0xb7c
	ctx.r[24].s64 = ctx.r[11].s64 + 2940;
	// 829EB32C: 3AEA0B7C  addi r23, r10, 0xb7c
	ctx.r[23].s64 = ctx.r[10].s64 + 2940;
	// 829EB330: 39C9A2F8  addi r14, r9, -0x5d08
	ctx.r[14].s64 = ctx.r[9].s64 + -23816;
	pc = 0x829EB334; continue 'dispatch;
            }
            0x829EB334 => {
    //   block [0x829EB334..0x829EB380)
	// 829EB334: 396E0004  addi r11, r14, 4
	ctx.r[11].s64 = ctx.r[14].s64 + 4;
	// 829EB338: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 829EB33C: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829EB340: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829EB344: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829EB348: 7CB3582E  lwzx r5, r19, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829EB34C: 7D5A2E30  sraw r26, r10, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[26].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 829EB350: 7D2A2E30  sraw r10, r9, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> tmp.u32) as i64;
	// 829EB354: 7CEB2E30  sraw r11, r7, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> tmp.u32) as i64;
	// 829EB358: 3ACB0001  addi r22, r11, 1
	ctx.r[22].s64 = ctx.r[11].s64 + 1;
	// 829EB35C: 7CCB2E30  sraw r11, r6, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[6].s32 >> tmp.u32) as i64;
	// 829EB360: 7E1AB051  subf. r16, r26, r22
	ctx.r[16].s64 = ctx.r[22].s64 - ctx.r[26].s64;
	ctx.cr[0].compare_i32(ctx.r[16].s32, 0, &mut ctx.xer);
	// 829EB364: 39EB0001  addi r15, r11, 1
	ctx.r[15].s64 = ctx.r[11].s64 + 1;
	// 829EB368: 4182010C  beq 0x829eb474
	if ctx.cr[0].eq {
	pc = 0x829EB474; continue 'dispatch;
	}
	// 829EB36C: 7D6A7851  subf. r11, r10, r15
	ctx.r[11].s64 = ctx.r[15].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EB370: 41820104  beq 0x829eb474
	if ctx.cr[0].eq {
	pc = 0x829EB474; continue 'dispatch;
	}
	// 829EB374: 7D545378  mr r20, r10
	ctx.r[20].u64 = ctx.r[10].u64;
	// 829EB378: 7F0A7800  cmpw cr6, r10, r15
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829EB37C: 409800F8  bge cr6, 0x829eb474
	if !ctx.cr[6].lt {
	pc = 0x829EB474; continue 'dispatch;
	}
	pc = 0x829EB380; continue 'dispatch;
            }
            0x829EB380 => {
    //   block [0x829EB380..0x829EB3B4)
	// 829EB380: 81520008  lwz r10, 8(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EB384: 7F1AB000  cmpw cr6, r26, r22
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[22].s32, &mut ctx.xer);
	// 829EB388: 81720018  lwz r11, 0x18(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24 as u32) ) } as u64;
	// 829EB38C: 7D515214  add r10, r17, r10
	ctx.r[10].u64 = ctx.r[17].u64 + ctx.r[10].u64;
	// 829EB390: 7D2B9A14  add r9, r11, r19
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[19].u64;
	// 829EB394: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB398: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB39C: 7D68A1D6  mullw r11, r8, r20
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * ctx.r[20].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 829EB3A0: 7CEBD214  add r7, r11, r26
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 829EB3A4: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EB3A8: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829EB3AC: 409800B4  bge cr6, 0x829eb460
	if !ctx.cr[6].lt {
	pc = 0x829EB460; continue 'dispatch;
	}
	// 829EB3B0: 7E158378  mr r21, r16
	ctx.r[21].u64 = ctx.r[16].u64;
	pc = 0x829EB3B4; continue 'dispatch;
            }
            0x829EB3B4 => {
    //   block [0x829EB3B4..0x829EB3C0)
	// 829EB3B4: 83B90000  lwz r29, 0(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EB3B8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829EB3BC: 419A0098  beq cr6, 0x829eb454
	if ctx.cr[6].eq {
	pc = 0x829EB454; continue 'dispatch;
	}
	pc = 0x829EB3C0; continue 'dispatch;
            }
            0x829EB3C0 => {
    //   block [0x829EB3C0..0x829EB444)
	// 829EB3C0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EB3C4: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829EB3C8: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 829EB3CC: 4098007C  bge cr6, 0x829eb448
	if !ctx.cr[6].lt {
	pc = 0x829EB448; continue 'dispatch;
	}
	// 829EB3D0: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 829EB3D4: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB3D8: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EB3DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EB3E0: 4B818201  bl 0x822035e0
	ctx.lr = 0x829EB3E4;
	sub_822035E0(ctx, base);
	// 829EB3E4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EB3E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EB3EC: 419A0058  beq cr6, 0x829eb444
	if ctx.cr[6].eq {
	pc = 0x829EB444; continue 'dispatch;
	}
	// 829EB3F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EB3F4: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB3F8: 4BB24CC1  bl 0x825100b8
	ctx.lr = 0x829EB3FC;
	sub_825100B8(ctx, base);
	// 829EB3FC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EB400: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EB404: 419A0040  beq cr6, 0x829eb444
	if ctx.cr[6].eq {
	pc = 0x829EB444; continue 'dispatch;
	}
	// 829EB408: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 829EB40C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EB410: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 829EB414: 4B829485  bl 0x82214898
	ctx.lr = 0x829EB418;
	sub_82214898(ctx, base);
	// 829EB418: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EB41C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829EB420: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB424: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 829EB428: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 829EB42C: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 829EB430: 4BA6ACE9  bl 0x82456118
	ctx.lr = 0x829EB434;
	sub_82456118(ctx, base);
	// 829EB434: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 829EB438: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EB43C: 4B7A89FD  bl 0x82193e38
	ctx.lr = 0x829EB440;
	sub_82193E38(ctx, base);
	// 829EB440: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	pc = 0x829EB444; continue 'dispatch;
            }
            0x829EB444 => {
    //   block [0x829EB444..0x829EB448)
	// 829EB444: 83FB6C10  lwz r31, 0x6c10(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	pc = 0x829EB448; continue 'dispatch;
            }
            0x829EB448 => {
    //   block [0x829EB448..0x829EB454)
	// 829EB448: 83BD0004  lwz r29, 4(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB44C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829EB450: 409AFF70  bne cr6, 0x829eb3c0
	if !ctx.cr[6].eq {
	pc = 0x829EB3C0; continue 'dispatch;
	}
	pc = 0x829EB454; continue 'dispatch;
            }
            0x829EB454 => {
    //   block [0x829EB454..0x829EB460)
	// 829EB454: 36B5FFFF  addic. r21, r21, -1
	ctx.xer.ca = (ctx.r[21].u32 > (!(-1 as u32)));
	ctx.r[21].s64 = ctx.r[21].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[21].s32, 0, &mut ctx.xer);
	// 829EB458: 3B390004  addi r25, r25, 4
	ctx.r[25].s64 = ctx.r[25].s64 + 4;
	// 829EB45C: 4082FF58  bne 0x829eb3b4
	if !ctx.cr[0].eq {
	pc = 0x829EB3B4; continue 'dispatch;
	}
	pc = 0x829EB460; continue 'dispatch;
            }
            0x829EB460 => {
    //   block [0x829EB460..0x829EB474)
	// 829EB460: 3A940001  addi r20, r20, 1
	ctx.r[20].s64 = ctx.r[20].s64 + 1;
	// 829EB464: 7F147800  cmpw cr6, r20, r15
	ctx.cr[6].compare_i32(ctx.r[20].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829EB468: 4198FF18  blt cr6, 0x829eb380
	if ctx.cr[6].lt {
	pc = 0x829EB380; continue 'dispatch;
	}
	// 829EB46C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EB470: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	pc = 0x829EB474; continue 'dispatch;
            }
            0x829EB474 => {
    //   block [0x829EB474..0x829EB490)
	// 829EB474: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829EB478: 3A310014  addi r17, r17, 0x14
	ctx.r[17].s64 = ctx.r[17].s64 + 20;
	// 829EB47C: 3A730010  addi r19, r19, 0x10
	ctx.r[19].s64 = ctx.r[19].s64 + 16;
	// 829EB480: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EB484: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829EB488: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 829EB48C: 4198FEA8  blt cr6, 0x829eb334
	if ctx.cr[6].lt {
	pc = 0x829EB334; continue 'dispatch;
	}
	pc = 0x829EB490; continue 'dispatch;
            }
            0x829EB490 => {
    //   block [0x829EB490..0x829EB498)
	// 829EB490: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 829EB494: 482BDF8C  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EB498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EB498 size=536
    let mut pc: u32 = 0x829EB498;
    'dispatch: loop {
        match pc {
            0x829EB498 => {
    //   block [0x829EB498..0x829EB54C)
	// 829EB498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EB49C: 482BDF35  bl 0x82ca93d0
	ctx.lr = 0x829EB4A0;
	sub_82CA93D0(ctx, base);
	// 829EB4A0: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EB4A4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB4A8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829EB4AC: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 829EB4B0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829EB4B4: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 829EB4B8: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 829EB4BC: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB4C0: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 829EB4C4: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 829EB4C8: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 829EB4CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EB4D0: 813B6C10  lwz r9, 0x6c10(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	// 829EB4D4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829EB4D8: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 829EB4DC: 3BE90001  addi r31, r9, 1
	ctx.r[31].s64 = ctx.r[9].s64 + 1;
	// 829EB4E0: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 829EB4E4: 93FB6C10  stw r31, 0x6c10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(27664 as u32), ctx.r[31].u32 ) };
	// 829EB4E8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EB4EC: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB4F0: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 829EB4F4: 82490064  lwz r18, 0x64(r9)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 829EB4F8: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 829EB4FC: 4B87A52D  bl 0x82265a28
	ctx.lr = 0x829EB500;
	sub_82265A28(ctx, base);
	// 829EB500: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EB504: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829EB508: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 829EB50C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 829EB510: 40990198  ble cr6, 0x829eb6a8
	if !ctx.cr[6].gt {
	pc = 0x829EB6A8; continue 'dispatch;
	}
	// 829EB514: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 829EB518: 7F93E378  mr r19, r28
	ctx.r[19].u64 = ctx.r[28].u64;
	// 829EB51C: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829EB520: 7F91E378  mr r17, r28
	ctx.r[17].u64 = ctx.r[28].u64;
	// 829EB524: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 829EB528: 38EAFFFF  addi r7, r10, -1
	ctx.r[7].s64 = ctx.r[10].s64 + -1;
	// 829EB52C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 829EB530: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EB534: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EB538: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 829EB53C: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 829EB540: 3B0B0B7C  addi r24, r11, 0xb7c
	ctx.r[24].s64 = ctx.r[11].s64 + 2940;
	// 829EB544: 3AEA0B7C  addi r23, r10, 0xb7c
	ctx.r[23].s64 = ctx.r[10].s64 + 2940;
	// 829EB548: 39C9A2F8  addi r14, r9, -0x5d08
	ctx.r[14].s64 = ctx.r[9].s64 + -23816;
	pc = 0x829EB54C; continue 'dispatch;
            }
            0x829EB54C => {
    //   block [0x829EB54C..0x829EB598)
	// 829EB54C: 396E0004  addi r11, r14, 4
	ctx.r[11].s64 = ctx.r[14].s64 + 4;
	// 829EB550: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 829EB554: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829EB558: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829EB55C: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829EB560: 7CB3582E  lwzx r5, r19, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829EB564: 7D5A2E30  sraw r26, r10, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[26].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 829EB568: 7D2A2E30  sraw r10, r9, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> tmp.u32) as i64;
	// 829EB56C: 7CEB2E30  sraw r11, r7, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> tmp.u32) as i64;
	// 829EB570: 3ACB0001  addi r22, r11, 1
	ctx.r[22].s64 = ctx.r[11].s64 + 1;
	// 829EB574: 7CCB2E30  sraw r11, r6, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[6].s32 >> tmp.u32) as i64;
	// 829EB578: 7E1AB051  subf. r16, r26, r22
	ctx.r[16].s64 = ctx.r[22].s64 - ctx.r[26].s64;
	ctx.cr[0].compare_i32(ctx.r[16].s32, 0, &mut ctx.xer);
	// 829EB57C: 39EB0001  addi r15, r11, 1
	ctx.r[15].s64 = ctx.r[11].s64 + 1;
	// 829EB580: 4182010C  beq 0x829eb68c
	if ctx.cr[0].eq {
	pc = 0x829EB68C; continue 'dispatch;
	}
	// 829EB584: 7D6A7851  subf. r11, r10, r15
	ctx.r[11].s64 = ctx.r[15].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EB588: 41820104  beq 0x829eb68c
	if ctx.cr[0].eq {
	pc = 0x829EB68C; continue 'dispatch;
	}
	// 829EB58C: 7D545378  mr r20, r10
	ctx.r[20].u64 = ctx.r[10].u64;
	// 829EB590: 7F0A7800  cmpw cr6, r10, r15
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829EB594: 409800F8  bge cr6, 0x829eb68c
	if !ctx.cr[6].lt {
	pc = 0x829EB68C; continue 'dispatch;
	}
	pc = 0x829EB598; continue 'dispatch;
            }
            0x829EB598 => {
    //   block [0x829EB598..0x829EB5CC)
	// 829EB598: 81520008  lwz r10, 8(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EB59C: 7F1AB000  cmpw cr6, r26, r22
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[22].s32, &mut ctx.xer);
	// 829EB5A0: 81720018  lwz r11, 0x18(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24 as u32) ) } as u64;
	// 829EB5A4: 7D515214  add r10, r17, r10
	ctx.r[10].u64 = ctx.r[17].u64 + ctx.r[10].u64;
	// 829EB5A8: 7D2B9A14  add r9, r11, r19
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[19].u64;
	// 829EB5AC: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB5B0: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB5B4: 7D68A1D6  mullw r11, r8, r20
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * ctx.r[20].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 829EB5B8: 7CEBD214  add r7, r11, r26
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 829EB5BC: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EB5C0: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829EB5C4: 409800B4  bge cr6, 0x829eb678
	if !ctx.cr[6].lt {
	pc = 0x829EB678; continue 'dispatch;
	}
	// 829EB5C8: 7E158378  mr r21, r16
	ctx.r[21].u64 = ctx.r[16].u64;
	pc = 0x829EB5CC; continue 'dispatch;
            }
            0x829EB5CC => {
    //   block [0x829EB5CC..0x829EB5D8)
	// 829EB5CC: 83B90000  lwz r29, 0(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EB5D0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829EB5D4: 419A0098  beq cr6, 0x829eb66c
	if ctx.cr[6].eq {
	pc = 0x829EB66C; continue 'dispatch;
	}
	pc = 0x829EB5D8; continue 'dispatch;
            }
            0x829EB5D8 => {
    //   block [0x829EB5D8..0x829EB65C)
	// 829EB5D8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EB5DC: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829EB5E0: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 829EB5E4: 4098007C  bge cr6, 0x829eb660
	if !ctx.cr[6].lt {
	pc = 0x829EB660; continue 'dispatch;
	}
	// 829EB5E8: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 829EB5EC: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB5F0: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EB5F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EB5F8: 4B817FE9  bl 0x822035e0
	ctx.lr = 0x829EB5FC;
	sub_822035E0(ctx, base);
	// 829EB5FC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EB600: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EB604: 419A0058  beq cr6, 0x829eb65c
	if ctx.cr[6].eq {
	pc = 0x829EB65C; continue 'dispatch;
	}
	// 829EB608: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EB60C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB610: 4BB24BC1  bl 0x825101d0
	ctx.lr = 0x829EB614;
	sub_825101D0(ctx, base);
	// 829EB614: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EB618: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EB61C: 419A0040  beq cr6, 0x829eb65c
	if ctx.cr[6].eq {
	pc = 0x829EB65C; continue 'dispatch;
	}
	// 829EB620: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 829EB624: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EB628: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 829EB62C: 4B82926D  bl 0x82214898
	ctx.lr = 0x829EB630;
	sub_82214898(ctx, base);
	// 829EB630: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EB634: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829EB638: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB63C: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 829EB640: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 829EB644: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 829EB648: 4BA6AAD1  bl 0x82456118
	ctx.lr = 0x829EB64C;
	sub_82456118(ctx, base);
	// 829EB64C: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 829EB650: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EB654: 4B7A87E5  bl 0x82193e38
	ctx.lr = 0x829EB658;
	sub_82193E38(ctx, base);
	// 829EB658: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	pc = 0x829EB65C; continue 'dispatch;
            }
            0x829EB65C => {
    //   block [0x829EB65C..0x829EB660)
	// 829EB65C: 83FB6C10  lwz r31, 0x6c10(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	pc = 0x829EB660; continue 'dispatch;
            }
            0x829EB660 => {
    //   block [0x829EB660..0x829EB66C)
	// 829EB660: 83BD0004  lwz r29, 4(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB664: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829EB668: 409AFF70  bne cr6, 0x829eb5d8
	if !ctx.cr[6].eq {
	pc = 0x829EB5D8; continue 'dispatch;
	}
	pc = 0x829EB66C; continue 'dispatch;
            }
            0x829EB66C => {
    //   block [0x829EB66C..0x829EB678)
	// 829EB66C: 36B5FFFF  addic. r21, r21, -1
	ctx.xer.ca = (ctx.r[21].u32 > (!(-1 as u32)));
	ctx.r[21].s64 = ctx.r[21].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[21].s32, 0, &mut ctx.xer);
	// 829EB670: 3B390004  addi r25, r25, 4
	ctx.r[25].s64 = ctx.r[25].s64 + 4;
	// 829EB674: 4082FF58  bne 0x829eb5cc
	if !ctx.cr[0].eq {
	pc = 0x829EB5CC; continue 'dispatch;
	}
	pc = 0x829EB678; continue 'dispatch;
            }
            0x829EB678 => {
    //   block [0x829EB678..0x829EB68C)
	// 829EB678: 3A940001  addi r20, r20, 1
	ctx.r[20].s64 = ctx.r[20].s64 + 1;
	// 829EB67C: 7F147800  cmpw cr6, r20, r15
	ctx.cr[6].compare_i32(ctx.r[20].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829EB680: 4198FF18  blt cr6, 0x829eb598
	if ctx.cr[6].lt {
	pc = 0x829EB598; continue 'dispatch;
	}
	// 829EB684: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EB688: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	pc = 0x829EB68C; continue 'dispatch;
            }
            0x829EB68C => {
    //   block [0x829EB68C..0x829EB6A8)
	// 829EB68C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829EB690: 3A310014  addi r17, r17, 0x14
	ctx.r[17].s64 = ctx.r[17].s64 + 20;
	// 829EB694: 3A730010  addi r19, r19, 0x10
	ctx.r[19].s64 = ctx.r[19].s64 + 16;
	// 829EB698: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EB69C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829EB6A0: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 829EB6A4: 4198FEA8  blt cr6, 0x829eb54c
	if ctx.cr[6].lt {
	pc = 0x829EB54C; continue 'dispatch;
	}
	pc = 0x829EB6A8; continue 'dispatch;
            }
            0x829EB6A8 => {
    //   block [0x829EB6A8..0x829EB6B0)
	// 829EB6A8: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 829EB6AC: 482BDD74  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EB6B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EB6B0 size=536
    let mut pc: u32 = 0x829EB6B0;
    'dispatch: loop {
        match pc {
            0x829EB6B0 => {
    //   block [0x829EB6B0..0x829EB764)
	// 829EB6B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EB6B4: 482BDD1D  bl 0x82ca93d0
	ctx.lr = 0x829EB6B8;
	sub_82CA93D0(ctx, base);
	// 829EB6B8: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EB6BC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB6C0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829EB6C4: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 829EB6C8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829EB6CC: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 829EB6D0: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 829EB6D4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB6D8: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 829EB6DC: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 829EB6E0: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 829EB6E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EB6E8: 813B6C10  lwz r9, 0x6c10(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	// 829EB6EC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829EB6F0: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 829EB6F4: 3BE90001  addi r31, r9, 1
	ctx.r[31].s64 = ctx.r[9].s64 + 1;
	// 829EB6F8: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 829EB6FC: 93FB6C10  stw r31, 0x6c10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(27664 as u32), ctx.r[31].u32 ) };
	// 829EB700: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EB704: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB708: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 829EB70C: 82490064  lwz r18, 0x64(r9)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 829EB710: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 829EB714: 4B87A315  bl 0x82265a28
	ctx.lr = 0x829EB718;
	sub_82265A28(ctx, base);
	// 829EB718: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EB71C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829EB720: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 829EB724: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 829EB728: 40990198  ble cr6, 0x829eb8c0
	if !ctx.cr[6].gt {
	pc = 0x829EB8C0; continue 'dispatch;
	}
	// 829EB72C: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 829EB730: 7F93E378  mr r19, r28
	ctx.r[19].u64 = ctx.r[28].u64;
	// 829EB734: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829EB738: 7F91E378  mr r17, r28
	ctx.r[17].u64 = ctx.r[28].u64;
	// 829EB73C: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 829EB740: 38EAFFFF  addi r7, r10, -1
	ctx.r[7].s64 = ctx.r[10].s64 + -1;
	// 829EB744: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 829EB748: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EB74C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EB750: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 829EB754: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 829EB758: 3B0B0B7C  addi r24, r11, 0xb7c
	ctx.r[24].s64 = ctx.r[11].s64 + 2940;
	// 829EB75C: 3AEA0B7C  addi r23, r10, 0xb7c
	ctx.r[23].s64 = ctx.r[10].s64 + 2940;
	// 829EB760: 39C9A2F8  addi r14, r9, -0x5d08
	ctx.r[14].s64 = ctx.r[9].s64 + -23816;
	pc = 0x829EB764; continue 'dispatch;
            }
            0x829EB764 => {
    //   block [0x829EB764..0x829EB7B0)
	// 829EB764: 396E0004  addi r11, r14, 4
	ctx.r[11].s64 = ctx.r[14].s64 + 4;
	// 829EB768: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 829EB76C: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829EB770: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829EB774: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829EB778: 7CB3582E  lwzx r5, r19, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829EB77C: 7D5A2E30  sraw r26, r10, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[26].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 829EB780: 7D2A2E30  sraw r10, r9, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> tmp.u32) as i64;
	// 829EB784: 7CEB2E30  sraw r11, r7, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> tmp.u32) as i64;
	// 829EB788: 3ACB0001  addi r22, r11, 1
	ctx.r[22].s64 = ctx.r[11].s64 + 1;
	// 829EB78C: 7CCB2E30  sraw r11, r6, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[6].s32 >> tmp.u32) as i64;
	// 829EB790: 7E1AB051  subf. r16, r26, r22
	ctx.r[16].s64 = ctx.r[22].s64 - ctx.r[26].s64;
	ctx.cr[0].compare_i32(ctx.r[16].s32, 0, &mut ctx.xer);
	// 829EB794: 39EB0001  addi r15, r11, 1
	ctx.r[15].s64 = ctx.r[11].s64 + 1;
	// 829EB798: 4182010C  beq 0x829eb8a4
	if ctx.cr[0].eq {
	pc = 0x829EB8A4; continue 'dispatch;
	}
	// 829EB79C: 7D6A7851  subf. r11, r10, r15
	ctx.r[11].s64 = ctx.r[15].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EB7A0: 41820104  beq 0x829eb8a4
	if ctx.cr[0].eq {
	pc = 0x829EB8A4; continue 'dispatch;
	}
	// 829EB7A4: 7D545378  mr r20, r10
	ctx.r[20].u64 = ctx.r[10].u64;
	// 829EB7A8: 7F0A7800  cmpw cr6, r10, r15
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829EB7AC: 409800F8  bge cr6, 0x829eb8a4
	if !ctx.cr[6].lt {
	pc = 0x829EB8A4; continue 'dispatch;
	}
	pc = 0x829EB7B0; continue 'dispatch;
            }
            0x829EB7B0 => {
    //   block [0x829EB7B0..0x829EB7E4)
	// 829EB7B0: 81520008  lwz r10, 8(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EB7B4: 7F1AB000  cmpw cr6, r26, r22
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[22].s32, &mut ctx.xer);
	// 829EB7B8: 81720018  lwz r11, 0x18(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24 as u32) ) } as u64;
	// 829EB7BC: 7D515214  add r10, r17, r10
	ctx.r[10].u64 = ctx.r[17].u64 + ctx.r[10].u64;
	// 829EB7C0: 7D2B9A14  add r9, r11, r19
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[19].u64;
	// 829EB7C4: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB7C8: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB7CC: 7D68A1D6  mullw r11, r8, r20
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * ctx.r[20].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 829EB7D0: 7CEBD214  add r7, r11, r26
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 829EB7D4: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EB7D8: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829EB7DC: 409800B4  bge cr6, 0x829eb890
	if !ctx.cr[6].lt {
	pc = 0x829EB890; continue 'dispatch;
	}
	// 829EB7E0: 7E158378  mr r21, r16
	ctx.r[21].u64 = ctx.r[16].u64;
	pc = 0x829EB7E4; continue 'dispatch;
            }
            0x829EB7E4 => {
    //   block [0x829EB7E4..0x829EB7F0)
	// 829EB7E4: 83B90000  lwz r29, 0(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EB7E8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829EB7EC: 419A0098  beq cr6, 0x829eb884
	if ctx.cr[6].eq {
	pc = 0x829EB884; continue 'dispatch;
	}
	pc = 0x829EB7F0; continue 'dispatch;
            }
            0x829EB7F0 => {
    //   block [0x829EB7F0..0x829EB874)
	// 829EB7F0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EB7F4: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829EB7F8: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 829EB7FC: 4098007C  bge cr6, 0x829eb878
	if !ctx.cr[6].lt {
	pc = 0x829EB878; continue 'dispatch;
	}
	// 829EB800: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 829EB804: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB808: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EB80C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EB810: 4B817DD1  bl 0x822035e0
	ctx.lr = 0x829EB814;
	sub_822035E0(ctx, base);
	// 829EB814: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EB818: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EB81C: 419A0058  beq cr6, 0x829eb874
	if ctx.cr[6].eq {
	pc = 0x829EB874; continue 'dispatch;
	}
	// 829EB820: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EB824: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB828: 4BB24AD1  bl 0x825102f8
	ctx.lr = 0x829EB82C;
	sub_825102F8(ctx, base);
	// 829EB82C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EB830: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EB834: 419A0040  beq cr6, 0x829eb874
	if ctx.cr[6].eq {
	pc = 0x829EB874; continue 'dispatch;
	}
	// 829EB838: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 829EB83C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EB840: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 829EB844: 4B829055  bl 0x82214898
	ctx.lr = 0x829EB848;
	sub_82214898(ctx, base);
	// 829EB848: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EB84C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829EB850: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB854: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 829EB858: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 829EB85C: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 829EB860: 4BA6A8B9  bl 0x82456118
	ctx.lr = 0x829EB864;
	sub_82456118(ctx, base);
	// 829EB864: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 829EB868: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EB86C: 4B7A85CD  bl 0x82193e38
	ctx.lr = 0x829EB870;
	sub_82193E38(ctx, base);
	// 829EB870: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	pc = 0x829EB874; continue 'dispatch;
            }
            0x829EB874 => {
    //   block [0x829EB874..0x829EB878)
	// 829EB874: 83FB6C10  lwz r31, 0x6c10(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	pc = 0x829EB878; continue 'dispatch;
            }
            0x829EB878 => {
    //   block [0x829EB878..0x829EB884)
	// 829EB878: 83BD0004  lwz r29, 4(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB87C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829EB880: 409AFF70  bne cr6, 0x829eb7f0
	if !ctx.cr[6].eq {
	pc = 0x829EB7F0; continue 'dispatch;
	}
	pc = 0x829EB884; continue 'dispatch;
            }
            0x829EB884 => {
    //   block [0x829EB884..0x829EB890)
	// 829EB884: 36B5FFFF  addic. r21, r21, -1
	ctx.xer.ca = (ctx.r[21].u32 > (!(-1 as u32)));
	ctx.r[21].s64 = ctx.r[21].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[21].s32, 0, &mut ctx.xer);
	// 829EB888: 3B390004  addi r25, r25, 4
	ctx.r[25].s64 = ctx.r[25].s64 + 4;
	// 829EB88C: 4082FF58  bne 0x829eb7e4
	if !ctx.cr[0].eq {
	pc = 0x829EB7E4; continue 'dispatch;
	}
	pc = 0x829EB890; continue 'dispatch;
            }
            0x829EB890 => {
    //   block [0x829EB890..0x829EB8A4)
	// 829EB890: 3A940001  addi r20, r20, 1
	ctx.r[20].s64 = ctx.r[20].s64 + 1;
	// 829EB894: 7F147800  cmpw cr6, r20, r15
	ctx.cr[6].compare_i32(ctx.r[20].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829EB898: 4198FF18  blt cr6, 0x829eb7b0
	if ctx.cr[6].lt {
	pc = 0x829EB7B0; continue 'dispatch;
	}
	// 829EB89C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EB8A0: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	pc = 0x829EB8A4; continue 'dispatch;
            }
            0x829EB8A4 => {
    //   block [0x829EB8A4..0x829EB8C0)
	// 829EB8A4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829EB8A8: 3A310014  addi r17, r17, 0x14
	ctx.r[17].s64 = ctx.r[17].s64 + 20;
	// 829EB8AC: 3A730010  addi r19, r19, 0x10
	ctx.r[19].s64 = ctx.r[19].s64 + 16;
	// 829EB8B0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EB8B4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829EB8B8: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 829EB8BC: 4198FEA8  blt cr6, 0x829eb764
	if ctx.cr[6].lt {
	pc = 0x829EB764; continue 'dispatch;
	}
	pc = 0x829EB8C0; continue 'dispatch;
            }
            0x829EB8C0 => {
    //   block [0x829EB8C0..0x829EB8C8)
	// 829EB8C0: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 829EB8C4: 482BDB5C  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EB8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EB8C8 size=536
    let mut pc: u32 = 0x829EB8C8;
    'dispatch: loop {
        match pc {
            0x829EB8C8 => {
    //   block [0x829EB8C8..0x829EB97C)
	// 829EB8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EB8CC: 482BDB05  bl 0x82ca93d0
	ctx.lr = 0x829EB8D0;
	sub_82CA93D0(ctx, base);
	// 829EB8D0: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EB8D4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB8D8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829EB8DC: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 829EB8E0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829EB8E4: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 829EB8E8: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 829EB8EC: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB8F0: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 829EB8F4: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 829EB8F8: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 829EB8FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EB900: 813B6C10  lwz r9, 0x6c10(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	// 829EB904: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829EB908: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 829EB90C: 3BE90001  addi r31, r9, 1
	ctx.r[31].s64 = ctx.r[9].s64 + 1;
	// 829EB910: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 829EB914: 93FB6C10  stw r31, 0x6c10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(27664 as u32), ctx.r[31].u32 ) };
	// 829EB918: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EB91C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB920: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 829EB924: 82490064  lwz r18, 0x64(r9)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 829EB928: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 829EB92C: 4B87A0FD  bl 0x82265a28
	ctx.lr = 0x829EB930;
	sub_82265A28(ctx, base);
	// 829EB930: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EB934: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829EB938: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 829EB93C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 829EB940: 40990198  ble cr6, 0x829ebad8
	if !ctx.cr[6].gt {
	pc = 0x829EBAD8; continue 'dispatch;
	}
	// 829EB944: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 829EB948: 7F93E378  mr r19, r28
	ctx.r[19].u64 = ctx.r[28].u64;
	// 829EB94C: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829EB950: 7F91E378  mr r17, r28
	ctx.r[17].u64 = ctx.r[28].u64;
	// 829EB954: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 829EB958: 38EAFFFF  addi r7, r10, -1
	ctx.r[7].s64 = ctx.r[10].s64 + -1;
	// 829EB95C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 829EB960: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EB964: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EB968: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 829EB96C: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 829EB970: 3B0B0B7C  addi r24, r11, 0xb7c
	ctx.r[24].s64 = ctx.r[11].s64 + 2940;
	// 829EB974: 3AEA0B7C  addi r23, r10, 0xb7c
	ctx.r[23].s64 = ctx.r[10].s64 + 2940;
	// 829EB978: 39C9A2F8  addi r14, r9, -0x5d08
	ctx.r[14].s64 = ctx.r[9].s64 + -23816;
	pc = 0x829EB97C; continue 'dispatch;
            }
            0x829EB97C => {
    //   block [0x829EB97C..0x829EB9C8)
	// 829EB97C: 396E0004  addi r11, r14, 4
	ctx.r[11].s64 = ctx.r[14].s64 + 4;
	// 829EB980: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 829EB984: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829EB988: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829EB98C: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829EB990: 7CB3582E  lwzx r5, r19, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829EB994: 7D5A2E30  sraw r26, r10, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[26].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 829EB998: 7D2A2E30  sraw r10, r9, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> tmp.u32) as i64;
	// 829EB99C: 7CEB2E30  sraw r11, r7, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> tmp.u32) as i64;
	// 829EB9A0: 3ACB0001  addi r22, r11, 1
	ctx.r[22].s64 = ctx.r[11].s64 + 1;
	// 829EB9A4: 7CCB2E30  sraw r11, r6, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[6].s32 >> tmp.u32) as i64;
	// 829EB9A8: 7E1AB051  subf. r16, r26, r22
	ctx.r[16].s64 = ctx.r[22].s64 - ctx.r[26].s64;
	ctx.cr[0].compare_i32(ctx.r[16].s32, 0, &mut ctx.xer);
	// 829EB9AC: 39EB0001  addi r15, r11, 1
	ctx.r[15].s64 = ctx.r[11].s64 + 1;
	// 829EB9B0: 4182010C  beq 0x829ebabc
	if ctx.cr[0].eq {
	pc = 0x829EBABC; continue 'dispatch;
	}
	// 829EB9B4: 7D6A7851  subf. r11, r10, r15
	ctx.r[11].s64 = ctx.r[15].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EB9B8: 41820104  beq 0x829ebabc
	if ctx.cr[0].eq {
	pc = 0x829EBABC; continue 'dispatch;
	}
	// 829EB9BC: 7D545378  mr r20, r10
	ctx.r[20].u64 = ctx.r[10].u64;
	// 829EB9C0: 7F0A7800  cmpw cr6, r10, r15
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829EB9C4: 409800F8  bge cr6, 0x829ebabc
	if !ctx.cr[6].lt {
	pc = 0x829EBABC; continue 'dispatch;
	}
	pc = 0x829EB9C8; continue 'dispatch;
            }
            0x829EB9C8 => {
    //   block [0x829EB9C8..0x829EB9FC)
	// 829EB9C8: 81520008  lwz r10, 8(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EB9CC: 7F1AB000  cmpw cr6, r26, r22
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[22].s32, &mut ctx.xer);
	// 829EB9D0: 81720018  lwz r11, 0x18(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24 as u32) ) } as u64;
	// 829EB9D4: 7D515214  add r10, r17, r10
	ctx.r[10].u64 = ctx.r[17].u64 + ctx.r[10].u64;
	// 829EB9D8: 7D2B9A14  add r9, r11, r19
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[19].u64;
	// 829EB9DC: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB9E0: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EB9E4: 7D68A1D6  mullw r11, r8, r20
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * ctx.r[20].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 829EB9E8: 7CEBD214  add r7, r11, r26
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 829EB9EC: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EB9F0: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829EB9F4: 409800B4  bge cr6, 0x829ebaa8
	if !ctx.cr[6].lt {
	pc = 0x829EBAA8; continue 'dispatch;
	}
	// 829EB9F8: 7E158378  mr r21, r16
	ctx.r[21].u64 = ctx.r[16].u64;
	pc = 0x829EB9FC; continue 'dispatch;
            }
            0x829EB9FC => {
    //   block [0x829EB9FC..0x829EBA08)
	// 829EB9FC: 83B90000  lwz r29, 0(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EBA00: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829EBA04: 419A0098  beq cr6, 0x829eba9c
	if ctx.cr[6].eq {
	pc = 0x829EBA9C; continue 'dispatch;
	}
	pc = 0x829EBA08; continue 'dispatch;
            }
            0x829EBA08 => {
    //   block [0x829EBA08..0x829EBA8C)
	// 829EBA08: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EBA0C: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829EBA10: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 829EBA14: 4098007C  bge cr6, 0x829eba90
	if !ctx.cr[6].lt {
	pc = 0x829EBA90; continue 'dispatch;
	}
	// 829EBA18: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 829EBA1C: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EBA20: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EBA24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EBA28: 4B817BB9  bl 0x822035e0
	ctx.lr = 0x829EBA2C;
	sub_822035E0(ctx, base);
	// 829EBA2C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EBA30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EBA34: 419A0058  beq cr6, 0x829eba8c
	if ctx.cr[6].eq {
	pc = 0x829EBA8C; continue 'dispatch;
	}
	// 829EBA38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EBA3C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EBA40: 4BB24349  bl 0x8250fd88
	ctx.lr = 0x829EBA44;
	sub_8250FD88(ctx, base);
	// 829EBA44: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EBA48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EBA4C: 419A0040  beq cr6, 0x829eba8c
	if ctx.cr[6].eq {
	pc = 0x829EBA8C; continue 'dispatch;
	}
	// 829EBA50: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 829EBA54: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EBA58: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 829EBA5C: 4B828E3D  bl 0x82214898
	ctx.lr = 0x829EBA60;
	sub_82214898(ctx, base);
	// 829EBA60: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EBA64: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829EBA68: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EBA6C: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 829EBA70: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 829EBA74: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 829EBA78: 4BA6A6A1  bl 0x82456118
	ctx.lr = 0x829EBA7C;
	sub_82456118(ctx, base);
	// 829EBA7C: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 829EBA80: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EBA84: 4B7A83B5  bl 0x82193e38
	ctx.lr = 0x829EBA88;
	sub_82193E38(ctx, base);
	// 829EBA88: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	pc = 0x829EBA8C; continue 'dispatch;
            }
            0x829EBA8C => {
    //   block [0x829EBA8C..0x829EBA90)
	// 829EBA8C: 83FB6C10  lwz r31, 0x6c10(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	pc = 0x829EBA90; continue 'dispatch;
            }
            0x829EBA90 => {
    //   block [0x829EBA90..0x829EBA9C)
	// 829EBA90: 83BD0004  lwz r29, 4(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EBA94: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829EBA98: 409AFF70  bne cr6, 0x829eba08
	if !ctx.cr[6].eq {
	pc = 0x829EBA08; continue 'dispatch;
	}
	pc = 0x829EBA9C; continue 'dispatch;
            }
            0x829EBA9C => {
    //   block [0x829EBA9C..0x829EBAA8)
	// 829EBA9C: 36B5FFFF  addic. r21, r21, -1
	ctx.xer.ca = (ctx.r[21].u32 > (!(-1 as u32)));
	ctx.r[21].s64 = ctx.r[21].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[21].s32, 0, &mut ctx.xer);
	// 829EBAA0: 3B390004  addi r25, r25, 4
	ctx.r[25].s64 = ctx.r[25].s64 + 4;
	// 829EBAA4: 4082FF58  bne 0x829eb9fc
	if !ctx.cr[0].eq {
	pc = 0x829EB9FC; continue 'dispatch;
	}
	pc = 0x829EBAA8; continue 'dispatch;
            }
            0x829EBAA8 => {
    //   block [0x829EBAA8..0x829EBABC)
	// 829EBAA8: 3A940001  addi r20, r20, 1
	ctx.r[20].s64 = ctx.r[20].s64 + 1;
	// 829EBAAC: 7F147800  cmpw cr6, r20, r15
	ctx.cr[6].compare_i32(ctx.r[20].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829EBAB0: 4198FF18  blt cr6, 0x829eb9c8
	if ctx.cr[6].lt {
	pc = 0x829EB9C8; continue 'dispatch;
	}
	// 829EBAB4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EBAB8: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	pc = 0x829EBABC; continue 'dispatch;
            }
            0x829EBABC => {
    //   block [0x829EBABC..0x829EBAD8)
	// 829EBABC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829EBAC0: 3A310014  addi r17, r17, 0x14
	ctx.r[17].s64 = ctx.r[17].s64 + 20;
	// 829EBAC4: 3A730010  addi r19, r19, 0x10
	ctx.r[19].s64 = ctx.r[19].s64 + 16;
	// 829EBAC8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EBACC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829EBAD0: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 829EBAD4: 4198FEA8  blt cr6, 0x829eb97c
	if ctx.cr[6].lt {
	pc = 0x829EB97C; continue 'dispatch;
	}
	pc = 0x829EBAD8; continue 'dispatch;
            }
            0x829EBAD8 => {
    //   block [0x829EBAD8..0x829EBAE0)
	// 829EBAD8: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 829EBADC: 482BD944  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EBAE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EBAE0 size=536
    let mut pc: u32 = 0x829EBAE0;
    'dispatch: loop {
        match pc {
            0x829EBAE0 => {
    //   block [0x829EBAE0..0x829EBB94)
	// 829EBAE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EBAE4: 482BD8ED  bl 0x82ca93d0
	ctx.lr = 0x829EBAE8;
	sub_82CA93D0(ctx, base);
	// 829EBAE8: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EBAEC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EBAF0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829EBAF4: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 829EBAF8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829EBAFC: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 829EBB00: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 829EBB04: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EBB08: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 829EBB0C: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 829EBB10: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 829EBB14: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EBB18: 813B6C10  lwz r9, 0x6c10(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	// 829EBB1C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829EBB20: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 829EBB24: 3BE90001  addi r31, r9, 1
	ctx.r[31].s64 = ctx.r[9].s64 + 1;
	// 829EBB28: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 829EBB2C: 93FB6C10  stw r31, 0x6c10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(27664 as u32), ctx.r[31].u32 ) };
	// 829EBB30: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EBB34: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EBB38: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 829EBB3C: 82490064  lwz r18, 0x64(r9)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 829EBB40: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 829EBB44: 4B879EE5  bl 0x82265a28
	ctx.lr = 0x829EBB48;
	sub_82265A28(ctx, base);
	// 829EBB48: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EBB4C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829EBB50: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 829EBB54: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 829EBB58: 40990198  ble cr6, 0x829ebcf0
	if !ctx.cr[6].gt {
	pc = 0x829EBCF0; continue 'dispatch;
	}
	// 829EBB5C: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 829EBB60: 7F93E378  mr r19, r28
	ctx.r[19].u64 = ctx.r[28].u64;
	// 829EBB64: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829EBB68: 7F91E378  mr r17, r28
	ctx.r[17].u64 = ctx.r[28].u64;
	// 829EBB6C: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 829EBB70: 38EAFFFF  addi r7, r10, -1
	ctx.r[7].s64 = ctx.r[10].s64 + -1;
	// 829EBB74: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 829EBB78: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EBB7C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EBB80: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 829EBB84: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 829EBB88: 3B0B0B7C  addi r24, r11, 0xb7c
	ctx.r[24].s64 = ctx.r[11].s64 + 2940;
	// 829EBB8C: 3AEA0B7C  addi r23, r10, 0xb7c
	ctx.r[23].s64 = ctx.r[10].s64 + 2940;
	// 829EBB90: 39C9A2F8  addi r14, r9, -0x5d08
	ctx.r[14].s64 = ctx.r[9].s64 + -23816;
	pc = 0x829EBB94; continue 'dispatch;
            }
            0x829EBB94 => {
    //   block [0x829EBB94..0x829EBBE0)
	// 829EBB94: 396E0004  addi r11, r14, 4
	ctx.r[11].s64 = ctx.r[14].s64 + 4;
	// 829EBB98: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 829EBB9C: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829EBBA0: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829EBBA4: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829EBBA8: 7CB3582E  lwzx r5, r19, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829EBBAC: 7D5A2E30  sraw r26, r10, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[26].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 829EBBB0: 7D2A2E30  sraw r10, r9, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> tmp.u32) as i64;
	// 829EBBB4: 7CEB2E30  sraw r11, r7, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> tmp.u32) as i64;
	// 829EBBB8: 3ACB0001  addi r22, r11, 1
	ctx.r[22].s64 = ctx.r[11].s64 + 1;
	// 829EBBBC: 7CCB2E30  sraw r11, r6, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[6].s32 >> tmp.u32) as i64;
	// 829EBBC0: 7E1AB051  subf. r16, r26, r22
	ctx.r[16].s64 = ctx.r[22].s64 - ctx.r[26].s64;
	ctx.cr[0].compare_i32(ctx.r[16].s32, 0, &mut ctx.xer);
	// 829EBBC4: 39EB0001  addi r15, r11, 1
	ctx.r[15].s64 = ctx.r[11].s64 + 1;
	// 829EBBC8: 4182010C  beq 0x829ebcd4
	if ctx.cr[0].eq {
	pc = 0x829EBCD4; continue 'dispatch;
	}
	// 829EBBCC: 7D6A7851  subf. r11, r10, r15
	ctx.r[11].s64 = ctx.r[15].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EBBD0: 41820104  beq 0x829ebcd4
	if ctx.cr[0].eq {
	pc = 0x829EBCD4; continue 'dispatch;
	}
	// 829EBBD4: 7D545378  mr r20, r10
	ctx.r[20].u64 = ctx.r[10].u64;
	// 829EBBD8: 7F0A7800  cmpw cr6, r10, r15
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829EBBDC: 409800F8  bge cr6, 0x829ebcd4
	if !ctx.cr[6].lt {
	pc = 0x829EBCD4; continue 'dispatch;
	}
	pc = 0x829EBBE0; continue 'dispatch;
            }
            0x829EBBE0 => {
    //   block [0x829EBBE0..0x829EBC14)
	// 829EBBE0: 81520008  lwz r10, 8(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EBBE4: 7F1AB000  cmpw cr6, r26, r22
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[22].s32, &mut ctx.xer);
	// 829EBBE8: 81720018  lwz r11, 0x18(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24 as u32) ) } as u64;
	// 829EBBEC: 7D515214  add r10, r17, r10
	ctx.r[10].u64 = ctx.r[17].u64 + ctx.r[10].u64;
	// 829EBBF0: 7D2B9A14  add r9, r11, r19
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[19].u64;
	// 829EBBF4: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EBBF8: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EBBFC: 7D68A1D6  mullw r11, r8, r20
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * ctx.r[20].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 829EBC00: 7CEBD214  add r7, r11, r26
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 829EBC04: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EBC08: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829EBC0C: 409800B4  bge cr6, 0x829ebcc0
	if !ctx.cr[6].lt {
	pc = 0x829EBCC0; continue 'dispatch;
	}
	// 829EBC10: 7E158378  mr r21, r16
	ctx.r[21].u64 = ctx.r[16].u64;
	pc = 0x829EBC14; continue 'dispatch;
            }
            0x829EBC14 => {
    //   block [0x829EBC14..0x829EBC20)
	// 829EBC14: 83B90000  lwz r29, 0(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EBC18: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829EBC1C: 419A0098  beq cr6, 0x829ebcb4
	if ctx.cr[6].eq {
	pc = 0x829EBCB4; continue 'dispatch;
	}
	pc = 0x829EBC20; continue 'dispatch;
            }
            0x829EBC20 => {
    //   block [0x829EBC20..0x829EBCA4)
	// 829EBC20: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EBC24: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829EBC28: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 829EBC2C: 4098007C  bge cr6, 0x829ebca8
	if !ctx.cr[6].lt {
	pc = 0x829EBCA8; continue 'dispatch;
	}
	// 829EBC30: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 829EBC34: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EBC38: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EBC3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EBC40: 4B8179A1  bl 0x822035e0
	ctx.lr = 0x829EBC44;
	sub_822035E0(ctx, base);
	// 829EBC44: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EBC48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EBC4C: 419A0058  beq cr6, 0x829ebca4
	if ctx.cr[6].eq {
	pc = 0x829EBCA4; continue 'dispatch;
	}
	// 829EBC50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EBC54: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EBC58: 4BB24259  bl 0x8250feb0
	ctx.lr = 0x829EBC5C;
	sub_8250FEB0(ctx, base);
	// 829EBC5C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EBC60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EBC64: 419A0040  beq cr6, 0x829ebca4
	if ctx.cr[6].eq {
	pc = 0x829EBCA4; continue 'dispatch;
	}
	// 829EBC68: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 829EBC6C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EBC70: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 829EBC74: 4B828C25  bl 0x82214898
	ctx.lr = 0x829EBC78;
	sub_82214898(ctx, base);
	// 829EBC78: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EBC7C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829EBC80: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EBC84: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 829EBC88: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 829EBC8C: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 829EBC90: 4BA6A489  bl 0x82456118
	ctx.lr = 0x829EBC94;
	sub_82456118(ctx, base);
	// 829EBC94: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 829EBC98: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EBC9C: 4B7A819D  bl 0x82193e38
	ctx.lr = 0x829EBCA0;
	sub_82193E38(ctx, base);
	// 829EBCA0: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	pc = 0x829EBCA4; continue 'dispatch;
            }
            0x829EBCA4 => {
    //   block [0x829EBCA4..0x829EBCA8)
	// 829EBCA4: 83FB6C10  lwz r31, 0x6c10(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	pc = 0x829EBCA8; continue 'dispatch;
            }
            0x829EBCA8 => {
    //   block [0x829EBCA8..0x829EBCB4)
	// 829EBCA8: 83BD0004  lwz r29, 4(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EBCAC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829EBCB0: 409AFF70  bne cr6, 0x829ebc20
	if !ctx.cr[6].eq {
	pc = 0x829EBC20; continue 'dispatch;
	}
	pc = 0x829EBCB4; continue 'dispatch;
            }
            0x829EBCB4 => {
    //   block [0x829EBCB4..0x829EBCC0)
	// 829EBCB4: 36B5FFFF  addic. r21, r21, -1
	ctx.xer.ca = (ctx.r[21].u32 > (!(-1 as u32)));
	ctx.r[21].s64 = ctx.r[21].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[21].s32, 0, &mut ctx.xer);
	// 829EBCB8: 3B390004  addi r25, r25, 4
	ctx.r[25].s64 = ctx.r[25].s64 + 4;
	// 829EBCBC: 4082FF58  bne 0x829ebc14
	if !ctx.cr[0].eq {
	pc = 0x829EBC14; continue 'dispatch;
	}
	pc = 0x829EBCC0; continue 'dispatch;
            }
            0x829EBCC0 => {
    //   block [0x829EBCC0..0x829EBCD4)
	// 829EBCC0: 3A940001  addi r20, r20, 1
	ctx.r[20].s64 = ctx.r[20].s64 + 1;
	// 829EBCC4: 7F147800  cmpw cr6, r20, r15
	ctx.cr[6].compare_i32(ctx.r[20].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829EBCC8: 4198FF18  blt cr6, 0x829ebbe0
	if ctx.cr[6].lt {
	pc = 0x829EBBE0; continue 'dispatch;
	}
	// 829EBCCC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EBCD0: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	pc = 0x829EBCD4; continue 'dispatch;
            }
            0x829EBCD4 => {
    //   block [0x829EBCD4..0x829EBCF0)
	// 829EBCD4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829EBCD8: 3A310014  addi r17, r17, 0x14
	ctx.r[17].s64 = ctx.r[17].s64 + 20;
	// 829EBCDC: 3A730010  addi r19, r19, 0x10
	ctx.r[19].s64 = ctx.r[19].s64 + 16;
	// 829EBCE0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EBCE4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829EBCE8: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 829EBCEC: 4198FEA8  blt cr6, 0x829ebb94
	if ctx.cr[6].lt {
	pc = 0x829EBB94; continue 'dispatch;
	}
	pc = 0x829EBCF0; continue 'dispatch;
            }
            0x829EBCF0 => {
    //   block [0x829EBCF0..0x829EBCF8)
	// 829EBCF0: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 829EBCF4: 482BD72C  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EBCF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EBCF8 size=540
    let mut pc: u32 = 0x829EBCF8;
    'dispatch: loop {
        match pc {
            0x829EBCF8 => {
    //   block [0x829EBCF8..0x829EBDAC)
	// 829EBCF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EBCFC: 482BD6D5  bl 0x82ca93d0
	ctx.lr = 0x829EBD00;
	sub_82CA93D0(ctx, base);
	// 829EBD00: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EBD04: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EBD08: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829EBD0C: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 829EBD10: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829EBD14: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 829EBD18: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 829EBD1C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EBD20: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 829EBD24: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 829EBD28: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 829EBD2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EBD30: 813B6C10  lwz r9, 0x6c10(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	// 829EBD34: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829EBD38: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 829EBD3C: 3BE90001  addi r31, r9, 1
	ctx.r[31].s64 = ctx.r[9].s64 + 1;
	// 829EBD40: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 829EBD44: 93FB6C10  stw r31, 0x6c10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(27664 as u32), ctx.r[31].u32 ) };
	// 829EBD48: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EBD4C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EBD50: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 829EBD54: 82490064  lwz r18, 0x64(r9)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 829EBD58: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 829EBD5C: 4B879CCD  bl 0x82265a28
	ctx.lr = 0x829EBD60;
	sub_82265A28(ctx, base);
	// 829EBD60: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EBD64: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829EBD68: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 829EBD6C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 829EBD70: 4099019C  ble cr6, 0x829ebf0c
	if !ctx.cr[6].gt {
	pc = 0x829EBF0C; continue 'dispatch;
	}
	// 829EBD74: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 829EBD78: 7F93E378  mr r19, r28
	ctx.r[19].u64 = ctx.r[28].u64;
	// 829EBD7C: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829EBD80: 7F91E378  mr r17, r28
	ctx.r[17].u64 = ctx.r[28].u64;
	// 829EBD84: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 829EBD88: 38EAFFFF  addi r7, r10, -1
	ctx.r[7].s64 = ctx.r[10].s64 + -1;
	// 829EBD8C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 829EBD90: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EBD94: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EBD98: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 829EBD9C: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 829EBDA0: 3B0B0B7C  addi r24, r11, 0xb7c
	ctx.r[24].s64 = ctx.r[11].s64 + 2940;
	// 829EBDA4: 3AEA0B7C  addi r23, r10, 0xb7c
	ctx.r[23].s64 = ctx.r[10].s64 + 2940;
	// 829EBDA8: 39C9A2F8  addi r14, r9, -0x5d08
	ctx.r[14].s64 = ctx.r[9].s64 + -23816;
	pc = 0x829EBDAC; continue 'dispatch;
            }
            0x829EBDAC => {
    //   block [0x829EBDAC..0x829EBDF8)
	// 829EBDAC: 396E0004  addi r11, r14, 4
	ctx.r[11].s64 = ctx.r[14].s64 + 4;
	// 829EBDB0: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 829EBDB4: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829EBDB8: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829EBDBC: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829EBDC0: 7CB3582E  lwzx r5, r19, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829EBDC4: 7D5A2E30  sraw r26, r10, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[26].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 829EBDC8: 7D2A2E30  sraw r10, r9, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> tmp.u32) as i64;
	// 829EBDCC: 7CEB2E30  sraw r11, r7, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> tmp.u32) as i64;
	// 829EBDD0: 3ACB0001  addi r22, r11, 1
	ctx.r[22].s64 = ctx.r[11].s64 + 1;
	// 829EBDD4: 7CCB2E30  sraw r11, r6, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[6].s32 >> tmp.u32) as i64;
	// 829EBDD8: 7E1AB051  subf. r16, r26, r22
	ctx.r[16].s64 = ctx.r[22].s64 - ctx.r[26].s64;
	ctx.cr[0].compare_i32(ctx.r[16].s32, 0, &mut ctx.xer);
	// 829EBDDC: 39EB0001  addi r15, r11, 1
	ctx.r[15].s64 = ctx.r[11].s64 + 1;
	// 829EBDE0: 41820110  beq 0x829ebef0
	if ctx.cr[0].eq {
	pc = 0x829EBEF0; continue 'dispatch;
	}
	// 829EBDE4: 7D6A7851  subf. r11, r10, r15
	ctx.r[11].s64 = ctx.r[15].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EBDE8: 41820108  beq 0x829ebef0
	if ctx.cr[0].eq {
	pc = 0x829EBEF0; continue 'dispatch;
	}
	// 829EBDEC: 7D545378  mr r20, r10
	ctx.r[20].u64 = ctx.r[10].u64;
	// 829EBDF0: 7F0A7800  cmpw cr6, r10, r15
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829EBDF4: 409800FC  bge cr6, 0x829ebef0
	if !ctx.cr[6].lt {
	pc = 0x829EBEF0; continue 'dispatch;
	}
	pc = 0x829EBDF8; continue 'dispatch;
            }
            0x829EBDF8 => {
    //   block [0x829EBDF8..0x829EBE2C)
	// 829EBDF8: 81520008  lwz r10, 8(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EBDFC: 7F1AB000  cmpw cr6, r26, r22
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[22].s32, &mut ctx.xer);
	// 829EBE00: 81720018  lwz r11, 0x18(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24 as u32) ) } as u64;
	// 829EBE04: 7D515214  add r10, r17, r10
	ctx.r[10].u64 = ctx.r[17].u64 + ctx.r[10].u64;
	// 829EBE08: 7D2B9A14  add r9, r11, r19
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[19].u64;
	// 829EBE0C: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EBE10: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EBE14: 7D68A1D6  mullw r11, r8, r20
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * ctx.r[20].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 829EBE18: 7CEBD214  add r7, r11, r26
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 829EBE1C: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EBE20: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829EBE24: 409800B8  bge cr6, 0x829ebedc
	if !ctx.cr[6].lt {
	pc = 0x829EBEDC; continue 'dispatch;
	}
	// 829EBE28: 7E158378  mr r21, r16
	ctx.r[21].u64 = ctx.r[16].u64;
	pc = 0x829EBE2C; continue 'dispatch;
            }
            0x829EBE2C => {
    //   block [0x829EBE2C..0x829EBE38)
	// 829EBE2C: 83B90000  lwz r29, 0(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EBE30: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829EBE34: 419A009C  beq cr6, 0x829ebed0
	if ctx.cr[6].eq {
	pc = 0x829EBED0; continue 'dispatch;
	}
	pc = 0x829EBE38; continue 'dispatch;
            }
            0x829EBE38 => {
    //   block [0x829EBE38..0x829EBEC0)
	// 829EBE38: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EBE3C: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829EBE40: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 829EBE44: 40980080  bge cr6, 0x829ebec4
	if !ctx.cr[6].lt {
	pc = 0x829EBEC4; continue 'dispatch;
	}
	// 829EBE48: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 829EBE4C: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EBE50: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EBE54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EBE58: 4B817789  bl 0x822035e0
	ctx.lr = 0x829EBE5C;
	sub_822035E0(ctx, base);
	// 829EBE5C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EBE60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EBE64: 419A005C  beq cr6, 0x829ebec0
	if ctx.cr[6].eq {
	pc = 0x829EBEC0; continue 'dispatch;
	}
	// 829EBE68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EBE6C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EBE70: 4BB25729  bl 0x82511598
	ctx.lr = 0x829EBE74;
	sub_82511598(ctx, base);
	// 829EBE74: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EBE78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EBE7C: 419A0044  beq cr6, 0x829ebec0
	if ctx.cr[6].eq {
	pc = 0x829EBEC0; continue 'dispatch;
	}
	// 829EBE80: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 829EBE84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EBE88: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 829EBE8C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EBE90: 4B828A09  bl 0x82214898
	ctx.lr = 0x829EBE94;
	sub_82214898(ctx, base);
	// 829EBE94: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EBE98: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829EBE9C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EBEA0: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 829EBEA4: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 829EBEA8: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 829EBEAC: 4BA6A26D  bl 0x82456118
	ctx.lr = 0x829EBEB0;
	sub_82456118(ctx, base);
	// 829EBEB0: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 829EBEB4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EBEB8: 4B7A7F81  bl 0x82193e38
	ctx.lr = 0x829EBEBC;
	sub_82193E38(ctx, base);
	// 829EBEBC: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	pc = 0x829EBEC0; continue 'dispatch;
            }
            0x829EBEC0 => {
    //   block [0x829EBEC0..0x829EBEC4)
	// 829EBEC0: 83FB6C10  lwz r31, 0x6c10(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	pc = 0x829EBEC4; continue 'dispatch;
            }
            0x829EBEC4 => {
    //   block [0x829EBEC4..0x829EBED0)
	// 829EBEC4: 83BD0004  lwz r29, 4(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EBEC8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829EBECC: 409AFF6C  bne cr6, 0x829ebe38
	if !ctx.cr[6].eq {
	pc = 0x829EBE38; continue 'dispatch;
	}
	pc = 0x829EBED0; continue 'dispatch;
            }
            0x829EBED0 => {
    //   block [0x829EBED0..0x829EBEDC)
	// 829EBED0: 36B5FFFF  addic. r21, r21, -1
	ctx.xer.ca = (ctx.r[21].u32 > (!(-1 as u32)));
	ctx.r[21].s64 = ctx.r[21].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[21].s32, 0, &mut ctx.xer);
	// 829EBED4: 3B390004  addi r25, r25, 4
	ctx.r[25].s64 = ctx.r[25].s64 + 4;
	// 829EBED8: 4082FF54  bne 0x829ebe2c
	if !ctx.cr[0].eq {
	pc = 0x829EBE2C; continue 'dispatch;
	}
	pc = 0x829EBEDC; continue 'dispatch;
            }
            0x829EBEDC => {
    //   block [0x829EBEDC..0x829EBEF0)
	// 829EBEDC: 3A940001  addi r20, r20, 1
	ctx.r[20].s64 = ctx.r[20].s64 + 1;
	// 829EBEE0: 7F147800  cmpw cr6, r20, r15
	ctx.cr[6].compare_i32(ctx.r[20].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829EBEE4: 4198FF14  blt cr6, 0x829ebdf8
	if ctx.cr[6].lt {
	pc = 0x829EBDF8; continue 'dispatch;
	}
	// 829EBEE8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EBEEC: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	pc = 0x829EBEF0; continue 'dispatch;
            }
            0x829EBEF0 => {
    //   block [0x829EBEF0..0x829EBF0C)
	// 829EBEF0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829EBEF4: 3A310014  addi r17, r17, 0x14
	ctx.r[17].s64 = ctx.r[17].s64 + 20;
	// 829EBEF8: 3A730010  addi r19, r19, 0x10
	ctx.r[19].s64 = ctx.r[19].s64 + 16;
	// 829EBEFC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EBF00: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829EBF04: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 829EBF08: 4198FEA4  blt cr6, 0x829ebdac
	if ctx.cr[6].lt {
	pc = 0x829EBDAC; continue 'dispatch;
	}
	pc = 0x829EBF0C; continue 'dispatch;
            }
            0x829EBF0C => {
    //   block [0x829EBF0C..0x829EBF14)
	// 829EBF0C: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 829EBF10: 482BD510  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EBF18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EBF18 size=540
    let mut pc: u32 = 0x829EBF18;
    'dispatch: loop {
        match pc {
            0x829EBF18 => {
    //   block [0x829EBF18..0x829EBFCC)
	// 829EBF18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EBF1C: 482BD4B5  bl 0x82ca93d0
	ctx.lr = 0x829EBF20;
	sub_82CA93D0(ctx, base);
	// 829EBF20: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EBF24: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EBF28: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829EBF2C: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 829EBF30: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829EBF34: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 829EBF38: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 829EBF3C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EBF40: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 829EBF44: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 829EBF48: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 829EBF4C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EBF50: 813B6C10  lwz r9, 0x6c10(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	// 829EBF54: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829EBF58: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 829EBF5C: 3BE90001  addi r31, r9, 1
	ctx.r[31].s64 = ctx.r[9].s64 + 1;
	// 829EBF60: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 829EBF64: 93FB6C10  stw r31, 0x6c10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(27664 as u32), ctx.r[31].u32 ) };
	// 829EBF68: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EBF6C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EBF70: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 829EBF74: 82490064  lwz r18, 0x64(r9)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 829EBF78: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 829EBF7C: 4B879AAD  bl 0x82265a28
	ctx.lr = 0x829EBF80;
	sub_82265A28(ctx, base);
	// 829EBF80: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EBF84: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829EBF88: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 829EBF8C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 829EBF90: 4099019C  ble cr6, 0x829ec12c
	if !ctx.cr[6].gt {
	pc = 0x829EC12C; continue 'dispatch;
	}
	// 829EBF94: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 829EBF98: 7F93E378  mr r19, r28
	ctx.r[19].u64 = ctx.r[28].u64;
	// 829EBF9C: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829EBFA0: 7F91E378  mr r17, r28
	ctx.r[17].u64 = ctx.r[28].u64;
	// 829EBFA4: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 829EBFA8: 38EAFFFF  addi r7, r10, -1
	ctx.r[7].s64 = ctx.r[10].s64 + -1;
	// 829EBFAC: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 829EBFB0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EBFB4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EBFB8: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 829EBFBC: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 829EBFC0: 3B0B0B7C  addi r24, r11, 0xb7c
	ctx.r[24].s64 = ctx.r[11].s64 + 2940;
	// 829EBFC4: 3AEA0B7C  addi r23, r10, 0xb7c
	ctx.r[23].s64 = ctx.r[10].s64 + 2940;
	// 829EBFC8: 39C9A2F8  addi r14, r9, -0x5d08
	ctx.r[14].s64 = ctx.r[9].s64 + -23816;
	pc = 0x829EBFCC; continue 'dispatch;
            }
            0x829EBFCC => {
    //   block [0x829EBFCC..0x829EC018)
	// 829EBFCC: 396E0004  addi r11, r14, 4
	ctx.r[11].s64 = ctx.r[14].s64 + 4;
	// 829EBFD0: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 829EBFD4: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829EBFD8: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829EBFDC: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829EBFE0: 7CB3582E  lwzx r5, r19, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829EBFE4: 7D5A2E30  sraw r26, r10, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[26].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 829EBFE8: 7D2A2E30  sraw r10, r9, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> tmp.u32) as i64;
	// 829EBFEC: 7CEB2E30  sraw r11, r7, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> tmp.u32) as i64;
	// 829EBFF0: 3ACB0001  addi r22, r11, 1
	ctx.r[22].s64 = ctx.r[11].s64 + 1;
	// 829EBFF4: 7CCB2E30  sraw r11, r6, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[6].s32 >> tmp.u32) as i64;
	// 829EBFF8: 7E1AB051  subf. r16, r26, r22
	ctx.r[16].s64 = ctx.r[22].s64 - ctx.r[26].s64;
	ctx.cr[0].compare_i32(ctx.r[16].s32, 0, &mut ctx.xer);
	// 829EBFFC: 39EB0001  addi r15, r11, 1
	ctx.r[15].s64 = ctx.r[11].s64 + 1;
	// 829EC000: 41820110  beq 0x829ec110
	if ctx.cr[0].eq {
	pc = 0x829EC110; continue 'dispatch;
	}
	// 829EC004: 7D6A7851  subf. r11, r10, r15
	ctx.r[11].s64 = ctx.r[15].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EC008: 41820108  beq 0x829ec110
	if ctx.cr[0].eq {
	pc = 0x829EC110; continue 'dispatch;
	}
	// 829EC00C: 7D545378  mr r20, r10
	ctx.r[20].u64 = ctx.r[10].u64;
	// 829EC010: 7F0A7800  cmpw cr6, r10, r15
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829EC014: 409800FC  bge cr6, 0x829ec110
	if !ctx.cr[6].lt {
	pc = 0x829EC110; continue 'dispatch;
	}
	pc = 0x829EC018; continue 'dispatch;
            }
            0x829EC018 => {
    //   block [0x829EC018..0x829EC04C)
	// 829EC018: 81520008  lwz r10, 8(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EC01C: 7F1AB000  cmpw cr6, r26, r22
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[22].s32, &mut ctx.xer);
	// 829EC020: 81720018  lwz r11, 0x18(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24 as u32) ) } as u64;
	// 829EC024: 7D515214  add r10, r17, r10
	ctx.r[10].u64 = ctx.r[17].u64 + ctx.r[10].u64;
	// 829EC028: 7D2B9A14  add r9, r11, r19
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[19].u64;
	// 829EC02C: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC030: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC034: 7D68A1D6  mullw r11, r8, r20
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * ctx.r[20].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 829EC038: 7CEBD214  add r7, r11, r26
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 829EC03C: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EC040: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829EC044: 409800B8  bge cr6, 0x829ec0fc
	if !ctx.cr[6].lt {
	pc = 0x829EC0FC; continue 'dispatch;
	}
	// 829EC048: 7E158378  mr r21, r16
	ctx.r[21].u64 = ctx.r[16].u64;
	pc = 0x829EC04C; continue 'dispatch;
            }
            0x829EC04C => {
    //   block [0x829EC04C..0x829EC058)
	// 829EC04C: 83B90000  lwz r29, 0(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC050: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829EC054: 419A009C  beq cr6, 0x829ec0f0
	if ctx.cr[6].eq {
	pc = 0x829EC0F0; continue 'dispatch;
	}
	pc = 0x829EC058; continue 'dispatch;
            }
            0x829EC058 => {
    //   block [0x829EC058..0x829EC0E0)
	// 829EC058: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC05C: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829EC060: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 829EC064: 40980080  bge cr6, 0x829ec0e4
	if !ctx.cr[6].lt {
	pc = 0x829EC0E4; continue 'dispatch;
	}
	// 829EC068: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 829EC06C: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC070: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC074: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EC078: 4B817569  bl 0x822035e0
	ctx.lr = 0x829EC07C;
	sub_822035E0(ctx, base);
	// 829EC07C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EC080: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EC084: 419A005C  beq cr6, 0x829ec0e0
	if ctx.cr[6].eq {
	pc = 0x829EC0E0; continue 'dispatch;
	}
	// 829EC088: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EC08C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC090: 4BB25739  bl 0x825117c8
	ctx.lr = 0x829EC094;
	sub_825117C8(ctx, base);
	// 829EC094: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EC098: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EC09C: 419A0044  beq cr6, 0x829ec0e0
	if ctx.cr[6].eq {
	pc = 0x829EC0E0; continue 'dispatch;
	}
	// 829EC0A0: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 829EC0A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EC0A8: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 829EC0AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EC0B0: 4B8287E9  bl 0x82214898
	ctx.lr = 0x829EC0B4;
	sub_82214898(ctx, base);
	// 829EC0B4: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EC0B8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829EC0BC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC0C0: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 829EC0C4: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 829EC0C8: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 829EC0CC: 4BA6A04D  bl 0x82456118
	ctx.lr = 0x829EC0D0;
	sub_82456118(ctx, base);
	// 829EC0D0: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 829EC0D4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EC0D8: 4B7A7D61  bl 0x82193e38
	ctx.lr = 0x829EC0DC;
	sub_82193E38(ctx, base);
	// 829EC0DC: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	pc = 0x829EC0E0; continue 'dispatch;
            }
            0x829EC0E0 => {
    //   block [0x829EC0E0..0x829EC0E4)
	// 829EC0E0: 83FB6C10  lwz r31, 0x6c10(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	pc = 0x829EC0E4; continue 'dispatch;
            }
            0x829EC0E4 => {
    //   block [0x829EC0E4..0x829EC0F0)
	// 829EC0E4: 83BD0004  lwz r29, 4(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC0E8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829EC0EC: 409AFF6C  bne cr6, 0x829ec058
	if !ctx.cr[6].eq {
	pc = 0x829EC058; continue 'dispatch;
	}
	pc = 0x829EC0F0; continue 'dispatch;
            }
            0x829EC0F0 => {
    //   block [0x829EC0F0..0x829EC0FC)
	// 829EC0F0: 36B5FFFF  addic. r21, r21, -1
	ctx.xer.ca = (ctx.r[21].u32 > (!(-1 as u32)));
	ctx.r[21].s64 = ctx.r[21].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[21].s32, 0, &mut ctx.xer);
	// 829EC0F4: 3B390004  addi r25, r25, 4
	ctx.r[25].s64 = ctx.r[25].s64 + 4;
	// 829EC0F8: 4082FF54  bne 0x829ec04c
	if !ctx.cr[0].eq {
	pc = 0x829EC04C; continue 'dispatch;
	}
	pc = 0x829EC0FC; continue 'dispatch;
            }
            0x829EC0FC => {
    //   block [0x829EC0FC..0x829EC110)
	// 829EC0FC: 3A940001  addi r20, r20, 1
	ctx.r[20].s64 = ctx.r[20].s64 + 1;
	// 829EC100: 7F147800  cmpw cr6, r20, r15
	ctx.cr[6].compare_i32(ctx.r[20].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829EC104: 4198FF14  blt cr6, 0x829ec018
	if ctx.cr[6].lt {
	pc = 0x829EC018; continue 'dispatch;
	}
	// 829EC108: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EC10C: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	pc = 0x829EC110; continue 'dispatch;
            }
            0x829EC110 => {
    //   block [0x829EC110..0x829EC12C)
	// 829EC110: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829EC114: 3A310014  addi r17, r17, 0x14
	ctx.r[17].s64 = ctx.r[17].s64 + 20;
	// 829EC118: 3A730010  addi r19, r19, 0x10
	ctx.r[19].s64 = ctx.r[19].s64 + 16;
	// 829EC11C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EC120: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829EC124: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 829EC128: 4198FEA4  blt cr6, 0x829ebfcc
	if ctx.cr[6].lt {
	pc = 0x829EBFCC; continue 'dispatch;
	}
	pc = 0x829EC12C; continue 'dispatch;
            }
            0x829EC12C => {
    //   block [0x829EC12C..0x829EC134)
	// 829EC12C: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 829EC130: 482BD2F0  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EC138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EC138 size=552
    let mut pc: u32 = 0x829EC138;
    'dispatch: loop {
        match pc {
            0x829EC138 => {
    //   block [0x829EC138..0x829EC1EC)
	// 829EC138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EC13C: 482BD295  bl 0x82ca93d0
	ctx.lr = 0x829EC140;
	sub_82CA93D0(ctx, base);
	// 829EC140: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EC144: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC148: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829EC14C: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 829EC150: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829EC154: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 829EC158: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 829EC15C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC160: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 829EC164: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 829EC168: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 829EC16C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EC170: 813B6C10  lwz r9, 0x6c10(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	// 829EC174: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829EC178: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 829EC17C: 3BE90001  addi r31, r9, 1
	ctx.r[31].s64 = ctx.r[9].s64 + 1;
	// 829EC180: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 829EC184: 93FB6C10  stw r31, 0x6c10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(27664 as u32), ctx.r[31].u32 ) };
	// 829EC188: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EC18C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC190: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 829EC194: 82490064  lwz r18, 0x64(r9)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 829EC198: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 829EC19C: 4B87988D  bl 0x82265a28
	ctx.lr = 0x829EC1A0;
	sub_82265A28(ctx, base);
	// 829EC1A0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EC1A4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829EC1A8: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 829EC1AC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 829EC1B0: 409901A8  ble cr6, 0x829ec358
	if !ctx.cr[6].gt {
	pc = 0x829EC358; continue 'dispatch;
	}
	// 829EC1B4: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 829EC1B8: 7F93E378  mr r19, r28
	ctx.r[19].u64 = ctx.r[28].u64;
	// 829EC1BC: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829EC1C0: 7F91E378  mr r17, r28
	ctx.r[17].u64 = ctx.r[28].u64;
	// 829EC1C4: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 829EC1C8: 38EAFFFF  addi r7, r10, -1
	ctx.r[7].s64 = ctx.r[10].s64 + -1;
	// 829EC1CC: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 829EC1D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EC1D4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EC1D8: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 829EC1DC: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 829EC1E0: 3B0B0B7C  addi r24, r11, 0xb7c
	ctx.r[24].s64 = ctx.r[11].s64 + 2940;
	// 829EC1E4: 3AEA0B7C  addi r23, r10, 0xb7c
	ctx.r[23].s64 = ctx.r[10].s64 + 2940;
	// 829EC1E8: 39C9A2F8  addi r14, r9, -0x5d08
	ctx.r[14].s64 = ctx.r[9].s64 + -23816;
	pc = 0x829EC1EC; continue 'dispatch;
            }
            0x829EC1EC => {
    //   block [0x829EC1EC..0x829EC238)
	// 829EC1EC: 396E0004  addi r11, r14, 4
	ctx.r[11].s64 = ctx.r[14].s64 + 4;
	// 829EC1F0: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 829EC1F4: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829EC1F8: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829EC1FC: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829EC200: 7CB3582E  lwzx r5, r19, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829EC204: 7D5A2E30  sraw r26, r10, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[26].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 829EC208: 7D2A2E30  sraw r10, r9, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> tmp.u32) as i64;
	// 829EC20C: 7CEB2E30  sraw r11, r7, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> tmp.u32) as i64;
	// 829EC210: 3ACB0001  addi r22, r11, 1
	ctx.r[22].s64 = ctx.r[11].s64 + 1;
	// 829EC214: 7CCB2E30  sraw r11, r6, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[6].s32 >> tmp.u32) as i64;
	// 829EC218: 7E1AB051  subf. r16, r26, r22
	ctx.r[16].s64 = ctx.r[22].s64 - ctx.r[26].s64;
	ctx.cr[0].compare_i32(ctx.r[16].s32, 0, &mut ctx.xer);
	// 829EC21C: 39EB0001  addi r15, r11, 1
	ctx.r[15].s64 = ctx.r[11].s64 + 1;
	// 829EC220: 4182011C  beq 0x829ec33c
	if ctx.cr[0].eq {
	pc = 0x829EC33C; continue 'dispatch;
	}
	// 829EC224: 7D6A7851  subf. r11, r10, r15
	ctx.r[11].s64 = ctx.r[15].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EC228: 41820114  beq 0x829ec33c
	if ctx.cr[0].eq {
	pc = 0x829EC33C; continue 'dispatch;
	}
	// 829EC22C: 7D545378  mr r20, r10
	ctx.r[20].u64 = ctx.r[10].u64;
	// 829EC230: 7F0A7800  cmpw cr6, r10, r15
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829EC234: 40980108  bge cr6, 0x829ec33c
	if !ctx.cr[6].lt {
	pc = 0x829EC33C; continue 'dispatch;
	}
	pc = 0x829EC238; continue 'dispatch;
            }
            0x829EC238 => {
    //   block [0x829EC238..0x829EC26C)
	// 829EC238: 81720008  lwz r11, 8(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EC23C: 7F1AB000  cmpw cr6, r26, r22
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[22].s32, &mut ctx.xer);
	// 829EC240: 81520018  lwz r10, 0x18(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24 as u32) ) } as u64;
	// 829EC244: 7D715A14  add r11, r17, r11
	ctx.r[11].u64 = ctx.r[17].u64 + ctx.r[11].u64;
	// 829EC248: 7D4A9A14  add r10, r10, r19
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[19].u64;
	// 829EC24C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC250: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC254: 7D69A1D6  mullw r11, r9, r20
	ctx.r[11].s32 = ((ctx.r[9].s32 as i64 * ctx.r[20].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 829EC258: 7D0BD214  add r8, r11, r26
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 829EC25C: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EC260: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829EC264: 409800C4  bge cr6, 0x829ec328
	if !ctx.cr[6].lt {
	pc = 0x829EC328; continue 'dispatch;
	}
	// 829EC268: 7E158378  mr r21, r16
	ctx.r[21].u64 = ctx.r[16].u64;
	pc = 0x829EC26C; continue 'dispatch;
            }
            0x829EC26C => {
    //   block [0x829EC26C..0x829EC278)
	// 829EC26C: 83B90000  lwz r29, 0(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC270: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829EC274: 419A00A8  beq cr6, 0x829ec31c
	if ctx.cr[6].eq {
	pc = 0x829EC31C; continue 'dispatch;
	}
	pc = 0x829EC278; continue 'dispatch;
            }
            0x829EC278 => {
    //   block [0x829EC278..0x829EC30C)
	// 829EC278: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC27C: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829EC280: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 829EC284: 4098008C  bge cr6, 0x829ec310
	if !ctx.cr[6].lt {
	pc = 0x829EC310; continue 'dispatch;
	}
	// 829EC288: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 829EC28C: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC290: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EC298: 4B817349  bl 0x822035e0
	ctx.lr = 0x829EC29C;
	sub_822035E0(ctx, base);
	// 829EC29C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EC2A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EC2A4: 419A0068  beq cr6, 0x829ec30c
	if ctx.cr[6].eq {
	pc = 0x829EC30C; continue 'dispatch;
	}
	// 829EC2A8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC2AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EC2B0: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EC2B4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC2B8: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 829EC2BC: 4B8850AD  bl 0x82271368
	ctx.lr = 0x829EC2C0;
	sub_82271368(ctx, base);
	// 829EC2C0: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EC2C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829EC2C8: 419A0044  beq cr6, 0x829ec30c
	if ctx.cr[6].eq {
	pc = 0x829EC30C; continue 'dispatch;
	}
	// 829EC2CC: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 829EC2D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EC2D4: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 829EC2D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EC2DC: 4B8285BD  bl 0x82214898
	ctx.lr = 0x829EC2E0;
	sub_82214898(ctx, base);
	// 829EC2E0: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EC2E4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829EC2E8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC2EC: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 829EC2F0: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 829EC2F4: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 829EC2F8: 4BA69E21  bl 0x82456118
	ctx.lr = 0x829EC2FC;
	sub_82456118(ctx, base);
	// 829EC2FC: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 829EC300: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EC304: 4B7A7B35  bl 0x82193e38
	ctx.lr = 0x829EC308;
	sub_82193E38(ctx, base);
	// 829EC308: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	pc = 0x829EC30C; continue 'dispatch;
            }
            0x829EC30C => {
    //   block [0x829EC30C..0x829EC310)
	// 829EC30C: 83FB6C10  lwz r31, 0x6c10(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	pc = 0x829EC310; continue 'dispatch;
            }
            0x829EC310 => {
    //   block [0x829EC310..0x829EC31C)
	// 829EC310: 83BD0004  lwz r29, 4(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC314: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829EC318: 409AFF60  bne cr6, 0x829ec278
	if !ctx.cr[6].eq {
	pc = 0x829EC278; continue 'dispatch;
	}
	pc = 0x829EC31C; continue 'dispatch;
            }
            0x829EC31C => {
    //   block [0x829EC31C..0x829EC328)
	// 829EC31C: 36B5FFFF  addic. r21, r21, -1
	ctx.xer.ca = (ctx.r[21].u32 > (!(-1 as u32)));
	ctx.r[21].s64 = ctx.r[21].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[21].s32, 0, &mut ctx.xer);
	// 829EC320: 3B390004  addi r25, r25, 4
	ctx.r[25].s64 = ctx.r[25].s64 + 4;
	// 829EC324: 4082FF48  bne 0x829ec26c
	if !ctx.cr[0].eq {
	pc = 0x829EC26C; continue 'dispatch;
	}
	pc = 0x829EC328; continue 'dispatch;
            }
            0x829EC328 => {
    //   block [0x829EC328..0x829EC33C)
	// 829EC328: 3A940001  addi r20, r20, 1
	ctx.r[20].s64 = ctx.r[20].s64 + 1;
	// 829EC32C: 7F147800  cmpw cr6, r20, r15
	ctx.cr[6].compare_i32(ctx.r[20].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829EC330: 4198FF08  blt cr6, 0x829ec238
	if ctx.cr[6].lt {
	pc = 0x829EC238; continue 'dispatch;
	}
	// 829EC334: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EC338: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	pc = 0x829EC33C; continue 'dispatch;
            }
            0x829EC33C => {
    //   block [0x829EC33C..0x829EC358)
	// 829EC33C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829EC340: 3A310014  addi r17, r17, 0x14
	ctx.r[17].s64 = ctx.r[17].s64 + 20;
	// 829EC344: 3A730010  addi r19, r19, 0x10
	ctx.r[19].s64 = ctx.r[19].s64 + 16;
	// 829EC348: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EC34C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829EC350: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 829EC354: 4198FE98  blt cr6, 0x829ec1ec
	if ctx.cr[6].lt {
	pc = 0x829EC1EC; continue 'dispatch;
	}
	pc = 0x829EC358; continue 'dispatch;
            }
            0x829EC358 => {
    //   block [0x829EC358..0x829EC360)
	// 829EC358: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 829EC35C: 482BD0C4  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EC360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EC360 size=516
    let mut pc: u32 = 0x829EC360;
    'dispatch: loop {
        match pc {
            0x829EC360 => {
    //   block [0x829EC360..0x829EC414)
	// 829EC360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EC364: 482BD06D  bl 0x82ca93d0
	ctx.lr = 0x829EC368;
	sub_82CA93D0(ctx, base);
	// 829EC368: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EC36C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC370: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829EC374: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 829EC378: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829EC37C: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 829EC380: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 829EC384: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC388: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 829EC38C: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 829EC390: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 829EC394: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EC398: 813B6C10  lwz r9, 0x6c10(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	// 829EC39C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829EC3A0: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 829EC3A4: 3BE90001  addi r31, r9, 1
	ctx.r[31].s64 = ctx.r[9].s64 + 1;
	// 829EC3A8: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 829EC3AC: 93FB6C10  stw r31, 0x6c10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(27664 as u32), ctx.r[31].u32 ) };
	// 829EC3B0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EC3B4: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC3B8: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 829EC3BC: 82490064  lwz r18, 0x64(r9)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 829EC3C0: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 829EC3C4: 4B879665  bl 0x82265a28
	ctx.lr = 0x829EC3C8;
	sub_82265A28(ctx, base);
	// 829EC3C8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EC3CC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829EC3D0: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 829EC3D4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 829EC3D8: 40990184  ble cr6, 0x829ec55c
	if !ctx.cr[6].gt {
	pc = 0x829EC55C; continue 'dispatch;
	}
	// 829EC3DC: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 829EC3E0: 7F93E378  mr r19, r28
	ctx.r[19].u64 = ctx.r[28].u64;
	// 829EC3E4: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829EC3E8: 7F91E378  mr r17, r28
	ctx.r[17].u64 = ctx.r[28].u64;
	// 829EC3EC: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 829EC3F0: 38EAFFFF  addi r7, r10, -1
	ctx.r[7].s64 = ctx.r[10].s64 + -1;
	// 829EC3F4: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 829EC3F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EC3FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EC400: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 829EC404: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 829EC408: 3B0B0B7C  addi r24, r11, 0xb7c
	ctx.r[24].s64 = ctx.r[11].s64 + 2940;
	// 829EC40C: 3AEA0B7C  addi r23, r10, 0xb7c
	ctx.r[23].s64 = ctx.r[10].s64 + 2940;
	// 829EC410: 39C9A2F8  addi r14, r9, -0x5d08
	ctx.r[14].s64 = ctx.r[9].s64 + -23816;
	pc = 0x829EC414; continue 'dispatch;
            }
            0x829EC414 => {
    //   block [0x829EC414..0x829EC460)
	// 829EC414: 396E0004  addi r11, r14, 4
	ctx.r[11].s64 = ctx.r[14].s64 + 4;
	// 829EC418: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 829EC41C: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829EC420: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829EC424: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829EC428: 7CB3582E  lwzx r5, r19, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829EC42C: 7D5A2E30  sraw r26, r10, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[26].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 829EC430: 7D2A2E30  sraw r10, r9, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> tmp.u32) as i64;
	// 829EC434: 7CEB2E30  sraw r11, r7, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> tmp.u32) as i64;
	// 829EC438: 3ACB0001  addi r22, r11, 1
	ctx.r[22].s64 = ctx.r[11].s64 + 1;
	// 829EC43C: 7CCB2E30  sraw r11, r6, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[6].s32 >> tmp.u32) as i64;
	// 829EC440: 7E1AB051  subf. r16, r26, r22
	ctx.r[16].s64 = ctx.r[22].s64 - ctx.r[26].s64;
	ctx.cr[0].compare_i32(ctx.r[16].s32, 0, &mut ctx.xer);
	// 829EC444: 39EB0001  addi r15, r11, 1
	ctx.r[15].s64 = ctx.r[11].s64 + 1;
	// 829EC448: 418200F8  beq 0x829ec540
	if ctx.cr[0].eq {
	pc = 0x829EC540; continue 'dispatch;
	}
	// 829EC44C: 7D6A7851  subf. r11, r10, r15
	ctx.r[11].s64 = ctx.r[15].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EC450: 418200F0  beq 0x829ec540
	if ctx.cr[0].eq {
	pc = 0x829EC540; continue 'dispatch;
	}
	// 829EC454: 7D545378  mr r20, r10
	ctx.r[20].u64 = ctx.r[10].u64;
	// 829EC458: 7F0A7800  cmpw cr6, r10, r15
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829EC45C: 409800E4  bge cr6, 0x829ec540
	if !ctx.cr[6].lt {
	pc = 0x829EC540; continue 'dispatch;
	}
	pc = 0x829EC460; continue 'dispatch;
            }
            0x829EC460 => {
    //   block [0x829EC460..0x829EC494)
	// 829EC460: 81520008  lwz r10, 8(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EC464: 7F1AB000  cmpw cr6, r26, r22
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[22].s32, &mut ctx.xer);
	// 829EC468: 81720018  lwz r11, 0x18(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24 as u32) ) } as u64;
	// 829EC46C: 7D515214  add r10, r17, r10
	ctx.r[10].u64 = ctx.r[17].u64 + ctx.r[10].u64;
	// 829EC470: 7D2B9A14  add r9, r11, r19
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[19].u64;
	// 829EC474: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC478: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC47C: 7D68A1D6  mullw r11, r8, r20
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * ctx.r[20].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 829EC480: 7CEBD214  add r7, r11, r26
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 829EC484: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EC488: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829EC48C: 409800A0  bge cr6, 0x829ec52c
	if !ctx.cr[6].lt {
	pc = 0x829EC52C; continue 'dispatch;
	}
	// 829EC490: 7E158378  mr r21, r16
	ctx.r[21].u64 = ctx.r[16].u64;
	pc = 0x829EC494; continue 'dispatch;
            }
            0x829EC494 => {
    //   block [0x829EC494..0x829EC4A0)
	// 829EC494: 83B90000  lwz r29, 0(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC498: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829EC49C: 419A0084  beq cr6, 0x829ec520
	if ctx.cr[6].eq {
	pc = 0x829EC520; continue 'dispatch;
	}
	pc = 0x829EC4A0; continue 'dispatch;
            }
            0x829EC4A0 => {
    //   block [0x829EC4A0..0x829EC510)
	// 829EC4A0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC4A4: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829EC4A8: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 829EC4AC: 40980068  bge cr6, 0x829ec514
	if !ctx.cr[6].lt {
	pc = 0x829EC514; continue 'dispatch;
	}
	// 829EC4B0: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 829EC4B4: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC4B8: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC4BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EC4C0: 4B817121  bl 0x822035e0
	ctx.lr = 0x829EC4C4;
	sub_822035E0(ctx, base);
	// 829EC4C4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EC4C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EC4CC: 419A0044  beq cr6, 0x829ec510
	if ctx.cr[6].eq {
	pc = 0x829EC510; continue 'dispatch;
	}
	// 829EC4D0: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 829EC4D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EC4D8: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 829EC4DC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EC4E0: 4B8283B9  bl 0x82214898
	ctx.lr = 0x829EC4E4;
	sub_82214898(ctx, base);
	// 829EC4E4: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EC4E8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829EC4EC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC4F0: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 829EC4F4: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 829EC4F8: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 829EC4FC: 4BA69C1D  bl 0x82456118
	ctx.lr = 0x829EC500;
	sub_82456118(ctx, base);
	// 829EC500: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 829EC504: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EC508: 4B7A7931  bl 0x82193e38
	ctx.lr = 0x829EC50C;
	sub_82193E38(ctx, base);
	// 829EC50C: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	pc = 0x829EC510; continue 'dispatch;
            }
            0x829EC510 => {
    //   block [0x829EC510..0x829EC514)
	// 829EC510: 83FB6C10  lwz r31, 0x6c10(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	pc = 0x829EC514; continue 'dispatch;
            }
            0x829EC514 => {
    //   block [0x829EC514..0x829EC520)
	// 829EC514: 83BD0004  lwz r29, 4(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC518: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829EC51C: 409AFF84  bne cr6, 0x829ec4a0
	if !ctx.cr[6].eq {
	pc = 0x829EC4A0; continue 'dispatch;
	}
	pc = 0x829EC520; continue 'dispatch;
            }
            0x829EC520 => {
    //   block [0x829EC520..0x829EC52C)
	// 829EC520: 36B5FFFF  addic. r21, r21, -1
	ctx.xer.ca = (ctx.r[21].u32 > (!(-1 as u32)));
	ctx.r[21].s64 = ctx.r[21].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[21].s32, 0, &mut ctx.xer);
	// 829EC524: 3B390004  addi r25, r25, 4
	ctx.r[25].s64 = ctx.r[25].s64 + 4;
	// 829EC528: 4082FF6C  bne 0x829ec494
	if !ctx.cr[0].eq {
	pc = 0x829EC494; continue 'dispatch;
	}
	pc = 0x829EC52C; continue 'dispatch;
            }
            0x829EC52C => {
    //   block [0x829EC52C..0x829EC540)
	// 829EC52C: 3A940001  addi r20, r20, 1
	ctx.r[20].s64 = ctx.r[20].s64 + 1;
	// 829EC530: 7F147800  cmpw cr6, r20, r15
	ctx.cr[6].compare_i32(ctx.r[20].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829EC534: 4198FF2C  blt cr6, 0x829ec460
	if ctx.cr[6].lt {
	pc = 0x829EC460; continue 'dispatch;
	}
	// 829EC538: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EC53C: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	pc = 0x829EC540; continue 'dispatch;
            }
            0x829EC540 => {
    //   block [0x829EC540..0x829EC55C)
	// 829EC540: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829EC544: 3A310014  addi r17, r17, 0x14
	ctx.r[17].s64 = ctx.r[17].s64 + 20;
	// 829EC548: 3A730010  addi r19, r19, 0x10
	ctx.r[19].s64 = ctx.r[19].s64 + 16;
	// 829EC54C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EC550: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829EC554: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 829EC558: 4198FEBC  blt cr6, 0x829ec414
	if ctx.cr[6].lt {
	pc = 0x829EC414; continue 'dispatch;
	}
	pc = 0x829EC55C; continue 'dispatch;
            }
            0x829EC55C => {
    //   block [0x829EC55C..0x829EC564)
	// 829EC55C: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 829EC560: 482BCEC0  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EC568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EC568 size=532
    let mut pc: u32 = 0x829EC568;
    'dispatch: loop {
        match pc {
            0x829EC568 => {
    //   block [0x829EC568..0x829EC61C)
	// 829EC568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EC56C: 482BCE65  bl 0x82ca93d0
	ctx.lr = 0x829EC570;
	sub_82CA93D0(ctx, base);
	// 829EC570: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EC574: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC578: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829EC57C: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 829EC580: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829EC584: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 829EC588: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 829EC58C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC590: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 829EC594: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 829EC598: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 829EC59C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EC5A0: 813B6C10  lwz r9, 0x6c10(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	// 829EC5A4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829EC5A8: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 829EC5AC: 3BE90001  addi r31, r9, 1
	ctx.r[31].s64 = ctx.r[9].s64 + 1;
	// 829EC5B0: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 829EC5B4: 93FB6C10  stw r31, 0x6c10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(27664 as u32), ctx.r[31].u32 ) };
	// 829EC5B8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EC5BC: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC5C0: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 829EC5C4: 82490064  lwz r18, 0x64(r9)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 829EC5C8: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 829EC5CC: 4B87945D  bl 0x82265a28
	ctx.lr = 0x829EC5D0;
	sub_82265A28(ctx, base);
	// 829EC5D0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EC5D4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829EC5D8: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 829EC5DC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 829EC5E0: 40990194  ble cr6, 0x829ec774
	if !ctx.cr[6].gt {
	pc = 0x829EC774; continue 'dispatch;
	}
	// 829EC5E4: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 829EC5E8: 7F93E378  mr r19, r28
	ctx.r[19].u64 = ctx.r[28].u64;
	// 829EC5EC: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829EC5F0: 7F91E378  mr r17, r28
	ctx.r[17].u64 = ctx.r[28].u64;
	// 829EC5F4: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 829EC5F8: 38EAFFFF  addi r7, r10, -1
	ctx.r[7].s64 = ctx.r[10].s64 + -1;
	// 829EC5FC: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 829EC600: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EC604: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EC608: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 829EC60C: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 829EC610: 3B0B0B7C  addi r24, r11, 0xb7c
	ctx.r[24].s64 = ctx.r[11].s64 + 2940;
	// 829EC614: 3AEA0B7C  addi r23, r10, 0xb7c
	ctx.r[23].s64 = ctx.r[10].s64 + 2940;
	// 829EC618: 39C9A2F8  addi r14, r9, -0x5d08
	ctx.r[14].s64 = ctx.r[9].s64 + -23816;
	pc = 0x829EC61C; continue 'dispatch;
            }
            0x829EC61C => {
    //   block [0x829EC61C..0x829EC668)
	// 829EC61C: 396E0004  addi r11, r14, 4
	ctx.r[11].s64 = ctx.r[14].s64 + 4;
	// 829EC620: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 829EC624: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829EC628: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829EC62C: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829EC630: 7CB3582E  lwzx r5, r19, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829EC634: 7D5A2E30  sraw r26, r10, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[26].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 829EC638: 7D2A2E30  sraw r10, r9, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> tmp.u32) as i64;
	// 829EC63C: 7CEB2E30  sraw r11, r7, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> tmp.u32) as i64;
	// 829EC640: 3ACB0001  addi r22, r11, 1
	ctx.r[22].s64 = ctx.r[11].s64 + 1;
	// 829EC644: 7CCB2E30  sraw r11, r6, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[6].s32 >> tmp.u32) as i64;
	// 829EC648: 7E1AB051  subf. r16, r26, r22
	ctx.r[16].s64 = ctx.r[22].s64 - ctx.r[26].s64;
	ctx.cr[0].compare_i32(ctx.r[16].s32, 0, &mut ctx.xer);
	// 829EC64C: 39EB0001  addi r15, r11, 1
	ctx.r[15].s64 = ctx.r[11].s64 + 1;
	// 829EC650: 41820108  beq 0x829ec758
	if ctx.cr[0].eq {
	pc = 0x829EC758; continue 'dispatch;
	}
	// 829EC654: 7D6A7851  subf. r11, r10, r15
	ctx.r[11].s64 = ctx.r[15].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EC658: 41820100  beq 0x829ec758
	if ctx.cr[0].eq {
	pc = 0x829EC758; continue 'dispatch;
	}
	// 829EC65C: 7D545378  mr r20, r10
	ctx.r[20].u64 = ctx.r[10].u64;
	// 829EC660: 7F0A7800  cmpw cr6, r10, r15
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829EC664: 409800F4  bge cr6, 0x829ec758
	if !ctx.cr[6].lt {
	pc = 0x829EC758; continue 'dispatch;
	}
	pc = 0x829EC668; continue 'dispatch;
            }
            0x829EC668 => {
    //   block [0x829EC668..0x829EC69C)
	// 829EC668: 81520008  lwz r10, 8(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EC66C: 7F1AB000  cmpw cr6, r26, r22
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[22].s32, &mut ctx.xer);
	// 829EC670: 81720018  lwz r11, 0x18(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24 as u32) ) } as u64;
	// 829EC674: 7D515214  add r10, r17, r10
	ctx.r[10].u64 = ctx.r[17].u64 + ctx.r[10].u64;
	// 829EC678: 7D2B9A14  add r9, r11, r19
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[19].u64;
	// 829EC67C: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC680: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC684: 7D68A1D6  mullw r11, r8, r20
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * ctx.r[20].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 829EC688: 7CEBD214  add r7, r11, r26
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 829EC68C: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EC690: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829EC694: 409800B0  bge cr6, 0x829ec744
	if !ctx.cr[6].lt {
	pc = 0x829EC744; continue 'dispatch;
	}
	// 829EC698: 7E158378  mr r21, r16
	ctx.r[21].u64 = ctx.r[16].u64;
	pc = 0x829EC69C; continue 'dispatch;
            }
            0x829EC69C => {
    //   block [0x829EC69C..0x829EC6A8)
	// 829EC69C: 83B90000  lwz r29, 0(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC6A0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829EC6A4: 419A0094  beq cr6, 0x829ec738
	if ctx.cr[6].eq {
	pc = 0x829EC738; continue 'dispatch;
	}
	pc = 0x829EC6A8; continue 'dispatch;
            }
            0x829EC6A8 => {
    //   block [0x829EC6A8..0x829EC728)
	// 829EC6A8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC6AC: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829EC6B0: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 829EC6B4: 40980078  bge cr6, 0x829ec72c
	if !ctx.cr[6].lt {
	pc = 0x829EC72C; continue 'dispatch;
	}
	// 829EC6B8: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 829EC6BC: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC6C0: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC6C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EC6C8: 4B816F19  bl 0x822035e0
	ctx.lr = 0x829EC6CC;
	sub_822035E0(ctx, base);
	// 829EC6CC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EC6D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EC6D4: 419A0054  beq cr6, 0x829ec728
	if ctx.cr[6].eq {
	pc = 0x829EC728; continue 'dispatch;
	}
	// 829EC6D8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC6DC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC6E0: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829EC6E4: 419A0044  beq cr6, 0x829ec728
	if ctx.cr[6].eq {
	pc = 0x829EC728; continue 'dispatch;
	}
	// 829EC6E8: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 829EC6EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EC6F0: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 829EC6F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EC6F8: 4B8281A1  bl 0x82214898
	ctx.lr = 0x829EC6FC;
	sub_82214898(ctx, base);
	// 829EC6FC: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EC700: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829EC704: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC708: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 829EC70C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 829EC710: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 829EC714: 4BA69A05  bl 0x82456118
	ctx.lr = 0x829EC718;
	sub_82456118(ctx, base);
	// 829EC718: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 829EC71C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EC720: 4B7A7719  bl 0x82193e38
	ctx.lr = 0x829EC724;
	sub_82193E38(ctx, base);
	// 829EC724: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	pc = 0x829EC728; continue 'dispatch;
            }
            0x829EC728 => {
    //   block [0x829EC728..0x829EC72C)
	// 829EC728: 83FB6C10  lwz r31, 0x6c10(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	pc = 0x829EC72C; continue 'dispatch;
            }
            0x829EC72C => {
    //   block [0x829EC72C..0x829EC738)
	// 829EC72C: 83BD0004  lwz r29, 4(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC730: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829EC734: 409AFF74  bne cr6, 0x829ec6a8
	if !ctx.cr[6].eq {
	pc = 0x829EC6A8; continue 'dispatch;
	}
	pc = 0x829EC738; continue 'dispatch;
            }
            0x829EC738 => {
    //   block [0x829EC738..0x829EC744)
	// 829EC738: 36B5FFFF  addic. r21, r21, -1
	ctx.xer.ca = (ctx.r[21].u32 > (!(-1 as u32)));
	ctx.r[21].s64 = ctx.r[21].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[21].s32, 0, &mut ctx.xer);
	// 829EC73C: 3B390004  addi r25, r25, 4
	ctx.r[25].s64 = ctx.r[25].s64 + 4;
	// 829EC740: 4082FF5C  bne 0x829ec69c
	if !ctx.cr[0].eq {
	pc = 0x829EC69C; continue 'dispatch;
	}
	pc = 0x829EC744; continue 'dispatch;
            }
            0x829EC744 => {
    //   block [0x829EC744..0x829EC758)
	// 829EC744: 3A940001  addi r20, r20, 1
	ctx.r[20].s64 = ctx.r[20].s64 + 1;
	// 829EC748: 7F147800  cmpw cr6, r20, r15
	ctx.cr[6].compare_i32(ctx.r[20].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829EC74C: 4198FF1C  blt cr6, 0x829ec668
	if ctx.cr[6].lt {
	pc = 0x829EC668; continue 'dispatch;
	}
	// 829EC750: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EC754: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	pc = 0x829EC758; continue 'dispatch;
            }
            0x829EC758 => {
    //   block [0x829EC758..0x829EC774)
	// 829EC758: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829EC75C: 3A310014  addi r17, r17, 0x14
	ctx.r[17].s64 = ctx.r[17].s64 + 20;
	// 829EC760: 3A730010  addi r19, r19, 0x10
	ctx.r[19].s64 = ctx.r[19].s64 + 16;
	// 829EC764: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EC768: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829EC76C: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 829EC770: 4198FEAC  blt cr6, 0x829ec61c
	if ctx.cr[6].lt {
	pc = 0x829EC61C; continue 'dispatch;
	}
	pc = 0x829EC774; continue 'dispatch;
            }
            0x829EC774 => {
    //   block [0x829EC774..0x829EC77C)
	// 829EC774: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 829EC778: 482BCCA8  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EC780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EC780 size=536
    let mut pc: u32 = 0x829EC780;
    'dispatch: loop {
        match pc {
            0x829EC780 => {
    //   block [0x829EC780..0x829EC834)
	// 829EC780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EC784: 482BCC4D  bl 0x82ca93d0
	ctx.lr = 0x829EC788;
	sub_82CA93D0(ctx, base);
	// 829EC788: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EC78C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC790: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829EC794: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 829EC798: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829EC79C: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 829EC7A0: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 829EC7A4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC7A8: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 829EC7AC: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 829EC7B0: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 829EC7B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EC7B8: 813B6C10  lwz r9, 0x6c10(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	// 829EC7BC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829EC7C0: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 829EC7C4: 3BE90001  addi r31, r9, 1
	ctx.r[31].s64 = ctx.r[9].s64 + 1;
	// 829EC7C8: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 829EC7CC: 93FB6C10  stw r31, 0x6c10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(27664 as u32), ctx.r[31].u32 ) };
	// 829EC7D0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EC7D4: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC7D8: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 829EC7DC: 82490064  lwz r18, 0x64(r9)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 829EC7E0: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 829EC7E4: 4B879245  bl 0x82265a28
	ctx.lr = 0x829EC7E8;
	sub_82265A28(ctx, base);
	// 829EC7E8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EC7EC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829EC7F0: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 829EC7F4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 829EC7F8: 40990198  ble cr6, 0x829ec990
	if !ctx.cr[6].gt {
	pc = 0x829EC990; continue 'dispatch;
	}
	// 829EC7FC: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 829EC800: 7F93E378  mr r19, r28
	ctx.r[19].u64 = ctx.r[28].u64;
	// 829EC804: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829EC808: 7F91E378  mr r17, r28
	ctx.r[17].u64 = ctx.r[28].u64;
	// 829EC80C: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 829EC810: 38EAFFFF  addi r7, r10, -1
	ctx.r[7].s64 = ctx.r[10].s64 + -1;
	// 829EC814: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 829EC818: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EC81C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EC820: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 829EC824: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 829EC828: 3B0B0B7C  addi r24, r11, 0xb7c
	ctx.r[24].s64 = ctx.r[11].s64 + 2940;
	// 829EC82C: 3AEA0B7C  addi r23, r10, 0xb7c
	ctx.r[23].s64 = ctx.r[10].s64 + 2940;
	// 829EC830: 39C9A2F8  addi r14, r9, -0x5d08
	ctx.r[14].s64 = ctx.r[9].s64 + -23816;
	pc = 0x829EC834; continue 'dispatch;
            }
            0x829EC834 => {
    //   block [0x829EC834..0x829EC880)
	// 829EC834: 396E0004  addi r11, r14, 4
	ctx.r[11].s64 = ctx.r[14].s64 + 4;
	// 829EC838: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 829EC83C: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829EC840: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829EC844: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829EC848: 7CB3582E  lwzx r5, r19, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829EC84C: 7D5A2E30  sraw r26, r10, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[26].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 829EC850: 7D2A2E30  sraw r10, r9, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> tmp.u32) as i64;
	// 829EC854: 7CEB2E30  sraw r11, r7, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> tmp.u32) as i64;
	// 829EC858: 3ACB0001  addi r22, r11, 1
	ctx.r[22].s64 = ctx.r[11].s64 + 1;
	// 829EC85C: 7CCB2E30  sraw r11, r6, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[6].s32 >> tmp.u32) as i64;
	// 829EC860: 7E1AB051  subf. r16, r26, r22
	ctx.r[16].s64 = ctx.r[22].s64 - ctx.r[26].s64;
	ctx.cr[0].compare_i32(ctx.r[16].s32, 0, &mut ctx.xer);
	// 829EC864: 39EB0001  addi r15, r11, 1
	ctx.r[15].s64 = ctx.r[11].s64 + 1;
	// 829EC868: 4182010C  beq 0x829ec974
	if ctx.cr[0].eq {
	pc = 0x829EC974; continue 'dispatch;
	}
	// 829EC86C: 7D6A7851  subf. r11, r10, r15
	ctx.r[11].s64 = ctx.r[15].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EC870: 41820104  beq 0x829ec974
	if ctx.cr[0].eq {
	pc = 0x829EC974; continue 'dispatch;
	}
	// 829EC874: 7D545378  mr r20, r10
	ctx.r[20].u64 = ctx.r[10].u64;
	// 829EC878: 7F0A7800  cmpw cr6, r10, r15
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829EC87C: 409800F8  bge cr6, 0x829ec974
	if !ctx.cr[6].lt {
	pc = 0x829EC974; continue 'dispatch;
	}
	pc = 0x829EC880; continue 'dispatch;
            }
            0x829EC880 => {
    //   block [0x829EC880..0x829EC8B4)
	// 829EC880: 81520008  lwz r10, 8(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EC884: 7F1AB000  cmpw cr6, r26, r22
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[22].s32, &mut ctx.xer);
	// 829EC888: 81720018  lwz r11, 0x18(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24 as u32) ) } as u64;
	// 829EC88C: 7D515214  add r10, r17, r10
	ctx.r[10].u64 = ctx.r[17].u64 + ctx.r[10].u64;
	// 829EC890: 7D2B9A14  add r9, r11, r19
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[19].u64;
	// 829EC894: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC898: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC89C: 7D68A1D6  mullw r11, r8, r20
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * ctx.r[20].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 829EC8A0: 7CEBD214  add r7, r11, r26
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 829EC8A4: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EC8A8: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829EC8AC: 409800B4  bge cr6, 0x829ec960
	if !ctx.cr[6].lt {
	pc = 0x829EC960; continue 'dispatch;
	}
	// 829EC8B0: 7E158378  mr r21, r16
	ctx.r[21].u64 = ctx.r[16].u64;
	pc = 0x829EC8B4; continue 'dispatch;
            }
            0x829EC8B4 => {
    //   block [0x829EC8B4..0x829EC8C0)
	// 829EC8B4: 83B90000  lwz r29, 0(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC8B8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829EC8BC: 419A0098  beq cr6, 0x829ec954
	if ctx.cr[6].eq {
	pc = 0x829EC954; continue 'dispatch;
	}
	pc = 0x829EC8C0; continue 'dispatch;
            }
            0x829EC8C0 => {
    //   block [0x829EC8C0..0x829EC944)
	// 829EC8C0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC8C4: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829EC8C8: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 829EC8CC: 4098007C  bge cr6, 0x829ec948
	if !ctx.cr[6].lt {
	pc = 0x829EC948; continue 'dispatch;
	}
	// 829EC8D0: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 829EC8D4: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC8D8: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC8DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EC8E0: 4B816D01  bl 0x822035e0
	ctx.lr = 0x829EC8E4;
	sub_822035E0(ctx, base);
	// 829EC8E4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EC8E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EC8EC: 419A0058  beq cr6, 0x829ec944
	if ctx.cr[6].eq {
	pc = 0x829EC944; continue 'dispatch;
	}
	// 829EC8F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EC8F4: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC8F8: 4BB247D1  bl 0x825110c8
	ctx.lr = 0x829EC8FC;
	sub_825110C8(ctx, base);
	// 829EC8FC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EC900: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EC904: 419A0040  beq cr6, 0x829ec944
	if ctx.cr[6].eq {
	pc = 0x829EC944; continue 'dispatch;
	}
	// 829EC908: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 829EC90C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EC910: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 829EC914: 4B827F85  bl 0x82214898
	ctx.lr = 0x829EC918;
	sub_82214898(ctx, base);
	// 829EC918: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EC91C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829EC920: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC924: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 829EC928: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 829EC92C: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 829EC930: 4BA697E9  bl 0x82456118
	ctx.lr = 0x829EC934;
	sub_82456118(ctx, base);
	// 829EC934: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 829EC938: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EC93C: 4B7A74FD  bl 0x82193e38
	ctx.lr = 0x829EC940;
	sub_82193E38(ctx, base);
	// 829EC940: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	pc = 0x829EC944; continue 'dispatch;
            }
            0x829EC944 => {
    //   block [0x829EC944..0x829EC948)
	// 829EC944: 83FB6C10  lwz r31, 0x6c10(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	pc = 0x829EC948; continue 'dispatch;
            }
            0x829EC948 => {
    //   block [0x829EC948..0x829EC954)
	// 829EC948: 83BD0004  lwz r29, 4(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC94C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829EC950: 409AFF70  bne cr6, 0x829ec8c0
	if !ctx.cr[6].eq {
	pc = 0x829EC8C0; continue 'dispatch;
	}
	pc = 0x829EC954; continue 'dispatch;
            }
            0x829EC954 => {
    //   block [0x829EC954..0x829EC960)
	// 829EC954: 36B5FFFF  addic. r21, r21, -1
	ctx.xer.ca = (ctx.r[21].u32 > (!(-1 as u32)));
	ctx.r[21].s64 = ctx.r[21].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[21].s32, 0, &mut ctx.xer);
	// 829EC958: 3B390004  addi r25, r25, 4
	ctx.r[25].s64 = ctx.r[25].s64 + 4;
	// 829EC95C: 4082FF58  bne 0x829ec8b4
	if !ctx.cr[0].eq {
	pc = 0x829EC8B4; continue 'dispatch;
	}
	pc = 0x829EC960; continue 'dispatch;
            }
            0x829EC960 => {
    //   block [0x829EC960..0x829EC974)
	// 829EC960: 3A940001  addi r20, r20, 1
	ctx.r[20].s64 = ctx.r[20].s64 + 1;
	// 829EC964: 7F147800  cmpw cr6, r20, r15
	ctx.cr[6].compare_i32(ctx.r[20].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829EC968: 4198FF18  blt cr6, 0x829ec880
	if ctx.cr[6].lt {
	pc = 0x829EC880; continue 'dispatch;
	}
	// 829EC96C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EC970: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	pc = 0x829EC974; continue 'dispatch;
            }
            0x829EC974 => {
    //   block [0x829EC974..0x829EC990)
	// 829EC974: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829EC978: 3A310014  addi r17, r17, 0x14
	ctx.r[17].s64 = ctx.r[17].s64 + 20;
	// 829EC97C: 3A730010  addi r19, r19, 0x10
	ctx.r[19].s64 = ctx.r[19].s64 + 16;
	// 829EC980: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EC984: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829EC988: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 829EC98C: 4198FEA8  blt cr6, 0x829ec834
	if ctx.cr[6].lt {
	pc = 0x829EC834; continue 'dispatch;
	}
	pc = 0x829EC990; continue 'dispatch;
            }
            0x829EC990 => {
    //   block [0x829EC990..0x829EC998)
	// 829EC990: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 829EC994: 482BCA8C  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EC998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EC998 size=536
    let mut pc: u32 = 0x829EC998;
    'dispatch: loop {
        match pc {
            0x829EC998 => {
    //   block [0x829EC998..0x829ECA4C)
	// 829EC998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EC99C: 482BCA35  bl 0x82ca93d0
	ctx.lr = 0x829EC9A0;
	sub_82CA93D0(ctx, base);
	// 829EC9A0: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EC9A4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC9A8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829EC9AC: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 829EC9B0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829EC9B4: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 829EC9B8: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 829EC9BC: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC9C0: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 829EC9C4: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 829EC9C8: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 829EC9CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EC9D0: 813B6C10  lwz r9, 0x6c10(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	// 829EC9D4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829EC9D8: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 829EC9DC: 3BE90001  addi r31, r9, 1
	ctx.r[31].s64 = ctx.r[9].s64 + 1;
	// 829EC9E0: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 829EC9E4: 93FB6C10  stw r31, 0x6c10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(27664 as u32), ctx.r[31].u32 ) };
	// 829EC9E8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EC9EC: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EC9F0: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 829EC9F4: 82490064  lwz r18, 0x64(r9)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 829EC9F8: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 829EC9FC: 4B87902D  bl 0x82265a28
	ctx.lr = 0x829ECA00;
	sub_82265A28(ctx, base);
	// 829ECA00: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829ECA04: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829ECA08: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 829ECA0C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 829ECA10: 40990198  ble cr6, 0x829ecba8
	if !ctx.cr[6].gt {
	pc = 0x829ECBA8; continue 'dispatch;
	}
	// 829ECA14: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 829ECA18: 7F93E378  mr r19, r28
	ctx.r[19].u64 = ctx.r[28].u64;
	// 829ECA1C: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829ECA20: 7F91E378  mr r17, r28
	ctx.r[17].u64 = ctx.r[28].u64;
	// 829ECA24: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 829ECA28: 38EAFFFF  addi r7, r10, -1
	ctx.r[7].s64 = ctx.r[10].s64 + -1;
	// 829ECA2C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 829ECA30: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829ECA34: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829ECA38: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 829ECA3C: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 829ECA40: 3B0B0B7C  addi r24, r11, 0xb7c
	ctx.r[24].s64 = ctx.r[11].s64 + 2940;
	// 829ECA44: 3AEA0B7C  addi r23, r10, 0xb7c
	ctx.r[23].s64 = ctx.r[10].s64 + 2940;
	// 829ECA48: 39C9A2F8  addi r14, r9, -0x5d08
	ctx.r[14].s64 = ctx.r[9].s64 + -23816;
	pc = 0x829ECA4C; continue 'dispatch;
            }
            0x829ECA4C => {
    //   block [0x829ECA4C..0x829ECA98)
	// 829ECA4C: 396E0004  addi r11, r14, 4
	ctx.r[11].s64 = ctx.r[14].s64 + 4;
	// 829ECA50: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 829ECA54: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829ECA58: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829ECA5C: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829ECA60: 7CB3582E  lwzx r5, r19, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829ECA64: 7D5A2E30  sraw r26, r10, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[26].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 829ECA68: 7D2A2E30  sraw r10, r9, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> tmp.u32) as i64;
	// 829ECA6C: 7CEB2E30  sraw r11, r7, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> tmp.u32) as i64;
	// 829ECA70: 3ACB0001  addi r22, r11, 1
	ctx.r[22].s64 = ctx.r[11].s64 + 1;
	// 829ECA74: 7CCB2E30  sraw r11, r6, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[6].s32 >> tmp.u32) as i64;
	// 829ECA78: 7E1AB051  subf. r16, r26, r22
	ctx.r[16].s64 = ctx.r[22].s64 - ctx.r[26].s64;
	ctx.cr[0].compare_i32(ctx.r[16].s32, 0, &mut ctx.xer);
	// 829ECA7C: 39EB0001  addi r15, r11, 1
	ctx.r[15].s64 = ctx.r[11].s64 + 1;
	// 829ECA80: 4182010C  beq 0x829ecb8c
	if ctx.cr[0].eq {
	pc = 0x829ECB8C; continue 'dispatch;
	}
	// 829ECA84: 7D6A7851  subf. r11, r10, r15
	ctx.r[11].s64 = ctx.r[15].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829ECA88: 41820104  beq 0x829ecb8c
	if ctx.cr[0].eq {
	pc = 0x829ECB8C; continue 'dispatch;
	}
	// 829ECA8C: 7D545378  mr r20, r10
	ctx.r[20].u64 = ctx.r[10].u64;
	// 829ECA90: 7F0A7800  cmpw cr6, r10, r15
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829ECA94: 409800F8  bge cr6, 0x829ecb8c
	if !ctx.cr[6].lt {
	pc = 0x829ECB8C; continue 'dispatch;
	}
	pc = 0x829ECA98; continue 'dispatch;
            }
            0x829ECA98 => {
    //   block [0x829ECA98..0x829ECACC)
	// 829ECA98: 81520008  lwz r10, 8(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) } as u64;
	// 829ECA9C: 7F1AB000  cmpw cr6, r26, r22
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[22].s32, &mut ctx.xer);
	// 829ECAA0: 81720018  lwz r11, 0x18(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24 as u32) ) } as u64;
	// 829ECAA4: 7D515214  add r10, r17, r10
	ctx.r[10].u64 = ctx.r[17].u64 + ctx.r[10].u64;
	// 829ECAA8: 7D2B9A14  add r9, r11, r19
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[19].u64;
	// 829ECAAC: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ECAB0: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ECAB4: 7D68A1D6  mullw r11, r8, r20
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * ctx.r[20].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 829ECAB8: 7CEBD214  add r7, r11, r26
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 829ECABC: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829ECAC0: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829ECAC4: 409800B4  bge cr6, 0x829ecb78
	if !ctx.cr[6].lt {
	pc = 0x829ECB78; continue 'dispatch;
	}
	// 829ECAC8: 7E158378  mr r21, r16
	ctx.r[21].u64 = ctx.r[16].u64;
	pc = 0x829ECACC; continue 'dispatch;
            }
            0x829ECACC => {
    //   block [0x829ECACC..0x829ECAD8)
	// 829ECACC: 83B90000  lwz r29, 0(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829ECAD0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829ECAD4: 419A0098  beq cr6, 0x829ecb6c
	if ctx.cr[6].eq {
	pc = 0x829ECB6C; continue 'dispatch;
	}
	pc = 0x829ECAD8; continue 'dispatch;
            }
            0x829ECAD8 => {
    //   block [0x829ECAD8..0x829ECB5C)
	// 829ECAD8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829ECADC: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829ECAE0: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 829ECAE4: 4098007C  bge cr6, 0x829ecb60
	if !ctx.cr[6].lt {
	pc = 0x829ECB60; continue 'dispatch;
	}
	// 829ECAE8: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 829ECAEC: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ECAF0: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829ECAF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829ECAF8: 4B816AE9  bl 0x822035e0
	ctx.lr = 0x829ECAFC;
	sub_822035E0(ctx, base);
	// 829ECAFC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829ECB00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829ECB04: 419A0058  beq cr6, 0x829ecb5c
	if ctx.cr[6].eq {
	pc = 0x829ECB5C; continue 'dispatch;
	}
	// 829ECB08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829ECB0C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ECB10: 4BB23BE1  bl 0x825106f0
	ctx.lr = 0x829ECB14;
	sub_825106F0(ctx, base);
	// 829ECB14: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829ECB18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829ECB1C: 419A0040  beq cr6, 0x829ecb5c
	if ctx.cr[6].eq {
	pc = 0x829ECB5C; continue 'dispatch;
	}
	// 829ECB20: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 829ECB24: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829ECB28: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 829ECB2C: 4B827D6D  bl 0x82214898
	ctx.lr = 0x829ECB30;
	sub_82214898(ctx, base);
	// 829ECB30: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829ECB34: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829ECB38: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ECB3C: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 829ECB40: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 829ECB44: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 829ECB48: 4BA695D1  bl 0x82456118
	ctx.lr = 0x829ECB4C;
	sub_82456118(ctx, base);
	// 829ECB4C: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 829ECB50: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829ECB54: 4B7A72E5  bl 0x82193e38
	ctx.lr = 0x829ECB58;
	sub_82193E38(ctx, base);
	// 829ECB58: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	pc = 0x829ECB5C; continue 'dispatch;
            }
            0x829ECB5C => {
    //   block [0x829ECB5C..0x829ECB60)
	// 829ECB5C: 83FB6C10  lwz r31, 0x6c10(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	pc = 0x829ECB60; continue 'dispatch;
            }
            0x829ECB60 => {
    //   block [0x829ECB60..0x829ECB6C)
	// 829ECB60: 83BD0004  lwz r29, 4(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ECB64: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829ECB68: 409AFF70  bne cr6, 0x829ecad8
	if !ctx.cr[6].eq {
	pc = 0x829ECAD8; continue 'dispatch;
	}
	pc = 0x829ECB6C; continue 'dispatch;
            }
            0x829ECB6C => {
    //   block [0x829ECB6C..0x829ECB78)
	// 829ECB6C: 36B5FFFF  addic. r21, r21, -1
	ctx.xer.ca = (ctx.r[21].u32 > (!(-1 as u32)));
	ctx.r[21].s64 = ctx.r[21].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[21].s32, 0, &mut ctx.xer);
	// 829ECB70: 3B390004  addi r25, r25, 4
	ctx.r[25].s64 = ctx.r[25].s64 + 4;
	// 829ECB74: 4082FF58  bne 0x829ecacc
	if !ctx.cr[0].eq {
	pc = 0x829ECACC; continue 'dispatch;
	}
	pc = 0x829ECB78; continue 'dispatch;
            }
            0x829ECB78 => {
    //   block [0x829ECB78..0x829ECB8C)
	// 829ECB78: 3A940001  addi r20, r20, 1
	ctx.r[20].s64 = ctx.r[20].s64 + 1;
	// 829ECB7C: 7F147800  cmpw cr6, r20, r15
	ctx.cr[6].compare_i32(ctx.r[20].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829ECB80: 4198FF18  blt cr6, 0x829eca98
	if ctx.cr[6].lt {
	pc = 0x829ECA98; continue 'dispatch;
	}
	// 829ECB84: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829ECB88: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	pc = 0x829ECB8C; continue 'dispatch;
            }
            0x829ECB8C => {
    //   block [0x829ECB8C..0x829ECBA8)
	// 829ECB8C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829ECB90: 3A310014  addi r17, r17, 0x14
	ctx.r[17].s64 = ctx.r[17].s64 + 20;
	// 829ECB94: 3A730010  addi r19, r19, 0x10
	ctx.r[19].s64 = ctx.r[19].s64 + 16;
	// 829ECB98: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829ECB9C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829ECBA0: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 829ECBA4: 4198FEA8  blt cr6, 0x829eca4c
	if ctx.cr[6].lt {
	pc = 0x829ECA4C; continue 'dispatch;
	}
	pc = 0x829ECBA8; continue 'dispatch;
            }
            0x829ECBA8 => {
    //   block [0x829ECBA8..0x829ECBB0)
	// 829ECBA8: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 829ECBAC: 482BC874  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829ECBB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829ECBB0 size=540
    let mut pc: u32 = 0x829ECBB0;
    'dispatch: loop {
        match pc {
            0x829ECBB0 => {
    //   block [0x829ECBB0..0x829ECC64)
	// 829ECBB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829ECBB4: 482BC81D  bl 0x82ca93d0
	ctx.lr = 0x829ECBB8;
	sub_82CA93D0(ctx, base);
	// 829ECBB8: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829ECBBC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ECBC0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829ECBC4: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 829ECBC8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829ECBCC: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 829ECBD0: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 829ECBD4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ECBD8: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 829ECBDC: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 829ECBE0: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 829ECBE4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829ECBE8: 813B6C10  lwz r9, 0x6c10(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	// 829ECBEC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829ECBF0: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 829ECBF4: 3BE90001  addi r31, r9, 1
	ctx.r[31].s64 = ctx.r[9].s64 + 1;
	// 829ECBF8: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 829ECBFC: 93FB6C10  stw r31, 0x6c10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(27664 as u32), ctx.r[31].u32 ) };
	// 829ECC00: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829ECC04: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ECC08: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 829ECC0C: 82490064  lwz r18, 0x64(r9)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 829ECC10: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 829ECC14: 4B878E15  bl 0x82265a28
	ctx.lr = 0x829ECC18;
	sub_82265A28(ctx, base);
	// 829ECC18: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829ECC1C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829ECC20: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 829ECC24: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 829ECC28: 4099019C  ble cr6, 0x829ecdc4
	if !ctx.cr[6].gt {
	pc = 0x829ECDC4; continue 'dispatch;
	}
	// 829ECC2C: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 829ECC30: 7F93E378  mr r19, r28
	ctx.r[19].u64 = ctx.r[28].u64;
	// 829ECC34: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829ECC38: 7F91E378  mr r17, r28
	ctx.r[17].u64 = ctx.r[28].u64;
	// 829ECC3C: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 829ECC40: 38EAFFFF  addi r7, r10, -1
	ctx.r[7].s64 = ctx.r[10].s64 + -1;
	// 829ECC44: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 829ECC48: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829ECC4C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829ECC50: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 829ECC54: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 829ECC58: 3B0B0B7C  addi r24, r11, 0xb7c
	ctx.r[24].s64 = ctx.r[11].s64 + 2940;
	// 829ECC5C: 3AEA0B7C  addi r23, r10, 0xb7c
	ctx.r[23].s64 = ctx.r[10].s64 + 2940;
	// 829ECC60: 39C9A2F8  addi r14, r9, -0x5d08
	ctx.r[14].s64 = ctx.r[9].s64 + -23816;
	pc = 0x829ECC64; continue 'dispatch;
            }
            0x829ECC64 => {
    //   block [0x829ECC64..0x829ECCB0)
	// 829ECC64: 396E0004  addi r11, r14, 4
	ctx.r[11].s64 = ctx.r[14].s64 + 4;
	// 829ECC68: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 829ECC6C: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829ECC70: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829ECC74: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829ECC78: 7CB3582E  lwzx r5, r19, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829ECC7C: 7D5A2E30  sraw r26, r10, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[26].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 829ECC80: 7D2A2E30  sraw r10, r9, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> tmp.u32) as i64;
	// 829ECC84: 7CEB2E30  sraw r11, r7, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> tmp.u32) as i64;
	// 829ECC88: 3ACB0001  addi r22, r11, 1
	ctx.r[22].s64 = ctx.r[11].s64 + 1;
	// 829ECC8C: 7CCB2E30  sraw r11, r6, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[6].s32 >> tmp.u32) as i64;
	// 829ECC90: 7E1AB051  subf. r16, r26, r22
	ctx.r[16].s64 = ctx.r[22].s64 - ctx.r[26].s64;
	ctx.cr[0].compare_i32(ctx.r[16].s32, 0, &mut ctx.xer);
	// 829ECC94: 39EB0001  addi r15, r11, 1
	ctx.r[15].s64 = ctx.r[11].s64 + 1;
	// 829ECC98: 41820110  beq 0x829ecda8
	if ctx.cr[0].eq {
	pc = 0x829ECDA8; continue 'dispatch;
	}
	// 829ECC9C: 7D6A7851  subf. r11, r10, r15
	ctx.r[11].s64 = ctx.r[15].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829ECCA0: 41820108  beq 0x829ecda8
	if ctx.cr[0].eq {
	pc = 0x829ECDA8; continue 'dispatch;
	}
	// 829ECCA4: 7D545378  mr r20, r10
	ctx.r[20].u64 = ctx.r[10].u64;
	// 829ECCA8: 7F0A7800  cmpw cr6, r10, r15
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829ECCAC: 409800FC  bge cr6, 0x829ecda8
	if !ctx.cr[6].lt {
	pc = 0x829ECDA8; continue 'dispatch;
	}
	pc = 0x829ECCB0; continue 'dispatch;
            }
            0x829ECCB0 => {
    //   block [0x829ECCB0..0x829ECCE4)
	// 829ECCB0: 81520008  lwz r10, 8(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) } as u64;
	// 829ECCB4: 7F1AB000  cmpw cr6, r26, r22
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[22].s32, &mut ctx.xer);
	// 829ECCB8: 81720018  lwz r11, 0x18(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24 as u32) ) } as u64;
	// 829ECCBC: 7D515214  add r10, r17, r10
	ctx.r[10].u64 = ctx.r[17].u64 + ctx.r[10].u64;
	// 829ECCC0: 7D2B9A14  add r9, r11, r19
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[19].u64;
	// 829ECCC4: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ECCC8: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ECCCC: 7D68A1D6  mullw r11, r8, r20
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * ctx.r[20].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 829ECCD0: 7CEBD214  add r7, r11, r26
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 829ECCD4: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829ECCD8: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829ECCDC: 409800B8  bge cr6, 0x829ecd94
	if !ctx.cr[6].lt {
	pc = 0x829ECD94; continue 'dispatch;
	}
	// 829ECCE0: 7E158378  mr r21, r16
	ctx.r[21].u64 = ctx.r[16].u64;
	pc = 0x829ECCE4; continue 'dispatch;
            }
            0x829ECCE4 => {
    //   block [0x829ECCE4..0x829ECCF0)
	// 829ECCE4: 83B90000  lwz r29, 0(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829ECCE8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829ECCEC: 419A009C  beq cr6, 0x829ecd88
	if ctx.cr[6].eq {
	pc = 0x829ECD88; continue 'dispatch;
	}
	pc = 0x829ECCF0; continue 'dispatch;
            }
            0x829ECCF0 => {
    //   block [0x829ECCF0..0x829ECD78)
	// 829ECCF0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829ECCF4: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829ECCF8: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 829ECCFC: 40980080  bge cr6, 0x829ecd7c
	if !ctx.cr[6].lt {
	pc = 0x829ECD7C; continue 'dispatch;
	}
	// 829ECD00: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 829ECD04: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ECD08: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829ECD0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829ECD10: 4B8168D1  bl 0x822035e0
	ctx.lr = 0x829ECD14;
	sub_822035E0(ctx, base);
	// 829ECD14: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829ECD18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829ECD1C: 419A005C  beq cr6, 0x829ecd78
	if ctx.cr[6].eq {
	pc = 0x829ECD78; continue 'dispatch;
	}
	// 829ECD20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829ECD24: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ECD28: 4BB25451  bl 0x82512178
	ctx.lr = 0x829ECD2C;
	sub_82512178(ctx, base);
	// 829ECD2C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829ECD30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829ECD34: 419A0044  beq cr6, 0x829ecd78
	if ctx.cr[6].eq {
	pc = 0x829ECD78; continue 'dispatch;
	}
	// 829ECD38: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 829ECD3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829ECD40: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 829ECD44: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829ECD48: 4B827B51  bl 0x82214898
	ctx.lr = 0x829ECD4C;
	sub_82214898(ctx, base);
	// 829ECD4C: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829ECD50: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829ECD54: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ECD58: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 829ECD5C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 829ECD60: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 829ECD64: 4BA693B5  bl 0x82456118
	ctx.lr = 0x829ECD68;
	sub_82456118(ctx, base);
	// 829ECD68: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 829ECD6C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829ECD70: 4B7A70C9  bl 0x82193e38
	ctx.lr = 0x829ECD74;
	sub_82193E38(ctx, base);
	// 829ECD74: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	pc = 0x829ECD78; continue 'dispatch;
            }
            0x829ECD78 => {
    //   block [0x829ECD78..0x829ECD7C)
	// 829ECD78: 83FB6C10  lwz r31, 0x6c10(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	pc = 0x829ECD7C; continue 'dispatch;
            }
            0x829ECD7C => {
    //   block [0x829ECD7C..0x829ECD88)
	// 829ECD7C: 83BD0004  lwz r29, 4(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ECD80: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829ECD84: 409AFF6C  bne cr6, 0x829eccf0
	if !ctx.cr[6].eq {
	pc = 0x829ECCF0; continue 'dispatch;
	}
	pc = 0x829ECD88; continue 'dispatch;
            }
            0x829ECD88 => {
    //   block [0x829ECD88..0x829ECD94)
	// 829ECD88: 36B5FFFF  addic. r21, r21, -1
	ctx.xer.ca = (ctx.r[21].u32 > (!(-1 as u32)));
	ctx.r[21].s64 = ctx.r[21].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[21].s32, 0, &mut ctx.xer);
	// 829ECD8C: 3B390004  addi r25, r25, 4
	ctx.r[25].s64 = ctx.r[25].s64 + 4;
	// 829ECD90: 4082FF54  bne 0x829ecce4
	if !ctx.cr[0].eq {
	pc = 0x829ECCE4; continue 'dispatch;
	}
	pc = 0x829ECD94; continue 'dispatch;
            }
            0x829ECD94 => {
    //   block [0x829ECD94..0x829ECDA8)
	// 829ECD94: 3A940001  addi r20, r20, 1
	ctx.r[20].s64 = ctx.r[20].s64 + 1;
	// 829ECD98: 7F147800  cmpw cr6, r20, r15
	ctx.cr[6].compare_i32(ctx.r[20].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829ECD9C: 4198FF14  blt cr6, 0x829eccb0
	if ctx.cr[6].lt {
	pc = 0x829ECCB0; continue 'dispatch;
	}
	// 829ECDA0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829ECDA4: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	pc = 0x829ECDA8; continue 'dispatch;
            }
            0x829ECDA8 => {
    //   block [0x829ECDA8..0x829ECDC4)
	// 829ECDA8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829ECDAC: 3A310014  addi r17, r17, 0x14
	ctx.r[17].s64 = ctx.r[17].s64 + 20;
	// 829ECDB0: 3A730010  addi r19, r19, 0x10
	ctx.r[19].s64 = ctx.r[19].s64 + 16;
	// 829ECDB4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829ECDB8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829ECDBC: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 829ECDC0: 4198FEA4  blt cr6, 0x829ecc64
	if ctx.cr[6].lt {
	pc = 0x829ECC64; continue 'dispatch;
	}
	pc = 0x829ECDC4; continue 'dispatch;
            }
            0x829ECDC4 => {
    //   block [0x829ECDC4..0x829ECDCC)
	// 829ECDC4: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 829ECDC8: 482BC658  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829ECDD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829ECDD0 size=400
    let mut pc: u32 = 0x829ECDD0;
    'dispatch: loop {
        match pc {
            0x829ECDD0 => {
    //   block [0x829ECDD0..0x829ECE6C)
	// 829ECDD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829ECDD4: 482BC5FD  bl 0x82ca93d0
	ctx.lr = 0x829ECDD8;
	sub_82CA93D0(ctx, base);
	// 829ECDD8: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829ECDDC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ECDE0: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 829ECDE4: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 829ECDE8: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 829ECDEC: 3EC08349  lis r22, -0x7cb7
	ctx.r[22].s64 = -2092367872;
	// 829ECDF0: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
	// 829ECDF4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ECDF8: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 829ECDFC: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 829ECE00: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 829ECE04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829ECE08: 81366C10  lwz r9, 0x6c10(r22)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(27664 as u32) ) } as u64;
	// 829ECE0C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829ECE10: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 829ECE14: 3BC90001  addi r30, r9, 1
	ctx.r[30].s64 = ctx.r[9].s64 + 1;
	// 829ECE18: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 829ECE1C: 93D66C10  stw r30, 0x6c10(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(27664 as u32), ctx.r[30].u32 ) };
	// 829ECE20: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829ECE24: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ECE28: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 829ECE2C: 82E90064  lwz r23, 0x64(r9)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 829ECE30: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 829ECE34: 4B878BF5  bl 0x82265a28
	ctx.lr = 0x829ECE38;
	sub_82265A28(ctx, base);
	// 829ECE38: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829ECE3C: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 829ECE40: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 829ECE44: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829ECE48: 40990110  ble cr6, 0x829ecf58
	if !ctx.cr[6].gt {
	pc = 0x829ECF58; continue 'dispatch;
	}
	// 829ECE4C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 829ECE50: 7E98A378  mr r24, r20
	ctx.r[24].u64 = ctx.r[20].u64;
	// 829ECE54: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829ECE58: 3A0BFFFF  addi r16, r11, -1
	ctx.r[16].s64 = ctx.r[11].s64 + -1;
	// 829ECE5C: 81C10064  lwz r14, 0x64(r1)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829ECE60: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 829ECE64: 39EAFFFF  addi r15, r10, -1
	ctx.r[15].s64 = ctx.r[10].s64 + -1;
	// 829ECE68: 3A2BA2F8  addi r17, r11, -0x5d08
	ctx.r[17].s64 = ctx.r[11].s64 + -23816;
	pc = 0x829ECE6C; continue 'dispatch;
            }
            0x829ECE6C => {
    //   block [0x829ECE6C..0x829ECEAC)
	// 829ECE6C: 39710004  addi r11, r17, 4
	ctx.r[11].s64 = ctx.r[17].s64 + 4;
	// 829ECE70: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 829ECE74: 7D18582E  lwzx r8, r24, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829ECE78: 7D5D4630  sraw r29, r10, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 829ECE7C: 7DCA4630  sraw r10, r14, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[14].s32 < 0) && ((ctx.r[14].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[14].s32 >> tmp.u32) as i64;
	// 829ECE80: 7E0B4630  sraw r11, r16, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[16].s32 < 0) && ((ctx.r[16].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[16].s32 >> tmp.u32) as i64;
	// 829ECE84: 3B6B0001  addi r27, r11, 1
	ctx.r[27].s64 = ctx.r[11].s64 + 1;
	// 829ECE88: 7DEB4630  sraw r11, r15, r8
	tmp.u32 = ctx.r[8].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[15].s32 < 0) && ((ctx.r[15].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[15].s32 >> tmp.u32) as i64;
	// 829ECE8C: 7E7DD851  subf. r19, r29, r27
	ctx.r[19].s64 = ctx.r[27].s64 - ctx.r[29].s64;
	ctx.cr[0].compare_i32(ctx.r[19].s32, 0, &mut ctx.xer);
	// 829ECE90: 3A4B0001  addi r18, r11, 1
	ctx.r[18].s64 = ctx.r[11].s64 + 1;
	// 829ECE94: 418200A8  beq 0x829ecf3c
	if ctx.cr[0].eq {
	pc = 0x829ECF3C; continue 'dispatch;
	}
	// 829ECE98: 7D6A9051  subf. r11, r10, r18
	ctx.r[11].s64 = ctx.r[18].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829ECE9C: 418200A0  beq 0x829ecf3c
	if ctx.cr[0].eq {
	pc = 0x829ECF3C; continue 'dispatch;
	}
	// 829ECEA0: 7D595378  mr r25, r10
	ctx.r[25].u64 = ctx.r[10].u64;
	// 829ECEA4: 7F0A9000  cmpw cr6, r10, r18
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[18].s32, &mut ctx.xer);
	// 829ECEA8: 40980094  bge cr6, 0x829ecf3c
	if !ctx.cr[6].lt {
	pc = 0x829ECF3C; continue 'dispatch;
	}
	pc = 0x829ECEAC; continue 'dispatch;
            }
            0x829ECEAC => {
    //   block [0x829ECEAC..0x829ECEE0)
	// 829ECEAC: 81770008  lwz r11, 8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 829ECEB0: 7F1DD800  cmpw cr6, r29, r27
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[27].s32, &mut ctx.xer);
	// 829ECEB4: 81570018  lwz r10, 0x18(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(24 as u32) ) } as u64;
	// 829ECEB8: 7D745A14  add r11, r20, r11
	ctx.r[11].u64 = ctx.r[20].u64 + ctx.r[11].u64;
	// 829ECEBC: 7D4AC214  add r10, r10, r24
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[24].u64;
	// 829ECEC0: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ECEC4: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ECEC8: 7D69C9D6  mullw r11, r9, r25
	ctx.r[11].s32 = ((ctx.r[9].s32 as i64 * ctx.r[25].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 829ECECC: 7D0BEA14  add r8, r11, r29
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 829ECED0: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829ECED4: 7F8B5214  add r28, r11, r10
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829ECED8: 40980050  bge cr6, 0x829ecf28
	if !ctx.cr[6].lt {
	pc = 0x829ECF28; continue 'dispatch;
	}
	// 829ECEDC: 7E7A9B78  mr r26, r19
	ctx.r[26].u64 = ctx.r[19].u64;
	pc = 0x829ECEE0; continue 'dispatch;
            }
            0x829ECEE0 => {
    //   block [0x829ECEE0..0x829ECEEC)
	// 829ECEE0: 83FC0000  lwz r31, 0(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 829ECEE4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829ECEE8: 419A0034  beq cr6, 0x829ecf1c
	if ctx.cr[6].eq {
	pc = 0x829ECF1C; continue 'dispatch;
	}
	pc = 0x829ECEEC; continue 'dispatch;
            }
            0x829ECEEC => {
    //   block [0x829ECEEC..0x829ECF10)
	// 829ECEEC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829ECEF0: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829ECEF4: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829ECEF8: 40980018  bge cr6, 0x829ecf10
	if !ctx.cr[6].lt {
	pc = 0x829ECF10; continue 'dispatch;
	}
	// 829ECEFC: 93CB004C  stw r30, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[30].u32 ) };
	// 829ECF00: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 829ECF04: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ECF08: 48000579  bl 0x829ed480
	ctx.lr = 0x829ECF0C;
	sub_829ED480(ctx, base);
	// 829ECF0C: 83D66C10  lwz r30, 0x6c10(r22)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(27664 as u32) ) } as u64;
	pc = 0x829ECF10; continue 'dispatch;
            }
            0x829ECF10 => {
    //   block [0x829ECF10..0x829ECF1C)
	// 829ECF10: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ECF14: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829ECF18: 409AFFD4  bne cr6, 0x829eceec
	if !ctx.cr[6].eq {
	pc = 0x829ECEEC; continue 'dispatch;
	}
	pc = 0x829ECF1C; continue 'dispatch;
            }
            0x829ECF1C => {
    //   block [0x829ECF1C..0x829ECF28)
	// 829ECF1C: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 829ECF20: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 829ECF24: 4082FFBC  bne 0x829ecee0
	if !ctx.cr[0].eq {
	pc = 0x829ECEE0; continue 'dispatch;
	}
	pc = 0x829ECF28; continue 'dispatch;
            }
            0x829ECF28 => {
    //   block [0x829ECF28..0x829ECF3C)
	// 829ECF28: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 829ECF2C: 7F199000  cmpw cr6, r25, r18
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[18].s32, &mut ctx.xer);
	// 829ECF30: 4198FF7C  blt cr6, 0x829eceac
	if ctx.cr[6].lt {
	pc = 0x829ECEAC; continue 'dispatch;
	}
	// 829ECF34: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829ECF38: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	pc = 0x829ECF3C; continue 'dispatch;
            }
            0x829ECF3C => {
    //   block [0x829ECF3C..0x829ECF58)
	// 829ECF3C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829ECF40: 3A940014  addi r20, r20, 0x14
	ctx.r[20].s64 = ctx.r[20].s64 + 20;
	// 829ECF44: 3B180010  addi r24, r24, 0x10
	ctx.r[24].s64 = ctx.r[24].s64 + 16;
	// 829ECF48: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829ECF4C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829ECF50: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 829ECF54: 4198FF18  blt cr6, 0x829ece6c
	if ctx.cr[6].lt {
	pc = 0x829ECE6C; continue 'dispatch;
	}
	pc = 0x829ECF58; continue 'dispatch;
            }
            0x829ECF58 => {
    //   block [0x829ECF58..0x829ECF60)
	// 829ECF58: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 829ECF5C: 482BC4C4  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829ECF60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829ECF60 size=540
    let mut pc: u32 = 0x829ECF60;
    'dispatch: loop {
        match pc {
            0x829ECF60 => {
    //   block [0x829ECF60..0x829ED014)
	// 829ECF60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829ECF64: 482BC46D  bl 0x82ca93d0
	ctx.lr = 0x829ECF68;
	sub_82CA93D0(ctx, base);
	// 829ECF68: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829ECF6C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ECF70: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829ECF74: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 829ECF78: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829ECF7C: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 829ECF80: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 829ECF84: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ECF88: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 829ECF8C: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 829ECF90: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 829ECF94: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829ECF98: 813B6C10  lwz r9, 0x6c10(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	// 829ECF9C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829ECFA0: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 829ECFA4: 3BE90001  addi r31, r9, 1
	ctx.r[31].s64 = ctx.r[9].s64 + 1;
	// 829ECFA8: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 829ECFAC: 93FB6C10  stw r31, 0x6c10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(27664 as u32), ctx.r[31].u32 ) };
	// 829ECFB0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829ECFB4: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ECFB8: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 829ECFBC: 82490064  lwz r18, 0x64(r9)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 829ECFC0: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 829ECFC4: 4B878A65  bl 0x82265a28
	ctx.lr = 0x829ECFC8;
	sub_82265A28(ctx, base);
	// 829ECFC8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829ECFCC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829ECFD0: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 829ECFD4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 829ECFD8: 4099019C  ble cr6, 0x829ed174
	if !ctx.cr[6].gt {
	pc = 0x829ED174; continue 'dispatch;
	}
	// 829ECFDC: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 829ECFE0: 7F93E378  mr r19, r28
	ctx.r[19].u64 = ctx.r[28].u64;
	// 829ECFE4: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829ECFE8: 7F91E378  mr r17, r28
	ctx.r[17].u64 = ctx.r[28].u64;
	// 829ECFEC: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 829ECFF0: 38EAFFFF  addi r7, r10, -1
	ctx.r[7].s64 = ctx.r[10].s64 + -1;
	// 829ECFF4: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 829ECFF8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829ECFFC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829ED000: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 829ED004: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 829ED008: 3B0B0B7C  addi r24, r11, 0xb7c
	ctx.r[24].s64 = ctx.r[11].s64 + 2940;
	// 829ED00C: 3AEA0B7C  addi r23, r10, 0xb7c
	ctx.r[23].s64 = ctx.r[10].s64 + 2940;
	// 829ED010: 39C9A2F8  addi r14, r9, -0x5d08
	ctx.r[14].s64 = ctx.r[9].s64 + -23816;
	pc = 0x829ED014; continue 'dispatch;
            }
            0x829ED014 => {
    //   block [0x829ED014..0x829ED060)
	// 829ED014: 396E0004  addi r11, r14, 4
	ctx.r[11].s64 = ctx.r[14].s64 + 4;
	// 829ED018: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 829ED01C: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829ED020: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829ED024: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829ED028: 7CB3582E  lwzx r5, r19, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829ED02C: 7D5A2E30  sraw r26, r10, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[26].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 829ED030: 7D2A2E30  sraw r10, r9, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> tmp.u32) as i64;
	// 829ED034: 7CEB2E30  sraw r11, r7, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> tmp.u32) as i64;
	// 829ED038: 3ACB0001  addi r22, r11, 1
	ctx.r[22].s64 = ctx.r[11].s64 + 1;
	// 829ED03C: 7CCB2E30  sraw r11, r6, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[6].s32 >> tmp.u32) as i64;
	// 829ED040: 7E1AB051  subf. r16, r26, r22
	ctx.r[16].s64 = ctx.r[22].s64 - ctx.r[26].s64;
	ctx.cr[0].compare_i32(ctx.r[16].s32, 0, &mut ctx.xer);
	// 829ED044: 39EB0001  addi r15, r11, 1
	ctx.r[15].s64 = ctx.r[11].s64 + 1;
	// 829ED048: 41820110  beq 0x829ed158
	if ctx.cr[0].eq {
	pc = 0x829ED158; continue 'dispatch;
	}
	// 829ED04C: 7D6A7851  subf. r11, r10, r15
	ctx.r[11].s64 = ctx.r[15].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829ED050: 41820108  beq 0x829ed158
	if ctx.cr[0].eq {
	pc = 0x829ED158; continue 'dispatch;
	}
	// 829ED054: 7D545378  mr r20, r10
	ctx.r[20].u64 = ctx.r[10].u64;
	// 829ED058: 7F0A7800  cmpw cr6, r10, r15
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829ED05C: 409800FC  bge cr6, 0x829ed158
	if !ctx.cr[6].lt {
	pc = 0x829ED158; continue 'dispatch;
	}
	pc = 0x829ED060; continue 'dispatch;
            }
            0x829ED060 => {
    //   block [0x829ED060..0x829ED094)
	// 829ED060: 81520008  lwz r10, 8(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) } as u64;
	// 829ED064: 7F1AB000  cmpw cr6, r26, r22
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[22].s32, &mut ctx.xer);
	// 829ED068: 81720018  lwz r11, 0x18(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24 as u32) ) } as u64;
	// 829ED06C: 7D515214  add r10, r17, r10
	ctx.r[10].u64 = ctx.r[17].u64 + ctx.r[10].u64;
	// 829ED070: 7D2B9A14  add r9, r11, r19
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[19].u64;
	// 829ED074: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ED078: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ED07C: 7D68A1D6  mullw r11, r8, r20
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * ctx.r[20].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 829ED080: 7CEBD214  add r7, r11, r26
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 829ED084: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829ED088: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829ED08C: 409800B8  bge cr6, 0x829ed144
	if !ctx.cr[6].lt {
	pc = 0x829ED144; continue 'dispatch;
	}
	// 829ED090: 7E158378  mr r21, r16
	ctx.r[21].u64 = ctx.r[16].u64;
	pc = 0x829ED094; continue 'dispatch;
            }
            0x829ED094 => {
    //   block [0x829ED094..0x829ED0A0)
	// 829ED094: 83B90000  lwz r29, 0(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829ED098: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829ED09C: 419A009C  beq cr6, 0x829ed138
	if ctx.cr[6].eq {
	pc = 0x829ED138; continue 'dispatch;
	}
	pc = 0x829ED0A0; continue 'dispatch;
            }
            0x829ED0A0 => {
    //   block [0x829ED0A0..0x829ED128)
	// 829ED0A0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829ED0A4: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829ED0A8: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 829ED0AC: 40980080  bge cr6, 0x829ed12c
	if !ctx.cr[6].lt {
	pc = 0x829ED12C; continue 'dispatch;
	}
	// 829ED0B0: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 829ED0B4: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ED0B8: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829ED0BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829ED0C0: 4B816521  bl 0x822035e0
	ctx.lr = 0x829ED0C4;
	sub_822035E0(ctx, base);
	// 829ED0C4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829ED0C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829ED0CC: 419A005C  beq cr6, 0x829ed128
	if ctx.cr[6].eq {
	pc = 0x829ED128; continue 'dispatch;
	}
	// 829ED0D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829ED0D4: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ED0D8: 4BB24C39  bl 0x82511d10
	ctx.lr = 0x829ED0DC;
	sub_82511D10(ctx, base);
	// 829ED0DC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829ED0E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829ED0E4: 419A0044  beq cr6, 0x829ed128
	if ctx.cr[6].eq {
	pc = 0x829ED128; continue 'dispatch;
	}
	// 829ED0E8: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 829ED0EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829ED0F0: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 829ED0F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829ED0F8: 4B8277A1  bl 0x82214898
	ctx.lr = 0x829ED0FC;
	sub_82214898(ctx, base);
	// 829ED0FC: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829ED100: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829ED104: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ED108: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 829ED10C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 829ED110: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 829ED114: 4BA69005  bl 0x82456118
	ctx.lr = 0x829ED118;
	sub_82456118(ctx, base);
	// 829ED118: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 829ED11C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829ED120: 4B7A6D19  bl 0x82193e38
	ctx.lr = 0x829ED124;
	sub_82193E38(ctx, base);
	// 829ED124: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	pc = 0x829ED128; continue 'dispatch;
            }
            0x829ED128 => {
    //   block [0x829ED128..0x829ED12C)
	// 829ED128: 83FB6C10  lwz r31, 0x6c10(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	pc = 0x829ED12C; continue 'dispatch;
            }
            0x829ED12C => {
    //   block [0x829ED12C..0x829ED138)
	// 829ED12C: 83BD0004  lwz r29, 4(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ED130: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829ED134: 409AFF6C  bne cr6, 0x829ed0a0
	if !ctx.cr[6].eq {
	pc = 0x829ED0A0; continue 'dispatch;
	}
	pc = 0x829ED138; continue 'dispatch;
            }
            0x829ED138 => {
    //   block [0x829ED138..0x829ED144)
	// 829ED138: 36B5FFFF  addic. r21, r21, -1
	ctx.xer.ca = (ctx.r[21].u32 > (!(-1 as u32)));
	ctx.r[21].s64 = ctx.r[21].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[21].s32, 0, &mut ctx.xer);
	// 829ED13C: 3B390004  addi r25, r25, 4
	ctx.r[25].s64 = ctx.r[25].s64 + 4;
	// 829ED140: 4082FF54  bne 0x829ed094
	if !ctx.cr[0].eq {
	pc = 0x829ED094; continue 'dispatch;
	}
	pc = 0x829ED144; continue 'dispatch;
            }
            0x829ED144 => {
    //   block [0x829ED144..0x829ED158)
	// 829ED144: 3A940001  addi r20, r20, 1
	ctx.r[20].s64 = ctx.r[20].s64 + 1;
	// 829ED148: 7F147800  cmpw cr6, r20, r15
	ctx.cr[6].compare_i32(ctx.r[20].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829ED14C: 4198FF14  blt cr6, 0x829ed060
	if ctx.cr[6].lt {
	pc = 0x829ED060; continue 'dispatch;
	}
	// 829ED150: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829ED154: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	pc = 0x829ED158; continue 'dispatch;
            }
            0x829ED158 => {
    //   block [0x829ED158..0x829ED174)
	// 829ED158: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829ED15C: 3A310014  addi r17, r17, 0x14
	ctx.r[17].s64 = ctx.r[17].s64 + 20;
	// 829ED160: 3A730010  addi r19, r19, 0x10
	ctx.r[19].s64 = ctx.r[19].s64 + 16;
	// 829ED164: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829ED168: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829ED16C: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 829ED170: 4198FEA4  blt cr6, 0x829ed014
	if ctx.cr[6].lt {
	pc = 0x829ED014; continue 'dispatch;
	}
	pc = 0x829ED174; continue 'dispatch;
            }
            0x829ED174 => {
    //   block [0x829ED174..0x829ED17C)
	// 829ED174: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 829ED178: 482BC2A8  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829ED180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829ED180 size=540
    let mut pc: u32 = 0x829ED180;
    'dispatch: loop {
        match pc {
            0x829ED180 => {
    //   block [0x829ED180..0x829ED234)
	// 829ED180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829ED184: 482BC24D  bl 0x82ca93d0
	ctx.lr = 0x829ED188;
	sub_82CA93D0(ctx, base);
	// 829ED188: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829ED18C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ED190: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829ED194: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 829ED198: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829ED19C: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 829ED1A0: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 829ED1A4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ED1A8: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 829ED1AC: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 829ED1B0: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 829ED1B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829ED1B8: 813B6C10  lwz r9, 0x6c10(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	// 829ED1BC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829ED1C0: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 829ED1C4: 3BE90001  addi r31, r9, 1
	ctx.r[31].s64 = ctx.r[9].s64 + 1;
	// 829ED1C8: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 829ED1CC: 93FB6C10  stw r31, 0x6c10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(27664 as u32), ctx.r[31].u32 ) };
	// 829ED1D0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829ED1D4: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ED1D8: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 829ED1DC: 82490064  lwz r18, 0x64(r9)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 829ED1E0: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 829ED1E4: 4B878845  bl 0x82265a28
	ctx.lr = 0x829ED1E8;
	sub_82265A28(ctx, base);
	// 829ED1E8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829ED1EC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829ED1F0: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 829ED1F4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 829ED1F8: 4099019C  ble cr6, 0x829ed394
	if !ctx.cr[6].gt {
	pc = 0x829ED394; continue 'dispatch;
	}
	// 829ED1FC: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 829ED200: 7F93E378  mr r19, r28
	ctx.r[19].u64 = ctx.r[28].u64;
	// 829ED204: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829ED208: 7F91E378  mr r17, r28
	ctx.r[17].u64 = ctx.r[28].u64;
	// 829ED20C: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 829ED210: 38EAFFFF  addi r7, r10, -1
	ctx.r[7].s64 = ctx.r[10].s64 + -1;
	// 829ED214: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 829ED218: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829ED21C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829ED220: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 829ED224: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 829ED228: 3B0B0B7C  addi r24, r11, 0xb7c
	ctx.r[24].s64 = ctx.r[11].s64 + 2940;
	// 829ED22C: 3AEA0B7C  addi r23, r10, 0xb7c
	ctx.r[23].s64 = ctx.r[10].s64 + 2940;
	// 829ED230: 39C9A2F8  addi r14, r9, -0x5d08
	ctx.r[14].s64 = ctx.r[9].s64 + -23816;
	pc = 0x829ED234; continue 'dispatch;
            }
            0x829ED234 => {
    //   block [0x829ED234..0x829ED280)
	// 829ED234: 396E0004  addi r11, r14, 4
	ctx.r[11].s64 = ctx.r[14].s64 + 4;
	// 829ED238: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 829ED23C: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829ED240: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829ED244: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829ED248: 7CB3582E  lwzx r5, r19, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829ED24C: 7D5A2E30  sraw r26, r10, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[26].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 829ED250: 7D2A2E30  sraw r10, r9, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> tmp.u32) as i64;
	// 829ED254: 7CEB2E30  sraw r11, r7, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> tmp.u32) as i64;
	// 829ED258: 3ACB0001  addi r22, r11, 1
	ctx.r[22].s64 = ctx.r[11].s64 + 1;
	// 829ED25C: 7CCB2E30  sraw r11, r6, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[6].s32 >> tmp.u32) as i64;
	// 829ED260: 7E1AB051  subf. r16, r26, r22
	ctx.r[16].s64 = ctx.r[22].s64 - ctx.r[26].s64;
	ctx.cr[0].compare_i32(ctx.r[16].s32, 0, &mut ctx.xer);
	// 829ED264: 39EB0001  addi r15, r11, 1
	ctx.r[15].s64 = ctx.r[11].s64 + 1;
	// 829ED268: 41820110  beq 0x829ed378
	if ctx.cr[0].eq {
	pc = 0x829ED378; continue 'dispatch;
	}
	// 829ED26C: 7D6A7851  subf. r11, r10, r15
	ctx.r[11].s64 = ctx.r[15].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829ED270: 41820108  beq 0x829ed378
	if ctx.cr[0].eq {
	pc = 0x829ED378; continue 'dispatch;
	}
	// 829ED274: 7D545378  mr r20, r10
	ctx.r[20].u64 = ctx.r[10].u64;
	// 829ED278: 7F0A7800  cmpw cr6, r10, r15
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829ED27C: 409800FC  bge cr6, 0x829ed378
	if !ctx.cr[6].lt {
	pc = 0x829ED378; continue 'dispatch;
	}
	pc = 0x829ED280; continue 'dispatch;
            }
            0x829ED280 => {
    //   block [0x829ED280..0x829ED2B4)
	// 829ED280: 81720008  lwz r11, 8(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) } as u64;
	// 829ED284: 7F1AB000  cmpw cr6, r26, r22
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[22].s32, &mut ctx.xer);
	// 829ED288: 81520018  lwz r10, 0x18(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(24 as u32) ) } as u64;
	// 829ED28C: 7D715A14  add r11, r17, r11
	ctx.r[11].u64 = ctx.r[17].u64 + ctx.r[11].u64;
	// 829ED290: 7D4A9A14  add r10, r10, r19
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[19].u64;
	// 829ED294: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ED298: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ED29C: 7D69A1D6  mullw r11, r9, r20
	ctx.r[11].s32 = ((ctx.r[9].s32 as i64 * ctx.r[20].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 829ED2A0: 7D0BD214  add r8, r11, r26
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 829ED2A4: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829ED2A8: 7F2B5214  add r25, r11, r10
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829ED2AC: 409800B8  bge cr6, 0x829ed364
	if !ctx.cr[6].lt {
	pc = 0x829ED364; continue 'dispatch;
	}
	// 829ED2B0: 7E158378  mr r21, r16
	ctx.r[21].u64 = ctx.r[16].u64;
	pc = 0x829ED2B4; continue 'dispatch;
            }
            0x829ED2B4 => {
    //   block [0x829ED2B4..0x829ED2C0)
	// 829ED2B4: 83B90000  lwz r29, 0(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829ED2B8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829ED2BC: 419A009C  beq cr6, 0x829ed358
	if ctx.cr[6].eq {
	pc = 0x829ED358; continue 'dispatch;
	}
	pc = 0x829ED2C0; continue 'dispatch;
            }
            0x829ED2C0 => {
    //   block [0x829ED2C0..0x829ED348)
	// 829ED2C0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829ED2C4: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829ED2C8: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 829ED2CC: 40980080  bge cr6, 0x829ed34c
	if !ctx.cr[6].lt {
	pc = 0x829ED34C; continue 'dispatch;
	}
	// 829ED2D0: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 829ED2D4: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ED2D8: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829ED2DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829ED2E0: 4B816301  bl 0x822035e0
	ctx.lr = 0x829ED2E4;
	sub_822035E0(ctx, base);
	// 829ED2E4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829ED2E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829ED2EC: 419A005C  beq cr6, 0x829ed348
	if ctx.cr[6].eq {
	pc = 0x829ED348; continue 'dispatch;
	}
	// 829ED2F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829ED2F4: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ED2F8: 4BBF9599  bl 0x825e6890
	ctx.lr = 0x829ED2FC;
	sub_825E6890(ctx, base);
	// 829ED2FC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829ED300: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829ED304: 419A0044  beq cr6, 0x829ed348
	if ctx.cr[6].eq {
	pc = 0x829ED348; continue 'dispatch;
	}
	// 829ED308: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 829ED30C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829ED310: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 829ED314: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829ED318: 4B827581  bl 0x82214898
	ctx.lr = 0x829ED31C;
	sub_82214898(ctx, base);
	// 829ED31C: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829ED320: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829ED324: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ED328: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 829ED32C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 829ED330: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 829ED334: 4BA68DE5  bl 0x82456118
	ctx.lr = 0x829ED338;
	sub_82456118(ctx, base);
	// 829ED338: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 829ED33C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829ED340: 4B7A6AF9  bl 0x82193e38
	ctx.lr = 0x829ED344;
	sub_82193E38(ctx, base);
	// 829ED344: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	pc = 0x829ED348; continue 'dispatch;
            }
            0x829ED348 => {
    //   block [0x829ED348..0x829ED34C)
	// 829ED348: 83FB6C10  lwz r31, 0x6c10(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27664 as u32) ) } as u64;
	pc = 0x829ED34C; continue 'dispatch;
            }
            0x829ED34C => {
    //   block [0x829ED34C..0x829ED358)
	// 829ED34C: 83BD0004  lwz r29, 4(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ED350: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829ED354: 409AFF6C  bne cr6, 0x829ed2c0
	if !ctx.cr[6].eq {
	pc = 0x829ED2C0; continue 'dispatch;
	}
	pc = 0x829ED358; continue 'dispatch;
            }
            0x829ED358 => {
    //   block [0x829ED358..0x829ED364)
	// 829ED358: 36B5FFFF  addic. r21, r21, -1
	ctx.xer.ca = (ctx.r[21].u32 > (!(-1 as u32)));
	ctx.r[21].s64 = ctx.r[21].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[21].s32, 0, &mut ctx.xer);
	// 829ED35C: 3B390004  addi r25, r25, 4
	ctx.r[25].s64 = ctx.r[25].s64 + 4;
	// 829ED360: 4082FF54  bne 0x829ed2b4
	if !ctx.cr[0].eq {
	pc = 0x829ED2B4; continue 'dispatch;
	}
	pc = 0x829ED364; continue 'dispatch;
            }
            0x829ED364 => {
    //   block [0x829ED364..0x829ED378)
	// 829ED364: 3A940001  addi r20, r20, 1
	ctx.r[20].s64 = ctx.r[20].s64 + 1;
	// 829ED368: 7F147800  cmpw cr6, r20, r15
	ctx.cr[6].compare_i32(ctx.r[20].s32, ctx.r[15].s32, &mut ctx.xer);
	// 829ED36C: 4198FF14  blt cr6, 0x829ed280
	if ctx.cr[6].lt {
	pc = 0x829ED280; continue 'dispatch;
	}
	// 829ED370: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829ED374: 810B6CE4  lwz r8, 0x6ce4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	pc = 0x829ED378; continue 'dispatch;
            }
            0x829ED378 => {
    //   block [0x829ED378..0x829ED394)
	// 829ED378: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829ED37C: 3A310014  addi r17, r17, 0x14
	ctx.r[17].s64 = ctx.r[17].s64 + 20;
	// 829ED380: 3A730010  addi r19, r19, 0x10
	ctx.r[19].s64 = ctx.r[19].s64 + 16;
	// 829ED384: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829ED388: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829ED38C: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 829ED390: 4198FEA4  blt cr6, 0x829ed234
	if ctx.cr[6].lt {
	pc = 0x829ED234; continue 'dispatch;
	}
	pc = 0x829ED394; continue 'dispatch;
            }
            0x829ED394 => {
    //   block [0x829ED394..0x829ED39C)
	// 829ED394: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 829ED398: 482BC088  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829ED3A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829ED3A0 size=224
    let mut pc: u32 = 0x829ED3A0;
    'dispatch: loop {
        match pc {
            0x829ED3A0 => {
    //   block [0x829ED3A0..0x829ED3F0)
	// 829ED3A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829ED3A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829ED3A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829ED3AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829ED3B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829ED3B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829ED3B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829ED3BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829ED3C0: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829ED3C4: 4B81621D  bl 0x822035e0
	ctx.lr = 0x829ED3C8;
	sub_822035E0(ctx, base);
	// 829ED3C8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829ED3CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829ED3D0: 419A0098  beq cr6, 0x829ed468
	if ctx.cr[6].eq {
	pc = 0x829ED468; continue 'dispatch;
	}
	// 829ED3D4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ED3D8: 807E0080  lwz r3, 0x80(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 829ED3DC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829ED3E0: 7F032040  cmplw cr6, r3, r4
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[4].u32, &mut ctx.xer);
	// 829ED3E4: 409A000C  bne cr6, 0x829ed3f0
	if !ctx.cr[6].eq {
	pc = 0x829ED3F0; continue 'dispatch;
	}
	// 829ED3E8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829ED3EC: 48000020  b 0x829ed40c
	pc = 0x829ED40C; continue 'dispatch;
            }
            0x829ED3F0 => {
    //   block [0x829ED3F0..0x829ED408)
	// 829ED3F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829ED3F4: 419A0014  beq cr6, 0x829ed408
	if ctx.cr[6].eq {
	pc = 0x829ED408; continue 'dispatch;
	}
	// 829ED3F8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 829ED3FC: 419A000C  beq cr6, 0x829ed408
	if ctx.cr[6].eq {
	pc = 0x829ED408; continue 'dispatch;
	}
	// 829ED400: 4B880391  bl 0x8226d790
	ctx.lr = 0x829ED404;
	sub_8226D790(ctx, base);
	// 829ED404: 48000008  b 0x829ed40c
	pc = 0x829ED40C; continue 'dispatch;
            }
            0x829ED408 => {
    //   block [0x829ED408..0x829ED40C)
	// 829ED408: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x829ED40C; continue 'dispatch;
            }
            0x829ED40C => {
    //   block [0x829ED40C..0x829ED468)
	// 829ED40C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829ED410: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829ED414: 419A0054  beq cr6, 0x829ed468
	if ctx.cr[6].eq {
	pc = 0x829ED468; continue 'dispatch;
	}
	// 829ED418: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829ED41C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829ED420: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 829ED424: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829ED428: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829ED42C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 829ED430: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829ED434: 4B827465  bl 0x82214898
	ctx.lr = 0x829ED438;
	sub_82214898(ctx, base);
	// 829ED438: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829ED43C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829ED440: 81030004  lwz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ED444: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 829ED448: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 829ED44C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829ED450: 4BA68CC9  bl 0x82456118
	ctx.lr = 0x829ED454;
	sub_82456118(ctx, base);
	// 829ED454: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 829ED458: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829ED45C: 38C70B7C  addi r6, r7, 0xb7c
	ctx.r[6].s64 = ctx.r[7].s64 + 2940;
	// 829ED460: 90C10050  stw r6, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u32 ) };
	// 829ED464: 4B7A69D5  bl 0x82193e38
	ctx.lr = 0x829ED468;
	sub_82193E38(ctx, base);
	pc = 0x829ED468; continue 'dispatch;
            }
            0x829ED468 => {
    //   block [0x829ED468..0x829ED480)
	// 829ED468: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829ED46C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829ED470: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829ED474: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829ED478: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829ED47C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829ED480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829ED480 size=240
    let mut pc: u32 = 0x829ED480;
    'dispatch: loop {
        match pc {
            0x829ED480 => {
    //   block [0x829ED480..0x829ED4F8)
	// 829ED480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829ED484: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829ED488: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829ED48C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829ED490: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829ED494: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829ED498: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829ED49C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829ED4A0: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829ED4A4: 4B81613D  bl 0x822035e0
	ctx.lr = 0x829ED4A8;
	sub_822035E0(ctx, base);
	// 829ED4A8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829ED4AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829ED4B0: 419A00A8  beq cr6, 0x829ed558
	if ctx.cr[6].eq {
	pc = 0x829ED558; continue 'dispatch;
	}
	// 829ED4B4: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ED4B8: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 829ED4BC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829ED4C0: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829ED4C4: 419A0034  beq cr6, 0x829ed4f8
	if ctx.cr[6].eq {
	pc = 0x829ED4F8; continue 'dispatch;
	}
	// 829ED4C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829ED4CC: 80650004  lwz r3, 4(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ED4D0: 4BB23AD1  bl 0x82510fa0
	ctx.lr = 0x829ED4D4;
	sub_82510FA0(ctx, base);
	// 829ED4D4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829ED4D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829ED4DC: 419A001C  beq cr6, 0x829ed4f8
	if ctx.cr[6].eq {
	pc = 0x829ED4F8; continue 'dispatch;
	}
	// 829ED4E0: 80650008  lwz r3, 8(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 829ED4E4: 4B812C05  bl 0x822000e8
	ctx.lr = 0x829ED4E8;
	sub_822000E8(ctx, base);
	// 829ED4E8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829ED4EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829ED4F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829ED4F4: 409A0008  bne cr6, 0x829ed4fc
	if !ctx.cr[6].eq {
	pc = 0x829ED4FC; continue 'dispatch;
	}
	pc = 0x829ED4F8; continue 'dispatch;
            }
            0x829ED4F8 => {
    //   block [0x829ED4F8..0x829ED4FC)
	// 829ED4F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829ED4FC; continue 'dispatch;
            }
            0x829ED4FC => {
    //   block [0x829ED4FC..0x829ED558)
	// 829ED4FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829ED500: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829ED504: 419A0054  beq cr6, 0x829ed558
	if ctx.cr[6].eq {
	pc = 0x829ED558; continue 'dispatch;
	}
	// 829ED508: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829ED50C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829ED510: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 829ED514: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829ED518: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829ED51C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 829ED520: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829ED524: 4B827375  bl 0x82214898
	ctx.lr = 0x829ED528;
	sub_82214898(ctx, base);
	// 829ED528: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829ED52C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829ED530: 81030004  lwz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ED534: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 829ED538: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 829ED53C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829ED540: 4BA68BD9  bl 0x82456118
	ctx.lr = 0x829ED544;
	sub_82456118(ctx, base);
	// 829ED544: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 829ED548: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829ED54C: 38C70B7C  addi r6, r7, 0xb7c
	ctx.r[6].s64 = ctx.r[7].s64 + 2940;
	// 829ED550: 90C10050  stw r6, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u32 ) };
	// 829ED554: 4B7A68E5  bl 0x82193e38
	ctx.lr = 0x829ED558;
	sub_82193E38(ctx, base);
	pc = 0x829ED558; continue 'dispatch;
            }
            0x829ED558 => {
    //   block [0x829ED558..0x829ED570)
	// 829ED558: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829ED55C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829ED560: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829ED564: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829ED568: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829ED56C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829ED570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829ED570 size=156
    let mut pc: u32 = 0x829ED570;
    'dispatch: loop {
        match pc {
            0x829ED570 => {
    //   block [0x829ED570..0x829ED5B4)
	// 829ED570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829ED574: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829ED578: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829ED57C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829ED580: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829ED584: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829ED588: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829ED58C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 829ED590: 394B1324  addi r10, r11, 0x1324
	ctx.r[10].s64 = ctx.r[11].s64 + 4900;
	// 829ED594: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829ED598: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829ED59C: 4B9335ED  bl 0x82320b88
	ctx.lr = 0x829ED5A0;
	sub_82320B88(ctx, base);
	// 829ED5A0: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 829ED5A4: 4B831CB5  bl 0x8221f258
	ctx.lr = 0x829ED5A8;
	sub_8221F258(ctx, base);
	// 829ED5A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829ED5AC: 419A0008  beq cr6, 0x829ed5b4
	if ctx.cr[6].eq {
	pc = 0x829ED5B4; continue 'dispatch;
	}
	// 829ED5B0: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x829ED5B4; continue 'dispatch;
            }
            0x829ED5B4 => {
    //   block [0x829ED5B4..0x829ED5C0)
	// 829ED5B4: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829ED5B8: 41820008  beq 0x829ed5c0
	if ctx.cr[0].eq {
	pc = 0x829ED5C0; continue 'dispatch;
	}
	// 829ED5BC: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x829ED5C0; continue 'dispatch;
            }
            0x829ED5C0 => {
    //   block [0x829ED5C0..0x829ED60C)
	// 829ED5C0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829ED5C4: 907F0014  stw r3, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 829ED5C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829ED5CC: 392A9484  addi r9, r10, -0x6b7c
	ctx.r[9].s64 = ctx.r[10].s64 + -27516;
	// 829ED5D0: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 829ED5D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829ED5D8: 93DF003C  stw r30, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[30].u32 ) };
	// 829ED5DC: C00A9484  lfs f0, -0x6b7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829ED5E0: 997F0024  stb r11, 0x24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 829ED5E4: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 829ED5E8: 997F0038  stb r11, 0x38(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u8 ) };
	// 829ED5EC: C009FE44  lfs f0, -0x1bc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-444 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829ED5F0: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 829ED5F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829ED5F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829ED5FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829ED600: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829ED604: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829ED608: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829ED610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829ED610 size=104
    let mut pc: u32 = 0x829ED610;
    'dispatch: loop {
        match pc {
            0x829ED610 => {
    //   block [0x829ED610..0x829ED660)
	// 829ED610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829ED614: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829ED618: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829ED61C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829ED620: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829ED624: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829ED628: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829ED62C: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 829ED630: 4BC4D059  bl 0x8263a688
	ctx.lr = 0x829ED634;
	sub_8263A688(ctx, base);
	// 829ED634: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 829ED638: 4BC4D051  bl 0x8263a688
	ctx.lr = 0x829ED63C;
	sub_8263A688(ctx, base);
	// 829ED63C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829ED640: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 829ED644: 392B2B90  addi r9, r11, 0x2b90
	ctx.r[9].s64 = ctx.r[11].s64 + 11152;
	// 829ED648: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829ED64C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829ED650: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829ED654: 419A000C  beq cr6, 0x829ed660
	if ctx.cr[6].eq {
	pc = 0x829ED660; continue 'dispatch;
	}
	// 829ED658: 4B82E6E1  bl 0x8221bd38
	ctx.lr = 0x829ED65C;
	sub_8221BD38(ctx, base);
	// 829ED65C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x829ED660; continue 'dispatch;
            }
            0x829ED660 => {
    //   block [0x829ED660..0x829ED678)
	// 829ED660: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829ED664: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829ED668: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829ED66C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829ED670: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829ED674: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829ED678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829ED678 size=272
    let mut pc: u32 = 0x829ED678;
    'dispatch: loop {
        match pc {
            0x829ED678 => {
    //   block [0x829ED678..0x829ED730)
	// 829ED678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829ED67C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829ED680: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829ED684: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829ED688: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829ED68C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 829ED690: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 829ED694: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ED698: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829ED69C: 419A0094  beq cr6, 0x829ed730
	if ctx.cr[6].eq {
	pc = 0x829ED730; continue 'dispatch;
	}
	// 829ED6A0: 894B000A  lbz r10, 0xa(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(10 as u32) ) } as u64;
	// 829ED6A4: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 829ED6A8: 409A0088  bne cr6, 0x829ed730
	if !ctx.cr[6].eq {
	pc = 0x829ED730; continue 'dispatch;
	}
	// 829ED6AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829ED6B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829ED6B4: 419A007C  beq cr6, 0x829ed730
	if ctx.cr[6].eq {
	pc = 0x829ED730; continue 'dispatch;
	}
	// 829ED6B8: 39400060  li r10, 0x60
	ctx.r[10].s64 = 96;
	// 829ED6BC: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 829ED6C0: 392000A0  li r9, 0xa0
	ctx.r[9].s64 = 160;
	// 829ED6C4: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 829ED6C8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	pc = 0x829ED730; continue 'dispatch;
            }
            0x829ED730 => {
    //   block [0x829ED730..0x829ED788)
	// 829ED730: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829ED734: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829ED738: 48000309  bl 0x829eda40
	ctx.lr = 0x829ED73C;
	sub_829EDA40(ctx, base);
	// 829ED73C: C1BF002C  lfs f13, 0x2c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829ED740: C181005C  lfs f12, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829ED744: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829ED748: C1610054  lfs f11, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829ED74C: C15F0034  lfs f10, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 829ED750: ED2B6028  fsubs f9, f11, f12
	ctx.f[9].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 829ED754: ED0D5028  fsubs f8, f13, f10
	ctx.f[8].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 829ED758: C00B9484  lfs f0, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829ED75C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829ED760: ECE94028  fsubs f7, f9, f8
	ctx.f[7].f64 = (((ctx.f[9].f64 - ctx.f[8].f64) as f32) as f64);
	// 829ED764: FF070000  fcmpu cr6, f7, f0
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[0].f64);
	// 829ED768: 40990008  ble cr6, 0x829ed770
	if !ctx.cr[6].gt {
	pc = 0x829ED770; continue 'dispatch;
	}
	// 829ED76C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829ED770: 997F0024  stb r11, 0x24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 829ED774: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829ED778: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829ED77C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829ED780: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829ED784: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829ED788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829ED788 size=440
    let mut pc: u32 = 0x829ED788;
    'dispatch: loop {
        match pc {
            0x829ED788 => {
    //   block [0x829ED788..0x829ED7E8)
	// 829ED788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829ED78C: 482BBC79  bl 0x82ca9404
	ctx.lr = 0x829ED790;
	sub_82CA93D0(ctx, base);
	// 829ED790: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 829ED794: 482C0545  bl 0x82cadcd8
	ctx.lr = 0x829ED798;
	sub_82CADCA0(ctx, base);
	// 829ED798: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829ED79C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829ED7A0: F88100C8  std r4, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[4].u64 ) };
	// 829ED7A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829ED7A8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829ED7AC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 829ED7B0: 48000291  bl 0x829eda40
	ctx.lr = 0x829ED7B4;
	sub_829EDA40(ctx, base);
	// 829ED7B4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829ED7B8: C00100CC  lfs f0, 0xcc(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829ED7BC: 3B6B9490  addi r27, r11, -0x6b70
	ctx.r[27].s64 = ctx.r[11].s64 + -27504;
	// 829ED7C0: C3DBFFF4  lfs f30, -0xc(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-12 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829ED7C4: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 829ED7C8: C3A10054  lfs f29, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 829ED7CC: C381005C  lfs f28, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 829ED7D0: 40990018  ble cr6, 0x829ed7e8
	if !ctx.cr[6].gt {
	pc = 0x829ED7E8; continue 'dispatch;
	}
	// 829ED7D4: EDA0E02A  fadds f13, f0, f28
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[28].f64) as f32) as f64;
	// 829ED7D8: C19D0034  lfs f12, 0x34(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829ED7DC: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 829ED7E0: 4198001C  blt cr6, 0x829ed7fc
	if ctx.cr[6].lt {
	pc = 0x829ED7FC; continue 'dispatch;
	}
	// 829ED7E4: 48000014  b 0x829ed7f8
	pc = 0x829ED7F8; continue 'dispatch;
            }
            0x829ED7E8 => {
    //   block [0x829ED7E8..0x829ED7F8)
	// 829ED7E8: EDA0E82A  fadds f13, f0, f29
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 829ED7EC: C19D002C  lfs f12, 0x2c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829ED7F0: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 829ED7F4: 41990008  bgt cr6, 0x829ed7fc
	if ctx.cr[6].gt {
	pc = 0x829ED7FC; continue 'dispatch;
	}
	pc = 0x829ED7F8; continue 'dispatch;
            }
            0x829ED7F8 => {
    //   block [0x829ED7F8..0x829ED7FC)
	// 829ED7F8: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	pc = 0x829ED7FC; continue 'dispatch;
            }
            0x829ED7FC => {
    //   block [0x829ED7FC..0x829ED80C)
	// 829ED7FC: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 829ED800: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	// 829ED804: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 829ED808: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829ED80C; continue 'dispatch;
            }
            0x829ED80C => {
    //   block [0x829ED80C..0x829ED81C)
	// 829ED80C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ED810: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829ED814: 419A0008  beq cr6, 0x829ed81c
	if ctx.cr[6].eq {
	pc = 0x829ED81C; continue 'dispatch;
	}
	// 829ED818: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829ED81C; continue 'dispatch;
            }
            0x829ED81C => {
    //   block [0x829ED81C..0x829ED834)
	// 829ED81C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829ED820: 419A0078  beq cr6, 0x829ed898
	if ctx.cr[6].eq {
	pc = 0x829ED898; continue 'dispatch;
	}
	// 829ED824: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ED828: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829ED82C: 409A0008  bne cr6, 0x829ed834
	if !ctx.cr[6].eq {
	pc = 0x829ED834; continue 'dispatch;
	}
	// 829ED830: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829ED834; continue 'dispatch;
            }
            0x829ED834 => {
    //   block [0x829ED834..0x829ED874)
	// 829ED834: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829ED838: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829ED83C: 4BA37AAD  bl 0x824252e8
	ctx.lr = 0x829ED840;
	sub_824252E8(ctx, base);
	// 829ED840: C01D001C  lfs f0, 0x1c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829ED844: EDA007F2  fmuls f13, f0, f31
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 829ED848: C1810054  lfs f12, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829ED84C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ED850: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829ED854: EC4C682A  fadds f2, f12, f13
	ctx.f[2].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 829ED858: D0410054  stfs f2, 0x54(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829ED85C: C0210050  lfs f1, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829ED860: C0610058  lfs f3, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 829ED864: D0210050  stfs f1, 0x50(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829ED868: D0610058  stfs f3, 0x58(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829ED86C: 409A0008  bne cr6, 0x829ed874
	if !ctx.cr[6].eq {
	pc = 0x829ED874; continue 'dispatch;
	}
	// 829ED870: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829ED874; continue 'dispatch;
            }
            0x829ED874 => {
    //   block [0x829ED874..0x829ED890)
	// 829ED874: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829ED878: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829ED87C: 4BA37965  bl 0x824251e0
	ctx.lr = 0x829ED880;
	sub_824251E0(ctx, base);
	// 829ED880: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ED884: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829ED888: 409A0008  bne cr6, 0x829ed890
	if !ctx.cr[6].eq {
	pc = 0x829ED890; continue 'dispatch;
	}
	// 829ED88C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829ED890; continue 'dispatch;
            }
            0x829ED890 => {
    //   block [0x829ED890..0x829ED898)
	// 829ED890: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829ED894: 4BFFFF78  b 0x829ed80c
	pc = 0x829ED80C; continue 'dispatch;
            }
            0x829ED898 => {
    //   block [0x829ED898..0x829ED91C)
	// 829ED898: C01D002C  lfs f0, 0x2c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829ED89C: EDBDE028  fsubs f13, f29, f28
	ctx.f[13].f64 = (((ctx.f[29].f64 - ctx.f[28].f64) as f32) as f64);
	// 829ED8A0: C19D0034  lfs f12, 0x34(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829ED8A4: ED606028  fsubs f11, f0, f12
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 829ED8A8: EDAD5828  fsubs f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 829ED8AC: FF0DF000  fcmpu cr6, f13, f30
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[30].f64);
	// 829ED8B0: 4099006C  ble cr6, 0x829ed91c
	if !ctx.cr[6].gt {
	pc = 0x829ED91C; continue 'dispatch;
	}
	// 829ED8B4: ED9D0028  fsubs f12, f29, f0
	ctx.f[12].f64 = (((ctx.f[29].f64 - ctx.f[0].f64) as f32) as f64);
	// 829ED8B8: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 829ED8BC: C01B0000  lfs f0, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829ED8C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829ED8C4: 392A0E68  addi r9, r10, 0xe68
	ctx.r[9].s64 = ctx.r[10].s64 + 3688;
	// 829ED8C8: 997D0038  stb r11, 0x38(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(56 as u32), ctx.r[11].u8 ) };
	// 829ED8CC: 397D0020  addi r11, r29, 0x20
	ctx.r[11].s64 = ctx.r[29].s64 + 32;
	// 829ED8D0: ED6C6824  fdivs f11, f12, f13
	ctx.f[11].f64 = ((ctx.f[12].f64 / ctx.f[13].f64) as f32) as f64;
	// 829ED8D4: D17D0020  stfs f11, 0x20(r29)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 829ED8D8: FD405890  fmr f10, f11
	ctx.f[10].f64 = ctx.f[11].f64;
	// 829ED8DC: FF0AF000  fcmpu cr6, f10, f30
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[30].f64);
	// 829ED8E0: 7D000026  mfcr r8
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[8].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 829ED8E4: 5507DF7A  rlwinm r7, r8, 0x1b, 0x1d, 0x1d
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 829ED8E8: 5506F77A  rlwinm r6, r8, 0x1e, 0x1d, 0x1d
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x00000003u64;
	// 829ED8EC: 7CE53378  or r5, r7, r6
	ctx.r[5].u64 = ctx.r[7].u64 | ctx.r[6].u64;
	// 829ED8F0: 7D292C2E  lfsx f9, r9, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 829ED8F4: FD09F2AE  fsel f8, f9, f10, f30
	ctx.f[8].f64 = if ctx.f[9].f64 >= 0.0 { ctx.f[10].f64 } else { ctx.f[30].f64 };
	// 829ED8F8: ECE80028  fsubs f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 - ctx.f[0].f64) as f32) as f64);
	// 829ED8FC: FF07F000  fcmpu cr6, f7, f30
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[30].f64);
	// 829ED900: 7C800026  mfcr r4
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[4].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 829ED904: 5483DF7A  rlwinm r3, r4, 0x1b, 0x1d, 0x1d
	ctx.r[3].u64 = ctx.r[4].u32 as u64 & 0x0000001Fu64;
	// 829ED908: 548BF77A  rlwinm r11, r4, 0x1e, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000003u64;
	// 829ED90C: 7C6A5B78  or r10, r3, r11
	ctx.r[10].u64 = ctx.r[3].u64 | ctx.r[11].u64;
	// 829ED910: 7CC9542E  lfsx f6, r9, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 829ED914: FCA6402E  fsel f5, f6, f0, f8
	ctx.f[5].f64 = if ctx.f[6].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[8].f64 };
	// 829ED918: D0BD0020  stfs f5, 0x20(r29)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), tmp.u32 ) };
	pc = 0x829ED91C; continue 'dispatch;
            }
            0x829ED91C => {
    //   block [0x829ED91C..0x829ED92C)
	// 829ED91C: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 829ED920: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829ED924: 409A0008  bne cr6, 0x829ed92c
	if !ctx.cr[6].eq {
	pc = 0x829ED92C; continue 'dispatch;
	}
	// 829ED928: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829ED92C; continue 'dispatch;
            }
            0x829ED92C => {
    //   block [0x829ED92C..0x829ED940)
	// 829ED92C: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829ED930: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 829ED934: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 829ED938: 482C03ED  bl 0x82cadd24
	ctx.lr = 0x829ED93C;
	sub_82CADCEC(ctx, base);
	// 829ED93C: 482BBB18  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829ED940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829ED940 size=256
    let mut pc: u32 = 0x829ED940;
    'dispatch: loop {
        match pc {
            0x829ED940 => {
    //   block [0x829ED940..0x829ED994)
	// 829ED940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829ED944: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829ED948: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829ED94C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829ED950: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829ED954: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829ED958: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829ED95C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 829ED960: 93C1009C  stw r30, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[30].u32 ) };
	// 829ED964: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 829ED968: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829ED96C: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 829ED970: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 829ED974: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829ED978: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829ED97C: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829ED980: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 829ED984: E9010060  ld r8, 0x60(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 829ED988: F9010060  std r8, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u64 ) };
	// 829ED98C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829ED990: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	pc = 0x829ED994; continue 'dispatch;
            }
            0x829ED994 => {
    //   block [0x829ED994..0x829ED9B0)
	// 829ED994: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829ED998: 419A0018  beq cr6, 0x829ed9b0
	if ctx.cr[6].eq {
	pc = 0x829ED9B0; continue 'dispatch;
	}
	// 829ED99C: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829ED9A0: 7F09F040  cmplw cr6, r9, r30
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829ED9A4: 419A000C  beq cr6, 0x829ed9b0
	if ctx.cr[6].eq {
	pc = 0x829ED9B0; continue 'dispatch;
	}
	// 829ED9A8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829ED9AC: 4BFFFFE8  b 0x829ed994
	pc = 0x829ED994; continue 'dispatch;
            }
            0x829ED9B0 => {
    //   block [0x829ED9B0..0x829ED9C0)
	// 829ED9B0: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 829ED9B4: 7F035040  cmplw cr6, r3, r10
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829ED9B8: 419A0008  beq cr6, 0x829ed9c0
	if ctx.cr[6].eq {
	pc = 0x829ED9C0; continue 'dispatch;
	}
	// 829ED9BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829ED9C0; continue 'dispatch;
            }
            0x829ED9C0 => {
    //   block [0x829ED9C0..0x829ED9D8)
	// 829ED9C0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829ED9C4: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ED9C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829ED9CC: 419A000C  beq cr6, 0x829ed9d8
	if ctx.cr[6].eq {
	pc = 0x829ED9D8; continue 'dispatch;
	}
	// 829ED9D0: 7F0A1840  cmplw cr6, r10, r3
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[3].u32, &mut ctx.xer);
	// 829ED9D4: 419A0008  beq cr6, 0x829ed9dc
	if ctx.cr[6].eq {
	pc = 0x829ED9DC; continue 'dispatch;
	}
	pc = 0x829ED9D8; continue 'dispatch;
            }
            0x829ED9D8 => {
    //   block [0x829ED9D8..0x829ED9DC)
	// 829ED9D8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829ED9DC; continue 'dispatch;
            }
            0x829ED9DC => {
    //   block [0x829ED9DC..0x829EDA28)
	// 829ED9DC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 829ED9E0: 409A0048  bne cr6, 0x829eda28
	if !ctx.cr[6].eq {
	pc = 0x829EDA28; continue 'dispatch;
	}
	// 829ED9E4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ED9E8: 38A1009C  addi r5, r1, 0x9c
	ctx.r[5].s64 = ctx.r[1].s64 + 156;
	// 829ED9EC: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 829ED9F0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 829ED9F4: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 829ED9F8: 480A9971  bl 0x82a97368
	ctx.lr = 0x829ED9FC;
	sub_82A97368(ctx, base);
	// 829ED9FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829EDA00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EDA04: 4BA378E5  bl 0x824252e8
	ctx.lr = 0x829EDA08;
	sub_824252E8(ctx, base);
	// 829EDA08: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 829EDA0C: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 829EDA10: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829EDA14: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 829EDA18: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 829EDA1C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 829EDA20: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 829EDA24: 48000765  bl 0x829ee188
	ctx.lr = 0x829EDA28;
	sub_829EE188(ctx, base);
	pc = 0x829EDA28; continue 'dispatch;
            }
            0x829EDA28 => {
    //   block [0x829EDA28..0x829EDA40)
	// 829EDA28: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829EDA2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EDA30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EDA34: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EDA38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EDA3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EDA40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EDA40 size=392
    let mut pc: u32 = 0x829EDA40;
    'dispatch: loop {
        match pc {
            0x829EDA40 => {
    //   block [0x829EDA40..0x829EDA74)
	// 829EDA40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EDA44: 482BB9B9  bl 0x82ca93fc
	ctx.lr = 0x829EDA48;
	sub_82CA93D0(ctx, base);
	// 829EDA48: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 829EDA4C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EDA50: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EDA54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EDA58: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 829EDA5C: 3B840004  addi r28, r4, 4
	ctx.r[28].s64 = ctx.r[4].s64 + 4;
	// 829EDA60: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 829EDA64: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EDA68: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EDA6C: 3B2B9484  addi r25, r11, -0x6b7c
	ctx.r[25].s64 = ctx.r[11].s64 + -27516;
	// 829EDA70: C3EB9484  lfs f31, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x829EDA74; continue 'dispatch;
            }
            0x829EDA74 => {
    //   block [0x829EDA74..0x829EDA84)
	// 829EDA74: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EDA78: 7F1CE040  cmplw cr6, r28, r28
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[28].u32, &mut ctx.xer);
	// 829EDA7C: 419A0008  beq cr6, 0x829eda84
	if ctx.cr[6].eq {
	pc = 0x829EDA84; continue 'dispatch;
	}
	// 829EDA80: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829EDA84; continue 'dispatch;
            }
            0x829EDA84 => {
    //   block [0x829EDA84..0x829EDA9C)
	// 829EDA84: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829EDA88: 419A0130  beq cr6, 0x829edbb8
	if ctx.cr[6].eq {
	pc = 0x829EDBB8; continue 'dispatch;
	}
	// 829EDA8C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EDA90: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829EDA94: 409A0008  bne cr6, 0x829eda9c
	if !ctx.cr[6].eq {
	pc = 0x829EDA9C; continue 'dispatch;
	}
	// 829EDA98: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829EDA9C; continue 'dispatch;
            }
            0x829EDA9C => {
    //   block [0x829EDA9C..0x829EDAC4)
	// 829EDA9C: 83FD0008  lwz r31, 8(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EDAA0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829EDAA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EDAA8: 4B8968C1  bl 0x82284368
	ctx.lr = 0x829EDAAC;
	sub_82284368(ctx, base);
	// 829EDAAC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EDAB0: 419A0014  beq cr6, 0x829edac4
	if ctx.cr[6].eq {
	pc = 0x829EDAC4; continue 'dispatch;
	}
	// 829EDAB4: C01921CC  lfs f0, 0x21cc(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8652 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EDAB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829EDABC: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 829EDAC0: 41990008  bgt cr6, 0x829edac8
	if ctx.cr[6].gt {
	pc = 0x829EDAC8; continue 'dispatch;
	}
	pc = 0x829EDAC4; continue 'dispatch;
            }
            0x829EDAC4 => {
    //   block [0x829EDAC4..0x829EDAC8)
	// 829EDAC4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829EDAC8; continue 'dispatch;
            }
            0x829EDAC8 => {
    //   block [0x829EDAC8..0x829EDAF8)
	// 829EDAC8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829EDACC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EDAD0: 419A0028  beq cr6, 0x829edaf8
	if ctx.cr[6].eq {
	pc = 0x829EDAF8; continue 'dispatch;
	}
	// 829EDAD4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 829EDAD8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EDADC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EDAE0: 4BA39771  bl 0x82427250
	ctx.lr = 0x829EDAE4;
	sub_82427250(ctx, base);
	// 829EDAE4: C141005C  lfs f10, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 829EDAE8: C1610058  lfs f11, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829EDAEC: C1810054  lfs f12, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829EDAF0: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EDAF4: 48000024  b 0x829edb18
	pc = 0x829EDB18; continue 'dispatch;
            }
            0x829EDAF8 => {
    //   block [0x829EDAF8..0x829EDB18)
	// 829EDAF8: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 829EDAFC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829EDB00: FD80F890  fmr f12, f31
	ctx.f[12].f64 = ctx.f[31].f64;
	// 829EDB04: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829EDB08: FD60F890  fmr f11, f31
	ctx.f[11].f64 = ctx.f[31].f64;
	// 829EDB0C: D1610058  stfs f11, 0x58(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829EDB10: FD40F890  fmr f10, f31
	ctx.f[10].f64 = ctx.f[31].f64;
	// 829EDB14: D141005C  stfs f10, 0x5c(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	pc = 0x829EDB18; continue 'dispatch;
            }
            0x829EDB18 => {
    //   block [0x829EDB18..0x829EDB50)
	// 829EDB18: 574B063E  clrlwi r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 829EDB1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EDB20: 419A0030  beq cr6, 0x829edb50
	if ctx.cr[6].eq {
	pc = 0x829EDB50; continue 'dispatch;
	}
	// 829EDB24: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829EDB28: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 829EDB2C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EDB30: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EDB34: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EDB38: 80EB000C  lwz r7, 0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 829EDB3C: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829EDB40: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 829EDB44: 911E0008  stw r8, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 829EDB48: 90FE000C  stw r7, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 829EDB4C: 48000054  b 0x829edba0
	pc = 0x829EDBA0; continue 'dispatch;
            }
            0x829EDB50 => {
    //   block [0x829EDB50..0x829EDB60)
	// 829EDB50: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829EDB54: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829EDB58: 41980008  blt cr6, 0x829edb60
	if ctx.cr[6].lt {
	pc = 0x829EDB60; continue 'dispatch;
	}
	// 829EDB5C: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x829EDB60; continue 'dispatch;
            }
            0x829EDB60 => {
    //   block [0x829EDB60..0x829EDB74)
	// 829EDB60: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829EDB64: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EDB68: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 829EDB6C: 40990008  ble cr6, 0x829edb74
	if !ctx.cr[6].gt {
	pc = 0x829EDB74; continue 'dispatch;
	}
	// 829EDB70: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	pc = 0x829EDB74; continue 'dispatch;
            }
            0x829EDB74 => {
    //   block [0x829EDB74..0x829EDB88)
	// 829EDB74: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829EDB78: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EDB7C: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 829EDB80: 40990008  ble cr6, 0x829edb88
	if !ctx.cr[6].gt {
	pc = 0x829EDB88; continue 'dispatch;
	}
	// 829EDB84: FC005890  fmr f0, f11
	ctx.f[0].f64 = ctx.f[11].f64;
	pc = 0x829EDB88; continue 'dispatch;
            }
            0x829EDB88 => {
    //   block [0x829EDB88..0x829EDB9C)
	// 829EDB88: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829EDB8C: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EDB90: FF0A0000  fcmpu cr6, f10, f0
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[0].f64);
	// 829EDB94: 40980008  bge cr6, 0x829edb9c
	if !ctx.cr[6].lt {
	pc = 0x829EDB9C; continue 'dispatch;
	}
	// 829EDB98: FC005090  fmr f0, f10
	ctx.f[0].f64 = ctx.f[10].f64;
	pc = 0x829EDB9C; continue 'dispatch;
            }
            0x829EDB9C => {
    //   block [0x829EDB9C..0x829EDBA0)
	// 829EDB9C: D01E000C  stfs f0, 0xc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x829EDBA0; continue 'dispatch;
            }
            0x829EDBA0 => {
    //   block [0x829EDBA0..0x829EDBB0)
	// 829EDBA0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EDBA4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829EDBA8: 409A0008  bne cr6, 0x829edbb0
	if !ctx.cr[6].eq {
	pc = 0x829EDBB0; continue 'dispatch;
	}
	// 829EDBAC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829EDBB0; continue 'dispatch;
            }
            0x829EDBB0 => {
    //   block [0x829EDBB0..0x829EDBB8)
	// 829EDBB0: 83BD0000  lwz r29, 0(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EDBB4: 4BFFFEC0  b 0x829eda74
	pc = 0x829EDA74; continue 'dispatch;
            }
            0x829EDBB8 => {
    //   block [0x829EDBB8..0x829EDBC8)
	// 829EDBB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EDBBC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 829EDBC0: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 829EDBC4: 482BB888  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EDBC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EDBC8 size=544
    let mut pc: u32 = 0x829EDBC8;
    'dispatch: loop {
        match pc {
            0x829EDBC8 => {
    //   block [0x829EDBC8..0x829EDC1C)
	// 829EDBC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EDBCC: 482BB82D  bl 0x82ca93f8
	ctx.lr = 0x829EDBD0;
	sub_82CA93D0(ctx, base);
	// 829EDBD0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EDBD4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829EDBD8: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 829EDBDC: 93C100FC  stw r30, 0xfc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), ctx.r[30].u32 ) };
	// 829EDBE0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 829EDBE4: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 829EDBE8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829EDBEC: 409A00F4  bne cr6, 0x829edce0
	if !ctx.cr[6].eq {
	pc = 0x829EDCE0; continue 'dispatch;
	}
	// 829EDBF0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EDBF4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829EDBF8: 806B6B08  lwz r3, 0x6b08(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27400 as u32) ) } as u64;
	// 829EDBFC: 4B9849FD  bl 0x823725f8
	ctx.lr = 0x829EDC00;
	sub_823725F8(ctx, base);
	// 829EDC00: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829EDC04: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829EDC08: 419A01D8  beq cr6, 0x829edde0
	if ctx.cr[6].eq {
	pc = 0x829EDDE0; continue 'dispatch;
	}
	// 829EDC0C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EDC10: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EDC14: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829EDC18: 3B4BE3C4  addi r26, r11, -0x1c3c
	ctx.r[26].s64 = ctx.r[11].s64 + -7228;
	pc = 0x829EDC1C; continue 'dispatch;
            }
            0x829EDC1C => {
    //   block [0x829EDC1C..0x829EDC38)
	// 829EDC1C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EDC20: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829EDC24: 419A01BC  beq cr6, 0x829edde0
	if ctx.cr[6].eq {
	pc = 0x829EDDE0; continue 'dispatch;
	}
	// 829EDC28: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EDC2C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829EDC30: 409A0008  bne cr6, 0x829edc38
	if !ctx.cr[6].eq {
	pc = 0x829EDC38; continue 'dispatch;
	}
	// 829EDC34: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829EDC38; continue 'dispatch;
            }
            0x829EDC38 => {
    //   block [0x829EDC38..0x829EDC68)
	// 829EDC38: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 829EDC3C: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EDC40: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 829EDC44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EDC48: 3BBE0008  addi r29, r30, 8
	ctx.r[29].s64 = ctx.r[30].s64 + 8;
	// 829EDC4C: 4BA373ED  bl 0x82425038
	ctx.lr = 0x829EDC50;
	sub_82425038(ctx, base);
	// 829EDC50: 80990000  lwz r4, 0(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EDC54: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EDC58: 7F032040  cmplw cr6, r3, r4
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[4].u32, &mut ctx.xer);
	// 829EDC5C: 409A000C  bne cr6, 0x829edc68
	if !ctx.cr[6].eq {
	pc = 0x829EDC68; continue 'dispatch;
	}
	// 829EDC60: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 829EDC64: 48000024  b 0x829edc88
	pc = 0x829EDC88; continue 'dispatch;
            }
            0x829EDC68 => {
    //   block [0x829EDC68..0x829EDC84)
	// 829EDC68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EDC6C: 419A0018  beq cr6, 0x829edc84
	if ctx.cr[6].eq {
	pc = 0x829EDC84; continue 'dispatch;
	}
	// 829EDC70: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 829EDC74: 419A0010  beq cr6, 0x829edc84
	if ctx.cr[6].eq {
	pc = 0x829EDC84; continue 'dispatch;
	}
	// 829EDC78: 4B87FB19  bl 0x8226d790
	ctx.lr = 0x829EDC7C;
	sub_8226D790(ctx, base);
	// 829EDC7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EDC80: 48000008  b 0x829edc88
	pc = 0x829EDC88; continue 'dispatch;
            }
            0x829EDC84 => {
    //   block [0x829EDC84..0x829EDC88)
	// 829EDC84: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x829EDC88; continue 'dispatch;
            }
            0x829EDC88 => {
    //   block [0x829EDC88..0x829EDCAC)
	// 829EDC88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EDC8C: 4B82714D  bl 0x82214dd8
	ctx.lr = 0x829EDC90;
	sub_82214DD8(ctx, base);
	// 829EDC90: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 829EDC94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EDC98: 419A0030  beq cr6, 0x829edcc8
	if ctx.cr[6].eq {
	pc = 0x829EDCC8; continue 'dispatch;
	}
	// 829EDC9C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EDCA0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829EDCA4: 409A0008  bne cr6, 0x829edcac
	if !ctx.cr[6].eq {
	pc = 0x829EDCAC; continue 'dispatch;
	}
	// 829EDCA8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829EDCAC; continue 'dispatch;
            }
            0x829EDCAC => {
    //   block [0x829EDCAC..0x829EDCC8)
	// 829EDCAC: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EDCB0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829EDCB4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829EDCB8: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 829EDCBC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829EDCC0: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829EDCC4: 480A96A5  bl 0x82a97368
	ctx.lr = 0x829EDCC8;
	sub_82A97368(ctx, base);
	pc = 0x829EDCC8; continue 'dispatch;
            }
            0x829EDCC8 => {
    //   block [0x829EDCC8..0x829EDCD8)
	// 829EDCC8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EDCCC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829EDCD0: 409A0008  bne cr6, 0x829edcd8
	if !ctx.cr[6].eq {
	pc = 0x829EDCD8; continue 'dispatch;
	}
	// 829EDCD4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829EDCD8; continue 'dispatch;
            }
            0x829EDCD8 => {
    //   block [0x829EDCD8..0x829EDCE0)
	// 829EDCD8: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EDCDC: 4BFFFF40  b 0x829edc1c
	pc = 0x829EDC1C; continue 'dispatch;
            }
            0x829EDCE0 => {
    //   block [0x829EDCE0..0x829EDD10)
	// 829EDCE0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829EDCE4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 829EDCE8: 38CBE3C4  addi r6, r11, -0x1c3c
	ctx.r[6].s64 = ctx.r[11].s64 + -7228;
	// 829EDCEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829EDCF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EDCF4: 4BA37345  bl 0x82425038
	ctx.lr = 0x829EDCF8;
	sub_82425038(ctx, base);
	// 829EDCF8: 80990000  lwz r4, 0(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EDCFC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EDD00: 7F032040  cmplw cr6, r3, r4
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[4].u32, &mut ctx.xer);
	// 829EDD04: 409A000C  bne cr6, 0x829edd10
	if !ctx.cr[6].eq {
	pc = 0x829EDD10; continue 'dispatch;
	}
	// 829EDD08: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 829EDD0C: 48000024  b 0x829edd30
	pc = 0x829EDD30; continue 'dispatch;
            }
            0x829EDD10 => {
    //   block [0x829EDD10..0x829EDD2C)
	// 829EDD10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EDD14: 419A0018  beq cr6, 0x829edd2c
	if ctx.cr[6].eq {
	pc = 0x829EDD2C; continue 'dispatch;
	}
	// 829EDD18: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 829EDD1C: 419A0010  beq cr6, 0x829edd2c
	if ctx.cr[6].eq {
	pc = 0x829EDD2C; continue 'dispatch;
	}
	// 829EDD20: 4B87FA71  bl 0x8226d790
	ctx.lr = 0x829EDD24;
	sub_8226D790(ctx, base);
	// 829EDD24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EDD28: 48000008  b 0x829edd30
	pc = 0x829EDD30; continue 'dispatch;
            }
            0x829EDD2C => {
    //   block [0x829EDD2C..0x829EDD30)
	// 829EDD2C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x829EDD30; continue 'dispatch;
            }
            0x829EDD30 => {
    //   block [0x829EDD30..0x829EDD60)
	// 829EDD30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EDD34: 4B8270A5  bl 0x82214dd8
	ctx.lr = 0x829EDD38;
	sub_82214DD8(ctx, base);
	// 829EDD38: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 829EDD3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EDD40: 419A0020  beq cr6, 0x829edd60
	if ctx.cr[6].eq {
	pc = 0x829EDD60; continue 'dispatch;
	}
	// 829EDD44: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EDD48: 38A100FC  addi r5, r1, 0xfc
	ctx.r[5].s64 = ctx.r[1].s64 + 252;
	// 829EDD4C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829EDD50: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 829EDD54: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829EDD58: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829EDD5C: 480A960D  bl 0x82a97368
	ctx.lr = 0x829EDD60;
	sub_82A97368(ctx, base);
	pc = 0x829EDD60; continue 'dispatch;
            }
            0x829EDD60 => {
    //   block [0x829EDD60..0x829EDDA8)
	// 829EDD60: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EDD64: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829EDD68: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829EDD6C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EDD70: C02BBE40  lfs f1, -0x41c0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16832 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829EDD74: 4BA397DD  bl 0x82427550
	ctx.lr = 0x829EDD78;
	sub_82427550(ctx, base);
	// 829EDD78: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 829EDD7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829EDD80: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EDD84: 4BA38B15  bl 0x82426898
	ctx.lr = 0x829EDD88;
	sub_82426898(ctx, base);
	// 829EDD88: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EDD8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829EDD90: 419A0044  beq cr6, 0x829eddd4
	if ctx.cr[6].eq {
	pc = 0x829EDDD4; continue 'dispatch;
	}
	// 829EDD94: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 829EDD98: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829EDD9C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EDDA0: 40990034  ble cr6, 0x829eddd4
	if !ctx.cr[6].gt {
	pc = 0x829EDDD4; continue 'dispatch;
	}
	// 829EDDA4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x829EDDA8; continue 'dispatch;
            }
            0x829EDDA8 => {
    //   block [0x829EDDA8..0x829EDDD4)
	// 829EDDA8: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 829EDDAC: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 829EDDB0: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 829EDDB4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 829EDDB8: 7C9F582E  lwzx r4, r31, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829EDDBC: 4BFFFE0D  bl 0x829edbc8
	ctx.lr = 0x829EDDC0;
	sub_829EDBC8(ctx, base);
	// 829EDDC0: 81410088  lwz r10, 0x88(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 829EDDC4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 829EDDC8: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 829EDDCC: 7F1E5000  cmpw cr6, r30, r10
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[10].s32, &mut ctx.xer);
	// 829EDDD0: 4198FFD8  blt cr6, 0x829edda8
	if ctx.cr[6].lt {
	pc = 0x829EDDA8; continue 'dispatch;
	}
	pc = 0x829EDDD4; continue 'dispatch;
            }
            0x829EDDD4 => {
    //   block [0x829EDDD4..0x829EDDE0)
	// 829EDDD4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829EDDD8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EDDDC: 481C570D  bl 0x82bb34e8
	ctx.lr = 0x829EDDE0;
	sub_82BB34E8(ctx, base);
	pc = 0x829EDDE0; continue 'dispatch;
            }
            0x829EDDE0 => {
    //   block [0x829EDDE0..0x829EDDE8)
	// 829EDDE0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 829EDDE4: 482BB664  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EDDE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EDDE8 size=232
    let mut pc: u32 = 0x829EDDE8;
    'dispatch: loop {
        match pc {
            0x829EDDE8 => {
    //   block [0x829EDDE8..0x829EDE1C)
	// 829EDDE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EDDEC: 482BB619  bl 0x82ca9404
	ctx.lr = 0x829EDDF0;
	sub_82CA93D0(ctx, base);
	// 829EDDF0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EDDF4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EDDF8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829EDDFC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EDE00: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 829EDE04: 4B932D85  bl 0x82320b88
	ctx.lr = 0x829EDE08;
	sub_82320B88(ctx, base);
	// 829EDE08: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EDE0C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829EDE10: 3BAB7088  addi r29, r11, 0x7088
	ctx.r[29].s64 = ctx.r[11].s64 + 28808;
	// 829EDE14: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829EDE18: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	pc = 0x829EDE1C; continue 'dispatch;
            }
            0x829EDE1C => {
    //   block [0x829EDE1C..0x829EDE64)
	// 829EDE1C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829EDE20: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829EDE24: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829EDE28: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829EDE2C: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829EDE30: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829EDE34: 4082FFE8  bne 0x829ede1c
	if !ctx.cr[0].eq {
	pc = 0x829EDE1C; continue 'dispatch;
	}
	// 829EDE38: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829EDE3C: 807E003C  lwz r3, 0x3c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 829EDE40: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829EDE44: 4BA38365  bl 0x824261a8
	ctx.lr = 0x829EDE48;
	sub_824261A8(ctx, base);
	// 829EDE48: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 829EDE4C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 829EDE50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EDE54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EDE58: 4BFFFD71  bl 0x829edbc8
	ctx.lr = 0x829EDE5C;
	sub_829EDBC8(ctx, base);
	// 829EDE5C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829EDE60: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829EDE64; continue 'dispatch;
            }
            0x829EDE64 => {
    //   block [0x829EDE64..0x829EDE88)
	// 829EDE64: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829EDE68: 419A0028  beq cr6, 0x829ede90
	if ctx.cr[6].eq {
	pc = 0x829EDE90; continue 'dispatch;
	}
	// 829EDE6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EDE70: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EDE74: 4BFFFACD  bl 0x829ed940
	ctx.lr = 0x829EDE78;
	sub_829ED940(ctx, base);
	// 829EDE78: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829EDE7C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829EDE80: 409A0008  bne cr6, 0x829ede88
	if !ctx.cr[6].eq {
	pc = 0x829EDE88; continue 'dispatch;
	}
	// 829EDE84: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829EDE88; continue 'dispatch;
            }
            0x829EDE88 => {
    //   block [0x829EDE88..0x829EDE90)
	// 829EDE88: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EDE8C: 4BFFFFD8  b 0x829ede64
	pc = 0x829EDE64; continue 'dispatch;
            }
            0x829EDE90 => {
    //   block [0x829EDE90..0x829EDEA0)
	// 829EDE90: 3960000A  li r11, 0xa
	ctx.r[11].s64 = 10;
	// 829EDE94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EDE98: 917E0040  stw r11, 0x40(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 829EDE9C: 4B7D88CD  bl 0x821c6768
	ctx.lr = 0x829EDEA0;
	sub_821C6768(ctx, base);
	pc = 0x829EDEA0; continue 'dispatch;
            }
            0x829EDEA0 => {
    //   block [0x829EDEA0..0x829EDED0)
	// 829EDEA0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829EDEA4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829EDEA8: 7D40E828  lwarx r10, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829EDEAC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 829EDEB0: 7D40E92D  stwcx. r10, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829EDEB4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829EDEB8: 4082FFE8  bne 0x829edea0
	if !ctx.cr[0].eq {
	pc = 0x829EDEA0; continue 'dispatch;
	}
	// 829EDEBC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829EDEC0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829EDEC4: 4BC4C7C5  bl 0x8263a688
	ctx.lr = 0x829EDEC8;
	sub_8263A688(ctx, base);
	// 829EDEC8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829EDECC: 482BB588  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EDED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EDED0 size=220
    let mut pc: u32 = 0x829EDED0;
    'dispatch: loop {
        match pc {
            0x829EDED0 => {
    //   block [0x829EDED0..0x829EDF08)
	// 829EDED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EDED4: 482BB52D  bl 0x82ca9400
	ctx.lr = 0x829EDED8;
	sub_82CA93D0(ctx, base);
	// 829EDED8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EDEDC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829EDEE0: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 829EDEE4: 897B0038  lbz r11, 0x38(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(56 as u32) ) } as u64;
	// 829EDEE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EDEEC: 419A0098  beq cr6, 0x829edf84
	if ctx.cr[6].eq {
	pc = 0x829EDF84; continue 'dispatch;
	}
	// 829EDEF0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EDEF4: 3BBB0004  addi r29, r27, 4
	ctx.r[29].s64 = ctx.r[27].s64 + 4;
	// 829EDEF8: 815B0014  lwz r10, 0x14(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 829EDEFC: 3B9B0010  addi r28, r27, 0x10
	ctx.r[28].s64 = ctx.r[27].s64 + 16;
	// 829EDF00: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EDF04: 83EA0000  lwz r31, 0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829EDF08; continue 'dispatch;
            }
            0x829EDF08 => {
    //   block [0x829EDF08..0x829EDF18)
	// 829EDF08: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EDF0C: 7F1DE840  cmplw cr6, r29, r29
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829EDF10: 419A0008  beq cr6, 0x829edf18
	if ctx.cr[6].eq {
	pc = 0x829EDF18; continue 'dispatch;
	}
	// 829EDF14: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829EDF18; continue 'dispatch;
            }
            0x829EDF18 => {
    //   block [0x829EDF18..0x829EDF30)
	// 829EDF18: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829EDF1C: 419A0068  beq cr6, 0x829edf84
	if ctx.cr[6].eq {
	pc = 0x829EDF84; continue 'dispatch;
	}
	// 829EDF20: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EDF24: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829EDF28: 409A0008  bne cr6, 0x829edf30
	if !ctx.cr[6].eq {
	pc = 0x829EDF30; continue 'dispatch;
	}
	// 829EDF2C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829EDF30; continue 'dispatch;
            }
            0x829EDF30 => {
    //   block [0x829EDF30..0x829EDF40)
	// 829EDF30: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EDF34: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829EDF38: 409A0008  bne cr6, 0x829edf40
	if !ctx.cr[6].eq {
	pc = 0x829EDF40; continue 'dispatch;
	}
	// 829EDF3C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829EDF40; continue 'dispatch;
            }
            0x829EDF40 => {
    //   block [0x829EDF40..0x829EDF68)
	// 829EDF40: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 829EDF44: C07F0010  lfs f3, 0x10(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 829EDF48: C05F000C  lfs f2, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829EDF4C: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EDF50: C03F0008  lfs f1, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829EDF54: 4BA3728D  bl 0x824251e0
	ctx.lr = 0x829EDF58;
	sub_824251E0(ctx, base);
	// 829EDF58: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EDF5C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829EDF60: 409A0008  bne cr6, 0x829edf68
	if !ctx.cr[6].eq {
	pc = 0x829EDF68; continue 'dispatch;
	}
	// 829EDF64: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829EDF68; continue 'dispatch;
            }
            0x829EDF68 => {
    //   block [0x829EDF68..0x829EDF7C)
	// 829EDF68: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EDF6C: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EDF70: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829EDF74: 409A0008  bne cr6, 0x829edf7c
	if !ctx.cr[6].eq {
	pc = 0x829EDF7C; continue 'dispatch;
	}
	// 829EDF78: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829EDF7C; continue 'dispatch;
            }
            0x829EDF7C => {
    //   block [0x829EDF7C..0x829EDF84)
	// 829EDF7C: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EDF80: 4BFFFF88  b 0x829edf08
	pc = 0x829EDF08; continue 'dispatch;
            }
            0x829EDF84 => {
    //   block [0x829EDF84..0x829EDFAC)
	// 829EDF84: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829EDF88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EDF8C: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 829EDF90: 997B0038  stb r11, 0x38(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(56 as u32), ctx.r[11].u8 ) };
	// 829EDF94: 997B0024  stb r11, 0x24(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 829EDF98: C00A9484  lfs f0, -0x6b7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EDF9C: 913B0040  stw r9, 0x40(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(64 as u32), ctx.r[9].u32 ) };
	// 829EDFA0: D01B0020  stfs f0, 0x20(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 829EDFA4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829EDFA8: 482BB4A8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EDFB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EDFB0 size=468
    let mut pc: u32 = 0x829EDFB0;
    'dispatch: loop {
        match pc {
            0x829EDFB0 => {
    //   block [0x829EDFB0..0x829EDFF8)
	// 829EDFB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EDFB4: 482BB449  bl 0x82ca93fc
	ctx.lr = 0x829EDFB8;
	sub_82CA93D0(ctx, base);
	// 829EDFB8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EDFBC: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 829EDFC0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EDFC4: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 829EDFC8: 4B932BC1  bl 0x82320b88
	ctx.lr = 0x829EDFCC;
	sub_82320B88(ctx, base);
	// 829EDFCC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829EDFD0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 829EDFD4: 806B6B08  lwz r3, 0x6b08(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27400 as u32) ) } as u64;
	// 829EDFD8: 4B984621  bl 0x823725f8
	ctx.lr = 0x829EDFDC;
	sub_823725F8(ctx, base);
	// 829EDFDC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829EDFE0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829EDFE4: 419A0098  beq cr6, 0x829ee07c
	if ctx.cr[6].eq {
	pc = 0x829EE07C; continue 'dispatch;
	}
	// 829EDFE8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EDFEC: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EDFF0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829EDFF4: 3B8BE3C0  addi r28, r11, -0x1c40
	ctx.r[28].s64 = ctx.r[11].s64 + -7232;
	pc = 0x829EDFF8; continue 'dispatch;
            }
            0x829EDFF8 => {
    //   block [0x829EDFF8..0x829EE014)
	// 829EDFF8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EDFFC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829EE000: 419A007C  beq cr6, 0x829ee07c
	if ctx.cr[6].eq {
	pc = 0x829EE07C; continue 'dispatch;
	}
	// 829EE004: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EE008: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829EE00C: 409A0008  bne cr6, 0x829ee014
	if !ctx.cr[6].eq {
	pc = 0x829EE014; continue 'dispatch;
	}
	// 829EE010: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829EE014; continue 'dispatch;
            }
            0x829EE014 => {
    //   block [0x829EE014..0x829EE044)
	// 829EE014: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 829EE018: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EE01C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 829EE020: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 829EE024: 4BA370E5  bl 0x82425108
	ctx.lr = 0x829EE028;
	sub_82425108(ctx, base);
	// 829EE028: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EE02C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EE030: 419A0034  beq cr6, 0x829ee064
	if ctx.cr[6].eq {
	pc = 0x829EE064; continue 'dispatch;
	}
	// 829EE034: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EE038: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829EE03C: 409A0008  bne cr6, 0x829ee044
	if !ctx.cr[6].eq {
	pc = 0x829EE044; continue 'dispatch;
	}
	// 829EE040: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829EE044; continue 'dispatch;
            }
            0x829EE044 => {
    //   block [0x829EE044..0x829EE064)
	// 829EE044: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829EE048: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 829EE04C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829EE050: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EE054: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829EE058: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829EE05C: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829EE060: 480A9309  bl 0x82a97368
	ctx.lr = 0x829EE064;
	sub_82A97368(ctx, base);
	pc = 0x829EE064; continue 'dispatch;
            }
            0x829EE064 => {
    //   block [0x829EE064..0x829EE074)
	// 829EE064: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EE068: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829EE06C: 409A0008  bne cr6, 0x829ee074
	if !ctx.cr[6].eq {
	pc = 0x829EE074; continue 'dispatch;
	}
	// 829EE070: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829EE074; continue 'dispatch;
            }
            0x829EE074 => {
    //   block [0x829EE074..0x829EE07C)
	// 829EE074: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EE078: 4BFFFF80  b 0x829edff8
	pc = 0x829EDFF8; continue 'dispatch;
            }
            0x829EE07C => {
    //   block [0x829EE07C..0x829EE090)
	// 829EE07C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829EE080: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 829EE084: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 829EE088: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829EE08C: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829EE090; continue 'dispatch;
            }
            0x829EE090 => {
    //   block [0x829EE090..0x829EE0C4)
	// 829EE090: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829EE094: 419A00E0  beq cr6, 0x829ee174
	if ctx.cr[6].eq {
	pc = 0x829EE174; continue 'dispatch;
	}
	// 829EE098: 38600044  li r3, 0x44
	ctx.r[3].s64 = 68;
	// 829EE09C: 4B831225  bl 0x8221f2c0
	ctx.lr = 0x829EE0A0;
	sub_8221F2C0(ctx, base);
	// 829EE0A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EE0A4: 409A0060  bne cr6, 0x829ee104
	if !ctx.cr[6].eq {
	pc = 0x829EE104; continue 'dispatch;
	}
	// 829EE0A8: 817D6F6C  lwz r11, 0x6f6c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28524 as u32) ) } as u64;
	// 829EE0AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EE0B0: 419A0014  beq cr6, 0x829ee0c4
	if ctx.cr[6].eq {
	pc = 0x829EE0C4; continue 'dispatch;
	}
	// 829EE0B4: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EE0B8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829EE0BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EE0C0: 4E800421  bctrl
	ctx.lr = 0x829EE0C4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x829EE0C4 => {
    //   block [0x829EE0C4..0x829EE0CC)
	// 829EE0C4: 482D42E5  bl 0x82cc23a8
	ctx.lr = 0x829EE0C8;
	sub_82CC23A8(ctx, base);
	// 829EE0C8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	pc = 0x829EE0CC; continue 'dispatch;
            }
            0x829EE0CC => {
    //   block [0x829EE0CC..0x829EE104)
	// 829EE0CC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829EE0D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EE0D4: 419A0050  beq cr6, 0x829ee124
	if ctx.cr[6].eq {
	pc = 0x829EE124; continue 'dispatch;
	}
	// 829EE0D8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 829EE0DC: 4B83117D  bl 0x8221f258
	ctx.lr = 0x829EE0E0;
	sub_8221F258(ctx, base);
	// 829EE0E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EE0E4: 419A0040  beq cr6, 0x829ee124
	if ctx.cr[6].eq {
	pc = 0x829EE124; continue 'dispatch;
	}
	// 829EE0E8: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 829EE0EC: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 829EE0F0: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 829EE0F4: 394B9238  addi r10, r11, -0x6dc8
	ctx.r[10].s64 = ctx.r[11].s64 + -28104;
	// 829EE0F8: 93830000  stw r28, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 829EE0FC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829EE100: 48000028  b 0x829ee128
	pc = 0x829EE128; continue 'dispatch;
            }
            0x829EE104 => {
    //   block [0x829EE104..0x829EE114)
	// 829EE104: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829EE108: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829EE10C: 409A0008  bne cr6, 0x829ee114
	if !ctx.cr[6].eq {
	pc = 0x829EE114; continue 'dispatch;
	}
	// 829EE110: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829EE114; continue 'dispatch;
            }
            0x829EE114 => {
    //   block [0x829EE114..0x829EE124)
	// 829EE114: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EE118: 4BFFF459  bl 0x829ed570
	ctx.lr = 0x829EE11C;
	sub_829ED570(ctx, base);
	// 829EE11C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EE120: 4BFFFFAC  b 0x829ee0cc
	pc = 0x829EE0CC; continue 'dispatch;
            }
            0x829EE124 => {
    //   block [0x829EE124..0x829EE128)
	// 829EE124: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	pc = 0x829EE128; continue 'dispatch;
            }
            0x829EE128 => {
    //   block [0x829EE128..0x829EE16C)
	// 829EE128: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 829EE12C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829EE130: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EE134: 4BFFFCB5  bl 0x829edde8
	ctx.lr = 0x829EE138;
	sub_829EDDE8(ctx, base);
	// 829EE138: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EE13C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829EE140: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 829EE144: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 829EE148: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829EE14C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829EE150: 4BC2F999  bl 0x8261dae8
	ctx.lr = 0x829EE154;
	sub_8261DAE8(ctx, base);
	// 829EE154: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EE158: 4B7C99C1  bl 0x821b7b18
	ctx.lr = 0x829EE15C;
	sub_821B7B18(ctx, base);
	// 829EE15C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829EE160: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829EE164: 409A0008  bne cr6, 0x829ee16c
	if !ctx.cr[6].eq {
	pc = 0x829EE16C; continue 'dispatch;
	}
	// 829EE168: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829EE16C; continue 'dispatch;
            }
            0x829EE16C => {
    //   block [0x829EE16C..0x829EE174)
	// 829EE16C: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EE170: 4BFFFF20  b 0x829ee090
	pc = 0x829EE090; continue 'dispatch;
            }
            0x829EE174 => {
    //   block [0x829EE174..0x829EE184)
	// 829EE174: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EE178: 4BC4C511  bl 0x8263a688
	ctx.lr = 0x829EE17C;
	sub_8263A688(ctx, base);
	// 829EE17C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 829EE180: 482BB2CC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EE188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EE188 size=228
    let mut pc: u32 = 0x829EE188;
    'dispatch: loop {
        match pc {
            0x829EE188 => {
    //   block [0x829EE188..0x829EE1C0)
	// 829EE188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EE18C: 482BB275  bl 0x82ca9400
	ctx.lr = 0x829EE190;
	sub_82CA93D0(ctx, base);
	// 829EE190: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EE194: F88100E8  std r4, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[4].u64 ) };
	// 829EE198: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829EE19C: 836100EC  lwz r27, 0xec(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 829EE1A0: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 829EE1A4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 829EE1A8: 835B0004  lwz r26, 4(r27)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EE1AC: 4B8310AD  bl 0x8221f258
	ctx.lr = 0x829EE1B0;
	sub_8221F258(ctx, base);
	// 829EE1B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EE1B4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EE1B8: 419A0008  beq cr6, 0x829ee1c0
	if ctx.cr[6].eq {
	pc = 0x829EE1C0; continue 'dispatch;
	}
	// 829EE1BC: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	pc = 0x829EE1C0; continue 'dispatch;
            }
            0x829EE1C0 => {
    //   block [0x829EE1C0..0x829EE1D0)
	// 829EE1C0: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 829EE1C4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829EE1C8: 419A0008  beq cr6, 0x829ee1d0
	if ctx.cr[6].eq {
	pc = 0x829EE1D0; continue 'dispatch;
	}
	// 829EE1CC: 935E0000  stw r26, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	pc = 0x829EE1D0; continue 'dispatch;
            }
            0x829EE1D0 => {
    //   block [0x829EE1D0..0x829EE1F0)
	// 829EE1D0: 357F0008  addic. r11, r31, 8
	ctx.xer.ca = (ctx.r[31].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EE1D4: 4182001C  beq 0x829ee1f0
	if ctx.cr[0].eq {
	pc = 0x829EE1F0; continue 'dispatch;
	}
	// 829EE1D8: C01C0000  lfs f0, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EE1DC: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829EE1E0: C1BC0004  lfs f13, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829EE1E4: D1AB0004  stfs f13, 4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829EE1E8: C19C0008  lfs f12, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829EE1EC: D18B0008  stfs f12, 8(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x829EE1F0; continue 'dispatch;
            }
            0x829EE1F0 => {
    //   block [0x829EE1F0..0x829EE24C)
	// 829EE1F0: 3D601555  lis r11, 0x1555
	ctx.r[11].s64 = 357892096;
	// 829EE1F4: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EE1F8: 61695555  ori r9, r11, 0x5555
	ctx.r[9].u64 = ctx.r[11].u64 | 21845;
	// 829EE1FC: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 829EE200: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 829EE204: 40980048  bge cr6, 0x829ee24c
	if !ctx.cr[6].lt {
	pc = 0x829EE24C; continue 'dispatch;
	}
	// 829EE208: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EE20C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EE210: 388B2D94  addi r4, r11, 0x2d94
	ctx.r[4].s64 = ctx.r[11].s64 + 11668;
	// 829EE214: 4B903D2D  bl 0x822f1f40
	ctx.lr = 0x829EE218;
	sub_822F1F40(ctx, base);
	// 829EE218: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829EE21C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829EE220: 4B903B91  bl 0x822f1db0
	ctx.lr = 0x829EE224;
	sub_822F1DB0(ctx, base);
	// 829EE224: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829EE228: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829EE22C: 3B8A1720  addi r28, r10, 0x1720
	ctx.r[28].s64 = ctx.r[10].s64 + 5920;
	// 829EE230: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 829EE234: 4B903BED  bl 0x822f1e20
	ctx.lr = 0x829EE238;
	sub_822F1E20(ctx, base);
	// 829EE238: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 829EE23C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829EE240: 4BC8D5A1  bl 0x8267b7e0
	ctx.lr = 0x829EE244;
	sub_8267B7E0(ctx, base);
	// 829EE244: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EE248: 4B7835C9  bl 0x82171810
	ctx.lr = 0x829EE24C;
	sub_82171810(ctx, base);
	pc = 0x829EE24C; continue 'dispatch;
            }
            0x829EE24C => {
    //   block [0x829EE24C..0x829EE26C)
	// 829EE24C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EE250: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EE254: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 829EE258: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 829EE25C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EE260: 93EA0000  stw r31, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829EE264: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 829EE268: 482BB1E8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EE270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EE270 size=168
    let mut pc: u32 = 0x829EE270;
    'dispatch: loop {
        match pc {
            0x829EE270 => {
    //   block [0x829EE270..0x829EE2B8)
	// 829EE270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EE274: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EE278: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EE27C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EE280: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EE284: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829EE288: 394B1360  addi r10, r11, 0x1360
	ctx.r[10].s64 = ctx.r[11].s64 + 4960;
	// 829EE28C: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 829EE290: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829EE294: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 829EE298: 419A0020  beq cr6, 0x829ee2b8
	if ctx.cr[6].eq {
	pc = 0x829EE2B8; continue 'dispatch;
	}
	// 829EE29C: 80BF002C  lwz r5, 0x2c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 829EE2A0: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 829EE2A4: 419A0014  beq cr6, 0x829ee2b8
	if ctx.cr[6].eq {
	pc = 0x829EE2B8; continue 'dispatch;
	}
	// 829EE2A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EE2AC: 4839033D  bl 0x82d7e5e8
	ctx.lr = 0x829EE2B0;
	sub_82D7E5E8(ctx, base);
	// 829EE2B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EE2B4: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x829EE2B8; continue 'dispatch;
            }
            0x829EE2B8 => {
    //   block [0x829EE2B8..0x829EE2FC)
	// 829EE2B8: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 829EE2BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EE2C0: 419A003C  beq cr6, 0x829ee2fc
	if ctx.cr[6].eq {
	pc = 0x829EE2FC; continue 'dispatch;
	}
	// 829EE2C4: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EE2C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EE2CC: 419A0030  beq cr6, 0x829ee2fc
	if ctx.cr[6].eq {
	pc = 0x829EE2FC; continue 'dispatch;
	}
	// 829EE2D0: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 829EE2D4: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 829EE2D8: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 829EE2DC: B1230006  sth r9, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 829EE2E0: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829EE2E4: 409A0018  bne cr6, 0x829ee2fc
	if !ctx.cr[6].eq {
	pc = 0x829EE2FC; continue 'dispatch;
	}
	// 829EE2E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EE2EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829EE2F0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EE2F4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829EE2F8: 4E800421  bctrl
	ctx.lr = 0x829EE2FC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x829EE2FC => {
    //   block [0x829EE2FC..0x829EE318)
	// 829EE2FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EE300: 4BA2DCC1  bl 0x8241bfc0
	ctx.lr = 0x829EE304;
	sub_8241BFC0(ctx, base);
	// 829EE304: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EE308: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EE30C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EE310: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EE314: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EE318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829EE318 size=76
    let mut pc: u32 = 0x829EE318;
    'dispatch: loop {
        match pc {
            0x829EE318 => {
    //   block [0x829EE318..0x829EE364)
	// 829EE318: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EE31C: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 829EE320: 3921FFF4  addi r9, r1, -0xc
	ctx.r[9].s64 = ctx.r[1].s64 + -12;
	// 829EE324: 3901FFF4  addi r8, r1, -0xc
	ctx.r[8].s64 = ctx.r[1].s64 + -12;
	// 829EE328: 38E1FFF0  addi r7, r1, -0x10
	ctx.r[7].s64 = ctx.r[1].s64 + -16;
	// 829EE32C: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EE330: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EE368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829EE368 size=28
    let mut pc: u32 = 0x829EE368;
    'dispatch: loop {
        match pc {
            0x829EE368 => {
    //   block [0x829EE368..0x829EE384)
	// 829EE368: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829EE36C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 829EE370: 808B002C  lwz r4, 0x2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 829EE374: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 829EE378: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 829EE37C: 906B0010  stw r3, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 829EE380: 483900A8  b 0x82d7e428
	sub_82D7E428(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EE384(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829EE384 size=4
    let mut pc: u32 = 0x829EE384;
    'dispatch: loop {
        match pc {
            0x829EE384 => {
    //   block [0x829EE384..0x829EE388)
	// 829EE384: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EE388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EE388 size=72
    let mut pc: u32 = 0x829EE388;
    'dispatch: loop {
        match pc {
            0x829EE388 => {
    //   block [0x829EE388..0x829EE3BC)
	// 829EE388: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EE38C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EE390: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EE394: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EE398: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EE39C: 80BF002C  lwz r5, 0x2c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 829EE3A0: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 829EE3A4: 419A0018  beq cr6, 0x829ee3bc
	if ctx.cr[6].eq {
	pc = 0x829EE3BC; continue 'dispatch;
	}
	// 829EE3A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EE3AC: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 829EE3B0: 48390239  bl 0x82d7e5e8
	ctx.lr = 0x829EE3B4;
	sub_82D7E5E8(ctx, base);
	// 829EE3B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EE3B8: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x829EE3BC; continue 'dispatch;
            }
            0x829EE3BC => {
    //   block [0x829EE3BC..0x829EE3D0)
	// 829EE3BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EE3C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EE3C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EE3C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EE3CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EE3D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EE3D0 size=80
    let mut pc: u32 = 0x829EE3D0;
    'dispatch: loop {
        match pc {
            0x829EE3D0 => {
    //   block [0x829EE3D0..0x829EE408)
	// 829EE3D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EE3D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EE3D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EE3DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EE3E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EE3E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EE3E8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829EE3EC: 4BFFFE85  bl 0x829ee270
	ctx.lr = 0x829EE3F0;
	sub_829EE270(ctx, base);
	// 829EE3F0: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 829EE3F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EE3F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EE3FC: 419A000C  beq cr6, 0x829ee408
	if ctx.cr[6].eq {
	pc = 0x829EE408; continue 'dispatch;
	}
	// 829EE400: 4B82D939  bl 0x8221bd38
	ctx.lr = 0x829EE404;
	sub_8221BD38(ctx, base);
	// 829EE404: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x829EE408; continue 'dispatch;
            }
            0x829EE408 => {
    //   block [0x829EE408..0x829EE420)
	// 829EE408: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EE40C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EE410: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EE414: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EE418: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EE41C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EE420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EE420 size=464
    let mut pc: u32 = 0x829EE420;
    'dispatch: loop {
        match pc {
            0x829EE420 => {
    //   block [0x829EE420..0x829EE4B4)
	// 829EE420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EE424: 482BAFDD  bl 0x82ca9400
	ctx.lr = 0x829EE428;
	sub_82CA93D0(ctx, base);
	// 829EE428: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EE42C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EE430: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EE434: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829EE438: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 829EE43C: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 829EE440: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829EE444: 390A1360  addi r8, r10, 0x1360
	ctx.r[8].s64 = ctx.r[10].s64 + 4960;
	// 829EE448: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 829EE44C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 829EE450: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 829EE454: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 829EE458: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 829EE45C: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 829EE460: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 829EE464: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 829EE468: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 829EE46C: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 829EE470: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 829EE474: 8065007C  lwz r3, 0x7c(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(124 as u32) ) } as u64;
	// 829EE478: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EE47C: 80C7005C  lwz r6, 0x5c(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(92 as u32) ) } as u64;
	// 829EE480: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 829EE484: 4E800421  bctrl
	ctx.lr = 0x829EE488;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EE488: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829EE48C: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	// 829EE490: 80BD0000  lwz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EE494: 80850004  lwz r4, 4(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EE498: 7C8903A6  mtctr r4
	ctx.ctr.u64 = ctx.r[4].u64;
	// 829EE49C: 4E800421  bctrl
	ctx.lr = 0x829EE4A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EE4A0: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 829EE4A4: 409A0010  bne cr6, 0x829ee4b4
	if !ctx.cr[6].eq {
	pc = 0x829EE4B4; continue 'dispatch;
	}
	// 829EE4A8: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 829EE4AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829EE4B0: 48000008  b 0x829ee4b8
	pc = 0x829EE4B8; continue 'dispatch;
            }
            0x829EE4B4 => {
    //   block [0x829EE4B4..0x829EE4B8)
	// 829EE4B4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x829EE4B8; continue 'dispatch;
            }
            0x829EE4B8 => {
    //   block [0x829EE4B8..0x829EE518)
	// 829EE4B8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829EE4BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EE4C0: 419A0124  beq cr6, 0x829ee5e4
	if ctx.cr[6].eq {
	pc = 0x829EE5E4; continue 'dispatch;
	}
	// 829EE4C4: 807C007C  lwz r3, 0x7c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(124 as u32) ) } as u64;
	// 829EE4C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EE4CC: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 829EE4D0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829EE4D4: 4E800421  bctrl
	ctx.lr = 0x829EE4D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EE4D8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 829EE4DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829EE4E0: 4BD2E511  bl 0x8271c9f0
	ctx.lr = 0x829EE4E4;
	sub_8271C9F0(ctx, base);
	// 829EE4E4: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EE4E8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829EE4EC: 419A00F8  beq cr6, 0x829ee5e4
	if ctx.cr[6].eq {
	pc = 0x829EE5E4; continue 'dispatch;
	}
	// 829EE4F0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829EE4F4: 814B0038  lwz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 829EE4F8: 816A002C  lwz r11, 0x2c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 829EE4FC: 812B0020  lwz r9, 0x20(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 829EE500: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EE504: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 829EE508: 41980010  blt cr6, 0x829ee518
	if ctx.cr[6].lt {
	pc = 0x829EE518; continue 'dispatch;
	}
	// 829EE50C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EE510: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829EE514: 7FCA582E  lwzx r30, r10, r11
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
            }
            0x829EE518 => {
    //   block [0x829EE518..0x829EE5E4)
	// 829EE518: 817B0038  lwz r11, 0x38(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(56 as u32) ) } as u64;
	// 829EE51C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829EE520: 836B002C  lwz r27, 0x2c(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 829EE524: 419A00C0  beq cr6, 0x829ee5e4
	if ctx.cr[6].eq {
	pc = 0x829EE5E4; continue 'dispatch;
	}
	// 829EE528: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 829EE52C: 419A00B8  beq cr6, 0x829ee5e4
	if ctx.cr[6].eq {
	pc = 0x829EE5E4; continue 'dispatch;
	}
	// 829EE530: 83AD0000  lwz r29, 0(r13)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EE534: 3B800004  li r28, 4
	ctx.r[28].s64 = 4;
	// 829EE538: 38A0002B  li r5, 0x2b
	ctx.r[5].s64 = 43;
	// 829EE53C: 38800058  li r4, 0x58
	ctx.r[4].s64 = 88;
	// 829EE540: 7C7CE82E  lwzx r3, r28, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 829EE544: 48366D05  bl 0x82d55248
	ctx.lr = 0x829EE548;
	sub_82D55248(ctx, base);
	// 829EE548: 39600058  li r11, 0x58
	ctx.r[11].s64 = 88;
	// 829EE54C: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 829EE550: 48399B71  bl 0x82d880c0
	ctx.lr = 0x829EE554;
	sub_82D880C0(ctx, base);
	// 829EE554: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 829EE558: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829EE55C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 829EE560: 4839A6D9  bl 0x82d88c38
	ctx.lr = 0x829EE564;
	sub_82D88C38(ctx, base);
	// 829EE564: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 829EE568: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 829EE56C: 390A1570  addi r8, r10, 0x1570
	ctx.r[8].s64 = ctx.r[10].s64 + 5488;
	// 829EE570: 38E91560  addi r7, r9, 0x1560
	ctx.r[7].s64 = ctx.r[9].s64 + 5472;
	// 829EE574: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 829EE578: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 829EE57C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	pc = 0x829EE5E4; continue 'dispatch;
            }
            0x829EE5E4 => {
    //   block [0x829EE5E4..0x829EE5F0)
	// 829EE5E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EE5E8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 829EE5EC: 482BAE64  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EE5F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EE5F0 size=72
    let mut pc: u32 = 0x829EE5F0;
    'dispatch: loop {
        match pc {
            0x829EE5F0 => {
    //   block [0x829EE5F0..0x829EE624)
	// 829EE5F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EE5F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EE5F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EE5FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EE600: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EE604: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 829EE608: 548A07FE  clrlwi r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 829EE60C: 392B279C  addi r9, r11, 0x279c
	ctx.r[9].s64 = ctx.r[11].s64 + 10140;
	// 829EE610: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829EE614: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829EE618: 419A000C  beq cr6, 0x829ee624
	if ctx.cr[6].eq {
	pc = 0x829EE624; continue 'dispatch;
	}
	// 829EE61C: 4B82D71D  bl 0x8221bd38
	ctx.lr = 0x829EE620;
	sub_8221BD38(ctx, base);
	// 829EE620: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x829EE624; continue 'dispatch;
            }
            0x829EE624 => {
    //   block [0x829EE624..0x829EE638)
	// 829EE624: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829EE628: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EE62C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EE630: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EE634: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EE638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EE638 size=172
    let mut pc: u32 = 0x829EE638;
    'dispatch: loop {
        match pc {
            0x829EE638 => {
    //   block [0x829EE638..0x829EE6E4)
	// 829EE638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EE63C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EE640: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EE644: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EE648: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 829EE64C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 829EE650: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 829EE654: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 829EE658: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EE6E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EE6E8 size=96
    let mut pc: u32 = 0x829EE6E8;
    'dispatch: loop {
        match pc {
            0x829EE6E8 => {
    //   block [0x829EE6E8..0x829EE730)
	// 829EE6E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EE6EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EE6F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EE6F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EE6F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EE6FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EE700: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829EE704: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 829EE708: 483CFA01  bl 0x82dbe108
	ctx.lr = 0x829EE70C;
	sub_82DBE108(ctx, base);
	// 829EE70C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 829EE710: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 829EE714: 392B279C  addi r9, r11, 0x279c
	ctx.r[9].s64 = ctx.r[11].s64 + 10140;
	// 829EE718: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829EE71C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829EE720: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EE724: 419A000C  beq cr6, 0x829ee730
	if ctx.cr[6].eq {
	pc = 0x829EE730; continue 'dispatch;
	}
	// 829EE728: 4B82D611  bl 0x8221bd38
	ctx.lr = 0x829EE72C;
	sub_8221BD38(ctx, base);
	// 829EE72C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x829EE730; continue 'dispatch;
            }
            0x829EE730 => {
    //   block [0x829EE730..0x829EE748)
	// 829EE730: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EE734: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EE738: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EE73C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EE740: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EE744: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EE748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829EE748 size=104
    let mut pc: u32 = 0x829EE748;
    'dispatch: loop {
        match pc {
            0x829EE748 => {
    //   block [0x829EE748..0x829EE7A8)
	// 829EE748: EC021828  fsubs f0, f2, f3
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[2].f64 - ctx.f[3].f64) as f32) as f64);
	// 829EE74C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829EE750: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 829EE754: 396B0E68  addi r11, r11, 0xe68
	ctx.r[11].s64 = ctx.r[11].s64 + 3688;
	// 829EE758: C1AA9484  lfs f13, -0x6b7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829EE75C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829EE760: 7D200026  mfcr r9
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[9].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 829EE764: 5528DF7A  rlwinm r8, r9, 0x1b, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 829EE768: 5527F77A  rlwinm r7, r9, 0x1e, 0x1d, 0x1d
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 829EE76C: 7D063B78  or r6, r8, r7
	ctx.r[6].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 829EE770: 7D8B342E  lfsx f12, r11, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829EE774: FD6C10EE  fsel f11, f12, f3, f2
	ctx.f[11].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[3].f64 } else { ctx.f[2].f64 };
	// 829EE778: FF015800  fcmpu cr6, f1, f11
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[11].f64);
	// 829EE77C: 4099002C  ble cr6, 0x829ee7a8
	if !ctx.cr[6].gt {
	pc = 0x829EE7A8; continue 'dispatch;
	}
	// 829EE780: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829EE784: 7D400026  mfcr r10
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[10].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 829EE788: 5549DF7A  rlwinm r9, r10, 0x1b, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 829EE78C: 5548F77A  rlwinm r8, r10, 0x1e, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 829EE790: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829EE794: 7D274378  or r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 829EE798: 7C0B3C2E  lfsx f0, r11, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EE79C: FDA018AE  fsel f13, f0, f2, f3
	ctx.f[13].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[2].f64 } else { ctx.f[3].f64 };
	// 829EE7A0: FF016800  fcmpu cr6, f1, f13
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[13].f64);
	// 829EE7A4: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	pc = 0x829EE7A8; continue 'dispatch;
            }
            0x829EE7A8 => {
    //   block [0x829EE7A8..0x829EE7B0)
	// 829EE7A8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829EE7AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EE7B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829EE7B0 size=132
    let mut pc: u32 = 0x829EE7B0;
    'dispatch: loop {
        match pc {
            0x829EE7B0 => {
    //   block [0x829EE7B0..0x829EE834)
	// 829EE7B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EE7B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EE7B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EE7BC: 3980FFE0  li r12, -0x20
	ctx.r[12].s64 = -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EE838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EE838 size=124
    let mut pc: u32 = 0x829EE838;
    'dispatch: loop {
        match pc {
            0x829EE838 => {
    //   block [0x829EE838..0x829EE874)
	// 829EE838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EE83C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EE840: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EE844: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EE848: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EE84C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EE850: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 829EE854: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829EE858: 4B830A01  bl 0x8221f258
	ctx.lr = 0x829EE85C;
	sub_8221F258(ctx, base);
	// 829EE85C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EE860: 419A0014  beq cr6, 0x829ee874
	if ctx.cr[6].eq {
	pc = 0x829EE874; continue 'dispatch;
	}
	// 829EE864: 39600040  li r11, 0x40
	ctx.r[11].s64 = 64;
	pc = 0x829EE874; continue 'dispatch;
            }
            0x829EE874 => {
    //   block [0x829EE874..0x829EE8B4)
	// 829EE874: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829EE878: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 829EE87C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EE880: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EE884: 419A0010  beq cr6, 0x829ee894
	if ctx.cr[6].eq {
	pc = 0x829EE894; continue 'dispatch;
	}
	// 829EE888: 48016439  bl 0x82a04cc0
	ctx.lr = 0x829EE88C;
	sub_82A04CC0(ctx, base);
	// 829EE88C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EE890: 4800000C  b 0x829ee89c
	pc = 0x829EE89C; continue 'dispatch;
	// 829EE894: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EE898: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 829EE89C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EE8A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EE8A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EE8A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EE8AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EE8B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EE8B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EE8B8 size=124
    let mut pc: u32 = 0x829EE8B8;
    'dispatch: loop {
        match pc {
            0x829EE8B8 => {
    //   block [0x829EE8B8..0x829EE934)
	// 829EE8B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EE8BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EE8C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EE8C4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EE8C8: 39600050  li r11, 0x50
	ctx.r[11].s64 = 80;
	// 829EE8CC: 39400040  li r10, 0x40
	ctx.r[10].s64 = 64;
	// 829EE8D0: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 829EE8D4: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 829EE8D8: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EE938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EE938 size=136
    let mut pc: u32 = 0x829EE938;
    'dispatch: loop {
        match pc {
            0x829EE938 => {
    //   block [0x829EE938..0x829EE998)
	// 829EE938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EE93C: 482BAAD1  bl 0x82ca940c
	ctx.lr = 0x829EE940;
	sub_82CA93D0(ctx, base);
	// 829EE940: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EE944: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829EE948: 38600084  li r3, 0x84
	ctx.r[3].s64 = 132;
	// 829EE94C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829EE950: 4B830909  bl 0x8221f258
	ctx.lr = 0x829EE954;
	sub_8221F258(ctx, base);
	// 829EE954: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EE958: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EE95C: 419A003C  beq cr6, 0x829ee998
	if ctx.cr[6].eq {
	pc = 0x829EE998; continue 'dispatch;
	}
	// 829EE960: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829EE964: 4B79F425  bl 0x8218dd88
	ctx.lr = 0x829EE968;
	sub_8218DD88(ctx, base);
	// 829EE968: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829EE96C: 389E0074  addi r4, r30, 0x74
	ctx.r[4].s64 = ctx.r[30].s64 + 116;
	// 829EE970: 394B13C8  addi r10, r11, 0x13c8
	ctx.r[10].s64 = ctx.r[11].s64 + 5064;
	// 829EE974: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 829EE978: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829EE97C: C01E006C  lfs f0, 0x6c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EE980: D01F006C  stfs f0, 0x6c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 829EE984: 893E0070  lbz r9, 0x70(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) } as u64;
	// 829EE988: 993F0070  stb r9, 0x70(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[9].u8 ) };
	// 829EE98C: 48000C75  bl 0x829ef600
	ctx.lr = 0x829EE990;
	sub_829EF600(ctx, base);
	// 829EE990: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EE994: 48000008  b 0x829ee99c
	pc = 0x829EE99C; continue 'dispatch;
            }
            0x829EE998 => {
    //   block [0x829EE998..0x829EE99C)
	// 829EE998: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829EE99C; continue 'dispatch;
            }
            0x829EE99C => {
    //   block [0x829EE99C..0x829EE9B4)
	// 829EE99C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829EE9A0: 4B8D1579  bl 0x822bff18
	ctx.lr = 0x829EE9A4;
	sub_822BFF18(ctx, base);
	// 829EE9A4: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EE9A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EE9AC: 419A0008  beq cr6, 0x829ee9b4
	if ctx.cr[6].eq {
	pc = 0x829EE9B4; continue 'dispatch;
	}
	// 829EE9B0: 4B792871  bl 0x82181220
	ctx.lr = 0x829EE9B4;
	sub_82181220(ctx, base);
	pc = 0x829EE9B4; continue 'dispatch;
            }
            0x829EE9B4 => {
    //   block [0x829EE9B4..0x829EE9C0)
	// 829EE9B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829EE9B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EE9BC: 482BAAA0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EE9C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EE9C0 size=100
    let mut pc: u32 = 0x829EE9C0;
    'dispatch: loop {
        match pc {
            0x829EE9C0 => {
    //   block [0x829EE9C0..0x829EEA0C)
	// 829EE9C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EE9C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EE9C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EE9CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EE9D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EE9D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EE9D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829EE9DC: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 829EE9E0: 48000CF9  bl 0x829ef6d8
	ctx.lr = 0x829EE9E4;
	sub_829EF6D8(ctx, base);
	// 829EE9E4: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 829EE9E8: 4B8263F1  bl 0x82214dd8
	ctx.lr = 0x829EE9EC;
	sub_82214DD8(ctx, base);
	// 829EE9EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EE9F0: 4B7BE141  bl 0x821acb30
	ctx.lr = 0x829EE9F4;
	sub_821ACB30(ctx, base);
	// 829EE9F4: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 829EE9F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EE9FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EEA00: 419A000C  beq cr6, 0x829eea0c
	if ctx.cr[6].eq {
	pc = 0x829EEA0C; continue 'dispatch;
	}
	// 829EEA04: 4B82D335  bl 0x8221bd38
	ctx.lr = 0x829EEA08;
	sub_8221BD38(ctx, base);
	// 829EEA08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x829EEA0C; continue 'dispatch;
            }
            0x829EEA0C => {
    //   block [0x829EEA0C..0x829EEA24)
	// 829EEA0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EEA10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EEA14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EEA18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EEA1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EEA20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EEA28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EEA28 size=1136
    let mut pc: u32 = 0x829EEA28;
    'dispatch: loop {
        match pc {
            0x829EEA28 => {
    //   block [0x829EEA28..0x829EEA68)
	// 829EEA28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EEA2C: 482BA9C1  bl 0x82ca93ec
	ctx.lr = 0x829EEA30;
	sub_82CA93D0(ctx, base);
	// 829EEA30: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EEA34: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 829EEA38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EEA3C: 7ED5B378  mr r21, r22
	ctx.r[21].u64 = ctx.r[22].u64;
	// 829EEA40: 92A10058  stw r21, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[21].u32 ) };
	// 829EEA44: 4B7AB04D  bl 0x82199a90
	ctx.lr = 0x829EEA48;
	sub_82199A90(ctx, base);
	// 829EEA48: 809F007C  lwz r4, 0x7c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 829EEA4C: 3AFF0074  addi r23, r31, 0x74
	ctx.r[23].s64 = ctx.r[31].s64 + 116;
	// 829EEA50: 80BF0078  lwz r5, 0x78(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 829EEA54: 7F052040  cmplw cr6, r5, r4
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[4].u32, &mut ctx.xer);
	// 829EEA58: 40990010  ble cr6, 0x829eea68
	if !ctx.cr[6].gt {
	pc = 0x829EEA68; continue 'dispatch;
	}
	// 829EEA5C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 829EEA60: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 829EEA64: 7F052040  cmplw cr6, r5, r4
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[4].u32, &mut ctx.xer);
	pc = 0x829EEA68; continue 'dispatch;
            }
            0x829EEA68 => {
    //   block [0x829EEA68..0x829EEA88)
	// 829EEA68: 419A0020  beq cr6, 0x829eea88
	if ctx.cr[6].eq {
	pc = 0x829EEA88; continue 'dispatch;
	}
	// 829EEA6C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 829EEA70: 48001121  bl 0x829efb90
	ctx.lr = 0x829EEA74;
	sub_829EFB90(ctx, base);
	// 829EEA74: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 829EEA78: 80970008  lwz r4, 8(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EEA7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EEA80: 4BB77F91  bl 0x82566a10
	ctx.lr = 0x829EEA84;
	sub_82566A10(ctx, base);
	// 829EEA84: 93D70008  stw r30, 8(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	pc = 0x829EEA88; continue 'dispatch;
            }
            0x829EEA88 => {
    //   block [0x829EEA88..0x829EEAB0)
	// 829EEA88: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 829EEA8C: 7EDFB378  mr r31, r22
	ctx.r[31].u64 = ctx.r[22].u64;
	// 829EEA90: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EEA94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EEA98: 419A001C  beq cr6, 0x829eeab4
	if ctx.cr[6].eq {
	pc = 0x829EEAB4; continue 'dispatch;
	}
	// 829EEA9C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EEAA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829EEAA4: 419A000C  beq cr6, 0x829eeab0
	if ctx.cr[6].eq {
	pc = 0x829EEAB0; continue 'dispatch;
	}
	// 829EEAA8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EEAAC: 4800000C  b 0x829eeab8
	pc = 0x829EEAB8; continue 'dispatch;
            }
            0x829EEAB0 => {
    //   block [0x829EEAB0..0x829EEAB4)
	// 829EEAB0: 4B7A5389  bl 0x82193e38
	ctx.lr = 0x829EEAB4;
	sub_82193E38(ctx, base);
	pc = 0x829EEAB4; continue 'dispatch;
            }
            0x829EEAB4 => {
    //   block [0x829EEAB4..0x829EEAB8)
	// 829EEAB4: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x829EEAB8; continue 'dispatch;
            }
            0x829EEAB8 => {
    //   block [0x829EEAB8..0x829EEAF4)
	// 829EEAB8: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 829EEABC: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 829EEAC0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829EEAC4: 419A00F4  beq cr6, 0x829eebb8
	if ctx.cr[6].eq {
	pc = 0x829EEBB8; continue 'dispatch;
	}
	// 829EEAC8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 829EEACC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829EEAD0: 419A0024  beq cr6, 0x829eeaf4
	if ctx.cr[6].eq {
	pc = 0x829EEAF4; continue 'dispatch;
	}
	// 829EEAD4: 894A0013  lbz r10, 0x13(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 829EEAD8: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 829EEADC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 829EEAE0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829EEAE4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EEAE8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829EEAEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829EEAF0: 480000CC  b 0x829eebbc
	pc = 0x829EEBBC; continue 'dispatch;
            }
            0x829EEAF4 => {
    //   block [0x829EEAF4..0x829EEB10)
	// 829EEAF4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 829EEAF8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829EEAFC: 92C10058  stw r22, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[22].u32 ) };
	// 829EEB00: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829EEB04: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 829EEB08: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EEB0C: 40810054  ble 0x829eeb60
	if !ctx.cr[0].gt {
	pc = 0x829EEB60; continue 'dispatch;
	}
	pc = 0x829EEB10; continue 'dispatch;
            }
            0x829EEB10 => {
    //   block [0x829EEB10..0x829EEB30)
	// 829EEB10: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829EEB14: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829EEB18: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829EEB1C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EEB20: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 829EEB24: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829EEB28: 41980008  blt cr6, 0x829eeb30
	if ctx.cr[6].lt {
	pc = 0x829EEB30; continue 'dispatch;
	}
	// 829EEB2C: 7EC7B378  mr r7, r22
	ctx.r[7].u64 = ctx.r[22].u64;
	pc = 0x829EEB30; continue 'dispatch;
            }
            0x829EEB30 => {
    //   block [0x829EEB30..0x829EEB4C)
	// 829EEB30: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829EEB34: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829EEB38: 419A0014  beq cr6, 0x829eeb4c
	if ctx.cr[6].eq {
	pc = 0x829EEB4C; continue 'dispatch;
	}
	// 829EEB3C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829EEB40: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829EEB44: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829EEB48: 4800000C  b 0x829eeb54
	pc = 0x829EEB54; continue 'dispatch;
            }
            0x829EEB4C => {
    //   block [0x829EEB4C..0x829EEB54)
	// 829EEB4C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829EEB50: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829EEB54; continue 'dispatch;
            }
            0x829EEB54 => {
    //   block [0x829EEB54..0x829EEB60)
	// 829EEB54: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EEB58: 4199FFB8  bgt cr6, 0x829eeb10
	if ctx.cr[6].gt {
	pc = 0x829EEB10; continue 'dispatch;
	}
	// 829EEB5C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x829EEB60; continue 'dispatch;
            }
            0x829EEB60 => {
    //   block [0x829EEB60..0x829EEB7C)
	// 829EEB60: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829EEB64: 419A0040  beq cr6, 0x829eeba4
	if ctx.cr[6].eq {
	pc = 0x829EEBA4; continue 'dispatch;
	}
	// 829EEB68: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EEB6C: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 829EEB70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829EEB74: 41990008  bgt cr6, 0x829eeb7c
	if ctx.cr[6].gt {
	pc = 0x829EEB7C; continue 'dispatch;
	}
	// 829EEB78: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x829EEB7C; continue 'dispatch;
            }
            0x829EEB7C => {
    //   block [0x829EEB7C..0x829EEBA4)
	// 829EEB7C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829EEB80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EEB84: 409A0020  bne cr6, 0x829eeba4
	if !ctx.cr[6].eq {
	pc = 0x829EEBA4; continue 'dispatch;
	}
	// 829EEB88: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829EEB8C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 829EEB90: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829EEB94: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EEB98: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829EEB9C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829EEBA0: 4800001C  b 0x829eebbc
	pc = 0x829EEBBC; continue 'dispatch;
            }
            0x829EEBA4 => {
    //   block [0x829EEBA4..0x829EEBB8)
	// 829EEBA4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829EEBA8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EEBAC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829EEBB0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829EEBB4: 48000008  b 0x829eebbc
	pc = 0x829EEBBC; continue 'dispatch;
            }
            0x829EEBB8 => {
    //   block [0x829EEBB8..0x829EEBBC)
	// 829EEBB8: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x829EEBBC; continue 'dispatch;
            }
            0x829EEBBC => {
    //   block [0x829EEBBC..0x829EEC50)
	// 829EEBBC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829EEBC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EEBC4: 419A02CC  beq cr6, 0x829eee90
	if ctx.cr[6].eq {
	pc = 0x829EEE90; continue 'dispatch;
	}
	// 829EEBC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EEBCC: 4B81294D  bl 0x82201518
	ctx.lr = 0x829EEBD0;
	sub_82201518(ctx, base);
	// 829EEBD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EEBD4: 419A02BC  beq cr6, 0x829eee90
	if ctx.cr[6].eq {
	pc = 0x829EEE90; continue 'dispatch;
	}
	// 829EEBD8: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 829EEBDC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829EEBE0: 92C10050  stw r22, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[22].u32 ) };
	// 829EEBE4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829EEBE8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829EEBEC: 4B8116F5  bl 0x822002e0
	ctx.lr = 0x829EEBF0;
	sub_822002E0(ctx, base);
	// 829EEBF0: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EEBF4: 83010050  lwz r24, 0x50(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829EEBF8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829EEBFC: 419A024C  beq cr6, 0x829eee48
	if ctx.cr[6].eq {
	pc = 0x829EEE48; continue 'dispatch;
	}
	// 829EEC00: 92C10074  stw r22, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[22].u32 ) };
	// 829EEC04: 38980024  addi r4, r24, 0x24
	ctx.r[4].s64 = ctx.r[24].s64 + 36;
	// 829EEC08: 92C10078  stw r22, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[22].u32 ) };
	// 829EEC0C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829EEC10: 92C1007C  stw r22, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[22].u32 ) };
	// 829EEC14: 4B8016DD  bl 0x821f02f0
	ctx.lr = 0x829EEC18;
	sub_821F02F0(ctx, base);
	// 829EEC18: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 829EEC1C: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829EEC20: 3B80000C  li r28, 0xc
	ctx.r[28].s64 = 12;
	// 829EEC24: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 829EEC28: 7D69E3D7  divw. r11, r9, r28
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[28].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EEC2C: 41820214  beq 0x829eee40
	if ctx.cr[0].eq {
	pc = 0x829EEE40; continue 'dispatch;
	}
	// 829EEC30: 3BCA0008  addi r30, r10, 8
	ctx.r[30].s64 = ctx.r[10].s64 + 8;
	// 829EEC34: 7D795B78  mr r25, r11
	ctx.r[25].u64 = ctx.r[11].u64;
	// 829EEC38: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 829EEC3C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 829EEC40: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829EEC44: 3BA9FFDF  addi r29, r9, -0x21
	ctx.r[29].s64 = ctx.r[9].s64 + -33;
	// 829EEC48: 3B6A1E08  addi r27, r10, 0x1e08
	ctx.r[27].s64 = ctx.r[10].s64 + 7688;
	// 829EEC4C: 3B4B13B8  addi r26, r11, 0x13b8
	ctx.r[26].s64 = ctx.r[11].s64 + 5048;
	pc = 0x829EEC50; continue 'dispatch;
            }
            0x829EEC50 => {
    //   block [0x829EEC50..0x829EEC7C)
	// 829EEC50: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 829EEC54: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829EEC58: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829EEC5C: 4B83E275  bl 0x8222ced0
	ctx.lr = 0x829EEC60;
	sub_8222CED0(ctx, base);
	// 829EEC60: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829EEC64: 62B50001  ori r21, r21, 1
	ctx.r[21].u64 = ctx.r[21].u64 | 1;
	// 829EEC68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EEC6C: 409A0010  bne cr6, 0x829eec7c
	if !ctx.cr[6].eq {
	pc = 0x829EEC7C; continue 'dispatch;
	}
	// 829EEC70: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 829EEC74: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829EEC78: 4800000C  b 0x829eec84
	pc = 0x829EEC84; continue 'dispatch;
            }
            0x829EEC7C => {
    //   block [0x829EEC7C..0x829EEC84)
	// 829EEC7C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EEC80: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829EEC84; continue 'dispatch;
            }
            0x829EEC84 => {
    //   block [0x829EEC84..0x829EEC98)
	// 829EEC84: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EEC88: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829EEC8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EEC90: 419A0008  beq cr6, 0x829eec98
	if ctx.cr[6].eq {
	pc = 0x829EEC98; continue 'dispatch;
	}
	// 829EEC94: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829EEC98; continue 'dispatch;
            }
            0x829EEC98 => {
    //   block [0x829EEC98..0x829EECCC)
	// 829EEC98: 482BB459  bl 0x82caa0f0
	ctx.lr = 0x829EEC9C;
	sub_82CAA0F0(ctx, base);
	// 829EEC9C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 829EECA0: 409A00B0  bne cr6, 0x829eed50
	if !ctx.cr[6].eq {
	pc = 0x829EED50; continue 'dispatch;
	}
	// 829EECA4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829EECA8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829EECAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EECB0: 4B83E221  bl 0x8222ced0
	ctx.lr = 0x829EECB4;
	sub_8222CED0(ctx, base);
	// 829EECB4: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EECB8: 62B50002  ori r21, r21, 2
	ctx.r[21].u64 = ctx.r[21].u64 | 2;
	// 829EECBC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829EECC0: 7ECAB378  mr r10, r22
	ctx.r[10].u64 = ctx.r[22].u64;
	// 829EECC4: 419A0008  beq cr6, 0x829eeccc
	if ctx.cr[6].eq {
	pc = 0x829EECCC; continue 'dispatch;
	}
	// 829EECC8: 81470004  lwz r10, 4(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x829EECCC; continue 'dispatch;
            }
            0x829EECCC => {
    //   block [0x829EECCC..0x829EECE0)
	// 829EECCC: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829EECD0: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 829EECD4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 829EECD8: 419A0008  beq cr6, 0x829eece0
	if ctx.cr[6].eq {
	pc = 0x829EECE0; continue 'dispatch;
	}
	// 829EECDC: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x829EECE0; continue 'dispatch;
            }
            0x829EECE0 => {
    //   block [0x829EECE0..0x829EECF8)
	// 829EECE0: 7D2B5051  subf. r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829EECE4: 41800058  blt 0x829eed3c
	if ctx.cr[0].lt {
	pc = 0x829EED3C; continue 'dispatch;
	}
	// 829EECE8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 829EECEC: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 829EECF0: 419A0008  beq cr6, 0x829eecf8
	if ctx.cr[6].eq {
	pc = 0x829EECF8; continue 'dispatch;
	}
	// 829EECF4: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829EECF8; continue 'dispatch;
            }
            0x829EECF8 => {
    //   block [0x829EECF8..0x829EED08)
	// 829EECF8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829EECFC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 829EED00: 419A0008  beq cr6, 0x829eed08
	if ctx.cr[6].eq {
	pc = 0x829EED08; continue 'dispatch;
	}
	// 829EED04: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829EED08; continue 'dispatch;
            }
            0x829EED08 => {
    //   block [0x829EED08..0x829EED0C)
	// 829EED08: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x829EED0C; continue 'dispatch;
            }
            0x829EED0C => {
    //   block [0x829EED0C..0x829EED30)
	// 829EED0C: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EED10: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EED14: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829EED18: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 829EED1C: 419A0014  beq cr6, 0x829eed30
	if ctx.cr[6].eq {
	pc = 0x829EED30; continue 'dispatch;
	}
	// 829EED20: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EED24: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829EED28: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829EED2C: 419AFFE0  beq cr6, 0x829eed0c
	if ctx.cr[6].eq {
	pc = 0x829EED0C; continue 'dispatch;
	}
	pc = 0x829EED30; continue 'dispatch;
            }
            0x829EED30 => {
    //   block [0x829EED30..0x829EED3C)
	// 829EED30: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 829EED34: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 829EED38: 48000008  b 0x829eed40
	pc = 0x829EED40; continue 'dispatch;
            }
            0x829EED3C => {
    //   block [0x829EED3C..0x829EED40)
	// 829EED3C: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x829EED40; continue 'dispatch;
            }
            0x829EED40 => {
    //   block [0x829EED40..0x829EED50)
	// 829EED40: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829EED44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EED48: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829EED4C: 409A0008  bne cr6, 0x829eed54
	if !ctx.cr[6].eq {
	pc = 0x829EED54; continue 'dispatch;
	}
	pc = 0x829EED50; continue 'dispatch;
            }
            0x829EED50 => {
    //   block [0x829EED50..0x829EED54)
	// 829EED50: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x829EED54; continue 'dispatch;
            }
            0x829EED54 => {
    //   block [0x829EED54..0x829EED70)
	// 829EED54: 56AA07BC  rlwinm r10, r21, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[21].u32 as u64 & 0xFFFFFFFFu64;
	// 829EED58: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829EED5C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 829EED60: 419A0010  beq cr6, 0x829eed70
	if ctx.cr[6].eq {
	pc = 0x829EED70; continue 'dispatch;
	}
	// 829EED64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EED68: 56B507FA  rlwinm r21, r21, 0, 0x1f, 0x1d
	ctx.r[21].u64 = ctx.r[21].u32 as u64 & 0xFFFFFFFFu64;
	// 829EED6C: 4B82606D  bl 0x82214dd8
	ctx.lr = 0x829EED70;
	sub_82214DD8(ctx, base);
	pc = 0x829EED70; continue 'dispatch;
            }
            0x829EED70 => {
    //   block [0x829EED70..0x829EED88)
	// 829EED70: 56AB07FE  clrlwi r11, r21, 0x1f
	ctx.r[11].u64 = ctx.r[21].u32 as u64 & 0x00000001u64;
	// 829EED74: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EED78: 419A0010  beq cr6, 0x829eed88
	if ctx.cr[6].eq {
	pc = 0x829EED88; continue 'dispatch;
	}
	// 829EED7C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829EED80: 56B5003C  rlwinm r21, r21, 0, 0, 0x1e
	ctx.r[21].u64 = ctx.r[21].u32 as u64 & 0xFFFFFFFFu64;
	// 829EED84: 4B826055  bl 0x82214dd8
	ctx.lr = 0x829EED88;
	sub_82214DD8(ctx, base);
	pc = 0x829EED88; continue 'dispatch;
            }
            0x829EED88 => {
    //   block [0x829EED88..0x829EEDA8)
	// 829EED88: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 829EED8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EED90: 419A00A4  beq cr6, 0x829eee34
	if ctx.cr[6].eq {
	pc = 0x829EEE34; continue 'dispatch;
	}
	// 829EED94: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EED98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EED9C: 409A000C  bne cr6, 0x829eeda8
	if !ctx.cr[6].eq {
	pc = 0x829EEDA8; continue 'dispatch;
	}
	// 829EEDA0: 7ECAB378  mr r10, r22
	ctx.r[10].u64 = ctx.r[22].u64;
	// 829EEDA4: 48000010  b 0x829eedb4
	pc = 0x829EEDB4; continue 'dispatch;
            }
            0x829EEDA8 => {
    //   block [0x829EEDA8..0x829EEDB4)
	// 829EEDA8: 81570008  lwz r10, 8(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EEDAC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 829EEDB0: 7D49E3D6  divw r10, r9, r28
	ctx.r[10].s32 = ctx.r[9].s32 / ctx.r[28].s32;
	pc = 0x829EEDB4; continue 'dispatch;
            }
            0x829EEDB4 => {
    //   block [0x829EEDB4..0x829EEDFC)
	// 829EEDB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EEDB8: 419A0050  beq cr6, 0x829eee08
	if ctx.cr[6].eq {
	pc = 0x829EEE08; continue 'dispatch;
	}
	// 829EEDBC: 8137000C  lwz r9, 0xc(r23)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(12 as u32) ) } as u64;
	// 829EEDC0: 7D0B4850  subf r8, r11, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 829EEDC4: 7CE8E3D6  divw r7, r8, r28
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[28].s32;
	// 829EEDC8: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 829EEDCC: 4098003C  bge cr6, 0x829eee08
	if !ctx.cr[6].lt {
	pc = 0x829EEE08; continue 'dispatch;
	}
	// 829EEDD0: 83F70008  lwz r31, 8(r23)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EEDD4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EEDD8: 419A0024  beq cr6, 0x829eedfc
	if ctx.cr[6].eq {
	pc = 0x829EEDFC; continue 'dispatch;
	}
	// 829EEDDC: C01EFFF8  lfs f0, -8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EEDE0: 389EFFFC  addi r4, r30, -4
	ctx.r[4].s64 = ctx.r[30].s64 + -4;
	// 829EEDE4: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829EEDE8: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 829EEDEC: 4B801455  bl 0x821f0240
	ctx.lr = 0x829EEDF0;
	sub_821F0240(ctx, base);
	// 829EEDF0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829EEDF4: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 829EEDF8: 4B801449  bl 0x821f0240
	ctx.lr = 0x829EEDFC;
	sub_821F0240(ctx, base);
	pc = 0x829EEDFC; continue 'dispatch;
            }
            0x829EEDFC => {
    //   block [0x829EEDFC..0x829EEE08)
	// 829EEDFC: 397F000C  addi r11, r31, 0xc
	ctx.r[11].s64 = ctx.r[31].s64 + 12;
	// 829EEE00: 91770008  stw r11, 8(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 829EEE04: 48000030  b 0x829eee34
	pc = 0x829EEE34; continue 'dispatch;
            }
            0x829EEE08 => {
    //   block [0x829EEE08..0x829EEE18)
	// 829EEE08: 81570008  lwz r10, 8(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EEE0C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829EEE10: 40990008  ble cr6, 0x829eee18
	if !ctx.cr[6].gt {
	pc = 0x829EEE18; continue 'dispatch;
	}
	// 829EEE14: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829EEE18; continue 'dispatch;
            }
            0x829EEE18 => {
    //   block [0x829EEE18..0x829EEE34)
	// 829EEE18: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 829EEE1C: 38DEFFF8  addi r6, r30, -8
	ctx.r[6].s64 = ctx.r[30].s64 + -8;
	// 829EEE20: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 829EEE24: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 829EEE28: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829EEE2C: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 829EEE30: 48000901  bl 0x829ef730
	ctx.lr = 0x829EEE34;
	sub_829EF730(ctx, base);
	pc = 0x829EEE34; continue 'dispatch;
            }
            0x829EEE34 => {
    //   block [0x829EEE34..0x829EEE40)
	// 829EEE34: 3739FFFF  addic. r25, r25, -1
	ctx.xer.ca = (ctx.r[25].u32 > (!(-1 as u32)));
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 829EEE38: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 829EEE3C: 4082FE14  bne 0x829eec50
	if !ctx.cr[0].eq {
	pc = 0x829EEC50; continue 'dispatch;
	}
	pc = 0x829EEE40; continue 'dispatch;
            }
            0x829EEE40 => {
    //   block [0x829EEE40..0x829EEE48)
	// 829EEE40: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829EEE44: 48000895  bl 0x829ef6d8
	ctx.lr = 0x829EEE48;
	sub_829EF6D8(ctx, base);
	pc = 0x829EEE48; continue 'dispatch;
            }
            0x829EEE48 => {
    //   block [0x829EEE48..0x829EEE54)
	// 829EEE48: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 829EEE4C: 419A0044  beq cr6, 0x829eee90
	if ctx.cr[6].eq {
	pc = 0x829EEE90; continue 'dispatch;
	}
	// 829EEE50: 39780004  addi r11, r24, 4
	ctx.r[11].s64 = ctx.r[24].s64 + 4;
	pc = 0x829EEE54; continue 'dispatch;
            }
            0x829EEE54 => {
    //   block [0x829EEE54..0x829EEE90)
	// 829EEE54: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829EEE58: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829EEE5C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829EEE60: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 829EEE64: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829EEE68: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829EEE6C: 4082FFE8  bne 0x829eee54
	if !ctx.cr[0].eq {
	pc = 0x829EEE54; continue 'dispatch;
	}
	// 829EEE70: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 829EEE74: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EEE78: 409A0018  bne cr6, 0x829eee90
	if !ctx.cr[6].eq {
	pc = 0x829EEE90; continue 'dispatch;
	}
	// 829EEE7C: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EEE80: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829EEE84: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EEE88: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829EEE8C: 4E800421  bctrl
	ctx.lr = 0x829EEE90;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x829EEE90 => {
    //   block [0x829EEE90..0x829EEE98)
	// 829EEE90: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 829EEE94: 482BA5A8  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EEE98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EEE98 size=756
    let mut pc: u32 = 0x829EEE98;
    'dispatch: loop {
        match pc {
            0x829EEE98 => {
    //   block [0x829EEE98..0x829EEF04)
	// 829EEE98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EEE9C: 482BA559  bl 0x82ca93f4
	ctx.lr = 0x829EEEA0;
	sub_82CA93D0(ctx, base);
	// 829EEEA0: DBC1FFA0  stfd f30, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[30].u64 ) };
	// 829EEEA4: DBE1FFA8  stfd f31, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 829EEEA8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EEEAC: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 829EEEB0: 89780070  lbz r11, 0x70(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[24].u32.wrapping_add(112 as u32) ) } as u64;
	// 829EEEB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EEEB8: 409A02C4  bne cr6, 0x829ef17c
	if !ctx.cr[6].eq {
	pc = 0x829EF17C; continue 'dispatch;
	}
	// 829EEEBC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829EEEC0: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 829EEEC4: 4B7855A5  bl 0x82174468
	ctx.lr = 0x829EEEC8;
	sub_82174468(ctx, base);
	// 829EEEC8: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 829EEECC: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 829EEED0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829EEED4: 419A00F4  beq cr6, 0x829eefc8
	if ctx.cr[6].eq {
	pc = 0x829EEFC8; continue 'dispatch;
	}
	// 829EEED8: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 829EEEDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EEEE0: 419A0024  beq cr6, 0x829eef04
	if ctx.cr[6].eq {
	pc = 0x829EEF04; continue 'dispatch;
	}
	// 829EEEE4: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 829EEEE8: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829EEEEC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 829EEEF0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829EEEF4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EEEF8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829EEEFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829EEF00: 480000CC  b 0x829eefcc
	pc = 0x829EEFCC; continue 'dispatch;
            }
            0x829EEF04 => {
    //   block [0x829EEF04..0x829EEF20)
	// 829EEF04: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829EEF08: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 829EEF0C: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 829EEF10: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829EEF14: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 829EEF18: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EEF1C: 40810054  ble 0x829eef70
	if !ctx.cr[0].gt {
	pc = 0x829EEF70; continue 'dispatch;
	}
	pc = 0x829EEF20; continue 'dispatch;
            }
            0x829EEF20 => {
    //   block [0x829EEF20..0x829EEF40)
	// 829EEF20: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829EEF24: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829EEF28: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829EEF2C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EEF30: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 829EEF34: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829EEF38: 41980008  blt cr6, 0x829eef40
	if ctx.cr[6].lt {
	pc = 0x829EEF40; continue 'dispatch;
	}
	// 829EEF3C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x829EEF40; continue 'dispatch;
            }
            0x829EEF40 => {
    //   block [0x829EEF40..0x829EEF5C)
	// 829EEF40: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829EEF44: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829EEF48: 419A0014  beq cr6, 0x829eef5c
	if ctx.cr[6].eq {
	pc = 0x829EEF5C; continue 'dispatch;
	}
	// 829EEF4C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829EEF50: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829EEF54: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829EEF58: 4800000C  b 0x829eef64
	pc = 0x829EEF64; continue 'dispatch;
            }
            0x829EEF5C => {
    //   block [0x829EEF5C..0x829EEF64)
	// 829EEF5C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829EEF60: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829EEF64; continue 'dispatch;
            }
            0x829EEF64 => {
    //   block [0x829EEF64..0x829EEF70)
	// 829EEF64: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EEF68: 4199FFB8  bgt cr6, 0x829eef20
	if ctx.cr[6].gt {
	pc = 0x829EEF20; continue 'dispatch;
	}
	// 829EEF6C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x829EEF70; continue 'dispatch;
            }
            0x829EEF70 => {
    //   block [0x829EEF70..0x829EEF8C)
	// 829EEF70: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829EEF74: 419A0040  beq cr6, 0x829eefb4
	if ctx.cr[6].eq {
	pc = 0x829EEFB4; continue 'dispatch;
	}
	// 829EEF78: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EEF7C: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 829EEF80: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829EEF84: 41990008  bgt cr6, 0x829eef8c
	if ctx.cr[6].gt {
	pc = 0x829EEF8C; continue 'dispatch;
	}
	// 829EEF88: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x829EEF8C; continue 'dispatch;
            }
            0x829EEF8C => {
    //   block [0x829EEF8C..0x829EEFB4)
	// 829EEF8C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829EEF90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EEF94: 409A0020  bne cr6, 0x829eefb4
	if !ctx.cr[6].eq {
	pc = 0x829EEFB4; continue 'dispatch;
	}
	// 829EEF98: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829EEF9C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 829EEFA0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829EEFA4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EEFA8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829EEFAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829EEFB0: 4800001C  b 0x829eefcc
	pc = 0x829EEFCC; continue 'dispatch;
            }
            0x829EEFB4 => {
    //   block [0x829EEFB4..0x829EEFC8)
	// 829EEFB4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829EEFB8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EEFBC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829EEFC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829EEFC4: 48000008  b 0x829eefcc
	pc = 0x829EEFCC; continue 'dispatch;
            }
            0x829EEFC8 => {
    //   block [0x829EEFC8..0x829EEFCC)
	// 829EEFC8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x829EEFCC; continue 'dispatch;
            }
            0x829EEFCC => {
    //   block [0x829EEFCC..0x829EF028)
	// 829EEFCC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829EEFD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EEFD4: 419A01A8  beq cr6, 0x829ef17c
	if ctx.cr[6].eq {
	pc = 0x829EF17C; continue 'dispatch;
	}
	// 829EEFD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EEFDC: 4B81253D  bl 0x82201518
	ctx.lr = 0x829EEFE0;
	sub_82201518(ctx, base);
	// 829EEFE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EEFE4: 419A0198  beq cr6, 0x829ef17c
	if ctx.cr[6].eq {
	pc = 0x829EF17C; continue 'dispatch;
	}
	// 829EEFE8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EEFEC: C3E30020  lfs f31, 0x20(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829EEFF0: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 829EEFF4: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 829EEFF8: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	// 829EEFFC: 3B80000C  li r28, 0xc
	ctx.r[28].s64 = 12;
	// 829EF000: C80B0120  lfd f0, 0x120(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(288 as u32) ) };
	// 829EF004: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 829EF008: C9AA9660  lfd f13, -0x69a0(r10)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-27040 as u32) ) };
	// 829EF00C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 829EF010: FC006824  fdiv f0, f0, f13
	ctx.f[0].f64 = ctx.f[0].f64 / ctx.f[13].f64;
	// 829EF014: 3BABFFDF  addi r29, r11, -0x21
	ctx.r[29].s64 = ctx.r[11].s64 + -33;
	// 829EF018: 3B4AB980  addi r26, r10, -0x4680
	ctx.r[26].s64 = ctx.r[10].s64 + -18048;
	// 829EF01C: 3B29B988  addi r25, r9, -0x4678
	ctx.r[25].s64 = ctx.r[9].s64 + -18040;
	// 829EF020: FDBF0028  fsub f13, f31, f0
	ctx.f[13].f64 = ctx.f[31].f64 - ctx.f[0].f64;
	// 829EF024: FFC06818  frsp f30, f13
	ctx.f[30].f64 = (ctx.f[13].f64 as f32) as f64;
	pc = 0x829EF028; continue 'dispatch;
            }
            0x829EF028 => {
    //   block [0x829EF028..0x829EF068)
	// 829EF028: 81780078  lwz r11, 0x78(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(120 as u32) ) } as u64;
	// 829EF02C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EF030: 419A014C  beq cr6, 0x829ef17c
	if ctx.cr[6].eq {
	pc = 0x829EF17C; continue 'dispatch;
	}
	// 829EF034: 8158007C  lwz r10, 0x7c(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(124 as u32) ) } as u64;
	// 829EF038: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 829EF03C: 7D09E3D6  divw r8, r9, r28
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[28].s32;
	// 829EF040: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 829EF044: 40980138  bge cr6, 0x829ef17c
	if !ctx.cr[6].lt {
	pc = 0x829EF17C; continue 'dispatch;
	}
	// 829EF048: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EF04C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EF050: 419A0018  beq cr6, 0x829ef068
	if ctx.cr[6].eq {
	pc = 0x829EF068; continue 'dispatch;
	}
	// 829EF054: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829EF058: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 829EF05C: 7D09E3D6  divw r8, r9, r28
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[28].s32;
	// 829EF060: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 829EF064: 41980008  blt cr6, 0x829ef06c
	if ctx.cr[6].lt {
	pc = 0x829EF06C; continue 'dispatch;
	}
	pc = 0x829EF068; continue 'dispatch;
            }
            0x829EF068 => {
    //   block [0x829EF068..0x829EF06C)
	// 829EF068: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829EF06C; continue 'dispatch;
            }
            0x829EF06C => {
    //   block [0x829EF06C..0x829EF0A8)
	// 829EF06C: 7C1B5C2E  lfsx f0, r27, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EF070: 7FFB5A14  add r31, r27, r11
	ctx.r[31].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 829EF074: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 829EF078: 409900C4  ble cr6, 0x829ef13c
	if !ctx.cr[6].gt {
	pc = 0x829EF13C; continue 'dispatch;
	}
	// 829EF07C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 829EF080: 419900BC  bgt cr6, 0x829ef13c
	if ctx.cr[6].gt {
	pc = 0x829EF13C; continue 'dispatch;
	}
	// 829EF084: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 829EF088: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829EF08C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EF090: 4B83DE41  bl 0x8222ced0
	ctx.lr = 0x829EF094;
	sub_8222CED0(ctx, base);
	// 829EF094: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829EF098: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829EF09C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EF0A0: 419A0008  beq cr6, 0x829ef0a8
	if ctx.cr[6].eq {
	pc = 0x829EF0A8; continue 'dispatch;
	}
	// 829EF0A4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829EF0A8; continue 'dispatch;
            }
            0x829EF0A8 => {
    //   block [0x829EF0A8..0x829EF0BC)
	// 829EF0A8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EF0AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829EF0B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EF0B4: 419A0008  beq cr6, 0x829ef0bc
	if ctx.cr[6].eq {
	pc = 0x829EF0BC; continue 'dispatch;
	}
	// 829EF0B8: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829EF0BC; continue 'dispatch;
            }
            0x829EF0BC => {
    //   block [0x829EF0BC..0x829EF104)
	// 829EF0BC: 4B7F770D  bl 0x821e67c8
	ctx.lr = 0x829EF0C0;
	sub_821E67C8(ctx, base);
	// 829EF0C0: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 829EF0C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EF0C8: 556ADFFE  rlwinm r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 829EF0CC: 69570001  xori r23, r10, 1
	ctx.r[23].u64 = ctx.r[10].u64 ^ 1;
	// 829EF0D0: 4B825D09  bl 0x82214dd8
	ctx.lr = 0x829EF0D4;
	sub_82214DD8(ctx, base);
	// 829EF0D4: 56E9063E  clrlwi r9, r23, 0x18
	ctx.r[9].u64 = ctx.r[23].u32 as u64 & 0x000000FFu64;
	// 829EF0D8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829EF0DC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829EF0E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829EF0E4: 409A0064  bne cr6, 0x829ef148
	if !ctx.cr[6].eq {
	pc = 0x829EF148; continue 'dispatch;
	}
	// 829EF0E8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 829EF0EC: 4B83DDE5  bl 0x8222ced0
	ctx.lr = 0x829EF0F0;
	sub_8222CED0(ctx, base);
	// 829EF0F0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829EF0F4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829EF0F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EF0FC: 419A0008  beq cr6, 0x829ef104
	if ctx.cr[6].eq {
	pc = 0x829EF104; continue 'dispatch;
	}
	// 829EF100: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829EF104; continue 'dispatch;
            }
            0x829EF104 => {
    //   block [0x829EF104..0x829EF118)
	// 829EF104: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EF108: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829EF10C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EF110: 419A0008  beq cr6, 0x829ef118
	if ctx.cr[6].eq {
	pc = 0x829EF118; continue 'dispatch;
	}
	// 829EF114: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829EF118; continue 'dispatch;
            }
            0x829EF118 => {
    //   block [0x829EF118..0x829EF13C)
	// 829EF118: 4B7F76B1  bl 0x821e67c8
	ctx.lr = 0x829EF11C;
	sub_821E67C8(ctx, base);
	// 829EF11C: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 829EF120: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829EF124: 556ADFFE  rlwinm r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 829EF128: 695F0001  xori r31, r10, 1
	ctx.r[31].u64 = ctx.r[10].u64 ^ 1;
	// 829EF12C: 4B825CAD  bl 0x82214dd8
	ctx.lr = 0x829EF130;
	sub_82214DD8(ctx, base);
	// 829EF130: 57E9063E  clrlwi r9, r31, 0x18
	ctx.r[9].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 829EF134: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829EF138: 409A001C  bne cr6, 0x829ef154
	if !ctx.cr[6].eq {
	pc = 0x829EF154; continue 'dispatch;
	}
	pc = 0x829EF13C; continue 'dispatch;
            }
            0x829EF13C => {
    //   block [0x829EF13C..0x829EF148)
	// 829EF13C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 829EF140: 3B7B000C  addi r27, r27, 0xc
	ctx.r[27].s64 = ctx.r[27].s64 + 12;
	// 829EF144: 4BFFFEE4  b 0x829ef028
	pc = 0x829EF028; continue 'dispatch;
            }
            0x829EF148 => {
    //   block [0x829EF148..0x829EF154)
	// 829EF148: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 829EF14C: 388BEF80  addi r4, r11, -0x1080
	ctx.r[4].s64 = ctx.r[11].s64 + -4224;
	// 829EF150: 48000014  b 0x829ef164
	pc = 0x829EF164; continue 'dispatch;
            }
            0x829EF154 => {
    //   block [0x829EF154..0x829EF164)
	// 829EF154: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 829EF158: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829EF15C: 388BEF7C  addi r4, r11, -0x1084
	ctx.r[4].s64 = ctx.r[11].s64 + -4228;
	// 829EF160: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	pc = 0x829EF164; continue 'dispatch;
            }
            0x829EF164 => {
    //   block [0x829EF164..0x829EF17C)
	// 829EF164: 4B83DD6D  bl 0x8222ced0
	ctx.lr = 0x829EF168;
	sub_8222CED0(ctx, base);
	// 829EF168: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829EF16C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829EF170: 48000021  bl 0x829ef190
	ctx.lr = 0x829EF174;
	sub_829EF190(ctx, base);
	// 829EF174: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829EF178: 4B825C61  bl 0x82214dd8
	ctx.lr = 0x829EF17C;
	sub_82214DD8(ctx, base);
	pc = 0x829EF17C; continue 'dispatch;
            }
            0x829EF17C => {
    //   block [0x829EF17C..0x829EF18C)
	// 829EF17C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829EF180: CBC1FFA0  lfd f30, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 829EF184: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 829EF188: 482BA2BC  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EF190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EF190 size=704
    let mut pc: u32 = 0x829EF190;
    'dispatch: loop {
        match pc {
            0x829EF190 => {
    //   block [0x829EF190..0x829EF204)
	// 829EF190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EF194: 482BA271  bl 0x82ca9404
	ctx.lr = 0x829EF198;
	sub_82CA93D0(ctx, base);
	// 829EF198: DBA1FFB8  stfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[29].u64 ) };
	// 829EF19C: DBC1FFC0  stfd f30, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 829EF1A0: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 829EF1A4: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EF1A8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EF1AC: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 829EF1B0: 3BFE0054  addi r31, r30, 0x54
	ctx.r[31].s64 = ctx.r[30].s64 + 84;
	// 829EF1B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EF1B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EF1BC: 4B7F3F4D  bl 0x821e3108
	ctx.lr = 0x829EF1C0;
	sub_821E3108(ctx, base);
	// 829EF1C0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829EF1C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EF1C8: 4B875FD9  bl 0x822651a0
	ctx.lr = 0x829EF1CC;
	sub_822651A0(ctx, base);
	// 829EF1CC: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 829EF1D0: 4B830089  bl 0x8221f258
	ctx.lr = 0x829EF1D4;
	sub_8221F258(ctx, base);
	// 829EF1D4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829EF1D8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829EF1DC: 419A0028  beq cr6, 0x829ef204
	if ctx.cr[6].eq {
	pc = 0x829EF204; continue 'dispatch;
	}
	// 829EF1E0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829EF1E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829EF1E8: 4BF829C9  bl 0x82971bb0
	ctx.lr = 0x829EF1EC;
	sub_82971BB0(ctx, base);
	// 829EF1EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EF1F0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829EF1F4: 394B2BF4  addi r10, r11, 0x2bf4
	ctx.r[10].s64 = ctx.r[11].s64 + 11252;
	// 829EF1F8: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829EF1FC: 93FD002C  stw r31, 0x2c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(44 as u32), ctx.r[31].u32 ) };
	// 829EF200: 4800000C  b 0x829ef20c
	pc = 0x829EF20C; continue 'dispatch;
            }
            0x829EF204 => {
    //   block [0x829EF204..0x829EF20C)
	// 829EF204: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829EF208: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	pc = 0x829EF20C; continue 'dispatch;
            }
            0x829EF20C => {
    //   block [0x829EF20C..0x829EF2A4)
	// 829EF20C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829EF210: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829EF214: 4B7CC89D  bl 0x821bbab0
	ctx.lr = 0x829EF218;
	sub_821BBAB0(ctx, base);
	// 829EF218: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EF21C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EF220: 4B87CC49  bl 0x8226be68
	ctx.lr = 0x829EF224;
	sub_8226BE68(ctx, base);
	// 829EF224: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829EF228: 4B7C88F1  bl 0x821b7b18
	ctx.lr = 0x829EF22C;
	sub_821B7B18(ctx, base);
	// 829EF22C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EF230: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829EF234: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 829EF238: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829EF23C: 4E800421  bctrl
	ctx.lr = 0x829EF240;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EF240: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 829EF244: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 829EF248: 4B830011  bl 0x8221f258
	ctx.lr = 0x829EF24C;
	sub_8221F258(ctx, base);
	// 829EF24C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829EF250: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EF254: 39099490  addi r8, r9, -0x6b70
	ctx.r[8].s64 = ctx.r[9].s64 + -27504;
	// 829EF258: C3A99490  lfs f29, -0x6b70(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 829EF25C: C3E8FFF4  lfs f31, -0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829EF260: 419A0044  beq cr6, 0x829ef2a4
	if ctx.cr[6].eq {
	pc = 0x829EF2A4; continue 'dispatch;
	}
	// 829EF264: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EF268: C01E006C  lfs f0, 0x6c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EF26C: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 829EF270: D3E30008  stfs f31, 8(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829EF274: 392B21E0  addi r9, r11, 0x21e0
	ctx.r[9].s64 = ctx.r[11].s64 + 8672;
	// 829EF278: D3E3000C  stfs f31, 0xc(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829EF27C: D3C30010  stfs f30, 0x10(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 829EF280: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829EF284: D3A30014  stfs f29, 0x14(r3)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 829EF288: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 829EF28C: D0030020  stfs f0, 0x20(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 829EF290: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829EF294: 9BE3001C  stb r31, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[31].u8 ) };
	// 829EF298: 9BE3001D  stb r31, 0x1d(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(29 as u32), ctx.r[31].u8 ) };
	// 829EF29C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829EF2A0: 48000008  b 0x829ef2a8
	pc = 0x829EF2A8; continue 'dispatch;
            }
            0x829EF2A4 => {
    //   block [0x829EF2A4..0x829EF2A8)
	// 829EF2A4: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	pc = 0x829EF2A8; continue 'dispatch;
            }
            0x829EF2A8 => {
    //   block [0x829EF2A8..0x829EF310)
	// 829EF2A8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EF2AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829EF2B0: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 829EF2B4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829EF2B8: 4E800421  bctrl
	ctx.lr = 0x829EF2BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EF2BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EF2C0: 419A0050  beq cr6, 0x829ef310
	if ctx.cr[6].eq {
	pc = 0x829EF310; continue 'dispatch;
	}
	// 829EF2C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EF2C8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829EF2CC: 388B1808  addi r4, r11, 0x1808
	ctx.r[4].s64 = ctx.r[11].s64 + 6152;
	// 829EF2D0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829EF2D4: 4B83DBFD  bl 0x8222ced0
	ctx.lr = 0x829EF2D8;
	sub_8222CED0(ctx, base);
	// 829EF2D8: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EF2DC: 3B610054  addi r27, r1, 0x54
	ctx.r[27].s64 = ctx.r[1].s64 + 84;
	// 829EF2E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829EF2E4: 812A0020  lwz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 829EF2E8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 829EF2EC: 4E800421  bctrl
	ctx.lr = 0x829EF2F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EF2F0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829EF2F4: 4B87E2CD  bl 0x8226d5c0
	ctx.lr = 0x829EF2F8;
	sub_8226D5C0(ctx, base);
	// 829EF2F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829EF2FC: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 829EF300: 4B825AD9  bl 0x82214dd8
	ctx.lr = 0x829EF304;
	sub_82214DD8(ctx, base);
	// 829EF304: FF1EF800  fcmpu cr6, f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 829EF308: 40990008  ble cr6, 0x829ef310
	if !ctx.cr[6].gt {
	pc = 0x829EF310; continue 'dispatch;
	}
	// 829EF30C: D3DC0008  stfs f30, 8(r28)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), tmp.u32 ) };
            }
            0x829EF310 => {
    //   block [0x829EF310..0x829EF370)
	// 829EF310: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829EF314: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EF318: 4B7CC799  bl 0x821bbab0
	ctx.lr = 0x829EF31C;
	sub_821BBAB0(ctx, base);
	// 829EF31C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EF320: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EF324: 4B87CB45  bl 0x8226be68
	ctx.lr = 0x829EF328;
	sub_8226BE68(ctx, base);
	// 829EF328: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EF32C: 4B7C87ED  bl 0x821b7b18
	ctx.lr = 0x829EF330;
	sub_821B7B18(ctx, base);
	// 829EF330: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 829EF334: 387E000C  addi r3, r30, 0xc
	ctx.r[3].s64 = ctx.r[30].s64 + 12;
	// 829EF338: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 829EF33C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EF340: 419A0030  beq cr6, 0x829ef370
	if ctx.cr[6].eq {
	pc = 0x829EF370; continue 'dispatch;
	}
	// 829EF344: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EF348: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829EF34C: 419A0040  beq cr6, 0x829ef38c
	if ctx.cr[6].eq {
	pc = 0x829EF38C; continue 'dispatch;
	}
	// 829EF350: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EF354: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EF358: 419A0018  beq cr6, 0x829ef370
	if ctx.cr[6].eq {
	pc = 0x829EF370; continue 'dispatch;
	}
	// 829EF35C: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 829EF360: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829EF364: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 829EF368: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829EF36C: 409A0008  bne cr6, 0x829ef374
	if !ctx.cr[6].eq {
	pc = 0x829EF374; continue 'dispatch;
	}
	pc = 0x829EF370; continue 'dispatch;
            }
            0x829EF370 => {
    //   block [0x829EF370..0x829EF374)
	// 829EF370: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x829EF374; continue 'dispatch;
            }
            0x829EF374 => {
    //   block [0x829EF374..0x829EF38C)
	// 829EF374: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829EF378: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EF37C: 419A0018  beq cr6, 0x829ef394
	if ctx.cr[6].eq {
	pc = 0x829EF394; continue 'dispatch;
	}
	// 829EF380: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EF384: C3CB9048  lfs f30, -0x6fb8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28600 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829EF388: 48000010  b 0x829ef398
	pc = 0x829EF398; continue 'dispatch;
            }
            0x829EF38C => {
    //   block [0x829EF38C..0x829EF394)
	// 829EF38C: 4B7A4AAD  bl 0x82193e38
	ctx.lr = 0x829EF390;
	sub_82193E38(ctx, base);
	// 829EF390: 4BFFFFE0  b 0x829ef370
	pc = 0x829EF370; continue 'dispatch;
            }
            0x829EF394 => {
    //   block [0x829EF394..0x829EF398)
	// 829EF394: FFC0F890  fmr f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[31].f64;
	pc = 0x829EF398; continue 'dispatch;
            }
            0x829EF398 => {
    //   block [0x829EF398..0x829EF40C)
	// 829EF398: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 829EF39C: 4B82FEBD  bl 0x8221f258
	ctx.lr = 0x829EF3A0;
	sub_8221F258(ctx, base);
	// 829EF3A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EF3A4: 419A0068  beq cr6, 0x829ef40c
	if ctx.cr[6].eq {
	pc = 0x829EF40C; continue 'dispatch;
	}
	// 829EF3A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EF3AC: D3E30008  stfs f31, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829EF3B0: D3A30024  stfs f29, 0x24(r3)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 829EF3B4: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829EF3B8: 394B1DEC  addi r10, r11, 0x1dec
	ctx.r[10].s64 = ctx.r[11].s64 + 7660;
	// 829EF3BC: D3A30028  stfs f29, 0x28(r3)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 829EF3C0: D3E3002C  stfs f31, 0x2c(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 829EF3C4: 9BA3000C  stb r29, 0xc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[29].u8 ) };
	// 829EF3C8: D3C30030  stfs f30, 0x30(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 829EF3CC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829EF3D0: D3E30034  stfs f31, 0x34(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 829EF3D4: 9BE3000D  stb r31, 0xd(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(13 as u32), ctx.r[31].u8 ) };
	// 829EF3D8: D3E30038  stfs f31, 0x38(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 829EF3DC: 9BE3000E  stb r31, 0xe(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(14 as u32), ctx.r[31].u8 ) };
	// 829EF3E0: D3E3003C  stfs f31, 0x3c(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 829EF3E4: 9BE30020  stb r31, 0x20(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[31].u8 ) };
	// 829EF3E8: 9BE30040  stb r31, 0x40(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[31].u8 ) };
	// 829EF3EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EF3F0: 9BE30041  stb r31, 0x41(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(65 as u32), ctx.r[31].u8 ) };
	// 829EF3F4: 9BE30042  stb r31, 0x42(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(66 as u32), ctx.r[31].u8 ) };
	// 829EF3F8: 9BE30043  stb r31, 0x43(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(67 as u32), ctx.r[31].u8 ) };
	// 829EF3FC: 93E30048  stw r31, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[31].u32 ) };
	// 829EF400: 93E3004C  stw r31, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 829EF404: 9BA30054  stb r29, 0x54(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[29].u8 ) };
	// 829EF408: 48000008  b 0x829ef410
	pc = 0x829EF410; continue 'dispatch;
            }
            0x829EF40C => {
    //   block [0x829EF40C..0x829EF410)
	// 829EF40C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	pc = 0x829EF410; continue 'dispatch;
            }
            0x829EF410 => {
    //   block [0x829EF410..0x829EF450)
	// 829EF410: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829EF414: 4B7CC69D  bl 0x821bbab0
	ctx.lr = 0x829EF418;
	sub_821BBAB0(ctx, base);
	// 829EF418: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EF41C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EF420: 4B87CA49  bl 0x8226be68
	ctx.lr = 0x829EF424;
	sub_8226BE68(ctx, base);
	// 829EF424: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829EF428: 4B7C86F1  bl 0x821b7b18
	ctx.lr = 0x829EF42C;
	sub_821B7B18(ctx, base);
	// 829EF42C: 9BBE0070  stb r29, 0x70(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(112 as u32), ctx.r[29].u8 ) };
	// 829EF430: 9BFE004F  stb r31, 0x4f(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(79 as u32), ctx.r[31].u8 ) };
	// 829EF434: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EF438: 4B8259A1  bl 0x82214dd8
	ctx.lr = 0x829EF43C;
	sub_82214DD8(ctx, base);
	// 829EF43C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829EF440: CBA1FFB8  lfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 829EF444: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 829EF448: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 829EF44C: 482BA008  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EF450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EF450 size=428
    let mut pc: u32 = 0x829EF450;
    'dispatch: loop {
        match pc {
            0x829EF450 => {
    //   block [0x829EF450..0x829EF47C)
	// 829EF450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EF454: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EF458: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EF45C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EF460: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EF464: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EF468: 897E0070  lbz r11, 0x70(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) } as u64;
	// 829EF46C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EF470: 419A000C  beq cr6, 0x829ef47c
	if ctx.cr[6].eq {
	pc = 0x829EF47C; continue 'dispatch;
	}
	// 829EF474: 4B7E33A5  bl 0x821d2818
	ctx.lr = 0x829EF478;
	sub_821D2818(ctx, base);
	// 829EF478: 4800016C  b 0x829ef5e4
	pc = 0x829EF5E4; continue 'dispatch;
            }
            0x829EF47C => {
    //   block [0x829EF47C..0x829EF4C0)
	// 829EF47C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829EF480: 4B784FE9  bl 0x82174468
	ctx.lr = 0x829EF484;
	sub_82174468(ctx, base);
	// 829EF484: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 829EF488: 556A27FE  rlwinm r10, r11, 4, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0FFFFFFFu64;
	// 829EF48C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829EF490: 419A00F8  beq cr6, 0x829ef588
	if ctx.cr[6].eq {
	pc = 0x829EF588; continue 'dispatch;
	}
	// 829EF494: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 829EF498: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EF49C: 419A0024  beq cr6, 0x829ef4c0
	if ctx.cr[6].eq {
	pc = 0x829EF4C0; continue 'dispatch;
	}
	// 829EF4A0: 894B003C  lbz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 829EF4A4: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829EF4A8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 829EF4AC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829EF4B0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EF4B4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829EF4B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829EF4BC: 480000D0  b 0x829ef58c
	pc = 0x829EF58C; continue 'dispatch;
            }
            0x829EF4C0 => {
    //   block [0x829EF4C0..0x829EF4E0)
	// 829EF4C0: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829EF4C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EF4C8: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 829EF4CC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829EF4D0: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829EF4D4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829EF4D8: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EF4DC: 40810054  ble 0x829ef530
	if !ctx.cr[0].gt {
	pc = 0x829EF530; continue 'dispatch;
	}
	pc = 0x829EF4E0; continue 'dispatch;
            }
            0x829EF4E0 => {
    //   block [0x829EF4E0..0x829EF500)
	// 829EF4E0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829EF4E4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829EF4E8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829EF4EC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EF4F0: 2F07003C  cmpwi cr6, r7, 0x3c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 60, &mut ctx.xer);
	// 829EF4F4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829EF4F8: 41980008  blt cr6, 0x829ef500
	if ctx.cr[6].lt {
	pc = 0x829EF500; continue 'dispatch;
	}
	// 829EF4FC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x829EF500; continue 'dispatch;
            }
            0x829EF500 => {
    //   block [0x829EF500..0x829EF51C)
	// 829EF500: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829EF504: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829EF508: 419A0014  beq cr6, 0x829ef51c
	if ctx.cr[6].eq {
	pc = 0x829EF51C; continue 'dispatch;
	}
	// 829EF50C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829EF510: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829EF514: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829EF518: 4800000C  b 0x829ef524
	pc = 0x829EF524; continue 'dispatch;
            }
            0x829EF51C => {
    //   block [0x829EF51C..0x829EF524)
	// 829EF51C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829EF520: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829EF524; continue 'dispatch;
            }
            0x829EF524 => {
    //   block [0x829EF524..0x829EF530)
	// 829EF524: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EF528: 4199FFB8  bgt cr6, 0x829ef4e0
	if ctx.cr[6].gt {
	pc = 0x829EF4E0; continue 'dispatch;
	}
	// 829EF52C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x829EF530; continue 'dispatch;
            }
            0x829EF530 => {
    //   block [0x829EF530..0x829EF54C)
	// 829EF530: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829EF534: 419A0040  beq cr6, 0x829ef574
	if ctx.cr[6].eq {
	pc = 0x829EF574; continue 'dispatch;
	}
	// 829EF538: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EF53C: 2F0B003C  cmpwi cr6, r11, 0x3c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 60, &mut ctx.xer);
	// 829EF540: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829EF544: 41990008  bgt cr6, 0x829ef54c
	if ctx.cr[6].gt {
	pc = 0x829EF54C; continue 'dispatch;
	}
	// 829EF548: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829EF54C; continue 'dispatch;
            }
            0x829EF54C => {
    //   block [0x829EF54C..0x829EF574)
	// 829EF54C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829EF550: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EF554: 409A0020  bne cr6, 0x829ef574
	if !ctx.cr[6].eq {
	pc = 0x829EF574; continue 'dispatch;
	}
	// 829EF558: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829EF55C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829EF560: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829EF564: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EF568: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829EF56C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829EF570: 4800001C  b 0x829ef58c
	pc = 0x829EF58C; continue 'dispatch;
            }
            0x829EF574 => {
    //   block [0x829EF574..0x829EF588)
	// 829EF574: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829EF578: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EF57C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829EF580: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829EF584: 48000008  b 0x829ef58c
	pc = 0x829EF58C; continue 'dispatch;
            }
            0x829EF588 => {
    //   block [0x829EF588..0x829EF58C)
	// 829EF588: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829EF58C; continue 'dispatch;
            }
            0x829EF58C => {
    //   block [0x829EF58C..0x829EF5B0)
	// 829EF58C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829EF590: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EF594: 419A004C  beq cr6, 0x829ef5e0
	if ctx.cr[6].eq {
	pc = 0x829EF5E0; continue 'dispatch;
	}
	// 829EF598: C01F00F8  lfs f0, 0xf8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EF59C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829EF5A0: C1BF00E8  lfs f13, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829EF5A4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829EF5A8: 41990008  bgt cr6, 0x829ef5b0
	if ctx.cr[6].gt {
	pc = 0x829EF5B0; continue 'dispatch;
	}
	// 829EF5AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829EF5B0; continue 'dispatch;
            }
            0x829EF5B0 => {
    //   block [0x829EF5B0..0x829EF5E0)
	// 829EF5B0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829EF5B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EF5B8: 419A0028  beq cr6, 0x829ef5e0
	if ctx.cr[6].eq {
	pc = 0x829EF5E0; continue 'dispatch;
	}
	// 829EF5BC: 817E0078  lwz r11, 0x78(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) } as u64;
	// 829EF5C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EF5C4: 419A001C  beq cr6, 0x829ef5e0
	if ctx.cr[6].eq {
	pc = 0x829EF5E0; continue 'dispatch;
	}
	// 829EF5C8: 815E007C  lwz r10, 0x7c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 829EF5CC: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 829EF5D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829EF5D4: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 829EF5D8: 7CE84BD7  divw. r7, r8, r9
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 829EF5DC: 40820008  bne 0x829ef5e4
	if !ctx.cr[0].eq {
	pc = 0x829EF5E4; continue 'dispatch;
	}
	pc = 0x829EF5E0; continue 'dispatch;
            }
            0x829EF5E0 => {
    //   block [0x829EF5E0..0x829EF5E4)
	// 829EF5E0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x829EF5E4; continue 'dispatch;
            }
            0x829EF5E4 => {
    //   block [0x829EF5E4..0x829EF5FC)
	// 829EF5E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EF5E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EF5EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EF5F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EF5F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EF5F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EF600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EF600 size=212
    let mut pc: u32 = 0x829EF600;
    'dispatch: loop {
        match pc {
            0x829EF600 => {
    //   block [0x829EF600..0x829EF62C)
	// 829EF600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EF604: 482B9E01  bl 0x82ca9404
	ctx.lr = 0x829EF608;
	sub_82CA93D0(ctx, base);
	// 829EF608: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EF60C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EF610: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829EF614: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829EF618: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EF61C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EF620: 409A000C  bne cr6, 0x829ef62c
	if !ctx.cr[6].eq {
	pc = 0x829EF62C; continue 'dispatch;
	}
	// 829EF624: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EF628: 48000014  b 0x829ef63c
	pc = 0x829EF63C; continue 'dispatch;
            }
            0x829EF62C => {
    //   block [0x829EF62C..0x829EF63C)
	// 829EF62C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EF630: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 829EF634: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 829EF638: 7C884BD6  divw r4, r8, r9
	ctx.r[4].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	pc = 0x829EF63C; continue 'dispatch;
            }
            0x829EF63C => {
    //   block [0x829EF63C..0x829EF658)
	// 829EF63C: 907B0004  stw r3, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 829EF640: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 829EF644: 907B0008  stw r3, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 829EF648: 907B000C  stw r3, 0xc(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 829EF64C: 419A000C  beq cr6, 0x829ef658
	if ctx.cr[6].eq {
	pc = 0x829EF658; continue 'dispatch;
	}
	// 829EF650: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829EF654: 480001C5  bl 0x829ef818
	ctx.lr = 0x829EF658;
	sub_829EF818(ctx, base);
	pc = 0x829EF658; continue 'dispatch;
            }
            0x829EF658 => {
    //   block [0x829EF658..0x829EF67C)
	// 829EF658: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829EF65C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EF660: 419A0068  beq cr6, 0x829ef6c8
	if ctx.cr[6].eq {
	pc = 0x829EF6C8; continue 'dispatch;
	}
	// 829EF664: 839F0008  lwz r28, 8(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EF668: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EF66C: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 829EF670: 4099000C  ble cr6, 0x829ef67c
	if !ctx.cr[6].gt {
	pc = 0x829EF67C; continue 'dispatch;
	}
	// 829EF674: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 829EF678: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829EF67C; continue 'dispatch;
            }
            0x829EF67C => {
    //   block [0x829EF67C..0x829EF688)
	// 829EF67C: 83FB0004  lwz r31, 4(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EF680: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 829EF684: 419A0040  beq cr6, 0x829ef6c4
	if ctx.cr[6].eq {
	pc = 0x829EF6C4; continue 'dispatch;
	}
	pc = 0x829EF688; continue 'dispatch;
            }
            0x829EF688 => {
    //   block [0x829EF688..0x829EF6B4)
	// 829EF688: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EF68C: 419A0028  beq cr6, 0x829ef6b4
	if ctx.cr[6].eq {
	pc = 0x829EF6B4; continue 'dispatch;
	}
	// 829EF690: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EF694: 3BBE0008  addi r29, r30, 8
	ctx.r[29].s64 = ctx.r[30].s64 + 8;
	// 829EF698: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829EF69C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 829EF6A0: 389DFFFC  addi r4, r29, -4
	ctx.r[4].s64 = ctx.r[29].s64 + -4;
	// 829EF6A4: 4B800B9D  bl 0x821f0240
	ctx.lr = 0x829EF6A8;
	sub_821F0240(ctx, base);
	// 829EF6A8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829EF6AC: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 829EF6B0: 4B800B91  bl 0x821f0240
	ctx.lr = 0x829EF6B4;
	sub_821F0240(ctx, base);
	pc = 0x829EF6B4; continue 'dispatch;
            }
            0x829EF6B4 => {
    //   block [0x829EF6B4..0x829EF6C4)
	// 829EF6B4: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 829EF6B8: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 829EF6BC: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 829EF6C0: 409AFFC8  bne cr6, 0x829ef688
	if !ctx.cr[6].eq {
	pc = 0x829EF688; continue 'dispatch;
	}
	pc = 0x829EF6C4; continue 'dispatch;
            }
            0x829EF6C4 => {
    //   block [0x829EF6C4..0x829EF6C8)
	// 829EF6C4: 93FB0008  stw r31, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	pc = 0x829EF6C8; continue 'dispatch;
            }
            0x829EF6C8 => {
    //   block [0x829EF6C8..0x829EF6D4)
	// 829EF6C8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829EF6CC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829EF6D0: 482B9D84  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EF6D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EF6D8 size=88
    let mut pc: u32 = 0x829EF6D8;
    'dispatch: loop {
        match pc {
            0x829EF6D8 => {
    //   block [0x829EF6D8..0x829EF70C)
	// 829EF6D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EF6DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EF6E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EF6E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EF6E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EF6EC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EF6F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EF6F4: 419A0018  beq cr6, 0x829ef70c
	if ctx.cr[6].eq {
	pc = 0x829EF70C; continue 'dispatch;
	}
	// 829EF6F8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829EF6FC: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EF700: 4BB77311  bl 0x82566a10
	ctx.lr = 0x829EF704;
	sub_82566A10(ctx, base);
	// 829EF704: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EF708: 4B82C631  bl 0x8221bd38
	ctx.lr = 0x829EF70C;
	sub_8221BD38(ctx, base);
	pc = 0x829EF70C; continue 'dispatch;
            }
            0x829EF70C => {
    //   block [0x829EF70C..0x829EF730)
	// 829EF70C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EF710: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 829EF714: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 829EF718: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 829EF71C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829EF720: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EF724: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EF728: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EF72C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EF730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EF730 size=232
    let mut pc: u32 = 0x829EF730;
    'dispatch: loop {
        match pc {
            0x829EF730 => {
    //   block [0x829EF730..0x829EF76C)
	// 829EF730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EF734: 482B9CD9  bl 0x82ca940c
	ctx.lr = 0x829EF738;
	sub_82CA93D0(ctx, base);
	// 829EF738: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EF73C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EF740: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 829EF744: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829EF748: F88100A0  std r4, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[4].u64 ) };
	// 829EF74C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EF750: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EF754: 419A0018  beq cr6, 0x829ef76c
	if ctx.cr[6].eq {
	pc = 0x829EF76C; continue 'dispatch;
	}
	// 829EF758: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EF75C: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 829EF760: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 829EF764: 7CE84BD7  divw. r7, r8, r9
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 829EF768: 4082000C  bne 0x829ef774
	if !ctx.cr[0].eq {
	pc = 0x829EF774; continue 'dispatch;
	}
	pc = 0x829EF76C; continue 'dispatch;
            }
            0x829EF76C => {
    //   block [0x829EF76C..0x829EF774)
	// 829EF76C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829EF770: 48000034  b 0x829ef7a4
	pc = 0x829EF7A4; continue 'dispatch;
            }
            0x829EF774 => {
    //   block [0x829EF774..0x829EF780)
	// 829EF774: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829EF778: 40990008  ble cr6, 0x829ef780
	if !ctx.cr[6].gt {
	pc = 0x829EF780; continue 'dispatch;
	}
	// 829EF77C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829EF780; continue 'dispatch;
            }
            0x829EF780 => {
    //   block [0x829EF780..0x829EF794)
	// 829EF780: 814100A0  lwz r10, 0xa0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 829EF784: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829EF788: 419A000C  beq cr6, 0x829ef794
	if ctx.cr[6].eq {
	pc = 0x829EF794; continue 'dispatch;
	}
	// 829EF78C: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 829EF790: 419A0008  beq cr6, 0x829ef798
	if ctx.cr[6].eq {
	pc = 0x829EF798; continue 'dispatch;
	}
	pc = 0x829EF794; continue 'dispatch;
            }
            0x829EF794 => {
    //   block [0x829EF794..0x829EF798)
	// 829EF794: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829EF798; continue 'dispatch;
            }
            0x829EF798 => {
    //   block [0x829EF798..0x829EF7A4)
	// 829EF798: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 829EF79C: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 829EF7A0: 7FC84BD6  divw r30, r8, r9
	ctx.r[30].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	pc = 0x829EF7A4; continue 'dispatch;
            }
            0x829EF7A4 => {
    //   block [0x829EF7A4..0x829EF7C4)
	// 829EF7A4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829EF7A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EF7AC: 48000165  bl 0x829ef910
	ctx.lr = 0x829EF7B0;
	sub_829EF910(ctx, base);
	// 829EF7B0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EF7B4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EF7B8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829EF7BC: 40990008  ble cr6, 0x829ef7c4
	if !ctx.cr[6].gt {
	pc = 0x829EF7C4; continue 'dispatch;
	}
	// 829EF7C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829EF7C4; continue 'dispatch;
            }
            0x829EF7C4 => {
    //   block [0x829EF7C4..0x829EF7FC)
	// 829EF7C4: 57CA083C  slwi r10, r30, 1
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829EF7C8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829EF7CC: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EF7D0: 7D1E5214  add r8, r30, r10
	ctx.r[8].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 829EF7D4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829EF7D8: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829EF7DC: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829EF7E0: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 829EF7E4: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829EF7E8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 829EF7EC: 41990010  bgt cr6, 0x829ef7fc
	if ctx.cr[6].gt {
	pc = 0x829EF7FC; continue 'dispatch;
	}
	// 829EF7F0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EF7F4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829EF7F8: 40980008  bge cr6, 0x829ef800
	if !ctx.cr[6].lt {
	pc = 0x829EF800; continue 'dispatch;
	}
	pc = 0x829EF7FC; continue 'dispatch;
            }
            0x829EF7FC => {
    //   block [0x829EF7FC..0x829EF800)
	// 829EF7FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829EF800; continue 'dispatch;
            }
            0x829EF800 => {
    //   block [0x829EF800..0x829EF818)
	// 829EF800: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829EF804: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829EF808: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829EF80C: F97D0000  std r11, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 829EF810: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829EF814: 482B9C48  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EF818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EF818 size=124
    let mut pc: u32 = 0x829EF818;
    'dispatch: loop {
        match pc {
            0x829EF818 => {
    //   block [0x829EF818..0x829EF84C)
	// 829EF818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EF81C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EF820: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EF824: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EF828: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EF82C: 3D601555  lis r11, 0x1555
	ctx.r[11].s64 = 357892096;
	// 829EF830: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829EF834: 616A5555  ori r10, r11, 0x5555
	ctx.r[10].u64 = ctx.r[11].u64 | 21845;
	// 829EF838: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EF83C: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829EF840: 4099000C  ble cr6, 0x829ef84c
	if !ctx.cr[6].gt {
	pc = 0x829EF84C; continue 'dispatch;
	}
	// 829EF844: 4BB0528D  bl 0x824f4ad0
	ctx.lr = 0x829EF848;
	sub_824F4AD0(ctx, base);
	// 829EF848: 48000030  b 0x829ef878
	pc = 0x829EF878; continue 'dispatch;
            }
            0x829EF84C => {
    //   block [0x829EF84C..0x829EF878)
	// 829EF84C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829EF850: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EF854: 4B933B5D  bl 0x823233b0
	ctx.lr = 0x829EF858;
	sub_823233B0(ctx, base);
	// 829EF858: 57CA083C  slwi r10, r30, 1
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829EF85C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829EF860: 7D5E5214  add r10, r30, r10
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 829EF864: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 829EF868: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829EF86C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 829EF870: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829EF874: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	pc = 0x829EF878; continue 'dispatch;
            }
            0x829EF878 => {
    //   block [0x829EF878..0x829EF894)
	// 829EF878: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829EF87C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EF880: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EF884: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EF888: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EF88C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EF890: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EF898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EF898 size=120
    let mut pc: u32 = 0x829EF898;
    'dispatch: loop {
        match pc {
            0x829EF898 => {
    //   block [0x829EF898..0x829EF8C0)
	// 829EF898: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EF89C: 482B9B65  bl 0x82ca9400
	ctx.lr = 0x829EF8A0;
	sub_82CA93D0(ctx, base);
	// 829EF8A0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EF8A4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 829EF8A8: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 829EF8AC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 829EF8B0: 7F9BE378  mr r27, r28
	ctx.r[27].u64 = ctx.r[28].u64;
	// 829EF8B4: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 829EF8B8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829EF8BC: 419A003C  beq cr6, 0x829ef8f8
	if ctx.cr[6].eq {
	pc = 0x829EF8F8; continue 'dispatch;
	}
	pc = 0x829EF8C0; continue 'dispatch;
            }
            0x829EF8C0 => {
    //   block [0x829EF8C0..0x829EF8EC)
	// 829EF8C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EF8C4: 419A0028  beq cr6, 0x829ef8ec
	if ctx.cr[6].eq {
	pc = 0x829EF8EC; continue 'dispatch;
	}
	// 829EF8C8: C01D0000  lfs f0, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EF8CC: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 829EF8D0: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829EF8D4: 389D0004  addi r4, r29, 4
	ctx.r[4].s64 = ctx.r[29].s64 + 4;
	// 829EF8D8: 387EFFFC  addi r3, r30, -4
	ctx.r[3].s64 = ctx.r[30].s64 + -4;
	// 829EF8DC: 4B800965  bl 0x821f0240
	ctx.lr = 0x829EF8E0;
	sub_821F0240(ctx, base);
	// 829EF8E0: 389D0008  addi r4, r29, 8
	ctx.r[4].s64 = ctx.r[29].s64 + 8;
	// 829EF8E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EF8E8: 4B800959  bl 0x821f0240
	ctx.lr = 0x829EF8EC;
	sub_821F0240(ctx, base);
	pc = 0x829EF8EC; continue 'dispatch;
            }
            0x829EF8EC => {
    //   block [0x829EF8EC..0x829EF8F8)
	// 829EF8EC: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 829EF8F0: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 829EF8F4: 4082FFCC  bne 0x829ef8c0
	if !ctx.cr[0].eq {
	pc = 0x829EF8C0; continue 'dispatch;
	}
	pc = 0x829EF8F8; continue 'dispatch;
            }
            0x829EF8F8 => {
    //   block [0x829EF8F8..0x829EF910)
	// 829EF8F8: 578B083C  slwi r11, r28, 1
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EF8FC: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 829EF900: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EF904: 7C6BD214  add r3, r11, r26
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 829EF908: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829EF90C: 482B9B44  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EF910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EF910 size=640
    let mut pc: u32 = 0x829EF910;
    'dispatch: loop {
        match pc {
            0x829EF910 => {
    //   block [0x829EF910..0x829EF960)
	// 829EF910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EF914: 482B9AF1  bl 0x82ca9404
	ctx.lr = 0x829EF918;
	sub_82CA93D0(ctx, base);
	// 829EF918: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EF91C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 829EF920: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 829EF924: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EF928: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 829EF92C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829EF930: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EF934: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829EF938: 4B800909  bl 0x821f0240
	ctx.lr = 0x829EF93C;
	sub_821F0240(ctx, base);
	// 829EF93C: 389E0008  addi r4, r30, 8
	ctx.r[4].s64 = ctx.r[30].s64 + 8;
	// 829EF940: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829EF944: 4B8008FD  bl 0x821f0240
	ctx.lr = 0x829EF948;
	sub_821F0240(ctx, base);
	// 829EF948: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EF94C: 3B60000C  li r27, 0xc
	ctx.r[27].s64 = 12;
	// 829EF950: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EF954: 409A000C  bne cr6, 0x829ef960
	if !ctx.cr[6].eq {
	pc = 0x829EF960; continue 'dispatch;
	}
	// 829EF958: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 829EF95C: 48000010  b 0x829ef96c
	pc = 0x829EF96C; continue 'dispatch;
            }
            0x829EF960 => {
    //   block [0x829EF960..0x829EF96C)
	// 829EF960: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 829EF964: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 829EF968: 7D29DBD6  divw r9, r9, r27
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	pc = 0x829EF96C; continue 'dispatch;
            }
            0x829EF96C => {
    //   block [0x829EF96C..0x829EF97C)
	// 829EF96C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EF970: 409A000C  bne cr6, 0x829ef97c
	if !ctx.cr[6].eq {
	pc = 0x829EF97C; continue 'dispatch;
	}
	// 829EF974: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829EF978: 48000010  b 0x829ef988
	pc = 0x829EF988; continue 'dispatch;
            }
            0x829EF97C => {
    //   block [0x829EF97C..0x829EF988)
	// 829EF97C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EF980: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 829EF984: 7D48DBD6  divw r10, r8, r27
	ctx.r[10].s32 = ctx.r[8].s32 / ctx.r[27].s32;
	pc = 0x829EF988; continue 'dispatch;
            }
            0x829EF988 => {
    //   block [0x829EF988..0x829EF9A4)
	// 829EF988: 3D001555  lis r8, 0x1555
	ctx.r[8].s64 = 357892096;
	// 829EF98C: 61085555  ori r8, r8, 0x5555
	ctx.r[8].u64 = ctx.r[8].u64 | 21845;
	// 829EF990: 7CEA4050  subf r7, r10, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 829EF994: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 829EF998: 4098000C  bge cr6, 0x829ef9a4
	if !ctx.cr[6].lt {
	pc = 0x829EF9A4; continue 'dispatch;
	}
	// 829EF99C: 4BB05135  bl 0x824f4ad0
	ctx.lr = 0x829EF9A0;
	sub_824F4AD0(ctx, base);
	// 829EF9A0: 480001D8  b 0x829efb78
	pc = 0x829EFB78; continue 'dispatch;
            }
            0x829EF9A4 => {
    //   block [0x829EF9A4..0x829EF9B4)
	// 829EF9A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EF9A8: 409A000C  bne cr6, 0x829ef9b4
	if !ctx.cr[6].eq {
	pc = 0x829EF9B4; continue 'dispatch;
	}
	// 829EF9AC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829EF9B0: 48000010  b 0x829ef9c0
	pc = 0x829EF9C0; continue 'dispatch;
            }
            0x829EF9B4 => {
    //   block [0x829EF9B4..0x829EF9C0)
	// 829EF9B4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EF9B8: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 829EF9BC: 7D47DBD6  divw r10, r7, r27
	ctx.r[10].s32 = ctx.r[7].s32 / ctx.r[27].s32;
	pc = 0x829EF9C0; continue 'dispatch;
            }
            0x829EF9C0 => {
    //   block [0x829EF9C0..0x829EF9E4)
	// 829EF9C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829EF9C4: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829EF9C8: 40980120  bge cr6, 0x829efae8
	if !ctx.cr[6].lt {
	pc = 0x829EFAE8; continue 'dispatch;
	}
	// 829EF9CC: 552AF87E  srwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829EF9D0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829EF9D4: 7D0A4050  subf r8, r10, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 829EF9D8: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 829EF9DC: 41980008  blt cr6, 0x829ef9e4
	if ctx.cr[6].lt {
	pc = 0x829EF9E4; continue 'dispatch;
	}
	// 829EF9E0: 7F8A4A14  add r28, r10, r9
	ctx.r[28].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	pc = 0x829EF9E4; continue 'dispatch;
            }
            0x829EF9E4 => {
    //   block [0x829EF9E4..0x829EF9F4)
	// 829EF9E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EF9E8: 409A000C  bne cr6, 0x829ef9f4
	if !ctx.cr[6].eq {
	pc = 0x829EF9F4; continue 'dispatch;
	}
	// 829EF9EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829EF9F0: 48000010  b 0x829efa00
	pc = 0x829EFA00; continue 'dispatch;
            }
            0x829EF9F4 => {
    //   block [0x829EF9F4..0x829EFA00)
	// 829EF9F4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EF9F8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 829EF9FC: 7D49DBD6  divw r10, r9, r27
	ctx.r[10].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	pc = 0x829EFA00; continue 'dispatch;
            }
            0x829EFA00 => {
    //   block [0x829EFA00..0x829EFA20)
	// 829EFA00: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829EFA04: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829EFA08: 4098001C  bge cr6, 0x829efa24
	if !ctx.cr[6].lt {
	pc = 0x829EFA24; continue 'dispatch;
	}
	// 829EFA0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EFA10: 419A0010  beq cr6, 0x829efa20
	if ctx.cr[6].eq {
	pc = 0x829EFA20; continue 'dispatch;
	}
	// 829EFA14: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EFA18: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 829EFA1C: 7D69DBD6  divw r11, r9, r27
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	pc = 0x829EFA20; continue 'dispatch;
            }
            0x829EFA20 => {
    //   block [0x829EFA20..0x829EFA24)
	// 829EFA20: 3B8B0001  addi r28, r11, 1
	ctx.r[28].s64 = ctx.r[11].s64 + 1;
	pc = 0x829EFA24; continue 'dispatch;
            }
            0x829EFA24 => {
    //   block [0x829EFA24..0x829EFA8C)
	// 829EFA24: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829EFA28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EFA2C: 4B933985  bl 0x823233b0
	ctx.lr = 0x829EFA30;
	sub_823233B0(ctx, base);
	// 829EFA30: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EFA34: 83A100AC  lwz r29, 0xac(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 829EFA38: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EFA3C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 829EFA40: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829EFA44: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829EFA48: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 829EFA4C: 4BB781BD  bl 0x82567c08
	ctx.lr = 0x829EFA50;
	sub_82567C08(ctx, base);
	// 829EFA50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EFA54: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 829EFA58: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829EFA5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EFA60: 4BFFFE39  bl 0x829ef898
	ctx.lr = 0x829EFA64;
	sub_829EF898(ctx, base);
	// 829EFA64: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829EFA68: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 829EFA6C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EFA70: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829EFA74: 4BB78195  bl 0x82567c08
	ctx.lr = 0x829EFA78;
	sub_82567C08(ctx, base);
	// 829EFA78: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EFA7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EFA80: 409A000C  bne cr6, 0x829efa8c
	if !ctx.cr[6].eq {
	pc = 0x829EFA8C; continue 'dispatch;
	}
	// 829EFA84: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EFA88: 48000010  b 0x829efa98
	pc = 0x829EFA98; continue 'dispatch;
            }
            0x829EFA8C => {
    //   block [0x829EFA8C..0x829EFA98)
	// 829EFA8C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EFA90: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 829EFA94: 7D6ADBD6  divw r11, r10, r27
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[27].s32;
	pc = 0x829EFA98; continue 'dispatch;
            }
            0x829EFA98 => {
    //   block [0x829EFA98..0x829EFAB8)
	// 829EFA98: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	// 829EFA9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EFAA0: 419A0018  beq cr6, 0x829efab8
	if ctx.cr[6].eq {
	pc = 0x829EFAB8; continue 'dispatch;
	}
	// 829EFAA4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829EFAA8: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EFAAC: 4BB76F65  bl 0x82566a10
	ctx.lr = 0x829EFAB0;
	sub_82566A10(ctx, base);
	// 829EFAB0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EFAB4: 4B82C285  bl 0x8221bd38
	ctx.lr = 0x829EFAB8;
	sub_8221BD38(ctx, base);
	pc = 0x829EFAB8; continue 'dispatch;
            }
            0x829EFAB8 => {
    //   block [0x829EFAB8..0x829EFAE8)
	// 829EFAB8: 578B083C  slwi r11, r28, 1
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EFABC: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829EFAC0: 57AA083C  slwi r10, r29, 1
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829EFAC4: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 829EFAC8: 7D5D5214  add r10, r29, r10
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[10].u64;
	// 829EFACC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EFAD0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829EFAD4: 7D2BF214  add r9, r11, r30
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 829EFAD8: 7D0AF214  add r8, r10, r30
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 829EFADC: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 829EFAE0: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 829EFAE4: 48000094  b 0x829efb78
	pc = 0x829EFB78; continue 'dispatch;
            }
            0x829EFAE8 => {
    //   block [0x829EFAE8..0x829EFB44)
	// 829EFAE8: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EFAEC: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 829EFAF0: 83C100AC  lwz r30, 0xac(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 829EFAF4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829EFAF8: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 829EFAFC: 7D4BDBD6  divw r10, r11, r27
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 829EFB00: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 829EFB04: 40980040  bge cr6, 0x829efb44
	if !ctx.cr[6].lt {
	pc = 0x829EFB44; continue 'dispatch;
	}
	// 829EFB08: 38BE000C  addi r5, r30, 0xc
	ctx.r[5].s64 = ctx.r[30].s64 + 12;
	// 829EFB0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EFB10: 4BB780F9  bl 0x82567c08
	ctx.lr = 0x829EFB14;
	sub_82567C08(ctx, base);
	// 829EFB14: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EFB18: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 829EFB1C: 7D7E2050  subf r11, r30, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[30].s64;
	// 829EFB20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EFB24: 7D4BDBD6  divw r10, r11, r27
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 829EFB28: 20AA0001  subfic r5, r10, 1
	ctx.xer.ca = ctx.r[10].u32 <= 1 as u32;
	ctx.r[5].s64 = (1 as i64) - ctx.r[10].s64;
	// 829EFB2C: 4BFFFD6D  bl 0x829ef898
	ctx.lr = 0x829EFB30;
	sub_829EF898(ctx, base);
	// 829EFB30: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EFB34: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 829EFB38: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 829EFB3C: 388BFFF4  addi r4, r11, -0xc
	ctx.r[4].s64 = ctx.r[11].s64 + -12;
	// 829EFB40: 4800002C  b 0x829efb6c
	pc = 0x829EFB6C; continue 'dispatch;
            }
            0x829EFB44 => {
    //   block [0x829EFB44..0x829EFB6C)
	// 829EFB44: 3B9DFFF4  addi r28, r29, -0xc
	ctx.r[28].s64 = ctx.r[29].s64 + -12;
	// 829EFB48: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829EFB4C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829EFB50: 4BB780B9  bl 0x82567c08
	ctx.lr = 0x829EFB54;
	sub_82567C08(ctx, base);
	// 829EFB54: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 829EFB58: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829EFB5C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829EFB60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EFB64: 4BB76FA5  bl 0x82566b08
	ctx.lr = 0x829EFB68;
	sub_82566B08(ctx, base);
	// 829EFB68: 389E000C  addi r4, r30, 0xc
	ctx.r[4].s64 = ctx.r[30].s64 + 12;
	pc = 0x829EFB6C; continue 'dispatch;
            }
            0x829EFB6C => {
    //   block [0x829EFB6C..0x829EFB78)
	// 829EFB6C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829EFB70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EFB74: 4BB76F35  bl 0x82566aa8
	ctx.lr = 0x829EFB78;
	sub_82566AA8(ctx, base);
	pc = 0x829EFB78; continue 'dispatch;
            }
            0x829EFB78 => {
    //   block [0x829EFB78..0x829EFB90)
	// 829EFB78: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829EFB7C: 4B82525D  bl 0x82214dd8
	ctx.lr = 0x829EFB80;
	sub_82214DD8(ctx, base);
	// 829EFB80: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829EFB84: 4B825255  bl 0x82214dd8
	ctx.lr = 0x829EFB88;
	sub_82214DD8(ctx, base);
	// 829EFB88: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829EFB8C: 482B98C8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EFB90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EFB90 size=124
    let mut pc: u32 = 0x829EFB90;
    'dispatch: loop {
        match pc {
            0x829EFB90 => {
    //   block [0x829EFB90..0x829EFBD0)
	// 829EFB90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EFB94: 482B9871  bl 0x82ca9404
	ctx.lr = 0x829EFB98;
	sub_82CA93D0(ctx, base);
	// 829EFB98: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EFB9C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 829EFBA0: 3940000C  li r10, 0xc
	ctx.r[10].s64 = 12;
	// 829EFBA4: 7D63E850  subf r11, r3, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[3].s64;
	// 829EFBA8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EFBAC: 7D6B53D6  divw r11, r11, r10
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 829EFBB0: 7F03E840  cmplw cr6, r3, r29
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829EFBB4: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829EFBB8: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829EFBBC: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EFBC0: 7F6B2A14  add r27, r11, r5
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 829EFBC4: 419A003C  beq cr6, 0x829efc00
	if ctx.cr[6].eq {
	pc = 0x829EFC00; continue 'dispatch;
	}
	// 829EFBC8: 3BE50008  addi r31, r5, 8
	ctx.r[31].s64 = ctx.r[5].s64 + 8;
	// 829EFBCC: 7F851850  subf r28, r5, r3
	ctx.r[28].s64 = ctx.r[3].s64 - ctx.r[5].s64;
	pc = 0x829EFBD0; continue 'dispatch;
            }
            0x829EFBD0 => {
    //   block [0x829EFBD0..0x829EFC00)
	// 829EFBD0: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EFBD4: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 829EFBD8: D01FFFF8  stfs f0, -8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 829EFBDC: 387FFFFC  addi r3, r31, -4
	ctx.r[3].s64 = ctx.r[31].s64 + -4;
	// 829EFBE0: 4B8755C1  bl 0x822651a0
	ctx.lr = 0x829EFBE4;
	sub_822651A0(ctx, base);
	// 829EFBE4: 7C9CFA14  add r4, r28, r31
	ctx.r[4].u64 = ctx.r[28].u64 + ctx.r[31].u64;
	// 829EFBE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EFBEC: 4B8755B5  bl 0x822651a0
	ctx.lr = 0x829EFBF0;
	sub_822651A0(ctx, base);
	// 829EFBF0: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 829EFBF4: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 829EFBF8: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829EFBFC: 409AFFD4  bne cr6, 0x829efbd0
	if !ctx.cr[6].eq {
	pc = 0x829EFBD0; continue 'dispatch;
	}
	pc = 0x829EFC00; continue 'dispatch;
            }
            0x829EFC00 => {
    //   block [0x829EFC00..0x829EFC0C)
	// 829EFC00: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829EFC04: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829EFC08: 482B984C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EFC10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EFC10 size=120
    let mut pc: u32 = 0x829EFC10;
    'dispatch: loop {
        match pc {
            0x829EFC10 => {
    //   block [0x829EFC10..0x829EFC60)
	// 829EFC10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EFC14: 482B97F9  bl 0x82ca940c
	ctx.lr = 0x829EFC18;
	sub_82CA93D0(ctx, base);
	// 829EFC18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EFC1C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829EFC20: 3860007C  li r3, 0x7c
	ctx.r[3].s64 = 124;
	// 829EFC24: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829EFC28: 4B82F631  bl 0x8221f258
	ctx.lr = 0x829EFC2C;
	sub_8221F258(ctx, base);
	// 829EFC2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EFC30: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EFC34: 419A002C  beq cr6, 0x829efc60
	if ctx.cr[6].eq {
	pc = 0x829EFC60; continue 'dispatch;
	}
	// 829EFC38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829EFC3C: 4BA1A0B5  bl 0x82409cf0
	ctx.lr = 0x829EFC40;
	sub_82409CF0(ctx, base);
	// 829EFC40: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829EFC44: 389E0078  addi r4, r30, 0x78
	ctx.r[4].s64 = ctx.r[30].s64 + 120;
	// 829EFC48: 394B1440  addi r10, r11, 0x1440
	ctx.r[10].s64 = ctx.r[11].s64 + 5184;
	// 829EFC4C: 387F0078  addi r3, r31, 0x78
	ctx.r[3].s64 = ctx.r[31].s64 + 120;
	// 829EFC50: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829EFC54: 4B8005ED  bl 0x821f0240
	ctx.lr = 0x829EFC58;
	sub_821F0240(ctx, base);
	// 829EFC58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EFC5C: 48000008  b 0x829efc64
	pc = 0x829EFC64; continue 'dispatch;
            }
            0x829EFC60 => {
    //   block [0x829EFC60..0x829EFC64)
	// 829EFC60: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829EFC64; continue 'dispatch;
            }
            0x829EFC64 => {
    //   block [0x829EFC64..0x829EFC7C)
	// 829EFC64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829EFC68: 4B8D02B1  bl 0x822bff18
	ctx.lr = 0x829EFC6C;
	sub_822BFF18(ctx, base);
	// 829EFC6C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EFC70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EFC74: 419A0008  beq cr6, 0x829efc7c
	if ctx.cr[6].eq {
	pc = 0x829EFC7C; continue 'dispatch;
	}
	// 829EFC78: 4B7915A9  bl 0x82181220
	ctx.lr = 0x829EFC7C;
	sub_82181220(ctx, base);
	pc = 0x829EFC7C; continue 'dispatch;
            }
            0x829EFC7C => {
    //   block [0x829EFC7C..0x829EFC88)
	// 829EFC7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829EFC80: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EFC84: 482B97D8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EFC88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EFC88 size=108
    let mut pc: u32 = 0x829EFC88;
    'dispatch: loop {
        match pc {
            0x829EFC88 => {
    //   block [0x829EFC88..0x829EFCCC)
	// 829EFC88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EFC8C: 482B9781  bl 0x82ca940c
	ctx.lr = 0x829EFC90;
	sub_82CA93D0(ctx, base);
	// 829EFC90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EFC94: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EFC98: 3860008C  li r3, 0x8c
	ctx.r[3].s64 = 140;
	// 829EFC9C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 829EFCA0: 4B82F5B9  bl 0x8221f258
	ctx.lr = 0x829EFCA4;
	sub_8221F258(ctx, base);
	// 829EFCA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EFCA8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EFCAC: 419A0020  beq cr6, 0x829efccc
	if ctx.cr[6].eq {
	pc = 0x829EFCCC; continue 'dispatch;
	}
	// 829EFCB0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829EFCB4: 4B8D0435  bl 0x822c00e8
	ctx.lr = 0x829EFCB8;
	sub_822C00E8(ctx, base);
	// 829EFCB8: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829EFCBC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EFCC0: 394B1490  addi r10, r11, 0x1490
	ctx.r[10].s64 = ctx.r[11].s64 + 5264;
	// 829EFCC4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829EFCC8: 48000008  b 0x829efcd0
	pc = 0x829EFCD0; continue 'dispatch;
            }
            0x829EFCCC => {
    //   block [0x829EFCCC..0x829EFCD0)
	// 829EFCCC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829EFCD0; continue 'dispatch;
            }
            0x829EFCD0 => {
    //   block [0x829EFCD0..0x829EFCE8)
	// 829EFCD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EFCD4: 4B8D0245  bl 0x822bff18
	ctx.lr = 0x829EFCD8;
	sub_822BFF18(ctx, base);
	// 829EFCD8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EFCDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EFCE0: 419A0008  beq cr6, 0x829efce8
	if ctx.cr[6].eq {
	pc = 0x829EFCE8; continue 'dispatch;
	}
	// 829EFCE4: 4B79153D  bl 0x82181220
	ctx.lr = 0x829EFCE8;
	sub_82181220(ctx, base);
	pc = 0x829EFCE8; continue 'dispatch;
            }
            0x829EFCE8 => {
    //   block [0x829EFCE8..0x829EFCF4)
	// 829EFCE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EFCEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EFCF0: 482B976C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EFCF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EFCF8 size=148
    let mut pc: u32 = 0x829EFCF8;
    'dispatch: loop {
        match pc {
            0x829EFCF8 => {
    //   block [0x829EFCF8..0x829EFD58)
	// 829EFCF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EFCFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EFD00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EFD04: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EFD08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EFD0C: 4B7F3A2D  bl 0x821e3738
	ctx.lr = 0x829EFD10;
	sub_821E3738(ctx, base);
	// 829EFD10: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 829EFD14: 4B82F545  bl 0x8221f258
	ctx.lr = 0x829EFD18;
	sub_8221F258(ctx, base);
	// 829EFD18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EFD1C: 419A003C  beq cr6, 0x829efd58
	if ctx.cr[6].eq {
	pc = 0x829EFD58; continue 'dispatch;
	}
	// 829EFD20: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EFD24: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 829EFD28: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829EFD2C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 829EFD30: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829EFD34: 38E9B6C0  addi r7, r9, -0x4940
	ctx.r[7].s64 = ctx.r[9].s64 + -18752;
	// 829EFD38: C00B9040  lfs f0, -0x6fc0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28608 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EFD3C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EFD40: C1AA9484  lfs f13, -0x6b7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829EFD44: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 829EFD48: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829EFD4C: 99030010  stb r8, 0x10(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[8].u8 ) };
	// 829EFD50: D1A3000C  stfs f13, 0xc(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829EFD54: 48000008  b 0x829efd5c
	pc = 0x829EFD5C; continue 'dispatch;
            }
            0x829EFD58 => {
    //   block [0x829EFD58..0x829EFD5C)
	// 829EFD58: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829EFD5C; continue 'dispatch;
            }
            0x829EFD5C => {
    //   block [0x829EFD5C..0x829EFD8C)
	// 829EFD5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EFD60: 4B7CBD51  bl 0x821bbab0
	ctx.lr = 0x829EFD64;
	sub_821BBAB0(ctx, base);
	// 829EFD64: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EFD68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EFD6C: 4B87C0FD  bl 0x8226be68
	ctx.lr = 0x829EFD70;
	sub_8226BE68(ctx, base);
	// 829EFD70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EFD74: 4B7C7DA5  bl 0x821b7b18
	ctx.lr = 0x829EFD78;
	sub_821B7B18(ctx, base);
	// 829EFD78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EFD7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EFD80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EFD84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EFD88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EFD90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EFD90 size=344
    let mut pc: u32 = 0x829EFD90;
    'dispatch: loop {
        match pc {
            0x829EFD90 => {
    //   block [0x829EFD90..0x829EFDE0)
	// 829EFD90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EFD94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EFD98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EFD9C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EFDA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EFDA4: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 829EFDA8: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 829EFDAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EFDB0: 419A0030  beq cr6, 0x829efde0
	if ctx.cr[6].eq {
	pc = 0x829EFDE0; continue 'dispatch;
	}
	// 829EFDB4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EFDB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829EFDBC: 419A0124  beq cr6, 0x829efee0
	if ctx.cr[6].eq {
	pc = 0x829EFEE0; continue 'dispatch;
	}
	// 829EFDC0: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EFDC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EFDC8: 419A0018  beq cr6, 0x829efde0
	if ctx.cr[6].eq {
	pc = 0x829EFDE0; continue 'dispatch;
	}
	// 829EFDCC: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 829EFDD0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829EFDD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829EFDD8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829EFDDC: 409A0008  bne cr6, 0x829efde4
	if !ctx.cr[6].eq {
	pc = 0x829EFDE4; continue 'dispatch;
	}
	pc = 0x829EFDE0; continue 'dispatch;
            }
            0x829EFDE0 => {
    //   block [0x829EFDE0..0x829EFDE4)
	// 829EFDE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829EFDE4; continue 'dispatch;
            }
            0x829EFDE4 => {
    //   block [0x829EFDE4..0x829EFECC)
	// 829EFDE4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829EFDE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EFDEC: 419A00E0  beq cr6, 0x829efecc
	if ctx.cr[6].eq {
	pc = 0x829EFECC; continue 'dispatch;
	}
	// 829EFDF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EFDF4: 4B784675  bl 0x82174468
	ctx.lr = 0x829EFDF8;
	sub_82174468(ctx, base);
	// 829EFDF8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829EFDFC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EFE00: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829EFE04: 4B805DBD  bl 0x821f5bc0
	ctx.lr = 0x829EFE08;
	sub_821F5BC0(ctx, base);
	// 829EFE08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EFE0C: 4B78465D  bl 0x82174468
	ctx.lr = 0x829EFE10;
	sub_82174468(ctx, base);
	// 829EFE10: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 829EFE14: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829EFE18: 808A007C  lwz r4, 0x7c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(124 as u32) ) } as u64;
	// 829EFE1C: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EFE20: 81090040  lwz r8, 0x40(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(64 as u32) ) } as u64;
	// 829EFE24: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 829EFE28: 4E800421  bctrl
	ctx.lr = 0x829EFE2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EFE2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EFE30: 4B8AF049  bl 0x8229ee78
	ctx.lr = 0x829EFE34;
	sub_8229EE78(ctx, base);
	// 829EFE34: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 829EFE38: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829EFE3C: 8087007C  lwz r4, 0x7c(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(124 as u32) ) } as u64;
	// 829EFE40: 80C40000  lwz r6, 0(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EFE44: 80A60040  lwz r5, 0x40(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(64 as u32) ) } as u64;
	// 829EFE48: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 829EFE4C: 4E800421  bctrl
	ctx.lr = 0x829EFE50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EFE50: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 829EFE54: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 829EFE58: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 829EFE5C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829EFE60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
            }
            0x829EFECC => {
    //   block [0x829EFECC..0x829EFEE0)
	// 829EFECC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829EFED0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EFED4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EFED8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EFEDC: 4E800020  blr
	return;
            }
            0x829EFEE0 => {
    //   block [0x829EFEE0..0x829EFEE8)
	// 829EFEE0: 4B7A3F59  bl 0x82193e38
	ctx.lr = 0x829EFEE4;
	sub_82193E38(ctx, base);
	// 829EFEE4: 4BFFFEFC  b 0x829efde0
	pc = 0x829EFDE0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EFEE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829EFEE8 size=736
    let mut pc: u32 = 0x829EFEE8;
    'dispatch: loop {
        match pc {
            0x829EFEE8 => {
    //   block [0x829EFEE8..0x829F01C8)
	// 829EFEE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EFEEC: 482B9521  bl 0x82ca940c
	ctx.lr = 0x829EFEF0;
	sub_82CA93D0(ctx, base);
	// 829EFEF0: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F01C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829F01C8 size=572
    let mut pc: u32 = 0x829F01C8;
    'dispatch: loop {
        match pc {
            0x829F01C8 => {
    //   block [0x829F01C8..0x829F0404)
	// 829F01C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F01CC: 482B9235  bl 0x82ca9400
	ctx.lr = 0x829F01D0;
	sub_82CA93D0(ctx, base);
	// 829F01D0: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F0408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829F0408 size=604
    let mut pc: u32 = 0x829F0408;
    'dispatch: loop {
        match pc {
            0x829F0408 => {
    //   block [0x829F0408..0x829F0664)
	// 829F0408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F040C: 482B9001  bl 0x82ca940c
	ctx.lr = 0x829F0410;
	sub_82CA93D0(ctx, base);
	// 829F0410: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 829F0414: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 829F0418: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 829F041C: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F0668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F0668 size=112
    let mut pc: u32 = 0x829F0668;
    'dispatch: loop {
        match pc {
            0x829F0668 => {
    //   block [0x829F0668..0x829F06D8)
	// 829F0668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F066C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F0670: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F0674: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F0678: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F067C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 829F0680: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829F0684: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 829F0688: 38E99160  addi r7, r9, -0x6ea0
	ctx.r[7].s64 = ctx.r[9].s64 + -28320;
	// 829F068C: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F0690: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 829F0694: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829F0698: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F06D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F06D8 size=440
    let mut pc: u32 = 0x829F06D8;
    'dispatch: loop {
        match pc {
            0x829F06D8 => {
    //   block [0x829F06D8..0x829F0890)
	// 829F06D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F06DC: 482B8D25  bl 0x82ca9400
	ctx.lr = 0x829F06E0;
	sub_82CA93D0(ctx, base);
	// 829F06E0: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 829F06E4: 486162F1  bl 0x830069d4
	ctx.lr = 0x829F06E8;
	sub_83006760(ctx, base);
	// 829F06E8: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F06EC: F8810150  std r4, 0x150(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(336 as u32), ctx.r[4].u64 ) };
	// 829F06F0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F06F4: F8A10158  std r5, 0x158(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(344 as u32), ctx.r[5].u64 ) };
	// 829F06F8: 38A10160  addi r5, r1, 0x160
	ctx.r[5].s64 = ctx.r[1].s64 + 352;
	// 829F06FC: F8C10160  std r6, 0x160(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), ctx.r[6].u64 ) };
	// 829F0700: 38C10150  addi r6, r1, 0x150
	ctx.r[6].s64 = ctx.r[1].s64 + 336;
	// 829F0704: F8E10168  std r7, 0x168(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(360 as u32), ctx.r[7].u64 ) };
	// 829F0708: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829F070C: 392BD5C8  addi r9, r11, -0x2a38
	ctx.r[9].s64 = ctx.r[11].s64 + -10808;
	// 829F0710: D0210174  stfs f1, 0x174(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 829F0714: C00BD5C8  lfs f0, -0x2a38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10808 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F0718: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F0890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F0890 size=164
    let mut pc: u32 = 0x829F0890;
    'dispatch: loop {
        match pc {
            0x829F0890 => {
    //   block [0x829F0890..0x829F08E4)
	// 829F0890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F0894: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F0898: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F089C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F08A0: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F08A4: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 829F08A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F08AC: 419A0038  beq cr6, 0x829f08e4
	if ctx.cr[6].eq {
	pc = 0x829F08E4; continue 'dispatch;
	}
	// 829F08B0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F08B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F08B8: 419A0070  beq cr6, 0x829f0928
	if ctx.cr[6].eq {
	pc = 0x829F0928; continue 'dispatch;
	}
	// 829F08BC: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F08C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F08C4: 419A0020  beq cr6, 0x829f08e4
	if ctx.cr[6].eq {
	pc = 0x829F08E4; continue 'dispatch;
	}
	// 829F08C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F08CC: 4B78356D  bl 0x82173e38
	ctx.lr = 0x829F08D0;
	sub_82173E38(ctx, base);
	// 829F08D0: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 829F08D4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829F08D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F08DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F08E0: 409A0008  bne cr6, 0x829f08e8
	if !ctx.cr[6].eq {
	pc = 0x829F08E8; continue 'dispatch;
	}
	pc = 0x829F08E4; continue 'dispatch;
            }
            0x829F08E4 => {
    //   block [0x829F08E4..0x829F08E8)
	// 829F08E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829F08E8; continue 'dispatch;
            }
            0x829F08E8 => {
    //   block [0x829F08E8..0x829F0914)
	// 829F08E8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F08EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F08F0: 419A0024  beq cr6, 0x829f0914
	if ctx.cr[6].eq {
	pc = 0x829F0914; continue 'dispatch;
	}
	// 829F08F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F08F8: 4B783541  bl 0x82173e38
	ctx.lr = 0x829F08FC;
	sub_82173E38(ctx, base);
	// 829F08FC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829F0900: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F0904: 83EB007C  lwz r31, 0x7c(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829F0908: 4B783531  bl 0x82173e38
	ctx.lr = 0x829F090C;
	sub_82173E38(ctx, base);
	// 829F090C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F0910: 4B99CBA9  bl 0x8238d4b8
	ctx.lr = 0x829F0914;
	sub_8238D4B8(ctx, base);
	pc = 0x829F0914; continue 'dispatch;
            }
            0x829F0914 => {
    //   block [0x829F0914..0x829F0928)
	// 829F0914: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829F0918: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F091C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F0920: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F0924: 4E800020  blr
	return;
            }
            0x829F0928 => {
    //   block [0x829F0928..0x829F0934)
	// 829F0928: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F092C: 4B7A350D  bl 0x82193e38
	ctx.lr = 0x829F0930;
	sub_82193E38(ctx, base);
	// 829F0930: 4BFFFFB4  b 0x829f08e4
	pc = 0x829F08E4; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F0938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F0938 size=164
    let mut pc: u32 = 0x829F0938;
    'dispatch: loop {
        match pc {
            0x829F0938 => {
    //   block [0x829F0938..0x829F098C)
	// 829F0938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F093C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F0940: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F0944: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F0948: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F094C: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 829F0950: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F0954: 419A0038  beq cr6, 0x829f098c
	if ctx.cr[6].eq {
	pc = 0x829F098C; continue 'dispatch;
	}
	// 829F0958: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F095C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F0960: 419A0070  beq cr6, 0x829f09d0
	if ctx.cr[6].eq {
	pc = 0x829F09D0; continue 'dispatch;
	}
	// 829F0964: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F0968: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F096C: 419A0020  beq cr6, 0x829f098c
	if ctx.cr[6].eq {
	pc = 0x829F098C; continue 'dispatch;
	}
	// 829F0970: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F0974: 4B7834C5  bl 0x82173e38
	ctx.lr = 0x829F0978;
	sub_82173E38(ctx, base);
	// 829F0978: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 829F097C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829F0980: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F0984: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F0988: 409A0008  bne cr6, 0x829f0990
	if !ctx.cr[6].eq {
	pc = 0x829F0990; continue 'dispatch;
	}
	pc = 0x829F098C; continue 'dispatch;
            }
            0x829F098C => {
    //   block [0x829F098C..0x829F0990)
	// 829F098C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829F0990; continue 'dispatch;
            }
            0x829F0990 => {
    //   block [0x829F0990..0x829F09BC)
	// 829F0990: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F0994: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F0998: 419A0024  beq cr6, 0x829f09bc
	if ctx.cr[6].eq {
	pc = 0x829F09BC; continue 'dispatch;
	}
	// 829F099C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F09A0: 4B783499  bl 0x82173e38
	ctx.lr = 0x829F09A4;
	sub_82173E38(ctx, base);
	// 829F09A4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829F09A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F09AC: 83EB007C  lwz r31, 0x7c(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829F09B0: 4B783489  bl 0x82173e38
	ctx.lr = 0x829F09B4;
	sub_82173E38(ctx, base);
	// 829F09B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F09B8: 4B99CC89  bl 0x8238d640
	ctx.lr = 0x829F09BC;
	sub_8238D640(ctx, base);
	pc = 0x829F09BC; continue 'dispatch;
            }
            0x829F09BC => {
    //   block [0x829F09BC..0x829F09D0)
	// 829F09BC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829F09C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F09C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F09C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F09CC: 4E800020  blr
	return;
            }
            0x829F09D0 => {
    //   block [0x829F09D0..0x829F09DC)
	// 829F09D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F09D4: 4B7A3465  bl 0x82193e38
	ctx.lr = 0x829F09D8;
	sub_82193E38(ctx, base);
	// 829F09D8: 4BFFFFB4  b 0x829f098c
	pc = 0x829F098C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F09E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F09E0 size=288
    let mut pc: u32 = 0x829F09E0;
    'dispatch: loop {
        match pc {
            0x829F09E0 => {
    //   block [0x829F09E0..0x829F0A28)
	// 829F09E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F09E4: 482B8A29  bl 0x82ca940c
	ctx.lr = 0x829F09E8;
	sub_82CA93D0(ctx, base);
	// 829F09E8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F09EC: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 829F09F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F09F4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829F09F8: 817D6B08  lwz r11, 0x6b08(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27400 as u32) ) } as u64;
	// 829F09FC: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 829F0A00: 83CB009C  lwz r30, 0x9c(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) } as u64;
	// 829F0A04: 4BEA5E65  bl 0x82896868
	ctx.lr = 0x829F0A08;
	sub_82896868(ctx, base);
	// 829F0A08: 817D6B08  lwz r11, 0x6b08(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27400 as u32) ) } as u64;
	// 829F0A0C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829F0A10: 806B001C  lwz r3, 0x1c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 829F0A14: 4B97F5AD  bl 0x8236ffc0
	ctx.lr = 0x829F0A18;
	sub_8236FFC0(ctx, base);
	// 829F0A18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F0A1C: 419A000C  beq cr6, 0x829f0a28
	if ctx.cr[6].eq {
	pc = 0x829F0A28; continue 'dispatch;
	}
	// 829F0A20: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F0A24: 48000008  b 0x829f0a2c
	pc = 0x829F0A2C; continue 'dispatch;
            }
            0x829F0A28 => {
    //   block [0x829F0A28..0x829F0A2C)
	// 829F0A28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829F0A2C; continue 'dispatch;
            }
            0x829F0A2C => {
    //   block [0x829F0A2C..0x829F0AD8)
	// 829F0A2C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 829F0A30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F0A34: 5565DFFE  rlwinm r5, r11, 0x1b, 0x1f, 0x1f
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 829F0A38: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F0A3C: 4BEA5EC5  bl 0x82896900
	ctx.lr = 0x829F0A40;
	sub_82896900(ctx, base);
	// 829F0A40: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 829F0A44: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 829F0A48: 388AD4C0  addi r4, r10, -0x2b40
	ctx.r[4].s64 = ctx.r[10].s64 + -11072;
	// 829F0A4C: 4B7FF7F5  bl 0x821f0240
	ctx.lr = 0x829F0A50;
	sub_821F0240(ctx, base);
	// 829F0A50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F0A54: 4BA35D45  bl 0x82426798
	ctx.lr = 0x829F0A58;
	sub_82426798(ctx, base);
	// 829F0A58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F0A5C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F0A60: 419A0078  beq cr6, 0x829f0ad8
	if ctx.cr[6].eq {
	pc = 0x829F0AD8; continue 'dispatch;
	}
	// 829F0A64: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F0A68: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829F0A6C: 388B14F8  addi r4, r11, 0x14f8
	ctx.r[4].s64 = ctx.r[11].s64 + 5368;
	// 829F0A70: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829F0A74: 4B83C45D  bl 0x8222ced0
	ctx.lr = 0x829F0A78;
	sub_8222CED0(ctx, base);
	// 829F0A78: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F0A7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F0A80: 4B91D669  bl 0x8230e0e8
	ctx.lr = 0x829F0A84;
	sub_8230E0E8(ctx, base);
	// 829F0A84: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829F0A88: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829F0A8C: 388A3118  addi r4, r10, 0x3118
	ctx.r[4].s64 = ctx.r[10].s64 + 12568;
	// 829F0A90: 4B8E5979  bl 0x822d6408
	ctx.lr = 0x829F0A94;
	sub_822D6408(ctx, base);
	// 829F0A94: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829F0A98: 80810074  lwz r4, 0x74(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829F0A9C: 4B91A3DD  bl 0x8230ae78
	ctx.lr = 0x829F0AA0;
	sub_8230AE78(ctx, base);
	// 829F0AA0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829F0AA4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 829F0AA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F0AAC: 4814E0BD  bl 0x82b3eb68
	ctx.lr = 0x829F0AB0;
	sub_82B3EB68(ctx, base);
	// 829F0AB0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829F0AB4: 4B7D5D45  bl 0x821c67f8
	ctx.lr = 0x829F0AB8;
	sub_821C67F8(ctx, base);
	// 829F0AB8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829F0ABC: 4B7D5D3D  bl 0x821c67f8
	ctx.lr = 0x829F0AC0;
	sub_821C67F8(ctx, base);
	// 829F0AC0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829F0AC4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F0AC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F0ACC: 4BA35305  bl 0x82425dd0
	ctx.lr = 0x829F0AD0;
	sub_82425DD0(ctx, base);
	// 829F0AD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F0AD4: 4B7D5D25  bl 0x821c67f8
	ctx.lr = 0x829F0AD8;
	sub_821C67F8(ctx, base);
	pc = 0x829F0AD8; continue 'dispatch;
            }
            0x829F0AD8 => {
    //   block [0x829F0AD8..0x829F0B00)
	// 829F0AD8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829F0ADC: 4B8242FD  bl 0x82214dd8
	ctx.lr = 0x829F0AE0;
	sub_82214DD8(ctx, base);
	// 829F0AE0: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 829F0AE4: 4B8242F5  bl 0x82214dd8
	ctx.lr = 0x829F0AE8;
	sub_82214DD8(ctx, base);
	// 829F0AE8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829F0AEC: 4B7D5D0D  bl 0x821c67f8
	ctx.lr = 0x829F0AF0;
	sub_821C67F8(ctx, base);
	// 829F0AF0: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829F0AF4: 4B8242E5  bl 0x82214dd8
	ctx.lr = 0x829F0AF8;
	sub_82214DD8(ctx, base);
	// 829F0AF8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 829F0AFC: 482B8960  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F0B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F0B00 size=212
    let mut pc: u32 = 0x829F0B00;
    'dispatch: loop {
        match pc {
            0x829F0B00 => {
    //   block [0x829F0B00..0x829F0BD4)
	// 829F0B00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F0B04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F0B08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F0B0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F0B10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F0B14: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F0B18: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829F0B1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F0B20: 3BEB0020  addi r31, r11, 0x20
	ctx.r[31].s64 = ctx.r[11].s64 + 32;
	// 829F0B24: 4815BCB5  bl 0x82b4c7d8
	ctx.lr = 0x829F0B28;
	sub_82B4C7D8(ctx, base);
	// 829F0B28: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F0B2C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F0BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F0BD8 size=388
    let mut pc: u32 = 0x829F0BD8;
    'dispatch: loop {
        match pc {
            0x829F0BD8 => {
    //   block [0x829F0BD8..0x829F0C08)
	// 829F0BD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F0BDC: 482B8821  bl 0x82ca93fc
	ctx.lr = 0x829F0BE0;
	sub_82CA93D0(ctx, base);
	// 829F0BE0: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F0BE4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829F0BE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F0BEC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F0BF0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 829F0BF4: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 829F0BF8: 4B7C4911  bl 0x821b5508
	ctx.lr = 0x829F0BFC;
	sub_821B5508(ctx, base);
	// 829F0BFC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 829F0C00: 2F19FFFF  cmpwi cr6, r25, -1
	ctx.cr[6].compare_i32(ctx.r[25].s32, -1, &mut ctx.xer);
	// 829F0C04: 409A0010  bne cr6, 0x829f0c14
	if !ctx.cr[6].eq {
	pc = 0x829F0C14; continue 'dispatch;
	}
	pc = 0x829F0C08; continue 'dispatch;
            }
            0x829F0C08 => {
    //   block [0x829F0C08..0x829F0C14)
	// 829F0C08: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829F0C0C: 382101A0  addi r1, r1, 0x1a0
	ctx.r[1].s64 = ctx.r[1].s64 + 416;
	// 829F0C10: 482B883C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x829F0C14 => {
    //   block [0x829F0C14..0x829F0C84)
	// 829F0C14: 389C0004  addi r4, r28, 4
	ctx.r[4].s64 = ctx.r[28].s64 + 4;
	// 829F0C18: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F0C1C: 4B7C48ED  bl 0x821b5508
	ctx.lr = 0x829F0C20;
	sub_821B5508(ctx, base);
	// 829F0C20: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829F0C24: 2F1BFFFF  cmpwi cr6, r27, -1
	ctx.cr[6].compare_i32(ctx.r[27].s32, -1, &mut ctx.xer);
	// 829F0C28: 419AFFE0  beq cr6, 0x829f0c08
	if ctx.cr[6].eq {
	pc = 0x829F0C08; continue 'dispatch;
	}
	// 829F0C2C: 389C0008  addi r4, r28, 8
	ctx.r[4].s64 = ctx.r[28].s64 + 8;
	// 829F0C30: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F0C34: 4B7C48D5  bl 0x821b5508
	ctx.lr = 0x829F0C38;
	sub_821B5508(ctx, base);
	// 829F0C38: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 829F0C3C: 2F1AFFFF  cmpwi cr6, r26, -1
	ctx.cr[6].compare_i32(ctx.r[26].s32, -1, &mut ctx.xer);
	// 829F0C40: 419AFFC8  beq cr6, 0x829f0c08
	if ctx.cr[6].eq {
	pc = 0x829F0C08; continue 'dispatch;
	}
	// 829F0C44: 389C000C  addi r4, r28, 0xc
	ctx.r[4].s64 = ctx.r[28].s64 + 12;
	// 829F0C48: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F0C4C: 4B7C48BD  bl 0x821b5508
	ctx.lr = 0x829F0C50;
	sub_821B5508(ctx, base);
	// 829F0C50: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 829F0C54: 419AFFB4  beq cr6, 0x829f0c08
	if ctx.cr[6].eq {
	pc = 0x829F0C08; continue 'dispatch;
	}
	// 829F0C58: 933F0000  stw r25, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 829F0C5C: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 829F0C60: 937F0004  stw r27, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 829F0C64: 935F0008  stw r26, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 829F0C68: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 829F0C6C: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F0C70: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F0C74: 7D255050  subf r9, r5, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[5].s64;
	// 829F0C78: 7D095BD7  divw. r8, r9, r11
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[11].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 829F0C7C: 40820008  bne 0x829f0c84
	if !ctx.cr[0].eq {
	pc = 0x829F0C84; continue 'dispatch;
	}
	// 829F0C80: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	pc = 0x829F0C84; continue 'dispatch;
            }
            0x829F0C84 => {
    //   block [0x829F0C84..0x829F0D5C)
	// 829F0C84: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 829F0C88: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829F0C8C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829F0C90: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F0C94: 4B804E1D  bl 0x821f5ab0
	ctx.lr = 0x829F0C98;
	sub_821F5AB0(ctx, base);
	// 829F0C98: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 829F0C9C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F0CA0: 4BD21A99  bl 0x82712738
	ctx.lr = 0x829F0CA4;
	sub_82712738(ctx, base);
	// 829F0CA4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F0CA8: 83DE0004  lwz r30, 4(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F0CAC: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 829F0CB0: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829F0CB4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829F0CB8: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F0CBC: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 829F0CC0: 4BD21A79  bl 0x82712738
	ctx.lr = 0x829F0CC4;
	sub_82712738(ctx, base);
	// 829F0CC4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 829F0CC8: 38810120  addi r4, r1, 0x120
	ctx.r[4].s64 = ctx.r[1].s64 + 288;
	// 829F0CCC: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829F0CD0: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829F0CD4: 554B2036  slwi r11, r10, 4
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F0CD8: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 829F0CDC: 4BD21A5D  bl 0x82712738
	ctx.lr = 0x829F0CE0;
	sub_82712738(ctx, base);
	// 829F0CE0: 38A100E0  addi r5, r1, 0xe0
	ctx.r[5].s64 = ctx.r[1].s64 + 224;
	// 829F0CE4: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 829F0CE8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F0CEC: 4B829EA5  bl 0x8221ab90
	ctx.lr = 0x829F0CF0;
	sub_8221AB90(ctx, base);
	// 829F0CF0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 829F0CF4: 38810120  addi r4, r1, 0x120
	ctx.r[4].s64 = ctx.r[1].s64 + 288;
	// 829F0CF8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 829F0CFC: 4B829E95  bl 0x8221ab90
	ctx.lr = 0x829F0D00;
	sub_8221AB90(ctx, base);
	// 829F0D00: 39210110  addi r9, r1, 0x110
	ctx.r[9].s64 = ctx.r[1].s64 + 272;
	// 829F0D04: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 829F0D08: 38E100D0  addi r7, r1, 0xd0
	ctx.r[7].s64 = ctx.r[1].s64 + 208;
	// 829F0D0C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 829F0D10: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F0D60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F0D60 size=1784
    let mut pc: u32 = 0x829F0D60;
    'dispatch: loop {
        match pc {
            0x829F0D60 => {
    //   block [0x829F0D60..0x829F1458)
	// 829F0D60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F0D64: 482B869D  bl 0x82ca9400
	ctx.lr = 0x829F0D68;
	sub_82CA93D0(ctx, base);
	// 829F0D68: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 829F0D6C: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 829F0D70: 48615C45  bl 0x830069b4
	ctx.lr = 0x829F0D74;
	sub_83006760(ctx, base);
	// 829F0D74: 9421FCA0  stwu r1, -0x360(r1)
	ea = ctx.r[1].u32.wrapping_add(-864 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F0D78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F0D7C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F0D80: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 829F0D84: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 829F0D88: 3B600030  li r27, 0x30
	ctx.r[27].s64 = 48;
	// 829F0D8C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F0D90: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F0D94: 811F000C  lwz r8, 0xc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 829F0D98: 5544083C  slwi r4, r10, 1
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 829F0D9C: 5523083C  slwi r3, r9, 1
	ctx.r[3].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 829F0DA0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F0DA4: 551D083C  slwi r29, r8, 1
	ctx.r[29].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 829F0DA8: 839E0008  lwz r28, 8(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F0DAC: 7D4A2214  add r10, r10, r4
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 829F0DB0: 7D291A14  add r9, r9, r3
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[3].u64;
	// 829F0DB4: 7D08EA14  add r8, r8, r29
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[29].u64;
	// 829F0DB8: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829F0DBC: 55292036  slwi r9, r9, 4
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 829F0DC0: 55082036  slwi r8, r8, 4
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F0DC4: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829F0DC8: 7C695A14  add r3, r9, r11
	ctx.r[3].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 829F0DCC: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 829F0DD0: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 829F0DD4: 7D46E050  subf r10, r6, r28
	ctx.r[10].s64 = ctx.r[28].s64 - ctx.r[6].s64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F1458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F1458 size=116
    let mut pc: u32 = 0x829F1458;
    'dispatch: loop {
        match pc {
            0x829F1458 => {
    //   block [0x829F1458..0x829F14A4)
	// 829F1458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F145C: 482B7FB1  bl 0x82ca940c
	ctx.lr = 0x829F1460;
	sub_82CA93D0(ctx, base);
	// 829F1460: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F1464: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829F1468: 3860007C  li r3, 0x7c
	ctx.r[3].s64 = 124;
	// 829F146C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F1470: 4B82DDE9  bl 0x8221f258
	ctx.lr = 0x829F1474;
	sub_8221F258(ctx, base);
	// 829F1474: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F1478: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F147C: 419A0028  beq cr6, 0x829f14a4
	if ctx.cr[6].eq {
	pc = 0x829F14A4; continue 'dispatch;
	}
	// 829F1480: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F1484: 4BA1886D  bl 0x82409cf0
	ctx.lr = 0x829F1488;
	sub_82409CF0(ctx, base);
	// 829F1488: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F148C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F1490: 394B1670  addi r10, r11, 0x1670
	ctx.r[10].s64 = ctx.r[11].s64 + 5744;
	// 829F1494: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829F1498: C01E0078  lfs f0, 0x78(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F149C: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 829F14A0: 48000008  b 0x829f14a8
	pc = 0x829F14A8; continue 'dispatch;
            }
            0x829F14A4 => {
    //   block [0x829F14A4..0x829F14A8)
	// 829F14A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829F14A8; continue 'dispatch;
            }
            0x829F14A8 => {
    //   block [0x829F14A8..0x829F14C0)
	// 829F14A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F14AC: 4B8CEA6D  bl 0x822bff18
	ctx.lr = 0x829F14B0;
	sub_822BFF18(ctx, base);
	// 829F14B0: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F14B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F14B8: 419A0008  beq cr6, 0x829f14c0
	if ctx.cr[6].eq {
	pc = 0x829F14C0; continue 'dispatch;
	}
	// 829F14BC: 4B78FD65  bl 0x82181220
	ctx.lr = 0x829F14C0;
	sub_82181220(ctx, base);
	pc = 0x829F14C0; continue 'dispatch;
            }
            0x829F14C0 => {
    //   block [0x829F14C0..0x829F14CC)
	// 829F14C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F14C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F14C8: 482B7F94  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F14D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F14D0 size=120
    let mut pc: u32 = 0x829F14D0;
    'dispatch: loop {
        match pc {
            0x829F14D0 => {
    //   block [0x829F14D0..0x829F1520)
	// 829F14D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F14D4: 482B7F39  bl 0x82ca940c
	ctx.lr = 0x829F14D8;
	sub_82CA93D0(ctx, base);
	// 829F14D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F14DC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829F14E0: 3860007C  li r3, 0x7c
	ctx.r[3].s64 = 124;
	// 829F14E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F14E8: 4B82DD71  bl 0x8221f258
	ctx.lr = 0x829F14EC;
	sub_8221F258(ctx, base);
	// 829F14EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F14F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F14F4: 419A002C  beq cr6, 0x829f1520
	if ctx.cr[6].eq {
	pc = 0x829F1520; continue 'dispatch;
	}
	// 829F14F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F14FC: 4BA187F5  bl 0x82409cf0
	ctx.lr = 0x829F1500;
	sub_82409CF0(ctx, base);
	// 829F1500: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F1504: 389E0078  addi r4, r30, 0x78
	ctx.r[4].s64 = ctx.r[30].s64 + 120;
	// 829F1508: 394B16C0  addi r10, r11, 0x16c0
	ctx.r[10].s64 = ctx.r[11].s64 + 5824;
	// 829F150C: 387F0078  addi r3, r31, 0x78
	ctx.r[3].s64 = ctx.r[31].s64 + 120;
	// 829F1510: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829F1514: 4B7FED2D  bl 0x821f0240
	ctx.lr = 0x829F1518;
	sub_821F0240(ctx, base);
	// 829F1518: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F151C: 48000008  b 0x829f1524
	pc = 0x829F1524; continue 'dispatch;
            }
            0x829F1520 => {
    //   block [0x829F1520..0x829F1524)
	// 829F1520: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829F1524; continue 'dispatch;
            }
            0x829F1524 => {
    //   block [0x829F1524..0x829F153C)
	// 829F1524: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F1528: 4B8CE9F1  bl 0x822bff18
	ctx.lr = 0x829F152C;
	sub_822BFF18(ctx, base);
	// 829F152C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F1530: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F1534: 419A0008  beq cr6, 0x829f153c
	if ctx.cr[6].eq {
	pc = 0x829F153C; continue 'dispatch;
	}
	// 829F1538: 4B78FCE9  bl 0x82181220
	ctx.lr = 0x829F153C;
	sub_82181220(ctx, base);
	pc = 0x829F153C; continue 'dispatch;
            }
            0x829F153C => {
    //   block [0x829F153C..0x829F1548)
	// 829F153C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F1540: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F1544: 482B7F18  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F1548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F1548 size=180
    let mut pc: u32 = 0x829F1548;
    'dispatch: loop {
        match pc {
            0x829F1548 => {
    //   block [0x829F1548..0x829F15D4)
	// 829F1548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F154C: 482B7EC1  bl 0x82ca940c
	ctx.lr = 0x829F1550;
	sub_82CA93D0(ctx, base);
	// 829F1550: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F1554: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829F1558: 386000C4  li r3, 0xc4
	ctx.r[3].s64 = 196;
	// 829F155C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F1560: 4B82DCF9  bl 0x8221f258
	ctx.lr = 0x829F1564;
	sub_8221F258(ctx, base);
	// 829F1564: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F1568: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F156C: 419A0068  beq cr6, 0x829f15d4
	if ctx.cr[6].eq {
	pc = 0x829F15D4; continue 'dispatch;
	}
	// 829F1570: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F1574: 480000FD  bl 0x829f1670
	ctx.lr = 0x829F1578;
	sub_829F1670(ctx, base);
	// 829F1578: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F157C: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 829F1580: 392B1770  addi r9, r11, 0x1770
	ctx.r[9].s64 = ctx.r[11].s64 + 6000;
	// 829F1584: 390A17C0  addi r8, r10, 0x17c0
	ctx.r[8].s64 = ctx.r[10].s64 + 6080;
	// 829F1588: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829F158C: 389E00A4  addi r4, r30, 0xa4
	ctx.r[4].s64 = ctx.r[30].s64 + 164;
	// 829F1590: 911F0078  stw r8, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[8].u32 ) };
	// 829F1594: 387F00A4  addi r3, r31, 0xa4
	ctx.r[3].s64 = ctx.r[31].s64 + 164;
	// 829F1598: 4B7A57D9  bl 0x82196d70
	ctx.lr = 0x829F159C;
	sub_82196D70(ctx, base);
	// 829F159C: 80FE00AC  lwz r7, 0xac(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(172 as u32) ) } as u64;
	// 829F15A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F15A4: 90FF00AC  stw r7, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[7].u32 ) };
	// 829F15A8: 80DE00B0  lwz r6, 0xb0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 829F15AC: 90DF00B0  stw r6, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[6].u32 ) };
	// 829F15B0: C01E00B4  lfs f0, 0xb4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F15B4: D01F00B4  stfs f0, 0xb4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 829F15B8: C1BE00B8  lfs f13, 0xb8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829F15BC: D1BF00B8  stfs f13, 0xb8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 829F15C0: C19E00BC  lfs f12, 0xbc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(188 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829F15C4: D19F00BC  stfs f12, 0xbc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 829F15C8: C17E00C0  lfs f11, 0xc0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(192 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829F15CC: D17F00C0  stfs f11, 0xc0(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 829F15D0: 48000008  b 0x829f15d8
	pc = 0x829F15D8; continue 'dispatch;
            }
            0x829F15D4 => {
    //   block [0x829F15D4..0x829F15D8)
	// 829F15D4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829F15D8; continue 'dispatch;
            }
            0x829F15D8 => {
    //   block [0x829F15D8..0x829F15F0)
	// 829F15D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F15DC: 4B8CE93D  bl 0x822bff18
	ctx.lr = 0x829F15E0;
	sub_822BFF18(ctx, base);
	// 829F15E0: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F15E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F15E8: 419A0008  beq cr6, 0x829f15f0
	if ctx.cr[6].eq {
	pc = 0x829F15F0; continue 'dispatch;
	}
	// 829F15EC: 4B78FC35  bl 0x82181220
	ctx.lr = 0x829F15F0;
	sub_82181220(ctx, base);
	pc = 0x829F15F0; continue 'dispatch;
            }
            0x829F15F0 => {
    //   block [0x829F15F0..0x829F15FC)
	// 829F15F0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F15F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F15F8: 482B7E64  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F1600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F1600 size=112
    let mut pc: u32 = 0x829F1600;
    'dispatch: loop {
        match pc {
            0x829F1600 => {
    //   block [0x829F1600..0x829F1658)
	// 829F1600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F1604: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F1608: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F160C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F1610: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F1614: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F1618: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F161C: 387F00A4  addi r3, r31, 0xa4
	ctx.r[3].s64 = ctx.r[31].s64 + 164;
	// 829F1620: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 829F1624: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F1628: 915F00A4  stw r10, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[10].u32 ) };
	// 829F162C: 4B7A280D  bl 0x82193e38
	ctx.lr = 0x829F1630;
	sub_82193E38(ctx, base);
	// 829F1630: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 829F1634: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F1638: 913F00A8  stw r9, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[9].u32 ) };
	// 829F163C: 480000E5  bl 0x829f1720
	ctx.lr = 0x829F1640;
	sub_829F1720(ctx, base);
	// 829F1640: 57C807FE  clrlwi r8, r30, 0x1f
	ctx.r[8].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 829F1644: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F1648: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 829F164C: 419A000C  beq cr6, 0x829f1658
	if ctx.cr[6].eq {
	pc = 0x829F1658; continue 'dispatch;
	}
	// 829F1650: 4B82A6E9  bl 0x8221bd38
	ctx.lr = 0x829F1654;
	sub_8221BD38(ctx, base);
	// 829F1654: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x829F1658; continue 'dispatch;
            }
            0x829F1658 => {
    //   block [0x829F1658..0x829F1670)
	// 829F1658: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F165C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F1660: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F1664: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829F1668: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F166C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F1670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F1670 size=176
    let mut pc: u32 = 0x829F1670;
    'dispatch: loop {
        match pc {
            0x829F1670 => {
    //   block [0x829F1670..0x829F1720)
	// 829F1670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F1674: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F1678: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F167C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F1680: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F1684: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F1688: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F168C: 4BA18665  bl 0x82409cf0
	ctx.lr = 0x829F1690;
	sub_82409CF0(ctx, base);
	// 829F1690: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 829F1694: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 829F1698: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 829F169C: 390B04D4  addi r8, r11, 0x4d4
	ctx.r[8].s64 = ctx.r[11].s64 + 1236;
	// 829F16A0: 38EA1710  addi r7, r10, 0x1710
	ctx.r[7].s64 = ctx.r[10].s64 + 5904;
	// 829F16A4: 38C91760  addi r6, r9, 0x1760
	ctx.r[6].s64 = ctx.r[9].s64 + 5984;
	// 829F16A8: 911F0078  stw r8, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[8].u32 ) };
	// 829F16AC: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 829F16B0: 387F0084  addi r3, r31, 0x84
	ctx.r[3].s64 = ctx.r[31].s64 + 132;
	// 829F16B4: 90DF0078  stw r6, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[6].u32 ) };
	// 829F16B8: 389E0084  addi r4, r30, 0x84
	ctx.r[4].s64 = ctx.r[30].s64 + 132;
	// 829F16BC: 80BE007C  lwz r5, 0x7c(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 829F16C0: 90BF007C  stw r5, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[5].u32 ) };
	// 829F16C4: 817E0080  lwz r11, 0x80(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 829F16C8: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 829F16CC: 4B7FEB75  bl 0x821f0240
	ctx.lr = 0x829F16D0;
	sub_821F0240(ctx, base);
	// 829F16D0: 387F0088  addi r3, r31, 0x88
	ctx.r[3].s64 = ctx.r[31].s64 + 136;
	// 829F16D4: 389E0088  addi r4, r30, 0x88
	ctx.r[4].s64 = ctx.r[30].s64 + 136;
	// 829F16D8: 4B7A5699  bl 0x82196d70
	ctx.lr = 0x829F16DC;
	sub_82196D70(ctx, base);
	// 829F16DC: 387F0090  addi r3, r31, 0x90
	ctx.r[3].s64 = ctx.r[31].s64 + 144;
	// 829F16E0: 389E0090  addi r4, r30, 0x90
	ctx.r[4].s64 = ctx.r[30].s64 + 144;
	// 829F16E4: 4B7A568D  bl 0x82196d70
	ctx.lr = 0x829F16E8;
	sub_82196D70(ctx, base);
	// 829F16E8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 829F16EC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 829F16F0: 390A0E0C  addi r8, r10, 0xe0c
	ctx.r[8].s64 = ctx.r[10].s64 + 3596;
	// 829F16F4: 913F009C  stw r9, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[9].u32 ) };
	// 829F16F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F16FC: 911F0098  stw r8, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[8].u32 ) };
	// 829F1700: 80FE00A0  lwz r7, 0xa0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(160 as u32) ) } as u64;
	// 829F1704: 90FF00A0  stw r7, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[7].u32 ) };
	// 829F1708: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F170C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F1710: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F1714: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829F1718: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F171C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F1720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F1720 size=124
    let mut pc: u32 = 0x829F1720;
    'dispatch: loop {
        match pc {
            0x829F1720 => {
    //   block [0x829F1720..0x829F1778)
	// 829F1720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F1724: 482B7CE9  bl 0x82ca940c
	ctx.lr = 0x829F1728;
	sub_82CA93D0(ctx, base);
	// 829F1728: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F172C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F1730: 387F0098  addi r3, r31, 0x98
	ctx.r[3].s64 = ctx.r[31].s64 + 152;
	// 829F1734: 4B8A911D  bl 0x8229a850
	ctx.lr = 0x829F1738;
	sub_8229A850(ctx, base);
	// 829F1738: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F173C: 387F0090  addi r3, r31, 0x90
	ctx.r[3].s64 = ctx.r[31].s64 + 144;
	// 829F1740: 3BAB0B7C  addi r29, r11, 0xb7c
	ctx.r[29].s64 = ctx.r[11].s64 + 2940;
	// 829F1744: 93BF0090  stw r29, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[29].u32 ) };
	// 829F1748: 4B7A26F1  bl 0x82193e38
	ctx.lr = 0x829F174C;
	sub_82193E38(ctx, base);
	// 829F174C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829F1750: 387F0088  addi r3, r31, 0x88
	ctx.r[3].s64 = ctx.r[31].s64 + 136;
	// 829F1754: 93DF0094  stw r30, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[30].u32 ) };
	// 829F1758: 93BF0088  stw r29, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[29].u32 ) };
	// 829F175C: 4B7A26DD  bl 0x82193e38
	ctx.lr = 0x829F1760;
	sub_82193E38(ctx, base);
	// 829F1760: 93DF008C  stw r30, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[30].u32 ) };
	// 829F1764: 387F0084  addi r3, r31, 0x84
	ctx.r[3].s64 = ctx.r[31].s64 + 132;
	// 829F1768: 4B823671  bl 0x82214dd8
	ctx.lr = 0x829F176C;
	sub_82214DD8(ctx, base);
	// 829F176C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F1770: 419A0008  beq cr6, 0x829f1778
	if ctx.cr[6].eq {
	pc = 0x829F1778; continue 'dispatch;
	}
	// 829F1774: 3BDF0078  addi r30, r31, 0x78
	ctx.r[30].s64 = ctx.r[31].s64 + 120;
	pc = 0x829F1778; continue 'dispatch;
            }
            0x829F1778 => {
    //   block [0x829F1778..0x829F179C)
	// 829F1778: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 829F177C: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 829F1780: 394B04D4  addi r10, r11, 0x4d4
	ctx.r[10].s64 = ctx.r[11].s64 + 1236;
	// 829F1784: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829F1788: 4B823651  bl 0x82214dd8
	ctx.lr = 0x829F178C;
	sub_82214DD8(ctx, base);
	// 829F178C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F1790: 4B7BB3A1  bl 0x821acb30
	ctx.lr = 0x829F1794;
	sub_821ACB30(ctx, base);
	// 829F1794: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F1798: 482B7CC4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F17A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F17A0 size=80
    let mut pc: u32 = 0x829F17A0;
    'dispatch: loop {
        match pc {
            0x829F17A0 => {
    //   block [0x829F17A0..0x829F17D8)
	// 829F17A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F17A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F17A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F17AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F17B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F17B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F17B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F17BC: 4BFFFF65  bl 0x829f1720
	ctx.lr = 0x829F17C0;
	sub_829F1720(ctx, base);
	// 829F17C0: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 829F17C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F17C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F17CC: 419A000C  beq cr6, 0x829f17d8
	if ctx.cr[6].eq {
	pc = 0x829F17D8; continue 'dispatch;
	}
	// 829F17D0: 4B82A569  bl 0x8221bd38
	ctx.lr = 0x829F17D4;
	sub_8221BD38(ctx, base);
	// 829F17D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x829F17D8; continue 'dispatch;
            }
            0x829F17D8 => {
    //   block [0x829F17D8..0x829F17F0)
	// 829F17D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F17DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F17E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F17E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829F17E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F17EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F17F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F17F0 size=160
    let mut pc: u32 = 0x829F17F0;
    'dispatch: loop {
        match pc {
            0x829F17F0 => {
    //   block [0x829F17F0..0x829F1868)
	// 829F17F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F17F4: 482B7C19  bl 0x82ca940c
	ctx.lr = 0x829F17F8;
	sub_82CA93D0(ctx, base);
	// 829F17F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F17FC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829F1800: 386000BC  li r3, 0xbc
	ctx.r[3].s64 = 188;
	// 829F1804: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F1808: 4B82DA51  bl 0x8221f258
	ctx.lr = 0x829F180C;
	sub_8221F258(ctx, base);
	// 829F180C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F1810: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F1814: 419A0054  beq cr6, 0x829f1868
	if ctx.cr[6].eq {
	pc = 0x829F1868; continue 'dispatch;
	}
	// 829F1818: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F181C: 4BFFFE55  bl 0x829f1670
	ctx.lr = 0x829F1820;
	sub_829F1670(ctx, base);
	// 829F1820: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F1824: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 829F1828: 392B17D0  addi r9, r11, 0x17d0
	ctx.r[9].s64 = ctx.r[11].s64 + 6096;
	// 829F182C: 390A1820  addi r8, r10, 0x1820
	ctx.r[8].s64 = ctx.r[10].s64 + 6176;
	// 829F1830: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829F1834: 389E00AC  addi r4, r30, 0xac
	ctx.r[4].s64 = ctx.r[30].s64 + 172;
	// 829F1838: 911F0078  stw r8, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[8].u32 ) };
	// 829F183C: 387F00AC  addi r3, r31, 0xac
	ctx.r[3].s64 = ctx.r[31].s64 + 172;
	// 829F1840: 80FE00A4  lwz r7, 0xa4(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(164 as u32) ) } as u64;
	// 829F1844: 90FF00A4  stw r7, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[7].u32 ) };
	// 829F1848: 80DE00A8  lwz r6, 0xa8(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(168 as u32) ) } as u64;
	// 829F184C: 90DF00A8  stw r6, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[6].u32 ) };
	// 829F1850: 4BB66439  bl 0x82557c88
	ctx.lr = 0x829F1854;
	sub_82557C88(ctx, base);
	// 829F1854: 389E00B8  addi r4, r30, 0xb8
	ctx.r[4].s64 = ctx.r[30].s64 + 184;
	// 829F1858: 387F00B8  addi r3, r31, 0xb8
	ctx.r[3].s64 = ctx.r[31].s64 + 184;
	// 829F185C: 4B7FE9E5  bl 0x821f0240
	ctx.lr = 0x829F1860;
	sub_821F0240(ctx, base);
	// 829F1860: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F1864: 48000008  b 0x829f186c
	pc = 0x829F186C; continue 'dispatch;
            }
            0x829F1868 => {
    //   block [0x829F1868..0x829F186C)
	// 829F1868: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829F186C; continue 'dispatch;
            }
            0x829F186C => {
    //   block [0x829F186C..0x829F1884)
	// 829F186C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F1870: 4B8CE6A9  bl 0x822bff18
	ctx.lr = 0x829F1874;
	sub_822BFF18(ctx, base);
	// 829F1874: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F1878: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F187C: 419A0008  beq cr6, 0x829f1884
	if ctx.cr[6].eq {
	pc = 0x829F1884; continue 'dispatch;
	}
	// 829F1880: 4B78F9A1  bl 0x82181220
	ctx.lr = 0x829F1884;
	sub_82181220(ctx, base);
	pc = 0x829F1884; continue 'dispatch;
            }
            0x829F1884 => {
    //   block [0x829F1884..0x829F1890)
	// 829F1884: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F1888: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F188C: 482B7BD0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F1890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F1890 size=116
    let mut pc: u32 = 0x829F1890;
    'dispatch: loop {
        match pc {
            0x829F1890 => {
    //   block [0x829F1890..0x829F18EC)
	// 829F1890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F1894: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F1898: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F189C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F18A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F18A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F18A8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F18AC: 387F00B8  addi r3, r31, 0xb8
	ctx.r[3].s64 = ctx.r[31].s64 + 184;
	// 829F18B0: 4B823529  bl 0x82214dd8
	ctx.lr = 0x829F18B4;
	sub_82214DD8(ctx, base);
	// 829F18B4: 387F00AC  addi r3, r31, 0xac
	ctx.r[3].s64 = ctx.r[31].s64 + 172;
	// 829F18B8: 4BD3BA81  bl 0x8272d338
	ctx.lr = 0x829F18BC;
	sub_8272D338(ctx, base);
	// 829F18BC: 807F00B0  lwz r3, 0xb0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 829F18C0: 4B82A479  bl 0x8221bd38
	ctx.lr = 0x829F18C4;
	sub_8221BD38(ctx, base);
	// 829F18C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829F18C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F18CC: 917F00B0  stw r11, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 829F18D0: 4BFFFE51  bl 0x829f1720
	ctx.lr = 0x829F18D4;
	sub_829F1720(ctx, base);
	// 829F18D4: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 829F18D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F18DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F18E0: 419A000C  beq cr6, 0x829f18ec
	if ctx.cr[6].eq {
	pc = 0x829F18EC; continue 'dispatch;
	}
	// 829F18E4: 4B82A455  bl 0x8221bd38
	ctx.lr = 0x829F18E8;
	sub_8221BD38(ctx, base);
	// 829F18E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x829F18EC; continue 'dispatch;
            }
            0x829F18EC => {
    //   block [0x829F18EC..0x829F1904)
	// 829F18EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F18F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F18F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F18F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829F18FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F1900: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F1908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F1908 size=116
    let mut pc: u32 = 0x829F1908;
    'dispatch: loop {
        match pc {
            0x829F1908 => {
    //   block [0x829F1908..0x829F1944)
	// 829F1908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F190C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F1910: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F1914: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F1918: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F191C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F1920: 386000DC  li r3, 0xdc
	ctx.r[3].s64 = 220;
	// 829F1924: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F1928: 4B82D931  bl 0x8221f258
	ctx.lr = 0x829F192C;
	sub_8221F258(ctx, base);
	// 829F192C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F1930: 419A0014  beq cr6, 0x829f1944
	if ctx.cr[6].eq {
	pc = 0x829F1944; continue 'dispatch;
	}
	// 829F1934: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F1938: 48000049  bl 0x829f1980
	ctx.lr = 0x829F193C;
	sub_829F1980(ctx, base);
	// 829F193C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F1940: 48000008  b 0x829f1948
	pc = 0x829F1948; continue 'dispatch;
            }
            0x829F1944 => {
    //   block [0x829F1944..0x829F1948)
	// 829F1944: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829F1948; continue 'dispatch;
            }
            0x829F1948 => {
    //   block [0x829F1948..0x829F1960)
	// 829F1948: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F194C: 4B8CE5CD  bl 0x822bff18
	ctx.lr = 0x829F1950;
	sub_822BFF18(ctx, base);
	// 829F1950: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F1954: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F1958: 419A0008  beq cr6, 0x829f1960
	if ctx.cr[6].eq {
	pc = 0x829F1960; continue 'dispatch;
	}
	// 829F195C: 4B78F8C5  bl 0x82181220
	ctx.lr = 0x829F1960;
	sub_82181220(ctx, base);
	pc = 0x829F1960; continue 'dispatch;
            }
            0x829F1960 => {
    //   block [0x829F1960..0x829F197C)
	// 829F1960: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F1964: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F1968: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F196C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F1970: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829F1974: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F1978: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F1980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F1980 size=340
    let mut pc: u32 = 0x829F1980;
    'dispatch: loop {
        match pc {
            0x829F1980 => {
    //   block [0x829F1980..0x829F19C8)
	// 829F1980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F1984: 482B7A7D  bl 0x82ca9400
	ctx.lr = 0x829F1988;
	sub_82CA93D0(ctx, base);
	// 829F1988: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F198C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F1990: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829F1994: 4BFFFCDD  bl 0x829f1670
	ctx.lr = 0x829F1998;
	sub_829F1670(ctx, base);
	// 829F1998: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F199C: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 829F19A0: 392B1830  addi r9, r11, 0x1830
	ctx.r[9].s64 = ctx.r[11].s64 + 6192;
	// 829F19A4: 390A1880  addi r8, r10, 0x1880
	ctx.r[8].s64 = ctx.r[10].s64 + 6272;
	// 829F19A8: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829F19AC: 911E0078  stw r8, 0x78(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(120 as u32), ctx.r[8].u32 ) };
	// 829F19B0: 80FF00A4  lwz r7, 0xa4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 829F19B4: 90FE00A4  stw r7, 0xa4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(164 as u32), ctx.r[7].u32 ) };
	// 829F19B8: 817F00A8  lwz r11, 0xa8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 829F19BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F19C0: 917E00A8  stw r11, 0xa8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 829F19C4: 419A0020  beq cr6, 0x829f19e4
	if ctx.cr[6].eq {
	pc = 0x829F19E4; continue 'dispatch;
	}
	pc = 0x829F19C8; continue 'dispatch;
            }
            0x829F19C8 => {
    //   block [0x829F19C8..0x829F19E4)
	// 829F19C8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829F19CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F19D0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829F19D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F19D8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F19DC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F19E0: 4082FFE8  bne 0x829f19c8
	if !ctx.cr[0].eq {
	pc = 0x829F19C8; continue 'dispatch;
	}
	pc = 0x829F19E4; continue 'dispatch;
            }
            0x829F19E4 => {
    //   block [0x829F19E4..0x829F1A58)
	// 829F19E4: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 829F19E8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829F19EC: 3BBF00CC  addi r29, r31, 0xcc
	ctx.r[29].s64 = ctx.r[31].s64 + 204;
	// 829F19F0: 3B7E00CC  addi r27, r30, 0xcc
	ctx.r[27].s64 = ctx.r[30].s64 + 204;
	// 829F19F4: 917E00AC  stw r11, 0xac(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 829F19F8: 815F00B0  lwz r10, 0xb0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 829F19FC: 915E00B0  stw r10, 0xb0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(176 as u32), ctx.r[10].u32 ) };
	// 829F1A00: 813F00B4  lwz r9, 0xb4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 829F1A04: 913E00B4  stw r9, 0xb4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(180 as u32), ctx.r[9].u32 ) };
	// 829F1A08: C01F00B8  lfs f0, 0xb8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F1A0C: D01E00B8  stfs f0, 0xb8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 829F1A10: 811F00BC  lwz r8, 0xbc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 829F1A14: 911E00BC  stw r8, 0xbc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(188 as u32), ctx.r[8].u32 ) };
	// 829F1A18: 80FF00C0  lwz r7, 0xc0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 829F1A1C: 90FE00C0  stw r7, 0xc0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(192 as u32), ctx.r[7].u32 ) };
	// 829F1A20: 80DF00C4  lwz r6, 0xc4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 829F1A24: 90DE00C4  stw r6, 0xc4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(196 as u32), ctx.r[6].u32 ) };
	// 829F1A28: 80BF00C8  lwz r5, 0xc8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 829F1A2C: 90BE00C8  stw r5, 0xc8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(200 as u32), ctx.r[5].u32 ) };
	// 829F1A30: 809F00D4  lwz r4, 0xd4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 829F1A34: 807F00D0  lwz r3, 0xd0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 829F1A38: 7D632050  subf r11, r3, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[3].s64;
	// 829F1A3C: 7D642E71  srawi. r4, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[11].s32 >> 5) as i64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 829F1A40: 939E00D0  stw r28, 0xd0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(208 as u32), ctx.r[28].u32 ) };
	// 829F1A44: 939E00D4  stw r28, 0xd4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(212 as u32), ctx.r[28].u32 ) };
	// 829F1A48: 939E00D8  stw r28, 0xd8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(216 as u32), ctx.r[28].u32 ) };
	// 829F1A4C: 4082000C  bne 0x829f1a58
	if !ctx.cr[0].eq {
	pc = 0x829F1A58; continue 'dispatch;
	}
	// 829F1A50: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829F1A54: 4800000C  b 0x829f1a60
	pc = 0x829F1A60; continue 'dispatch;
            }
            0x829F1A58 => {
    //   block [0x829F1A58..0x829F1A60)
	// 829F1A58: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829F1A5C: 4801F495  bl 0x82a10ef0
	ctx.lr = 0x829F1A60;
	sub_82A10EF0(ctx, base);
	pc = 0x829F1A60; continue 'dispatch;
            }
            0x829F1A60 => {
    //   block [0x829F1A60..0x829F1AB4)
	// 829F1A60: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829F1A64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F1A68: 419A0060  beq cr6, 0x829f1ac8
	if ctx.cr[6].eq {
	pc = 0x829F1AC8; continue 'dispatch;
	}
	// 829F1A6C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829F1A70: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F1A74: 835D0008  lwz r26, 8(r29)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F1A78: 83FB0004  lwz r31, 4(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F1A7C: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 829F1A80: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829F1A84: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829F1A88: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829F1A8C: 419A0038  beq cr6, 0x829f1ac4
	if ctx.cr[6].eq {
	pc = 0x829F1AC4; continue 'dispatch;
	}
	// 829F1A90: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F1A94: 3B800010  li r28, 0x10
	ctx.r[28].s64 = 16;
	// 829F1A98: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F1A9C: 419A0018  beq cr6, 0x829f1ab4
	if ctx.cr[6].eq {
	pc = 0x829F1AB4; continue 'dispatch;
	}
	// 829F1AA0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F1AA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F1AA8: 4B7A52C9  bl 0x82196d70
	ctx.lr = 0x829F1AAC;
	sub_82196D70(ctx, base);
	pc = 0x829F1AB4; continue 'dispatch;
            }
            0x829F1AB4 => {
    //   block [0x829F1AB4..0x829F1AC4)
	// 829F1AB4: 3BBD0020  addi r29, r29, 0x20
	ctx.r[29].s64 = ctx.r[29].s64 + 32;
	// 829F1AB8: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 829F1ABC: 7F1DD040  cmplw cr6, r29, r26
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[26].u32, &mut ctx.xer);
	// 829F1AC0: 409AFFD8  bne cr6, 0x829f1a98
	if !ctx.cr[6].eq {
	pc = 0x829F1A98; continue 'dispatch;
	}
	pc = 0x829F1AC4; continue 'dispatch;
            }
            0x829F1AC4 => {
    //   block [0x829F1AC4..0x829F1AC8)
	// 829F1AC4: 93FB0008  stw r31, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	pc = 0x829F1AC8; continue 'dispatch;
            }
            0x829F1AC8 => {
    //   block [0x829F1AC8..0x829F1AD4)
	// 829F1AC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F1ACC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829F1AD0: 482B7980  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F1AD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F1AD8 size=120
    let mut pc: u32 = 0x829F1AD8;
    'dispatch: loop {
        match pc {
            0x829F1AD8 => {
    //   block [0x829F1AD8..0x829F1B10)
	// 829F1AD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F1ADC: 482B7931  bl 0x82ca940c
	ctx.lr = 0x829F1AE0;
	sub_82CA93D0(ctx, base);
	// 829F1AE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F1AE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F1AE8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 829F1AEC: 3BFE00CC  addi r31, r30, 0xcc
	ctx.r[31].s64 = ctx.r[30].s64 + 204;
	// 829F1AF0: 809E00D0  lwz r4, 0xd0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) } as u64;
	// 829F1AF4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 829F1AF8: 419A0018  beq cr6, 0x829f1b10
	if ctx.cr[6].eq {
	pc = 0x829F1B10; continue 'dispatch;
	}
	// 829F1AFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F1B00: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F1B04: 48003B3D  bl 0x829f5640
	ctx.lr = 0x829F1B08;
	sub_829F5640(ctx, base);
	// 829F1B08: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F1B0C: 4B82A22D  bl 0x8221bd38
	ctx.lr = 0x829F1B10;
	sub_8221BD38(ctx, base);
	pc = 0x829F1B10; continue 'dispatch;
            }
            0x829F1B10 => {
    //   block [0x829F1B10..0x829F1B48)
	// 829F1B10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829F1B14: 387E00A4  addi r3, r30, 0xa4
	ctx.r[3].s64 = ctx.r[30].s64 + 164;
	// 829F1B18: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 829F1B1C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 829F1B20: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 829F1B24: 4B7C5FF5  bl 0x821b7b18
	ctx.lr = 0x829F1B28;
	sub_821B7B18(ctx, base);
	// 829F1B28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F1B2C: 4BFFFBF5  bl 0x829f1720
	ctx.lr = 0x829F1B30;
	sub_829F1720(ctx, base);
	// 829F1B30: 57AB07FE  clrlwi r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	// 829F1B34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F1B38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F1B3C: 419A000C  beq cr6, 0x829f1b48
	if ctx.cr[6].eq {
	pc = 0x829F1B48; continue 'dispatch;
	}
	// 829F1B40: 4B82A1F9  bl 0x8221bd38
	ctx.lr = 0x829F1B44;
	sub_8221BD38(ctx, base);
	// 829F1B44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x829F1B48; continue 'dispatch;
            }
            0x829F1B48 => {
    //   block [0x829F1B48..0x829F1B50)
	// 829F1B48: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F1B4C: 482B7910  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F1B50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F1B50 size=124
    let mut pc: u32 = 0x829F1B50;
    'dispatch: loop {
        match pc {
            0x829F1B50 => {
    //   block [0x829F1B50..0x829F1BA4)
	// 829F1B50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F1B54: 482B78B9  bl 0x82ca940c
	ctx.lr = 0x829F1B58;
	sub_82CA93D0(ctx, base);
	// 829F1B58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F1B5C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829F1B60: 38600080  li r3, 0x80
	ctx.r[3].s64 = 128;
	// 829F1B64: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F1B68: 4B82D6F1  bl 0x8221f258
	ctx.lr = 0x829F1B6C;
	sub_8221F258(ctx, base);
	// 829F1B6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F1B70: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F1B74: 419A0030  beq cr6, 0x829f1ba4
	if ctx.cr[6].eq {
	pc = 0x829F1BA4; continue 'dispatch;
	}
	// 829F1B78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F1B7C: 4BA18175  bl 0x82409cf0
	ctx.lr = 0x829F1B80;
	sub_82409CF0(ctx, base);
	// 829F1B80: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F1B84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F1B88: 394B1890  addi r10, r11, 0x1890
	ctx.r[10].s64 = ctx.r[11].s64 + 6288;
	// 829F1B8C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829F1B90: C01E0078  lfs f0, 0x78(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F1B94: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 829F1B98: C1BE007C  lfs f13, 0x7c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829F1B9C: D1BF007C  stfs f13, 0x7c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 829F1BA0: 48000008  b 0x829f1ba8
	pc = 0x829F1BA8; continue 'dispatch;
            }
            0x829F1BA4 => {
    //   block [0x829F1BA4..0x829F1BA8)
	// 829F1BA4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829F1BA8; continue 'dispatch;
            }
            0x829F1BA8 => {
    //   block [0x829F1BA8..0x829F1BC0)
	// 829F1BA8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F1BAC: 4B8CE36D  bl 0x822bff18
	ctx.lr = 0x829F1BB0;
	sub_822BFF18(ctx, base);
	// 829F1BB0: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F1BB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F1BB8: 419A0008  beq cr6, 0x829f1bc0
	if ctx.cr[6].eq {
	pc = 0x829F1BC0; continue 'dispatch;
	}
	// 829F1BBC: 4B78F665  bl 0x82181220
	ctx.lr = 0x829F1BC0;
	sub_82181220(ctx, base);
	pc = 0x829F1BC0; continue 'dispatch;
            }
            0x829F1BC0 => {
    //   block [0x829F1BC0..0x829F1BCC)
	// 829F1BC0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F1BC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F1BC8: 482B7894  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F1BD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F1BD0 size=380
    let mut pc: u32 = 0x829F1BD0;
    'dispatch: loop {
        match pc {
            0x829F1BD0 => {
    //   block [0x829F1BD0..0x829F1C10)
	// 829F1BD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F1BD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F1BD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F1BDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F1BE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F1BE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F1BE8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829F1BEC: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 829F1BF0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F1BF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F1BF8: 419A001C  beq cr6, 0x829f1c14
	if ctx.cr[6].eq {
	pc = 0x829F1C14; continue 'dispatch;
	}
	// 829F1BFC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F1C00: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F1C04: 419A000C  beq cr6, 0x829f1c10
	if ctx.cr[6].eq {
	pc = 0x829F1C10; continue 'dispatch;
	}
	// 829F1C08: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F1C0C: 4800000C  b 0x829f1c18
	pc = 0x829F1C18; continue 'dispatch;
            }
            0x829F1C10 => {
    //   block [0x829F1C10..0x829F1C14)
	// 829F1C10: 4B7A2229  bl 0x82193e38
	ctx.lr = 0x829F1C14;
	sub_82193E38(ctx, base);
	pc = 0x829F1C14; continue 'dispatch;
            }
            0x829F1C14 => {
    //   block [0x829F1C14..0x829F1C18)
	// 829F1C14: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x829F1C18; continue 'dispatch;
            }
            0x829F1C18 => {
    //   block [0x829F1C18..0x829F1C54)
	// 829F1C18: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 829F1C1C: 55493FFE  rlwinm r9, r10, 7, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x01FFFFFFu64;
	// 829F1C20: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829F1C24: 419A00F4  beq cr6, 0x829f1d18
	if ctx.cr[6].eq {
	pc = 0x829F1D18; continue 'dispatch;
	}
	// 829F1C28: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F1C2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F1C30: 419A0024  beq cr6, 0x829f1c54
	if ctx.cr[6].eq {
	pc = 0x829F1C54; continue 'dispatch;
	}
	// 829F1C34: 892A00F9  lbz r9, 0xf9(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(249 as u32) ) } as u64;
	// 829F1C38: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F1C3C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 829F1C40: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829F1C44: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F1C48: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F1C4C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F1C50: 480000CC  b 0x829f1d1c
	pc = 0x829F1D1C; continue 'dispatch;
            }
            0x829F1C54 => {
    //   block [0x829F1C54..0x829F1C70)
	// 829F1C54: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F1C58: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829F1C5C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829F1C60: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829F1C64: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829F1C68: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F1C6C: 40810054  ble 0x829f1cc0
	if !ctx.cr[0].gt {
	pc = 0x829F1CC0; continue 'dispatch;
	}
	pc = 0x829F1C70; continue 'dispatch;
            }
            0x829F1C70 => {
    //   block [0x829F1C70..0x829F1C90)
	// 829F1C70: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829F1C74: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F1C78: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829F1C7C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F1C80: 2F0700F9  cmpwi cr6, r7, 0xf9
	ctx.cr[6].compare_i32(ctx.r[7].s32, 249, &mut ctx.xer);
	// 829F1C84: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829F1C88: 41980008  blt cr6, 0x829f1c90
	if ctx.cr[6].lt {
	pc = 0x829F1C90; continue 'dispatch;
	}
	// 829F1C8C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x829F1C90; continue 'dispatch;
            }
            0x829F1C90 => {
    //   block [0x829F1C90..0x829F1CAC)
	// 829F1C90: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829F1C94: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829F1C98: 419A0014  beq cr6, 0x829f1cac
	if ctx.cr[6].eq {
	pc = 0x829F1CAC; continue 'dispatch;
	}
	// 829F1C9C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829F1CA0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F1CA4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F1CA8: 4800000C  b 0x829f1cb4
	pc = 0x829F1CB4; continue 'dispatch;
            }
            0x829F1CAC => {
    //   block [0x829F1CAC..0x829F1CB4)
	// 829F1CAC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829F1CB0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829F1CB4; continue 'dispatch;
            }
            0x829F1CB4 => {
    //   block [0x829F1CB4..0x829F1CC0)
	// 829F1CB4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F1CB8: 4199FFB8  bgt cr6, 0x829f1c70
	if ctx.cr[6].gt {
	pc = 0x829F1C70; continue 'dispatch;
	}
	// 829F1CBC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x829F1CC0; continue 'dispatch;
            }
            0x829F1CC0 => {
    //   block [0x829F1CC0..0x829F1CDC)
	// 829F1CC0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829F1CC4: 419A0040  beq cr6, 0x829f1d04
	if ctx.cr[6].eq {
	pc = 0x829F1D04; continue 'dispatch;
	}
	// 829F1CC8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F1CCC: 2F0B00F9  cmpwi cr6, r11, 0xf9
	ctx.cr[6].compare_i32(ctx.r[11].s32, 249, &mut ctx.xer);
	// 829F1CD0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F1CD4: 41990008  bgt cr6, 0x829f1cdc
	if ctx.cr[6].gt {
	pc = 0x829F1CDC; continue 'dispatch;
	}
	// 829F1CD8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x829F1CDC; continue 'dispatch;
            }
            0x829F1CDC => {
    //   block [0x829F1CDC..0x829F1D04)
	// 829F1CDC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F1CE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F1CE4: 409A0020  bne cr6, 0x829f1d04
	if !ctx.cr[6].eq {
	pc = 0x829F1D04; continue 'dispatch;
	}
	// 829F1CE8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829F1CEC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829F1CF0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F1CF4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F1CF8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F1CFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F1D00: 4800001C  b 0x829f1d1c
	pc = 0x829F1D1C; continue 'dispatch;
            }
            0x829F1D04 => {
    //   block [0x829F1D04..0x829F1D18)
	// 829F1D04: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829F1D08: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F1D0C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F1D10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F1D14: 48000008  b 0x829f1d1c
	pc = 0x829F1D1C; continue 'dispatch;
            }
            0x829F1D18 => {
    //   block [0x829F1D18..0x829F1D1C)
	// 829F1D18: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x829F1D1C; continue 'dispatch;
            }
            0x829F1D1C => {
    //   block [0x829F1D1C..0x829F1D34)
	// 829F1D1C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F1D20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F1D24: 419A0010  beq cr6, 0x829f1d34
	if ctx.cr[6].eq {
	pc = 0x829F1D34; continue 'dispatch;
	}
	// 829F1D28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F1D2C: C03E0078  lfs f1, 0x78(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829F1D30: 4BD77B01  bl 0x82769830
	ctx.lr = 0x829F1D34;
	sub_82769830(ctx, base);
	pc = 0x829F1D34; continue 'dispatch;
            }
            0x829F1D34 => {
    //   block [0x829F1D34..0x829F1D4C)
	// 829F1D34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F1D38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F1D3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F1D40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829F1D44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F1D48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F1D50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F1D50 size=116
    let mut pc: u32 = 0x829F1D50;
    'dispatch: loop {
        match pc {
            0x829F1D50 => {
    //   block [0x829F1D50..0x829F1D90)
	// 829F1D50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F1D54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F1D58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F1D5C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F1D60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F1D64: 4B7F19D5  bl 0x821e3738
	ctx.lr = 0x829F1D68;
	sub_821E3738(ctx, base);
	// 829F1D68: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 829F1D6C: 4B82D4ED  bl 0x8221f258
	ctx.lr = 0x829F1D70;
	sub_8221F258(ctx, base);
	// 829F1D70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F1D74: 419A001C  beq cr6, 0x829f1d90
	if ctx.cr[6].eq {
	pc = 0x829F1D90; continue 'dispatch;
	}
	// 829F1D78: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 829F1D7C: 38BF0078  addi r5, r31, 0x78
	ctx.r[5].s64 = ctx.r[31].s64 + 120;
	// 829F1D80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F1D84: 4BFD8AFD  bl 0x829ca880
	ctx.lr = 0x829F1D88;
	sub_829CA880(ctx, base);
	// 829F1D88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F1D8C: 48000008  b 0x829f1d94
	pc = 0x829F1D94; continue 'dispatch;
            }
            0x829F1D90 => {
    //   block [0x829F1D90..0x829F1D94)
	// 829F1D90: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829F1D94; continue 'dispatch;
            }
            0x829F1D94 => {
    //   block [0x829F1D94..0x829F1DC4)
	// 829F1D94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F1D98: 4B7C9D19  bl 0x821bbab0
	ctx.lr = 0x829F1D9C;
	sub_821BBAB0(ctx, base);
	// 829F1D9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F1DA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F1DA4: 4B87A0C5  bl 0x8226be68
	ctx.lr = 0x829F1DA8;
	sub_8226BE68(ctx, base);
	// 829F1DA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F1DAC: 4B7C5D6D  bl 0x821b7b18
	ctx.lr = 0x829F1DB0;
	sub_821B7B18(ctx, base);
	// 829F1DB0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F1DB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F1DB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F1DBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F1DC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F1DC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F1DC8 size=288
    let mut pc: u32 = 0x829F1DC8;
    'dispatch: loop {
        match pc {
            0x829F1DC8 => {
    //   block [0x829F1DC8..0x829F1E8C)
	// 829F1DC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F1DCC: 482B7641  bl 0x82ca940c
	ctx.lr = 0x829F1DD0;
	sub_82CA93D0(ctx, base);
	// 829F1DD0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F1DD4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F1DD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F1DDC: 3BAB0CA0  addi r29, r11, 0xca0
	ctx.r[29].s64 = ctx.r[11].s64 + 3232;
	// 829F1DE0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F1DE4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829F1DE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F1DEC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F1DF0: 4B83B0E1  bl 0x8222ced0
	ctx.lr = 0x829F1DF4;
	sub_8222CED0(ctx, base);
	// 829F1DF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F1DF8: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 829F1DFC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 829F1E00: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 829F1E04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F1E08: 4B7A17C9  bl 0x821935d0
	ctx.lr = 0x829F1E0C;
	sub_821935D0(ctx, base);
	// 829F1E0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F1E10: 4B822FC9  bl 0x82214dd8
	ctx.lr = 0x829F1E14;
	sub_82214DD8(ctx, base);
	// 829F1E14: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 829F1E18: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 829F1E1C: 3D00820F  lis r8, -0x7df1
	ctx.r[8].s64 = -2112946176;
	// 829F1E20: 38EA04D4  addi r7, r10, 0x4d4
	ctx.r[7].s64 = ctx.r[10].s64 + 1236;
	// 829F1E24: 38A81760  addi r5, r8, 0x1760
	ctx.r[5].s64 = ctx.r[8].s64 + 5984;
	// 829F1E28: 38C91710  addi r6, r9, 0x1710
	ctx.r[6].s64 = ctx.r[9].s64 + 5904;
	// 829F1E2C: 90FF0078  stw r7, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[7].u32 ) };
	// 829F1E30: 90BF0078  stw r5, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[5].u32 ) };
	// 829F1E34: 3C80820F  lis r4, -0x7df1
	ctx.r[4].s64 = -2112946176;
	// 829F1E38: 90DF0000  stw r6, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 829F1E3C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829F1E40: 3884156C  addi r4, r4, 0x156c
	ctx.r[4].s64 = ctx.r[4].s64 + 5484;
	// 829F1E44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F1E48: 4B917179  bl 0x82308fc0
	ctx.lr = 0x829F1E4C;
	sub_82308FC0(ctx, base);
	// 829F1E4C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F1E50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F1E54: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829F1E58: 4B83B079  bl 0x8222ced0
	ctx.lr = 0x829F1E5C;
	sub_8222CED0(ctx, base);
	// 829F1E5C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829F1E60: 387F007C  addi r3, r31, 0x7c
	ctx.r[3].s64 = ctx.r[31].s64 + 124;
	// 829F1E64: 4B7AA785  bl 0x8219c5e8
	ctx.lr = 0x829F1E68;
	sub_8219C5E8(ctx, base);
	// 829F1E68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F1E6C: 4B822F6D  bl 0x82214dd8
	ctx.lr = 0x829F1E70;
	sub_82214DD8(ctx, base);
	// 829F1E70: 3C60834A  lis r3, -0x7cb6
	ctx.r[3].s64 = -2092302336;
	// 829F1E74: 8163B780  lwz r11, -0x4880(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-18560 as u32) ) } as u64;
	// 829F1E78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F1E7C: 409A0010  bne cr6, 0x829f1e8c
	if !ctx.cr[6].eq {
	pc = 0x829F1E8C; continue 'dispatch;
	}
	// 829F1E80: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 829F1E84: 38ABFFDF  addi r5, r11, -0x21
	ctx.r[5].s64 = ctx.r[11].s64 + -33;
	// 829F1E88: 48000008  b 0x829f1e90
	pc = 0x829F1E90; continue 'dispatch;
            }
            0x829F1E8C => {
    //   block [0x829F1E8C..0x829F1E90)
	// 829F1E8C: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829F1E90; continue 'dispatch;
            }
            0x829F1E90 => {
    //   block [0x829F1E90..0x829F1EE8)
	// 829F1E90: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F1E94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F1E98: 388B157C  addi r4, r11, 0x157c
	ctx.r[4].s64 = ctx.r[11].s64 + 5500;
	// 829F1E9C: 4B917125  bl 0x82308fc0
	ctx.lr = 0x829F1EA0;
	sub_82308FC0(ctx, base);
	// 829F1EA0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F1EA4: 387F0084  addi r3, r31, 0x84
	ctx.r[3].s64 = ctx.r[31].s64 + 132;
	// 829F1EA8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829F1EAC: 4B83B025  bl 0x8222ced0
	ctx.lr = 0x829F1EB0;
	sub_8222CED0(ctx, base);
	// 829F1EB0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829F1EB4: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 829F1EB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829F1EBC: 390A0B7C  addi r8, r10, 0xb7c
	ctx.r[8].s64 = ctx.r[10].s64 + 2940;
	// 829F1EC0: 38E90E0C  addi r7, r9, 0xe0c
	ctx.r[7].s64 = ctx.r[9].s64 + 3596;
	// 829F1EC4: 917F008C  stw r11, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 829F1EC8: 911F0088  stw r8, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[8].u32 ) };
	// 829F1ECC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F1ED0: 917F0094  stw r11, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 829F1ED4: 911F0090  stw r8, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[8].u32 ) };
	// 829F1ED8: 917F009C  stw r11, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 829F1EDC: 90FF0098  stw r7, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[7].u32 ) };
	// 829F1EE0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829F1EE4: 482B7578  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F1EE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829F1EE8 size=1504
    let mut pc: u32 = 0x829F1EE8;
    'dispatch: loop {
        match pc {
            0x829F1EE8 => {
    //   block [0x829F1EE8..0x829F24C8)
	// 829F1EE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F1EEC: 482B7515  bl 0x82ca9400
	ctx.lr = 0x829F1EF0;
	sub_82CA93D0(ctx, base);
	// 829F1EF0: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F24D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F24D0 size=584
    let mut pc: u32 = 0x829F24D0;
    'dispatch: loop {
        match pc {
            0x829F24D0 => {
    //   block [0x829F24D0..0x829F2528)
	// 829F24D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F24D4: 482B6F39  bl 0x82ca940c
	ctx.lr = 0x829F24D8;
	sub_82CA93D0(ctx, base);
	// 829F24D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F24DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F24E0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829F24E4: 3BFE0088  addi r31, r30, 0x88
	ctx.r[31].s64 = ctx.r[30].s64 + 136;
	// 829F24E8: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F24EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F24F0: 419A0038  beq cr6, 0x829f2528
	if ctx.cr[6].eq {
	pc = 0x829F2528; continue 'dispatch;
	}
	// 829F24F4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F24F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F24FC: 419A011C  beq cr6, 0x829f2618
	if ctx.cr[6].eq {
	pc = 0x829F2618; continue 'dispatch;
	}
	// 829F2500: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F2504: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F2508: 419A0020  beq cr6, 0x829f2528
	if ctx.cr[6].eq {
	pc = 0x829F2528; continue 'dispatch;
	}
	// 829F250C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F2510: 4B781929  bl 0x82173e38
	ctx.lr = 0x829F2514;
	sub_82173E38(ctx, base);
	// 829F2514: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 829F2518: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829F251C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F2520: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F2524: 409A0008  bne cr6, 0x829f252c
	if !ctx.cr[6].eq {
	pc = 0x829F252C; continue 'dispatch;
	}
	pc = 0x829F2528; continue 'dispatch;
            }
            0x829F2528 => {
    //   block [0x829F2528..0x829F252C)
	// 829F2528: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829F252C; continue 'dispatch;
            }
            0x829F252C => {
    //   block [0x829F252C..0x829F257C)
	// 829F252C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F2530: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F2534: 419A0048  beq cr6, 0x829f257c
	if ctx.cr[6].eq {
	pc = 0x829F257C; continue 'dispatch;
	}
	// 829F2538: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F253C: 4B7818FD  bl 0x82173e38
	ctx.lr = 0x829F2540;
	sub_82173E38(ctx, base);
	// 829F2540: 4B99B2E9  bl 0x8238d828
	ctx.lr = 0x829F2544;
	sub_8238D828(ctx, base);
	// 829F2544: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F2548: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829F254C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F2550: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 829F2554: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829F2558: 4B7A18E1  bl 0x82193e38
	ctx.lr = 0x829F255C;
	sub_82193E38(ctx, base);
	// 829F255C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829F2560: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F2564: 4BADF965  bl 0x824d1ec8
	ctx.lr = 0x829F2568;
	sub_824D1EC8(ctx, base);
	// 829F2568: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 829F256C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F2570: 39090B7C  addi r8, r9, 0xb7c
	ctx.r[8].s64 = ctx.r[9].s64 + 2940;
	// 829F2574: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 829F2578: 4B7A18C1  bl 0x82193e38
	ctx.lr = 0x829F257C;
	sub_82193E38(ctx, base);
	pc = 0x829F257C; continue 'dispatch;
            }
            0x829F257C => {
    //   block [0x829F257C..0x829F25C0)
	// 829F257C: 817E0094  lwz r11, 0x94(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) } as u64;
	// 829F2580: 3BFE0090  addi r31, r30, 0x90
	ctx.r[31].s64 = ctx.r[30].s64 + 144;
	// 829F2584: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F2588: 419A0038  beq cr6, 0x829f25c0
	if ctx.cr[6].eq {
	pc = 0x829F25C0; continue 'dispatch;
	}
	// 829F258C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F2590: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F2594: 419A0090  beq cr6, 0x829f2624
	if ctx.cr[6].eq {
	pc = 0x829F2624; continue 'dispatch;
	}
	// 829F2598: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F259C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F25A0: 419A0020  beq cr6, 0x829f25c0
	if ctx.cr[6].eq {
	pc = 0x829F25C0; continue 'dispatch;
	}
	// 829F25A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F25A8: 4B781891  bl 0x82173e38
	ctx.lr = 0x829F25AC;
	sub_82173E38(ctx, base);
	// 829F25AC: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 829F25B0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829F25B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F25B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F25BC: 409A0008  bne cr6, 0x829f25c4
	if !ctx.cr[6].eq {
	pc = 0x829F25C4; continue 'dispatch;
	}
	pc = 0x829F25C0; continue 'dispatch;
            }
            0x829F25C0 => {
    //   block [0x829F25C0..0x829F25C4)
	// 829F25C0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829F25C4; continue 'dispatch;
            }
            0x829F25C4 => {
    //   block [0x829F25C4..0x829F2618)
	// 829F25C4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F25C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F25CC: 419A0144  beq cr6, 0x829f2710
	if ctx.cr[6].eq {
	pc = 0x829F2710; continue 'dispatch;
	}
	// 829F25D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F25D4: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 829F25D8: 4B781861  bl 0x82173e38
	ctx.lr = 0x829F25DC;
	sub_82173E38(ctx, base);
	// 829F25DC: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 829F25E0: 556A57FE  rlwinm r10, r11, 0xa, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x003FFFFFu64;
	// 829F25E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F25E8: 419A010C  beq cr6, 0x829f26f4
	if ctx.cr[6].eq {
	pc = 0x829F26F4; continue 'dispatch;
	}
	// 829F25EC: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F25F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F25F4: 419A003C  beq cr6, 0x829f2630
	if ctx.cr[6].eq {
	pc = 0x829F2630; continue 'dispatch;
	}
	// 829F25F8: 894B0056  lbz r10, 0x56(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(86 as u32) ) } as u64;
	// 829F25FC: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F2600: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 829F2604: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829F2608: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F260C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F2610: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F2614: 480000E4  b 0x829f26f8
	pc = 0x829F26F8; continue 'dispatch;
            }
            0x829F2618 => {
    //   block [0x829F2618..0x829F2624)
	// 829F2618: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F261C: 4B7A181D  bl 0x82193e38
	ctx.lr = 0x829F2620;
	sub_82193E38(ctx, base);
	// 829F2620: 4BFFFF08  b 0x829f2528
	pc = 0x829F2528; continue 'dispatch;
            }
            0x829F2624 => {
    //   block [0x829F2624..0x829F2630)
	// 829F2624: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F2628: 4B7A1811  bl 0x82193e38
	ctx.lr = 0x829F262C;
	sub_82193E38(ctx, base);
	// 829F262C: 4BFFFF94  b 0x829f25c0
	pc = 0x829F25C0; continue 'dispatch;
            }
            0x829F2630 => {
    //   block [0x829F2630..0x829F264C)
	// 829F2630: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F2634: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 829F2638: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 829F263C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829F2640: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829F2644: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F2648: 40810054  ble 0x829f269c
	if !ctx.cr[0].gt {
	pc = 0x829F269C; continue 'dispatch;
	}
	pc = 0x829F264C; continue 'dispatch;
            }
            0x829F264C => {
    //   block [0x829F264C..0x829F266C)
	// 829F264C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829F2650: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F2654: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829F2658: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F265C: 2F070056  cmpwi cr6, r7, 0x56
	ctx.cr[6].compare_i32(ctx.r[7].s32, 86, &mut ctx.xer);
	// 829F2660: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829F2664: 41980008  blt cr6, 0x829f266c
	if ctx.cr[6].lt {
	pc = 0x829F266C; continue 'dispatch;
	}
	// 829F2668: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x829F266C; continue 'dispatch;
            }
            0x829F266C => {
    //   block [0x829F266C..0x829F2688)
	// 829F266C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829F2670: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829F2674: 419A0014  beq cr6, 0x829f2688
	if ctx.cr[6].eq {
	pc = 0x829F2688; continue 'dispatch;
	}
	// 829F2678: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829F267C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F2680: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F2684: 4800000C  b 0x829f2690
	pc = 0x829F2690; continue 'dispatch;
            }
            0x829F2688 => {
    //   block [0x829F2688..0x829F2690)
	// 829F2688: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829F268C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829F2690; continue 'dispatch;
            }
            0x829F2690 => {
    //   block [0x829F2690..0x829F269C)
	// 829F2690: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F2694: 4199FFB8  bgt cr6, 0x829f264c
	if ctx.cr[6].gt {
	pc = 0x829F264C; continue 'dispatch;
	}
	// 829F2698: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x829F269C; continue 'dispatch;
            }
            0x829F269C => {
    //   block [0x829F269C..0x829F26B8)
	// 829F269C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829F26A0: 419A0040  beq cr6, 0x829f26e0
	if ctx.cr[6].eq {
	pc = 0x829F26E0; continue 'dispatch;
	}
	// 829F26A4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F26A8: 2F0B0056  cmpwi cr6, r11, 0x56
	ctx.cr[6].compare_i32(ctx.r[11].s32, 86, &mut ctx.xer);
	// 829F26AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F26B0: 41990008  bgt cr6, 0x829f26b8
	if ctx.cr[6].gt {
	pc = 0x829F26B8; continue 'dispatch;
	}
	// 829F26B4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829F26B8; continue 'dispatch;
            }
            0x829F26B8 => {
    //   block [0x829F26B8..0x829F26E0)
	// 829F26B8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F26BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F26C0: 409A0020  bne cr6, 0x829f26e0
	if !ctx.cr[6].eq {
	pc = 0x829F26E0; continue 'dispatch;
	}
	// 829F26C4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829F26C8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829F26CC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F26D0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F26D4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F26D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F26DC: 4800001C  b 0x829f26f8
	pc = 0x829F26F8; continue 'dispatch;
            }
            0x829F26E0 => {
    //   block [0x829F26E0..0x829F26F4)
	// 829F26E0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829F26E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F26E8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F26EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F26F0: 48000008  b 0x829f26f8
	pc = 0x829F26F8; continue 'dispatch;
            }
            0x829F26F4 => {
    //   block [0x829F26F4..0x829F26F8)
	// 829F26F4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829F26F8; continue 'dispatch;
            }
            0x829F26F8 => {
    //   block [0x829F26F8..0x829F2710)
	// 829F26F8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F26FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F2700: 419A0010  beq cr6, 0x829f2710
	if ctx.cr[6].eq {
	pc = 0x829F2710; continue 'dispatch;
	}
	// 829F2704: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829F2708: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F270C: 4BD74715  bl 0x82766e20
	ctx.lr = 0x829F2710;
	sub_82766E20(ctx, base);
	pc = 0x829F2710; continue 'dispatch;
            }
            0x829F2710 => {
    //   block [0x829F2710..0x829F2718)
	// 829F2710: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829F2714: 482B6D48  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F2718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829F2718 size=868
    let mut pc: u32 = 0x829F2718;
    'dispatch: loop {
        match pc {
            0x829F2718 => {
    //   block [0x829F2718..0x829F2A7C)
	// 829F2718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F271C: 482B6CED  bl 0x82ca9408
	ctx.lr = 0x829F2720;
	sub_82CA93D0(ctx, base);
	// 829F2720: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F2A80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F2A80 size=728
    let mut pc: u32 = 0x829F2A80;
    'dispatch: loop {
        match pc {
            0x829F2A80 => {
    //   block [0x829F2A80..0x829F2ADC)
	// 829F2A80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F2A84: 482B6985  bl 0x82ca9408
	ctx.lr = 0x829F2A88;
	sub_82CA93D0(ctx, base);
	// 829F2A88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F2A8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F2A90: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 829F2A94: 3BFE0090  addi r31, r30, 0x90
	ctx.r[31].s64 = ctx.r[30].s64 + 144;
	// 829F2A98: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829F2A9C: 817E0094  lwz r11, 0x94(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) } as u64;
	// 829F2AA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F2AA4: 419A0038  beq cr6, 0x829f2adc
	if ctx.cr[6].eq {
	pc = 0x829F2ADC; continue 'dispatch;
	}
	// 829F2AA8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F2AAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F2AB0: 419A0084  beq cr6, 0x829f2b34
	if ctx.cr[6].eq {
	pc = 0x829F2B34; continue 'dispatch;
	}
	// 829F2AB4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F2AB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F2ABC: 419A0020  beq cr6, 0x829f2adc
	if ctx.cr[6].eq {
	pc = 0x829F2ADC; continue 'dispatch;
	}
	// 829F2AC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F2AC4: 4B781375  bl 0x82173e38
	ctx.lr = 0x829F2AC8;
	sub_82173E38(ctx, base);
	// 829F2AC8: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 829F2ACC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829F2AD0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F2AD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F2AD8: 409A0008  bne cr6, 0x829f2ae0
	if !ctx.cr[6].eq {
	pc = 0x829F2AE0; continue 'dispatch;
	}
	pc = 0x829F2ADC; continue 'dispatch;
            }
            0x829F2ADC => {
    //   block [0x829F2ADC..0x829F2AE0)
	// 829F2ADC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829F2AE0; continue 'dispatch;
            }
            0x829F2AE0 => {
    //   block [0x829F2AE0..0x829F2B34)
	// 829F2AE0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F2AE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F2AE8: 419A0144  beq cr6, 0x829f2c2c
	if ctx.cr[6].eq {
	pc = 0x829F2C2C; continue 'dispatch;
	}
	// 829F2AEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F2AF0: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 829F2AF4: 4B781345  bl 0x82173e38
	ctx.lr = 0x829F2AF8;
	sub_82173E38(ctx, base);
	// 829F2AF8: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 829F2AFC: 556A57FE  rlwinm r10, r11, 0xa, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x003FFFFFu64;
	// 829F2B00: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F2B04: 419A0100  beq cr6, 0x829f2c04
	if ctx.cr[6].eq {
	pc = 0x829F2C04; continue 'dispatch;
	}
	// 829F2B08: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F2B0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F2B10: 419A0030  beq cr6, 0x829f2b40
	if ctx.cr[6].eq {
	pc = 0x829F2B40; continue 'dispatch;
	}
	// 829F2B14: 894B0016  lbz r10, 0x16(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(22 as u32) ) } as u64;
	// 829F2B18: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F2B1C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 829F2B20: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829F2B24: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F2B28: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F2B2C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F2B30: 480000D8  b 0x829f2c08
	pc = 0x829F2C08; continue 'dispatch;
            }
            0x829F2B34 => {
    //   block [0x829F2B34..0x829F2B40)
	// 829F2B34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F2B38: 4B7A1301  bl 0x82193e38
	ctx.lr = 0x829F2B3C;
	sub_82193E38(ctx, base);
	// 829F2B3C: 4BFFFFA0  b 0x829f2adc
	pc = 0x829F2ADC; continue 'dispatch;
            }
            0x829F2B40 => {
    //   block [0x829F2B40..0x829F2B5C)
	// 829F2B40: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F2B44: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 829F2B48: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 829F2B4C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829F2B50: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829F2B54: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F2B58: 40810054  ble 0x829f2bac
	if !ctx.cr[0].gt {
	pc = 0x829F2BAC; continue 'dispatch;
	}
	pc = 0x829F2B5C; continue 'dispatch;
            }
            0x829F2B5C => {
    //   block [0x829F2B5C..0x829F2B7C)
	// 829F2B5C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829F2B60: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F2B64: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829F2B68: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F2B6C: 2F070016  cmpwi cr6, r7, 0x16
	ctx.cr[6].compare_i32(ctx.r[7].s32, 22, &mut ctx.xer);
	// 829F2B70: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829F2B74: 41980008  blt cr6, 0x829f2b7c
	if ctx.cr[6].lt {
	pc = 0x829F2B7C; continue 'dispatch;
	}
	// 829F2B78: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x829F2B7C; continue 'dispatch;
            }
            0x829F2B7C => {
    //   block [0x829F2B7C..0x829F2B98)
	// 829F2B7C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829F2B80: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829F2B84: 419A0014  beq cr6, 0x829f2b98
	if ctx.cr[6].eq {
	pc = 0x829F2B98; continue 'dispatch;
	}
	// 829F2B88: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829F2B8C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F2B90: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F2B94: 4800000C  b 0x829f2ba0
	pc = 0x829F2BA0; continue 'dispatch;
            }
            0x829F2B98 => {
    //   block [0x829F2B98..0x829F2BA0)
	// 829F2B98: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829F2B9C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829F2BA0; continue 'dispatch;
            }
            0x829F2BA0 => {
    //   block [0x829F2BA0..0x829F2BAC)
	// 829F2BA0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F2BA4: 4199FFB8  bgt cr6, 0x829f2b5c
	if ctx.cr[6].gt {
	pc = 0x829F2B5C; continue 'dispatch;
	}
	// 829F2BA8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x829F2BAC; continue 'dispatch;
            }
            0x829F2BAC => {
    //   block [0x829F2BAC..0x829F2BC8)
	// 829F2BAC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829F2BB0: 419A0040  beq cr6, 0x829f2bf0
	if ctx.cr[6].eq {
	pc = 0x829F2BF0; continue 'dispatch;
	}
	// 829F2BB4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F2BB8: 2F0B0016  cmpwi cr6, r11, 0x16
	ctx.cr[6].compare_i32(ctx.r[11].s32, 22, &mut ctx.xer);
	// 829F2BBC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F2BC0: 41990008  bgt cr6, 0x829f2bc8
	if ctx.cr[6].gt {
	pc = 0x829F2BC8; continue 'dispatch;
	}
	// 829F2BC4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829F2BC8; continue 'dispatch;
            }
            0x829F2BC8 => {
    //   block [0x829F2BC8..0x829F2BF0)
	// 829F2BC8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F2BCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F2BD0: 409A0020  bne cr6, 0x829f2bf0
	if !ctx.cr[6].eq {
	pc = 0x829F2BF0; continue 'dispatch;
	}
	// 829F2BD4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829F2BD8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829F2BDC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F2BE0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F2BE4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F2BE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F2BEC: 4800001C  b 0x829f2c08
	pc = 0x829F2C08; continue 'dispatch;
            }
            0x829F2BF0 => {
    //   block [0x829F2BF0..0x829F2C04)
	// 829F2BF0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829F2BF4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F2BF8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F2BFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F2C00: 48000008  b 0x829f2c08
	pc = 0x829F2C08; continue 'dispatch;
            }
            0x829F2C04 => {
    //   block [0x829F2C04..0x829F2C08)
	// 829F2C04: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829F2C08; continue 'dispatch;
            }
            0x829F2C08 => {
    //   block [0x829F2C08..0x829F2C2C)
	// 829F2C08: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F2C0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F2C10: 419A0140  beq cr6, 0x829f2d50
	if ctx.cr[6].eq {
	pc = 0x829F2D50; continue 'dispatch;
	}
	// 829F2C14: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829F2C18: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829F2C1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F2C20: 4BBF9BC1  bl 0x825ec7e0
	ctx.lr = 0x829F2C24;
	sub_825EC7E0(ctx, base);
	// 829F2C24: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829F2C28: 482B6830  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x829F2C2C => {
    //   block [0x829F2C2C..0x829F2C74)
	// 829F2C2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F2C30: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 829F2C34: 4B781835  bl 0x82174468
	ctx.lr = 0x829F2C38;
	sub_82174468(ctx, base);
	// 829F2C38: 89630024  lbz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 829F2C3C: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 829F2C40: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F2C44: 419A00F0  beq cr6, 0x829f2d34
	if ctx.cr[6].eq {
	pc = 0x829F2D34; continue 'dispatch;
	}
	// 829F2C48: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F2C4C: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F2C50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F2C54: 419A0020  beq cr6, 0x829f2c74
	if ctx.cr[6].eq {
	pc = 0x829F2C74; continue 'dispatch;
	}
	// 829F2C58: 896B0018  lbz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 829F2C5C: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 829F2C60: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829F2C64: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F2C68: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F2C6C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F2C70: 480000C8  b 0x829f2d38
	pc = 0x829F2D38; continue 'dispatch;
            }
            0x829F2C74 => {
    //   block [0x829F2C74..0x829F2C8C)
	// 829F2C74: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 829F2C78: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 829F2C7C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829F2C80: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829F2C84: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F2C88: 40810054  ble 0x829f2cdc
	if !ctx.cr[0].gt {
	pc = 0x829F2CDC; continue 'dispatch;
	}
	pc = 0x829F2C8C; continue 'dispatch;
            }
            0x829F2C8C => {
    //   block [0x829F2C8C..0x829F2CAC)
	// 829F2C8C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829F2C90: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F2C94: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829F2C98: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F2C9C: 2F070018  cmpwi cr6, r7, 0x18
	ctx.cr[6].compare_i32(ctx.r[7].s32, 24, &mut ctx.xer);
	// 829F2CA0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829F2CA4: 41980008  blt cr6, 0x829f2cac
	if ctx.cr[6].lt {
	pc = 0x829F2CAC; continue 'dispatch;
	}
	// 829F2CA8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x829F2CAC; continue 'dispatch;
            }
            0x829F2CAC => {
    //   block [0x829F2CAC..0x829F2CC8)
	// 829F2CAC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829F2CB0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829F2CB4: 419A0014  beq cr6, 0x829f2cc8
	if ctx.cr[6].eq {
	pc = 0x829F2CC8; continue 'dispatch;
	}
	// 829F2CB8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829F2CBC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F2CC0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F2CC4: 4800000C  b 0x829f2cd0
	pc = 0x829F2CD0; continue 'dispatch;
            }
            0x829F2CC8 => {
    //   block [0x829F2CC8..0x829F2CD0)
	// 829F2CC8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829F2CCC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829F2CD0; continue 'dispatch;
            }
            0x829F2CD0 => {
    //   block [0x829F2CD0..0x829F2CDC)
	// 829F2CD0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F2CD4: 4199FFB8  bgt cr6, 0x829f2c8c
	if ctx.cr[6].gt {
	pc = 0x829F2C8C; continue 'dispatch;
	}
	// 829F2CD8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x829F2CDC; continue 'dispatch;
            }
            0x829F2CDC => {
    //   block [0x829F2CDC..0x829F2CF8)
	// 829F2CDC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829F2CE0: 419A0040  beq cr6, 0x829f2d20
	if ctx.cr[6].eq {
	pc = 0x829F2D20; continue 'dispatch;
	}
	// 829F2CE4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F2CE8: 2F0B0018  cmpwi cr6, r11, 0x18
	ctx.cr[6].compare_i32(ctx.r[11].s32, 24, &mut ctx.xer);
	// 829F2CEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F2CF0: 41990008  bgt cr6, 0x829f2cf8
	if ctx.cr[6].gt {
	pc = 0x829F2CF8; continue 'dispatch;
	}
	// 829F2CF4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829F2CF8; continue 'dispatch;
            }
            0x829F2CF8 => {
    //   block [0x829F2CF8..0x829F2D20)
	// 829F2CF8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F2CFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F2D00: 409A0020  bne cr6, 0x829f2d20
	if !ctx.cr[6].eq {
	pc = 0x829F2D20; continue 'dispatch;
	}
	// 829F2D04: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829F2D08: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829F2D0C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F2D10: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F2D14: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F2D18: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F2D1C: 4800001C  b 0x829f2d38
	pc = 0x829F2D38; continue 'dispatch;
            }
            0x829F2D20 => {
    //   block [0x829F2D20..0x829F2D34)
	// 829F2D20: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829F2D24: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F2D28: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F2D2C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F2D30: 48000008  b 0x829f2d38
	pc = 0x829F2D38; continue 'dispatch;
            }
            0x829F2D34 => {
    //   block [0x829F2D34..0x829F2D38)
	// 829F2D34: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829F2D38; continue 'dispatch;
            }
            0x829F2D38 => {
    //   block [0x829F2D38..0x829F2D50)
	// 829F2D38: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F2D3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F2D40: 419A0010  beq cr6, 0x829f2d50
	if ctx.cr[6].eq {
	pc = 0x829F2D50; continue 'dispatch;
	}
	// 829F2D44: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829F2D48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F2D4C: 4BB0AD4D  bl 0x824fda98
	ctx.lr = 0x829F2D50;
	sub_824FDA98(ctx, base);
	pc = 0x829F2D50; continue 'dispatch;
            }
            0x829F2D50 => {
    //   block [0x829F2D50..0x829F2D58)
	// 829F2D50: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829F2D54: 482B6704  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F2D58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F2D58 size=924
    let mut pc: u32 = 0x829F2D58;
    'dispatch: loop {
        match pc {
            0x829F2D58 => {
    //   block [0x829F2D58..0x829F2D94)
	// 829F2D58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F2D5C: 482B66AD  bl 0x82ca9408
	ctx.lr = 0x829F2D60;
	sub_82CA93D0(ctx, base);
	// 829F2D60: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F2D64: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F2D68: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829F2D6C: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 829F2D70: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829F2D74: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F2D78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F2D7C: 419A001C  beq cr6, 0x829f2d98
	if ctx.cr[6].eq {
	pc = 0x829F2D98; continue 'dispatch;
	}
	// 829F2D80: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F2D84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F2D88: 419A000C  beq cr6, 0x829f2d94
	if ctx.cr[6].eq {
	pc = 0x829F2D94; continue 'dispatch;
	}
	// 829F2D8C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F2D90: 4800000C  b 0x829f2d9c
	pc = 0x829F2D9C; continue 'dispatch;
            }
            0x829F2D94 => {
    //   block [0x829F2D94..0x829F2D98)
	// 829F2D94: 4B7A10A5  bl 0x82193e38
	ctx.lr = 0x829F2D98;
	sub_82193E38(ctx, base);
	pc = 0x829F2D98; continue 'dispatch;
            }
            0x829F2D98 => {
    //   block [0x829F2D98..0x829F2D9C)
	// 829F2D98: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829F2D9C; continue 'dispatch;
            }
            0x829F2D9C => {
    //   block [0x829F2D9C..0x829F2DF8)
	// 829F2D9C: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829F2DA0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F2DA4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F2DA8: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 829F2DAC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829F2DB0: 4E800421  bctrl
	ctx.lr = 0x829F2DB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829F2DB4: 817E0094  lwz r11, 0x94(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) } as u64;
	// 829F2DB8: 3BFE0090  addi r31, r30, 0x90
	ctx.r[31].s64 = ctx.r[30].s64 + 144;
	// 829F2DBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F2DC0: 419A0038  beq cr6, 0x829f2df8
	if ctx.cr[6].eq {
	pc = 0x829F2DF8; continue 'dispatch;
	}
	// 829F2DC4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F2DC8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F2DCC: 419A00B8  beq cr6, 0x829f2e84
	if ctx.cr[6].eq {
	pc = 0x829F2E84; continue 'dispatch;
	}
	// 829F2DD0: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F2DD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F2DD8: 419A0020  beq cr6, 0x829f2df8
	if ctx.cr[6].eq {
	pc = 0x829F2DF8; continue 'dispatch;
	}
	// 829F2DDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F2DE0: 4B781059  bl 0x82173e38
	ctx.lr = 0x829F2DE4;
	sub_82173E38(ctx, base);
	// 829F2DE4: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 829F2DE8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829F2DEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F2DF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F2DF4: 409A0008  bne cr6, 0x829f2dfc
	if !ctx.cr[6].eq {
	pc = 0x829F2DFC; continue 'dispatch;
	}
            }
            0x829F2DF8 => {
    //   block [0x829F2DF8..0x829F2DFC)
	// 829F2DF8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829F2DFC; continue 'dispatch;
            }
            0x829F2DFC => {
    //   block [0x829F2DFC..0x829F2E84)
	// 829F2DFC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F2E00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F2E04: 419A0190  beq cr6, 0x829f2f94
	if ctx.cr[6].eq {
	pc = 0x829F2F94; continue 'dispatch;
	}
	// 829F2E08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F2E0C: 4B78102D  bl 0x82173e38
	ctx.lr = 0x829F2E10;
	sub_82173E38(ctx, base);
	// 829F2E10: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829F2E14: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829F2E18: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829F2E1C: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F2E20: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 829F2E24: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 829F2E28: 4E800421  bctrl
	ctx.lr = 0x829F2E2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829F2E2C: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 829F2E30: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 829F2E34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F2E38: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
            }
            0x829F2E84 => {
    //   block [0x829F2E84..0x829F2F94)
	// 829F2E84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F2E88: 4B7A0FB1  bl 0x82193e38
	ctx.lr = 0x829F2E8C;
	sub_82193E38(ctx, base);
	// 829F2E8C: 4BFFFF6C  b 0x829f2df8
	pc = 0x829F2DF8; continue 'dispatch;
	// 829F2E90: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F2E94: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 829F2E98: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 829F2E9C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829F2EA0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829F2EA4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F2EA8: 40810054  ble 0x829f2efc
	if !ctx.cr[0].gt {
	pc = 0x829F2EFC; continue 'dispatch;
	}
	// 829F2EAC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829F2EB0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F2EB4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829F2EB8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F2EBC: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 829F2EC0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829F2EC4: 41980008  blt cr6, 0x829f2ecc
	if ctx.cr[6].lt {
	pc = 0x829F2ECC; continue 'dispatch;
	}
	// 829F2EC8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 829F2ECC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829F2ED0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829F2ED4: 419A0014  beq cr6, 0x829f2ee8
	if ctx.cr[6].eq {
	pc = 0x829F2EE8; continue 'dispatch;
	}
	// 829F2ED8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829F2EDC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F2EE0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F2EE4: 4800000C  b 0x829f2ef0
	pc = 0x829F2EF0; continue 'dispatch;
	// 829F2EE8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829F2EEC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 829F2EF0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F2EF4: 4199FFB8  bgt cr6, 0x829f2eac
	if ctx.cr[6].gt {
	pc = 0x829F2EAC; continue 'dispatch;
	}
	// 829F2EF8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829F2EFC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829F2F00: 419A0040  beq cr6, 0x829f2f40
	if ctx.cr[6].eq {
	pc = 0x829F2F40; continue 'dispatch;
	}
	// 829F2F04: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F2F08: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 829F2F0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F2F10: 41990008  bgt cr6, 0x829f2f18
	if ctx.cr[6].gt {
	pc = 0x829F2F18; continue 'dispatch;
	}
	// 829F2F14: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 829F2F18: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F2F1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F2F20: 409A0020  bne cr6, 0x829f2f40
	if !ctx.cr[6].eq {
	pc = 0x829F2F40; continue 'dispatch;
	}
	// 829F2F24: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829F2F28: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829F2F2C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F2F30: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F2F34: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F2F38: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F2F3C: 4800001C  b 0x829f2f58
	pc = 0x829F2F58; continue 'dispatch;
	// 829F2F40: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829F2F44: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F2F48: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F2F4C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F2F50: 48000008  b 0x829f2f58
	pc = 0x829F2F58; continue 'dispatch;
	// 829F2F54: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 829F2F58: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F2F5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F2F60: 419A017C  beq cr6, 0x829f30dc
	if ctx.cr[6].eq {
	pc = 0x829F30DC; continue 'dispatch;
	}
	// 829F2F64: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829F2F68: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829F2F6C: 38ABB7DC  addi r5, r11, -0x4824
	ctx.r[5].s64 = ctx.r[11].s64 + -18468;
	// 829F2F70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F2F74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F2F78: 4BB81489  bl 0x82574400
	ctx.lr = 0x829F2F7C;
	sub_82574400(ctx, base);
	// 829F2F7C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 829F2F80: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
            }
            0x829F2F94 => {
    //   block [0x829F2F94..0x829F30F4)
	// 829F2F94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F2F98: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 829F2F9C: 4B7814CD  bl 0x82174468
	ctx.lr = 0x829F2FA0;
	sub_82174468(ctx, base);
	// 829F2FA0: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 829F2FA4: 556AEFFE  rlwinm r10, r11, 0x1d, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 829F2FA8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F2FAC: 419A00F4  beq cr6, 0x829f30a0
	if ctx.cr[6].eq {
	pc = 0x829F30A0; continue 'dispatch;
	}
	// 829F2FB0: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F2FB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F2FB8: 419A0024  beq cr6, 0x829f2fdc
	if ctx.cr[6].eq {
	pc = 0x829F2FDC; continue 'dispatch;
	}
	// 829F2FBC: 894B0003  lbz r10, 3(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 829F2FC0: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F2FC4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 829F2FC8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829F2FCC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F2FD0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F2FD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F2FD8: 480000CC  b 0x829f30a4
	pc = 0x829F30A4; continue 'dispatch;
	// 829F2FDC: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F2FE0: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 829F2FE4: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 829F2FE8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829F2FEC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829F2FF0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F2FF4: 40810054  ble 0x829f3048
	if !ctx.cr[0].gt {
	pc = 0x829F3048; continue 'dispatch;
	}
	// 829F2FF8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829F2FFC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F3000: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829F3004: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F3008: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 829F300C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829F3010: 41980008  blt cr6, 0x829f3018
	if ctx.cr[6].lt {
	pc = 0x829F3018; continue 'dispatch;
	}
	// 829F3014: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 829F3018: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829F301C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829F3020: 419A0014  beq cr6, 0x829f3034
	if ctx.cr[6].eq {
	pc = 0x829F3034; continue 'dispatch;
	}
	// 829F3024: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829F3028: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F302C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F3030: 4800000C  b 0x829f303c
	pc = 0x829F303C; continue 'dispatch;
	// 829F3034: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829F3038: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 829F303C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F3040: 4199FFB8  bgt cr6, 0x829f2ff8
	if ctx.cr[6].gt {
	pc = 0x829F2FF8; continue 'dispatch;
	}
	// 829F3044: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829F3048: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829F304C: 419A0040  beq cr6, 0x829f308c
	if ctx.cr[6].eq {
	pc = 0x829F308C; continue 'dispatch;
	}
	// 829F3050: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F3054: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 829F3058: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F305C: 41990008  bgt cr6, 0x829f3064
	if ctx.cr[6].gt {
	pc = 0x829F3064; continue 'dispatch;
	}
	// 829F3060: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 829F3064: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F3068: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F306C: 409A0020  bne cr6, 0x829f308c
	if !ctx.cr[6].eq {
	pc = 0x829F308C; continue 'dispatch;
	}
	// 829F3070: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829F3074: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829F3078: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F307C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F3080: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F3084: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F3088: 4800001C  b 0x829f30a4
	pc = 0x829F30A4; continue 'dispatch;
	// 829F308C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829F3090: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F3094: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F3098: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F309C: 48000008  b 0x829f30a4
	pc = 0x829F30A4; continue 'dispatch;
	// 829F30A0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 829F30A4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F30A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F30AC: 419A0030  beq cr6, 0x829f30dc
	if ctx.cr[6].eq {
	pc = 0x829F30DC; continue 'dispatch;
	}
	// 829F30B0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829F30B4: 38BE0084  addi r5, r30, 0x84
	ctx.r[5].s64 = ctx.r[30].s64 + 132;
	// 829F30B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F30BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F30C0: 4BB81341  bl 0x82574400
	ctx.lr = 0x829F30C4;
	sub_82574400(ctx, base);
	// 829F30C4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829F30C8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F30F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829F30F8 size=20
    let mut pc: u32 = 0x829F30F8;
    'dispatch: loop {
        match pc {
            0x829F30F8 => {
    //   block [0x829F30F8..0x829F310C)
	// 829F30F8: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F30FC: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 829F3100: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 829F3104: 3863FF88  addi r3, r3, -0x78
	ctx.r[3].s64 = ctx.r[3].s64 + -120;
	// 829F3108: 4B8930A0  b 0x822861a8
	sub_822861A8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F3110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F3110 size=252
    let mut pc: u32 = 0x829F3110;
    'dispatch: loop {
        match pc {
            0x829F3110 => {
    //   block [0x829F3110..0x829F320C)
	// 829F3110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F3114: 482B62F5  bl 0x82ca9408
	ctx.lr = 0x829F3118;
	sub_82CA93D0(ctx, base);
	// 829F3118: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 829F311C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F3120: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F3124: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F3128: 4BFFECA1  bl 0x829f1dc8
	ctx.lr = 0x829F312C;
	sub_829F1DC8(ctx, base);
	// 829F312C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F3130: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 829F3134: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 829F3138: 390B1770  addi r8, r11, 0x1770
	ctx.r[8].s64 = ctx.r[11].s64 + 6000;
	// 829F313C: 38EA17C0  addi r7, r10, 0x17c0
	ctx.r[7].s64 = ctx.r[10].s64 + 6080;
	// 829F3140: 38C90B7C  addi r6, r9, 0xb7c
	ctx.r[6].s64 = ctx.r[9].s64 + 2940;
	// 829F3144: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 829F3148: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829F314C: 90FF0078  stw r7, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[7].u32 ) };
	// 829F3150: 90DF00A4  stw r6, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[6].u32 ) };
	// 829F3154: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 829F3158: 90BF00A8  stw r5, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[5].u32 ) };
	// 829F315C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 829F3160: 38A40CA0  addi r5, r4, 0xca0
	ctx.r[5].s64 = ctx.r[4].s64 + 3232;
	// 829F3164: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F3168: 388B8048  addi r4, r11, -0x7fb8
	ctx.r[4].s64 = ctx.r[11].s64 + -32696;
	// 829F316C: 4B915E55  bl 0x82308fc0
	ctx.lr = 0x829F3170;
	sub_82308FC0(ctx, base);
	// 829F3170: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F3174: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F3178: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829F317C: 4B839D55  bl 0x8222ced0
	ctx.lr = 0x829F3180;
	sub_8222CED0(ctx, base);
	// 829F3180: 387F00AC  addi r3, r31, 0xac
	ctx.r[3].s64 = ctx.r[31].s64 + 172;
	// 829F3184: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829F3188: 4B7A9461  bl 0x8219c5e8
	ctx.lr = 0x829F318C;
	sub_8219C5E8(ctx, base);
	// 829F318C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F3190: 4B821C49  bl 0x82214dd8
	ctx.lr = 0x829F3194;
	sub_82214DD8(ctx, base);
	// 829F3194: 3FA0820A  lis r29, -0x7df6
	ctx.r[29].s64 = -2113273856;
	// 829F3198: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 829F319C: 3B9D9490  addi r28, r29, -0x6b70
	ctx.r[28].s64 = ctx.r[29].s64 + -27504;
	// 829F31A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F31A4: 388A1590  addi r4, r10, 0x1590
	ctx.r[4].s64 = ctx.r[10].s64 + 5520;
	// 829F31A8: C03CFE14  lfs f1, -0x1ec(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-492 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829F31AC: 4B7EC2AD  bl 0x821df458
	ctx.lr = 0x829F31B0;
	sub_821DF458(ctx, base);
	// 829F31B0: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 829F31B4: C3FCFFF4  lfs f31, -0xc(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829F31B8: D3FF00B8  stfs f31, 0xb8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 829F31BC: 3D00820F  lis r8, -0x7df1
	ctx.r[8].s64 = -2112946176;
	// 829F31C0: C1BD9490  lfs f13, -0x6b70(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829F31C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F31C8: 3888159C  addi r4, r8, 0x159c
	ctx.r[4].s64 = ctx.r[8].s64 + 5532;
	// 829F31CC: C0090ED4  lfs f0, 0xed4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3796 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F31D0: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 829F31D4: D01F00B4  stfs f0, 0xb4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 829F31D8: FC206890  fmr f1, f13
	ctx.f[1].f64 = ctx.f[13].f64;
	// 829F31DC: 4B7EC27D  bl 0x821df458
	ctx.lr = 0x829F31E0;
	sub_821DF458(ctx, base);
	// 829F31E0: D03F00BC  stfs f1, 0xbc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 829F31E4: 3CE0820F  lis r7, -0x7df1
	ctx.r[7].s64 = -2112946176;
	// 829F31E8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829F31EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F31F0: 388715AC  addi r4, r7, 0x15ac
	ctx.r[4].s64 = ctx.r[7].s64 + 5548;
	// 829F31F4: 4B7EC265  bl 0x821df458
	ctx.lr = 0x829F31F8;
	sub_821DF458(ctx, base);
	// 829F31F8: D03F00C0  stfs f1, 0xc0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 829F31FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F3200: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829F3204: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 829F3208: 482B6250  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F3210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829F3210 size=1000
    let mut pc: u32 = 0x829F3210;
    'dispatch: loop {
        match pc {
            0x829F3210 => {
    //   block [0x829F3210..0x829F35F8)
	// 829F3210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F3214: 482B61F5  bl 0x82ca9408
	ctx.lr = 0x829F3218;
	sub_82CA93D0(ctx, base);
	// 829F3218: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 829F321C: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 829F3220: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F35F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F35F8 size=528
    let mut pc: u32 = 0x829F35F8;
    'dispatch: loop {
        match pc {
            0x829F35F8 => {
    //   block [0x829F35F8..0x829F3650)
	// 829F35F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F35FC: 482B5E11  bl 0x82ca940c
	ctx.lr = 0x829F3600;
	sub_82CA93D0(ctx, base);
	// 829F3600: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 829F3604: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F3608: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F360C: 3BFE00A4  addi r31, r30, 0xa4
	ctx.r[31].s64 = ctx.r[30].s64 + 164;
	// 829F3610: 817E00A8  lwz r11, 0xa8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(168 as u32) ) } as u64;
	// 829F3614: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F3618: 419A0038  beq cr6, 0x829f3650
	if ctx.cr[6].eq {
	pc = 0x829F3650; continue 'dispatch;
	}
	// 829F361C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F3620: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F3624: 419A009C  beq cr6, 0x829f36c0
	if ctx.cr[6].eq {
	pc = 0x829F36C0; continue 'dispatch;
	}
	// 829F3628: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F362C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F3630: 419A0020  beq cr6, 0x829f3650
	if ctx.cr[6].eq {
	pc = 0x829F3650; continue 'dispatch;
	}
	// 829F3634: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F3638: 4B780801  bl 0x82173e38
	ctx.lr = 0x829F363C;
	sub_82173E38(ctx, base);
	// 829F363C: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 829F3640: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829F3644: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F3648: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F364C: 409A0008  bne cr6, 0x829f3654
	if !ctx.cr[6].eq {
	pc = 0x829F3654; continue 'dispatch;
	}
	pc = 0x829F3650; continue 'dispatch;
            }
            0x829F3650 => {
    //   block [0x829F3650..0x829F3654)
	// 829F3650: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829F3654; continue 'dispatch;
            }
            0x829F3654 => {
    //   block [0x829F3654..0x829F36C0)
	// 829F3654: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F3658: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F365C: 419A01A0  beq cr6, 0x829f37fc
	if ctx.cr[6].eq {
	pc = 0x829F37FC; continue 'dispatch;
	}
	// 829F3660: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F3664: C01E00B8  lfs f0, 0xb8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F3668: 3BAB9490  addi r29, r11, -0x6b70
	ctx.r[29].s64 = ctx.r[11].s64 + -27504;
	// 829F366C: C3FDFFF4  lfs f31, -0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829F3670: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 829F3674: 40990188  ble cr6, 0x829f37fc
	if !ctx.cr[6].gt {
	pc = 0x829F37FC; continue 'dispatch;
	}
	// 829F3678: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F367C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829F3680: 4B7807B9  bl 0x82173e38
	ctx.lr = 0x829F3684;
	sub_82173E38(ctx, base);
	// 829F3684: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 829F3688: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 829F368C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F3690: 419A0104  beq cr6, 0x829f3794
	if ctx.cr[6].eq {
	pc = 0x829F3794; continue 'dispatch;
	}
	// 829F3694: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F3698: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F369C: 419A0030  beq cr6, 0x829f36cc
	if ctx.cr[6].eq {
	pc = 0x829F36CC; continue 'dispatch;
	}
	// 829F36A0: 894B0055  lbz r10, 0x55(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(85 as u32) ) } as u64;
	// 829F36A4: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F36A8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 829F36AC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829F36B0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F36B4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F36B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F36BC: 480000DC  b 0x829f3798
	pc = 0x829F3798; continue 'dispatch;
            }
            0x829F36C0 => {
    //   block [0x829F36C0..0x829F36CC)
	// 829F36C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F36C4: 4B7A0775  bl 0x82193e38
	ctx.lr = 0x829F36C8;
	sub_82193E38(ctx, base);
	// 829F36C8: 4BFFFF88  b 0x829f3650
	pc = 0x829F3650; continue 'dispatch;
            }
            0x829F36CC => {
    //   block [0x829F36CC..0x829F36EC)
	// 829F36CC: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F36D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829F36D4: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 829F36D8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829F36DC: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829F36E0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829F36E4: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F36E8: 40810054  ble 0x829f373c
	if !ctx.cr[0].gt {
	pc = 0x829F373C; continue 'dispatch;
	}
	pc = 0x829F36EC; continue 'dispatch;
            }
            0x829F36EC => {
    //   block [0x829F36EC..0x829F370C)
	// 829F36EC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829F36F0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F36F4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829F36F8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F36FC: 2F070055  cmpwi cr6, r7, 0x55
	ctx.cr[6].compare_i32(ctx.r[7].s32, 85, &mut ctx.xer);
	// 829F3700: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829F3704: 41980008  blt cr6, 0x829f370c
	if ctx.cr[6].lt {
	pc = 0x829F370C; continue 'dispatch;
	}
	// 829F3708: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x829F370C; continue 'dispatch;
            }
            0x829F370C => {
    //   block [0x829F370C..0x829F3728)
	// 829F370C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829F3710: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829F3714: 419A0014  beq cr6, 0x829f3728
	if ctx.cr[6].eq {
	pc = 0x829F3728; continue 'dispatch;
	}
	// 829F3718: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829F371C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F3720: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F3724: 4800000C  b 0x829f3730
	pc = 0x829F3730; continue 'dispatch;
            }
            0x829F3728 => {
    //   block [0x829F3728..0x829F3730)
	// 829F3728: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829F372C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829F3730; continue 'dispatch;
            }
            0x829F3730 => {
    //   block [0x829F3730..0x829F373C)
	// 829F3730: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F3734: 4199FFB8  bgt cr6, 0x829f36ec
	if ctx.cr[6].gt {
	pc = 0x829F36EC; continue 'dispatch;
	}
	// 829F3738: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x829F373C; continue 'dispatch;
            }
            0x829F373C => {
    //   block [0x829F373C..0x829F3758)
	// 829F373C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829F3740: 419A0040  beq cr6, 0x829f3780
	if ctx.cr[6].eq {
	pc = 0x829F3780; continue 'dispatch;
	}
	// 829F3744: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F3748: 2F0B0055  cmpwi cr6, r11, 0x55
	ctx.cr[6].compare_i32(ctx.r[11].s32, 85, &mut ctx.xer);
	// 829F374C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F3750: 41990008  bgt cr6, 0x829f3758
	if ctx.cr[6].gt {
	pc = 0x829F3758; continue 'dispatch;
	}
	// 829F3754: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829F3758; continue 'dispatch;
            }
            0x829F3758 => {
    //   block [0x829F3758..0x829F3780)
	// 829F3758: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F375C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F3760: 409A0020  bne cr6, 0x829f3780
	if !ctx.cr[6].eq {
	pc = 0x829F3780; continue 'dispatch;
	}
	// 829F3764: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829F3768: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829F376C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F3770: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F3774: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F3778: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F377C: 4800001C  b 0x829f3798
	pc = 0x829F3798; continue 'dispatch;
            }
            0x829F3780 => {
    //   block [0x829F3780..0x829F3794)
	// 829F3780: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829F3784: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F3788: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F378C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F3790: 48000008  b 0x829f3798
	pc = 0x829F3798; continue 'dispatch;
            }
            0x829F3794 => {
    //   block [0x829F3794..0x829F3798)
	// 829F3794: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829F3798; continue 'dispatch;
            }
            0x829F3798 => {
    //   block [0x829F3798..0x829F37FC)
	// 829F3798: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F379C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F37A0: 419A005C  beq cr6, 0x829f37fc
	if ctx.cr[6].eq {
	pc = 0x829F37FC; continue 'dispatch;
	}
	// 829F37A4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F37A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F37AC: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 829F37B0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829F37B4: 4E800421  bctrl
	ctx.lr = 0x829F37B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829F37B8: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 829F37BC: C01E00B8  lfs f0, 0xb8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F37C0: EDA10024  fdivs f13, f1, f0
	ctx.f[13].f64 = ((ctx.f[1].f64 / ctx.f[0].f64) as f32) as f64;
	// 829F37C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F37C8: 419A0034  beq cr6, 0x829f37fc
	if ctx.cr[6].eq {
	pc = 0x829F37FC; continue 'dispatch;
	}
	// 829F37CC: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F37D0: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 829F37D4: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829F37D8: 394B0E68  addi r10, r11, 0xe68
	ctx.r[10].s64 = ctx.r[11].s64 + 3688;
	// 829F37DC: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 829F37E0: 7D200026  mfcr r9
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[9].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[9].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 829F37E4: 5528DF7A  rlwinm r8, r9, 0x1b, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 829F37E8: 5527F77A  rlwinm r7, r9, 0x1e, 0x1d, 0x1d
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 829F37EC: 7D063B78  or r6, r8, r7
	ctx.r[6].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 829F37F0: 7D6A342E  lfsx f11, r10, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829F37F4: FC2B036E  fsel f1, f11, f13, f0
	ctx.f[1].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 829F37F8: 4883EBE9  bl 0x832323e0
	ctx.lr = 0x829F37FC;
	sub_832323E0(ctx, base);
            }
            0x829F37FC => {
    //   block [0x829F37FC..0x829F3808)
	// 829F37FC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829F3800: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 829F3804: 482B5C58  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F3808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829F3808 size=1724
    let mut pc: u32 = 0x829F3808;
    'dispatch: loop {
        match pc {
            0x829F3808 => {
    //   block [0x829F3808..0x829F3EC4)
	// 829F3808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F380C: 482B5BF5  bl 0x82ca9400
	ctx.lr = 0x829F3810;
	sub_82CA93D0(ctx, base);
	// 829F3810: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 829F3814: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F3EC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F3EC8 size=152
    let mut pc: u32 = 0x829F3EC8;
    'dispatch: loop {
        match pc {
            0x829F3EC8 => {
    //   block [0x829F3EC8..0x829F3F24)
	// 829F3EC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F3ECC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F3ED0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F3ED4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F3ED8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F3EDC: 4BFFE5F5  bl 0x829f24d0
	ctx.lr = 0x829F3EE0;
	sub_829F24D0(ctx, base);
	// 829F3EE0: 3BFF00A4  addi r31, r31, 0xa4
	ctx.r[31].s64 = ctx.r[31].s64 + 164;
	// 829F3EE4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F3EE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F3EEC: 419A0038  beq cr6, 0x829f3f24
	if ctx.cr[6].eq {
	pc = 0x829F3F24; continue 'dispatch;
	}
	// 829F3EF0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F3EF4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F3EF8: 419A005C  beq cr6, 0x829f3f54
	if ctx.cr[6].eq {
	pc = 0x829F3F54; continue 'dispatch;
	}
	// 829F3EFC: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F3F00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F3F04: 419A0020  beq cr6, 0x829f3f24
	if ctx.cr[6].eq {
	pc = 0x829F3F24; continue 'dispatch;
	}
	// 829F3F08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F3F0C: 4B77FF2D  bl 0x82173e38
	ctx.lr = 0x829F3F10;
	sub_82173E38(ctx, base);
	// 829F3F10: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 829F3F14: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829F3F18: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F3F1C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F3F20: 409A0008  bne cr6, 0x829f3f28
	if !ctx.cr[6].eq {
	pc = 0x829F3F28; continue 'dispatch;
	}
	pc = 0x829F3F24; continue 'dispatch;
            }
            0x829F3F24 => {
    //   block [0x829F3F24..0x829F3F28)
	// 829F3F24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829F3F28; continue 'dispatch;
            }
            0x829F3F28 => {
    //   block [0x829F3F28..0x829F3F40)
	// 829F3F28: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F3F2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F3F30: 419A0010  beq cr6, 0x829f3f40
	if ctx.cr[6].eq {
	pc = 0x829F3F40; continue 'dispatch;
	}
	// 829F3F34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F3F38: 4B77FF01  bl 0x82173e38
	ctx.lr = 0x829F3F3C;
	sub_82173E38(ctx, base);
	// 829F3F3C: 4B9998ED  bl 0x8238d828
	ctx.lr = 0x829F3F40;
	sub_8238D828(ctx, base);
	pc = 0x829F3F40; continue 'dispatch;
            }
            0x829F3F40 => {
    //   block [0x829F3F40..0x829F3F54)
	// 829F3F40: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829F3F44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F3F48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F3F4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F3F50: 4E800020  blr
	return;
            }
            0x829F3F54 => {
    //   block [0x829F3F54..0x829F3F60)
	// 829F3F54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F3F58: 4B79FEE1  bl 0x82193e38
	ctx.lr = 0x829F3F5C;
	sub_82193E38(ctx, base);
	// 829F3F5C: 4BFFFFC8  b 0x829f3f24
	pc = 0x829F3F24; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F3F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F3F60 size=400
    let mut pc: u32 = 0x829F3F60;
    'dispatch: loop {
        match pc {
            0x829F3F60 => {
    //   block [0x829F3F60..0x829F4048)
	// 829F3F60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F3F64: 482B549D  bl 0x82ca9400
	ctx.lr = 0x829F3F68;
	sub_82CA93D0(ctx, base);
	// 829F3F68: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F3F6C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 829F3F70: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F3F74: 4BFFDE55  bl 0x829f1dc8
	ctx.lr = 0x829F3F78;
	sub_829F1DC8(ctx, base);
	// 829F3F78: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F3F7C: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 829F3F80: 392B17D0  addi r9, r11, 0x17d0
	ctx.r[9].s64 = ctx.r[11].s64 + 6096;
	// 829F3F84: 390A1820  addi r8, r10, 0x1820
	ctx.r[8].s64 = ctx.r[10].s64 + 6176;
	// 829F3F88: 913A0000  stw r9, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829F3F8C: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 829F3F90: 911A0078  stw r8, 0x78(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(120 as u32), ctx.r[8].u32 ) };
	// 829F3F94: 3CC0820F  lis r6, -0x7df1
	ctx.r[6].s64 = -2112946176;
	// 829F3F98: 3BA70CA0  addi r29, r7, 0xca0
	ctx.r[29].s64 = ctx.r[7].s64 + 3232;
	// 829F3F9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F3FA0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829F3FA4: 388615CC  addi r4, r6, 0x15cc
	ctx.r[4].s64 = ctx.r[6].s64 + 5580;
	// 829F3FA8: 4B915019  bl 0x82308fc0
	ctx.lr = 0x829F3FAC;
	sub_82308FC0(ctx, base);
	// 829F3FAC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F3FB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F3FB4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829F3FB8: 4B838F19  bl 0x8222ced0
	ctx.lr = 0x829F3FBC;
	sub_8222CED0(ctx, base);
	// 829F3FBC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829F3FC0: 387A00A4  addi r3, r26, 0xa4
	ctx.r[3].s64 = ctx.r[26].s64 + 164;
	// 829F3FC4: 4B7A8625  bl 0x8219c5e8
	ctx.lr = 0x829F3FC8;
	sub_8219C5E8(ctx, base);
	// 829F3FC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F3FCC: 4B820E0D  bl 0x82214dd8
	ctx.lr = 0x829F3FD0;
	sub_82214DD8(ctx, base);
	// 829F3FD0: 3BFA00AC  addi r31, r26, 0xac
	ctx.r[31].s64 = ctx.r[26].s64 + 172;
	// 829F3FD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F3FD8: 4BE53FD9  bl 0x82847fb0
	ctx.lr = 0x829F3FDC;
	sub_82847FB0(ctx, base);
	// 829F3FDC: 3C80820F  lis r4, -0x7df1
	ctx.r[4].s64 = -2112946176;
	// 829F3FE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F3FE4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829F3FE8: 388415D8  addi r4, r4, 0x15d8
	ctx.r[4].s64 = ctx.r[4].s64 + 5592;
	// 829F3FEC: 4B914FD5  bl 0x82308fc0
	ctx.lr = 0x829F3FF0;
	sub_82308FC0(ctx, base);
	// 829F3FF0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F3FF4: 387A00B8  addi r3, r26, 0xb8
	ctx.r[3].s64 = ctx.r[26].s64 + 184;
	// 829F3FF8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829F3FFC: 4B838ED5  bl 0x8222ced0
	ctx.lr = 0x829F4000;
	sub_8222CED0(ctx, base);
	// 829F4000: 3C60820F  lis r3, -0x7df1
	ctx.r[3].s64 = -2112946176;
	// 829F4004: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F4008: 38A315EC  addi r5, r3, 0x15ec
	ctx.r[5].s64 = ctx.r[3].s64 + 5612;
	// 829F400C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829F4010: 4B9DA101  bl 0x823ce110
	ctx.lr = 0x829F4014;
	sub_823CE110(ctx, base);
	// 829F4014: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829F4018: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F401C: 419A00C0  beq cr6, 0x829f40dc
	if ctx.cr[6].eq {
	pc = 0x829F40DC; continue 'dispatch;
	}
	// 829F4020: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829F4024: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 829F4028: 4BA64399  bl 0x824583c0
	ctx.lr = 0x829F402C;
	sub_824583C0(ctx, base);
	// 829F402C: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 829F4030: 419800AC  blt cr6, 0x829f40dc
	if ctx.cr[6].lt {
	pc = 0x829F40DC; continue 'dispatch;
	}
	// 829F4034: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F4038: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829F403C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829F4040: 3BAB0B7C  addi r29, r11, 0xb7c
	ctx.r[29].s64 = ctx.r[11].s64 + 2940;
	// 829F4044: 3B8A0B7C  addi r28, r10, 0xb7c
	ctx.r[28].s64 = ctx.r[10].s64 + 2940;
	pc = 0x829F4048; continue 'dispatch;
            }
            0x829F4048 => {
    //   block [0x829F4048..0x829F4078)
	// 829F4048: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829F404C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829F4050: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829F4054: 4BA703A5  bl 0x824643f8
	ctx.lr = 0x829F4058;
	sub_824643F8(ctx, base);
	// 829F4058: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F405C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 829F4060: 419A0018  beq cr6, 0x829f4078
	if ctx.cr[6].eq {
	pc = 0x829F4078; continue 'dispatch;
	}
	// 829F4064: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 829F4068: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829F406C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F4070: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F4074: 409A0008  bne cr6, 0x829f407c
	if !ctx.cr[6].eq {
	pc = 0x829F407C; continue 'dispatch;
	}
	pc = 0x829F4078; continue 'dispatch;
            }
            0x829F4078 => {
    //   block [0x829F4078..0x829F407C)
	// 829F4078: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x829F407C; continue 'dispatch;
            }
            0x829F407C => {
    //   block [0x829F407C..0x829F40C8)
	// 829F407C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F4080: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F4084: 419A0044  beq cr6, 0x829f40c8
	if ctx.cr[6].eq {
	pc = 0x829F40C8; continue 'dispatch;
	}
	// 829F4088: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829F408C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F4090: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 829F4094: 4B820805  bl 0x82214898
	ctx.lr = 0x829F4098;
	sub_82214898(ctx, base);
	// 829F4098: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F409C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829F40A0: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 829F40A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F40A8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F40AC: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 829F40B0: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 829F40B4: 4BA62065  bl 0x82456118
	ctx.lr = 0x829F40B8;
	sub_82456118(ctx, base);
	// 829F40B8: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 829F40BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F40C0: 4B79FD79  bl 0x82193e38
	ctx.lr = 0x829F40C4;
	sub_82193E38(ctx, base);
	// 829F40C4: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	pc = 0x829F40C8; continue 'dispatch;
            }
            0x829F40C8 => {
    //   block [0x829F40C8..0x829F40DC)
	// 829F40C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829F40CC: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 829F40D0: 4BA642F1  bl 0x824583c0
	ctx.lr = 0x829F40D4;
	sub_824583C0(ctx, base);
	// 829F40D4: 7F1B1800  cmpw cr6, r27, r3
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[3].s32, &mut ctx.xer);
	// 829F40D8: 4099FF70  ble cr6, 0x829f4048
	if !ctx.cr[6].gt {
	pc = 0x829F4048; continue 'dispatch;
	}
	pc = 0x829F40DC; continue 'dispatch;
            }
            0x829F40DC => {
    //   block [0x829F40DC..0x829F40F0)
	// 829F40DC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829F40E0: 4B7C3A39  bl 0x821b7b18
	ctx.lr = 0x829F40E4;
	sub_821B7B18(ctx, base);
	// 829F40E4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829F40E8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829F40EC: 482B5364  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F40F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F40F0 size=1400
    let mut pc: u32 = 0x829F40F0;
    'dispatch: loop {
        match pc {
            0x829F40F0 => {
    //   block [0x829F40F0..0x829F4120)
	// 829F40F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F40F4: 482B52F5  bl 0x82ca93e8
	ctx.lr = 0x829F40F8;
	sub_82CA93D0(ctx, base);
	// 829F40F8: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F40FC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829F4100: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829F4104: 7F95E378  mr r21, r28
	ctx.r[21].u64 = ctx.r[28].u64;
	// 829F4108: 9381007C  stw r28, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[28].u32 ) };
	// 829F410C: 3A8B7088  addi r20, r11, 0x7088
	ctx.r[20].s64 = ctx.r[11].s64 + 28808;
	// 829F4110: 93810080  stw r28, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[28].u32 ) };
	// 829F4114: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 829F4118: 92A10078  stw r21, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[21].u32 ) };
	// 829F411C: 7E88A378  mr r8, r20
	ctx.r[8].u64 = ctx.r[20].u64;
	pc = 0x829F4120; continue 'dispatch;
            }
            0x829F4120 => {
    //   block [0x829F4120..0x829F4198)
	// 829F4120: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829F4124: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F4128: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829F412C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F4130: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F4134: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F4138: 4082FFE8  bne 0x829f4120
	if !ctx.cr[0].eq {
	pc = 0x829F4120; continue 'dispatch;
	}
	// 829F413C: 817900B8  lwz r11, 0xb8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(184 as u32) ) } as u64;
	// 829F4140: 3BF900B8  addi r31, r25, 0xb8
	ctx.r[31].s64 = ctx.r[25].s64 + 184;
	// 829F4144: 3EC08349  lis r22, -0x7cb7
	ctx.r[22].s64 = -2092367872;
	// 829F4148: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F414C: 419A00E4  beq cr6, 0x829f4230
	if ctx.cr[6].eq {
	pc = 0x829F4230; continue 'dispatch;
	}
	// 829F4150: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F4154: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F4158: 419A00D8  beq cr6, 0x829f4230
	if ctx.cr[6].eq {
	pc = 0x829F4230; continue 'dispatch;
	}
	// 829F415C: 81766AB8  lwz r11, 0x6ab8(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(27320 as u32) ) } as u64;
	// 829F4160: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F4164: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 829F4168: 814B0078  lwz r10, 0x78(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 829F416C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F4170: 80890000  lwz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F4174: 4B9DA44D  bl 0x823ce5c0
	ctx.lr = 0x829F4178;
	sub_823CE5C0(ctx, base);
	// 829F4178: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 829F417C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 829F4180: 3BCBFFDF  addi r30, r11, -0x21
	ctx.r[30].s64 = ctx.r[11].s64 + -33;
	// 829F4184: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829F4188: 8168E434  lwz r11, -0x1bcc(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-7116 as u32) ) } as u64;
	// 829F418C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F4190: 419A0008  beq cr6, 0x829f4198
	if ctx.cr[6].eq {
	pc = 0x829F4198; continue 'dispatch;
	}
	// 829F4194: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829F4198; continue 'dispatch;
            }
            0x829F4198 => {
    //   block [0x829F4198..0x829F41D8)
	// 829F4198: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 829F419C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829F41A0: 4B9D9F71  bl 0x823ce110
	ctx.lr = 0x829F41A4;
	sub_823CE110(ctx, base);
	// 829F41A4: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F41A8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829F41AC: 388B15F4  addi r4, r11, 0x15f4
	ctx.r[4].s64 = ctx.r[11].s64 + 5620;
	// 829F41B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F41B4: 4B838D1D  bl 0x8222ced0
	ctx.lr = 0x829F41B8;
	sub_8222CED0(ctx, base);
	// 829F41B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F41BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F41C0: 4B7F8639  bl 0x821ec7f8
	ctx.lr = 0x829F41C4;
	sub_821EC7F8(ctx, base);
	// 829F41C4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829F41C8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 829F41CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F41D0: 419A0008  beq cr6, 0x829f41d8
	if ctx.cr[6].eq {
	pc = 0x829F41D8; continue 'dispatch;
	}
	// 829F41D4: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829F41D8; continue 'dispatch;
            }
            0x829F41D8 => {
    //   block [0x829F41D8..0x829F41EC)
	// 829F41D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F41DC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829F41E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F41E4: 419A0008  beq cr6, 0x829f41ec
	if ctx.cr[6].eq {
	pc = 0x829F41EC; continue 'dispatch;
	}
	// 829F41E8: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829F41EC; continue 'dispatch;
            }
            0x829F41EC => {
    //   block [0x829F41EC..0x829F4230)
	// 829F41EC: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 829F41F0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829F41F4: 4BA6F1AD  bl 0x824633a0
	ctx.lr = 0x829F41F8;
	sub_824633A0(ctx, base);
	// 829F41F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F41FC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829F4200: 4BA69831  bl 0x8245da30
	ctx.lr = 0x829F4204;
	sub_8245DA30(ctx, base);
	// 829F4204: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829F4208: 4B820BD1  bl 0x82214dd8
	ctx.lr = 0x829F420C;
	sub_82214DD8(ctx, base);
	// 829F420C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829F4210: 4B7C3909  bl 0x821b7b18
	ctx.lr = 0x829F4214;
	sub_821B7B18(ctx, base);
	// 829F4214: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F4218: 4B820BC1  bl 0x82214dd8
	ctx.lr = 0x829F421C;
	sub_82214DD8(ctx, base);
	// 829F421C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829F4220: 4B7C38F9  bl 0x821b7b18
	ctx.lr = 0x829F4224;
	sub_821B7B18(ctx, base);
	// 829F4224: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F4228: 4B7C38F1  bl 0x821b7b18
	ctx.lr = 0x829F422C;
	sub_821B7B18(ctx, base);
	// 829F422C: 82A10078  lwz r21, 0x78(r1)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	pc = 0x829F4230; continue 'dispatch;
            }
            0x829F4230 => {
    //   block [0x829F4230..0x829F425C)
	// 829F4230: 817900B0  lwz r11, 0xb0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(176 as u32) ) } as u64;
	// 829F4234: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 829F4238: 3B5900AC  addi r26, r25, 0xac
	ctx.r[26].s64 = ctx.r[25].s64 + 172;
	// 829F423C: 3AEA1604  addi r23, r10, 0x1604
	ctx.r[23].s64 = ctx.r[10].s64 + 5636;
	// 829F4240: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F4244: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 829F4248: 3B0B0FA8  addi r24, r11, 0xfa8
	ctx.r[24].s64 = ctx.r[11].s64 + 4008;
	// 829F424C: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F4250: 7F1AD040  cmplw cr6, r26, r26
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[26].u32, &mut ctx.xer);
	// 829F4254: 419A0008  beq cr6, 0x829f425c
	if ctx.cr[6].eq {
	pc = 0x829F425C; continue 'dispatch;
	}
	// 829F4258: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829F425C; continue 'dispatch;
            }
            0x829F425C => {
    //   block [0x829F425C..0x829F4274)
	// 829F425C: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829F4260: 419A03D0  beq cr6, 0x829f4630
	if ctx.cr[6].eq {
	pc = 0x829F4630; continue 'dispatch;
	}
	// 829F4264: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F4268: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829F426C: 409A0008  bne cr6, 0x829f4274
	if !ctx.cr[6].eq {
	pc = 0x829F4274; continue 'dispatch;
	}
	// 829F4270: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829F4274; continue 'dispatch;
            }
            0x829F4274 => {
    //   block [0x829F4274..0x829F42B0)
	// 829F4274: 817B000C  lwz r11, 0xc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 829F4278: 3BDB0008  addi r30, r27, 8
	ctx.r[30].s64 = ctx.r[27].s64 + 8;
	// 829F427C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F4280: 419A0030  beq cr6, 0x829f42b0
	if ctx.cr[6].eq {
	pc = 0x829F42B0; continue 'dispatch;
	}
	// 829F4284: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F4288: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F428C: 419A0064  beq cr6, 0x829f42f0
	if ctx.cr[6].eq {
	pc = 0x829F42F0; continue 'dispatch;
	}
	// 829F4290: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F4294: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F4298: 419A0018  beq cr6, 0x829f42b0
	if ctx.cr[6].eq {
	pc = 0x829F42B0; continue 'dispatch;
	}
	// 829F429C: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 829F42A0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829F42A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F42A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F42AC: 409A0008  bne cr6, 0x829f42b4
	if !ctx.cr[6].eq {
	pc = 0x829F42B4; continue 'dispatch;
	}
	pc = 0x829F42B0; continue 'dispatch;
            }
            0x829F42B0 => {
    //   block [0x829F42B0..0x829F42B4)
	// 829F42B0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x829F42B4; continue 'dispatch;
            }
            0x829F42B4 => {
    //   block [0x829F42B4..0x829F42D0)
	// 829F42B4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F42B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F42BC: 419A035C  beq cr6, 0x829f4618
	if ctx.cr[6].eq {
	pc = 0x829F4618; continue 'dispatch;
	}
	// 829F42C0: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F42C4: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829F42C8: 409A0008  bne cr6, 0x829f42d0
	if !ctx.cr[6].eq {
	pc = 0x829F42D0; continue 'dispatch;
	}
	// 829F42CC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829F42D0; continue 'dispatch;
            }
            0x829F42D0 => {
    //   block [0x829F42D0..0x829F42F0)
	// 829F42D0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F42D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F42D8: 419A002C  beq cr6, 0x829f4304
	if ctx.cr[6].eq {
	pc = 0x829F4304; continue 'dispatch;
	}
	// 829F42DC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F42E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F42E4: 419A0018  beq cr6, 0x829f42fc
	if ctx.cr[6].eq {
	pc = 0x829F42FC; continue 'dispatch;
	}
	// 829F42E8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F42EC: 4800001C  b 0x829f4308
	pc = 0x829F4308; continue 'dispatch;
            }
            0x829F42F0 => {
    //   block [0x829F42F0..0x829F42FC)
	// 829F42F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F42F4: 4B79FB45  bl 0x82193e38
	ctx.lr = 0x829F42F8;
	sub_82193E38(ctx, base);
	// 829F42F8: 4BFFFFB8  b 0x829f42b0
	pc = 0x829F42B0; continue 'dispatch;
            }
            0x829F42FC => {
    //   block [0x829F42FC..0x829F4304)
	// 829F42FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F4300: 4B79FB39  bl 0x82193e38
	ctx.lr = 0x829F4304;
	sub_82193E38(ctx, base);
	pc = 0x829F4304; continue 'dispatch;
            }
            0x829F4304 => {
    //   block [0x829F4304..0x829F4308)
	// 829F4304: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x829F4308; continue 'dispatch;
            }
            0x829F4308 => {
    //   block [0x829F4308..0x829F4338)
	// 829F4308: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 829F430C: 5549E7FE  rlwinm r9, r10, 0x1c, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 829F4310: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829F4314: 419A0078  beq cr6, 0x829f438c
	if ctx.cr[6].eq {
	pc = 0x829F438C; continue 'dispatch;
	}
	// 829F4318: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F431C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F4320: 409A0064  bne cr6, 0x829f4384
	if !ctx.cr[6].eq {
	pc = 0x829F4384; continue 'dispatch;
	}
	// 829F4324: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F4328: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829F432C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 829F4330: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F4334: 40810050  ble 0x829f4384
	if !ctx.cr[0].gt {
	pc = 0x829F4384; continue 'dispatch;
	}
	pc = 0x829F4338; continue 'dispatch;
            }
            0x829F4338 => {
    //   block [0x829F4338..0x829F4358)
	// 829F4338: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829F433C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F4340: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829F4344: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F4348: 2F070024  cmpwi cr6, r7, 0x24
	ctx.cr[6].compare_i32(ctx.r[7].s32, 36, &mut ctx.xer);
	// 829F434C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829F4350: 41980008  blt cr6, 0x829f4358
	if ctx.cr[6].lt {
	pc = 0x829F4358; continue 'dispatch;
	}
	// 829F4354: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x829F4358; continue 'dispatch;
            }
            0x829F4358 => {
    //   block [0x829F4358..0x829F4374)
	// 829F4358: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829F435C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829F4360: 419A0014  beq cr6, 0x829f4374
	if ctx.cr[6].eq {
	pc = 0x829F4374; continue 'dispatch;
	}
	// 829F4364: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829F4368: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F436C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F4370: 4800000C  b 0x829f437c
	pc = 0x829F437C; continue 'dispatch;
            }
            0x829F4374 => {
    //   block [0x829F4374..0x829F437C)
	// 829F4374: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829F4378: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829F437C; continue 'dispatch;
            }
            0x829F437C => {
    //   block [0x829F437C..0x829F4384)
	// 829F437C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F4380: 4199FFB8  bgt cr6, 0x829f4338
	if ctx.cr[6].gt {
	pc = 0x829F4338; continue 'dispatch;
	}
	pc = 0x829F4384; continue 'dispatch;
            }
            0x829F4384 => {
    //   block [0x829F4384..0x829F438C)
	// 829F4384: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F4388: 48000008  b 0x829f4390
	pc = 0x829F4390; continue 'dispatch;
            }
            0x829F438C => {
    //   block [0x829F438C..0x829F4390)
	// 829F438C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x829F4390; continue 'dispatch;
            }
            0x829F4390 => {
    //   block [0x829F4390..0x829F43B8)
	// 829F4390: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F4394: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F4398: 419A0280  beq cr6, 0x829f4618
	if ctx.cr[6].eq {
	pc = 0x829F4618; continue 'dispatch;
	}
	// 829F439C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829F43A0: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 829F43A4: 419A003C  beq cr6, 0x829f43e0
	if ctx.cr[6].eq {
	pc = 0x829F43E0; continue 'dispatch;
	}
	// 829F43A8: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F43AC: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829F43B0: 409A0008  bne cr6, 0x829f43b8
	if !ctx.cr[6].eq {
	pc = 0x829F43B8; continue 'dispatch;
	}
	// 829F43B4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829F43B8; continue 'dispatch;
            }
            0x829F43B8 => {
    //   block [0x829F43B8..0x829F43E0)
	// 829F43B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F43BC: 4B77FA7D  bl 0x82173e38
	ctx.lr = 0x829F43C0;
	sub_82173E38(ctx, base);
	// 829F43C0: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 829F43C4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 829F43C8: 4B7800A1  bl 0x82174468
	ctx.lr = 0x829F43CC;
	sub_82174468(ctx, base);
	// 829F43CC: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 829F43D0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829F43D4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 829F43D8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829F43DC: 48001525  bl 0x829f5900
	ctx.lr = 0x829F43E0;
	sub_829F5900(ctx, base);
	pc = 0x829F43E0; continue 'dispatch;
            }
            0x829F43E0 => {
    //   block [0x829F43E0..0x829F4418)
	// 829F43E0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829F43E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F43E8: 419A0230  beq cr6, 0x829f4618
	if ctx.cr[6].eq {
	pc = 0x829F4618; continue 'dispatch;
	}
	// 829F43EC: 817900A4  lwz r11, 0xa4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(164 as u32) ) } as u64;
	// 829F43F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F43F4: 419A0224  beq cr6, 0x829f4618
	if ctx.cr[6].eq {
	pc = 0x829F4618; continue 'dispatch;
	}
	// 829F43F8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 829F43FC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829F4400: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F4404: 4B838ACD  bl 0x8222ced0
	ctx.lr = 0x829F4408;
	sub_8222CED0(ctx, base);
	// 829F4408: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F440C: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829F4410: 409A0008  bne cr6, 0x829f4418
	if !ctx.cr[6].eq {
	pc = 0x829F4418; continue 'dispatch;
	}
	// 829F4414: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829F4418; continue 'dispatch;
            }
            0x829F4418 => {
    //   block [0x829F4418..0x829F4618)
	// 829F4418: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F441C: 4B77FA1D  bl 0x82173e38
	ctx.lr = 0x829F4420;
	sub_82173E38(ctx, base);
	// 829F4420: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829F4424: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 829F4428: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829F442C: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F4430: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 829F4434: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 829F4438: 4E800421  bctrl
	ctx.lr = 0x829F443C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829F443C: 81766AB8  lwz r11, 0x6ab8(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(27320 as u32) ) } as u64;
	// 829F4440: 390100A0  addi r8, r1, 0xa0
	ctx.r[8].s64 = ctx.r[1].s64 + 160;
	// 829F4444: 807900A4  lwz r3, 0xa4(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(164 as u32) ) } as u64;
	// 829F4448: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 829F444C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 829F4450: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 829F4454: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829F4458: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
            }
            0x829F4618 => {
    //   block [0x829F4618..0x829F4630)
	// 829F4618: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F461C: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829F4620: 409A0008  bne cr6, 0x829f4628
	if !ctx.cr[6].eq {
	pc = 0x829F4628; continue 'dispatch;
	}
	// 829F4624: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 829F4628: 837B0000  lwz r27, 0(r27)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F462C: 4BFFFC20  b 0x829f424c
	pc = 0x829F424C; continue 'dispatch;
            }
            0x829F4630 => {
    //   block [0x829F4630..0x829F4668)
	// 829F4630: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829F4634: 4B7D2135  bl 0x821c6768
	ctx.lr = 0x829F4638;
	sub_821C6768(ctx, base);
	// 829F4638: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 829F463C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F4640: 7D60A028  lwarx r11, 0, r20
	// lwarx
	let ea = ctx.r[20].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 829F4644: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F4648: 7D60A12D  stwcx. r11, 0, r20
	// stwcx.
	let addr = ctx.r[20].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F464C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F4650: 4082FFE8  bne 0x829f4638
	if !ctx.cr[0].eq {
	pc = 0x829F4638; continue 'dispatch;
	}
	// 829F4654: 93810080  stw r28, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[28].u32 ) };
	// 829F4658: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829F465C: 4B7C34BD  bl 0x821b7b18
	ctx.lr = 0x829F4660;
	sub_821B7B18(ctx, base);
	// 829F4660: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 829F4664: 482B4DD4  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F4668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F4668 size=388
    let mut pc: u32 = 0x829F4668;
    'dispatch: loop {
        match pc {
            0x829F4668 => {
    //   block [0x829F4668..0x829F47D8)
	// 829F4668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F466C: 482B4D99  bl 0x82ca9404
	ctx.lr = 0x829F4670;
	sub_82CA93D0(ctx, base);
	// 829F4670: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F4674: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F4678: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 829F467C: 4BFFD74D  bl 0x829f1dc8
	ctx.lr = 0x829F4680;
	sub_829F1DC8(ctx, base);
	// 829F4680: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F4684: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 829F4688: 392B1830  addi r9, r11, 0x1830
	ctx.r[9].s64 = ctx.r[11].s64 + 6192;
	// 829F468C: 390A1880  addi r8, r10, 0x1880
	ctx.r[8].s64 = ctx.r[10].s64 + 6272;
	// 829F4690: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829F4694: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829F4698: 911F0078  stw r8, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[8].u32 ) };
	// 829F469C: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 829F46A0: 93DF00A4  stw r30, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[30].u32 ) };
	// 829F46A4: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 829F46A8: 93DF00A8  stw r30, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[30].u32 ) };
	// 829F46AC: 3B670CA0  addi r27, r7, 0xca0
	ctx.r[27].s64 = ctx.r[7].s64 + 3232;
	// 829F46B0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829F46B4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 829F46B8: 38862F30  addi r4, r6, 0x2f30
	ctx.r[4].s64 = ctx.r[6].s64 + 12080;
	// 829F46BC: 3BBF00A4  addi r29, r31, 0xa4
	ctx.r[29].s64 = ctx.r[31].s64 + 164;
	// 829F46C0: 4B914901  bl 0x82308fc0
	ctx.lr = 0x829F46C4;
	sub_82308FC0(ctx, base);
	// 829F46C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F46C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F46CC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829F46D0: 4B838801  bl 0x8222ced0
	ctx.lr = 0x829F46D4;
	sub_8222CED0(ctx, base);
	// 829F46D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829F46D8: 387F00AC  addi r3, r31, 0xac
	ctx.r[3].s64 = ctx.r[31].s64 + 172;
	// 829F46DC: 4B7A7F0D  bl 0x8219c5e8
	ctx.lr = 0x829F46E0;
	sub_8219C5E8(ctx, base);
	// 829F46E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F46E4: 4B8206F5  bl 0x82214dd8
	ctx.lr = 0x829F46E8;
	sub_82214DD8(ctx, base);
	// 829F46E8: 3CA0820D  lis r5, -0x7df3
	ctx.r[5].s64 = -2113077248;
	// 829F46EC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829F46F0: 38852F40  addi r4, r5, 0x2f40
	ctx.r[4].s64 = ctx.r[5].s64 + 12096;
	// 829F46F4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829F46F8: 4B8A96F9  bl 0x8229ddf0
	ctx.lr = 0x829F46FC;
	sub_8229DDF0(ctx, base);
	// 829F46FC: 907F00B4  stw r3, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[3].u32 ) };
	// 829F4700: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F4704: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 829F4708: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829F470C: 388AABAC  addi r4, r10, -0x5454
	ctx.r[4].s64 = ctx.r[10].s64 + -21588;
	// 829F4710: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829F4714: 4B7EAD45  bl 0x821df458
	ctx.lr = 0x829F4718;
	sub_821DF458(ctx, base);
	// 829F4718: D03F00B8  stfs f1, 0xb8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 829F471C: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 829F4720: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 829F4724: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829F4728: 3889160C  addi r4, r9, 0x160c
	ctx.r[4].s64 = ctx.r[9].s64 + 5644;
	// 829F472C: 4B914895  bl 0x82308fc0
	ctx.lr = 0x829F4730;
	sub_82308FC0(ctx, base);
	// 829F4730: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F4734: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F4738: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829F473C: 4B838795  bl 0x8222ced0
	ctx.lr = 0x829F4740;
	sub_8222CED0(ctx, base);
	// 829F4740: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829F4744: 387F00BC  addi r3, r31, 0xbc
	ctx.r[3].s64 = ctx.r[31].s64 + 188;
	// 829F4748: 4B7A7EA1  bl 0x8219c5e8
	ctx.lr = 0x829F474C;
	sub_8219C5E8(ctx, base);
	// 829F474C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F4750: 4B820689  bl 0x82214dd8
	ctx.lr = 0x829F4754;
	sub_82214DD8(ctx, base);
	// 829F4754: 3D00820F  lis r8, -0x7df1
	ctx.r[8].s64 = -2112946176;
	// 829F4758: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829F475C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 829F4760: 38881618  addi r4, r8, 0x1618
	ctx.r[4].s64 = ctx.r[8].s64 + 5656;
	// 829F4764: 4B91485D  bl 0x82308fc0
	ctx.lr = 0x829F4768;
	sub_82308FC0(ctx, base);
	// 829F4768: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F476C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F4770: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829F4774: 4B83875D  bl 0x8222ced0
	ctx.lr = 0x829F4778;
	sub_8222CED0(ctx, base);
	// 829F4778: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829F477C: 387F00C4  addi r3, r31, 0xc4
	ctx.r[3].s64 = ctx.r[31].s64 + 196;
	// 829F4780: 4B7A7E69  bl 0x8219c5e8
	ctx.lr = 0x829F4784;
	sub_8219C5E8(ctx, base);
	// 829F4784: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F4788: 4B820651  bl 0x82214dd8
	ctx.lr = 0x829F478C;
	sub_82214DD8(ctx, base);
	// 829F478C: 93DF00D0  stw r30, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[30].u32 ) };
	// 829F4790: 93DF00D4  stw r30, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[30].u32 ) };
	// 829F4794: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 829F4798: 93DF00D8  stw r30, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[30].u32 ) };
	// 829F479C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829F47A0: 38A72F4C  addi r5, r7, 0x2f4c
	ctx.r[5].s64 = ctx.r[7].s64 + 12108;
	// 829F47A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829F47A8: 4B9D9969  bl 0x823ce110
	ctx.lr = 0x829F47AC;
	sub_823CE110(ctx, base);
	// 829F47AC: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829F47B0: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 829F47B4: 419A0024  beq cr6, 0x829f47d8
	if ctx.cr[6].eq {
	pc = 0x829F47D8; continue 'dispatch;
	}
	// 829F47B8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829F47BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F47C0: 4B796121  bl 0x8218a8e0
	ctx.lr = 0x829F47C4;
	sub_8218A8E0(ctx, base);
	// 829F47C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F47C8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F47CC: 4B786BCD  bl 0x8217b398
	ctx.lr = 0x829F47D0;
	sub_8217B398(ctx, base);
	// 829F47D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F47D4: 4B7C3345  bl 0x821b7b18
	ctx.lr = 0x829F47D8;
	sub_821B7B18(ctx, base);
	pc = 0x829F47D8; continue 'dispatch;
            }
            0x829F47D8 => {
    //   block [0x829F47D8..0x829F47EC)
	// 829F47D8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829F47DC: 4B7C333D  bl 0x821b7b18
	ctx.lr = 0x829F47E0;
	sub_821B7B18(ctx, base);
	// 829F47E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F47E4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829F47E8: 482B4C6C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F47F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F47F0 size=480
    let mut pc: u32 = 0x829F47F0;
    'dispatch: loop {
        match pc {
            0x829F47F0 => {
    //   block [0x829F47F0..0x829F4850)
	// 829F47F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F47F4: 482B4C11  bl 0x82ca9404
	ctx.lr = 0x829F47F8;
	sub_82CA93D0(ctx, base);
	// 829F47F8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F47FC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829F4800: 83DB00D0  lwz r30, 0xd0(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(208 as u32) ) } as u64;
	// 829F4804: 817B00D4  lwz r11, 0xd4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(212 as u32) ) } as u64;
	// 829F4808: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829F480C: 419A01BC  beq cr6, 0x829f49c8
	if ctx.cr[6].eq {
	pc = 0x829F49C8; continue 'dispatch;
	}
	// 829F4810: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829F4814: 3B800010  li r28, 0x10
	ctx.r[28].s64 = 16;
	// 829F4818: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F481C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F4820: 419A0030  beq cr6, 0x829f4850
	if ctx.cr[6].eq {
	pc = 0x829F4850; continue 'dispatch;
	}
	// 829F4824: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F4828: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F482C: 419A0058  beq cr6, 0x829f4884
	if ctx.cr[6].eq {
	pc = 0x829F4884; continue 'dispatch;
	}
	// 829F4830: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F4834: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F4838: 419A0018  beq cr6, 0x829f4850
	if ctx.cr[6].eq {
	pc = 0x829F4850; continue 'dispatch;
	}
	// 829F483C: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 829F4840: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829F4844: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F4848: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F484C: 409A0008  bne cr6, 0x829f4854
	if !ctx.cr[6].eq {
	pc = 0x829F4854; continue 'dispatch;
	}
	pc = 0x829F4850; continue 'dispatch;
            }
            0x829F4850 => {
    //   block [0x829F4850..0x829F4854)
	// 829F4850: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829F4854; continue 'dispatch;
            }
            0x829F4854 => {
    //   block [0x829F4854..0x829F4884)
	// 829F4854: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F4858: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F485C: 419A015C  beq cr6, 0x829f49b8
	if ctx.cr[6].eq {
	pc = 0x829F49B8; continue 'dispatch;
	}
	// 829F4860: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F4864: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 829F4868: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F486C: 419A002C  beq cr6, 0x829f4898
	if ctx.cr[6].eq {
	pc = 0x829F4898; continue 'dispatch;
	}
	// 829F4870: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F4874: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F4878: 419A0018  beq cr6, 0x829f4890
	if ctx.cr[6].eq {
	pc = 0x829F4890; continue 'dispatch;
	}
	// 829F487C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F4880: 4800001C  b 0x829f489c
	pc = 0x829F489C; continue 'dispatch;
            }
            0x829F4884 => {
    //   block [0x829F4884..0x829F4890)
	// 829F4884: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F4888: 4B79F5B1  bl 0x82193e38
	ctx.lr = 0x829F488C;
	sub_82193E38(ctx, base);
	// 829F488C: 4BFFFFC4  b 0x829f4850
	pc = 0x829F4850; continue 'dispatch;
            }
            0x829F4890 => {
    //   block [0x829F4890..0x829F4898)
	// 829F4890: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F4894: 4B79F5A5  bl 0x82193e38
	ctx.lr = 0x829F4898;
	sub_82193E38(ctx, base);
	pc = 0x829F4898; continue 'dispatch;
            }
            0x829F4898 => {
    //   block [0x829F4898..0x829F489C)
	// 829F4898: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829F489C; continue 'dispatch;
            }
            0x829F489C => {
    //   block [0x829F489C..0x829F48D8)
	// 829F489C: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 829F48A0: 55495FFE  rlwinm r9, r10, 0xb, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x001FFFFFu64;
	// 829F48A4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829F48A8: 419A00F4  beq cr6, 0x829f499c
	if ctx.cr[6].eq {
	pc = 0x829F499C; continue 'dispatch;
	}
	// 829F48AC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F48B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F48B4: 419A0024  beq cr6, 0x829f48d8
	if ctx.cr[6].eq {
	pc = 0x829F48D8; continue 'dispatch;
	}
	// 829F48B8: 892A0055  lbz r9, 0x55(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(85 as u32) ) } as u64;
	// 829F48BC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F48C0: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 829F48C4: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829F48C8: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F48CC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F48D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F48D4: 480000CC  b 0x829f49a0
	pc = 0x829F49A0; continue 'dispatch;
            }
            0x829F48D8 => {
    //   block [0x829F48D8..0x829F48F4)
	// 829F48D8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F48DC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829F48E0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 829F48E4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829F48E8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829F48EC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F48F0: 40810054  ble 0x829f4944
	if !ctx.cr[0].gt {
	pc = 0x829F4944; continue 'dispatch;
	}
	pc = 0x829F48F4; continue 'dispatch;
            }
            0x829F48F4 => {
    //   block [0x829F48F4..0x829F4914)
	// 829F48F4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829F48F8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F48FC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829F4900: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F4904: 2F070055  cmpwi cr6, r7, 0x55
	ctx.cr[6].compare_i32(ctx.r[7].s32, 85, &mut ctx.xer);
	// 829F4908: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829F490C: 41980008  blt cr6, 0x829f4914
	if ctx.cr[6].lt {
	pc = 0x829F4914; continue 'dispatch;
	}
	// 829F4910: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x829F4914; continue 'dispatch;
            }
            0x829F4914 => {
    //   block [0x829F4914..0x829F4930)
	// 829F4914: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829F4918: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829F491C: 419A0014  beq cr6, 0x829f4930
	if ctx.cr[6].eq {
	pc = 0x829F4930; continue 'dispatch;
	}
	// 829F4920: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829F4924: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F4928: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F492C: 4800000C  b 0x829f4938
	pc = 0x829F4938; continue 'dispatch;
            }
            0x829F4930 => {
    //   block [0x829F4930..0x829F4938)
	// 829F4930: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829F4934: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829F4938; continue 'dispatch;
            }
            0x829F4938 => {
    //   block [0x829F4938..0x829F4944)
	// 829F4938: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F493C: 4199FFB8  bgt cr6, 0x829f48f4
	if ctx.cr[6].gt {
	pc = 0x829F48F4; continue 'dispatch;
	}
	// 829F4940: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x829F4944; continue 'dispatch;
            }
            0x829F4944 => {
    //   block [0x829F4944..0x829F4960)
	// 829F4944: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829F4948: 419A0040  beq cr6, 0x829f4988
	if ctx.cr[6].eq {
	pc = 0x829F4988; continue 'dispatch;
	}
	// 829F494C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F4950: 2F0B0055  cmpwi cr6, r11, 0x55
	ctx.cr[6].compare_i32(ctx.r[11].s32, 85, &mut ctx.xer);
	// 829F4954: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F4958: 41990008  bgt cr6, 0x829f4960
	if ctx.cr[6].gt {
	pc = 0x829F4960; continue 'dispatch;
	}
	// 829F495C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829F4960; continue 'dispatch;
            }
            0x829F4960 => {
    //   block [0x829F4960..0x829F4988)
	// 829F4960: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F4964: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F4968: 409A0020  bne cr6, 0x829f4988
	if !ctx.cr[6].eq {
	pc = 0x829F4988; continue 'dispatch;
	}
	// 829F496C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829F4970: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 829F4974: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829F4978: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F497C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F4980: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F4984: 4800001C  b 0x829f49a0
	pc = 0x829F49A0; continue 'dispatch;
            }
            0x829F4988 => {
    //   block [0x829F4988..0x829F499C)
	// 829F4988: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829F498C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F4990: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F4994: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F4998: 48000008  b 0x829f49a0
	pc = 0x829F49A0; continue 'dispatch;
            }
            0x829F499C => {
    //   block [0x829F499C..0x829F49A0)
	// 829F499C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829F49A0; continue 'dispatch;
            }
            0x829F49A0 => {
    //   block [0x829F49A0..0x829F49B8)
	// 829F49A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F49A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F49A8: 419A0010  beq cr6, 0x829f49b8
	if ctx.cr[6].eq {
	pc = 0x829F49B8; continue 'dispatch;
	}
	// 829F49AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x829F49B8; continue 'dispatch;
            }
            0x829F49B8 => {
    //   block [0x829F49B8..0x829F49C8)
	// 829F49B8: 817B00D4  lwz r11, 0xd4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(212 as u32) ) } as u64;
	// 829F49BC: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 829F49C0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829F49C4: 409AFE54  bne cr6, 0x829f4818
	if !ctx.cr[6].eq {
	pc = 0x829F4818; continue 'dispatch;
	}
	pc = 0x829F49C8; continue 'dispatch;
            }
            0x829F49C8 => {
    //   block [0x829F49C8..0x829F49D0)
	// 829F49C8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829F49CC: 482B4A88  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F49D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829F49D0 size=2304
    let mut pc: u32 = 0x829F49D0;
    'dispatch: loop {
        match pc {
            0x829F49D0 => {
    //   block [0x829F49D0..0x829F52D0)
	// 829F49D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F49D4: 482B4A0D  bl 0x82ca93e0
	ctx.lr = 0x829F49D8;
	sub_82CA93D0(ctx, base);
	// 829F49D8: 3981FF88  addi r12, r1, -0x78
	ctx.r[12].s64 = ctx.r[1].s64 + -120;
	// 829F49DC: 482B92F9  bl 0x82cadcd4
	ctx.lr = 0x829F49E0;
	sub_82CADCA0(ctx, base);
	// 829F49E0: 3980FF50  li r12, -0xb0
	ctx.r[12].s64 = -176;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F52D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F52D0 size=352
    let mut pc: u32 = 0x829F52D0;
    'dispatch: loop {
        match pc {
            0x829F52D0 => {
    //   block [0x829F52D0..0x829F52F4)
	// 829F52D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F52D4: 482B412D  bl 0x82ca9400
	ctx.lr = 0x829F52D8;
	sub_82CA93D0(ctx, base);
	// 829F52D8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F52DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F52E0: 4BFFD1F1  bl 0x829f24d0
	ctx.lr = 0x829F52E4;
	sub_829F24D0(ctx, base);
	// 829F52E4: 817E00D4  lwz r11, 0xd4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(212 as u32) ) } as u64;
	// 829F52E8: 83FE00D0  lwz r31, 0xd0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) } as u64;
	// 829F52EC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829F52F0: 419A0098  beq cr6, 0x829f5388
	if ctx.cr[6].eq {
	pc = 0x829F5388; continue 'dispatch;
	}
	pc = 0x829F52F4; continue 'dispatch;
            }
            0x829F52F4 => {
    //   block [0x829F52F4..0x829F532C)
	// 829F52F4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F52F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F52FC: 419A0030  beq cr6, 0x829f532c
	if ctx.cr[6].eq {
	pc = 0x829F532C; continue 'dispatch;
	}
	// 829F5300: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F5304: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F5308: 419A0054  beq cr6, 0x829f535c
	if ctx.cr[6].eq {
	pc = 0x829F535C; continue 'dispatch;
	}
	// 829F530C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F5310: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F5314: 419A0018  beq cr6, 0x829f532c
	if ctx.cr[6].eq {
	pc = 0x829F532C; continue 'dispatch;
	}
	// 829F5318: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 829F531C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829F5320: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F5324: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F5328: 409A0008  bne cr6, 0x829f5330
	if !ctx.cr[6].eq {
	pc = 0x829F5330; continue 'dispatch;
	}
	pc = 0x829F532C; continue 'dispatch;
            }
            0x829F532C => {
    //   block [0x829F532C..0x829F5330)
	// 829F532C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829F5330; continue 'dispatch;
            }
            0x829F5330 => {
    //   block [0x829F5330..0x829F535C)
	// 829F5330: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F5334: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F5338: 419A0040  beq cr6, 0x829f5378
	if ctx.cr[6].eq {
	pc = 0x829F5378; continue 'dispatch;
	}
	// 829F533C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F5340: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F5344: 419A002C  beq cr6, 0x829f5370
	if ctx.cr[6].eq {
	pc = 0x829F5370; continue 'dispatch;
	}
	// 829F5348: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F534C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F5350: 419A0018  beq cr6, 0x829f5368
	if ctx.cr[6].eq {
	pc = 0x829F5368; continue 'dispatch;
	}
	// 829F5354: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 829F5358: 4800001C  b 0x829f5374
	pc = 0x829F5374; continue 'dispatch;
            }
            0x829F535C => {
    //   block [0x829F535C..0x829F5368)
	// 829F535C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F5360: 4B79EAD9  bl 0x82193e38
	ctx.lr = 0x829F5364;
	sub_82193E38(ctx, base);
	// 829F5364: 4BFFFFC8  b 0x829f532c
	pc = 0x829F532C; continue 'dispatch;
            }
            0x829F5368 => {
    //   block [0x829F5368..0x829F5370)
	// 829F5368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F536C: 4B79EACD  bl 0x82193e38
	ctx.lr = 0x829F5370;
	sub_82193E38(ctx, base);
	pc = 0x829F5370; continue 'dispatch;
            }
            0x829F5370 => {
    //   block [0x829F5370..0x829F5374)
	// 829F5370: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x829F5374; continue 'dispatch;
            }
            0x829F5374 => {
    //   block [0x829F5374..0x829F5378)
	// 829F5374: 4B9984B5  bl 0x8238d828
	ctx.lr = 0x829F5378;
	sub_8238D828(ctx, base);
	pc = 0x829F5378; continue 'dispatch;
            }
            0x829F5378 => {
    //   block [0x829F5378..0x829F5388)
	// 829F5378: 817E00D4  lwz r11, 0xd4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(212 as u32) ) } as u64;
	// 829F537C: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 829F5380: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829F5384: 409AFF70  bne cr6, 0x829f52f4
	if !ctx.cr[6].eq {
	pc = 0x829F52F4; continue 'dispatch;
	}
	pc = 0x829F5388; continue 'dispatch;
            }
            0x829F5388 => {
    //   block [0x829F5388..0x829F53E0)
	// 829F5388: 817E00D0  lwz r11, 0xd0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) } as u64;
	// 829F538C: 3B7E00CC  addi r27, r30, 0xcc
	ctx.r[27].s64 = ctx.r[30].s64 + 204;
	// 829F5390: 83DE00D4  lwz r30, 0xd4(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(212 as u32) ) } as u64;
	// 829F5394: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829F5398: 419A0090  beq cr6, 0x829f5428
	if ctx.cr[6].eq {
	pc = 0x829F5428; continue 'dispatch;
	}
	// 829F539C: 7D5EF050  subf r10, r30, r30
	ctx.r[10].s64 = ctx.r[30].s64 - ctx.r[30].s64;
	// 829F53A0: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829F53A4: 7D492E70  srawi r9, r10, 5
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 5) as i64;
	// 829F53A8: 552A2834  slwi r10, r9, 5
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829F53AC: 7F4A5A14  add r26, r10, r11
	ctx.r[26].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829F53B0: 419A0064  beq cr6, 0x829f5414
	if ctx.cr[6].eq {
	pc = 0x829F5414; continue 'dispatch;
	}
	// 829F53B4: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 829F53B8: 3BFE0004  addi r31, r30, 4
	ctx.r[31].s64 = ctx.r[30].s64 + 4;
	// 829F53BC: 7F9E5850  subf r28, r30, r11
	ctx.r[28].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 829F53C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F53C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F53C8: 419A0020  beq cr6, 0x829f53e8
	if ctx.cr[6].eq {
	pc = 0x829F53E8; continue 'dispatch;
	}
	// 829F53CC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F53D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F53D4: 419A000C  beq cr6, 0x829f53e0
	if ctx.cr[6].eq {
	pc = 0x829F53E0; continue 'dispatch;
	}
	// 829F53D8: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 829F53DC: 48000010  b 0x829f53ec
	pc = 0x829F53EC; continue 'dispatch;
            }
            0x829F53E0 => {
    //   block [0x829F53E0..0x829F53E8)
	// 829F53E0: 387FFFFC  addi r3, r31, -4
	ctx.r[3].s64 = ctx.r[31].s64 + -4;
	// 829F53E4: 4B79EA55  bl 0x82193e38
	ctx.lr = 0x829F53E8;
	sub_82193E38(ctx, base);
	pc = 0x829F53E8; continue 'dispatch;
            }
            0x829F53E8 => {
    //   block [0x829F53E8..0x829F53EC)
	// 829F53E8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829F53EC; continue 'dispatch;
            }
            0x829F53EC => {
    //   block [0x829F53EC..0x829F5414)
	// 829F53EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F53F0: 4B81F4A9  bl 0x82214898
	ctx.lr = 0x829F53F4;
	sub_82214898(ctx, base);
	// 829F53F4: 397F000C  addi r11, r31, 0xc
	ctx.r[11].s64 = ctx.r[31].s64 + 12;
	// 829F53F8: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 829F53FC: 3BBD0020  addi r29, r29, 0x20
	ctx.r[29].s64 = ctx.r[29].s64 + 32;
	// 829F5400: 395FFFFC  addi r10, r31, -4
	ctx.r[10].s64 = ctx.r[31].s64 + -4;
	pc = 0x829F5414; continue 'dispatch;
            }
            0x829F5414 => {
    //   block [0x829F5414..0x829F5428)
	// 829F5414: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 829F5418: 80BB0008  lwz r5, 8(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F541C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829F5420: 48000221  bl 0x829f5640
	ctx.lr = 0x829F5424;
	sub_829F5640(ctx, base);
	// 829F5424: 935B0008  stw r26, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	pc = 0x829F5428; continue 'dispatch;
            }
            0x829F5428 => {
    //   block [0x829F5428..0x829F5430)
	// 829F5428: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829F542C: 482B4024  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F5430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F5430 size=420
    let mut pc: u32 = 0x829F5430;
    'dispatch: loop {
        match pc {
            0x829F5430 => {
    //   block [0x829F5430..0x829F5470)
	// 829F5430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F5434: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F5438: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F543C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F5440: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F5444: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F5448: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829F544C: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 829F5450: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F5454: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F5458: 419A001C  beq cr6, 0x829f5474
	if ctx.cr[6].eq {
	pc = 0x829F5474; continue 'dispatch;
	}
	// 829F545C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F5460: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F5464: 419A000C  beq cr6, 0x829f5470
	if ctx.cr[6].eq {
	pc = 0x829F5470; continue 'dispatch;
	}
	// 829F5468: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F546C: 4800000C  b 0x829f5478
	pc = 0x829F5478; continue 'dispatch;
            }
            0x829F5470 => {
    //   block [0x829F5470..0x829F5474)
	// 829F5470: 4B79E9C9  bl 0x82193e38
	ctx.lr = 0x829F5474;
	sub_82193E38(ctx, base);
	pc = 0x829F5474; continue 'dispatch;
            }
            0x829F5474 => {
    //   block [0x829F5474..0x829F5478)
	// 829F5474: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x829F5478; continue 'dispatch;
            }
            0x829F5478 => {
    //   block [0x829F5478..0x829F54B0)
	// 829F5478: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 829F547C: 5549F7FE  rlwinm r9, r10, 0x1e, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 829F5480: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829F5484: 419A00E8  beq cr6, 0x829f556c
	if ctx.cr[6].eq {
	pc = 0x829F556C; continue 'dispatch;
	}
	// 829F5488: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F548C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F5490: 419A0020  beq cr6, 0x829f54b0
	if ctx.cr[6].eq {
	pc = 0x829F54B0; continue 'dispatch;
	}
	// 829F5494: 894A0022  lbz r10, 0x22(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(34 as u32) ) } as u64;
	// 829F5498: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F549C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 829F54A0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829F54A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F54A8: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F54AC: 480000C4  b 0x829f5570
	pc = 0x829F5570; continue 'dispatch;
            }
            0x829F54B0 => {
    //   block [0x829F54B0..0x829F54CC)
	// 829F54B0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F54B4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829F54B8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829F54BC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829F54C0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829F54C4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F54C8: 40810054  ble 0x829f551c
	if !ctx.cr[0].gt {
	pc = 0x829F551C; continue 'dispatch;
	}
	pc = 0x829F54CC; continue 'dispatch;
            }
            0x829F54CC => {
    //   block [0x829F54CC..0x829F54EC)
	// 829F54CC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829F54D0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F54D4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829F54D8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F54DC: 2F070022  cmpwi cr6, r7, 0x22
	ctx.cr[6].compare_i32(ctx.r[7].s32, 34, &mut ctx.xer);
	// 829F54E0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829F54E4: 41980008  blt cr6, 0x829f54ec
	if ctx.cr[6].lt {
	pc = 0x829F54EC; continue 'dispatch;
	}
	// 829F54E8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x829F54EC; continue 'dispatch;
            }
            0x829F54EC => {
    //   block [0x829F54EC..0x829F5508)
	// 829F54EC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829F54F0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829F54F4: 419A0014  beq cr6, 0x829f5508
	if ctx.cr[6].eq {
	pc = 0x829F5508; continue 'dispatch;
	}
	// 829F54F8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829F54FC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F5500: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F5504: 4800000C  b 0x829f5510
	pc = 0x829F5510; continue 'dispatch;
            }
            0x829F5508 => {
    //   block [0x829F5508..0x829F5510)
	// 829F5508: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829F550C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829F5510; continue 'dispatch;
            }
            0x829F5510 => {
    //   block [0x829F5510..0x829F551C)
	// 829F5510: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F5514: 4199FFB8  bgt cr6, 0x829f54cc
	if ctx.cr[6].gt {
	pc = 0x829F54CC; continue 'dispatch;
	}
	// 829F5518: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x829F551C; continue 'dispatch;
            }
            0x829F551C => {
    //   block [0x829F551C..0x829F5538)
	// 829F551C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829F5520: 419A003C  beq cr6, 0x829f555c
	if ctx.cr[6].eq {
	pc = 0x829F555C; continue 'dispatch;
	}
	// 829F5524: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F5528: 2F0B0022  cmpwi cr6, r11, 0x22
	ctx.cr[6].compare_i32(ctx.r[11].s32, 34, &mut ctx.xer);
	// 829F552C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F5530: 41990008  bgt cr6, 0x829f5538
	if ctx.cr[6].gt {
	pc = 0x829F5538; continue 'dispatch;
	}
	// 829F5534: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x829F5538; continue 'dispatch;
            }
            0x829F5538 => {
    //   block [0x829F5538..0x829F555C)
	// 829F5538: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F553C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F5540: 409A001C  bne cr6, 0x829f555c
	if !ctx.cr[6].eq {
	pc = 0x829F555C; continue 'dispatch;
	}
	// 829F5544: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829F5548: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829F554C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F5550: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F5554: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F5558: 48000018  b 0x829f5570
	pc = 0x829F5570; continue 'dispatch;
            }
            0x829F555C => {
    //   block [0x829F555C..0x829F556C)
	// 829F555C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829F5560: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F5564: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F5568: 48000008  b 0x829f5570
	pc = 0x829F5570; continue 'dispatch;
            }
            0x829F556C => {
    //   block [0x829F556C..0x829F5570)
	// 829F556C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x829F5570; continue 'dispatch;
            }
            0x829F5570 => {
    //   block [0x829F5570..0x829F55A8)
	// 829F5570: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F5574: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F5578: 419A0044  beq cr6, 0x829f55bc
	if ctx.cr[6].eq {
	pc = 0x829F55BC; continue 'dispatch;
	}
	// 829F557C: 897F00A4  lbz r11, 0xa4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 829F5580: C01E0078  lfs f0, 0x78(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F5584: C1BE007C  lfs f13, 0x7c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829F5588: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F558C: 409A001C  bne cr6, 0x829f55a8
	if !ctx.cr[6].eq {
	pc = 0x829F55A8; continue 'dispatch;
	}
	// 829F5590: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F5594: C19F0038  lfs f12, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829F5598: C17F003C  lfs f11, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829F559C: D19F00A8  stfs f12, 0xa8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 829F55A0: 997F00A4  stb r11, 0xa4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[11].u8 ) };
	// 829F55A4: D17F00AC  stfs f11, 0xac(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	pc = 0x829F55A8; continue 'dispatch;
            }
            0x829F55A8 => {
    //   block [0x829F55A8..0x829F55BC)
	// 829F55A8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 829F55AC: D1BF0038  stfs f13, 0x38(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 829F55B0: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 829F55B4: 816B9650  lwz r11, -0x69b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 829F55B8: 917F00B0  stw r11, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	pc = 0x829F55BC; continue 'dispatch;
            }
            0x829F55BC => {
    //   block [0x829F55BC..0x829F55D4)
	// 829F55BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F55C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F55C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F55C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829F55CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F55D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F55D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F55D8 size=100
    let mut pc: u32 = 0x829F55D8;
    'dispatch: loop {
        match pc {
            0x829F55D8 => {
    //   block [0x829F55D8..0x829F5620)
	// 829F55D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F55DC: 482B3E25  bl 0x82ca9400
	ctx.lr = 0x829F55E0;
	sub_82CA93D0(ctx, base);
	// 829F55E0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F55E4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 829F55E8: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 829F55EC: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 829F55F0: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 829F55F4: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 829F55F8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829F55FC: 419A0030  beq cr6, 0x829f562c
	if ctx.cr[6].eq {
	pc = 0x829F562C; continue 'dispatch;
	}
	// 829F5600: 3B600010  li r27, 0x10
	ctx.r[27].s64 = 16;
	// 829F5604: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F5608: 419A0018  beq cr6, 0x829f5620
	if ctx.cr[6].eq {
	pc = 0x829F5620; continue 'dispatch;
	}
	// 829F560C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F5610: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F5614: 4B7A175D  bl 0x82196d70
	ctx.lr = 0x829F5618;
	sub_82196D70(ctx, base);
	pc = 0x829F5620; continue 'dispatch;
            }
            0x829F5620 => {
    //   block [0x829F5620..0x829F562C)
	// 829F5620: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 829F5624: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 829F5628: 4082FFDC  bne 0x829f5604
	if !ctx.cr[0].eq {
	pc = 0x829F5604; continue 'dispatch;
	}
	pc = 0x829F562C; continue 'dispatch;
            }
            0x829F562C => {
    //   block [0x829F562C..0x829F563C)
	// 829F562C: 578B2834  slwi r11, r28, 5
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F5630: 7C6BD214  add r3, r11, r26
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 829F5634: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829F5638: 482B3E18  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F5640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F5640 size=132
    let mut pc: u32 = 0x829F5640;
    'dispatch: loop {
        match pc {
            0x829F5640 => {
    //   block [0x829F5640..0x829F5668)
	// 829F5640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F5644: 482B3DC5  bl 0x82ca9408
	ctx.lr = 0x829F5648;
	sub_82CA93D0(ctx, base);
	// 829F5648: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F564C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 829F5650: 7F04E040  cmplw cr6, r4, r28
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[28].u32, &mut ctx.xer);
	// 829F5654: 419A0068  beq cr6, 0x829f56bc
	if ctx.cr[6].eq {
	pc = 0x829F56BC; continue 'dispatch;
	}
	// 829F5658: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F565C: 3BE40004  addi r31, r4, 4
	ctx.r[31].s64 = ctx.r[4].s64 + 4;
	// 829F5660: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829F5664: 3BAB0B7C  addi r29, r11, 0xb7c
	ctx.r[29].s64 = ctx.r[11].s64 + 2940;
	pc = 0x829F5668; continue 'dispatch;
            }
            0x829F5668 => {
    //   block [0x829F5668..0x829F56A4)
	// 829F5668: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F566C: 93BFFFFC  stw r29, -4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), ctx.r[29].u32 ) };
	// 829F5670: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F5674: 419A0034  beq cr6, 0x829f56a8
	if ctx.cr[6].eq {
	pc = 0x829F56A8; continue 'dispatch;
	}
	// 829F5678: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F567C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 829F5680: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829F5684: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F5688: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F568C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829F5690: 409A0014  bne cr6, 0x829f56a4
	if !ctx.cr[6].eq {
	pc = 0x829F56A4; continue 'dispatch;
	}
	// 829F5694: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F5698: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F569C: 409A0008  bne cr6, 0x829f56a4
	if !ctx.cr[6].eq {
	pc = 0x829F56A4; continue 'dispatch;
	}
	// 829F56A0: 4B826699  bl 0x8221bd38
	ctx.lr = 0x829F56A4;
	sub_8221BD38(ctx, base);
	pc = 0x829F56A4; continue 'dispatch;
            }
            0x829F56A4 => {
    //   block [0x829F56A4..0x829F56A8)
	// 829F56A4: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x829F56A8; continue 'dispatch;
            }
            0x829F56A8 => {
    //   block [0x829F56A8..0x829F56BC)
	// 829F56A8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829F56AC: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 829F56B0: 397FFFFC  addi r11, r31, -4
	ctx.r[11].s64 = ctx.r[31].s64 + -4;
	// 829F56B4: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 829F56B8: 409AFFB0  bne cr6, 0x829f5668
	if !ctx.cr[6].eq {
	pc = 0x829F5668; continue 'dispatch;
	}
	pc = 0x829F56BC; continue 'dispatch;
            }
            0x829F56BC => {
    //   block [0x829F56BC..0x829F56C4)
	// 829F56BC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829F56C0: 482B3D98  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F56C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F56C8 size=564
    let mut pc: u32 = 0x829F56C8;
    'dispatch: loop {
        match pc {
            0x829F56C8 => {
    //   block [0x829F56C8..0x829F58FC)
	// 829F56C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F56CC: 482B3D3D  bl 0x82ca9408
	ctx.lr = 0x829F56D0;
	sub_82CA93D0(ctx, base);
	// 829F56D0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F56D4: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 829F56D8: F88100B8  std r4, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[4].u64 ) };
	// 829F56DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F56E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F56E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F56E8: 4B7A1689  bl 0x82196d70
	ctx.lr = 0x829F56EC;
	sub_82196D70(ctx, base);
	// 829F56EC: 3B800010  li r28, 0x10
	ctx.r[28].s64 = 16;
	// 829F56F0: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 829F56F4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F56F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F5900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F5900 size=308
    let mut pc: u32 = 0x829F5900;
    'dispatch: loop {
        match pc {
            0x829F5900 => {
    //   block [0x829F5900..0x829F5A00)
	// 829F5900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F5904: 482B3AFD  bl 0x82ca9400
	ctx.lr = 0x829F5908;
	sub_82CA93D0(ctx, base);
	// 829F5908: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F590C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F5910: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 829F5914: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 829F5918: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 829F591C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F5920: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F5924: 419A0104  beq cr6, 0x829f5a28
	if ctx.cr[6].eq {
	pc = 0x829F5A28; continue 'dispatch;
	}
	// 829F5928: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F592C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 829F5930: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829F5934: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F5938: 388BEE10  addi r4, r11, -0x11f0
	ctx.r[4].s64 = ctx.r[11].s64 + -4592;
	// 829F593C: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 829F5940: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F5944: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 829F5948: 7D1B1E70  srawi r27, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[27].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 829F594C: 4B7A5135  bl 0x8219aa80
	ctx.lr = 0x829F5950;
	sub_8219AA80(ctx, base);
	// 829F5950: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F5954: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F5958: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 829F595C: 80A70008  lwz r5, 8(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F5960: 4B8337A9  bl 0x82229108
	ctx.lr = 0x829F5964;
	sub_82229108(ctx, base);
	// 829F5964: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F5968: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F596C: 4B9AD655  bl 0x823a2fc0
	ctx.lr = 0x829F5970;
	sub_823A2FC0(ctx, base);
	// 829F5970: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F5974: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F5978: 4B9AD649  bl 0x823a2fc0
	ctx.lr = 0x829F597C;
	sub_823A2FC0(ctx, base);
	// 829F597C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F5980: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 829F5984: 813F0020  lwz r9, 0x20(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 829F5988: 394BFFE8  addi r10, r11, -0x18
	ctx.r[10].s64 = ctx.r[11].s64 + -24;
	// 829F598C: 90C1005C  stw r6, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[6].u32 ) };
	// 829F5990: 396BFFE0  addi r11, r11, -0x20
	ctx.r[11].s64 = ctx.r[11].s64 + -32;
	// 829F5994: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 829F5998: 3C8082A2  lis r4, -0x7d5e
	ctx.r[4].s64 = -2103312384;
	// 829F599C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829F59A0: 38844808  addi r4, r4, 0x4808
	ctx.r[4].s64 = ctx.r[4].s64 + 18440;
	// 829F59A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F59A8: 7CE95850  subf r7, r9, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829F59AC: 7CC95050  subf r6, r9, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 829F59B0: 4B7A4E91  bl 0x8219a840
	ctx.lr = 0x829F59B4;
	sub_8219A840(ctx, base);
	// 829F59B4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 829F59B8: 409A0048  bne cr6, 0x829f5a00
	if !ctx.cr[6].eq {
	pc = 0x829F5A00; continue 'dispatch;
	}
	// 829F59BC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F59C0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829F59C4: 392A9700  addi r9, r10, -0x6900
	ctx.r[9].s64 = ctx.r[10].s64 + -26880;
	// 829F59C8: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 829F59CC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 829F59D0: 419A004C  beq cr6, 0x829f5a1c
	if ctx.cr[6].eq {
	pc = 0x829F5A1C; continue 'dispatch;
	}
	// 829F59D4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F59D8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 829F59DC: 409A0040  bne cr6, 0x829f5a1c
	if !ctx.cr[6].eq {
	pc = 0x829F5A1C; continue 'dispatch;
	}
	// 829F59E0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829F59E4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829F59E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F59EC: 9B4B0000  stb r26, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u8 ) };
	// 829F59F0: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829F59F4: 4B90C4A5  bl 0x82301e98
	ctx.lr = 0x829F59F8;
	sub_82301E98(ctx, base);
	// 829F59F8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 829F59FC: 48000020  b 0x829f5a1c
	pc = 0x829F5A1C; continue 'dispatch;
            }
            0x829F5A00 => {
    //   block [0x829F5A00..0x829F5A1C)
	// 829F5A00: 48206E09  bl 0x82bfc808
	ctx.lr = 0x829F5A04;
	sub_82BFC808(ctx, base);
	// 829F5A04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F5A08: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829F5A0C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829F5A10: 4B8374C1  bl 0x8222ced0
	ctx.lr = 0x829F5A14;
	sub_8222CED0(ctx, base);
	// 829F5A14: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829F5A18: 4B81F3C1  bl 0x82214dd8
	ctx.lr = 0x829F5A1C;
	sub_82214DD8(ctx, base);
	pc = 0x829F5A1C; continue 'dispatch;
            }
            0x829F5A1C => {
    //   block [0x829F5A1C..0x829F5A28)
	// 829F5A1C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829F5A20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F5A24: 481D62E5  bl 0x82bcbd08
	ctx.lr = 0x829F5A28;
	sub_82BCBD08(ctx, base);
	pc = 0x829F5A28; continue 'dispatch;
            }
            0x829F5A28 => {
    //   block [0x829F5A28..0x829F5A34)
	// 829F5A28: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829F5A2C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829F5A30: 482B3A20  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F5A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F5A38 size=92
    let mut pc: u32 = 0x829F5A38;
    'dispatch: loop {
        match pc {
            0x829F5A38 => {
    //   block [0x829F5A38..0x829F5A78)
	// 829F5A38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F5A3C: 482B39D1  bl 0x82ca940c
	ctx.lr = 0x829F5A40;
	sub_82CA93D0(ctx, base);
	// 829F5A40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F5A44: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829F5A48: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 829F5A4C: 7F04E840  cmplw cr6, r4, r29
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829F5A50: 419A0038  beq cr6, 0x829f5a88
	if ctx.cr[6].eq {
	pc = 0x829F5A88; continue 'dispatch;
	}
	// 829F5A54: 7FDF2050  subf r30, r31, r4
	ctx.r[30].s64 = ctx.r[4].s64 - ctx.r[31].s64;
	// 829F5A58: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F5A5C: 419A001C  beq cr6, 0x829f5a78
	if ctx.cr[6].eq {
	pc = 0x829F5A78; continue 'dispatch;
	}
	// 829F5A60: 7C9EFA14  add r4, r30, r31
	ctx.r[4].u64 = ctx.r[30].u64 + ctx.r[31].u64;
	// 829F5A64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F5A68: 4B7A1309  bl 0x82196d70
	ctx.lr = 0x829F5A6C;
	sub_82196D70(ctx, base);
	// 829F5A6C: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	pc = 0x829F5A78; continue 'dispatch;
            }
            0x829F5A78 => {
    //   block [0x829F5A78..0x829F5A88)
	// 829F5A78: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 829F5A7C: 7D7EFA14  add r11, r30, r31
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[31].u64;
	// 829F5A80: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829F5A84: 409AFFD4  bne cr6, 0x829f5a58
	if !ctx.cr[6].eq {
	pc = 0x829F5A58; continue 'dispatch;
	}
	pc = 0x829F5A88; continue 'dispatch;
            }
            0x829F5A88 => {
    //   block [0x829F5A88..0x829F5A94)
	// 829F5A88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F5A8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F5A90: 482B39CC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F5A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F5A98 size=120
    let mut pc: u32 = 0x829F5A98;
    'dispatch: loop {
        match pc {
            0x829F5A98 => {
    //   block [0x829F5A98..0x829F5AE0)
	// 829F5A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F5A9C: 482B3969  bl 0x82ca9404
	ctx.lr = 0x829F5AA0;
	sub_82CA93D0(ctx, base);
	// 829F5AA0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F5AA4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F5AA8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829F5AAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F5AB0: 7F03F040  cmplw cr6, r3, r30
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829F5AB4: 419A0054  beq cr6, 0x829f5b08
	if ctx.cr[6].eq {
	pc = 0x829F5B08; continue 'dispatch;
	}
	// 829F5AB8: 3B9D0010  addi r28, r29, 0x10
	ctx.r[28].s64 = ctx.r[29].s64 + 16;
	// 829F5ABC: 3B600010  li r27, 0x10
	ctx.r[27].s64 = 16;
	// 829F5AC0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F5AC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F5AC8: 419A0020  beq cr6, 0x829f5ae8
	if ctx.cr[6].eq {
	pc = 0x829F5AE8; continue 'dispatch;
	}
	// 829F5ACC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F5AD0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F5AD4: 419A000C  beq cr6, 0x829f5ae0
	if ctx.cr[6].eq {
	pc = 0x829F5AE0; continue 'dispatch;
	}
	// 829F5AD8: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 829F5ADC: 48000010  b 0x829f5aec
	pc = 0x829F5AEC; continue 'dispatch;
            }
            0x829F5AE0 => {
    //   block [0x829F5AE0..0x829F5AE8)
	// 829F5AE0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F5AE4: 4B79E355  bl 0x82193e38
	ctx.lr = 0x829F5AE8;
	sub_82193E38(ctx, base);
	pc = 0x829F5AE8; continue 'dispatch;
            }
            0x829F5AE8 => {
    //   block [0x829F5AE8..0x829F5AEC)
	// 829F5AE8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829F5AEC; continue 'dispatch;
            }
            0x829F5AEC => {
    //   block [0x829F5AEC..0x829F5B08)
	// 829F5AEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F5AF0: 4B81EDA9  bl 0x82214898
	ctx.lr = 0x829F5AF4;
	sub_82214898(ctx, base);
	pc = 0x829F5B08; continue 'dispatch;
            }
            0x829F5B08 => {
    //   block [0x829F5B08..0x829F5B10)
	// 829F5B08: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829F5B0C: 482B3948  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F5B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829F5B10 size=8
    let mut pc: u32 = 0x829F5B10;
    'dispatch: loop {
        match pc {
            0x829F5B10 => {
    //   block [0x829F5B10..0x829F5B18)
	// 829F5B10: 3863FF88  addi r3, r3, -0x78
	ctx.r[3].s64 = ctx.r[3].s64 + -120;
	// 829F5B14: 4BFFBD7C  b 0x829f1890
	sub_829F1890(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F5B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829F5B18 size=8
    let mut pc: u32 = 0x829F5B18;
    'dispatch: loop {
        match pc {
            0x829F5B18 => {
    //   block [0x829F5B18..0x829F5B20)
	// 829F5B18: 3863FF88  addi r3, r3, -0x78
	ctx.r[3].s64 = ctx.r[3].s64 + -120;
	// 829F5B1C: 4BFFBFBC  b 0x829f1ad8
	sub_829F1AD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F5B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829F5B20 size=8
    let mut pc: u32 = 0x829F5B20;
    'dispatch: loop {
        match pc {
            0x829F5B20 => {
    //   block [0x829F5B20..0x829F5B28)
	// 829F5B20: 3863FF88  addi r3, r3, -0x78
	ctx.r[3].s64 = ctx.r[3].s64 + -120;
	// 829F5B24: 4BFFBADC  b 0x829f1600
	sub_829F1600(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F5B28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829F5B28 size=8
    let mut pc: u32 = 0x829F5B28;
    'dispatch: loop {
        match pc {
            0x829F5B28 => {
    //   block [0x829F5B28..0x829F5B30)
	// 829F5B28: 3863FF88  addi r3, r3, -0x78
	ctx.r[3].s64 = ctx.r[3].s64 + -120;
	// 829F5B2C: 4BFFBC74  b 0x829f17a0
	sub_829F17A0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F5B30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F5B30 size=116
    let mut pc: u32 = 0x829F5B30;
    'dispatch: loop {
        match pc {
            0x829F5B30 => {
    //   block [0x829F5B30..0x829F5B7C)
	// 829F5B30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F5B34: 482B38D9  bl 0x82ca940c
	ctx.lr = 0x829F5B38;
	sub_82CA93D0(ctx, base);
	// 829F5B38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F5B3C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829F5B40: 3860007C  li r3, 0x7c
	ctx.r[3].s64 = 124;
	// 829F5B44: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F5B48: 4B829711  bl 0x8221f258
	ctx.lr = 0x829F5B4C;
	sub_8221F258(ctx, base);
	// 829F5B4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F5B50: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F5B54: 419A0028  beq cr6, 0x829f5b7c
	if ctx.cr[6].eq {
	pc = 0x829F5B7C; continue 'dispatch;
	}
	// 829F5B58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F5B5C: 4BA14195  bl 0x82409cf0
	ctx.lr = 0x829F5B60;
	sub_82409CF0(ctx, base);
	// 829F5B60: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F5B64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F5B68: 394B1918  addi r10, r11, 0x1918
	ctx.r[10].s64 = ctx.r[11].s64 + 6424;
	// 829F5B6C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829F5B70: 813E0078  lwz r9, 0x78(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) } as u64;
	// 829F5B74: 913F0078  stw r9, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[9].u32 ) };
	// 829F5B78: 48000008  b 0x829f5b80
	pc = 0x829F5B80; continue 'dispatch;
            }
            0x829F5B7C => {
    //   block [0x829F5B7C..0x829F5B80)
	// 829F5B7C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829F5B80; continue 'dispatch;
            }
            0x829F5B80 => {
    //   block [0x829F5B80..0x829F5B98)
	// 829F5B80: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F5B84: 4B8CA395  bl 0x822bff18
	ctx.lr = 0x829F5B88;
	sub_822BFF18(ctx, base);
	// 829F5B88: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F5B8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F5B90: 419A0008  beq cr6, 0x829f5b98
	if ctx.cr[6].eq {
	pc = 0x829F5B98; continue 'dispatch;
	}
	// 829F5B94: 4B78B68D  bl 0x82181220
	ctx.lr = 0x829F5B98;
	sub_82181220(ctx, base);
	pc = 0x829F5B98; continue 'dispatch;
            }
            0x829F5B98 => {
    //   block [0x829F5B98..0x829F5BA4)
	// 829F5B98: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F5B9C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F5BA0: 482B38BC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F5BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F5BA8 size=188
    let mut pc: u32 = 0x829F5BA8;
    'dispatch: loop {
        match pc {
            0x829F5BA8 => {
    //   block [0x829F5BA8..0x829F5C0C)
	// 829F5BA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F5BAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F5BB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F5BB4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F5BB8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F5BBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F5BC0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829F5BC4: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 829F5BC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F5BCC: 4B837305  bl 0x8222ced0
	ctx.lr = 0x829F5BD0;
	sub_8222CED0(ctx, base);
	// 829F5BD0: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 829F5BD4: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 829F5BD8: 4199004C  bgt cr6, 0x829f5c24
	if ctx.cr[6].gt {
	pc = 0x829F5C24; continue 'dispatch;
	}
	// 829F5BDC: 3D80829F  lis r12, -0x7d61
	ctx.r[12].s64 = -2103508992;
	// 829F5BE0: 398C5BF4  addi r12, r12, 0x5bf4
	ctx.r[12].s64 = ctx.r[12].s64 + 23540;
	// 829F5BE4: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 829F5BE8: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 829F5BEC: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 829F5BF0: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x829F5C0C; continue 'dispatch;
		},
		1 => {
	pc = 0x829F5C18; continue 'dispatch;
		},
		2 => {
	pc = 0x829F5C0C; continue 'dispatch;
		},
		3 => {
	pc = 0x829F5C0C; continue 'dispatch;
		},
		4 => {
	pc = 0x829F5C18; continue 'dispatch;
		},
		5 => {
	pc = 0x829F5C18; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 829F5BF4: 829F5C0C  lwz r20, 0x5c0c(r31)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(23564 as u32) ) } as u64;
	// 829F5BF8: 829F5C18  lwz r20, 0x5c18(r31)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(23576 as u32) ) } as u64;
	// 829F5BFC: 829F5C0C  lwz r20, 0x5c0c(r31)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(23564 as u32) ) } as u64;
	// 829F5C00: 829F5C0C  lwz r20, 0x5c0c(r31)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(23564 as u32) ) } as u64;
	// 829F5C04: 829F5C18  lwz r20, 0x5c18(r31)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(23576 as u32) ) } as u64;
	// 829F5C08: 829F5C18  lwz r20, 0x5c18(r31)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(23576 as u32) ) } as u64;
            }
            0x829F5C0C => {
    //   block [0x829F5C0C..0x829F5C18)
	// 829F5C0C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F5C10: 388B18F8  addi r4, r11, 0x18f8
	ctx.r[4].s64 = ctx.r[11].s64 + 6392;
	// 829F5C14: 48000018  b 0x829f5c2c
	pc = 0x829F5C2C; continue 'dispatch;
            }
            0x829F5C18 => {
    //   block [0x829F5C18..0x829F5C24)
	// 829F5C18: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F5C1C: 388B1908  addi r4, r11, 0x1908
	ctx.r[4].s64 = ctx.r[11].s64 + 6408;
	// 829F5C20: 4800000C  b 0x829f5c2c
	pc = 0x829F5C2C; continue 'dispatch;
            }
            0x829F5C24 => {
    //   block [0x829F5C24..0x829F5C2C)
	// 829F5C24: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F5C28: 388B18E8  addi r4, r11, 0x18e8
	ctx.r[4].s64 = ctx.r[11].s64 + 6376;
	pc = 0x829F5C2C; continue 'dispatch;
            }
            0x829F5C2C => {
    //   block [0x829F5C2C..0x829F5C64)
	// 829F5C2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F5C30: 4B87F809  bl 0x82275438
	ctx.lr = 0x829F5C34;
	sub_82275438(ctx, base);
	// 829F5C34: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829F5C38: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 829F5C3C: 4B86F565  bl 0x822651a0
	ctx.lr = 0x829F5C40;
	sub_822651A0(ctx, base);
	// 829F5C40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F5C44: 4B81F195  bl 0x82214dd8
	ctx.lr = 0x829F5C48;
	sub_82214DD8(ctx, base);
	// 829F5C48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F5C4C: 4B7EDAED  bl 0x821e3738
	ctx.lr = 0x829F5C50;
	sub_821E3738(ctx, base);
	// 829F5C50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F5C54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F5C58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F5C5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F5C60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F5C68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F5C68 size=496
    let mut pc: u32 = 0x829F5C68;
    'dispatch: loop {
        match pc {
            0x829F5C68 => {
    //   block [0x829F5C68..0x829F5CC8)
	// 829F5C68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F5C6C: 482B379D  bl 0x82ca9408
	ctx.lr = 0x829F5C70;
	sub_82CA93D0(ctx, base);
	// 829F5C70: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F5C74: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829F5C78: 897C004B  lbz r11, 0x4b(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(75 as u32) ) } as u64;
	// 829F5C7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F5C80: 409A01D0  bne cr6, 0x829f5e50
	if !ctx.cr[6].eq {
	pc = 0x829F5E50; continue 'dispatch;
	}
	// 829F5C84: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829F5C88: 4B77E7E1  bl 0x82174468
	ctx.lr = 0x829F5C8C;
	sub_82174468(ctx, base);
	// 829F5C8C: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 829F5C90: 556ADFFE  rlwinm r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 829F5C94: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F5C98: 419A00F4  beq cr6, 0x829f5d8c
	if ctx.cr[6].eq {
	pc = 0x829F5D8C; continue 'dispatch;
	}
	// 829F5C9C: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F5CA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F5CA4: 419A0024  beq cr6, 0x829f5cc8
	if ctx.cr[6].eq {
	pc = 0x829F5CC8; continue 'dispatch;
	}
	// 829F5CA8: 894B0065  lbz r10, 0x65(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(101 as u32) ) } as u64;
	// 829F5CAC: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F5CB0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 829F5CB4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829F5CB8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F5CBC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829F5CC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F5CC4: 480000CC  b 0x829f5d90
	pc = 0x829F5D90; continue 'dispatch;
            }
            0x829F5CC8 => {
    //   block [0x829F5CC8..0x829F5CE4)
	// 829F5CC8: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F5CCC: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 829F5CD0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 829F5CD4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829F5CD8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829F5CDC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F5CE0: 40810054  ble 0x829f5d34
	if !ctx.cr[0].gt {
	pc = 0x829F5D34; continue 'dispatch;
	}
	pc = 0x829F5CE4; continue 'dispatch;
            }
            0x829F5CE4 => {
    //   block [0x829F5CE4..0x829F5D04)
	// 829F5CE4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829F5CE8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F5CEC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829F5CF0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F5CF4: 2F070065  cmpwi cr6, r7, 0x65
	ctx.cr[6].compare_i32(ctx.r[7].s32, 101, &mut ctx.xer);
	// 829F5CF8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829F5CFC: 41980008  blt cr6, 0x829f5d04
	if ctx.cr[6].lt {
	pc = 0x829F5D04; continue 'dispatch;
	}
	// 829F5D00: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x829F5D04; continue 'dispatch;
            }
            0x829F5D04 => {
    //   block [0x829F5D04..0x829F5D20)
	// 829F5D04: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829F5D08: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829F5D0C: 419A0014  beq cr6, 0x829f5d20
	if ctx.cr[6].eq {
	pc = 0x829F5D20; continue 'dispatch;
	}
	// 829F5D10: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829F5D14: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F5D18: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F5D1C: 4800000C  b 0x829f5d28
	pc = 0x829F5D28; continue 'dispatch;
            }
            0x829F5D20 => {
    //   block [0x829F5D20..0x829F5D28)
	// 829F5D20: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829F5D24: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829F5D28; continue 'dispatch;
            }
            0x829F5D28 => {
    //   block [0x829F5D28..0x829F5D34)
	// 829F5D28: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F5D2C: 4199FFB8  bgt cr6, 0x829f5ce4
	if ctx.cr[6].gt {
	pc = 0x829F5CE4; continue 'dispatch;
	}
	// 829F5D30: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x829F5D34; continue 'dispatch;
            }
            0x829F5D34 => {
    //   block [0x829F5D34..0x829F5D50)
	// 829F5D34: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829F5D38: 419A0040  beq cr6, 0x829f5d78
	if ctx.cr[6].eq {
	pc = 0x829F5D78; continue 'dispatch;
	}
	// 829F5D3C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F5D40: 2F0B0065  cmpwi cr6, r11, 0x65
	ctx.cr[6].compare_i32(ctx.r[11].s32, 101, &mut ctx.xer);
	// 829F5D44: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F5D48: 41990008  bgt cr6, 0x829f5d50
	if ctx.cr[6].gt {
	pc = 0x829F5D50; continue 'dispatch;
	}
	// 829F5D4C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x829F5D50; continue 'dispatch;
            }
            0x829F5D50 => {
    //   block [0x829F5D50..0x829F5D78)
	// 829F5D50: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F5D54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F5D58: 409A0020  bne cr6, 0x829f5d78
	if !ctx.cr[6].eq {
	pc = 0x829F5D78; continue 'dispatch;
	}
	// 829F5D5C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829F5D60: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829F5D64: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F5D68: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F5D6C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829F5D70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F5D74: 4800001C  b 0x829f5d90
	pc = 0x829F5D90; continue 'dispatch;
            }
            0x829F5D78 => {
    //   block [0x829F5D78..0x829F5D8C)
	// 829F5D78: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829F5D7C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F5D80: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829F5D84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F5D88: 48000008  b 0x829f5d90
	pc = 0x829F5D90; continue 'dispatch;
            }
            0x829F5D8C => {
    //   block [0x829F5D8C..0x829F5D90)
	// 829F5D8C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x829F5D90; continue 'dispatch;
            }
            0x829F5D90 => {
    //   block [0x829F5D90..0x829F5DEC)
	// 829F5D90: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F5D94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F5D98: 419A00B8  beq cr6, 0x829f5e50
	if ctx.cr[6].eq {
	pc = 0x829F5E50; continue 'dispatch;
	}
	// 829F5D9C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F5DA0: 8BBE0015  lbz r29, 0x15(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(21 as u32) ) } as u64;
	// 829F5DA4: 997E0015  stb r11, 0x15(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(21 as u32), ctx.r[11].u8 ) };
	// 829F5DA8: 817C0078  lwz r11, 0x78(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(120 as u32) ) } as u64;
	// 829F5DAC: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 829F5DB0: 4199009C  bgt cr6, 0x829f5e4c
	if ctx.cr[6].gt {
	pc = 0x829F5E4C; continue 'dispatch;
	}
	// 829F5DB4: 3D80829F  lis r12, -0x7d61
	ctx.r[12].s64 = -2103508992;
	// 829F5DB8: 398C5DCC  addi r12, r12, 0x5dcc
	ctx.r[12].s64 = ctx.r[12].s64 + 24012;
	// 829F5DBC: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 829F5DC0: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 829F5DC4: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 829F5DC8: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x829F5DFC; continue 'dispatch;
		},
		1 => {
	pc = 0x829F5DEC; continue 'dispatch;
		},
		2 => {
	pc = 0x829F5E04; continue 'dispatch;
		},
		3 => {
	pc = 0x829F5E04; continue 'dispatch;
		},
		4 => {
	pc = 0x829F5E0C; continue 'dispatch;
		},
		5 => {
	pc = 0x829F5DEC; continue 'dispatch;
		},
		6 => {
	pc = 0x829F5DF4; continue 'dispatch;
		},
		7 => {
	pc = 0x829F5E14; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 829F5DCC: 829F5DFC  lwz r20, 0x5dfc(r31)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24060 as u32) ) } as u64;
	// 829F5DD0: 829F5DEC  lwz r20, 0x5dec(r31)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24044 as u32) ) } as u64;
	// 829F5DD4: 829F5E04  lwz r20, 0x5e04(r31)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24068 as u32) ) } as u64;
	// 829F5DD8: 829F5E04  lwz r20, 0x5e04(r31)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24068 as u32) ) } as u64;
	// 829F5DDC: 829F5E0C  lwz r20, 0x5e0c(r31)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24076 as u32) ) } as u64;
	// 829F5DE0: 829F5DEC  lwz r20, 0x5dec(r31)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24044 as u32) ) } as u64;
	// 829F5DE4: 829F5DF4  lwz r20, 0x5df4(r31)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24052 as u32) ) } as u64;
	// 829F5DE8: 829F5E14  lwz r20, 0x5e14(r31)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24084 as u32) ) } as u64;
            }
            0x829F5DEC => {
    //   block [0x829F5DEC..0x829F5DF4)
	// 829F5DEC: 3BE00015  li r31, 0x15
	ctx.r[31].s64 = 21;
	// 829F5DF0: 48000028  b 0x829f5e18
	pc = 0x829F5E18; continue 'dispatch;
            }
            0x829F5DF4 => {
    //   block [0x829F5DF4..0x829F5DFC)
	// 829F5DF4: 3BE00018  li r31, 0x18
	ctx.r[31].s64 = 24;
	// 829F5DF8: 48000020  b 0x829f5e18
	pc = 0x829F5E18; continue 'dispatch;
            }
            0x829F5DFC => {
    //   block [0x829F5DFC..0x829F5E04)
	// 829F5DFC: 3BE00019  li r31, 0x19
	ctx.r[31].s64 = 25;
	// 829F5E00: 48000018  b 0x829f5e18
	pc = 0x829F5E18; continue 'dispatch;
            }
            0x829F5E04 => {
    //   block [0x829F5E04..0x829F5E0C)
	// 829F5E04: 3BE0001A  li r31, 0x1a
	ctx.r[31].s64 = 26;
	// 829F5E08: 48000010  b 0x829f5e18
	pc = 0x829F5E18; continue 'dispatch;
            }
            0x829F5E0C => {
    //   block [0x829F5E0C..0x829F5E14)
	// 829F5E0C: 3BE00017  li r31, 0x17
	ctx.r[31].s64 = 23;
	// 829F5E10: 48000008  b 0x829f5e18
	pc = 0x829F5E18; continue 'dispatch;
            }
            0x829F5E14 => {
    //   block [0x829F5E14..0x829F5E18)
	// 829F5E14: 3BE00016  li r31, 0x16
	ctx.r[31].s64 = 22;
	pc = 0x829F5E18; continue 'dispatch;
            }
            0x829F5E18 => {
    //   block [0x829F5E18..0x829F5E4C)
	// 829F5E18: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829F5E1C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829F5E20: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 829F5E24: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 829F5E28: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 829F5E2C: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F5E30: 83880060  lwz r28, 0x60(r8)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(96 as u32) ) } as u64;
	// 829F5E34: 4B77E635  bl 0x82174468
	ctx.lr = 0x829F5E38;
	sub_82174468(ctx, base);
	// 829F5E38: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829F5E3C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829F5E40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F5E44: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829F5E48: 4B78A659  bl 0x821804a0
	ctx.lr = 0x829F5E4C;
	sub_821804A0(ctx, base);
	pc = 0x829F5E4C; continue 'dispatch;
            }
            0x829F5E4C => {
    //   block [0x829F5E4C..0x829F5E50)
	// 829F5E4C: 9BBE0015  stb r29, 0x15(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(21 as u32), ctx.r[29].u8 ) };
	pc = 0x829F5E50; continue 'dispatch;
            }
            0x829F5E50 => {
    //   block [0x829F5E50..0x829F5E58)
	// 829F5E50: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829F5E54: 482B3604  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F5E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F5E58 size=136
    let mut pc: u32 = 0x829F5E58;
    'dispatch: loop {
        match pc {
            0x829F5E58 => {
    //   block [0x829F5E58..0x829F5EB8)
	// 829F5E58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F5E5C: 482B35B1  bl 0x82ca940c
	ctx.lr = 0x829F5E60;
	sub_82CA93D0(ctx, base);
	// 829F5E60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F5E64: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829F5E68: 386000A0  li r3, 0xa0
	ctx.r[3].s64 = 160;
	// 829F5E6C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F5E70: 4B8293E9  bl 0x8221f258
	ctx.lr = 0x829F5E74;
	sub_8221F258(ctx, base);
	// 829F5E74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F5E78: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F5E7C: 419A003C  beq cr6, 0x829f5eb8
	if ctx.cr[6].eq {
	pc = 0x829F5EB8; continue 'dispatch;
	}
	// 829F5E80: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F5E84: 4BA13E6D  bl 0x82409cf0
	ctx.lr = 0x829F5E88;
	sub_82409CF0(ctx, base);
	// 829F5E88: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 829F5E8C: 39600080  li r11, 0x80
	ctx.r[11].s64 = 128;
	// 829F5E90: 392A1970  addi r9, r10, 0x1970
	ctx.r[9].s64 = ctx.r[10].s64 + 6512;
	// 829F5E94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F5E98: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829F5E9C: C01E0078  lfs f0, 0x78(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F5EA0: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	pc = 0x829F5EB8; continue 'dispatch;
            }
            0x829F5EB8 => {
    //   block [0x829F5EB8..0x829F5EE0)
	// 829F5EB8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829F5EBC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F5EC0: 4B8CA059  bl 0x822bff18
	ctx.lr = 0x829F5EC4;
	sub_822BFF18(ctx, base);
	// 829F5EC4: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F5EC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F5ECC: 419A0008  beq cr6, 0x829f5ed4
	if ctx.cr[6].eq {
	pc = 0x829F5ED4; continue 'dispatch;
	}
	// 829F5ED0: 4B78B351  bl 0x82181220
	ctx.lr = 0x829F5ED4;
	sub_82181220(ctx, base);
	// 829F5ED4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F5ED8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F5EDC: 482B3580  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F5EE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F5EE0 size=108
    let mut pc: u32 = 0x829F5EE0;
    'dispatch: loop {
        match pc {
            0x829F5EE0 => {
    //   block [0x829F5EE0..0x829F5F24)
	// 829F5EE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F5EE4: 482B3529  bl 0x82ca940c
	ctx.lr = 0x829F5EE8;
	sub_82CA93D0(ctx, base);
	// 829F5EE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F5EEC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F5EF0: 38600078  li r3, 0x78
	ctx.r[3].s64 = 120;
	// 829F5EF4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 829F5EF8: 4B829361  bl 0x8221f258
	ctx.lr = 0x829F5EFC;
	sub_8221F258(ctx, base);
	// 829F5EFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F5F00: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F5F04: 419A0020  beq cr6, 0x829f5f24
	if ctx.cr[6].eq {
	pc = 0x829F5F24; continue 'dispatch;
	}
	// 829F5F08: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F5F0C: 4BA13DE5  bl 0x82409cf0
	ctx.lr = 0x829F5F10;
	sub_82409CF0(ctx, base);
	// 829F5F10: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F5F14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F5F18: 394B19C0  addi r10, r11, 0x19c0
	ctx.r[10].s64 = ctx.r[11].s64 + 6592;
	// 829F5F1C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829F5F20: 48000008  b 0x829f5f28
	pc = 0x829F5F28; continue 'dispatch;
            }
            0x829F5F24 => {
    //   block [0x829F5F24..0x829F5F28)
	// 829F5F24: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829F5F28; continue 'dispatch;
            }
            0x829F5F28 => {
    //   block [0x829F5F28..0x829F5F40)
	// 829F5F28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F5F2C: 4B8C9FED  bl 0x822bff18
	ctx.lr = 0x829F5F30;
	sub_822BFF18(ctx, base);
	// 829F5F30: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F5F34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F5F38: 419A0008  beq cr6, 0x829f5f40
	if ctx.cr[6].eq {
	pc = 0x829F5F40; continue 'dispatch;
	}
	// 829F5F3C: 4B78B2E5  bl 0x82181220
	ctx.lr = 0x829F5F40;
	sub_82181220(ctx, base);
	pc = 0x829F5F40; continue 'dispatch;
            }
            0x829F5F40 => {
    //   block [0x829F5F40..0x829F5F4C)
	// 829F5F40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F5F44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F5F48: 482B3514  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F5F50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F5F50 size=1408
    let mut pc: u32 = 0x829F5F50;
    'dispatch: loop {
        match pc {
            0x829F5F50 => {
    //   block [0x829F5F50..0x829F5F94)
	// 829F5F50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F5F54: 482B34B5  bl 0x82ca9408
	ctx.lr = 0x829F5F58;
	sub_82CA93D0(ctx, base);
	// 829F5F58: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 829F5F5C: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F5F60: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F5F64: 4B7ED7D5  bl 0x821e3738
	ctx.lr = 0x829F5F68;
	sub_821E3738(ctx, base);
	// 829F5F68: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F5F6C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829F5F70: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 829F5F74: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 829F5F78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F5F7C: 419A001C  beq cr6, 0x829f5f98
	if ctx.cr[6].eq {
	pc = 0x829F5F98; continue 'dispatch;
	}
	// 829F5F80: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F5F84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F5F88: 419A000C  beq cr6, 0x829f5f94
	if ctx.cr[6].eq {
	pc = 0x829F5F94; continue 'dispatch;
	}
	// 829F5F8C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F5F90: 4800000C  b 0x829f5f9c
	pc = 0x829F5F9C; continue 'dispatch;
            }
            0x829F5F94 => {
    //   block [0x829F5F94..0x829F5F98)
	// 829F5F94: 4B79DEA5  bl 0x82193e38
	ctx.lr = 0x829F5F98;
	sub_82193E38(ctx, base);
	pc = 0x829F5F98; continue 'dispatch;
            }
            0x829F5F98 => {
    //   block [0x829F5F98..0x829F5F9C)
	// 829F5F98: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829F5F9C; continue 'dispatch;
            }
            0x829F5F9C => {
    //   block [0x829F5F9C..0x829F5FDC)
	// 829F5F9C: 894B0040  lbz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 829F5FA0: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829F5FA4: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 829F5FA8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829F5FAC: 419A00F4  beq cr6, 0x829f60a0
	if ctx.cr[6].eq {
	pc = 0x829F60A0; continue 'dispatch;
	}
	// 829F5FB0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F5FB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F5FB8: 419A0024  beq cr6, 0x829f5fdc
	if ctx.cr[6].eq {
	pc = 0x829F5FDC; continue 'dispatch;
	}
	// 829F5FBC: 894A00F8  lbz r10, 0xf8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(248 as u32) ) } as u64;
	// 829F5FC0: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F5FC4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 829F5FC8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829F5FCC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F5FD0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F5FD4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 829F5FD8: 480000CC  b 0x829f60a4
	pc = 0x829F60A4; continue 'dispatch;
            }
            0x829F5FDC => {
    //   block [0x829F5FDC..0x829F5FF8)
	// 829F5FDC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F5FE0: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829F5FE4: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 829F5FE8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829F5FEC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829F5FF0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F5FF4: 40810054  ble 0x829f6048
	if !ctx.cr[0].gt {
	pc = 0x829F6048; continue 'dispatch;
	}
	pc = 0x829F5FF8; continue 'dispatch;
            }
            0x829F5FF8 => {
    //   block [0x829F5FF8..0x829F6018)
	// 829F5FF8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829F5FFC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F6000: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829F6004: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F6008: 2F0700F8  cmpwi cr6, r7, 0xf8
	ctx.cr[6].compare_i32(ctx.r[7].s32, 248, &mut ctx.xer);
	// 829F600C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 829F6010: 41980008  blt cr6, 0x829f6018
	if ctx.cr[6].lt {
	pc = 0x829F6018; continue 'dispatch;
	}
	// 829F6014: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x829F6018; continue 'dispatch;
            }
            0x829F6018 => {
    //   block [0x829F6018..0x829F6034)
	// 829F6018: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829F601C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829F6020: 419A0014  beq cr6, 0x829f6034
	if ctx.cr[6].eq {
	pc = 0x829F6034; continue 'dispatch;
	}
	// 829F6024: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829F6028: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F602C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F6030: 4800000C  b 0x829f603c
	pc = 0x829F603C; continue 'dispatch;
            }
            0x829F6034 => {
    //   block [0x829F6034..0x829F603C)
	// 829F6034: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829F6038: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829F603C; continue 'dispatch;
            }
            0x829F603C => {
    //   block [0x829F603C..0x829F6048)
	// 829F603C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F6040: 4199FFB8  bgt cr6, 0x829f5ff8
	if ctx.cr[6].gt {
	pc = 0x829F5FF8; continue 'dispatch;
	}
	// 829F6044: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x829F6048; continue 'dispatch;
            }
            0x829F6048 => {
    //   block [0x829F6048..0x829F6064)
	// 829F6048: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829F604C: 419A0040  beq cr6, 0x829f608c
	if ctx.cr[6].eq {
	pc = 0x829F608C; continue 'dispatch;
	}
	// 829F6050: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F6054: 2F0B00F8  cmpwi cr6, r11, 0xf8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 248, &mut ctx.xer);
	// 829F6058: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 829F605C: 41990008  bgt cr6, 0x829f6064
	if ctx.cr[6].gt {
	pc = 0x829F6064; continue 'dispatch;
	}
	// 829F6060: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829F6064; continue 'dispatch;
            }
            0x829F6064 => {
    //   block [0x829F6064..0x829F608C)
	// 829F6064: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F6068: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F606C: 409A0020  bne cr6, 0x829f608c
	if !ctx.cr[6].eq {
	pc = 0x829F608C; continue 'dispatch;
	}
	// 829F6070: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829F6074: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829F6078: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F607C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F6080: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F6084: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 829F6088: 4800001C  b 0x829f60a4
	pc = 0x829F60A4; continue 'dispatch;
            }
            0x829F608C => {
    //   block [0x829F608C..0x829F60A0)
	// 829F608C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829F6090: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F6094: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F6098: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 829F609C: 48000008  b 0x829f60a4
	pc = 0x829F60A4; continue 'dispatch;
            }
            0x829F60A0 => {
    //   block [0x829F60A0..0x829F60A4)
	// 829F60A0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829F60A4; continue 'dispatch;
            }
            0x829F60A4 => {
    //   block [0x829F60A4..0x829F60B8)
	// 829F60A4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F60A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F60AC: 419A000C  beq cr6, 0x829f60b8
	if ctx.cr[6].eq {
	pc = 0x829F60B8; continue 'dispatch;
	}
	// 829F60B0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 829F60B4: 917E0090  stw r11, 0x90(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	pc = 0x829F60B8; continue 'dispatch;
            }
            0x829F60B8 => {
    //   block [0x829F60B8..0x829F6108)
	// 829F60B8: 817E0090  lwz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 829F60BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F60C0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 829F60C4: 4099016C  ble cr6, 0x829f6230
	if !ctx.cr[6].gt {
	pc = 0x829F6230; continue 'dispatch;
	}
	// 829F60C8: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 829F60CC: 4B77E39D  bl 0x82174468
	ctx.lr = 0x829F60D0;
	sub_82174468(ctx, base);
	// 829F60D0: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 829F60D4: 556A7FFE  rlwinm r10, r11, 0xf, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0001FFFFu64;
	// 829F60D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F60DC: 419A00E8  beq cr6, 0x829f61c4
	if ctx.cr[6].eq {
	pc = 0x829F61C4; continue 'dispatch;
	}
	// 829F60E0: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F60E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F60E8: 419A0020  beq cr6, 0x829f6108
	if ctx.cr[6].eq {
	pc = 0x829F6108; continue 'dispatch;
	}
	// 829F60EC: 894B0031  lbz r10, 0x31(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(49 as u32) ) } as u64;
	// 829F60F0: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F60F4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 829F60F8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829F60FC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 829F6100: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F6104: 480000C4  b 0x829f61c8
	pc = 0x829F61C8; continue 'dispatch;
            }
            0x829F6108 => {
    //   block [0x829F6108..0x829F6124)
	// 829F6108: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F610C: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 829F6110: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 829F6114: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829F6118: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829F611C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F6120: 40810054  ble 0x829f6174
	if !ctx.cr[0].gt {
	pc = 0x829F6174; continue 'dispatch;
	}
	pc = 0x829F6124; continue 'dispatch;
            }
            0x829F6124 => {
    //   block [0x829F6124..0x829F6144)
	// 829F6124: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829F6128: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F612C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829F6130: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F6134: 2F070031  cmpwi cr6, r7, 0x31
	ctx.cr[6].compare_i32(ctx.r[7].s32, 49, &mut ctx.xer);
	// 829F6138: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 829F613C: 41980008  blt cr6, 0x829f6144
	if ctx.cr[6].lt {
	pc = 0x829F6144; continue 'dispatch;
	}
	// 829F6140: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x829F6144; continue 'dispatch;
            }
            0x829F6144 => {
    //   block [0x829F6144..0x829F6160)
	// 829F6144: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829F6148: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829F614C: 419A0014  beq cr6, 0x829f6160
	if ctx.cr[6].eq {
	pc = 0x829F6160; continue 'dispatch;
	}
	// 829F6150: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829F6154: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F6158: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F615C: 4800000C  b 0x829f6168
	pc = 0x829F6168; continue 'dispatch;
            }
            0x829F6160 => {
    //   block [0x829F6160..0x829F6168)
	// 829F6160: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829F6164: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829F6168; continue 'dispatch;
            }
            0x829F6168 => {
    //   block [0x829F6168..0x829F6174)
	// 829F6168: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F616C: 4199FFB8  bgt cr6, 0x829f6124
	if ctx.cr[6].gt {
	pc = 0x829F6124; continue 'dispatch;
	}
	// 829F6170: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x829F6174; continue 'dispatch;
            }
            0x829F6174 => {
    //   block [0x829F6174..0x829F6190)
	// 829F6174: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829F6178: 419A003C  beq cr6, 0x829f61b4
	if ctx.cr[6].eq {
	pc = 0x829F61B4; continue 'dispatch;
	}
	// 829F617C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F6180: 2F0B0031  cmpwi cr6, r11, 0x31
	ctx.cr[6].compare_i32(ctx.r[11].s32, 49, &mut ctx.xer);
	// 829F6184: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 829F6188: 41990008  bgt cr6, 0x829f6190
	if ctx.cr[6].gt {
	pc = 0x829F6190; continue 'dispatch;
	}
	// 829F618C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829F6190; continue 'dispatch;
            }
            0x829F6190 => {
    //   block [0x829F6190..0x829F61B4)
	// 829F6190: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F6194: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F6198: 409A001C  bne cr6, 0x829f61b4
	if !ctx.cr[6].eq {
	pc = 0x829F61B4; continue 'dispatch;
	}
	// 829F619C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829F61A0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829F61A4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F61A8: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F61AC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 829F61B0: 48000018  b 0x829f61c8
	pc = 0x829F61C8; continue 'dispatch;
            }
            0x829F61B4 => {
    //   block [0x829F61B4..0x829F61C4)
	// 829F61B4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829F61B8: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F61BC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 829F61C0: 48000008  b 0x829f61c8
	pc = 0x829F61C8; continue 'dispatch;
            }
            0x829F61C4 => {
    //   block [0x829F61C4..0x829F61C8)
	// 829F61C4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829F61C8; continue 'dispatch;
            }
            0x829F61C8 => {
    //   block [0x829F61C8..0x829F6230)
	// 829F61C8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F61CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F61D0: 419A02F4  beq cr6, 0x829f64c4
	if ctx.cr[6].eq {
	pc = 0x829F64C4; continue 'dispatch;
	}
	// 829F61D4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 829F61D8: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F61DC: 48000A0D  bl 0x829f6be8
	ctx.lr = 0x829F61E0;
	sub_829F6BE8(ctx, base);
	// 829F61E0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829F61E4: 817E0040  lwz r11, 0x40(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 829F61E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F61EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F61F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829F61F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829F61F8: 4E800421  bctrl
	ctx.lr = 0x829F61FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829F61FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829F6200: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F6204: 392A0B7C  addi r9, r10, 0xb7c
	ctx.r[9].s64 = ctx.r[10].s64 + 2940;
	// 829F6208: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 829F620C: 4B79DC2D  bl 0x82193e38
	ctx.lr = 0x829F6210;
	sub_82193E38(ctx, base);
	// 829F6210: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 829F6214: 386100F4  addi r3, r1, 0xf4
	ctx.r[3].s64 = ctx.r[1].s64 + 244;
	// 829F6218: 4B81EBC1  bl 0x82214dd8
	ctx.lr = 0x829F621C;
	sub_82214DD8(ctx, base);
	// 829F621C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 829F6220: 4B7B6911  bl 0x821acb30
	ctx.lr = 0x829F6224;
	sub_821ACB30(ctx, base);
	// 829F6224: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 829F6228: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 829F622C: 482B322C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x829F6230 => {
    //   block [0x829F6230..0x829F6250)
	// 829F6230: 4B8A8C49  bl 0x8229ee78
	ctx.lr = 0x829F6234;
	sub_8229EE78(ctx, base);
	// 829F6234: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F6238: 419A0018  beq cr6, 0x829f6250
	if ctx.cr[6].eq {
	pc = 0x829F6250; continue 'dispatch;
	}
	// 829F623C: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 829F6240: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829F6244: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 829F6248: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F624C: 409A0008  bne cr6, 0x829f6254
	if !ctx.cr[6].eq {
	pc = 0x829F6254; continue 'dispatch;
	}
	pc = 0x829F6250; continue 'dispatch;
            }
            0x829F6250 => {
    //   block [0x829F6250..0x829F6254)
	// 829F6250: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829F6254; continue 'dispatch;
            }
            0x829F6254 => {
    //   block [0x829F6254..0x829F6284)
	// 829F6254: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F6258: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F625C: 419A0268  beq cr6, 0x829f64c4
	if ctx.cr[6].eq {
	pc = 0x829F64C4; continue 'dispatch;
	}
	// 829F6260: 813E0018  lwz r9, 0x18(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 829F6264: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 829F6268: 80DE001C  lwz r6, 0x1c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 829F626C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829F6270: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 829F6274: 7D493050  subf r10, r9, r6
	ctx.r[10].s64 = ctx.r[6].s64 - ctx.r[9].s64;
	// 829F6278: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 829F627C: 7D6A5BD7  divw. r11, r10, r11
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[11].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F6280: 4081005C  ble 0x829f62dc
	if !ctx.cr[0].gt {
	pc = 0x829F62DC; continue 'dispatch;
	}
	pc = 0x829F6284; continue 'dispatch;
            }
            0x829F6284 => {
    //   block [0x829F6284..0x829F62AC)
	// 829F6284: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829F6288: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F628C: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 829F6290: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F6294: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 829F6298: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F629C: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 829F62A0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 829F62A4: 41980008  blt cr6, 0x829f62ac
	if ctx.cr[6].lt {
	pc = 0x829F62AC; continue 'dispatch;
	}
	// 829F62A8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x829F62AC; continue 'dispatch;
            }
            0x829F62AC => {
    //   block [0x829F62AC..0x829F62C8)
	// 829F62AC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829F62B0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829F62B4: 419A0014  beq cr6, 0x829f62c8
	if ctx.cr[6].eq {
	pc = 0x829F62C8; continue 'dispatch;
	}
	// 829F62B8: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 829F62BC: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 829F62C0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F62C4: 4800000C  b 0x829f62d0
	pc = 0x829F62D0; continue 'dispatch;
            }
            0x829F62C8 => {
    //   block [0x829F62C8..0x829F62D0)
	// 829F62C8: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 829F62CC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x829F62D0; continue 'dispatch;
            }
            0x829F62D0 => {
    //   block [0x829F62D0..0x829F62DC)
	// 829F62D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F62D4: 4199FFB0  bgt cr6, 0x829f6284
	if ctx.cr[6].gt {
	pc = 0x829F6284; continue 'dispatch;
	}
	// 829F62D8: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	pc = 0x829F62DC; continue 'dispatch;
            }
            0x829F62DC => {
    //   block [0x829F62DC..0x829F62F8)
	// 829F62DC: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829F62E0: 419A0034  beq cr6, 0x829f6314
	if ctx.cr[6].eq {
	pc = 0x829F6314; continue 'dispatch;
	}
	// 829F62E4: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F62E8: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 829F62EC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 829F62F0: 41990008  bgt cr6, 0x829f62f8
	if ctx.cr[6].gt {
	pc = 0x829F62F8; continue 'dispatch;
	}
	// 829F62F4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829F62F8; continue 'dispatch;
            }
            0x829F62F8 => {
    //   block [0x829F62F8..0x829F6314)
	// 829F62F8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F62FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F6300: 409A0014  bne cr6, 0x829f6314
	if !ctx.cr[6].eq {
	pc = 0x829F6314; continue 'dispatch;
	}
	// 829F6304: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829F6308: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829F630C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F6310: 48000008  b 0x829f6318
	pc = 0x829F6318; continue 'dispatch;
            }
            0x829F6314 => {
    //   block [0x829F6314..0x829F6318)
	// 829F6314: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x829F6318; continue 'dispatch;
            }
            0x829F6318 => {
    //   block [0x829F6318..0x829F6330)
	// 829F6318: 815E001C  lwz r10, 0x1c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 829F631C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829F6320: 419A0010  beq cr6, 0x829f6330
	if ctx.cr[6].eq {
	pc = 0x829F6330; continue 'dispatch;
	}
	// 829F6324: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F6328: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 829F632C: 48000008  b 0x829f6334
	pc = 0x829F6334; continue 'dispatch;
            }
            0x829F6330 => {
    //   block [0x829F6330..0x829F6334)
	// 829F6330: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829F6334; continue 'dispatch;
            }
            0x829F6334 => {
    //   block [0x829F6334..0x829F64C4)
	// 829F6334: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F6338: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F633C: 419A0188  beq cr6, 0x829f64c4
	if ctx.cr[6].eq {
	pc = 0x829F64C4; continue 'dispatch;
	}
	// 829F6340: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 829F6344: 9B850042  stb r28, 0x42(r5)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[5].u32.wrapping_add(66 as u32), ctx.r[28].u8 ) };
	// 829F6348: 9B850040  stb r28, 0x40(r5)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[5].u32.wrapping_add(64 as u32), ctx.r[28].u8 ) };
	// 829F634C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F6350: C00B0E60  lfs f0, 0xe60(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3680 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F6354: D0050030  stfs f0, 0x30(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 829F6358: 4B8A8B21  bl 0x8229ee78
	ctx.lr = 0x829F635C;
	sub_8229EE78(ctx, base);
	// 829F635C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 829F6360: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829F6364: 808A007C  lwz r4, 0x7c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(124 as u32) ) } as u64;
	// 829F6368: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F636C: 81090040  lwz r8, 0x40(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(64 as u32) ) } as u64;
	// 829F6370: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 829F6374: 4E800421  bctrl
	ctx.lr = 0x829F6378;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829F6378: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F637C: 4B77E0ED  bl 0x82174468
	ctx.lr = 0x829F6380;
	sub_82174468(ctx, base);
	// 829F6380: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 829F6384: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829F6388: 8087007C  lwz r4, 0x7c(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(124 as u32) ) } as u64;
	// 829F638C: 80C40000  lwz r6, 0(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F6390: 80A60040  lwz r5, 0x40(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(64 as u32) ) } as u64;
	// 829F6394: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 829F6398: 4E800421  bctrl
	ctx.lr = 0x829F639C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829F639C: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 829F63A0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829F63A4: C01E0078  lfs f0, 0x78(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F63A8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F63AC: EDA00032  fmuls f13, f0, f0
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 829F63B0: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 829F63B4: 392B90F0  addi r9, r11, -0x6f10
	ctx.r[9].s64 = ctx.r[11].s64 + -28432;
            }
            0x829F64C4 => {
    //   block [0x829F64C4..0x829F64D0)
	// 829F64C4: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 829F64C8: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 829F64CC: 482B2F8C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F64D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F64D0 size=1164
    let mut pc: u32 = 0x829F64D0;
    'dispatch: loop {
        match pc {
            0x829F64D0 => {
    //   block [0x829F64D0..0x829F6508)
	// 829F64D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F64D4: 482B2F2D  bl 0x82ca9400
	ctx.lr = 0x829F64D8;
	sub_82CA93D0(ctx, base);
	// 829F64D8: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F64DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F64E0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829F64E4: 3BFE0004  addi r31, r30, 4
	ctx.r[31].s64 = ctx.r[30].s64 + 4;
	// 829F64E8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F64EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F64F0: 419A0020  beq cr6, 0x829f6510
	if ctx.cr[6].eq {
	pc = 0x829F6510; continue 'dispatch;
	}
	// 829F64F4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F64F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F64FC: 419A000C  beq cr6, 0x829f6508
	if ctx.cr[6].eq {
	pc = 0x829F6508; continue 'dispatch;
	}
	// 829F6500: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F6504: 48000010  b 0x829f6514
	pc = 0x829F6514; continue 'dispatch;
            }
            0x829F6508 => {
    //   block [0x829F6508..0x829F6510)
	// 829F6508: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F650C: 4B79D92D  bl 0x82193e38
	ctx.lr = 0x829F6510;
	sub_82193E38(ctx, base);
	pc = 0x829F6510; continue 'dispatch;
            }
            0x829F6510 => {
    //   block [0x829F6510..0x829F6514)
	// 829F6510: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x829F6514; continue 'dispatch;
            }
            0x829F6514 => {
    //   block [0x829F6514..0x829F654C)
	// 829F6514: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829F6518: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829F651C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F6520: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 829F6524: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829F6528: 4E800421  bctrl
	ctx.lr = 0x829F652C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829F652C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F6530: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F6534: 419A0020  beq cr6, 0x829f6554
	if ctx.cr[6].eq {
	pc = 0x829F6554; continue 'dispatch;
	}
	// 829F6538: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F653C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F6540: 419A000C  beq cr6, 0x829f654c
	if ctx.cr[6].eq {
	pc = 0x829F654C; continue 'dispatch;
	}
	// 829F6544: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F6548: 48000010  b 0x829f6558
	pc = 0x829F6558; continue 'dispatch;
            }
            0x829F654C => {
    //   block [0x829F654C..0x829F6554)
	// 829F654C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F6550: 4B79D8E9  bl 0x82193e38
	ctx.lr = 0x829F6554;
	sub_82193E38(ctx, base);
	pc = 0x829F6554; continue 'dispatch;
            }
            0x829F6554 => {
    //   block [0x829F6554..0x829F6558)
	// 829F6554: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x829F6558; continue 'dispatch;
            }
            0x829F6558 => {
    //   block [0x829F6558..0x829F695C)
	// 829F6558: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829F655C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F6560: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F6564: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 829F6568: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829F656C: 4E800421  bctrl
	ctx.lr = 0x829F6570;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829F6570: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 829F6574: E8690000  ld r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 829F6578: E8890008  ld r4, 8(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	// 829F657C: 4B7FF5DD  bl 0x821f5b58
	ctx.lr = 0x829F6580;
	sub_821F5B58(ctx, base);
	// 829F6580: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F6584: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 829F6588: 3BEB92CC  addi r31, r11, -0x6d34
	ctx.r[31].s64 = ctx.r[11].s64 + -27956;
	// 829F658C: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 829F6590: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 829F6594: 38A6A940  addi r5, r6, -0x56c0
	ctx.r[5].s64 = ctx.r[6].s64 + -22208;
	// 829F6598: C01F01C4  lfs f0, 0x1c4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(452 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F659C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F6960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F6960 size=376
    let mut pc: u32 = 0x829F6960;
    'dispatch: loop {
        match pc {
            0x829F6960 => {
    //   block [0x829F6960..0x829F69A0)
	// 829F6960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F6964: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F6968: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F696C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F6970: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F6974: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F6978: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829F697C: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 829F6980: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F6984: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F6988: 419A001C  beq cr6, 0x829f69a4
	if ctx.cr[6].eq {
	pc = 0x829F69A4; continue 'dispatch;
	}
	// 829F698C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F6990: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F6994: 419A000C  beq cr6, 0x829f69a0
	if ctx.cr[6].eq {
	pc = 0x829F69A0; continue 'dispatch;
	}
	// 829F6998: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F699C: 4800000C  b 0x829f69a8
	pc = 0x829F69A8; continue 'dispatch;
            }
            0x829F69A0 => {
    //   block [0x829F69A0..0x829F69A4)
	// 829F69A0: 4B79D499  bl 0x82193e38
	ctx.lr = 0x829F69A4;
	sub_82193E38(ctx, base);
	pc = 0x829F69A4; continue 'dispatch;
            }
            0x829F69A4 => {
    //   block [0x829F69A4..0x829F69A8)
	// 829F69A4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x829F69A8; continue 'dispatch;
            }
            0x829F69A8 => {
    //   block [0x829F69A8..0x829F69E4)
	// 829F69A8: 894B0040  lbz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 829F69AC: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 829F69B0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829F69B4: 419A00F4  beq cr6, 0x829f6aa8
	if ctx.cr[6].eq {
	pc = 0x829F6AA8; continue 'dispatch;
	}
	// 829F69B8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F69BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F69C0: 419A0024  beq cr6, 0x829f69e4
	if ctx.cr[6].eq {
	pc = 0x829F69E4; continue 'dispatch;
	}
	// 829F69C4: 892A00F8  lbz r9, 0xf8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(248 as u32) ) } as u64;
	// 829F69C8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F69CC: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 829F69D0: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829F69D4: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F69D8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F69DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F69E0: 480000CC  b 0x829f6aac
	pc = 0x829F6AAC; continue 'dispatch;
            }
            0x829F69E4 => {
    //   block [0x829F69E4..0x829F6A00)
	// 829F69E4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F69E8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829F69EC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829F69F0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829F69F4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829F69F8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F69FC: 40810054  ble 0x829f6a50
	if !ctx.cr[0].gt {
	pc = 0x829F6A50; continue 'dispatch;
	}
	pc = 0x829F6A00; continue 'dispatch;
            }
            0x829F6A00 => {
    //   block [0x829F6A00..0x829F6A20)
	// 829F6A00: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829F6A04: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F6A08: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829F6A0C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F6A10: 2F0700F8  cmpwi cr6, r7, 0xf8
	ctx.cr[6].compare_i32(ctx.r[7].s32, 248, &mut ctx.xer);
	// 829F6A14: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829F6A18: 41980008  blt cr6, 0x829f6a20
	if ctx.cr[6].lt {
	pc = 0x829F6A20; continue 'dispatch;
	}
	// 829F6A1C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x829F6A20; continue 'dispatch;
            }
            0x829F6A20 => {
    //   block [0x829F6A20..0x829F6A3C)
	// 829F6A20: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829F6A24: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829F6A28: 419A0014  beq cr6, 0x829f6a3c
	if ctx.cr[6].eq {
	pc = 0x829F6A3C; continue 'dispatch;
	}
	// 829F6A2C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829F6A30: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F6A34: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F6A38: 4800000C  b 0x829f6a44
	pc = 0x829F6A44; continue 'dispatch;
            }
            0x829F6A3C => {
    //   block [0x829F6A3C..0x829F6A44)
	// 829F6A3C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829F6A40: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829F6A44; continue 'dispatch;
            }
            0x829F6A44 => {
    //   block [0x829F6A44..0x829F6A50)
	// 829F6A44: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F6A48: 4199FFB8  bgt cr6, 0x829f6a00
	if ctx.cr[6].gt {
	pc = 0x829F6A00; continue 'dispatch;
	}
	// 829F6A4C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x829F6A50; continue 'dispatch;
            }
            0x829F6A50 => {
    //   block [0x829F6A50..0x829F6A6C)
	// 829F6A50: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829F6A54: 419A0040  beq cr6, 0x829f6a94
	if ctx.cr[6].eq {
	pc = 0x829F6A94; continue 'dispatch;
	}
	// 829F6A58: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F6A5C: 2F0B00F8  cmpwi cr6, r11, 0xf8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 248, &mut ctx.xer);
	// 829F6A60: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F6A64: 41990008  bgt cr6, 0x829f6a6c
	if ctx.cr[6].gt {
	pc = 0x829F6A6C; continue 'dispatch;
	}
	// 829F6A68: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x829F6A6C; continue 'dispatch;
            }
            0x829F6A6C => {
    //   block [0x829F6A6C..0x829F6A94)
	// 829F6A6C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F6A70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F6A74: 409A0020  bne cr6, 0x829f6a94
	if !ctx.cr[6].eq {
	pc = 0x829F6A94; continue 'dispatch;
	}
	// 829F6A78: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829F6A7C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829F6A80: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F6A84: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F6A88: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F6A8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F6A90: 4800001C  b 0x829f6aac
	pc = 0x829F6AAC; continue 'dispatch;
            }
            0x829F6A94 => {
    //   block [0x829F6A94..0x829F6AA8)
	// 829F6A94: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829F6A98: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F6A9C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F6AA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F6AA4: 48000008  b 0x829f6aac
	pc = 0x829F6AAC; continue 'dispatch;
            }
            0x829F6AA8 => {
    //   block [0x829F6AA8..0x829F6AAC)
	// 829F6AA8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x829F6AAC; continue 'dispatch;
            }
            0x829F6AAC => {
    //   block [0x829F6AAC..0x829F6AC0)
	// 829F6AAC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F6AB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F6AB4: 419A000C  beq cr6, 0x829f6ac0
	if ctx.cr[6].eq {
	pc = 0x829F6AC0; continue 'dispatch;
	}
	// 829F6AB8: 817E0090  lwz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 829F6ABC: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x829F6AC0; continue 'dispatch;
            }
            0x829F6AC0 => {
    //   block [0x829F6AC0..0x829F6AD8)
	// 829F6AC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F6AC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F6AC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F6ACC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829F6AD0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F6AD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F6AD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F6AD8 size=272
    let mut pc: u32 = 0x829F6AD8;
    'dispatch: loop {
        match pc {
            0x829F6AD8 => {
    //   block [0x829F6AD8..0x829F6B0C)
	// 829F6AD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F6ADC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F6AE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F6AE4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F6AE8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F6AEC: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 829F6AF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F6AF4: 419A0020  beq cr6, 0x829f6b14
	if ctx.cr[6].eq {
	pc = 0x829F6B14; continue 'dispatch;
	}
	// 829F6AF8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F6AFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F6B00: 419A000C  beq cr6, 0x829f6b0c
	if ctx.cr[6].eq {
	pc = 0x829F6B0C; continue 'dispatch;
	}
	// 829F6B04: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F6B08: 48000010  b 0x829f6b18
	pc = 0x829F6B18; continue 'dispatch;
            }
            0x829F6B0C => {
    //   block [0x829F6B0C..0x829F6B14)
	// 829F6B0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F6B10: 4B79D329  bl 0x82193e38
	ctx.lr = 0x829F6B14;
	sub_82193E38(ctx, base);
	pc = 0x829F6B14; continue 'dispatch;
            }
            0x829F6B14 => {
    //   block [0x829F6B14..0x829F6B18)
	// 829F6B14: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829F6B18; continue 'dispatch;
            }
            0x829F6B18 => {
    //   block [0x829F6B18..0x829F6BE8)
	// 829F6B18: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829F6B1C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829F6B20: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F6B24: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 829F6B28: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829F6B2C: 4E800421  bctrl
	ctx.lr = 0x829F6B30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829F6B30: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 829F6B34: E8690000  ld r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 829F6B38: E8890008  ld r4, 8(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	// 829F6B3C: 4B7FF01D  bl 0x821f5b58
	ctx.lr = 0x829F6B40;
	sub_821F5B58(ctx, base);
	// 829F6B40: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 829F6B44: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 829F6B48: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 829F6B4C: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 829F6B50: 38869150  addi r4, r6, -0x6eb0
	ctx.r[4].s64 = ctx.r[6].s64 + -28336;
	// 829F6B54: C0089490  lfs f0, -0x6b70(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F6B58: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F6B5C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829F6B60: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F6BE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F6BE8 size=104
    let mut pc: u32 = 0x829F6BE8;
    'dispatch: loop {
        match pc {
            0x829F6BE8 => {
    //   block [0x829F6BE8..0x829F6C50)
	// 829F6BE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F6BEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F6BF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F6BF4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F6BF8: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F6BFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F6C00: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829F6C04: 388B1968  addi r4, r11, 0x1968
	ctx.r[4].s64 = ctx.r[11].s64 + 6504;
	// 829F6C08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F6C0C: 4B8362C5  bl 0x8222ced0
	ctx.lr = 0x829F6C10;
	sub_8222CED0(ctx, base);
	// 829F6C10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F6C14: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829F6C18: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829F6C1C: 3880000D  li r4, 0xd
	ctx.r[4].s64 = 13;
	// 829F6C20: 4BE54C11  bl 0x8284b830
	ctx.lr = 0x829F6C24;
	sub_8284B830(ctx, base);
	// 829F6C24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F6C28: 4B81E1B1  bl 0x82214dd8
	ctx.lr = 0x829F6C2C;
	sub_82214DD8(ctx, base);
	// 829F6C2C: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 829F6C30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F6C34: 392A19C0  addi r9, r10, 0x19c0
	ctx.r[9].s64 = ctx.r[10].s64 + 6592;
	// 829F6C38: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829F6C3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F6C40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F6C44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F6C48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F6C4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F6C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F6C50 size=364
    let mut pc: u32 = 0x829F6C50;
    'dispatch: loop {
        match pc {
            0x829F6C50 => {
    //   block [0x829F6C50..0x829F6C8C)
	// 829F6C50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F6C54: 482B27B9  bl 0x82ca940c
	ctx.lr = 0x829F6C58;
	sub_82CA93D0(ctx, base);
	// 829F6C58: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F6C5C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829F6C60: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829F6C64: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 829F6C68: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 829F6C6C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F6C70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F6C74: 419A001C  beq cr6, 0x829f6c90
	if ctx.cr[6].eq {
	pc = 0x829F6C90; continue 'dispatch;
	}
	// 829F6C78: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F6C7C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F6C80: 419A000C  beq cr6, 0x829f6c8c
	if ctx.cr[6].eq {
	pc = 0x829F6C8C; continue 'dispatch;
	}
	// 829F6C84: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F6C88: 4800000C  b 0x829f6c94
	pc = 0x829F6C94; continue 'dispatch;
            }
            0x829F6C8C => {
    //   block [0x829F6C8C..0x829F6C90)
	// 829F6C8C: 4B79D1AD  bl 0x82193e38
	ctx.lr = 0x829F6C90;
	sub_82193E38(ctx, base);
	pc = 0x829F6C90; continue 'dispatch;
            }
            0x829F6C90 => {
    //   block [0x829F6C90..0x829F6C94)
	// 829F6C90: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x829F6C94; continue 'dispatch;
            }
            0x829F6C94 => {
    //   block [0x829F6C94..0x829F6CD0)
	// 829F6C94: 894B0040  lbz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 829F6C98: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 829F6C9C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829F6CA0: 419A00F4  beq cr6, 0x829f6d94
	if ctx.cr[6].eq {
	pc = 0x829F6D94; continue 'dispatch;
	}
	// 829F6CA4: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F6CA8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F6CAC: 419A0024  beq cr6, 0x829f6cd0
	if ctx.cr[6].eq {
	pc = 0x829F6CD0; continue 'dispatch;
	}
	// 829F6CB0: 892A00F8  lbz r9, 0xf8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(248 as u32) ) } as u64;
	// 829F6CB4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F6CB8: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 829F6CBC: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829F6CC0: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F6CC4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F6CC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F6CCC: 480000CC  b 0x829f6d98
	pc = 0x829F6D98; continue 'dispatch;
            }
            0x829F6CD0 => {
    //   block [0x829F6CD0..0x829F6CEC)
	// 829F6CD0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F6CD4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829F6CD8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 829F6CDC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829F6CE0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829F6CE4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F6CE8: 40810054  ble 0x829f6d3c
	if !ctx.cr[0].gt {
	pc = 0x829F6D3C; continue 'dispatch;
	}
	pc = 0x829F6CEC; continue 'dispatch;
            }
            0x829F6CEC => {
    //   block [0x829F6CEC..0x829F6D0C)
	// 829F6CEC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829F6CF0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F6CF4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829F6CF8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F6CFC: 2F0700F8  cmpwi cr6, r7, 0xf8
	ctx.cr[6].compare_i32(ctx.r[7].s32, 248, &mut ctx.xer);
	// 829F6D00: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829F6D04: 41980008  blt cr6, 0x829f6d0c
	if ctx.cr[6].lt {
	pc = 0x829F6D0C; continue 'dispatch;
	}
	// 829F6D08: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x829F6D0C; continue 'dispatch;
            }
            0x829F6D0C => {
    //   block [0x829F6D0C..0x829F6D28)
	// 829F6D0C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829F6D10: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829F6D14: 419A0014  beq cr6, 0x829f6d28
	if ctx.cr[6].eq {
	pc = 0x829F6D28; continue 'dispatch;
	}
	// 829F6D18: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829F6D1C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F6D20: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F6D24: 4800000C  b 0x829f6d30
	pc = 0x829F6D30; continue 'dispatch;
            }
            0x829F6D28 => {
    //   block [0x829F6D28..0x829F6D30)
	// 829F6D28: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829F6D2C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829F6D30; continue 'dispatch;
            }
            0x829F6D30 => {
    //   block [0x829F6D30..0x829F6D3C)
	// 829F6D30: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F6D34: 4199FFB8  bgt cr6, 0x829f6cec
	if ctx.cr[6].gt {
	pc = 0x829F6CEC; continue 'dispatch;
	}
	// 829F6D38: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x829F6D3C; continue 'dispatch;
            }
            0x829F6D3C => {
    //   block [0x829F6D3C..0x829F6D58)
	// 829F6D3C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829F6D40: 419A0040  beq cr6, 0x829f6d80
	if ctx.cr[6].eq {
	pc = 0x829F6D80; continue 'dispatch;
	}
	// 829F6D44: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F6D48: 2F0B00F8  cmpwi cr6, r11, 0xf8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 248, &mut ctx.xer);
	// 829F6D4C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F6D50: 41990008  bgt cr6, 0x829f6d58
	if ctx.cr[6].gt {
	pc = 0x829F6D58; continue 'dispatch;
	}
	// 829F6D54: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x829F6D58; continue 'dispatch;
            }
            0x829F6D58 => {
    //   block [0x829F6D58..0x829F6D80)
	// 829F6D58: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F6D5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F6D60: 409A0020  bne cr6, 0x829f6d80
	if !ctx.cr[6].eq {
	pc = 0x829F6D80; continue 'dispatch;
	}
	// 829F6D64: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829F6D68: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829F6D6C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F6D70: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F6D74: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F6D78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F6D7C: 4800001C  b 0x829f6d98
	pc = 0x829F6D98; continue 'dispatch;
            }
            0x829F6D80 => {
    //   block [0x829F6D80..0x829F6D94)
	// 829F6D80: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829F6D84: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F6D88: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F6D8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F6D90: 48000008  b 0x829f6d98
	pc = 0x829F6D98; continue 'dispatch;
            }
            0x829F6D94 => {
    //   block [0x829F6D94..0x829F6D98)
	// 829F6D94: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x829F6D98; continue 'dispatch;
            }
            0x829F6D98 => {
    //   block [0x829F6D98..0x829F6DB4)
	// 829F6D98: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F6D9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F6DA0: 419A0014  beq cr6, 0x829f6db4
	if ctx.cr[6].eq {
	pc = 0x829F6DB4; continue 'dispatch;
	}
	// 829F6DA4: 9BDF000C  stb r30, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u8 ) };
	// 829F6DA8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F6DAC: 4B77D6BD  bl 0x82174468
	ctx.lr = 0x829F6DB0;
	sub_82174468(ctx, base);
	// 829F6DB0: 4B996A79  bl 0x8238d828
	ctx.lr = 0x829F6DB4;
	sub_8238D828(ctx, base);
	pc = 0x829F6DB4; continue 'dispatch;
            }
            0x829F6DB4 => {
    //   block [0x829F6DB4..0x829F6DBC)
	// 829F6DB4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829F6DB8: 482B26A4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F6DC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F6DC0 size=124
    let mut pc: u32 = 0x829F6DC0;
    'dispatch: loop {
        match pc {
            0x829F6DC0 => {
    //   block [0x829F6DC0..0x829F6E14)
	// 829F6DC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F6DC4: 482B2649  bl 0x82ca940c
	ctx.lr = 0x829F6DC8;
	sub_82CA93D0(ctx, base);
	// 829F6DC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F6DCC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829F6DD0: 38600080  li r3, 0x80
	ctx.r[3].s64 = 128;
	// 829F6DD4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F6DD8: 4B828481  bl 0x8221f258
	ctx.lr = 0x829F6DDC;
	sub_8221F258(ctx, base);
	// 829F6DDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F6DE0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F6DE4: 419A0030  beq cr6, 0x829f6e14
	if ctx.cr[6].eq {
	pc = 0x829F6E14; continue 'dispatch;
	}
	// 829F6DE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F6DEC: 4BA12F05  bl 0x82409cf0
	ctx.lr = 0x829F6DF0;
	sub_82409CF0(ctx, base);
	// 829F6DF0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F6DF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F6DF8: 394B1A78  addi r10, r11, 0x1a78
	ctx.r[10].s64 = ctx.r[11].s64 + 6776;
	// 829F6DFC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829F6E00: C01E0078  lfs f0, 0x78(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F6E04: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 829F6E08: C1BE007C  lfs f13, 0x7c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829F6E0C: D1BF007C  stfs f13, 0x7c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 829F6E10: 48000008  b 0x829f6e18
	pc = 0x829F6E18; continue 'dispatch;
            }
            0x829F6E14 => {
    //   block [0x829F6E14..0x829F6E18)
	// 829F6E14: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829F6E18; continue 'dispatch;
            }
            0x829F6E18 => {
    //   block [0x829F6E18..0x829F6E30)
	// 829F6E18: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F6E1C: 4B8C90FD  bl 0x822bff18
	ctx.lr = 0x829F6E20;
	sub_822BFF18(ctx, base);
	// 829F6E20: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F6E24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F6E28: 419A0008  beq cr6, 0x829f6e30
	if ctx.cr[6].eq {
	pc = 0x829F6E30; continue 'dispatch;
	}
	// 829F6E2C: 4B78A3F5  bl 0x82181220
	ctx.lr = 0x829F6E30;
	sub_82181220(ctx, base);
	pc = 0x829F6E30; continue 'dispatch;
            }
            0x829F6E30 => {
    //   block [0x829F6E30..0x829F6E3C)
	// 829F6E30: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F6E34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F6E38: 482B2624  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F6E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F6E40 size=108
    let mut pc: u32 = 0x829F6E40;
    'dispatch: loop {
        match pc {
            0x829F6E40 => {
    //   block [0x829F6E40..0x829F6E84)
	// 829F6E40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F6E44: 482B25C9  bl 0x82ca940c
	ctx.lr = 0x829F6E48;
	sub_82CA93D0(ctx, base);
	// 829F6E48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F6E4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F6E50: 38600078  li r3, 0x78
	ctx.r[3].s64 = 120;
	// 829F6E54: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 829F6E58: 4B828401  bl 0x8221f258
	ctx.lr = 0x829F6E5C;
	sub_8221F258(ctx, base);
	// 829F6E5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F6E60: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F6E64: 419A0020  beq cr6, 0x829f6e84
	if ctx.cr[6].eq {
	pc = 0x829F6E84; continue 'dispatch;
	}
	// 829F6E68: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F6E6C: 4BA12E85  bl 0x82409cf0
	ctx.lr = 0x829F6E70;
	sub_82409CF0(ctx, base);
	// 829F6E70: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F6E74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F6E78: 394B1AC8  addi r10, r11, 0x1ac8
	ctx.r[10].s64 = ctx.r[11].s64 + 6856;
	// 829F6E7C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829F6E80: 48000008  b 0x829f6e88
	pc = 0x829F6E88; continue 'dispatch;
            }
            0x829F6E84 => {
    //   block [0x829F6E84..0x829F6E88)
	// 829F6E84: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829F6E88; continue 'dispatch;
            }
            0x829F6E88 => {
    //   block [0x829F6E88..0x829F6EA0)
	// 829F6E88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F6E8C: 4B8C908D  bl 0x822bff18
	ctx.lr = 0x829F6E90;
	sub_822BFF18(ctx, base);
	// 829F6E90: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F6E94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F6E98: 419A0008  beq cr6, 0x829f6ea0
	if ctx.cr[6].eq {
	pc = 0x829F6EA0; continue 'dispatch;
	}
	// 829F6E9C: 4B78A385  bl 0x82181220
	ctx.lr = 0x829F6EA0;
	sub_82181220(ctx, base);
	pc = 0x829F6EA0; continue 'dispatch;
            }
            0x829F6EA0 => {
    //   block [0x829F6EA0..0x829F6EAC)
	// 829F6EA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F6EA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F6EA8: 482B25B4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F6EB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F6EB0 size=116
    let mut pc: u32 = 0x829F6EB0;
    'dispatch: loop {
        match pc {
            0x829F6EB0 => {
    //   block [0x829F6EB0..0x829F6EEC)
	// 829F6EB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F6EB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F6EB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F6EBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F6EC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F6EC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F6EC8: 386000AC  li r3, 0xac
	ctx.r[3].s64 = 172;
	// 829F6ECC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F6ED0: 4B828389  bl 0x8221f258
	ctx.lr = 0x829F6ED4;
	sub_8221F258(ctx, base);
	// 829F6ED4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F6ED8: 419A0014  beq cr6, 0x829f6eec
	if ctx.cr[6].eq {
	pc = 0x829F6EEC; continue 'dispatch;
	}
	// 829F6EDC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F6EE0: 48000049  bl 0x829f6f28
	ctx.lr = 0x829F6EE4;
	sub_829F6F28(ctx, base);
	// 829F6EE4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F6EE8: 48000008  b 0x829f6ef0
	pc = 0x829F6EF0; continue 'dispatch;
            }
            0x829F6EEC => {
    //   block [0x829F6EEC..0x829F6EF0)
	// 829F6EEC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829F6EF0; continue 'dispatch;
            }
            0x829F6EF0 => {
    //   block [0x829F6EF0..0x829F6F08)
	// 829F6EF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F6EF4: 4B8C9025  bl 0x822bff18
	ctx.lr = 0x829F6EF8;
	sub_822BFF18(ctx, base);
	// 829F6EF8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F6EFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F6F00: 419A0008  beq cr6, 0x829f6f08
	if ctx.cr[6].eq {
	pc = 0x829F6F08; continue 'dispatch;
	}
	// 829F6F04: 4B78A31D  bl 0x82181220
	ctx.lr = 0x829F6F08;
	sub_82181220(ctx, base);
	pc = 0x829F6F08; continue 'dispatch;
            }
            0x829F6F08 => {
    //   block [0x829F6F08..0x829F6F24)
	// 829F6F08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F6F0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F6F10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F6F14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F6F18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829F6F1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F6F20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F6F28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F6F28 size=264
    let mut pc: u32 = 0x829F6F28;
    'dispatch: loop {
        match pc {
            0x829F6F28 => {
    //   block [0x829F6F28..0x829F6F84)
	// 829F6F28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F6F2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F6F30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F6F34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F6F38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F6F3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F6F40: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F6F44: 4BA12DAD  bl 0x82409cf0
	ctx.lr = 0x829F6F48;
	sub_82409CF0(ctx, base);
	// 829F6F48: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 829F6F4C: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 829F6F50: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 829F6F54: 390BDE04  addi r8, r11, -0x21fc
	ctx.r[8].s64 = ctx.r[11].s64 + -8700;
	// 829F6F58: 38EA1B18  addi r7, r10, 0x1b18
	ctx.r[7].s64 = ctx.r[10].s64 + 6936;
	// 829F6F5C: 38C91B68  addi r6, r9, 0x1b68
	ctx.r[6].s64 = ctx.r[9].s64 + 7016;
	// 829F6F60: 911F0078  stw r8, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[8].u32 ) };
	// 829F6F64: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 829F6F68: 90DF0078  stw r6, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[6].u32 ) };
	// 829F6F6C: 80BE007C  lwz r5, 0x7c(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 829F6F70: 90BF007C  stw r5, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[5].u32 ) };
	// 829F6F74: 817E0080  lwz r11, 0x80(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 829F6F78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F6F7C: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 829F6F80: 419A0020  beq cr6, 0x829f6fa0
	if ctx.cr[6].eq {
	pc = 0x829F6FA0; continue 'dispatch;
	}
	pc = 0x829F6F84; continue 'dispatch;
            }
            0x829F6F84 => {
    //   block [0x829F6F84..0x829F6FA0)
	// 829F6F84: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829F6F88: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F6F8C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829F6F90: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F6F94: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F6F98: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F6F9C: 4082FFE8  bne 0x829f6f84
	if !ctx.cr[0].eq {
	pc = 0x829F6F84; continue 'dispatch;
	}
	pc = 0x829F6FA0; continue 'dispatch;
            }
            0x829F6FA0 => {
    //   block [0x829F6FA0..0x829F6FB8)
	// 829F6FA0: 817E0084  lwz r11, 0x84(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) } as u64;
	// 829F6FA4: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 829F6FA8: 817E0088  lwz r11, 0x88(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 829F6FAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F6FB0: 917F0088  stw r11, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 829F6FB4: 419A0020  beq cr6, 0x829f6fd4
	if ctx.cr[6].eq {
	pc = 0x829F6FD4; continue 'dispatch;
	}
	pc = 0x829F6FB8; continue 'dispatch;
            }
            0x829F6FB8 => {
    //   block [0x829F6FB8..0x829F6FD4)
	// 829F6FB8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829F6FBC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F6FC0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829F6FC4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F6FC8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F6FCC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F6FD0: 4082FFE8  bne 0x829f6fb8
	if !ctx.cr[0].eq {
	pc = 0x829F6FB8; continue 'dispatch;
	}
	pc = 0x829F6FD4; continue 'dispatch;
            }
            0x829F6FD4 => {
    //   block [0x829F6FD4..0x829F7030)
	// 829F6FD4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 829F6FD8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829F6FDC: 392B0E0C  addi r9, r11, 0xe0c
	ctx.r[9].s64 = ctx.r[11].s64 + 3596;
	// 829F6FE0: 915F0090  stw r10, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 829F6FE4: 389E00A0  addi r4, r30, 0xa0
	ctx.r[4].s64 = ctx.r[30].s64 + 160;
	// 829F6FE8: 913F008C  stw r9, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[9].u32 ) };
	// 829F6FEC: 387F00A0  addi r3, r31, 0xa0
	ctx.r[3].s64 = ctx.r[31].s64 + 160;
	// 829F6FF0: 811E0094  lwz r8, 0x94(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) } as u64;
	// 829F6FF4: 911F0094  stw r8, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[8].u32 ) };
	// 829F6FF8: C01E0098  lfs f0, 0x98(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F6FFC: D01F0098  stfs f0, 0x98(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 829F7000: 88FE009C  lbz r7, 0x9c(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(156 as u32) ) } as u64;
	// 829F7004: 98FF009C  stb r7, 0x9c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[7].u8 ) };
	// 829F7008: 88DE009D  lbz r6, 0x9d(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(157 as u32) ) } as u64;
	// 829F700C: 98DF009D  stb r6, 0x9d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(157 as u32), ctx.r[6].u8 ) };
	// 829F7010: 4BB60C79  bl 0x82557c88
	ctx.lr = 0x829F7014;
	sub_82557C88(ctx, base);
	// 829F7014: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F7018: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F701C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F7020: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F7024: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829F7028: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F702C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F7030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F7030 size=168
    let mut pc: u32 = 0x829F7030;
    'dispatch: loop {
        match pc {
            0x829F7030 => {
    //   block [0x829F7030..0x829F708C)
	// 829F7030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F7034: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F7038: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F703C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F7040: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F7044: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F7048: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F704C: 387F00A0  addi r3, r31, 0xa0
	ctx.r[3].s64 = ctx.r[31].s64 + 160;
	// 829F7050: 4BD362E9  bl 0x8272d338
	ctx.lr = 0x829F7054;
	sub_8272D338(ctx, base);
	// 829F7054: 807F00A4  lwz r3, 0xa4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 829F7058: 4B824CE1  bl 0x8221bd38
	ctx.lr = 0x829F705C;
	sub_8221BD38(ctx, base);
	// 829F705C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829F7060: 387F008C  addi r3, r31, 0x8c
	ctx.r[3].s64 = ctx.r[31].s64 + 140;
	// 829F7064: 917F00A4  stw r11, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 829F7068: 4B8A37E9  bl 0x8229a850
	ctx.lr = 0x829F706C;
	sub_8229A850(ctx, base);
	// 829F706C: 387F0084  addi r3, r31, 0x84
	ctx.r[3].s64 = ctx.r[31].s64 + 132;
	// 829F7070: 4B7C0AA9  bl 0x821b7b18
	ctx.lr = 0x829F7074;
	sub_821B7B18(ctx, base);
	// 829F7074: 387F007C  addi r3, r31, 0x7c
	ctx.r[3].s64 = ctx.r[31].s64 + 124;
	// 829F7078: 4B7C0AA1  bl 0x821b7b18
	ctx.lr = 0x829F707C;
	sub_821B7B18(ctx, base);
	// 829F707C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F7080: 397F0078  addi r11, r31, 0x78
	ctx.r[11].s64 = ctx.r[31].s64 + 120;
	// 829F7084: 409A0008  bne cr6, 0x829f708c
	if !ctx.cr[6].eq {
	pc = 0x829F708C; continue 'dispatch;
	}
	// 829F7088: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829F708C; continue 'dispatch;
            }
            0x829F708C => {
    //   block [0x829F708C..0x829F70C0)
	// 829F708C: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 829F7090: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 829F7094: 392ADE04  addi r9, r10, -0x21fc
	ctx.r[9].s64 = ctx.r[10].s64 + -8700;
	// 829F7098: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829F709C: 4B81DD3D  bl 0x82214dd8
	ctx.lr = 0x829F70A0;
	sub_82214DD8(ctx, base);
	// 829F70A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F70A4: 4B7B5A8D  bl 0x821acb30
	ctx.lr = 0x829F70A8;
	sub_821ACB30(ctx, base);
	// 829F70A8: 57C807FE  clrlwi r8, r30, 0x1f
	ctx.r[8].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 829F70AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F70B0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 829F70B4: 419A000C  beq cr6, 0x829f70c0
	if ctx.cr[6].eq {
	pc = 0x829F70C0; continue 'dispatch;
	}
	// 829F70B8: 4B824C81  bl 0x8221bd38
	ctx.lr = 0x829F70BC;
	sub_8221BD38(ctx, base);
	// 829F70BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x829F70C0; continue 'dispatch;
            }
            0x829F70C0 => {
    //   block [0x829F70C0..0x829F70D8)
	// 829F70C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F70C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F70C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F70CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829F70D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F70D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F70D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F70D8 size=420
    let mut pc: u32 = 0x829F70D8;
    'dispatch: loop {
        match pc {
            0x829F70D8 => {
    //   block [0x829F70D8..0x829F712C)
	// 829F70D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F70DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F70E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F70E4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F70E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F70EC: 4B7EC64D  bl 0x821e3738
	ctx.lr = 0x829F70F0;
	sub_821E3738(ctx, base);
	// 829F70F0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 829F70F4: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 829F70F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F70FC: 419A0030  beq cr6, 0x829f712c
	if ctx.cr[6].eq {
	pc = 0x829F712C; continue 'dispatch;
	}
	// 829F7100: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F7104: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F7108: 419A007C  beq cr6, 0x829f7184
	if ctx.cr[6].eq {
	pc = 0x829F7184; continue 'dispatch;
	}
	// 829F710C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F7110: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F7114: 419A0018  beq cr6, 0x829f712c
	if ctx.cr[6].eq {
	pc = 0x829F712C; continue 'dispatch;
	}
	// 829F7118: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 829F711C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829F7120: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F7124: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F7128: 409A0008  bne cr6, 0x829f7130
	if !ctx.cr[6].eq {
	pc = 0x829F7130; continue 'dispatch;
	}
	pc = 0x829F712C; continue 'dispatch;
            }
            0x829F712C => {
    //   block [0x829F712C..0x829F7130)
	// 829F712C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829F7130; continue 'dispatch;
            }
            0x829F7130 => {
    //   block [0x829F7130..0x829F7184)
	// 829F7130: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F7134: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F7138: 419A0130  beq cr6, 0x829f7268
	if ctx.cr[6].eq {
	pc = 0x829F7268; continue 'dispatch;
	}
	// 829F713C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F7140: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829F7144: 4B77D325  bl 0x82174468
	ctx.lr = 0x829F7148;
	sub_82174468(ctx, base);
	// 829F7148: 81630038  lwz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 829F714C: 556AC7FE  rlwinm r10, r11, 0x18, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F7150: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F7154: 419A00FC  beq cr6, 0x829f7250
	if ctx.cr[6].eq {
	pc = 0x829F7250; continue 'dispatch;
	}
	// 829F7158: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F715C: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F7160: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F7164: 419A0028  beq cr6, 0x829f718c
	if ctx.cr[6].eq {
	pc = 0x829F718C; continue 'dispatch;
	}
	// 829F7168: 896B00A8  lbz r11, 0xa8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) } as u64;
	// 829F716C: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 829F7170: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829F7174: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F7178: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F717C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F7180: 480000D4  b 0x829f7254
	pc = 0x829F7254; continue 'dispatch;
            }
            0x829F7184 => {
    //   block [0x829F7184..0x829F718C)
	// 829F7184: 4B79CCB5  bl 0x82193e38
	ctx.lr = 0x829F7188;
	sub_82193E38(ctx, base);
	// 829F7188: 4BFFFFA4  b 0x829f712c
	pc = 0x829F712C; continue 'dispatch;
            }
            0x829F718C => {
    //   block [0x829F718C..0x829F71A8)
	// 829F718C: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 829F7190: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829F7194: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829F7198: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829F719C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829F71A0: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F71A4: 40810054  ble 0x829f71f8
	if !ctx.cr[0].gt {
	pc = 0x829F71F8; continue 'dispatch;
	}
	pc = 0x829F71A8; continue 'dispatch;
            }
            0x829F71A8 => {
    //   block [0x829F71A8..0x829F71C8)
	// 829F71A8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829F71AC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F71B0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829F71B4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F71B8: 2F0700A8  cmpwi cr6, r7, 0xa8
	ctx.cr[6].compare_i32(ctx.r[7].s32, 168, &mut ctx.xer);
	// 829F71BC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829F71C0: 41980008  blt cr6, 0x829f71c8
	if ctx.cr[6].lt {
	pc = 0x829F71C8; continue 'dispatch;
	}
	// 829F71C4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x829F71C8; continue 'dispatch;
            }
            0x829F71C8 => {
    //   block [0x829F71C8..0x829F71E4)
	// 829F71C8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829F71CC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829F71D0: 419A0014  beq cr6, 0x829f71e4
	if ctx.cr[6].eq {
	pc = 0x829F71E4; continue 'dispatch;
	}
	// 829F71D4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829F71D8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F71DC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F71E0: 4800000C  b 0x829f71ec
	pc = 0x829F71EC; continue 'dispatch;
            }
            0x829F71E4 => {
    //   block [0x829F71E4..0x829F71EC)
	// 829F71E4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829F71E8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829F71EC; continue 'dispatch;
            }
            0x829F71EC => {
    //   block [0x829F71EC..0x829F71F8)
	// 829F71EC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F71F0: 4199FFB8  bgt cr6, 0x829f71a8
	if ctx.cr[6].gt {
	pc = 0x829F71A8; continue 'dispatch;
	}
	// 829F71F4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x829F71F8; continue 'dispatch;
            }
            0x829F71F8 => {
    //   block [0x829F71F8..0x829F7214)
	// 829F71F8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829F71FC: 419A0040  beq cr6, 0x829f723c
	if ctx.cr[6].eq {
	pc = 0x829F723C; continue 'dispatch;
	}
	// 829F7200: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F7204: 2F0B00A8  cmpwi cr6, r11, 0xa8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 168, &mut ctx.xer);
	// 829F7208: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F720C: 41990008  bgt cr6, 0x829f7214
	if ctx.cr[6].gt {
	pc = 0x829F7214; continue 'dispatch;
	}
	// 829F7210: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829F7214; continue 'dispatch;
            }
            0x829F7214 => {
    //   block [0x829F7214..0x829F723C)
	// 829F7214: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F7218: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F721C: 409A0020  bne cr6, 0x829f723c
	if !ctx.cr[6].eq {
	pc = 0x829F723C; continue 'dispatch;
	}
	// 829F7220: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829F7224: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829F7228: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F722C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F7230: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F7234: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F7238: 4800001C  b 0x829f7254
	pc = 0x829F7254; continue 'dispatch;
            }
            0x829F723C => {
    //   block [0x829F723C..0x829F7250)
	// 829F723C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829F7240: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F7244: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F7248: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F724C: 48000008  b 0x829f7254
	pc = 0x829F7254; continue 'dispatch;
            }
            0x829F7250 => {
    //   block [0x829F7250..0x829F7254)
	// 829F7250: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829F7254; continue 'dispatch;
            }
            0x829F7254 => {
    //   block [0x829F7254..0x829F7268)
	// 829F7254: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F7258: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F725C: 419A000C  beq cr6, 0x829f7268
	if ctx.cr[6].eq {
	pc = 0x829F7268; continue 'dispatch;
	}
	// 829F7260: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F7264: 4BF1DE1D  bl 0x82915080
	ctx.lr = 0x829F7268;
	sub_82915080(ctx, base);
	pc = 0x829F7268; continue 'dispatch;
            }
            0x829F7268 => {
    //   block [0x829F7268..0x829F727C)
	// 829F7268: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F726C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F7270: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F7274: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F7278: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F7280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F7280 size=372
    let mut pc: u32 = 0x829F7280;
    'dispatch: loop {
        match pc {
            0x829F7280 => {
    //   block [0x829F7280..0x829F72C0)
	// 829F7280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F7284: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F7288: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F728C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F7290: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F7294: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 829F7298: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829F729C: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 829F72A0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F72A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F72A8: 419A001C  beq cr6, 0x829f72c4
	if ctx.cr[6].eq {
	pc = 0x829F72C4; continue 'dispatch;
	}
	// 829F72AC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F72B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F72B4: 419A000C  beq cr6, 0x829f72c0
	if ctx.cr[6].eq {
	pc = 0x829F72C0; continue 'dispatch;
	}
	// 829F72B8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F72BC: 4800000C  b 0x829f72c8
	pc = 0x829F72C8; continue 'dispatch;
            }
            0x829F72C0 => {
    //   block [0x829F72C0..0x829F72C4)
	// 829F72C0: 4B79CB79  bl 0x82193e38
	ctx.lr = 0x829F72C4;
	sub_82193E38(ctx, base);
	pc = 0x829F72C4; continue 'dispatch;
            }
            0x829F72C4 => {
    //   block [0x829F72C4..0x829F72C8)
	// 829F72C4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x829F72C8; continue 'dispatch;
            }
            0x829F72C8 => {
    //   block [0x829F72C8..0x829F7304)
	// 829F72C8: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 829F72CC: 55490FFE  srwi r9, r10, 0x1f
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shr(31);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 829F72D0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829F72D4: 419A00F4  beq cr6, 0x829f73c8
	if ctx.cr[6].eq {
	pc = 0x829F73C8; continue 'dispatch;
	}
	// 829F72D8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F72DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F72E0: 419A0024  beq cr6, 0x829f7304
	if ctx.cr[6].eq {
	pc = 0x829F7304; continue 'dispatch;
	}
	// 829F72E4: 892A001F  lbz r9, 0x1f(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(31 as u32) ) } as u64;
	// 829F72E8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F72EC: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 829F72F0: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829F72F4: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F72F8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F72FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F7300: 480000CC  b 0x829f73cc
	pc = 0x829F73CC; continue 'dispatch;
            }
            0x829F7304 => {
    //   block [0x829F7304..0x829F7320)
	// 829F7304: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F7308: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829F730C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 829F7310: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829F7314: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829F7318: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F731C: 40810054  ble 0x829f7370
	if !ctx.cr[0].gt {
	pc = 0x829F7370; continue 'dispatch;
	}
	pc = 0x829F7320; continue 'dispatch;
            }
            0x829F7320 => {
    //   block [0x829F7320..0x829F7340)
	// 829F7320: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829F7324: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F7328: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829F732C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F7330: 2F07001F  cmpwi cr6, r7, 0x1f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 31, &mut ctx.xer);
	// 829F7334: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829F7338: 41980008  blt cr6, 0x829f7340
	if ctx.cr[6].lt {
	pc = 0x829F7340; continue 'dispatch;
	}
	// 829F733C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x829F7340; continue 'dispatch;
            }
            0x829F7340 => {
    //   block [0x829F7340..0x829F735C)
	// 829F7340: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829F7344: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829F7348: 419A0014  beq cr6, 0x829f735c
	if ctx.cr[6].eq {
	pc = 0x829F735C; continue 'dispatch;
	}
	// 829F734C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829F7350: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F7354: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F7358: 4800000C  b 0x829f7364
	pc = 0x829F7364; continue 'dispatch;
            }
            0x829F735C => {
    //   block [0x829F735C..0x829F7364)
	// 829F735C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829F7360: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829F7364; continue 'dispatch;
            }
            0x829F7364 => {
    //   block [0x829F7364..0x829F7370)
	// 829F7364: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F7368: 4199FFB8  bgt cr6, 0x829f7320
	if ctx.cr[6].gt {
	pc = 0x829F7320; continue 'dispatch;
	}
	// 829F736C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x829F7370; continue 'dispatch;
            }
            0x829F7370 => {
    //   block [0x829F7370..0x829F738C)
	// 829F7370: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829F7374: 419A0040  beq cr6, 0x829f73b4
	if ctx.cr[6].eq {
	pc = 0x829F73B4; continue 'dispatch;
	}
	// 829F7378: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F737C: 2F0B001F  cmpwi cr6, r11, 0x1f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 31, &mut ctx.xer);
	// 829F7380: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F7384: 41990008  bgt cr6, 0x829f738c
	if ctx.cr[6].gt {
	pc = 0x829F738C; continue 'dispatch;
	}
	// 829F7388: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x829F738C; continue 'dispatch;
            }
            0x829F738C => {
    //   block [0x829F738C..0x829F73B4)
	// 829F738C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F7390: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F7394: 409A0020  bne cr6, 0x829f73b4
	if !ctx.cr[6].eq {
	pc = 0x829F73B4; continue 'dispatch;
	}
	// 829F7398: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829F739C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829F73A0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F73A4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F73A8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F73AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F73B0: 4800001C  b 0x829f73cc
	pc = 0x829F73CC; continue 'dispatch;
            }
            0x829F73B4 => {
    //   block [0x829F73B4..0x829F73C8)
	// 829F73B4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829F73B8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F73BC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F73C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F73C4: 48000008  b 0x829f73cc
	pc = 0x829F73CC; continue 'dispatch;
            }
            0x829F73C8 => {
    //   block [0x829F73C8..0x829F73CC)
	// 829F73C8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x829F73CC; continue 'dispatch;
            }
            0x829F73CC => {
    //   block [0x829F73CC..0x829F73DC)
	// 829F73CC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F73D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F73D4: 419A0008  beq cr6, 0x829f73dc
	if ctx.cr[6].eq {
	pc = 0x829F73DC; continue 'dispatch;
	}
	// 829F73D8: 9BDF0019  stb r30, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[30].u8 ) };
	pc = 0x829F73DC; continue 'dispatch;
            }
            0x829F73DC => {
    //   block [0x829F73DC..0x829F73F4)
	// 829F73DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F73E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F73E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F73E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829F73EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F73F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F73F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F73F8 size=1760
    let mut pc: u32 = 0x829F73F8;
    'dispatch: loop {
        match pc {
            0x829F73F8 => {
    //   block [0x829F73F8..0x829F7478)
	// 829F73F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F73FC: 482B1FFD  bl 0x82ca93f8
	ctx.lr = 0x829F7400;
	sub_82CA93D0(ctx, base);
	// 829F7400: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 829F7404: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F7408: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829F740C: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 829F7410: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 829F7414: 897B004B  lbz r11, 0x4b(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(75 as u32) ) } as u64;
	// 829F7418: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F741C: 409A0560  bne cr6, 0x829f797c
	if !ctx.cr[6].eq {
	pc = 0x829F797C; continue 'dispatch;
	}
	// 829F7420: 4B8A7A59  bl 0x8229ee78
	ctx.lr = 0x829F7424;
	sub_8229EE78(ctx, base);
	// 829F7424: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 829F7428: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829F742C: 7F1CC378  mr r28, r24
	ctx.r[28].u64 = ctx.r[24].u64;
	// 829F7430: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 829F7434: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 829F7438: 4B77D031  bl 0x82174468
	ctx.lr = 0x829F743C;
	sub_82174468(ctx, base);
	// 829F743C: 81630038  lwz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 829F7440: 556AC7FE  rlwinm r10, r11, 0x18, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F7444: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F7448: 419A00F4  beq cr6, 0x829f753c
	if ctx.cr[6].eq {
	pc = 0x829F753C; continue 'dispatch;
	}
	// 829F744C: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F7450: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F7454: 419A0024  beq cr6, 0x829f7478
	if ctx.cr[6].eq {
	pc = 0x829F7478; continue 'dispatch;
	}
	// 829F7458: 894B00A8  lbz r10, 0xa8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) } as u64;
	// 829F745C: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F7460: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 829F7464: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829F7468: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F746C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 829F7470: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 829F7474: 480000CC  b 0x829f7540
	pc = 0x829F7540; continue 'dispatch;
            }
            0x829F7478 => {
    //   block [0x829F7478..0x829F7494)
	// 829F7478: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F747C: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 829F7480: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 829F7484: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829F7488: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829F748C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F7490: 40810054  ble 0x829f74e4
	if !ctx.cr[0].gt {
	pc = 0x829F74E4; continue 'dispatch;
	}
	pc = 0x829F7494; continue 'dispatch;
            }
            0x829F7494 => {
    //   block [0x829F7494..0x829F74B4)
	// 829F7494: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829F7498: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F749C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 829F74A0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F74A4: 2F0700A8  cmpwi cr6, r7, 0xa8
	ctx.cr[6].compare_i32(ctx.r[7].s32, 168, &mut ctx.xer);
	// 829F74A8: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 829F74AC: 41980008  blt cr6, 0x829f74b4
	if ctx.cr[6].lt {
	pc = 0x829F74B4; continue 'dispatch;
	}
	// 829F74B0: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	pc = 0x829F74B4; continue 'dispatch;
            }
            0x829F74B4 => {
    //   block [0x829F74B4..0x829F74D0)
	// 829F74B4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829F74B8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829F74BC: 419A0014  beq cr6, 0x829f74d0
	if ctx.cr[6].eq {
	pc = 0x829F74D0; continue 'dispatch;
	}
	// 829F74C0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829F74C4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F74C8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F74CC: 4800000C  b 0x829f74d8
	pc = 0x829F74D8; continue 'dispatch;
            }
            0x829F74D0 => {
    //   block [0x829F74D0..0x829F74D8)
	// 829F74D0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829F74D4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829F74D8; continue 'dispatch;
            }
            0x829F74D8 => {
    //   block [0x829F74D8..0x829F74E4)
	// 829F74D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F74DC: 4199FFB8  bgt cr6, 0x829f7494
	if ctx.cr[6].gt {
	pc = 0x829F7494; continue 'dispatch;
	}
	// 829F74E0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x829F74E4; continue 'dispatch;
            }
            0x829F74E4 => {
    //   block [0x829F74E4..0x829F7500)
	// 829F74E4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829F74E8: 419A0040  beq cr6, 0x829f7528
	if ctx.cr[6].eq {
	pc = 0x829F7528; continue 'dispatch;
	}
	// 829F74EC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F74F0: 2F0B00A8  cmpwi cr6, r11, 0xa8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 168, &mut ctx.xer);
	// 829F74F4: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 829F74F8: 41990008  bgt cr6, 0x829f7500
	if ctx.cr[6].gt {
	pc = 0x829F7500; continue 'dispatch;
	}
	// 829F74FC: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x829F7500; continue 'dispatch;
            }
            0x829F7500 => {
    //   block [0x829F7500..0x829F7528)
	// 829F7500: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F7504: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F7508: 409A0020  bne cr6, 0x829f7528
	if !ctx.cr[6].eq {
	pc = 0x829F7528; continue 'dispatch;
	}
	// 829F750C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829F7510: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829F7514: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F7518: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F751C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 829F7520: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 829F7524: 4800001C  b 0x829f7540
	pc = 0x829F7540; continue 'dispatch;
            }
            0x829F7528 => {
    //   block [0x829F7528..0x829F753C)
	// 829F7528: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829F752C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F7530: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 829F7534: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 829F7538: 48000008  b 0x829f7540
	pc = 0x829F7540; continue 'dispatch;
            }
            0x829F753C => {
    //   block [0x829F753C..0x829F7540)
	// 829F753C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x829F7540; continue 'dispatch;
            }
            0x829F7540 => {
    //   block [0x829F7540..0x829F75A0)
	// 829F7540: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829F7544: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F7548: 3BEA92D4  addi r31, r10, -0x6d2c
	ctx.r[31].s64 = ctx.r[10].s64 + -27948;
	// 829F754C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F7550: C3FF01B0  lfs f31, 0x1b0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829F7554: 419A004C  beq cr6, 0x829f75a0
	if ctx.cr[6].eq {
	pc = 0x829F75A0; continue 'dispatch;
	}
	// 829F7558: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F755C: 4BF1DB25  bl 0x82915080
	ctx.lr = 0x829F7560;
	sub_82915080(ctx, base);
	// 829F7560: C03B007C  lfs f1, 0x7c(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(124 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829F7564: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F7568: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 829F756C: 40990034  ble cr6, 0x829f75a0
	if !ctx.cr[6].gt {
	pc = 0x829F75A0; continue 'dispatch;
	}
	// 829F7570: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F7574: 4BF1B5FD  bl 0x82912b70
	ctx.lr = 0x829F7578;
	sub_82912B70(ctx, base);
	// 829F7578: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829F757C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F7580: 419A0020  beq cr6, 0x829f75a0
	if ctx.cr[6].eq {
	pc = 0x829F75A0; continue 'dispatch;
	}
	// 829F7584: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F7588: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 829F758C: 4BF1BEC5  bl 0x82913450
	ctx.lr = 0x829F7590;
	sub_82913450(ctx, base);
	// 829F7590: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829F7594: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F7598: 409A0008  bne cr6, 0x829f75a0
	if !ctx.cr[6].eq {
	pc = 0x829F75A0; continue 'dispatch;
	}
	// 829F759C: 7F59D378  mr r25, r26
	ctx.r[25].u64 = ctx.r[26].u64;
	pc = 0x829F75A0; continue 'dispatch;
            }
            0x829F75A0 => {
    //   block [0x829F75A0..0x829F76B0)
	// 829F75A0: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 829F75A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F75A8: 419A0108  beq cr6, 0x829f76b0
	if ctx.cr[6].eq {
	pc = 0x829F76B0; continue 'dispatch;
	}
	// 829F75AC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829F75B0: 4B77CEB9  bl 0x82174468
	ctx.lr = 0x829F75B4;
	sub_82174468(ctx, base);
	// 829F75B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F75B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F75BC: 4B7EFF4D  bl 0x821e7508
	ctx.lr = 0x829F75C0;
	sub_821E7508(ctx, base);
	// 829F75C0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829F75C4: 4B77CEA5  bl 0x82174468
	ctx.lr = 0x829F75C8;
	sub_82174468(ctx, base);
	// 829F75C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829F75CC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829F75D0: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829F75D4: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F75D8: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 829F75DC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 829F75E0: 4E800421  bctrl
	ctx.lr = 0x829F75E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829F75E4: 39000078  li r8, 0x78
	ctx.r[8].s64 = 120;
	// 829F75E8: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 829F75EC: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 829F75F0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829F75F4: 57DE063E  clrlwi r30, r30, 0x18
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
            }
            0x829F76B0 => {
    //   block [0x829F76B0..0x829F797C)
	// 829F76B0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829F76B4: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 829F76B8: 4B77CDB1  bl 0x82174468
	ctx.lr = 0x829F76BC;
	sub_82174468(ctx, base);
	// 829F76BC: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 829F76C0: 556AF7FE  rlwinm r10, r11, 0x1e, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 829F76C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F76C8: 419A00F4  beq cr6, 0x829f77bc
	if ctx.cr[6].eq {
	pc = 0x829F77BC; continue 'dispatch;
	}
	// 829F76CC: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F76D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F76D4: 419A0024  beq cr6, 0x829f76f8
	if ctx.cr[6].eq {
	pc = 0x829F76F8; continue 'dispatch;
	}
	// 829F76D8: 894B0022  lbz r10, 0x22(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(34 as u32) ) } as u64;
	// 829F76DC: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F76E0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 829F76E4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829F76E8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F76EC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F76F0: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 829F76F4: 480000CC  b 0x829f77c0
	pc = 0x829F77C0; continue 'dispatch;
	// 829F76F8: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F76FC: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 829F7700: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 829F7704: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829F7708: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829F770C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F7710: 40810054  ble 0x829f7764
	if !ctx.cr[0].gt {
	pc = 0x829F7764; continue 'dispatch;
	}
	// 829F7714: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829F7718: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F771C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 829F7720: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F7724: 2F070022  cmpwi cr6, r7, 0x22
	ctx.cr[6].compare_i32(ctx.r[7].s32, 34, &mut ctx.xer);
	// 829F7728: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 829F772C: 41980008  blt cr6, 0x829f7734
	if ctx.cr[6].lt {
	pc = 0x829F7734; continue 'dispatch;
	}
	// 829F7730: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 829F7734: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829F7738: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829F773C: 419A0014  beq cr6, 0x829f7750
	if ctx.cr[6].eq {
	pc = 0x829F7750; continue 'dispatch;
	}
	// 829F7740: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829F7744: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F7748: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F774C: 4800000C  b 0x829f7758
	pc = 0x829F7758; continue 'dispatch;
	// 829F7750: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829F7754: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 829F7758: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F775C: 4199FFB8  bgt cr6, 0x829f7714
	if ctx.cr[6].gt {
	pc = 0x829F7714; continue 'dispatch;
	}
	// 829F7760: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829F7764: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829F7768: 419A0040  beq cr6, 0x829f77a8
	if ctx.cr[6].eq {
	pc = 0x829F77A8; continue 'dispatch;
	}
	// 829F776C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F7770: 2F0B0022  cmpwi cr6, r11, 0x22
	ctx.cr[6].compare_i32(ctx.r[11].s32, 34, &mut ctx.xer);
	// 829F7774: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 829F7778: 41990008  bgt cr6, 0x829f7780
	if ctx.cr[6].gt {
	pc = 0x829F7780; continue 'dispatch;
	}
	// 829F777C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 829F7780: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F7784: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F7788: 409A0020  bne cr6, 0x829f77a8
	if !ctx.cr[6].eq {
	pc = 0x829F77A8; continue 'dispatch;
	}
	// 829F778C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829F7790: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829F7794: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F7798: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F779C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F77A0: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 829F77A4: 4800001C  b 0x829f77c0
	pc = 0x829F77C0; continue 'dispatch;
	// 829F77A8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829F77AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F77B0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F77B4: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 829F77B8: 48000008  b 0x829f77c0
	pc = 0x829F77C0; continue 'dispatch;
	// 829F77BC: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 829F77C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F77C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F77C8: 419A0010  beq cr6, 0x829f77d8
	if ctx.cr[6].eq {
	pc = 0x829F77D8; continue 'dispatch;
	}
	// 829F77CC: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 829F77D0: 816B9650  lwz r11, -0x69b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 829F77D4: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 829F77D8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829F77DC: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 829F77E0: 4B77CC89  bl 0x82174468
	ctx.lr = 0x829F77E4;
	sub_82174468(ctx, base);
	// 829F77E4: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 829F77E8: 556A7FFE  rlwinm r10, r11, 0xf, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0001FFFFu64;
	// 829F77EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F77F0: 419A00E8  beq cr6, 0x829f78d8
	if ctx.cr[6].eq {
	pc = 0x829F78D8; continue 'dispatch;
	}
	// 829F77F4: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F77F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F77FC: 419A0020  beq cr6, 0x829f781c
	if ctx.cr[6].eq {
	pc = 0x829F781C; continue 'dispatch;
	}
	// 829F7800: 894B0031  lbz r10, 0x31(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(49 as u32) ) } as u64;
	// 829F7804: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F7808: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 829F780C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829F7810: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 829F7814: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F7818: 480000C4  b 0x829f78dc
	pc = 0x829F78DC; continue 'dispatch;
	// 829F781C: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F7820: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 829F7824: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 829F7828: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829F782C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829F7830: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F7834: 40810054  ble 0x829f7888
	if !ctx.cr[0].gt {
	pc = 0x829F7888; continue 'dispatch;
	}
	// 829F7838: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829F783C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F7840: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 829F7844: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F7848: 2F070031  cmpwi cr6, r7, 0x31
	ctx.cr[6].compare_i32(ctx.r[7].s32, 49, &mut ctx.xer);
	// 829F784C: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 829F7850: 41980008  blt cr6, 0x829f7858
	if ctx.cr[6].lt {
	pc = 0x829F7858; continue 'dispatch;
	}
	// 829F7854: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 829F7858: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829F785C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829F7860: 419A0014  beq cr6, 0x829f7874
	if ctx.cr[6].eq {
	pc = 0x829F7874; continue 'dispatch;
	}
	// 829F7864: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829F7868: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F786C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F7870: 4800000C  b 0x829f787c
	pc = 0x829F787C; continue 'dispatch;
	// 829F7874: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829F7878: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 829F787C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F7880: 4199FFB8  bgt cr6, 0x829f7838
	if ctx.cr[6].gt {
	pc = 0x829F7838; continue 'dispatch;
	}
	// 829F7884: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829F7888: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829F788C: 419A003C  beq cr6, 0x829f78c8
	if ctx.cr[6].eq {
	pc = 0x829F78C8; continue 'dispatch;
	}
	// 829F7890: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F7894: 2F0B0031  cmpwi cr6, r11, 0x31
	ctx.cr[6].compare_i32(ctx.r[11].s32, 49, &mut ctx.xer);
	// 829F7898: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 829F789C: 41990008  bgt cr6, 0x829f78a4
	if ctx.cr[6].gt {
	pc = 0x829F78A4; continue 'dispatch;
	}
	// 829F78A0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 829F78A4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F78A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F78AC: 409A001C  bne cr6, 0x829f78c8
	if !ctx.cr[6].eq {
	pc = 0x829F78C8; continue 'dispatch;
	}
	// 829F78B0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829F78B4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829F78B8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F78BC: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F78C0: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 829F78C4: 48000018  b 0x829f78dc
	pc = 0x829F78DC; continue 'dispatch;
	// 829F78C8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829F78CC: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F78D0: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 829F78D4: 48000008  b 0x829f78dc
	pc = 0x829F78DC; continue 'dispatch;
	// 829F78D8: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 829F78DC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F78E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F78E4: 419A0098  beq cr6, 0x829f797c
	if ctx.cr[6].eq {
	pc = 0x829F797C; continue 'dispatch;
	}
	// 829F78E8: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F78EC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829F78F0: 388B1A38  addi r4, r11, 0x1a38
	ctx.r[4].s64 = ctx.r[11].s64 + 6712;
	// 829F78F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F78F8: 4B8355D9  bl 0x8222ced0
	ctx.lr = 0x829F78FC;
	sub_8222CED0(ctx, base);
	// 829F78FC: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 829F7900: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829F7904: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 829F7908: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829F790C: 4BE53F25  bl 0x8284b830
	ctx.lr = 0x829F7910;
	sub_8284B830(ctx, base);
	// 829F7910: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F7914: 4B81D4C5  bl 0x82214dd8
	ctx.lr = 0x829F7918;
	sub_82214DD8(ctx, base);
	// 829F7918: 810100C8  lwz r8, 0xc8(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 829F791C: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 829F7920: 9B010104  stb r24, 0x104(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[24].u8 ) };
	// 829F7924: 61070004  ori r7, r8, 4
	ctx.r[7].u64 = ctx.r[8].u64 | 4;
	// 829F7928: 392A1AC8  addi r9, r10, 0x1ac8
	ctx.r[9].s64 = ctx.r[10].s64 + 6856;
	// 829F792C: 90E100C8  stw r7, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[7].u32 ) };
	// 829F7930: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829F7934: 91210090  stw r9, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[9].u32 ) };
	// 829F7938: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 829F793C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F7940: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F7944: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F7948: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 829F794C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829F7950: 4E800421  bctrl
	ctx.lr = 0x829F7954;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829F7954: 386100E4  addi r3, r1, 0xe4
	ctx.r[3].s64 = ctx.r[1].s64 + 228;
	// 829F7958: 4B81D481  bl 0x82214dd8
	ctx.lr = 0x829F795C;
	sub_82214DD8(ctx, base);
	// 829F795C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829F7960: 4B7B51D1  bl 0x821acb30
	ctx.lr = 0x829F7964;
	sub_821ACB30(ctx, base);
	// 829F7964: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 829F7968: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F796C: 39090B7C  addi r8, r9, 0xb7c
	ctx.r[8].s64 = ctx.r[9].s64 + 2940;
	// 829F7970: 91010060  stw r8, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 829F7974: 4B79C4C5  bl 0x82193e38
	ctx.lr = 0x829F7978;
	sub_82193E38(ctx, base);
	// 829F7978: 93410064  stw r26, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[26].u32 ) };
            }
            0x829F797C => {
    //   block [0x829F797C..0x829F7AD8)
	// 829F797C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F7980: 387B0004  addi r3, r27, 4
	ctx.r[3].s64 = ctx.r[27].s64 + 4;
	// 829F7984: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 829F7988: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F798C: 419A001C  beq cr6, 0x829f79a8
	if ctx.cr[6].eq {
	pc = 0x829F79A8; continue 'dispatch;
	}
	// 829F7990: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F7994: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F7998: 419A000C  beq cr6, 0x829f79a4
	if ctx.cr[6].eq {
	pc = 0x829F79A4; continue 'dispatch;
	}
	// 829F799C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F79A0: 4800000C  b 0x829f79ac
	pc = 0x829F79AC; continue 'dispatch;
	// 829F79A4: 4B79C495  bl 0x82193e38
	ctx.lr = 0x829F79A8;
	sub_82193E38(ctx, base);
	// 829F79A8: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 829F79AC: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 829F79B0: 55490FFE  srwi r9, r10, 0x1f
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shr(31);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 829F79B4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829F79B8: 419A00F4  beq cr6, 0x829f7aac
	if ctx.cr[6].eq {
	pc = 0x829F7AAC; continue 'dispatch;
	}
	// 829F79BC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F79C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F79C4: 419A0024  beq cr6, 0x829f79e8
	if ctx.cr[6].eq {
	pc = 0x829F79E8; continue 'dispatch;
	}
	// 829F79C8: 894A001F  lbz r10, 0x1f(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(31 as u32) ) } as u64;
	// 829F79CC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F79D0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 829F79D4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829F79D8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F79DC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F79E0: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 829F79E4: 480000CC  b 0x829f7ab0
	pc = 0x829F7AB0; continue 'dispatch;
	// 829F79E8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F79EC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829F79F0: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 829F79F4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829F79F8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829F79FC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F7A00: 40810054  ble 0x829f7a54
	if !ctx.cr[0].gt {
	pc = 0x829F7A54; continue 'dispatch;
	}
	// 829F7A04: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829F7A08: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F7A0C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 829F7A10: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F7A14: 2F07001F  cmpwi cr6, r7, 0x1f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 31, &mut ctx.xer);
	// 829F7A18: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 829F7A1C: 41980008  blt cr6, 0x829f7a24
	if ctx.cr[6].lt {
	pc = 0x829F7A24; continue 'dispatch;
	}
	// 829F7A20: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 829F7A24: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829F7A28: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829F7A2C: 419A0014  beq cr6, 0x829f7a40
	if ctx.cr[6].eq {
	pc = 0x829F7A40; continue 'dispatch;
	}
	// 829F7A30: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829F7A34: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F7A38: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F7A3C: 4800000C  b 0x829f7a48
	pc = 0x829F7A48; continue 'dispatch;
	// 829F7A40: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829F7A44: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 829F7A48: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F7A4C: 4199FFB8  bgt cr6, 0x829f7a04
	if ctx.cr[6].gt {
	pc = 0x829F7A04; continue 'dispatch;
	}
	// 829F7A50: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829F7A54: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829F7A58: 419A0040  beq cr6, 0x829f7a98
	if ctx.cr[6].eq {
	pc = 0x829F7A98; continue 'dispatch;
	}
	// 829F7A5C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F7A60: 2F0B001F  cmpwi cr6, r11, 0x1f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 31, &mut ctx.xer);
	// 829F7A64: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 829F7A68: 41990008  bgt cr6, 0x829f7a70
	if ctx.cr[6].gt {
	pc = 0x829F7A70; continue 'dispatch;
	}
	// 829F7A6C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 829F7A70: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F7A74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F7A78: 409A0020  bne cr6, 0x829f7a98
	if !ctx.cr[6].eq {
	pc = 0x829F7A98; continue 'dispatch;
	}
	// 829F7A7C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829F7A80: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829F7A84: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F7A88: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F7A8C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F7A90: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 829F7A94: 4800001C  b 0x829f7ab0
	pc = 0x829F7AB0; continue 'dispatch;
	// 829F7A98: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829F7A9C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F7AA0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F7AA4: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 829F7AA8: 48000008  b 0x829f7ab0
	pc = 0x829F7AB0; continue 'dispatch;
	// 829F7AAC: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 829F7AB0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F7AB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F7AB8: 419A0014  beq cr6, 0x829f7acc
	if ctx.cr[6].eq {
	pc = 0x829F7ACC; continue 'dispatch;
	}
	// 829F7ABC: 9B1F0019  stb r24, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[24].u8 ) };
	// 829F7AC0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829F7AC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F7AC8: 4BBCD5C9  bl 0x825c5090
	ctx.lr = 0x829F7ACC;
	sub_825C5090(ctx, base);
	// 829F7ACC: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 829F7AD0: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 829F7AD4: 482B1974  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F7AD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F7AD8 size=552
    let mut pc: u32 = 0x829F7AD8;
    'dispatch: loop {
        match pc {
            0x829F7AD8 => {
    //   block [0x829F7AD8..0x829F7B2C)
	// 829F7AD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F7ADC: 482B1931  bl 0x82ca940c
	ctx.lr = 0x829F7AE0;
	sub_82CA93D0(ctx, base);
	// 829F7AE0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F7AE4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829F7AE8: 4B7EBC51  bl 0x821e3738
	ctx.lr = 0x829F7AEC;
	sub_821E3738(ctx, base);
	// 829F7AEC: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 829F7AF0: 387D000C  addi r3, r29, 0xc
	ctx.r[3].s64 = ctx.r[29].s64 + 12;
	// 829F7AF4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829F7AF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F7AFC: 419A0030  beq cr6, 0x829f7b2c
	if ctx.cr[6].eq {
	pc = 0x829F7B2C; continue 'dispatch;
	}
	// 829F7B00: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F7B04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F7B08: 419A0078  beq cr6, 0x829f7b80
	if ctx.cr[6].eq {
	pc = 0x829F7B80; continue 'dispatch;
	}
	// 829F7B0C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F7B10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F7B14: 419A0018  beq cr6, 0x829f7b2c
	if ctx.cr[6].eq {
	pc = 0x829F7B2C; continue 'dispatch;
	}
	// 829F7B18: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 829F7B1C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829F7B20: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F7B24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F7B28: 409A0008  bne cr6, 0x829f7b30
	if !ctx.cr[6].eq {
	pc = 0x829F7B30; continue 'dispatch;
	}
	pc = 0x829F7B2C; continue 'dispatch;
            }
            0x829F7B2C => {
    //   block [0x829F7B2C..0x829F7B30)
	// 829F7B2C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x829F7B30; continue 'dispatch;
            }
            0x829F7B30 => {
    //   block [0x829F7B30..0x829F7B80)
	// 829F7B30: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F7B34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F7B38: 419A0070  beq cr6, 0x829f7ba8
	if ctx.cr[6].eq {
	pc = 0x829F7BA8; continue 'dispatch;
	}
	// 829F7B3C: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 829F7B40: 4B827719  bl 0x8221f258
	ctx.lr = 0x829F7B44;
	sub_8221F258(ctx, base);
	// 829F7B44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F7B48: 419A0040  beq cr6, 0x829f7b88
	if ctx.cr[6].eq {
	pc = 0x829F7B88; continue 'dispatch;
	}
	// 829F7B4C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F7B50: 93A30004  stw r29, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 829F7B54: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829F7B58: 9BC30010  stb r30, 0x10(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[30].u8 ) };
	// 829F7B5C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 829F7B60: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F7B64: 3909B6C0  addi r8, r9, -0x4940
	ctx.r[8].s64 = ctx.r[9].s64 + -18752;
	// 829F7B68: C00B9040  lfs f0, -0x6fc0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28608 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F7B6C: C1AA9484  lfs f13, -0x6b7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829F7B70: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 829F7B74: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829F7B78: D1A3000C  stfs f13, 0xc(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829F7B7C: 48000010  b 0x829f7b8c
	pc = 0x829F7B8C; continue 'dispatch;
            }
            0x829F7B80 => {
    //   block [0x829F7B80..0x829F7B88)
	// 829F7B80: 4B79C2B9  bl 0x82193e38
	ctx.lr = 0x829F7B84;
	sub_82193E38(ctx, base);
	// 829F7B84: 4BFFFFA8  b 0x829f7b2c
	pc = 0x829F7B2C; continue 'dispatch;
            }
            0x829F7B88 => {
    //   block [0x829F7B88..0x829F7B8C)
	// 829F7B88: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	pc = 0x829F7B8C; continue 'dispatch;
            }
            0x829F7B8C => {
    //   block [0x829F7B8C..0x829F7BA8)
	// 829F7B8C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829F7B90: 4B7C3F21  bl 0x821bbab0
	ctx.lr = 0x829F7B94;
	sub_821BBAB0(ctx, base);
	// 829F7B94: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F7B98: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F7B9C: 4B8742CD  bl 0x8226be68
	ctx.lr = 0x829F7BA0;
	sub_8226BE68(ctx, base);
	// 829F7BA0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829F7BA4: 4B7BFF75  bl 0x821b7b18
	ctx.lr = 0x829F7BA8;
	sub_821B7B18(ctx, base);
	pc = 0x829F7BA8; continue 'dispatch;
            }
            0x829F7BA8 => {
    //   block [0x829F7BA8..0x829F7BD0)
	// 829F7BA8: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F7BAC: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 829F7BB0: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 829F7BB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F7BB8: 419A001C  beq cr6, 0x829f7bd4
	if ctx.cr[6].eq {
	pc = 0x829F7BD4; continue 'dispatch;
	}
	// 829F7BBC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F7BC0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F7BC4: 419A000C  beq cr6, 0x829f7bd0
	if ctx.cr[6].eq {
	pc = 0x829F7BD0; continue 'dispatch;
	}
	// 829F7BC8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F7BCC: 4800000C  b 0x829f7bd8
	pc = 0x829F7BD8; continue 'dispatch;
            }
            0x829F7BD0 => {
    //   block [0x829F7BD0..0x829F7BD4)
	// 829F7BD0: 4B79C269  bl 0x82193e38
	ctx.lr = 0x829F7BD4;
	sub_82193E38(ctx, base);
	pc = 0x829F7BD4; continue 'dispatch;
            }
            0x829F7BD4 => {
    //   block [0x829F7BD4..0x829F7BD8)
	// 829F7BD4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x829F7BD8; continue 'dispatch;
            }
            0x829F7BD8 => {
    //   block [0x829F7BD8..0x829F7C14)
	// 829F7BD8: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 829F7BDC: 55490FFE  srwi r9, r10, 0x1f
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shr(31);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 829F7BE0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829F7BE4: 419A00F4  beq cr6, 0x829f7cd8
	if ctx.cr[6].eq {
	pc = 0x829F7CD8; continue 'dispatch;
	}
	// 829F7BE8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F7BEC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F7BF0: 419A0024  beq cr6, 0x829f7c14
	if ctx.cr[6].eq {
	pc = 0x829F7C14; continue 'dispatch;
	}
	// 829F7BF4: 894A001F  lbz r10, 0x1f(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(31 as u32) ) } as u64;
	// 829F7BF8: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F7BFC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 829F7C00: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829F7C04: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F7C08: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F7C0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F7C10: 480000CC  b 0x829f7cdc
	pc = 0x829F7CDC; continue 'dispatch;
            }
            0x829F7C14 => {
    //   block [0x829F7C14..0x829F7C30)
	// 829F7C14: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F7C18: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829F7C1C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 829F7C20: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829F7C24: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829F7C28: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F7C2C: 40810054  ble 0x829f7c80
	if !ctx.cr[0].gt {
	pc = 0x829F7C80; continue 'dispatch;
	}
	pc = 0x829F7C30; continue 'dispatch;
            }
            0x829F7C30 => {
    //   block [0x829F7C30..0x829F7C50)
	// 829F7C30: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829F7C34: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F7C38: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829F7C3C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F7C40: 2F07001F  cmpwi cr6, r7, 0x1f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 31, &mut ctx.xer);
	// 829F7C44: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829F7C48: 41980008  blt cr6, 0x829f7c50
	if ctx.cr[6].lt {
	pc = 0x829F7C50; continue 'dispatch;
	}
	// 829F7C4C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x829F7C50; continue 'dispatch;
            }
            0x829F7C50 => {
    //   block [0x829F7C50..0x829F7C6C)
	// 829F7C50: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829F7C54: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829F7C58: 419A0014  beq cr6, 0x829f7c6c
	if ctx.cr[6].eq {
	pc = 0x829F7C6C; continue 'dispatch;
	}
	// 829F7C5C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829F7C60: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F7C64: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F7C68: 4800000C  b 0x829f7c74
	pc = 0x829F7C74; continue 'dispatch;
            }
            0x829F7C6C => {
    //   block [0x829F7C6C..0x829F7C74)
	// 829F7C6C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829F7C70: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829F7C74; continue 'dispatch;
            }
            0x829F7C74 => {
    //   block [0x829F7C74..0x829F7C80)
	// 829F7C74: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F7C78: 4199FFB8  bgt cr6, 0x829f7c30
	if ctx.cr[6].gt {
	pc = 0x829F7C30; continue 'dispatch;
	}
	// 829F7C7C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x829F7C80; continue 'dispatch;
            }
            0x829F7C80 => {
    //   block [0x829F7C80..0x829F7C9C)
	// 829F7C80: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829F7C84: 419A0040  beq cr6, 0x829f7cc4
	if ctx.cr[6].eq {
	pc = 0x829F7CC4; continue 'dispatch;
	}
	// 829F7C88: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F7C8C: 2F0B001F  cmpwi cr6, r11, 0x1f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 31, &mut ctx.xer);
	// 829F7C90: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F7C94: 41990008  bgt cr6, 0x829f7c9c
	if ctx.cr[6].gt {
	pc = 0x829F7C9C; continue 'dispatch;
	}
	// 829F7C98: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x829F7C9C; continue 'dispatch;
            }
            0x829F7C9C => {
    //   block [0x829F7C9C..0x829F7CC4)
	// 829F7C9C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F7CA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F7CA4: 409A0020  bne cr6, 0x829f7cc4
	if !ctx.cr[6].eq {
	pc = 0x829F7CC4; continue 'dispatch;
	}
	// 829F7CA8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829F7CAC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829F7CB0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F7CB4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F7CB8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F7CBC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F7CC0: 4800001C  b 0x829f7cdc
	pc = 0x829F7CDC; continue 'dispatch;
            }
            0x829F7CC4 => {
    //   block [0x829F7CC4..0x829F7CD8)
	// 829F7CC4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829F7CC8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F7CCC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F7CD0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F7CD4: 48000008  b 0x829f7cdc
	pc = 0x829F7CDC; continue 'dispatch;
            }
            0x829F7CD8 => {
    //   block [0x829F7CD8..0x829F7CDC)
	// 829F7CD8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x829F7CDC; continue 'dispatch;
            }
            0x829F7CDC => {
    //   block [0x829F7CDC..0x829F7CEC)
	// 829F7CDC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F7CE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F7CE4: 419A0008  beq cr6, 0x829f7cec
	if ctx.cr[6].eq {
	pc = 0x829F7CEC; continue 'dispatch;
	}
	// 829F7CE8: 9BDF0019  stb r30, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[30].u8 ) };
	pc = 0x829F7CEC; continue 'dispatch;
            }
            0x829F7CEC => {
    //   block [0x829F7CEC..0x829F7D00)
	// 829F7CEC: 817D0038  lwz r11, 0x38(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 829F7CF0: 616A0002  ori r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u64 | 2;
	// 829F7CF4: 915D0038  stw r10, 0x38(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 829F7CF8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829F7CFC: 482B1760  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F7D00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F7D00 size=376
    let mut pc: u32 = 0x829F7D00;
    'dispatch: loop {
        match pc {
            0x829F7D00 => {
    //   block [0x829F7D00..0x829F7D38)
	// 829F7D00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F7D04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F7D08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F7D0C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F7D10: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 829F7D14: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829F7D18: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F7D1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F7D20: 419A001C  beq cr6, 0x829f7d3c
	if ctx.cr[6].eq {
	pc = 0x829F7D3C; continue 'dispatch;
	}
	// 829F7D24: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F7D28: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F7D2C: 419A000C  beq cr6, 0x829f7d38
	if ctx.cr[6].eq {
	pc = 0x829F7D38; continue 'dispatch;
	}
	// 829F7D30: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F7D34: 4800000C  b 0x829f7d40
	pc = 0x829F7D40; continue 'dispatch;
            }
            0x829F7D38 => {
    //   block [0x829F7D38..0x829F7D3C)
	// 829F7D38: 4B79C101  bl 0x82193e38
	ctx.lr = 0x829F7D3C;
	sub_82193E38(ctx, base);
	pc = 0x829F7D3C; continue 'dispatch;
            }
            0x829F7D3C => {
    //   block [0x829F7D3C..0x829F7D40)
	// 829F7D3C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x829F7D40; continue 'dispatch;
            }
            0x829F7D40 => {
    //   block [0x829F7D40..0x829F7D7C)
	// 829F7D40: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 829F7D44: 55490FFE  srwi r9, r10, 0x1f
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shr(31);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 829F7D48: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829F7D4C: 419A00F4  beq cr6, 0x829f7e40
	if ctx.cr[6].eq {
	pc = 0x829F7E40; continue 'dispatch;
	}
	// 829F7D50: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F7D54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F7D58: 419A0024  beq cr6, 0x829f7d7c
	if ctx.cr[6].eq {
	pc = 0x829F7D7C; continue 'dispatch;
	}
	// 829F7D5C: 892A001F  lbz r9, 0x1f(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(31 as u32) ) } as u64;
	// 829F7D60: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F7D64: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 829F7D68: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829F7D6C: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F7D70: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F7D74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F7D78: 480000CC  b 0x829f7e44
	pc = 0x829F7E44; continue 'dispatch;
            }
            0x829F7D7C => {
    //   block [0x829F7D7C..0x829F7D98)
	// 829F7D7C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F7D80: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829F7D84: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829F7D88: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829F7D8C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829F7D90: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F7D94: 40810054  ble 0x829f7de8
	if !ctx.cr[0].gt {
	pc = 0x829F7DE8; continue 'dispatch;
	}
	pc = 0x829F7D98; continue 'dispatch;
            }
            0x829F7D98 => {
    //   block [0x829F7D98..0x829F7DB8)
	// 829F7D98: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829F7D9C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F7DA0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829F7DA4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F7DA8: 2F07001F  cmpwi cr6, r7, 0x1f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 31, &mut ctx.xer);
	// 829F7DAC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829F7DB0: 41980008  blt cr6, 0x829f7db8
	if ctx.cr[6].lt {
	pc = 0x829F7DB8; continue 'dispatch;
	}
	// 829F7DB4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x829F7DB8; continue 'dispatch;
            }
            0x829F7DB8 => {
    //   block [0x829F7DB8..0x829F7DD4)
	// 829F7DB8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829F7DBC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829F7DC0: 419A0014  beq cr6, 0x829f7dd4
	if ctx.cr[6].eq {
	pc = 0x829F7DD4; continue 'dispatch;
	}
	// 829F7DC4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829F7DC8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F7DCC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F7DD0: 4800000C  b 0x829f7ddc
	pc = 0x829F7DDC; continue 'dispatch;
            }
            0x829F7DD4 => {
    //   block [0x829F7DD4..0x829F7DDC)
	// 829F7DD4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829F7DD8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829F7DDC; continue 'dispatch;
            }
            0x829F7DDC => {
    //   block [0x829F7DDC..0x829F7DE8)
	// 829F7DDC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F7DE0: 4199FFB8  bgt cr6, 0x829f7d98
	if ctx.cr[6].gt {
	pc = 0x829F7D98; continue 'dispatch;
	}
	// 829F7DE4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x829F7DE8; continue 'dispatch;
            }
            0x829F7DE8 => {
    //   block [0x829F7DE8..0x829F7E04)
	// 829F7DE8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829F7DEC: 419A0040  beq cr6, 0x829f7e2c
	if ctx.cr[6].eq {
	pc = 0x829F7E2C; continue 'dispatch;
	}
	// 829F7DF0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F7DF4: 2F0B001F  cmpwi cr6, r11, 0x1f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 31, &mut ctx.xer);
	// 829F7DF8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F7DFC: 41990008  bgt cr6, 0x829f7e04
	if ctx.cr[6].gt {
	pc = 0x829F7E04; continue 'dispatch;
	}
	// 829F7E00: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x829F7E04; continue 'dispatch;
            }
            0x829F7E04 => {
    //   block [0x829F7E04..0x829F7E2C)
	// 829F7E04: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F7E08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F7E0C: 409A0020  bne cr6, 0x829f7e2c
	if !ctx.cr[6].eq {
	pc = 0x829F7E2C; continue 'dispatch;
	}
	// 829F7E10: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829F7E14: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829F7E18: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F7E1C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F7E20: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F7E24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F7E28: 4800001C  b 0x829f7e44
	pc = 0x829F7E44; continue 'dispatch;
            }
            0x829F7E2C => {
    //   block [0x829F7E2C..0x829F7E40)
	// 829F7E2C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829F7E30: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F7E34: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F7E38: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F7E3C: 48000008  b 0x829f7e44
	pc = 0x829F7E44; continue 'dispatch;
            }
            0x829F7E40 => {
    //   block [0x829F7E40..0x829F7E44)
	// 829F7E40: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x829F7E44; continue 'dispatch;
            }
            0x829F7E44 => {
    //   block [0x829F7E44..0x829F7E64)
	// 829F7E44: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F7E48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F7E4C: 419A0018  beq cr6, 0x829f7e64
	if ctx.cr[6].eq {
	pc = 0x829F7E64; continue 'dispatch;
	}
	// 829F7E50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F7E54: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829F7E58: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 829F7E5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F7E60: 4BBCD231  bl 0x825c5090
	ctx.lr = 0x829F7E64;
	sub_825C5090(ctx, base);
	pc = 0x829F7E64; continue 'dispatch;
            }
            0x829F7E64 => {
    //   block [0x829F7E64..0x829F7E78)
	// 829F7E64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F7E68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F7E6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F7E70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F7E74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F7E78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F7E78 size=404
    let mut pc: u32 = 0x829F7E78;
    'dispatch: loop {
        match pc {
            0x829F7E78 => {
    //   block [0x829F7E78..0x829F7FA4)
	// 829F7E78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F7E7C: 482B158D  bl 0x82ca9408
	ctx.lr = 0x829F7E80;
	sub_82CA93D0(ctx, base);
	// 829F7E80: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F7E84: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F7E88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F7E8C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F7E90: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829F7E94: 388B1A44  addi r4, r11, 0x1a44
	ctx.r[4].s64 = ctx.r[11].s64 + 6724;
	// 829F7E98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F7E9C: 4B835035  bl 0x8222ced0
	ctx.lr = 0x829F7EA0;
	sub_8222CED0(ctx, base);
	// 829F7EA0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F7EA4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 829F7EA8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829F7EAC: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 829F7EB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F7EB4: 4B79B71D  bl 0x821935d0
	ctx.lr = 0x829F7EB8;
	sub_821935D0(ctx, base);
	// 829F7EB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F7EBC: 4B81CF1D  bl 0x82214dd8
	ctx.lr = 0x829F7EC0;
	sub_82214DD8(ctx, base);
	// 829F7EC0: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 829F7EC4: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 829F7EC8: 3D00820F  lis r8, -0x7df1
	ctx.r[8].s64 = -2112946176;
	// 829F7ECC: 38EADE04  addi r7, r10, -0x21fc
	ctx.r[7].s64 = ctx.r[10].s64 + -8700;
	// 829F7ED0: 38C91B18  addi r6, r9, 0x1b18
	ctx.r[6].s64 = ctx.r[9].s64 + 6936;
	// 829F7ED4: 38A81B68  addi r5, r8, 0x1b68
	ctx.r[5].s64 = ctx.r[8].s64 + 7016;
	// 829F7ED8: 90FF0078  stw r7, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[7].u32 ) };
	// 829F7EDC: 3C80820D  lis r4, -0x7df3
	ctx.r[4].s64 = -2113077248;
	// 829F7EE0: 90DF0000  stw r6, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 829F7EE4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829F7EE8: 90BF0078  stw r5, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[5].u32 ) };
	// 829F7EEC: 39440E0C  addi r10, r4, 0xe0c
	ctx.r[10].s64 = ctx.r[4].s64 + 3596;
	// 829F7EF0: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 829F7EF4: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829F7EF8: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 829F7EFC: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 829F7F00: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 829F7F04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F7F08: 917F0088  stw r11, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 829F7F0C: 38885CA0  addi r4, r8, 0x5ca0
	ctx.r[4].s64 = ctx.r[8].s64 + 23712;
	// 829F7F10: 915F008C  stw r10, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	// 829F7F14: 3BBF007C  addi r29, r31, 0x7c
	ctx.r[29].s64 = ctx.r[31].s64 + 124;
	// 829F7F18: 917F0090  stw r11, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 829F7F1C: C0299490  lfs f1, -0x6b70(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829F7F20: 3B9F0084  addi r28, r31, 0x84
	ctx.r[28].s64 = ctx.r[31].s64 + 132;
	// 829F7F24: 4B7E7535  bl 0x821df458
	ctx.lr = 0x829F7F28;
	sub_821DF458(ctx, base);
	// 829F7F28: D03F0098  stfs f1, 0x98(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 829F7F2C: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 829F7F30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F7F34: 3887123C  addi r4, r7, 0x123c
	ctx.r[4].s64 = ctx.r[7].s64 + 4668;
	// 829F7F38: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829F7F3C: 4B7EC37D  bl 0x821e42b8
	ctx.lr = 0x829F7F40;
	sub_821E42B8(ctx, base);
	// 829F7F40: 987F009C  stb r3, 0x9c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[3].u8 ) };
	// 829F7F44: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 829F7F48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F7F4C: 38861220  addi r4, r6, 0x1220
	ctx.r[4].s64 = ctx.r[6].s64 + 4640;
	// 829F7F50: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829F7F54: 4B7EC365  bl 0x821e42b8
	ctx.lr = 0x829F7F58;
	sub_821E42B8(ctx, base);
	// 829F7F58: 987F009D  stb r3, 0x9d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(157 as u32), ctx.r[3].u8 ) };
	// 829F7F5C: 387F00A0  addi r3, r31, 0xa0
	ctx.r[3].s64 = ctx.r[31].s64 + 160;
	// 829F7F60: 4BE50051  bl 0x82847fb0
	ctx.lr = 0x829F7F64;
	sub_82847FB0(ctx, base);
	// 829F7F64: 3CA0820F  lis r5, -0x7df1
	ctx.r[5].s64 = -2112946176;
	// 829F7F68: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F7F6C: 38A51A50  addi r5, r5, 0x1a50
	ctx.r[5].s64 = ctx.r[5].s64 + 6736;
	// 829F7F70: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F7F74: 4B9D619D  bl 0x823ce110
	ctx.lr = 0x829F7F78;
	sub_823CE110(ctx, base);
	// 829F7F78: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 829F7F7C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 829F7F80: 419A0024  beq cr6, 0x829f7fa4
	if ctx.cr[6].eq {
	pc = 0x829F7FA4; continue 'dispatch;
	}
	// 829F7F84: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 829F7F88: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829F7F8C: 4B792955  bl 0x8218a8e0
	ctx.lr = 0x829F7F90;
	sub_8218A8E0(ctx, base);
	// 829F7F90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F7F94: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F7F98: 4B783401  bl 0x8217b398
	ctx.lr = 0x829F7F9C;
	sub_8217B398(ctx, base);
	// 829F7F9C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829F7FA0: 4B7BFB79  bl 0x821b7b18
	ctx.lr = 0x829F7FA4;
	sub_821B7B18(ctx, base);
	pc = 0x829F7FA4; continue 'dispatch;
            }
            0x829F7FA4 => {
    //   block [0x829F7FA4..0x829F7FE4)
	// 829F7FA4: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F7FA8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F7FAC: 38AB1A60  addi r5, r11, 0x1a60
	ctx.r[5].s64 = ctx.r[11].s64 + 6752;
	// 829F7FB0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829F7FB4: 4B9D615D  bl 0x823ce110
	ctx.lr = 0x829F7FB8;
	sub_823CE110(ctx, base);
	// 829F7FB8: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829F7FBC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F7FC0: 419A0024  beq cr6, 0x829f7fe4
	if ctx.cr[6].eq {
	pc = 0x829F7FE4; continue 'dispatch;
	}
	// 829F7FC4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829F7FC8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829F7FCC: 4B792915  bl 0x8218a8e0
	ctx.lr = 0x829F7FD0;
	sub_8218A8E0(ctx, base);
	// 829F7FD0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F7FD4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829F7FD8: 4B7833C1  bl 0x8217b398
	ctx.lr = 0x829F7FDC;
	sub_8217B398(ctx, base);
	// 829F7FDC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829F7FE0: 4B7BFB39  bl 0x821b7b18
	ctx.lr = 0x829F7FE4;
	sub_821B7B18(ctx, base);
	pc = 0x829F7FE4; continue 'dispatch;
            }
            0x829F7FE4 => {
    //   block [0x829F7FE4..0x829F800C)
	// 829F7FE4: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 829F7FE8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829F7FEC: 616A0004  ori r10, r11, 4
	ctx.r[10].u64 = ctx.r[11].u64 | 4;
	// 829F7FF0: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 829F7FF4: 4B7BFB25  bl 0x821b7b18
	ctx.lr = 0x829F7FF8;
	sub_821B7B18(ctx, base);
	// 829F7FF8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F7FFC: 4B7BFB1D  bl 0x821b7b18
	ctx.lr = 0x829F8000;
	sub_821B7B18(ctx, base);
	// 829F8000: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F8004: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829F8008: 482B1450  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F8010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F8010 size=284
    let mut pc: u32 = 0x829F8010;
    'dispatch: loop {
        match pc {
            0x829F8010 => {
    //   block [0x829F8010..0x829F8038)
	// 829F8010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F8014: 482B13F9  bl 0x82ca940c
	ctx.lr = 0x829F8018;
	sub_82CA93D0(ctx, base);
	// 829F8018: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F801C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F8020: 4B7EB719  bl 0x821e3738
	ctx.lr = 0x829F8024;
	sub_821E3738(ctx, base);
	// 829F8024: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829F8028: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829F802C: 3BBE0078  addi r29, r30, 0x78
	ctx.r[29].s64 = ctx.r[30].s64 + 120;
	// 829F8030: 409A0008  bne cr6, 0x829f8038
	if !ctx.cr[6].eq {
	pc = 0x829F8038; continue 'dispatch;
	}
	// 829F8034: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	pc = 0x829F8038; continue 'dispatch;
            }
            0x829F8038 => {
    //   block [0x829F8038..0x829F805C)
	// 829F8038: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F803C: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 829F8040: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F8044: 419A001C  beq cr6, 0x829f8060
	if ctx.cr[6].eq {
	pc = 0x829F8060; continue 'dispatch;
	}
	// 829F8048: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F804C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F8050: 419A000C  beq cr6, 0x829f805c
	if ctx.cr[6].eq {
	pc = 0x829F805C; continue 'dispatch;
	}
	// 829F8054: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F8058: 4800000C  b 0x829f8064
	pc = 0x829F8064; continue 'dispatch;
            }
            0x829F805C => {
    //   block [0x829F805C..0x829F8060)
	// 829F805C: 4B79BDDD  bl 0x82193e38
	ctx.lr = 0x829F8060;
	sub_82193E38(ctx, base);
	pc = 0x829F8060; continue 'dispatch;
            }
            0x829F8060 => {
    //   block [0x829F8060..0x829F8064)
	// 829F8060: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x829F8064; continue 'dispatch;
            }
            0x829F8064 => {
    //   block [0x829F8064..0x829F8104)
	// 829F8064: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829F8068: 806B007C  lwz r3, 0x7c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 829F806C: 389E008C  addi r4, r30, 0x8c
	ctx.r[4].s64 = ctx.r[30].s64 + 140;
	// 829F8070: 4B8A6A51  bl 0x8229eac0
	ctx.lr = 0x829F8074;
	sub_8229EAC0(ctx, base);
	// 829F8074: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 829F8078: 4B8271E1  bl 0x8221f258
	ctx.lr = 0x829F807C;
	sub_8221F258(ctx, base);
	// 829F807C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F8080: 419A0084  beq cr6, 0x829f8104
	if ctx.cr[6].eq {
	pc = 0x829F8104; continue 'dispatch;
	}
	// 829F8084: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829F8088: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829F808C: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 829F8090: 9BE3000D  stb r31, 0xd(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(13 as u32), ctx.r[31].u8 ) };
	// 829F8094: 390A9490  addi r8, r10, -0x6b70
	ctx.r[8].s64 = ctx.r[10].s64 + -27504;
	// 829F8098: 9BE3000E  stb r31, 0xe(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(14 as u32), ctx.r[31].u8 ) };
	// 829F809C: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 829F80A0: 9BE30020  stb r31, 0x20(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[31].u8 ) };
	// 829F80A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F80A8: 9BE30041  stb r31, 0x41(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(65 as u32), ctx.r[31].u8 ) };
	// 829F80AC: 38C71DEC  addi r6, r7, 0x1dec
	ctx.r[6].s64 = ctx.r[7].s64 + 7660;
	// 829F80B0: C1AA9490  lfs f13, -0x6b70(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829F80B4: C1891508  lfs f12, 0x1508(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(5384 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829F80B8: 9963000C  stb r11, 0xc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 829F80BC: C008FFF4  lfs f0, -0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F80C0: 90C30000  stw r6, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 829F80C4: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829F80C8: 99630040  stb r11, 0x40(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u8 ) };
	// 829F80CC: D1A30024  stfs f13, 0x24(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 829F80D0: 9BE30042  stb r31, 0x42(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(66 as u32), ctx.r[31].u8 ) };
	// 829F80D4: D1A30028  stfs f13, 0x28(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 829F80D8: 9BE30043  stb r31, 0x43(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(67 as u32), ctx.r[31].u8 ) };
	// 829F80DC: D003002C  stfs f0, 0x2c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 829F80E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F80E4: D1830030  stfs f12, 0x30(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 829F80E8: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 829F80EC: D0030038  stfs f0, 0x38(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 829F80F0: D003003C  stfs f0, 0x3c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 829F80F4: 93E30048  stw r31, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[31].u32 ) };
	// 829F80F8: 93E3004C  stw r31, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 829F80FC: 99630054  stb r11, 0x54(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[11].u8 ) };
	// 829F8100: 48000008  b 0x829f8108
	pc = 0x829F8108; continue 'dispatch;
            }
            0x829F8104 => {
    //   block [0x829F8104..0x829F8108)
	// 829F8104: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	pc = 0x829F8108; continue 'dispatch;
            }
            0x829F8108 => {
    //   block [0x829F8108..0x829F812C)
	// 829F8108: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F810C: 4B7C39A5  bl 0x821bbab0
	ctx.lr = 0x829F8110;
	sub_821BBAB0(ctx, base);
	// 829F8110: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F8114: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F8118: 4B873D51  bl 0x8226be68
	ctx.lr = 0x829F811C;
	sub_8226BE68(ctx, base);
	// 829F811C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F8120: 4B7BF9F9  bl 0x821b7b18
	ctx.lr = 0x829F8124;
	sub_821B7B18(ctx, base);
	// 829F8124: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829F8128: 482B1334  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F8130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F8130 size=168
    let mut pc: u32 = 0x829F8130;
    'dispatch: loop {
        match pc {
            0x829F8130 => {
    //   block [0x829F8130..0x829F814C)
	// 829F8130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F8134: 482B12D9  bl 0x82ca940c
	ctx.lr = 0x829F8138;
	sub_82CA93D0(ctx, base);
	// 829F8138: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F813C: 816300A4  lwz r11, 0xa4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(164 as u32) ) } as u64;
	// 829F8140: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 829F8144: 3BC300A0  addi r30, r3, 0xa0
	ctx.r[30].s64 = ctx.r[3].s64 + 160;
	// 829F8148: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x829F814C; continue 'dispatch;
            }
            0x829F814C => {
    //   block [0x829F814C..0x829F815C)
	// 829F814C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F8150: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829F8154: 419A0008  beq cr6, 0x829f815c
	if ctx.cr[6].eq {
	pc = 0x829F815C; continue 'dispatch;
	}
	// 829F8158: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829F815C; continue 'dispatch;
            }
            0x829F815C => {
    //   block [0x829F815C..0x829F8174)
	// 829F815C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829F8160: 419A006C  beq cr6, 0x829f81cc
	if ctx.cr[6].eq {
	pc = 0x829F81CC; continue 'dispatch;
	}
	// 829F8164: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F8168: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829F816C: 409A0008  bne cr6, 0x829f8174
	if !ctx.cr[6].eq {
	pc = 0x829F8174; continue 'dispatch;
	}
	// 829F8170: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829F8174; continue 'dispatch;
            }
            0x829F8174 => {
    //   block [0x829F8174..0x829F8198)
	// 829F8174: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 829F8178: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 829F817C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F8180: 419A001C  beq cr6, 0x829f819c
	if ctx.cr[6].eq {
	pc = 0x829F819C; continue 'dispatch;
	}
	// 829F8184: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F8188: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F818C: 419A000C  beq cr6, 0x829f8198
	if ctx.cr[6].eq {
	pc = 0x829F8198; continue 'dispatch;
	}
	// 829F8190: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F8194: 4800000C  b 0x829f81a0
	pc = 0x829F81A0; continue 'dispatch;
            }
            0x829F8198 => {
    //   block [0x829F8198..0x829F819C)
	// 829F8198: 4B79BCA1  bl 0x82193e38
	ctx.lr = 0x829F819C;
	sub_82193E38(ctx, base);
	pc = 0x829F819C; continue 'dispatch;
            }
            0x829F819C => {
    //   block [0x829F819C..0x829F81A0)
	// 829F819C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829F81A0; continue 'dispatch;
            }
            0x829F81A0 => {
    //   block [0x829F81A0..0x829F81B8)
	// 829F81A0: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829F81A4: 419A001C  beq cr6, 0x829f81c0
	if ctx.cr[6].eq {
	pc = 0x829F81C0; continue 'dispatch;
	}
	// 829F81A8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F81AC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829F81B0: 409A0008  bne cr6, 0x829f81b8
	if !ctx.cr[6].eq {
	pc = 0x829F81B8; continue 'dispatch;
	}
	// 829F81B4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829F81B8; continue 'dispatch;
            }
            0x829F81B8 => {
    //   block [0x829F81B8..0x829F81C0)
	// 829F81B8: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F81BC: 4BFFFF90  b 0x829f814c
	pc = 0x829F814C; continue 'dispatch;
            }
            0x829F81C0 => {
    //   block [0x829F81C0..0x829F81CC)
	// 829F81C0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829F81C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F81C8: 482B1294  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x829F81CC => {
    //   block [0x829F81CC..0x829F81D8)
	// 829F81CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829F81D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F81D4: 482B1288  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F81D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F81D8 size=932
    let mut pc: u32 = 0x829F81D8;
    'dispatch: loop {
        match pc {
            0x829F81D8 => {
    //   block [0x829F81D8..0x829F8214)
	// 829F81D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F81DC: 482B1219  bl 0x82ca93f4
	ctx.lr = 0x829F81E0;
	sub_82CA93D0(ctx, base);
	// 829F81E0: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F81E4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 829F81E8: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 829F81EC: 3879FF8C  addi r3, r25, -0x74
	ctx.r[3].s64 = ctx.r[25].s64 + -116;
	// 829F81F0: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 829F81F4: 8179FF90  lwz r11, -0x70(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-112 as u32) ) } as u64;
	// 829F81F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F81FC: 419A001C  beq cr6, 0x829f8218
	if ctx.cr[6].eq {
	pc = 0x829F8218; continue 'dispatch;
	}
	// 829F8200: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F8204: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F8208: 419A000C  beq cr6, 0x829f8214
	if ctx.cr[6].eq {
	pc = 0x829F8214; continue 'dispatch;
	}
	// 829F820C: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 829F8210: 4800000C  b 0x829f821c
	pc = 0x829F821C; continue 'dispatch;
            }
            0x829F8214 => {
    //   block [0x829F8214..0x829F8218)
	// 829F8214: 4B79BC25  bl 0x82193e38
	ctx.lr = 0x829F8218;
	sub_82193E38(ctx, base);
	pc = 0x829F8218; continue 'dispatch;
            }
            0x829F8218 => {
    //   block [0x829F8218..0x829F821C)
	// 829F8218: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	pc = 0x829F821C; continue 'dispatch;
            }
            0x829F821C => {
    //   block [0x829F821C..0x829F8270)
	// 829F821C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 829F8220: 4BEEAFA9  bl 0x828e31c8
	ctx.lr = 0x829F8224;
	sub_828E31C8(ctx, base);
	// 829F8224: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829F8228: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F822C: 419A0348  beq cr6, 0x829f8574
	if ctx.cr[6].eq {
	pc = 0x829F8574; continue 'dispatch;
	}
	// 829F8230: 817A0024  lwz r11, 0x24(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(36 as u32) ) } as u64;
	// 829F8234: 7F1BC378  mr r27, r24
	ctx.r[27].u64 = ctx.r[24].u64;
	// 829F8238: 556A0FFE  srwi r10, r11, 0x1f
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829F823C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F8240: 419A00F4  beq cr6, 0x829f8334
	if ctx.cr[6].eq {
	pc = 0x829F8334; continue 'dispatch;
	}
	// 829F8244: 817A008C  lwz r11, 0x8c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F8248: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F824C: 419A0024  beq cr6, 0x829f8270
	if ctx.cr[6].eq {
	pc = 0x829F8270; continue 'dispatch;
	}
	// 829F8250: 894B001F  lbz r10, 0x1f(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(31 as u32) ) } as u64;
	// 829F8254: 817A0048  lwz r11, 0x48(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F8258: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 829F825C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829F8260: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F8264: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 829F8268: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F826C: 480000CC  b 0x829f8338
	pc = 0x829F8338; continue 'dispatch;
            }
            0x829F8270 => {
    //   block [0x829F8270..0x829F828C)
	// 829F8270: 815A0048  lwz r10, 0x48(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F8274: 80DA004C  lwz r6, 0x4c(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(76 as u32) ) } as u64;
	// 829F8278: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 829F827C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829F8280: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829F8284: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F8288: 40810054  ble 0x829f82dc
	if !ctx.cr[0].gt {
	pc = 0x829F82DC; continue 'dispatch;
	}
	pc = 0x829F828C; continue 'dispatch;
            }
            0x829F828C => {
    //   block [0x829F828C..0x829F82AC)
	// 829F828C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829F8290: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F8294: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829F8298: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F829C: 2F07001F  cmpwi cr6, r7, 0x1f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 31, &mut ctx.xer);
	// 829F82A0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829F82A4: 41980008  blt cr6, 0x829f82ac
	if ctx.cr[6].lt {
	pc = 0x829F82AC; continue 'dispatch;
	}
	// 829F82A8: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	pc = 0x829F82AC; continue 'dispatch;
            }
            0x829F82AC => {
    //   block [0x829F82AC..0x829F82C8)
	// 829F82AC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829F82B0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829F82B4: 419A0014  beq cr6, 0x829f82c8
	if ctx.cr[6].eq {
	pc = 0x829F82C8; continue 'dispatch;
	}
	// 829F82B8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829F82BC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F82C0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F82C4: 4800000C  b 0x829f82d0
	pc = 0x829F82D0; continue 'dispatch;
            }
            0x829F82C8 => {
    //   block [0x829F82C8..0x829F82D0)
	// 829F82C8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829F82CC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829F82D0; continue 'dispatch;
            }
            0x829F82D0 => {
    //   block [0x829F82D0..0x829F82DC)
	// 829F82D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F82D4: 4199FFB8  bgt cr6, 0x829f828c
	if ctx.cr[6].gt {
	pc = 0x829F828C; continue 'dispatch;
	}
	// 829F82D8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x829F82DC; continue 'dispatch;
            }
            0x829F82DC => {
    //   block [0x829F82DC..0x829F82F8)
	// 829F82DC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829F82E0: 419A0040  beq cr6, 0x829f8320
	if ctx.cr[6].eq {
	pc = 0x829F8320; continue 'dispatch;
	}
	// 829F82E4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F82E8: 2F0B001F  cmpwi cr6, r11, 0x1f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 31, &mut ctx.xer);
	// 829F82EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F82F0: 41990008  bgt cr6, 0x829f82f8
	if ctx.cr[6].gt {
	pc = 0x829F82F8; continue 'dispatch;
	}
	// 829F82F4: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x829F82F8; continue 'dispatch;
            }
            0x829F82F8 => {
    //   block [0x829F82F8..0x829F8320)
	// 829F82F8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F82FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F8300: 409A0020  bne cr6, 0x829f8320
	if !ctx.cr[6].eq {
	pc = 0x829F8320; continue 'dispatch;
	}
	// 829F8304: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829F8308: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 829F830C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829F8310: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F8314: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 829F8318: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F831C: 4800001C  b 0x829f8338
	pc = 0x829F8338; continue 'dispatch;
            }
            0x829F8320 => {
    //   block [0x829F8320..0x829F8334)
	// 829F8320: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829F8324: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F8328: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 829F832C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F8330: 48000008  b 0x829f8338
	pc = 0x829F8338; continue 'dispatch;
            }
            0x829F8334 => {
    //   block [0x829F8334..0x829F8338)
	// 829F8334: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x829F8338; continue 'dispatch;
            }
            0x829F8338 => {
    //   block [0x829F8338..0x829F83E4)
	// 829F8338: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F833C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F8340: 419A0234  beq cr6, 0x829f8574
	if ctx.cr[6].eq {
	pc = 0x829F8574; continue 'dispatch;
	}
	// 829F8344: 3BF9FF88  addi r31, r25, -0x78
	ctx.r[31].s64 = ctx.r[25].s64 + -120;
	// 829F8348: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 829F834C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F8350: 4BFFFDE1  bl 0x829f8130
	ctx.lr = 0x829F8354;
	sub_829F8130(ctx, base);
	// 829F8354: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829F8358: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F835C: 409A0218  bne cr6, 0x829f8574
	if !ctx.cr[6].eq {
	pc = 0x829F8574; continue 'dispatch;
	}
	// 829F8360: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829F8364: 4BBCC5F5  bl 0x825c4958
	ctx.lr = 0x829F8368;
	sub_825C4958(ctx, base);
	// 829F8368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F836C: 4B77C0FD  bl 0x82174468
	ctx.lr = 0x829F8370;
	sub_82174468(ctx, base);
	// 829F8370: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F8374: 93010054  stw r24, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 829F8378: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F837C: 3BAB0B7C  addi r29, r11, 0xb7c
	ctx.r[29].s64 = ctx.r[11].s64 + 2940;
	// 829F8380: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F8384: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 829F8388: 4B81C511  bl 0x82214898
	ctx.lr = 0x829F838C;
	sub_82214898(ctx, base);
	// 829F838C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829F8390: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829F8394: 4BAD9B35  bl 0x824d1ec8
	ctx.lr = 0x829F8398;
	sub_824D1EC8(ctx, base);
	// 829F8398: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F839C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F83A0: 3B8B0B7C  addi r28, r11, 0xb7c
	ctx.r[28].s64 = ctx.r[11].s64 + 2940;
	// 829F83A4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829F83A8: 4B79BA91  bl 0x82193e38
	ctx.lr = 0x829F83AC;
	sub_82193E38(ctx, base);
	// 829F83AC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 829F83B0: 4B826EA9  bl 0x8221f258
	ctx.lr = 0x829F83B4;
	sub_8221F258(ctx, base);
	// 829F83B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F83B8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829F83BC: 419A0028  beq cr6, 0x829f83e4
	if ctx.cr[6].eq {
	pc = 0x829F83E4; continue 'dispatch;
	}
	// 829F83C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F83C4: 82F9FFC4  lwz r23, -0x3c(r25)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-60 as u32) ) } as u64;
	// 829F83C8: 4B77C0A1  bl 0x82174468
	ctx.lr = 0x829F83CC;
	sub_82174468(ctx, base);
	// 829F83CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F83D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F83D4: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 829F83D8: 4B9991C1  bl 0x82391598
	ctx.lr = 0x829F83DC;
	sub_82391598(ctx, base);
	// 829F83DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F83E0: 48000008  b 0x829f83e8
	pc = 0x829F83E8; continue 'dispatch;
            }
            0x829F83E4 => {
    //   block [0x829F83E4..0x829F83E8)
	// 829F83E4: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	pc = 0x829F83E8; continue 'dispatch;
            }
            0x829F83E8 => {
    //   block [0x829F83E8..0x829F8574)
	// 829F83E8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829F83EC: 4B9A6B65  bl 0x8239ef50
	ctx.lr = 0x829F83F0;
	sub_8239EF50(ctx, base);
	// 829F83F0: 89390025  lbz r9, 0x25(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(37 as u32) ) } as u64;
	// 829F83F4: 89190024  lbz r8, 0x24(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(36 as u32) ) } as u64;
	// 829F83F8: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 829F83FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829F8400: 916100E0  stw r11, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	// 829F8404: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F8408: 914100D0  stw r10, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[10].u32 ) };
	// 829F840C: 99210098  stb r9, 0x98(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[9].u8 ) };
	// 829F8410: 99010099  stb r8, 0x99(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(153 as u32), ctx.r[8].u8 ) };
	// 829F8414: 4B77C055  bl 0x82174468
	ctx.lr = 0x829F8418;
	sub_82174468(ctx, base);
	// 829F8418: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F841C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F8420: 4B7EF0E9  bl 0x821e7508
	ctx.lr = 0x829F8424;
	sub_821E7508(ctx, base);
	// 829F8424: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 829F8428: 38C10120  addi r6, r1, 0x120
	ctx.r[6].s64 = ctx.r[1].s64 + 288;
	// 829F842C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x829F8574; continue 'dispatch;
            }
            0x829F8574 => {
    //   block [0x829F8574..0x829F857C)
	// 829F8574: 382101B0  addi r1, r1, 0x1b0
	ctx.r[1].s64 = ctx.r[1].s64 + 432;
	// 829F8578: 482B0ECC  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F8580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F8580 size=548
    let mut pc: u32 = 0x829F8580;
    'dispatch: loop {
        match pc {
            0x829F8580 => {
    //   block [0x829F8580..0x829F85E8)
	// 829F8580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F8584: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F8588: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F858C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F8590: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F8594: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F8598: 897E004B  lbz r11, 0x4b(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(75 as u32) ) } as u64;
	// 829F859C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F85A0: 409A01EC  bne cr6, 0x829f878c
	if !ctx.cr[6].eq {
	pc = 0x829F878C; continue 'dispatch;
	}
	// 829F85A4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829F85A8: 4B77BEC1  bl 0x82174468
	ctx.lr = 0x829F85AC;
	sub_82174468(ctx, base);
	// 829F85AC: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 829F85B0: 556A7FFE  rlwinm r10, r11, 0xf, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0001FFFFu64;
	// 829F85B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F85B8: 419A00F8  beq cr6, 0x829f86b0
	if ctx.cr[6].eq {
	pc = 0x829F86B0; continue 'dispatch;
	}
	// 829F85BC: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F85C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F85C4: 419A0024  beq cr6, 0x829f85e8
	if ctx.cr[6].eq {
	pc = 0x829F85E8; continue 'dispatch;
	}
	// 829F85C8: 894B0031  lbz r10, 0x31(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(49 as u32) ) } as u64;
	// 829F85CC: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F85D0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 829F85D4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829F85D8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F85DC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F85E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F85E4: 480000D0  b 0x829f86b4
	pc = 0x829F86B4; continue 'dispatch;
            }
            0x829F85E8 => {
    //   block [0x829F85E8..0x829F8608)
	// 829F85E8: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F85EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829F85F0: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 829F85F4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829F85F8: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829F85FC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829F8600: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F8604: 40810054  ble 0x829f8658
	if !ctx.cr[0].gt {
	pc = 0x829F8658; continue 'dispatch;
	}
	pc = 0x829F8608; continue 'dispatch;
            }
            0x829F8608 => {
    //   block [0x829F8608..0x829F8628)
	// 829F8608: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829F860C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F8610: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829F8614: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F8618: 2F070031  cmpwi cr6, r7, 0x31
	ctx.cr[6].compare_i32(ctx.r[7].s32, 49, &mut ctx.xer);
	// 829F861C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829F8620: 41980008  blt cr6, 0x829f8628
	if ctx.cr[6].lt {
	pc = 0x829F8628; continue 'dispatch;
	}
	// 829F8624: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x829F8628; continue 'dispatch;
            }
            0x829F8628 => {
    //   block [0x829F8628..0x829F8644)
	// 829F8628: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829F862C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829F8630: 419A0014  beq cr6, 0x829f8644
	if ctx.cr[6].eq {
	pc = 0x829F8644; continue 'dispatch;
	}
	// 829F8634: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829F8638: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F863C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F8640: 4800000C  b 0x829f864c
	pc = 0x829F864C; continue 'dispatch;
            }
            0x829F8644 => {
    //   block [0x829F8644..0x829F864C)
	// 829F8644: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829F8648: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829F864C; continue 'dispatch;
            }
            0x829F864C => {
    //   block [0x829F864C..0x829F8658)
	// 829F864C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F8650: 4199FFB8  bgt cr6, 0x829f8608
	if ctx.cr[6].gt {
	pc = 0x829F8608; continue 'dispatch;
	}
	// 829F8654: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x829F8658; continue 'dispatch;
            }
            0x829F8658 => {
    //   block [0x829F8658..0x829F8674)
	// 829F8658: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829F865C: 419A0040  beq cr6, 0x829f869c
	if ctx.cr[6].eq {
	pc = 0x829F869C; continue 'dispatch;
	}
	// 829F8660: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F8664: 2F0B0031  cmpwi cr6, r11, 0x31
	ctx.cr[6].compare_i32(ctx.r[11].s32, 49, &mut ctx.xer);
	// 829F8668: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F866C: 41990008  bgt cr6, 0x829f8674
	if ctx.cr[6].gt {
	pc = 0x829F8674; continue 'dispatch;
	}
	// 829F8670: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829F8674; continue 'dispatch;
            }
            0x829F8674 => {
    //   block [0x829F8674..0x829F869C)
	// 829F8674: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F8678: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F867C: 409A0020  bne cr6, 0x829f869c
	if !ctx.cr[6].eq {
	pc = 0x829F869C; continue 'dispatch;
	}
	// 829F8680: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829F8684: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829F8688: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F868C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F8690: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F8694: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F8698: 4800001C  b 0x829f86b4
	pc = 0x829F86B4; continue 'dispatch;
            }
            0x829F869C => {
    //   block [0x829F869C..0x829F86B0)
	// 829F869C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829F86A0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F86A4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F86A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F86AC: 48000008  b 0x829f86b4
	pc = 0x829F86B4; continue 'dispatch;
            }
            0x829F86B0 => {
    //   block [0x829F86B0..0x829F86B4)
	// 829F86B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829F86B4; continue 'dispatch;
            }
            0x829F86B4 => {
    //   block [0x829F86B4..0x829F86E4)
	// 829F86B4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F86B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F86BC: 419A00D0  beq cr6, 0x829f878c
	if ctx.cr[6].eq {
	pc = 0x829F878C; continue 'dispatch;
	}
	// 829F86C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F86C4: 4B8A67B5  bl 0x8229ee78
	ctx.lr = 0x829F86C8;
	sub_8229EE78(ctx, base);
	// 829F86C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F86CC: 419A0018  beq cr6, 0x829f86e4
	if ctx.cr[6].eq {
	pc = 0x829F86E4; continue 'dispatch;
	}
	// 829F86D0: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 829F86D4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829F86D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F86DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F86E0: 409A0008  bne cr6, 0x829f86e8
	if !ctx.cr[6].eq {
	pc = 0x829F86E8; continue 'dispatch;
	}
	pc = 0x829F86E4; continue 'dispatch;
            }
            0x829F86E4 => {
    //   block [0x829F86E4..0x829F86E8)
	// 829F86E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829F86E8; continue 'dispatch;
            }
            0x829F86E8 => {
    //   block [0x829F86E8..0x829F8750)
	// 829F86E8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F86EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F86F0: 419A0060  beq cr6, 0x829f8750
	if ctx.cr[6].eq {
	pc = 0x829F8750; continue 'dispatch;
	}
	// 829F86F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F86F8: 4B8A6781  bl 0x8229ee78
	ctx.lr = 0x829F86FC;
	sub_8229EE78(ctx, base);
	// 829F86FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F8700: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F8704: 4BFFFA2D  bl 0x829f8130
	ctx.lr = 0x829F8708;
	sub_829F8130(ctx, base);
	// 829F8708: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829F870C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F8710: 419A0040  beq cr6, 0x829f8750
	if ctx.cr[6].eq {
	pc = 0x829F8750; continue 'dispatch;
	}
	// 829F8714: 80BE007C  lwz r5, 0x7c(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 829F8718: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 829F871C: 419A0070  beq cr6, 0x829f878c
	if ctx.cr[6].eq {
	pc = 0x829F878C; continue 'dispatch;
	}
	// 829F8720: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F8724: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829F8728: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F872C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829F8730: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 829F8734: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829F8738: 4E800421  bctrl
	ctx.lr = 0x829F873C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829F873C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 829F8740: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829F8744: 39090B7C  addi r8, r9, 0xb7c
	ctx.r[8].s64 = ctx.r[9].s64 + 2940;
	// 829F8748: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 829F874C: 4800003C  b 0x829f8788
	pc = 0x829F8788; continue 'dispatch;
            }
            0x829F8750 => {
    //   block [0x829F8750..0x829F8788)
	// 829F8750: 80BE0084  lwz r5, 0x84(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) } as u64;
	// 829F8754: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 829F8758: 419A0034  beq cr6, 0x829f878c
	if ctx.cr[6].eq {
	pc = 0x829F878C; continue 'dispatch;
	}
	// 829F875C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F8760: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829F8764: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F8768: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829F876C: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 829F8770: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829F8774: 4E800421  bctrl
	ctx.lr = 0x829F8778;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829F8778: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 829F877C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829F8780: 39090B7C  addi r8, r9, 0xb7c
	ctx.r[8].s64 = ctx.r[9].s64 + 2940;
	// 829F8784: 91010068  stw r8, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[8].u32 ) };
            }
            0x829F8788 => {
    //   block [0x829F8788..0x829F878C)
	// 829F8788: 4B79B6B1  bl 0x82193e38
	ctx.lr = 0x829F878C;
	sub_82193E38(ctx, base);
	pc = 0x829F878C; continue 'dispatch;
            }
            0x829F878C => {
    //   block [0x829F878C..0x829F87A4)
	// 829F878C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829F8790: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F8794: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F8798: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829F879C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F87A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F87A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829F87A8 size=8
    let mut pc: u32 = 0x829F87A8;
    'dispatch: loop {
        match pc {
            0x829F87A8 => {
    //   block [0x829F87A8..0x829F87B0)
	// 829F87A8: 3863FF88  addi r3, r3, -0x78
	ctx.r[3].s64 = ctx.r[3].s64 + -120;
	// 829F87AC: 4BFFE884  b 0x829f7030
	sub_829F7030(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F87B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F87B0 size=148
    let mut pc: u32 = 0x829F87B0;
    'dispatch: loop {
        match pc {
            0x829F87B0 => {
    //   block [0x829F87B0..0x829F881C)
	// 829F87B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F87B4: 482B0C59  bl 0x82ca940c
	ctx.lr = 0x829F87B8;
	sub_82CA93D0(ctx, base);
	// 829F87B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F87BC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829F87C0: 3860008C  li r3, 0x8c
	ctx.r[3].s64 = 140;
	// 829F87C4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F87C8: 4B826A91  bl 0x8221f258
	ctx.lr = 0x829F87CC;
	sub_8221F258(ctx, base);
	// 829F87CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F87D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F87D4: 419A0048  beq cr6, 0x829f881c
	if ctx.cr[6].eq {
	pc = 0x829F881C; continue 'dispatch;
	}
	// 829F87D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F87DC: 4BA11515  bl 0x82409cf0
	ctx.lr = 0x829F87E0;
	sub_82409CF0(ctx, base);
	// 829F87E0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F87E4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 829F87E8: 392B1C80  addi r9, r11, 0x1c80
	ctx.r[9].s64 = ctx.r[11].s64 + 7296;
	// 829F87EC: 390A0E0C  addi r8, r10, 0xe0c
	ctx.r[8].s64 = ctx.r[10].s64 + 3596;
	// 829F87F0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 829F87F4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829F87F8: 911F0078  stw r8, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[8].u32 ) };
	// 829F87FC: 389E0084  addi r4, r30, 0x84
	ctx.r[4].s64 = ctx.r[30].s64 + 132;
	// 829F8800: 90FF007C  stw r7, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[7].u32 ) };
	// 829F8804: 387F0084  addi r3, r31, 0x84
	ctx.r[3].s64 = ctx.r[31].s64 + 132;
	// 829F8808: 80DE0080  lwz r6, 0x80(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 829F880C: 90DF0080  stw r6, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[6].u32 ) };
	// 829F8810: 4B79E561  bl 0x82196d70
	ctx.lr = 0x829F8814;
	sub_82196D70(ctx, base);
	// 829F8814: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F8818: 48000008  b 0x829f8820
	pc = 0x829F8820; continue 'dispatch;
            }
            0x829F881C => {
    //   block [0x829F881C..0x829F8820)
	// 829F881C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829F8820; continue 'dispatch;
            }
            0x829F8820 => {
    //   block [0x829F8820..0x829F8838)
	// 829F8820: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F8824: 4B8C76F5  bl 0x822bff18
	ctx.lr = 0x829F8828;
	sub_822BFF18(ctx, base);
	// 829F8828: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F882C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F8830: 419A0008  beq cr6, 0x829f8838
	if ctx.cr[6].eq {
	pc = 0x829F8838; continue 'dispatch;
	}
	// 829F8834: 4B7889ED  bl 0x82181220
	ctx.lr = 0x829F8838;
	sub_82181220(ctx, base);
	pc = 0x829F8838; continue 'dispatch;
            }
            0x829F8838 => {
    //   block [0x829F8838..0x829F8844)
	// 829F8838: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F883C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F8840: 482B0C1C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F8848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F8848 size=128
    let mut pc: u32 = 0x829F8848;
    'dispatch: loop {
        match pc {
            0x829F8848 => {
    //   block [0x829F8848..0x829F88B0)
	// 829F8848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F884C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F8850: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F8854: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F8858: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F885C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F8860: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F8864: 387F0084  addi r3, r31, 0x84
	ctx.r[3].s64 = ctx.r[31].s64 + 132;
	// 829F8868: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 829F886C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F8870: 915F0084  stw r10, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 829F8874: 4B79B5C5  bl 0x82193e38
	ctx.lr = 0x829F8878;
	sub_82193E38(ctx, base);
	// 829F8878: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 829F887C: 387F0078  addi r3, r31, 0x78
	ctx.r[3].s64 = ctx.r[31].s64 + 120;
	// 829F8880: 913F0088  stw r9, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[9].u32 ) };
	// 829F8884: 4B8A1FCD  bl 0x8229a850
	ctx.lr = 0x829F8888;
	sub_8229A850(ctx, base);
	// 829F8888: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 829F888C: 4B81C54D  bl 0x82214dd8
	ctx.lr = 0x829F8890;
	sub_82214DD8(ctx, base);
	// 829F8890: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F8894: 4B7B429D  bl 0x821acb30
	ctx.lr = 0x829F8898;
	sub_821ACB30(ctx, base);
	// 829F8898: 57C807FE  clrlwi r8, r30, 0x1f
	ctx.r[8].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 829F889C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F88A0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 829F88A4: 419A000C  beq cr6, 0x829f88b0
	if ctx.cr[6].eq {
	pc = 0x829F88B0; continue 'dispatch;
	}
	// 829F88A8: 4B823491  bl 0x8221bd38
	ctx.lr = 0x829F88AC;
	sub_8221BD38(ctx, base);
	// 829F88AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x829F88B0; continue 'dispatch;
            }
            0x829F88B0 => {
    //   block [0x829F88B0..0x829F88C8)
	// 829F88B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F88B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F88B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F88BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829F88C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F88C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F88C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F88C8 size=148
    let mut pc: u32 = 0x829F88C8;
    'dispatch: loop {
        match pc {
            0x829F88C8 => {
    //   block [0x829F88C8..0x829F8934)
	// 829F88C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F88CC: 482B0B41  bl 0x82ca940c
	ctx.lr = 0x829F88D0;
	sub_82CA93D0(ctx, base);
	// 829F88D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F88D4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829F88D8: 3860008C  li r3, 0x8c
	ctx.r[3].s64 = 140;
	// 829F88DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F88E0: 4B826979  bl 0x8221f258
	ctx.lr = 0x829F88E4;
	sub_8221F258(ctx, base);
	// 829F88E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F88E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F88EC: 419A0048  beq cr6, 0x829f8934
	if ctx.cr[6].eq {
	pc = 0x829F8934; continue 'dispatch;
	}
	// 829F88F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F88F4: 4BA113FD  bl 0x82409cf0
	ctx.lr = 0x829F88F8;
	sub_82409CF0(ctx, base);
	// 829F88F8: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F88FC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 829F8900: 392B1CD0  addi r9, r11, 0x1cd0
	ctx.r[9].s64 = ctx.r[11].s64 + 7376;
	// 829F8904: 390A0E0C  addi r8, r10, 0xe0c
	ctx.r[8].s64 = ctx.r[10].s64 + 3596;
	// 829F8908: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 829F890C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829F8910: 911F0078  stw r8, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[8].u32 ) };
	// 829F8914: 389E0084  addi r4, r30, 0x84
	ctx.r[4].s64 = ctx.r[30].s64 + 132;
	// 829F8918: 90FF007C  stw r7, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[7].u32 ) };
	// 829F891C: 387F0084  addi r3, r31, 0x84
	ctx.r[3].s64 = ctx.r[31].s64 + 132;
	// 829F8920: 80DE0080  lwz r6, 0x80(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 829F8924: 90DF0080  stw r6, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[6].u32 ) };
	// 829F8928: 4B79E449  bl 0x82196d70
	ctx.lr = 0x829F892C;
	sub_82196D70(ctx, base);
	// 829F892C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F8930: 48000008  b 0x829f8938
	pc = 0x829F8938; continue 'dispatch;
            }
            0x829F8934 => {
    //   block [0x829F8934..0x829F8938)
	// 829F8934: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829F8938; continue 'dispatch;
            }
            0x829F8938 => {
    //   block [0x829F8938..0x829F8950)
	// 829F8938: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F893C: 4B8C75DD  bl 0x822bff18
	ctx.lr = 0x829F8940;
	sub_822BFF18(ctx, base);
	// 829F8940: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F8944: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F8948: 419A0008  beq cr6, 0x829f8950
	if ctx.cr[6].eq {
	pc = 0x829F8950; continue 'dispatch;
	}
	// 829F894C: 4B7888D5  bl 0x82181220
	ctx.lr = 0x829F8950;
	sub_82181220(ctx, base);
	pc = 0x829F8950; continue 'dispatch;
            }
            0x829F8950 => {
    //   block [0x829F8950..0x829F895C)
	// 829F8950: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F8954: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F8958: 482B0B04  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F8960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F8960 size=184
    let mut pc: u32 = 0x829F8960;
    'dispatch: loop {
        match pc {
            0x829F8960 => {
    //   block [0x829F8960..0x829F89F0)
	// 829F8960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F8964: 482B0AA9  bl 0x82ca940c
	ctx.lr = 0x829F8968;
	sub_82CA93D0(ctx, base);
	// 829F8968: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F896C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829F8970: 386000D0  li r3, 0xd0
	ctx.r[3].s64 = 208;
	// 829F8974: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F8978: 4B8268E1  bl 0x8221f258
	ctx.lr = 0x829F897C;
	sub_8221F258(ctx, base);
	// 829F897C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F8980: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F8984: 419A006C  beq cr6, 0x829f89f0
	if ctx.cr[6].eq {
	pc = 0x829F89F0; continue 'dispatch;
	}
	// 829F8988: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F898C: 4BA11365  bl 0x82409cf0
	ctx.lr = 0x829F8990;
	sub_82409CF0(ctx, base);
	// 829F8990: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F8994: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 829F8998: 390B1D20  addi r8, r11, 0x1d20
	ctx.r[8].s64 = ctx.r[11].s64 + 7456;
	// 829F899C: 39400090  li r10, 0x90
	ctx.r[10].s64 = 144;
	// 829F89A0: 38E90E0C  addi r7, r9, 0xe0c
	ctx.r[7].s64 = ctx.r[9].s64 + 3596;
	// 829F89A4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 829F89A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829F89AC: 396000A0  li r11, 0xa0
	ctx.r[11].s64 = 160;
	// 829F89B0: 90FF0078  stw r7, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[7].u32 ) };
	// 829F89B4: 90DF007C  stw r6, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[6].u32 ) };
	// 829F89B8: 389E00B0  addi r4, r30, 0xb0
	ctx.r[4].s64 = ctx.r[30].s64 + 176;
	// 829F89BC: 80BE0080  lwz r5, 0x80(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 829F89C0: 387F00B0  addi r3, r31, 0xb0
	ctx.r[3].s64 = ctx.r[31].s64 + 176;
	// 829F89C4: 90BF0080  stw r5, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[5].u32 ) };
	pc = 0x829F89F0; continue 'dispatch;
            }
            0x829F89F0 => {
    //   block [0x829F89F0..0x829F8A18)
	// 829F89F0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829F89F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F89F8: 4B8C7521  bl 0x822bff18
	ctx.lr = 0x829F89FC;
	sub_822BFF18(ctx, base);
	// 829F89FC: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F8A00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F8A04: 419A0008  beq cr6, 0x829f8a0c
	if ctx.cr[6].eq {
	pc = 0x829F8A0C; continue 'dispatch;
	}
	// 829F8A08: 4B788819  bl 0x82181220
	ctx.lr = 0x829F8A0C;
	sub_82181220(ctx, base);
	// 829F8A0C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F8A10: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F8A14: 482B0A48  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F8A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F8A18 size=136
    let mut pc: u32 = 0x829F8A18;
    'dispatch: loop {
        match pc {
            0x829F8A18 => {
    //   block [0x829F8A18..0x829F8A88)
	// 829F8A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F8A1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F8A20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F8A24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F8A28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F8A2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F8A30: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F8A34: 387F00BC  addi r3, r31, 0xbc
	ctx.r[3].s64 = ctx.r[31].s64 + 188;
	// 829F8A38: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 829F8A3C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F8A40: 915F00BC  stw r10, 0xbc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[10].u32 ) };
	// 829F8A44: 4B79B3F5  bl 0x82193e38
	ctx.lr = 0x829F8A48;
	sub_82193E38(ctx, base);
	// 829F8A48: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 829F8A4C: 387F00B0  addi r3, r31, 0xb0
	ctx.r[3].s64 = ctx.r[31].s64 + 176;
	// 829F8A50: 913F00C0  stw r9, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[9].u32 ) };
	// 829F8A54: 4BC41C35  bl 0x8263a688
	ctx.lr = 0x829F8A58;
	sub_8263A688(ctx, base);
	// 829F8A58: 387F0078  addi r3, r31, 0x78
	ctx.r[3].s64 = ctx.r[31].s64 + 120;
	// 829F8A5C: 4B8A1DF5  bl 0x8229a850
	ctx.lr = 0x829F8A60;
	sub_8229A850(ctx, base);
	// 829F8A60: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 829F8A64: 4B81C375  bl 0x82214dd8
	ctx.lr = 0x829F8A68;
	sub_82214DD8(ctx, base);
	// 829F8A68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F8A6C: 4B7B40C5  bl 0x821acb30
	ctx.lr = 0x829F8A70;
	sub_821ACB30(ctx, base);
	// 829F8A70: 57C807FE  clrlwi r8, r30, 0x1f
	ctx.r[8].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 829F8A74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F8A78: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 829F8A7C: 419A000C  beq cr6, 0x829f8a88
	if ctx.cr[6].eq {
	pc = 0x829F8A88; continue 'dispatch;
	}
	// 829F8A80: 4B8232B9  bl 0x8221bd38
	ctx.lr = 0x829F8A84;
	sub_8221BD38(ctx, base);
	// 829F8A84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x829F8A88; continue 'dispatch;
            }
            0x829F8A88 => {
    //   block [0x829F8A88..0x829F8AA0)
	// 829F8A88: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F8A8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F8A90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F8A94: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829F8A98: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F8A9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F8AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F8AA0 size=196
    let mut pc: u32 = 0x829F8AA0;
    'dispatch: loop {
        match pc {
            0x829F8AA0 => {
    //   block [0x829F8AA0..0x829F8B3C)
	// 829F8AA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F8AA4: 482B0969  bl 0x82ca940c
	ctx.lr = 0x829F8AA8;
	sub_82CA93D0(ctx, base);
	// 829F8AA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F8AAC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829F8AB0: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 829F8AB4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F8AB8: 4B8267A1  bl 0x8221f258
	ctx.lr = 0x829F8ABC;
	sub_8221F258(ctx, base);
	// 829F8ABC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F8AC0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F8AC4: 419A0078  beq cr6, 0x829f8b3c
	if ctx.cr[6].eq {
	pc = 0x829F8B3C; continue 'dispatch;
	}
	// 829F8AC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F8ACC: 4BA11225  bl 0x82409cf0
	ctx.lr = 0x829F8AD0;
	sub_82409CF0(ctx, base);
	// 829F8AD0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F8AD4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 829F8AD8: 392B1D70  addi r9, r11, 0x1d70
	ctx.r[9].s64 = ctx.r[11].s64 + 7536;
	// 829F8ADC: 39000090  li r8, 0x90
	ctx.r[8].s64 = 144;
	// 829F8AE0: 38EA0E0C  addi r7, r10, 0xe0c
	ctx.r[7].s64 = ctx.r[10].s64 + 3596;
	// 829F8AE4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829F8AE8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829F8AEC: 392000A0  li r9, 0xa0
	ctx.r[9].s64 = 160;
	// 829F8AF0: 90FF0078  stw r7, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[7].u32 ) };
	// 829F8AF4: 90DF007C  stw r6, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[6].u32 ) };
	// 829F8AF8: 394000B0  li r10, 0xb0
	ctx.r[10].s64 = 176;
	// 829F8AFC: 80BE0080  lwz r5, 0x80(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 829F8B00: 396000C0  li r11, 0xc0
	ctx.r[11].s64 = 192;
	// 829F8B04: 90BF0080  stw r5, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[5].u32 ) };
	pc = 0x829F8B3C; continue 'dispatch;
            }
            0x829F8B3C => {
    //   block [0x829F8B3C..0x829F8B64)
	// 829F8B3C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829F8B40: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F8B44: 4B8C73D5  bl 0x822bff18
	ctx.lr = 0x829F8B48;
	sub_822BFF18(ctx, base);
	// 829F8B48: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F8B4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F8B50: 419A0008  beq cr6, 0x829f8b58
	if ctx.cr[6].eq {
	pc = 0x829F8B58; continue 'dispatch;
	}
	// 829F8B54: 4B7886CD  bl 0x82181220
	ctx.lr = 0x829F8B58;
	sub_82181220(ctx, base);
	// 829F8B58: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F8B5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F8B60: 482B08FC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F8B68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F8B68 size=128
    let mut pc: u32 = 0x829F8B68;
    'dispatch: loop {
        match pc {
            0x829F8B68 => {
    //   block [0x829F8B68..0x829F8BD0)
	// 829F8B68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F8B6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F8B70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F8B74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F8B78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F8B7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F8B80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F8B84: 387F00D0  addi r3, r31, 0xd0
	ctx.r[3].s64 = ctx.r[31].s64 + 208;
	// 829F8B88: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 829F8B8C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F8B90: 915F00D0  stw r10, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[10].u32 ) };
	// 829F8B94: 4B79B2A5  bl 0x82193e38
	ctx.lr = 0x829F8B98;
	sub_82193E38(ctx, base);
	// 829F8B98: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 829F8B9C: 387F0078  addi r3, r31, 0x78
	ctx.r[3].s64 = ctx.r[31].s64 + 120;
	// 829F8BA0: 913F00D4  stw r9, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[9].u32 ) };
	// 829F8BA4: 4B8A1CAD  bl 0x8229a850
	ctx.lr = 0x829F8BA8;
	sub_8229A850(ctx, base);
	// 829F8BA8: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 829F8BAC: 4B81C22D  bl 0x82214dd8
	ctx.lr = 0x829F8BB0;
	sub_82214DD8(ctx, base);
	// 829F8BB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F8BB4: 4B7B3F7D  bl 0x821acb30
	ctx.lr = 0x829F8BB8;
	sub_821ACB30(ctx, base);
	// 829F8BB8: 57C807FE  clrlwi r8, r30, 0x1f
	ctx.r[8].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 829F8BBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F8BC0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 829F8BC4: 419A000C  beq cr6, 0x829f8bd0
	if ctx.cr[6].eq {
	pc = 0x829F8BD0; continue 'dispatch;
	}
	// 829F8BC8: 4B823171  bl 0x8221bd38
	ctx.lr = 0x829F8BCC;
	sub_8221BD38(ctx, base);
	// 829F8BCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x829F8BD0; continue 'dispatch;
            }
            0x829F8BD0 => {
    //   block [0x829F8BD0..0x829F8BE8)
	// 829F8BD0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F8BD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F8BD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F8BDC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829F8BE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F8BE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F8BE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F8BE8 size=172
    let mut pc: u32 = 0x829F8BE8;
    'dispatch: loop {
        match pc {
            0x829F8BE8 => {
    //   block [0x829F8BE8..0x829F8C6C)
	// 829F8BE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F8BEC: 482B0821  bl 0x82ca940c
	ctx.lr = 0x829F8BF0;
	sub_82CA93D0(ctx, base);
	// 829F8BF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F8BF4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829F8BF8: 386000C0  li r3, 0xc0
	ctx.r[3].s64 = 192;
	// 829F8BFC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F8C00: 4B826659  bl 0x8221f258
	ctx.lr = 0x829F8C04;
	sub_8221F258(ctx, base);
	// 829F8C04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F8C08: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F8C0C: 419A0060  beq cr6, 0x829f8c6c
	if ctx.cr[6].eq {
	pc = 0x829F8C6C; continue 'dispatch;
	}
	// 829F8C10: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F8C14: 4BA110DD  bl 0x82409cf0
	ctx.lr = 0x829F8C18;
	sub_82409CF0(ctx, base);
	// 829F8C18: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F8C1C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 829F8C20: 390B1DC0  addi r8, r11, 0x1dc0
	ctx.r[8].s64 = ctx.r[11].s64 + 7616;
	// 829F8C24: 39400090  li r10, 0x90
	ctx.r[10].s64 = 144;
	// 829F8C28: 38E90E0C  addi r7, r9, 0xe0c
	ctx.r[7].s64 = ctx.r[9].s64 + 3596;
	// 829F8C2C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 829F8C30: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829F8C34: 396000A0  li r11, 0xa0
	ctx.r[11].s64 = 160;
	// 829F8C38: 90FF0078  stw r7, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[7].u32 ) };
	// 829F8C3C: 90DF007C  stw r6, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[6].u32 ) };
	// 829F8C40: 389E00B0  addi r4, r30, 0xb0
	ctx.r[4].s64 = ctx.r[30].s64 + 176;
	// 829F8C44: 80BE0080  lwz r5, 0x80(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 829F8C48: 387F00B0  addi r3, r31, 0xb0
	ctx.r[3].s64 = ctx.r[31].s64 + 176;
	// 829F8C4C: 90BF0080  stw r5, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[5].u32 ) };
	pc = 0x829F8C6C; continue 'dispatch;
            }
            0x829F8C6C => {
    //   block [0x829F8C6C..0x829F8C94)
	// 829F8C6C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829F8C70: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F8C74: 4B8C72A5  bl 0x822bff18
	ctx.lr = 0x829F8C78;
	sub_822BFF18(ctx, base);
	// 829F8C78: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F8C7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F8C80: 419A0008  beq cr6, 0x829f8c88
	if ctx.cr[6].eq {
	pc = 0x829F8C88; continue 'dispatch;
	}
	// 829F8C84: 4B78859D  bl 0x82181220
	ctx.lr = 0x829F8C88;
	sub_82181220(ctx, base);
	// 829F8C88: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F8C8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F8C90: 482B07CC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F8C98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F8C98 size=108
    let mut pc: u32 = 0x829F8C98;
    'dispatch: loop {
        match pc {
            0x829F8C98 => {
    //   block [0x829F8C98..0x829F8CEC)
	// 829F8C98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F8C9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F8CA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F8CA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F8CA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F8CAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F8CB0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F8CB4: 387F00B0  addi r3, r31, 0xb0
	ctx.r[3].s64 = ctx.r[31].s64 + 176;
	// 829F8CB8: 4BC419D1  bl 0x8263a688
	ctx.lr = 0x829F8CBC;
	sub_8263A688(ctx, base);
	// 829F8CBC: 387F0078  addi r3, r31, 0x78
	ctx.r[3].s64 = ctx.r[31].s64 + 120;
	// 829F8CC0: 4B8A1B91  bl 0x8229a850
	ctx.lr = 0x829F8CC4;
	sub_8229A850(ctx, base);
	// 829F8CC4: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 829F8CC8: 4B81C111  bl 0x82214dd8
	ctx.lr = 0x829F8CCC;
	sub_82214DD8(ctx, base);
	// 829F8CCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F8CD0: 4B7B3E61  bl 0x821acb30
	ctx.lr = 0x829F8CD4;
	sub_821ACB30(ctx, base);
	// 829F8CD4: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 829F8CD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F8CDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F8CE0: 419A000C  beq cr6, 0x829f8cec
	if ctx.cr[6].eq {
	pc = 0x829F8CEC; continue 'dispatch;
	}
	// 829F8CE4: 4B823055  bl 0x8221bd38
	ctx.lr = 0x829F8CE8;
	sub_8221BD38(ctx, base);
	// 829F8CE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x829F8CEC; continue 'dispatch;
            }
            0x829F8CEC => {
    //   block [0x829F8CEC..0x829F8D04)
	// 829F8CEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F8CF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F8CF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F8CF8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829F8CFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F8D00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F8D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F8D08 size=148
    let mut pc: u32 = 0x829F8D08;
    'dispatch: loop {
        match pc {
            0x829F8D08 => {
    //   block [0x829F8D08..0x829F8D74)
	// 829F8D08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F8D0C: 482B0701  bl 0x82ca940c
	ctx.lr = 0x829F8D10;
	sub_82CA93D0(ctx, base);
	// 829F8D10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F8D14: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829F8D18: 38600088  li r3, 0x88
	ctx.r[3].s64 = 136;
	// 829F8D1C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F8D20: 4B826539  bl 0x8221f258
	ctx.lr = 0x829F8D24;
	sub_8221F258(ctx, base);
	// 829F8D24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F8D28: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F8D2C: 419A0048  beq cr6, 0x829f8d74
	if ctx.cr[6].eq {
	pc = 0x829F8D74; continue 'dispatch;
	}
	// 829F8D30: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F8D34: 4BA10FBD  bl 0x82409cf0
	ctx.lr = 0x829F8D38;
	sub_82409CF0(ctx, base);
	// 829F8D38: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F8D3C: 389E0078  addi r4, r30, 0x78
	ctx.r[4].s64 = ctx.r[30].s64 + 120;
	// 829F8D40: 394B1E10  addi r10, r11, 0x1e10
	ctx.r[10].s64 = ctx.r[11].s64 + 7696;
	// 829F8D44: 387F0078  addi r3, r31, 0x78
	ctx.r[3].s64 = ctx.r[31].s64 + 120;
	// 829F8D48: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829F8D4C: 4B7F74F5  bl 0x821f0240
	ctx.lr = 0x829F8D50;
	sub_821F0240(ctx, base);
	// 829F8D50: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 829F8D54: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829F8D58: 38E90E0C  addi r7, r9, 0xe0c
	ctx.r[7].s64 = ctx.r[9].s64 + 3596;
	// 829F8D5C: 911F0080  stw r8, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[8].u32 ) };
	// 829F8D60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F8D64: 90FF007C  stw r7, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[7].u32 ) };
	// 829F8D68: 80DE0084  lwz r6, 0x84(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) } as u64;
	// 829F8D6C: 90DF0084  stw r6, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[6].u32 ) };
	// 829F8D70: 48000008  b 0x829f8d78
	pc = 0x829F8D78; continue 'dispatch;
            }
            0x829F8D74 => {
    //   block [0x829F8D74..0x829F8D78)
	// 829F8D74: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829F8D78; continue 'dispatch;
            }
            0x829F8D78 => {
    //   block [0x829F8D78..0x829F8D90)
	// 829F8D78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F8D7C: 4B8C719D  bl 0x822bff18
	ctx.lr = 0x829F8D80;
	sub_822BFF18(ctx, base);
	// 829F8D80: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F8D84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F8D88: 419A0008  beq cr6, 0x829f8d90
	if ctx.cr[6].eq {
	pc = 0x829F8D90; continue 'dispatch;
	}
	// 829F8D8C: 4B788495  bl 0x82181220
	ctx.lr = 0x829F8D90;
	sub_82181220(ctx, base);
	pc = 0x829F8D90; continue 'dispatch;
            }
            0x829F8D90 => {
    //   block [0x829F8D90..0x829F8D9C)
	// 829F8D90: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F8D94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F8D98: 482B06C4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F8DA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F8DA0 size=108
    let mut pc: u32 = 0x829F8DA0;
    'dispatch: loop {
        match pc {
            0x829F8DA0 => {
    //   block [0x829F8DA0..0x829F8DF4)
	// 829F8DA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F8DA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F8DA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F8DAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F8DB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F8DB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F8DB8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F8DBC: 387F007C  addi r3, r31, 0x7c
	ctx.r[3].s64 = ctx.r[31].s64 + 124;
	// 829F8DC0: 4B8A1A91  bl 0x8229a850
	ctx.lr = 0x829F8DC4;
	sub_8229A850(ctx, base);
	// 829F8DC4: 387F0078  addi r3, r31, 0x78
	ctx.r[3].s64 = ctx.r[31].s64 + 120;
	// 829F8DC8: 4B81C011  bl 0x82214dd8
	ctx.lr = 0x829F8DCC;
	sub_82214DD8(ctx, base);
	// 829F8DCC: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 829F8DD0: 4B81C009  bl 0x82214dd8
	ctx.lr = 0x829F8DD4;
	sub_82214DD8(ctx, base);
	// 829F8DD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F8DD8: 4B7B3D59  bl 0x821acb30
	ctx.lr = 0x829F8DDC;
	sub_821ACB30(ctx, base);
	// 829F8DDC: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 829F8DE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F8DE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F8DE8: 419A000C  beq cr6, 0x829f8df4
	if ctx.cr[6].eq {
	pc = 0x829F8DF4; continue 'dispatch;
	}
	// 829F8DEC: 4B822F4D  bl 0x8221bd38
	ctx.lr = 0x829F8DF0;
	sub_8221BD38(ctx, base);
	// 829F8DF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x829F8DF4; continue 'dispatch;
            }
            0x829F8DF4 => {
    //   block [0x829F8DF4..0x829F8E0C)
	// 829F8DF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F8DF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F8DFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F8E00: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829F8E04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F8E08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F8E10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F8E10 size=136
    let mut pc: u32 = 0x829F8E10;
    'dispatch: loop {
        match pc {
            0x829F8E10 => {
    //   block [0x829F8E10..0x829F8E70)
	// 829F8E10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F8E14: 482B05F9  bl 0x82ca940c
	ctx.lr = 0x829F8E18;
	sub_82CA93D0(ctx, base);
	// 829F8E18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F8E1C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829F8E20: 38600084  li r3, 0x84
	ctx.r[3].s64 = 132;
	// 829F8E24: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F8E28: 4B826431  bl 0x8221f258
	ctx.lr = 0x829F8E2C;
	sub_8221F258(ctx, base);
	// 829F8E2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F8E30: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F8E34: 419A003C  beq cr6, 0x829f8e70
	if ctx.cr[6].eq {
	pc = 0x829F8E70; continue 'dispatch;
	}
	// 829F8E38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F8E3C: 4BA10EB5  bl 0x82409cf0
	ctx.lr = 0x829F8E40;
	sub_82409CF0(ctx, base);
	// 829F8E40: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F8E44: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 829F8E48: 392B1E68  addi r9, r11, 0x1e68
	ctx.r[9].s64 = ctx.r[11].s64 + 7784;
	// 829F8E4C: 390A0E0C  addi r8, r10, 0xe0c
	ctx.r[8].s64 = ctx.r[10].s64 + 3596;
	// 829F8E50: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 829F8E54: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829F8E58: 911F0078  stw r8, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[8].u32 ) };
	// 829F8E5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F8E60: 90FF007C  stw r7, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[7].u32 ) };
	// 829F8E64: 80DE0080  lwz r6, 0x80(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 829F8E68: 90DF0080  stw r6, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[6].u32 ) };
	// 829F8E6C: 48000008  b 0x829f8e74
	pc = 0x829F8E74; continue 'dispatch;
            }
            0x829F8E70 => {
    //   block [0x829F8E70..0x829F8E74)
	// 829F8E70: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829F8E74; continue 'dispatch;
            }
            0x829F8E74 => {
    //   block [0x829F8E74..0x829F8E8C)
	// 829F8E74: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F8E78: 4B8C70A1  bl 0x822bff18
	ctx.lr = 0x829F8E7C;
	sub_822BFF18(ctx, base);
	// 829F8E7C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F8E80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F8E84: 419A0008  beq cr6, 0x829f8e8c
	if ctx.cr[6].eq {
	pc = 0x829F8E8C; continue 'dispatch;
	}
	// 829F8E88: 4B788399  bl 0x82181220
	ctx.lr = 0x829F8E8C;
	sub_82181220(ctx, base);
	pc = 0x829F8E8C; continue 'dispatch;
            }
            0x829F8E8C => {
    //   block [0x829F8E8C..0x829F8E98)
	// 829F8E8C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F8E90: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F8E94: 482B05C8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F8E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F8E98 size=100
    let mut pc: u32 = 0x829F8E98;
    'dispatch: loop {
        match pc {
            0x829F8E98 => {
    //   block [0x829F8E98..0x829F8EE4)
	// 829F8E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F8E9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F8EA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F8EA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F8EA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F8EAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F8EB0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F8EB4: 387F0078  addi r3, r31, 0x78
	ctx.r[3].s64 = ctx.r[31].s64 + 120;
	// 829F8EB8: 4B8A1999  bl 0x8229a850
	ctx.lr = 0x829F8EBC;
	sub_8229A850(ctx, base);
	// 829F8EBC: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 829F8EC0: 4B81BF19  bl 0x82214dd8
	ctx.lr = 0x829F8EC4;
	sub_82214DD8(ctx, base);
	// 829F8EC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F8EC8: 4B7B3C69  bl 0x821acb30
	ctx.lr = 0x829F8ECC;
	sub_821ACB30(ctx, base);
	// 829F8ECC: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 829F8ED0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F8ED4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F8ED8: 419A000C  beq cr6, 0x829f8ee4
	if ctx.cr[6].eq {
	pc = 0x829F8EE4; continue 'dispatch;
	}
	// 829F8EDC: 4B822E5D  bl 0x8221bd38
	ctx.lr = 0x829F8EE0;
	sub_8221BD38(ctx, base);
	// 829F8EE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x829F8EE4; continue 'dispatch;
            }
            0x829F8EE4 => {
    //   block [0x829F8EE4..0x829F8EFC)
	// 829F8EE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F8EE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F8EEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F8EF0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829F8EF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F8EF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F8F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F8F00 size=700
    let mut pc: u32 = 0x829F8F00;
    'dispatch: loop {
        match pc {
            0x829F8F00 => {
    //   block [0x829F8F00..0x829F8F58)
	// 829F8F00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F8F04: 482B0505  bl 0x82ca9408
	ctx.lr = 0x829F8F08;
	sub_82CA93D0(ctx, base);
	// 829F8F08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F8F0C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 829F8F10: 80A30024  lwz r5, 0x24(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 829F8F14: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829F8F18: 54AB47FE  rlwinm r11, r5, 8, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x00FFFFFFu64;
	// 829F8F1C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 829F8F20: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 829F8F24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F8F28: 419A00F4  beq cr6, 0x829f901c
	if ctx.cr[6].eq {
	pc = 0x829F901C; continue 'dispatch;
	}
	// 829F8F2C: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F8F30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F8F34: 419A0024  beq cr6, 0x829f8f58
	if ctx.cr[6].eq {
	pc = 0x829F8F58; continue 'dispatch;
	}
	// 829F8F38: 894B0018  lbz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 829F8F3C: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F8F40: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 829F8F44: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829F8F48: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F8F4C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F8F50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F8F54: 480000CC  b 0x829f9020
	pc = 0x829F9020; continue 'dispatch;
            }
            0x829F8F58 => {
    //   block [0x829F8F58..0x829F8F74)
	// 829F8F58: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F8F5C: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 829F8F60: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 829F8F64: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829F8F68: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829F8F6C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F8F70: 40810054  ble 0x829f8fc4
	if !ctx.cr[0].gt {
	pc = 0x829F8FC4; continue 'dispatch;
	}
	pc = 0x829F8F74; continue 'dispatch;
            }
            0x829F8F74 => {
    //   block [0x829F8F74..0x829F8F94)
	// 829F8F74: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829F8F78: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F8F7C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829F8F80: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F8F84: 2F070018  cmpwi cr6, r7, 0x18
	ctx.cr[6].compare_i32(ctx.r[7].s32, 24, &mut ctx.xer);
	// 829F8F88: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829F8F8C: 41980008  blt cr6, 0x829f8f94
	if ctx.cr[6].lt {
	pc = 0x829F8F94; continue 'dispatch;
	}
	// 829F8F90: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x829F8F94; continue 'dispatch;
            }
            0x829F8F94 => {
    //   block [0x829F8F94..0x829F8FB0)
	// 829F8F94: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829F8F98: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829F8F9C: 419A0014  beq cr6, 0x829f8fb0
	if ctx.cr[6].eq {
	pc = 0x829F8FB0; continue 'dispatch;
	}
	// 829F8FA0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829F8FA4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F8FA8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F8FAC: 4800000C  b 0x829f8fb8
	pc = 0x829F8FB8; continue 'dispatch;
            }
            0x829F8FB0 => {
    //   block [0x829F8FB0..0x829F8FB8)
	// 829F8FB0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829F8FB4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829F8FB8; continue 'dispatch;
            }
            0x829F8FB8 => {
    //   block [0x829F8FB8..0x829F8FC4)
	// 829F8FB8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F8FBC: 4199FFB8  bgt cr6, 0x829f8f74
	if ctx.cr[6].gt {
	pc = 0x829F8F74; continue 'dispatch;
	}
	// 829F8FC0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x829F8FC4; continue 'dispatch;
            }
            0x829F8FC4 => {
    //   block [0x829F8FC4..0x829F8FE0)
	// 829F8FC4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829F8FC8: 419A0040  beq cr6, 0x829f9008
	if ctx.cr[6].eq {
	pc = 0x829F9008; continue 'dispatch;
	}
	// 829F8FCC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F8FD0: 2F0B0018  cmpwi cr6, r11, 0x18
	ctx.cr[6].compare_i32(ctx.r[11].s32, 24, &mut ctx.xer);
	// 829F8FD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F8FD8: 41990008  bgt cr6, 0x829f8fe0
	if ctx.cr[6].gt {
	pc = 0x829F8FE0; continue 'dispatch;
	}
	// 829F8FDC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x829F8FE0; continue 'dispatch;
            }
            0x829F8FE0 => {
    //   block [0x829F8FE0..0x829F9008)
	// 829F8FE0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F8FE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F8FE8: 409A0020  bne cr6, 0x829f9008
	if !ctx.cr[6].eq {
	pc = 0x829F9008; continue 'dispatch;
	}
	// 829F8FEC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829F8FF0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829F8FF4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F8FF8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F8FFC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F9000: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F9004: 4800001C  b 0x829f9020
	pc = 0x829F9020; continue 'dispatch;
            }
            0x829F9008 => {
    //   block [0x829F9008..0x829F901C)
	// 829F9008: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829F900C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F9010: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F9014: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F9018: 48000008  b 0x829f9020
	pc = 0x829F9020; continue 'dispatch;
            }
            0x829F901C => {
    //   block [0x829F901C..0x829F9020)
	// 829F901C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x829F9020; continue 'dispatch;
            }
            0x829F9020 => {
    //   block [0x829F9020..0x829F9060)
	// 829F9020: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F9024: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F9028: 419A018C  beq cr6, 0x829f91b4
	if ctx.cr[6].eq {
	pc = 0x829F91B4; continue 'dispatch;
	}
	// 829F902C: 54AB57FE  rlwinm r11, r5, 0xa, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x003FFFFFu64;
	// 829F9030: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F9034: 419A00E4  beq cr6, 0x829f9118
	if ctx.cr[6].eq {
	pc = 0x829F9118; continue 'dispatch;
	}
	// 829F9038: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F903C: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F9040: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F9044: 419A001C  beq cr6, 0x829f9060
	if ctx.cr[6].eq {
	pc = 0x829F9060; continue 'dispatch;
	}
	// 829F9048: 896B0016  lbz r11, 0x16(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(22 as u32) ) } as u64;
	// 829F904C: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 829F9050: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 829F9054: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F9058: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829F905C: 480000C4  b 0x829f9120
	pc = 0x829F9120; continue 'dispatch;
            }
            0x829F9060 => {
    //   block [0x829F9060..0x829F9078)
	// 829F9060: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 829F9064: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 829F9068: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829F906C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829F9070: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F9074: 40810054  ble 0x829f90c8
	if !ctx.cr[0].gt {
	pc = 0x829F90C8; continue 'dispatch;
	}
	pc = 0x829F9078; continue 'dispatch;
            }
            0x829F9078 => {
    //   block [0x829F9078..0x829F9098)
	// 829F9078: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829F907C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F9080: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829F9084: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9088: 2F070016  cmpwi cr6, r7, 0x16
	ctx.cr[6].compare_i32(ctx.r[7].s32, 22, &mut ctx.xer);
	// 829F908C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829F9090: 41980008  blt cr6, 0x829f9098
	if ctx.cr[6].lt {
	pc = 0x829F9098; continue 'dispatch;
	}
	// 829F9094: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x829F9098; continue 'dispatch;
            }
            0x829F9098 => {
    //   block [0x829F9098..0x829F90B4)
	// 829F9098: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829F909C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829F90A0: 419A0014  beq cr6, 0x829f90b4
	if ctx.cr[6].eq {
	pc = 0x829F90B4; continue 'dispatch;
	}
	// 829F90A4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829F90A8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F90AC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F90B0: 4800000C  b 0x829f90bc
	pc = 0x829F90BC; continue 'dispatch;
            }
            0x829F90B4 => {
    //   block [0x829F90B4..0x829F90BC)
	// 829F90B4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829F90B8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829F90BC; continue 'dispatch;
            }
            0x829F90BC => {
    //   block [0x829F90BC..0x829F90C8)
	// 829F90BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F90C0: 4199FFB8  bgt cr6, 0x829f9078
	if ctx.cr[6].gt {
	pc = 0x829F9078; continue 'dispatch;
	}
	// 829F90C4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x829F90C8; continue 'dispatch;
            }
            0x829F90C8 => {
    //   block [0x829F90C8..0x829F90E4)
	// 829F90C8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829F90CC: 419A003C  beq cr6, 0x829f9108
	if ctx.cr[6].eq {
	pc = 0x829F9108; continue 'dispatch;
	}
	// 829F90D0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F90D4: 2F0B0016  cmpwi cr6, r11, 0x16
	ctx.cr[6].compare_i32(ctx.r[11].s32, 22, &mut ctx.xer);
	// 829F90D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F90DC: 41990008  bgt cr6, 0x829f90e4
	if ctx.cr[6].gt {
	pc = 0x829F90E4; continue 'dispatch;
	}
	// 829F90E0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x829F90E4; continue 'dispatch;
            }
            0x829F90E4 => {
    //   block [0x829F90E4..0x829F9108)
	// 829F90E4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F90E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F90EC: 409A001C  bne cr6, 0x829f9108
	if !ctx.cr[6].eq {
	pc = 0x829F9108; continue 'dispatch;
	}
	// 829F90F0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829F90F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829F90F8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 829F90FC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F9100: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F9104: 4800001C  b 0x829f9120
	pc = 0x829F9120; continue 'dispatch;
            }
            0x829F9108 => {
    //   block [0x829F9108..0x829F9118)
	// 829F9108: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829F910C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829F9110: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F9114: 4800000C  b 0x829f9120
	pc = 0x829F9120; continue 'dispatch;
            }
            0x829F9118 => {
    //   block [0x829F9118..0x829F9120)
	// 829F9118: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829F911C: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	pc = 0x829F9120; continue 'dispatch;
            }
            0x829F9120 => {
    //   block [0x829F9120..0x829F9150)
	// 829F9120: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 829F9124: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F9128: 419A0028  beq cr6, 0x829f9150
	if ctx.cr[6].eq {
	pc = 0x829F9150; continue 'dispatch;
	}
	// 829F912C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829F9130: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F9134: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 829F9138: 4BBF3CE9  bl 0x825ece20
	ctx.lr = 0x829F913C;
	sub_825ECE20(ctx, base);
	// 829F913C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829F9140: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F9144: 4BB039DD  bl 0x824fcb20
	ctx.lr = 0x829F9148;
	sub_824FCB20(ctx, base);
	// 829F9148: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829F914C: 482B030C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x829F9150 => {
    //   block [0x829F9150..0x829F91B4)
	// 829F9150: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829F9154: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F9158: 4BB039C9  bl 0x824fcb20
	ctx.lr = 0x829F915C;
	sub_824FCB20(ctx, base);
	// 829F915C: 807D007C  lwz r3, 0x7c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(124 as u32) ) } as u64;
	// 829F9160: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 829F9164: 419A0050  beq cr6, 0x829f91b4
	if ctx.cr[6].eq {
	pc = 0x829F91B4; continue 'dispatch;
	}
	// 829F9168: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F916C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 829F9170: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 829F9174: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829F9178: 4E800421  bctrl
	ctx.lr = 0x829F917C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829F917C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F9180: 419A0034  beq cr6, 0x829f91b4
	if ctx.cr[6].eq {
	pc = 0x829F91B4; continue 'dispatch;
	}
	// 829F9184: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829F9188: 4B98CA81  bl 0x82385c08
	ctx.lr = 0x829F918C;
	sub_82385C08(ctx, base);
	// 829F918C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829F9190: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F9194: 419A0020  beq cr6, 0x829f91b4
	if ctx.cr[6].eq {
	pc = 0x829F91B4; continue 'dispatch;
	}
	// 829F9198: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829F919C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829F91A0: 806B0038  lwz r3, 0x38(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 829F91A4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F91A8: 812A0024  lwz r9, 0x24(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 829F91AC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 829F91B0: 4E800421  bctrl
	ctx.lr = 0x829F91B4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x829F91B4 => {
    //   block [0x829F91B4..0x829F91BC)
	// 829F91B4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829F91B8: 482B02A0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F91C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F91C0 size=1044
    let mut pc: u32 = 0x829F91C0;
    'dispatch: loop {
        match pc {
            0x829F91C0 => {
    //   block [0x829F91C0..0x829F91E0)
	// 829F91C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F91C4: 482B0241  bl 0x82ca9404
	ctx.lr = 0x829F91C8;
	sub_82CA93D0(ctx, base);
	// 829F91C8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F91CC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829F91D0: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 829F91D4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829F91D8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829F91DC: 39097088  addi r8, r9, 0x7088
	ctx.r[8].s64 = ctx.r[9].s64 + 28808;
	pc = 0x829F91E0; continue 'dispatch;
            }
            0x829F91E0 => {
    //   block [0x829F91E0..0x829F921C)
	// 829F91E0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 829F91E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F91E8: 7D604028  lwarx r11, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 829F91EC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829F91F0: 7D60412D  stwcx. r11, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F91F4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F91F8: 4082FFE8  bne 0x829f91e0
	if !ctx.cr[0].eq {
	pc = 0x829F91E0; continue 'dispatch;
	}
	// 829F91FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F9200: 83C60000  lwz r30, 0(r6)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9204: 3BAB0CA0  addi r29, r11, 0xca0
	ctx.r[29].s64 = ctx.r[11].s64 + 3232;
	// 829F9208: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829F920C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F9210: 409A003C  bne cr6, 0x829f924c
	if !ctx.cr[6].eq {
	pc = 0x829F924C; continue 'dispatch;
	}
	// 829F9214: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 829F9218: 396B1B84  addi r11, r11, 0x1b84
	ctx.r[11].s64 = ctx.r[11].s64 + 7044;
	pc = 0x829F921C; continue 'dispatch;
            }
            0x829F921C => {
    //   block [0x829F921C..0x829F9240)
	// 829F921C: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9220: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9224: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829F9228: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 829F922C: 419A0014  beq cr6, 0x829f9240
	if ctx.cr[6].eq {
	pc = 0x829F9240; continue 'dispatch;
	}
	// 829F9230: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829F9234: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F9238: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829F923C: 419AFFE0  beq cr6, 0x829f921c
	if ctx.cr[6].eq {
	pc = 0x829F921C; continue 'dispatch;
	}
	pc = 0x829F9240; continue 'dispatch;
            }
            0x829F9240 => {
    //   block [0x829F9240..0x829F924C)
	// 829F9240: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 829F9244: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 829F9248: 48000018  b 0x829f9260
	pc = 0x829F9260; continue 'dispatch;
            }
            0x829F924C => {
    //   block [0x829F924C..0x829F9260)
	// 829F924C: 388B1B84  addi r4, r11, 0x1b84
	ctx.r[4].s64 = ctx.r[11].s64 + 7044;
	// 829F9250: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9254: 4B8745A5  bl 0x8226d7f8
	ctx.lr = 0x829F9258;
	sub_8226D7F8(ctx, base);
	// 829F9258: 7C6A0034  cntlzw r10, r3
	ctx.r[10].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 829F925C: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	pc = 0x829F9260; continue 'dispatch;
            }
            0x829F9260 => {
    //   block [0x829F9260..0x829F9278)
	// 829F9260: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F9264: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F9268: 419A0010  beq cr6, 0x829f9278
	if ctx.cr[6].eq {
	pc = 0x829F9278; continue 'dispatch;
	}
	// 829F926C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829F9270: 388BB780  addi r4, r11, -0x4880
	ctx.r[4].s64 = ctx.r[11].s64 + -18560;
	// 829F9274: 48000070  b 0x829f92e4
	pc = 0x829F92E4; continue 'dispatch;
            }
            0x829F9278 => {
    //   block [0x829F9278..0x829F928C)
	// 829F9278: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829F927C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F9280: 409A003C  bne cr6, 0x829f92bc
	if !ctx.cr[6].eq {
	pc = 0x829F92BC; continue 'dispatch;
	}
	// 829F9284: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 829F9288: 396B1B98  addi r11, r11, 0x1b98
	ctx.r[11].s64 = ctx.r[11].s64 + 7064;
	pc = 0x829F928C; continue 'dispatch;
            }
            0x829F928C => {
    //   block [0x829F928C..0x829F92B0)
	// 829F928C: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9290: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9294: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829F9298: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 829F929C: 419A0014  beq cr6, 0x829f92b0
	if ctx.cr[6].eq {
	pc = 0x829F92B0; continue 'dispatch;
	}
	// 829F92A0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829F92A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F92A8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829F92AC: 419AFFE0  beq cr6, 0x829f928c
	if ctx.cr[6].eq {
	pc = 0x829F928C; continue 'dispatch;
	}
	pc = 0x829F92B0; continue 'dispatch;
            }
            0x829F92B0 => {
    //   block [0x829F92B0..0x829F92BC)
	// 829F92B0: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 829F92B4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 829F92B8: 48000018  b 0x829f92d0
	pc = 0x829F92D0; continue 'dispatch;
            }
            0x829F92BC => {
    //   block [0x829F92BC..0x829F92D0)
	// 829F92BC: 388B1B98  addi r4, r11, 0x1b98
	ctx.r[4].s64 = ctx.r[11].s64 + 7064;
	// 829F92C0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F92C4: 4B874535  bl 0x8226d7f8
	ctx.lr = 0x829F92C8;
	sub_8226D7F8(ctx, base);
	// 829F92C8: 7C6A0034  cntlzw r10, r3
	ctx.r[10].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 829F92CC: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	pc = 0x829F92D0; continue 'dispatch;
            }
            0x829F92D0 => {
    //   block [0x829F92D0..0x829F92E4)
	// 829F92D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F92D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F92D8: 419A02EC  beq cr6, 0x829f95c4
	if ctx.cr[6].eq {
	pc = 0x829F95C4; continue 'dispatch;
	}
	// 829F92DC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829F92E0: 388BB784  addi r4, r11, -0x487c
	ctx.r[4].s64 = ctx.r[11].s64 + -18556;
	pc = 0x829F92E4; continue 'dispatch;
            }
            0x829F92E4 => {
    //   block [0x829F92E4..0x829F9314)
	// 829F92E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F92E8: 4B86BEB9  bl 0x822651a0
	ctx.lr = 0x829F92EC;
	sub_822651A0(ctx, base);
	// 829F92EC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829F92F0: 4B8A5B89  bl 0x8229ee78
	ctx.lr = 0x829F92F4;
	sub_8229EE78(ctx, base);
	// 829F92F4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829F92F8: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 829F92FC: 419A0018  beq cr6, 0x829f9314
	if ctx.cr[6].eq {
	pc = 0x829F9314; continue 'dispatch;
	}
	// 829F9300: 897B0090  lbz r11, 0x90(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(144 as u32) ) } as u64;
	// 829F9304: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829F9308: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F930C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F9310: 409A0008  bne cr6, 0x829f9318
	if !ctx.cr[6].eq {
	pc = 0x829F9318; continue 'dispatch;
	}
	pc = 0x829F9314; continue 'dispatch;
            }
            0x829F9314 => {
    //   block [0x829F9314..0x829F9318)
	// 829F9314: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x829F9318; continue 'dispatch;
            }
            0x829F9318 => {
    //   block [0x829F9318..0x829F9364)
	// 829F9318: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F931C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F9320: 419A02A4  beq cr6, 0x829f95c4
	if ctx.cr[6].eq {
	pc = 0x829F95C4; continue 'dispatch;
	}
	// 829F9324: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829F9328: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 829F932C: 4B77B13D  bl 0x82174468
	ctx.lr = 0x829F9330;
	sub_82174468(ctx, base);
	// 829F9330: 89630024  lbz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 829F9334: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 829F9338: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F933C: 419A00D8  beq cr6, 0x829f9414
	if ctx.cr[6].eq {
	pc = 0x829F9414; continue 'dispatch;
	}
	// 829F9340: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F9344: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F9348: 419A001C  beq cr6, 0x829f9364
	if ctx.cr[6].eq {
	pc = 0x829F9364; continue 'dispatch;
	}
	// 829F934C: 894B0018  lbz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 829F9350: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F9354: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 829F9358: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829F935C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F9360: 480000B0  b 0x829f9410
	pc = 0x829F9410; continue 'dispatch;
            }
            0x829F9364 => {
    //   block [0x829F9364..0x829F9380)
	// 829F9364: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F9368: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 829F936C: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 829F9370: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829F9374: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 829F9378: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F937C: 40810054  ble 0x829f93d0
	if !ctx.cr[0].gt {
	pc = 0x829F93D0; continue 'dispatch;
	}
	pc = 0x829F9380; continue 'dispatch;
            }
            0x829F9380 => {
    //   block [0x829F9380..0x829F93A0)
	// 829F9380: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829F9384: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F9388: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829F938C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9390: 2F070018  cmpwi cr6, r7, 0x18
	ctx.cr[6].compare_i32(ctx.r[7].s32, 24, &mut ctx.xer);
	// 829F9394: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829F9398: 41980008  blt cr6, 0x829f93a0
	if ctx.cr[6].lt {
	pc = 0x829F93A0; continue 'dispatch;
	}
	// 829F939C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x829F93A0; continue 'dispatch;
            }
            0x829F93A0 => {
    //   block [0x829F93A0..0x829F93BC)
	// 829F93A0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829F93A4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829F93A8: 419A0014  beq cr6, 0x829f93bc
	if ctx.cr[6].eq {
	pc = 0x829F93BC; continue 'dispatch;
	}
	// 829F93AC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829F93B0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F93B4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F93B8: 4800000C  b 0x829f93c4
	pc = 0x829F93C4; continue 'dispatch;
            }
            0x829F93BC => {
    //   block [0x829F93BC..0x829F93C4)
	// 829F93BC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829F93C0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829F93C4; continue 'dispatch;
            }
            0x829F93C4 => {
    //   block [0x829F93C4..0x829F93D0)
	// 829F93C4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F93C8: 4199FFB8  bgt cr6, 0x829f9380
	if ctx.cr[6].gt {
	pc = 0x829F9380; continue 'dispatch;
	}
	// 829F93CC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x829F93D0; continue 'dispatch;
            }
            0x829F93D0 => {
    //   block [0x829F93D0..0x829F93EC)
	// 829F93D0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829F93D4: 419A0034  beq cr6, 0x829f9408
	if ctx.cr[6].eq {
	pc = 0x829F9408; continue 'dispatch;
	}
	// 829F93D8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F93DC: 2F0B0018  cmpwi cr6, r11, 0x18
	ctx.cr[6].compare_i32(ctx.r[11].s32, 24, &mut ctx.xer);
	// 829F93E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F93E4: 41990008  bgt cr6, 0x829f93ec
	if ctx.cr[6].gt {
	pc = 0x829F93EC; continue 'dispatch;
	}
	// 829F93E8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x829F93EC; continue 'dispatch;
            }
            0x829F93EC => {
    //   block [0x829F93EC..0x829F9408)
	// 829F93EC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F93F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F93F4: 409A0014  bne cr6, 0x829f9408
	if !ctx.cr[6].eq {
	pc = 0x829F9408; continue 'dispatch;
	}
	// 829F93F8: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829F93FC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 829F9400: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829F9404: 48000008  b 0x829f940c
	pc = 0x829F940C; continue 'dispatch;
            }
            0x829F9408 => {
    //   block [0x829F9408..0x829F940C)
	// 829F9408: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x829F940C; continue 'dispatch;
            }
            0x829F940C => {
    //   block [0x829F940C..0x829F9410)
	// 829F940C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x829F9410; continue 'dispatch;
            }
            0x829F9410 => {
    //   block [0x829F9410..0x829F9414)
	// 829F9410: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	pc = 0x829F9414; continue 'dispatch;
            }
            0x829F9414 => {
    //   block [0x829F9414..0x829F9458)
	// 829F9414: 817C0088  lwz r11, 0x88(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(136 as u32) ) } as u64;
	// 829F9418: 3BDC0084  addi r30, r28, 0x84
	ctx.r[30].s64 = ctx.r[28].s64 + 132;
	// 829F941C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F9420: 419A0038  beq cr6, 0x829f9458
	if ctx.cr[6].eq {
	pc = 0x829F9458; continue 'dispatch;
	}
	// 829F9424: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9428: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F942C: 419A0080  beq cr6, 0x829f94ac
	if ctx.cr[6].eq {
	pc = 0x829F94AC; continue 'dispatch;
	}
	// 829F9430: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F9434: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F9438: 419A0020  beq cr6, 0x829f9458
	if ctx.cr[6].eq {
	pc = 0x829F9458; continue 'dispatch;
	}
	// 829F943C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F9440: 4B77A9F9  bl 0x82173e38
	ctx.lr = 0x829F9444;
	sub_82173E38(ctx, base);
	// 829F9444: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 829F9448: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829F944C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F9450: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F9454: 409A0008  bne cr6, 0x829f945c
	if !ctx.cr[6].eq {
	pc = 0x829F945C; continue 'dispatch;
	}
	pc = 0x829F9458; continue 'dispatch;
            }
            0x829F9458 => {
    //   block [0x829F9458..0x829F945C)
	// 829F9458: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x829F945C; continue 'dispatch;
            }
            0x829F945C => {
    //   block [0x829F945C..0x829F94AC)
	// 829F945C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F9460: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F9464: 419A0150  beq cr6, 0x829f95b4
	if ctx.cr[6].eq {
	pc = 0x829F95B4; continue 'dispatch;
	}
	// 829F9468: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F946C: 4B77A9CD  bl 0x82173e38
	ctx.lr = 0x829F9470;
	sub_82173E38(ctx, base);
	// 829F9470: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 829F9474: 556A57FE  rlwinm r10, r11, 0xa, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x003FFFFFu64;
	// 829F9478: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F947C: 419A0100  beq cr6, 0x829f957c
	if ctx.cr[6].eq {
	pc = 0x829F957C; continue 'dispatch;
	}
	// 829F9480: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F9484: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F9488: 419A0030  beq cr6, 0x829f94b8
	if ctx.cr[6].eq {
	pc = 0x829F94B8; continue 'dispatch;
	}
	// 829F948C: 894B0016  lbz r10, 0x16(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(22 as u32) ) } as u64;
	// 829F9490: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F9494: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 829F9498: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829F949C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F94A0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F94A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F94A8: 480000D8  b 0x829f9580
	pc = 0x829F9580; continue 'dispatch;
            }
            0x829F94AC => {
    //   block [0x829F94AC..0x829F94B8)
	// 829F94AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F94B0: 4B79A989  bl 0x82193e38
	ctx.lr = 0x829F94B4;
	sub_82193E38(ctx, base);
	// 829F94B4: 4BFFFFA4  b 0x829f9458
	pc = 0x829F9458; continue 'dispatch;
            }
            0x829F94B8 => {
    //   block [0x829F94B8..0x829F94D4)
	// 829F94B8: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F94BC: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 829F94C0: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 829F94C4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829F94C8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 829F94CC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F94D0: 40810054  ble 0x829f9524
	if !ctx.cr[0].gt {
	pc = 0x829F9524; continue 'dispatch;
	}
	pc = 0x829F94D4; continue 'dispatch;
            }
            0x829F94D4 => {
    //   block [0x829F94D4..0x829F94F4)
	// 829F94D4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829F94D8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F94DC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829F94E0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F94E4: 2F070016  cmpwi cr6, r7, 0x16
	ctx.cr[6].compare_i32(ctx.r[7].s32, 22, &mut ctx.xer);
	// 829F94E8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829F94EC: 41980008  blt cr6, 0x829f94f4
	if ctx.cr[6].lt {
	pc = 0x829F94F4; continue 'dispatch;
	}
	// 829F94F0: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x829F94F4; continue 'dispatch;
            }
            0x829F94F4 => {
    //   block [0x829F94F4..0x829F9510)
	// 829F94F4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829F94F8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829F94FC: 419A0014  beq cr6, 0x829f9510
	if ctx.cr[6].eq {
	pc = 0x829F9510; continue 'dispatch;
	}
	// 829F9500: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829F9504: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F9508: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F950C: 4800000C  b 0x829f9518
	pc = 0x829F9518; continue 'dispatch;
            }
            0x829F9510 => {
    //   block [0x829F9510..0x829F9518)
	// 829F9510: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829F9514: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829F9518; continue 'dispatch;
            }
            0x829F9518 => {
    //   block [0x829F9518..0x829F9524)
	// 829F9518: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F951C: 4199FFB8  bgt cr6, 0x829f94d4
	if ctx.cr[6].gt {
	pc = 0x829F94D4; continue 'dispatch;
	}
	// 829F9520: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x829F9524; continue 'dispatch;
            }
            0x829F9524 => {
    //   block [0x829F9524..0x829F9540)
	// 829F9524: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829F9528: 419A0040  beq cr6, 0x829f9568
	if ctx.cr[6].eq {
	pc = 0x829F9568; continue 'dispatch;
	}
	// 829F952C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9530: 2F0B0016  cmpwi cr6, r11, 0x16
	ctx.cr[6].compare_i32(ctx.r[11].s32, 22, &mut ctx.xer);
	// 829F9534: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F9538: 41990008  bgt cr6, 0x829f9540
	if ctx.cr[6].gt {
	pc = 0x829F9540; continue 'dispatch;
	}
	// 829F953C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x829F9540; continue 'dispatch;
            }
            0x829F9540 => {
    //   block [0x829F9540..0x829F9568)
	// 829F9540: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F9544: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F9548: 409A0020  bne cr6, 0x829f9568
	if !ctx.cr[6].eq {
	pc = 0x829F9568; continue 'dispatch;
	}
	// 829F954C: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829F9550: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 829F9554: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829F9558: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F955C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F9560: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F9564: 4800001C  b 0x829f9580
	pc = 0x829F9580; continue 'dispatch;
            }
            0x829F9568 => {
    //   block [0x829F9568..0x829F957C)
	// 829F9568: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 829F956C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F9570: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829F9574: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F9578: 48000008  b 0x829f9580
	pc = 0x829F9580; continue 'dispatch;
            }
            0x829F957C => {
    //   block [0x829F957C..0x829F9580)
	// 829F957C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x829F9580; continue 'dispatch;
            }
            0x829F9580 => {
    //   block [0x829F9580..0x829F95B4)
	// 829F9580: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F9584: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F9588: 419A002C  beq cr6, 0x829f95b4
	if ctx.cr[6].eq {
	pc = 0x829F95B4; continue 'dispatch;
	}
	// 829F958C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829F9590: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F9594: 4B8DCB1D  bl 0x822d60b0
	ctx.lr = 0x829F9598;
	sub_822D60B0(ctx, base);
	// 829F9598: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829F959C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F95A0: 419A0014  beq cr6, 0x829f95b4
	if ctx.cr[6].eq {
	pc = 0x829F95B4; continue 'dispatch;
	}
	// 829F95A4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829F95A8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829F95AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F95B0: 4BBF3231  bl 0x825ec7e0
	ctx.lr = 0x829F95B4;
	sub_825EC7E0(ctx, base);
	pc = 0x829F95B4; continue 'dispatch;
            }
            0x829F95B4 => {
    //   block [0x829F95B4..0x829F95C4)
	// 829F95B4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 829F95B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829F95BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F95C0: 4BB02019  bl 0x824fb5d8
	ctx.lr = 0x829F95C4;
	sub_824FB5D8(ctx, base);
	pc = 0x829F95C4; continue 'dispatch;
            }
            0x829F95C4 => {
    //   block [0x829F95C4..0x829F95D4)
	// 829F95C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F95C8: 4B81B811  bl 0x82214dd8
	ctx.lr = 0x829F95CC;
	sub_82214DD8(ctx, base);
	// 829F95CC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829F95D0: 482AFE84  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F95D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F95D8 size=684
    let mut pc: u32 = 0x829F95D8;
    'dispatch: loop {
        match pc {
            0x829F95D8 => {
    //   block [0x829F95D8..0x829F95FC)
	// 829F95D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F95DC: 482AFE29  bl 0x82ca9404
	ctx.lr = 0x829F95E0;
	sub_82CA93D0(ctx, base);
	// 829F95E0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F95E4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829F95E8: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 829F95EC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829F95F0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829F95F4: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 829F95F8: 39097088  addi r8, r9, 0x7088
	ctx.r[8].s64 = ctx.r[9].s64 + 28808;
	pc = 0x829F95FC; continue 'dispatch;
            }
            0x829F95FC => {
    //   block [0x829F95FC..0x829F963C)
	// 829F95FC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 829F9600: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F9604: 7D604028  lwarx r11, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 829F9608: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829F960C: 7D60412D  stwcx. r11, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F9610: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F9614: 4082FFE8  bne 0x829f95fc
	if !ctx.cr[0].eq {
	pc = 0x829F95FC; continue 'dispatch;
	}
	// 829F9618: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 829F961C: 387C000C  addi r3, r28, 0xc
	ctx.r[3].s64 = ctx.r[28].s64 + 12;
	// 829F9620: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F9624: 419A001C  beq cr6, 0x829f9640
	if ctx.cr[6].eq {
	pc = 0x829F9640; continue 'dispatch;
	}
	// 829F9628: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F962C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F9630: 419A000C  beq cr6, 0x829f963c
	if ctx.cr[6].eq {
	pc = 0x829F963C; continue 'dispatch;
	}
	// 829F9634: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F9638: 4800000C  b 0x829f9644
	pc = 0x829F9644; continue 'dispatch;
            }
            0x829F963C => {
    //   block [0x829F963C..0x829F9640)
	// 829F963C: 4B79A7FD  bl 0x82193e38
	ctx.lr = 0x829F9640;
	sub_82193E38(ctx, base);
	pc = 0x829F9640; continue 'dispatch;
            }
            0x829F9640 => {
    //   block [0x829F9640..0x829F9644)
	// 829F9640: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x829F9644; continue 'dispatch;
            }
            0x829F9644 => {
    //   block [0x829F9644..0x829F9668)
	// 829F9644: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9648: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829F964C: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 829F9650: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829F9654: 3BAA0CA0  addi r29, r10, 0xca0
	ctx.r[29].s64 = ctx.r[10].s64 + 3232;
	// 829F9658: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F965C: 409A003C  bne cr6, 0x829f9698
	if !ctx.cr[6].eq {
	pc = 0x829F9698; continue 'dispatch;
	}
	// 829F9660: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 829F9664: 396B1B84  addi r11, r11, 0x1b84
	ctx.r[11].s64 = ctx.r[11].s64 + 7044;
	pc = 0x829F9668; continue 'dispatch;
            }
            0x829F9668 => {
    //   block [0x829F9668..0x829F968C)
	// 829F9668: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F966C: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9670: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829F9674: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 829F9678: 419A0014  beq cr6, 0x829f968c
	if ctx.cr[6].eq {
	pc = 0x829F968C; continue 'dispatch;
	}
	// 829F967C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829F9680: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F9684: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829F9688: 419AFFE0  beq cr6, 0x829f9668
	if ctx.cr[6].eq {
	pc = 0x829F9668; continue 'dispatch;
	}
	pc = 0x829F968C; continue 'dispatch;
            }
            0x829F968C => {
    //   block [0x829F968C..0x829F9698)
	// 829F968C: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 829F9690: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 829F9694: 48000018  b 0x829f96ac
	pc = 0x829F96AC; continue 'dispatch;
            }
            0x829F9698 => {
    //   block [0x829F9698..0x829F96AC)
	// 829F9698: 388B1B84  addi r4, r11, 0x1b84
	ctx.r[4].s64 = ctx.r[11].s64 + 7044;
	// 829F969C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F96A0: 4B874159  bl 0x8226d7f8
	ctx.lr = 0x829F96A4;
	sub_8226D7F8(ctx, base);
	// 829F96A4: 7C6A0034  cntlzw r10, r3
	ctx.r[10].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 829F96A8: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	pc = 0x829F96AC; continue 'dispatch;
            }
            0x829F96AC => {
    //   block [0x829F96AC..0x829F96CC)
	// 829F96AC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F96B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F96B4: 419A0018  beq cr6, 0x829f96cc
	if ctx.cr[6].eq {
	pc = 0x829F96CC; continue 'dispatch;
	}
	// 829F96B8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829F96BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F96C0: 388BB780  addi r4, r11, -0x4880
	ctx.r[4].s64 = ctx.r[11].s64 + -18560;
	// 829F96C4: 4B86BADD  bl 0x822651a0
	ctx.lr = 0x829F96C8;
	sub_822651A0(ctx, base);
	// 829F96C8: 48000084  b 0x829f974c
	pc = 0x829F974C; continue 'dispatch;
            }
            0x829F96CC => {
    //   block [0x829F96CC..0x829F96E0)
	// 829F96CC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829F96D0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F96D4: 409A003C  bne cr6, 0x829f9710
	if !ctx.cr[6].eq {
	pc = 0x829F9710; continue 'dispatch;
	}
	// 829F96D8: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 829F96DC: 396B1B98  addi r11, r11, 0x1b98
	ctx.r[11].s64 = ctx.r[11].s64 + 7064;
	pc = 0x829F96E0; continue 'dispatch;
            }
            0x829F96E0 => {
    //   block [0x829F96E0..0x829F9704)
	// 829F96E0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F96E4: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F96E8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829F96EC: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 829F96F0: 419A0014  beq cr6, 0x829f9704
	if ctx.cr[6].eq {
	pc = 0x829F9704; continue 'dispatch;
	}
	// 829F96F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829F96F8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F96FC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829F9700: 419AFFE0  beq cr6, 0x829f96e0
	if ctx.cr[6].eq {
	pc = 0x829F96E0; continue 'dispatch;
	}
	pc = 0x829F9704; continue 'dispatch;
            }
            0x829F9704 => {
    //   block [0x829F9704..0x829F9710)
	// 829F9704: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 829F9708: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 829F970C: 48000018  b 0x829f9724
	pc = 0x829F9724; continue 'dispatch;
            }
            0x829F9710 => {
    //   block [0x829F9710..0x829F9724)
	// 829F9710: 388B1B98  addi r4, r11, 0x1b98
	ctx.r[4].s64 = ctx.r[11].s64 + 7064;
	// 829F9714: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9718: 4B8740E1  bl 0x8226d7f8
	ctx.lr = 0x829F971C;
	sub_8226D7F8(ctx, base);
	// 829F971C: 7C6A0034  cntlzw r10, r3
	ctx.r[10].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 829F9720: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	pc = 0x829F9724; continue 'dispatch;
            }
            0x829F9724 => {
    //   block [0x829F9724..0x829F974C)
	// 829F9724: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F9728: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F972C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F9730: 419A0148  beq cr6, 0x829f9878
	if ctx.cr[6].eq {
	pc = 0x829F9878; continue 'dispatch;
	}
	// 829F9734: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829F9738: 388BB784  addi r4, r11, -0x487c
	ctx.r[4].s64 = ctx.r[11].s64 + -18556;
	// 829F973C: 4B86BA65  bl 0x822651a0
	ctx.lr = 0x829F9740;
	sub_822651A0(ctx, base);
	// 829F9740: 387C0084  addi r3, r28, 0x84
	ctx.r[3].s64 = ctx.r[28].s64 + 132;
	// 829F9744: 4B77A6F5  bl 0x82173e38
	ctx.lr = 0x829F9748;
	sub_82173E38(ctx, base);
	// 829F9748: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	pc = 0x829F974C; continue 'dispatch;
            }
            0x829F974C => {
    //   block [0x829F974C..0x829F9768)
	// 829F974C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 829F9750: 419A0018  beq cr6, 0x829f9768
	if ctx.cr[6].eq {
	pc = 0x829F9768; continue 'dispatch;
	}
	// 829F9754: 897B0090  lbz r11, 0x90(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(144 as u32) ) } as u64;
	// 829F9758: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829F975C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F9760: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F9764: 409A0008  bne cr6, 0x829f976c
	if !ctx.cr[6].eq {
	pc = 0x829F976C; continue 'dispatch;
	}
	pc = 0x829F9768; continue 'dispatch;
            }
            0x829F9768 => {
    //   block [0x829F9768..0x829F976C)
	// 829F9768: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x829F976C; continue 'dispatch;
            }
            0x829F976C => {
    //   block [0x829F976C..0x829F97B4)
	// 829F976C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F9770: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F9774: 419A0100  beq cr6, 0x829f9874
	if ctx.cr[6].eq {
	pc = 0x829F9874; continue 'dispatch;
	}
	// 829F9778: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829F977C: 4B77ACED  bl 0x82174468
	ctx.lr = 0x829F9780;
	sub_82174468(ctx, base);
	// 829F9780: 89630024  lbz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 829F9784: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 829F9788: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F978C: 419A00D8  beq cr6, 0x829f9864
	if ctx.cr[6].eq {
	pc = 0x829F9864; continue 'dispatch;
	}
	// 829F9790: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F9794: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F9798: 419A001C  beq cr6, 0x829f97b4
	if ctx.cr[6].eq {
	pc = 0x829F97B4; continue 'dispatch;
	}
	// 829F979C: 894B0018  lbz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 829F97A0: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F97A4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 829F97A8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829F97AC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F97B0: 480000B0  b 0x829f9860
	pc = 0x829F9860; continue 'dispatch;
            }
            0x829F97B4 => {
    //   block [0x829F97B4..0x829F97D0)
	// 829F97B4: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 829F97B8: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 829F97BC: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 829F97C0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829F97C4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 829F97C8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F97CC: 40810054  ble 0x829f9820
	if !ctx.cr[0].gt {
	pc = 0x829F9820; continue 'dispatch;
	}
	pc = 0x829F97D0; continue 'dispatch;
            }
            0x829F97D0 => {
    //   block [0x829F97D0..0x829F97F0)
	// 829F97D0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829F97D4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829F97D8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829F97DC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F97E0: 2F070018  cmpwi cr6, r7, 0x18
	ctx.cr[6].compare_i32(ctx.r[7].s32, 24, &mut ctx.xer);
	// 829F97E4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829F97E8: 41980008  blt cr6, 0x829f97f0
	if ctx.cr[6].lt {
	pc = 0x829F97F0; continue 'dispatch;
	}
	// 829F97EC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x829F97F0; continue 'dispatch;
            }
            0x829F97F0 => {
    //   block [0x829F97F0..0x829F980C)
	// 829F97F0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829F97F4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829F97F8: 419A0014  beq cr6, 0x829f980c
	if ctx.cr[6].eq {
	pc = 0x829F980C; continue 'dispatch;
	}
	// 829F97FC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829F9800: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F9804: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829F9808: 4800000C  b 0x829f9814
	pc = 0x829F9814; continue 'dispatch;
            }
            0x829F980C => {
    //   block [0x829F980C..0x829F9814)
	// 829F980C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829F9810: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829F9814; continue 'dispatch;
            }
            0x829F9814 => {
    //   block [0x829F9814..0x829F9820)
	// 829F9814: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F9818: 4199FFB8  bgt cr6, 0x829f97d0
	if ctx.cr[6].gt {
	pc = 0x829F97D0; continue 'dispatch;
	}
	// 829F981C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x829F9820; continue 'dispatch;
            }
            0x829F9820 => {
    //   block [0x829F9820..0x829F983C)
	// 829F9820: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829F9824: 419A0034  beq cr6, 0x829f9858
	if ctx.cr[6].eq {
	pc = 0x829F9858; continue 'dispatch;
	}
	// 829F9828: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F982C: 2F0B0018  cmpwi cr6, r11, 0x18
	ctx.cr[6].compare_i32(ctx.r[11].s32, 24, &mut ctx.xer);
	// 829F9830: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F9834: 41990008  bgt cr6, 0x829f983c
	if ctx.cr[6].gt {
	pc = 0x829F983C; continue 'dispatch;
	}
	// 829F9838: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x829F983C; continue 'dispatch;
            }
            0x829F983C => {
    //   block [0x829F983C..0x829F9858)
	// 829F983C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F9840: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F9844: 409A0014  bne cr6, 0x829f9858
	if !ctx.cr[6].eq {
	pc = 0x829F9858; continue 'dispatch;
	}
	// 829F9848: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829F984C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 829F9850: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829F9854: 48000008  b 0x829f985c
	pc = 0x829F985C; continue 'dispatch;
            }
            0x829F9858 => {
    //   block [0x829F9858..0x829F985C)
	// 829F9858: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x829F985C; continue 'dispatch;
            }
            0x829F985C => {
    //   block [0x829F985C..0x829F9860)
	// 829F985C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x829F9860; continue 'dispatch;
            }
            0x829F9860 => {
    //   block [0x829F9860..0x829F9864)
	// 829F9860: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	pc = 0x829F9864; continue 'dispatch;
            }
            0x829F9864 => {
    //   block [0x829F9864..0x829F9874)
	// 829F9864: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 829F9868: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829F986C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F9870: 4BB01D69  bl 0x824fb5d8
	ctx.lr = 0x829F9874;
	sub_824FB5D8(ctx, base);
	pc = 0x829F9874; continue 'dispatch;
            }
            0x829F9874 => {
    //   block [0x829F9874..0x829F9878)
	// 829F9874: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	pc = 0x829F9878; continue 'dispatch;
            }
            0x829F9878 => {
    //   block [0x829F9878..0x829F9884)
	// 829F9878: 4B81B561  bl 0x82214dd8
	ctx.lr = 0x829F987C;
	sub_82214DD8(ctx, base);
	// 829F987C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829F9880: 482AFBD4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F9888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829F9888 size=304
    let mut pc: u32 = 0x829F9888;
    'dispatch: loop {
        match pc {
            0x829F9888 => {
    //   block [0x829F9888..0x829F99B8)
	// 829F9888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F988C: 482AFB81  bl 0x82ca940c
	ctx.lr = 0x829F9890;
	sub_82CA93D0(ctx, base);
	// 829F9890: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F99B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F99B8 size=1284
    let mut pc: u32 = 0x829F99B8;
    'dispatch: loop {
        match pc {
            0x829F99B8 => {
    //   block [0x829F99B8..0x829F9A10)
	// 829F99B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F99BC: 482AFA31  bl 0x82ca93ec
	ctx.lr = 0x829F99C0;
	sub_82CA93D0(ctx, base);
	// 829F99C0: DBE1FF98  stfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 829F99C4: 9421FD40  stwu r1, -0x2c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-704 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F99C8: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 829F99CC: 4B7E9D6D  bl 0x821e3738
	ctx.lr = 0x829F99D0;
	sub_821E3738(ctx, base);
	// 829F99D0: 81760008  lwz r11, 8(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F99D4: 38760004  addi r3, r22, 4
	ctx.r[3].s64 = ctx.r[22].s64 + 4;
	// 829F99D8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829F99DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F99E0: 419A015C  beq cr6, 0x829f9b3c
	if ctx.cr[6].eq {
	pc = 0x829F9B3C; continue 'dispatch;
	}
	// 829F99E4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F99E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F99EC: 419A014C  beq cr6, 0x829f9b38
	if ctx.cr[6].eq {
	pc = 0x829F9B38; continue 'dispatch;
	}
	// 829F99F0: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 829F99F4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 829F99F8: 419A0018  beq cr6, 0x829f9a10
	if ctx.cr[6].eq {
	pc = 0x829F9A10; continue 'dispatch;
	}
	// 829F99FC: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 829F9A00: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829F9A04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829F9A08: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F9A0C: 409A0008  bne cr6, 0x829f9a14
	if !ctx.cr[6].eq {
	pc = 0x829F9A14; continue 'dispatch;
	}
	pc = 0x829F9A10; continue 'dispatch;
            }
            0x829F9A10 => {
    //   block [0x829F9A10..0x829F9A14)
	// 829F9A10: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x829F9A14; continue 'dispatch;
            }
            0x829F9A14 => {
    //   block [0x829F9A14..0x829F9A40)
	// 829F9A14: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F9A18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F9A1C: 419A0494  beq cr6, 0x829f9eb0
	if ctx.cr[6].eq {
	pc = 0x829F9EB0; continue 'dispatch;
	}
	// 829F9A20: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 829F9A24: 38B60054  addi r5, r22, 0x54
	ctx.r[5].s64 = ctx.r[22].s64 + 84;
	// 829F9A28: 38610210  addi r3, r1, 0x210
	ctx.r[3].s64 = ctx.r[1].s64 + 528;
	// 829F9A2C: 4BEE79AD  bl 0x828e13d8
	ctx.lr = 0x829F9A30;
	sub_828E13D8(ctx, base);
	// 829F9A30: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829F9A34: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 829F9A38: 3BAB7088  addi r29, r11, 0x7088
	ctx.r[29].s64 = ctx.r[11].s64 + 28808;
	// 829F9A3C: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	pc = 0x829F9A40; continue 'dispatch;
            }
            0x829F9A40 => {
    //   block [0x829F9A40..0x829F9A94)
	// 829F9A40: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829F9A44: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F9A48: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829F9A4C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F9A50: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F9A54: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F9A58: 4082FFE8  bne 0x829f9a40
	if !ctx.cr[0].eq {
	pc = 0x829F9A40; continue 'dispatch;
	}
	// 829F9A5C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F9A60: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829F9A64: 3AAB0E58  addi r21, r11, 0xe58
	ctx.r[21].s64 = ctx.r[11].s64 + 3672;
	// 829F9A68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F9A6C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 829F9A70: 4B833461  bl 0x8222ced0
	ctx.lr = 0x829F9A74;
	sub_8222CED0(ctx, base);
	// 829F9A74: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 829F9A78: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829F9A7C: 38610210  addi r3, r1, 0x210
	ctx.r[3].s64 = ctx.r[1].s64 + 528;
	// 829F9A80: 4BEE7E89  bl 0x828e1908
	ctx.lr = 0x829F9A84;
	sub_828E1908(ctx, base);
	// 829F9A84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F9A88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F9A8C: 4B7CCCDD  bl 0x821c6768
	ctx.lr = 0x829F9A90;
	sub_821C6768(ctx, base);
	// 829F9A90: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	pc = 0x829F9A94; continue 'dispatch;
            }
            0x829F9A94 => {
    //   block [0x829F9A94..0x829F9B0C)
	// 829F9A94: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 829F9A98: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F9A9C: 7CE02828  lwarx r7, 0, r5
	// lwarx
	let ea = ctx.r[5].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 829F9AA0: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 829F9AA4: 7CE0292D  stwcx. r7, 0, r5
	// stwcx.
	let addr = ctx.r[5].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F9AA8: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F9AAC: 4082FFE8  bne 0x829f9a94
	if !ctx.cr[0].eq {
	pc = 0x829F9A94; continue 'dispatch;
	}
	// 829F9AB0: 57E4063E  clrlwi r4, r31, 0x18
	ctx.r[4].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 829F9AB4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 829F9AB8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 829F9ABC: 419A03E4  beq cr6, 0x829f9ea0
	if ctx.cr[6].eq {
	pc = 0x829F9EA0; continue 'dispatch;
	}
	// 829F9AC0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F9AC4: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 829F9AC8: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 829F9ACC: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 829F9AD0: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 829F9AD4: C3EB9490  lfs f31, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829F9AD8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 829F9ADC: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829F9AE0: 3B889160  addi r28, r8, -0x6ea0
	ctx.r[28].s64 = ctx.r[8].s64 + -28320;
	// 829F9AE4: 3B670CA0  addi r27, r7, 0xca0
	ctx.r[27].s64 = ctx.r[7].s64 + 3232;
	// 829F9AE8: 3B06B784  addi r24, r6, -0x487c
	ctx.r[24].s64 = ctx.r[6].s64 + -18556;
	// 829F9AEC: 3B491BE8  addi r26, r9, 0x1be8
	ctx.r[26].s64 = ctx.r[9].s64 + 7144;
	// 829F9AF0: 3AEAB780  addi r23, r10, -0x4880
	ctx.r[23].s64 = ctx.r[10].s64 + -18560;
	// 829F9AF4: 3B2B1BD4  addi r25, r11, 0x1bd4
	ctx.r[25].s64 = ctx.r[11].s64 + 7124;
	// 829F9AF8: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F9AFC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F9B00: 409A0044  bne cr6, 0x829f9b44
	if !ctx.cr[6].eq {
	pc = 0x829F9B44; continue 'dispatch;
	}
	// 829F9B04: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 829F9B08: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x829F9B0C; continue 'dispatch;
            }
            0x829F9B0C => {
    //   block [0x829F9B0C..0x829F9B30)
	// 829F9B0C: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9B10: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9B14: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829F9B18: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 829F9B1C: 419A0014  beq cr6, 0x829f9b30
	if ctx.cr[6].eq {
	pc = 0x829F9B30; continue 'dispatch;
	}
	// 829F9B20: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829F9B24: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F9B28: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829F9B2C: 419AFFE0  beq cr6, 0x829f9b0c
	if ctx.cr[6].eq {
	pc = 0x829F9B0C; continue 'dispatch;
	}
	pc = 0x829F9B30; continue 'dispatch;
            }
            0x829F9B30 => {
    //   block [0x829F9B30..0x829F9B38)
	// 829F9B30: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 829F9B34: 48000020  b 0x829f9b54
	pc = 0x829F9B54; continue 'dispatch;
            }
            0x829F9B38 => {
    //   block [0x829F9B38..0x829F9B3C)
	// 829F9B38: 4B79A301  bl 0x82193e38
	ctx.lr = 0x829F9B3C;
	sub_82193E38(ctx, base);
	pc = 0x829F9B3C; continue 'dispatch;
            }
            0x829F9B3C => {
    //   block [0x829F9B3C..0x829F9B44)
	// 829F9B3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F9B40: 4BFFFED0  b 0x829f9a10
	pc = 0x829F9A10; continue 'dispatch;
            }
            0x829F9B44 => {
    //   block [0x829F9B44..0x829F9B54)
	// 829F9B44: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 829F9B48: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9B4C: 4B873CAD  bl 0x8226d7f8
	ctx.lr = 0x829F9B50;
	sub_8226D7F8(ctx, base);
	// 829F9B50: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	pc = 0x829F9B54; continue 'dispatch;
            }
            0x829F9B54 => {
    //   block [0x829F9B54..0x829F9B6C)
	// 829F9B54: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 829F9B58: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F9B5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F9B60: 419A0148  beq cr6, 0x829f9ca8
	if ctx.cr[6].eq {
	pc = 0x829F9CA8; continue 'dispatch;
	}
	// 829F9B64: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 829F9B68: 93C100F0  stw r30, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[30].u32 ) };
	pc = 0x829F9B6C; continue 'dispatch;
            }
            0x829F9B6C => {
    //   block [0x829F9B6C..0x829F9CA8)
	// 829F9B6C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 829F9B70: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F9B74: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 829F9B78: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829F9B7C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F9B80: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F9B84: 4082FFE8  bne 0x829f9b6c
	if !ctx.cr[0].eq {
	pc = 0x829F9B6C; continue 'dispatch;
	}
	// 829F9B88: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 829F9B8C: D3E10058  stfs f31, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829F9B90: 11A0038C  vspltisw v13, 0
	for i in 0..4 {
		ctx.v[13].u32[i] = 0;
	}
	// 829F9B94: 38E10110  addi r7, r1, 0x110
	ctx.r[7].s64 = ctx.r[1].s64 + 272;
	pc = 0x829F9CA8; continue 'dispatch;
            }
            0x829F9CA8 => {
    //   block [0x829F9CA8..0x829F9EA0)
	// 829F9CA8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F9CAC: 409A0038  bne cr6, 0x829f9ce4
	if !ctx.cr[6].eq {
	pc = 0x829F9CE4; continue 'dispatch;
	}
	// 829F9CB0: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 829F9CB4: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 829F9CB8: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9CBC: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9CC0: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829F9CC4: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 829F9CC8: 419A0014  beq cr6, 0x829f9cdc
	if ctx.cr[6].eq {
	pc = 0x829F9CDC; continue 'dispatch;
	}
	// 829F9CCC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829F9CD0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F9CD4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829F9CD8: 419AFFE0  beq cr6, 0x829f9cb8
	if ctx.cr[6].eq {
	pc = 0x829F9CB8; continue 'dispatch;
	}
	// 829F9CDC: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 829F9CE0: 48000014  b 0x829f9cf4
	pc = 0x829F9CF4; continue 'dispatch;
	// 829F9CE4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 829F9CE8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9CEC: 4B873B0D  bl 0x8226d7f8
	ctx.lr = 0x829F9CF0;
	sub_8226D7F8(ctx, base);
	// 829F9CF0: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 829F9CF4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 829F9CF8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829F9CFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F9D00: 419A0144  beq cr6, 0x829f9e44
	if ctx.cr[6].eq {
	pc = 0x829F9E44; continue 'dispatch;
	}
	// 829F9D04: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 829F9D08: 93C100B0  stw r30, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[30].u32 ) };
	// 829F9D0C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 829F9D10: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F9D14: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 829F9D18: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829F9D1C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F9D20: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F9D24: 4082FFE8  bne 0x829f9d0c
	if !ctx.cr[0].eq {
	pc = 0x829F9D0C; continue 'dispatch;
	}
	// 829F9D28: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 829F9D2C: D3E10058  stfs f31, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829F9D30: 11A0038C  vspltisw v13, 0
	for i in 0..4 {
		ctx.v[13].u32[i] = 0;
	}
	// 829F9D34: 38E100D0  addi r7, r1, 0xd0
	ctx.r[7].s64 = ctx.r[1].s64 + 208;
            }
            0x829F9EA0 => {
    //   block [0x829F9EA0..0x829F9EB0)
	// 829F9EA0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829F9EA4: 4B81AF35  bl 0x82214dd8
	ctx.lr = 0x829F9EA8;
	sub_82214DD8(ctx, base);
	// 829F9EA8: 38610210  addi r3, r1, 0x210
	ctx.r[3].s64 = ctx.r[1].s64 + 528;
	// 829F9EAC: 4BBAA965  bl 0x825a4810
	ctx.lr = 0x829F9EB0;
	sub_825A4810(ctx, base);
	pc = 0x829F9EB0; continue 'dispatch;
            }
            0x829F9EB0 => {
    //   block [0x829F9EB0..0x829F9EBC)
	// 829F9EB0: 382102C0  addi r1, r1, 0x2c0
	ctx.r[1].s64 = ctx.r[1].s64 + 704;
	// 829F9EB4: CBE1FF98  lfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 829F9EB8: 482AF584  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F9EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F9EC0 size=180
    let mut pc: u32 = 0x829F9EC0;
    'dispatch: loop {
        match pc {
            0x829F9EC0 => {
    //   block [0x829F9EC0..0x829F9F4C)
	// 829F9EC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F9EC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F9EC8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F9ECC: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 829F9ED0: 3943000C  addi r10, r3, 0xc
	ctx.r[10].s64 = ctx.r[3].s64 + 12;
	// 829F9ED4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F9ED8: 419A0074  beq cr6, 0x829f9f4c
	if ctx.cr[6].eq {
	pc = 0x829F9F4C; continue 'dispatch;
	}
	// 829F9EDC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9EE0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829F9EE4: 419A0078  beq cr6, 0x829f9f5c
	if ctx.cr[6].eq {
	pc = 0x829F9F5C; continue 'dispatch;
	}
	// 829F9EE8: 552B003E  slwi r11, r9, 0
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F9EEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F9EF0: 419A005C  beq cr6, 0x829f9f4c
	if ctx.cr[6].eq {
	pc = 0x829F9F4C; continue 'dispatch;
	}
	// 829F9EF4: 4B8A4F85  bl 0x8229ee78
	ctx.lr = 0x829F9EF8;
	sub_8229EE78(ctx, base);
	// 829F9EF8: 8063007C  lwz r3, 0x7c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(124 as u32) ) } as u64;
	// 829F9EFC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9F00: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 829F9F04: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829F9F08: 4E800421  bctrl
	ctx.lr = 0x829F9F0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829F9F0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F9F10: 419A003C  beq cr6, 0x829f9f4c
	if ctx.cr[6].eq {
	pc = 0x829F9F4C; continue 'dispatch;
	}
	// 829F9F14: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829F9F18: 4B98BCF1  bl 0x82385c08
	ctx.lr = 0x829F9F1C;
	sub_82385C08(ctx, base);
	// 829F9F1C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829F9F20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F9F24: 419A0028  beq cr6, 0x829f9f4c
	if ctx.cr[6].eq {
	pc = 0x829F9F4C; continue 'dispatch;
	}
	// 829F9F28: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829F9F2C: 806B0038  lwz r3, 0x38(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 829F9F30: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 829F9F34: 419A0018  beq cr6, 0x829f9f4c
	if ctx.cr[6].eq {
	pc = 0x829F9F4C; continue 'dispatch;
	}
	// 829F9F38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F9F3C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829F9F40: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 829F9F44: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829F9F48: 4E800421  bctrl
	ctx.lr = 0x829F9F4C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x829F9F4C => {
    //   block [0x829F9F4C..0x829F9F5C)
	// 829F9F4C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829F9F50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F9F54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F9F58: 4E800020  blr
	return;
            }
            0x829F9F5C => {
    //   block [0x829F9F5C..0x829F9F74)
	// 829F9F5C: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 829F9F60: 4B799ED9  bl 0x82193e38
	ctx.lr = 0x829F9F64;
	sub_82193E38(ctx, base);
	// 829F9F64: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829F9F68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F9F6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F9F70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F9F78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829F9F78 size=2968
    let mut pc: u32 = 0x829F9F78;
    'dispatch: loop {
        match pc {
            0x829F9F78 => {
    //   block [0x829F9F78..0x829FAB10)
	// 829F9F78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F9F7C: 482AF475  bl 0x82ca93f0
	ctx.lr = 0x829F9F80;
	sub_82CA93D0(ctx, base);
	// 829F9F80: DBE1FFA0  stfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 829F9F84: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FAB10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829FAB10 size=332
    let mut pc: u32 = 0x829FAB10;
    'dispatch: loop {
        match pc {
            0x829FAB10 => {
    //   block [0x829FAB10..0x829FAC5C)
	// 829FAB10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FAB14: 482AE8F9  bl 0x82ca940c
	ctx.lr = 0x829FAB18;
	sub_82CA93D0(ctx, base);
	// 829FAB18: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FAC60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FAC60 size=164
    let mut pc: u32 = 0x829FAC60;
    'dispatch: loop {
        match pc {
            0x829FAC60 => {
    //   block [0x829FAC60..0x829FAC88)
	// 829FAC60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FAC64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FAC68: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FAC6C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 829FAC70: 419A0018  beq cr6, 0x829fac88
	if ctx.cr[6].eq {
	pc = 0x829FAC88; continue 'dispatch;
	}
	// 829FAC74: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 829FAC78: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829FAC7C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829FAC80: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FAC84: 409A0008  bne cr6, 0x829fac8c
	if !ctx.cr[6].eq {
	pc = 0x829FAC8C; continue 'dispatch;
	}
	pc = 0x829FAC88; continue 'dispatch;
            }
            0x829FAC88 => {
    //   block [0x829FAC88..0x829FAC8C)
	// 829FAC88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x829FAC8C; continue 'dispatch;
            }
            0x829FAC8C => {
    //   block [0x829FAC8C..0x829FACF4)
	// 829FAC8C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829FAC90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FAC94: 419A0060  beq cr6, 0x829facf4
	if ctx.cr[6].eq {
	pc = 0x829FACF4; continue 'dispatch;
	}
	// 829FAC98: 8064007C  lwz r3, 0x7c(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(124 as u32) ) } as u64;
	// 829FAC9C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FACA0: 814B005C  lwz r10, 0x5c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 829FACA4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FACA8: 4E800421  bctrl
	ctx.lr = 0x829FACAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829FACAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FACB0: 419A0044  beq cr6, 0x829facf4
	if ctx.cr[6].eq {
	pc = 0x829FACF4; continue 'dispatch;
	}
	// 829FACB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FACB8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FACBC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829FACC0: 4B98AF49  bl 0x82385c08
	ctx.lr = 0x829FACC4;
	sub_82385C08(ctx, base);
	// 829FACC4: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829FACC8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FACCC: 419A0028  beq cr6, 0x829facf4
	if ctx.cr[6].eq {
	pc = 0x829FACF4; continue 'dispatch;
	}
	// 829FACD0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FACD4: 806B0038  lwz r3, 0x38(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 829FACD8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 829FACDC: 419A0018  beq cr6, 0x829facf4
	if ctx.cr[6].eq {
	pc = 0x829FACF4; continue 'dispatch;
	}
	// 829FACE0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FACE4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829FACE8: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 829FACEC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 829FACF0: 4E800421  bctrl
	ctx.lr = 0x829FACF4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x829FACF4 => {
    //   block [0x829FACF4..0x829FAD04)
	// 829FACF4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829FACF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FACFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FAD00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FAD08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FAD08 size=196
    let mut pc: u32 = 0x829FAD08;
    'dispatch: loop {
        match pc {
            0x829FAD08 => {
    //   block [0x829FAD08..0x829FAD5C)
	// 829FAD08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FAD0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FAD10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FAD14: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FAD18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FAD1C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 829FAD20: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 829FAD24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FAD28: 419A0034  beq cr6, 0x829fad5c
	if ctx.cr[6].eq {
	pc = 0x829FAD5C; continue 'dispatch;
	}
	// 829FAD2C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FAD30: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FAD34: 419A0078  beq cr6, 0x829fadac
	if ctx.cr[6].eq {
	pc = 0x829FADAC; continue 'dispatch;
	}
	// 829FAD38: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FAD3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FAD40: 419A001C  beq cr6, 0x829fad5c
	if ctx.cr[6].eq {
	pc = 0x829FAD5C; continue 'dispatch;
	}
	// 829FAD44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FAD48: 4B8A4131  bl 0x8229ee78
	ctx.lr = 0x829FAD4C;
	sub_8229EE78(ctx, base);
	// 829FAD4C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829FAD50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FAD54: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829FAD58: 4BFFFF09  bl 0x829fac60
	ctx.lr = 0x829FAD5C;
	sub_829FAC60(ctx, base);
	pc = 0x829FAD5C; continue 'dispatch;
            }
            0x829FAD5C => {
    //   block [0x829FAD5C..0x829FAD98)
	// 829FAD5C: 817F00D4  lwz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 829FAD60: 387F00D0  addi r3, r31, 0xd0
	ctx.r[3].s64 = ctx.r[31].s64 + 208;
	// 829FAD64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FAD68: 419A0030  beq cr6, 0x829fad98
	if ctx.cr[6].eq {
	pc = 0x829FAD98; continue 'dispatch;
	}
	// 829FAD6C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FAD70: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FAD74: 419A0040  beq cr6, 0x829fadb4
	if ctx.cr[6].eq {
	pc = 0x829FADB4; continue 'dispatch;
	}
	// 829FAD78: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FAD7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FAD80: 419A0018  beq cr6, 0x829fad98
	if ctx.cr[6].eq {
	pc = 0x829FAD98; continue 'dispatch;
	}
	// 829FAD84: 4B7790B5  bl 0x82173e38
	ctx.lr = 0x829FAD88;
	sub_82173E38(ctx, base);
	// 829FAD88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829FAD8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FAD90: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829FAD94: 4BFFFECD  bl 0x829fac60
	ctx.lr = 0x829FAD98;
	sub_829FAC60(ctx, base);
	pc = 0x829FAD98; continue 'dispatch;
            }
            0x829FAD98 => {
    //   block [0x829FAD98..0x829FADAC)
	// 829FAD98: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829FAD9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FADA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FADA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FADA8: 4E800020  blr
	return;
            }
            0x829FADAC => {
    //   block [0x829FADAC..0x829FADB4)
	// 829FADAC: 4B79908D  bl 0x82193e38
	ctx.lr = 0x829FADB0;
	sub_82193E38(ctx, base);
	// 829FADB0: 4BFFFFAC  b 0x829fad5c
	pc = 0x829FAD5C; continue 'dispatch;
            }
            0x829FADB4 => {
    //   block [0x829FADB4..0x829FADCC)
	// 829FADB4: 4B799085  bl 0x82193e38
	ctx.lr = 0x829FADB8;
	sub_82193E38(ctx, base);
	// 829FADB8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829FADBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FADC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FADC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FADC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FADD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829FADD0 size=1224
    let mut pc: u32 = 0x829FADD0;
    'dispatch: loop {
        match pc {
            0x829FADD0 => {
    //   block [0x829FADD0..0x829FB298)
	// 829FADD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FADD4: 482AE62D  bl 0x82ca9400
	ctx.lr = 0x829FADD8;
	sub_82CA93D0(ctx, base);
	// 829FADD8: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 829FADDC: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FB298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829FB298 size=252
    let mut pc: u32 = 0x829FB298;
    'dispatch: loop {
        match pc {
            0x829FB298 => {
    //   block [0x829FB298..0x829FB394)
	// 829FB298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FB29C: 482AE171  bl 0x82ca940c
	ctx.lr = 0x829FB2A0;
	sub_82CA93D0(ctx, base);
	// 829FB2A0: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FB398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FB398 size=1468
    let mut pc: u32 = 0x829FB398;
    'dispatch: loop {
        match pc {
            0x829FB398 => {
    //   block [0x829FB398..0x829FB454)
	// 829FB398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FB39C: 482AE051  bl 0x82ca93ec
	ctx.lr = 0x829FB3A0;
	sub_82CA93D0(ctx, base);
	// 829FB3A0: DBE1FF98  stfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 829FB3A4: 9421FD30  stwu r1, -0x2d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-720 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FB3A8: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 829FB3AC: 4B7E838D  bl 0x821e3738
	ctx.lr = 0x829FB3B0;
	sub_821E3738(ctx, base);
	// 829FB3B0: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 829FB3B4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 829FB3B8: 4B7DFCA9  bl 0x821db060
	ctx.lr = 0x829FB3BC;
	sub_821DB060(ctx, base);
	// 829FB3BC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FB3C0: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829FB3C4: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 829FB3C8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829FB3CC: 3BEB9490  addi r31, r11, -0x6b70
	ctx.r[31].s64 = ctx.r[11].s64 + -27504;
	// 829FB3D0: C3EB9490  lfs f31, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829FB3D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FB3D8: 409A009C  bne cr6, 0x829fb474
	if !ctx.cr[6].eq {
	pc = 0x829FB474; continue 'dispatch;
	}
	// 829FB3DC: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 829FB3E0: 4B823E79  bl 0x8221f258
	ctx.lr = 0x829FB3E4;
	sub_8221F258(ctx, base);
	// 829FB3E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FB3E8: 419A006C  beq cr6, 0x829fb454
	if ctx.cr[6].eq {
	pc = 0x829FB454; continue 'dispatch;
	}
	// 829FB3EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829FB3F0: C01FFFF4  lfs f0, -0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829FB3F4: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829FB3F8: 92C30004  stw r22, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[22].u32 ) };
	// 829FB3FC: 394B1DEC  addi r10, r11, 0x1dec
	ctx.r[10].s64 = ctx.r[11].s64 + 7660;
	// 829FB400: D3E30024  stfs f31, 0x24(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 829FB404: D3E30028  stfs f31, 0x28(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 829FB408: 9BC3000C  stb r30, 0xc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[30].u8 ) };
	// 829FB40C: D003002C  stfs f0, 0x2c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 829FB410: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829FB414: D0030030  stfs f0, 0x30(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 829FB418: 9BA3000D  stb r29, 0xd(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(13 as u32), ctx.r[29].u8 ) };
	// 829FB41C: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 829FB420: 9BA3000E  stb r29, 0xe(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(14 as u32), ctx.r[29].u8 ) };
	// 829FB424: D0030038  stfs f0, 0x38(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 829FB428: 9BA30020  stb r29, 0x20(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 829FB42C: D003003C  stfs f0, 0x3c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 829FB430: 9BA30040  stb r29, 0x40(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[29].u8 ) };
	// 829FB434: 9BA30041  stb r29, 0x41(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(65 as u32), ctx.r[29].u8 ) };
	// 829FB438: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829FB43C: 9BA30042  stb r29, 0x42(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(66 as u32), ctx.r[29].u8 ) };
	// 829FB440: 9BA30043  stb r29, 0x43(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(67 as u32), ctx.r[29].u8 ) };
	// 829FB444: 93A30048  stw r29, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[29].u32 ) };
	// 829FB448: 93A3004C  stw r29, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[29].u32 ) };
	// 829FB44C: 9BC30054  stb r30, 0x54(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[30].u8 ) };
	// 829FB450: 48000008  b 0x829fb458
	pc = 0x829FB458; continue 'dispatch;
            }
            0x829FB454 => {
    //   block [0x829FB454..0x829FB458)
	// 829FB454: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	pc = 0x829FB458; continue 'dispatch;
            }
            0x829FB458 => {
    //   block [0x829FB458..0x829FB474)
	// 829FB458: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 829FB45C: 4B7C0655  bl 0x821bbab0
	ctx.lr = 0x829FB460;
	sub_821BBAB0(ctx, base);
	// 829FB460: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829FB464: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 829FB468: 4B870A01  bl 0x8226be68
	ctx.lr = 0x829FB46C;
	sub_8226BE68(ctx, base);
	// 829FB46C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 829FB470: 4B7BC6A9  bl 0x821b7b18
	ctx.lr = 0x829FB474;
	sub_821B7B18(ctx, base);
	pc = 0x829FB474; continue 'dispatch;
            }
            0x829FB474 => {
    //   block [0x829FB474..0x829FB4B0)
	// 829FB474: 81760008  lwz r11, 8(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FB478: 38760004  addi r3, r22, 4
	ctx.r[3].s64 = ctx.r[22].s64 + 4;
	// 829FB47C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FB480: 419A0154  beq cr6, 0x829fb5d4
	if ctx.cr[6].eq {
	pc = 0x829FB5D4; continue 'dispatch;
	}
	// 829FB484: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FB488: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FB48C: 419A0144  beq cr6, 0x829fb5d0
	if ctx.cr[6].eq {
	pc = 0x829FB5D0; continue 'dispatch;
	}
	// 829FB490: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 829FB494: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 829FB498: 419A0018  beq cr6, 0x829fb4b0
	if ctx.cr[6].eq {
	pc = 0x829FB4B0; continue 'dispatch;
	}
	// 829FB49C: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 829FB4A0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829FB4A4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 829FB4A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FB4AC: 409A0008  bne cr6, 0x829fb4b4
	if !ctx.cr[6].eq {
	pc = 0x829FB4B4; continue 'dispatch;
	}
	pc = 0x829FB4B0; continue 'dispatch;
            }
            0x829FB4B0 => {
    //   block [0x829FB4B0..0x829FB4B4)
	// 829FB4B0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829FB4B4; continue 'dispatch;
            }
            0x829FB4B4 => {
    //   block [0x829FB4B4..0x829FB4E0)
	// 829FB4B4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829FB4B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FB4BC: 419A048C  beq cr6, 0x829fb948
	if ctx.cr[6].eq {
	pc = 0x829FB948; continue 'dispatch;
	}
	// 829FB4C0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 829FB4C4: 38B60054  addi r5, r22, 0x54
	ctx.r[5].s64 = ctx.r[22].s64 + 84;
	// 829FB4C8: 38610220  addi r3, r1, 0x220
	ctx.r[3].s64 = ctx.r[1].s64 + 544;
	// 829FB4CC: 4BEE5F0D  bl 0x828e13d8
	ctx.lr = 0x829FB4D0;
	sub_828E13D8(ctx, base);
	// 829FB4D0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829FB4D4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829FB4D8: 3BCB7088  addi r30, r11, 0x7088
	ctx.r[30].s64 = ctx.r[11].s64 + 28808;
	// 829FB4DC: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	pc = 0x829FB4E0; continue 'dispatch;
            }
            0x829FB4E0 => {
    //   block [0x829FB4E0..0x829FB534)
	// 829FB4E0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829FB4E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FB4E8: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829FB4EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829FB4F0: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829FB4F4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FB4F8: 4082FFE8  bne 0x829fb4e0
	if !ctx.cr[0].eq {
	pc = 0x829FB4E0; continue 'dispatch;
	}
	// 829FB4FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829FB500: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 829FB504: 3AAB0E58  addi r21, r11, 0xe58
	ctx.r[21].s64 = ctx.r[11].s64 + 3672;
	// 829FB508: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FB50C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 829FB510: 4B8319C1  bl 0x8222ced0
	ctx.lr = 0x829FB514;
	sub_8222CED0(ctx, base);
	// 829FB514: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 829FB518: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FB51C: 38610220  addi r3, r1, 0x220
	ctx.r[3].s64 = ctx.r[1].s64 + 544;
	// 829FB520: 4BEE63E9  bl 0x828e1908
	ctx.lr = 0x829FB524;
	sub_828E1908(ctx, base);
	// 829FB524: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FB528: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FB52C: 4B7CB23D  bl 0x821c6768
	ctx.lr = 0x829FB530;
	sub_821C6768(ctx, base);
	// 829FB530: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	pc = 0x829FB534; continue 'dispatch;
            }
            0x829FB534 => {
    //   block [0x829FB534..0x829FB5A4)
	// 829FB534: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 829FB538: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FB53C: 7CE02828  lwarx r7, 0, r5
	// lwarx
	let ea = ctx.r[5].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 829FB540: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 829FB544: 7CE0292D  stwcx. r7, 0, r5
	// stwcx.
	let addr = ctx.r[5].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829FB548: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FB54C: 4082FFE8  bne 0x829fb534
	if !ctx.cr[0].eq {
	pc = 0x829FB534; continue 'dispatch;
	}
	// 829FB550: 57E4063E  clrlwi r4, r31, 0x18
	ctx.r[4].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 829FB554: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 829FB558: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 829FB55C: 419A03DC  beq cr6, 0x829fb938
	if ctx.cr[6].eq {
	pc = 0x829FB938; continue 'dispatch;
	}
	// 829FB560: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 829FB564: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 829FB568: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 829FB56C: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 829FB570: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 829FB574: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829FB578: 3B879160  addi r28, r7, -0x6ea0
	ctx.r[28].s64 = ctx.r[7].s64 + -28320;
	// 829FB57C: 3B660CA0  addi r27, r6, 0xca0
	ctx.r[27].s64 = ctx.r[6].s64 + 3232;
	// 829FB580: 3B08B784  addi r24, r8, -0x487c
	ctx.r[24].s64 = ctx.r[8].s64 + -18556;
	// 829FB584: 3B491BE8  addi r26, r9, 0x1be8
	ctx.r[26].s64 = ctx.r[9].s64 + 7144;
	// 829FB588: 3AEAB780  addi r23, r10, -0x4880
	ctx.r[23].s64 = ctx.r[10].s64 + -18560;
	// 829FB58C: 3B2B1BD4  addi r25, r11, 0x1bd4
	ctx.r[25].s64 = ctx.r[11].s64 + 7124;
	// 829FB590: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829FB594: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829FB598: 409A0044  bne cr6, 0x829fb5dc
	if !ctx.cr[6].eq {
	pc = 0x829FB5DC; continue 'dispatch;
	}
	// 829FB59C: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 829FB5A0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x829FB5A4; continue 'dispatch;
            }
            0x829FB5A4 => {
    //   block [0x829FB5A4..0x829FB5C8)
	// 829FB5A4: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FB5A8: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FB5AC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829FB5B0: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 829FB5B4: 419A0014  beq cr6, 0x829fb5c8
	if ctx.cr[6].eq {
	pc = 0x829FB5C8; continue 'dispatch;
	}
	// 829FB5B8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829FB5BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829FB5C0: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829FB5C4: 419AFFE0  beq cr6, 0x829fb5a4
	if ctx.cr[6].eq {
	pc = 0x829FB5A4; continue 'dispatch;
	}
	pc = 0x829FB5C8; continue 'dispatch;
            }
            0x829FB5C8 => {
    //   block [0x829FB5C8..0x829FB5D0)
	// 829FB5C8: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 829FB5CC: 48000020  b 0x829fb5ec
	pc = 0x829FB5EC; continue 'dispatch;
            }
            0x829FB5D0 => {
    //   block [0x829FB5D0..0x829FB5D4)
	// 829FB5D0: 4B798869  bl 0x82193e38
	ctx.lr = 0x829FB5D4;
	sub_82193E38(ctx, base);
	pc = 0x829FB5D4; continue 'dispatch;
            }
            0x829FB5D4 => {
    //   block [0x829FB5D4..0x829FB5DC)
	// 829FB5D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829FB5D8: 4BFFFED8  b 0x829fb4b0
	pc = 0x829FB4B0; continue 'dispatch;
            }
            0x829FB5DC => {
    //   block [0x829FB5DC..0x829FB5EC)
	// 829FB5DC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 829FB5E0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FB5E4: 4B872215  bl 0x8226d7f8
	ctx.lr = 0x829FB5E8;
	sub_8226D7F8(ctx, base);
	// 829FB5E8: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	pc = 0x829FB5EC; continue 'dispatch;
            }
            0x829FB5EC => {
    //   block [0x829FB5EC..0x829FB604)
	// 829FB5EC: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 829FB5F0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829FB5F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FB5F8: 419A0148  beq cr6, 0x829fb740
	if ctx.cr[6].eq {
	pc = 0x829FB740; continue 'dispatch;
	}
	// 829FB5FC: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 829FB600: 93A10100  stw r29, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[29].u32 ) };
	pc = 0x829FB604; continue 'dispatch;
            }
            0x829FB604 => {
    //   block [0x829FB604..0x829FB740)
	// 829FB604: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 829FB608: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FB60C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 829FB610: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829FB614: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829FB618: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FB61C: 4082FFE8  bne 0x829fb604
	if !ctx.cr[0].eq {
	pc = 0x829FB604; continue 'dispatch;
	}
	// 829FB620: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 829FB624: D3E10058  stfs f31, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829FB628: 11A0038C  vspltisw v13, 0
	for i in 0..4 {
		ctx.v[13].u32[i] = 0;
	}
	// 829FB62C: 38E10120  addi r7, r1, 0x120
	ctx.r[7].s64 = ctx.r[1].s64 + 288;
	pc = 0x829FB740; continue 'dispatch;
            }
            0x829FB740 => {
    //   block [0x829FB740..0x829FB938)
	// 829FB740: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829FB744: 409A0038  bne cr6, 0x829fb77c
	if !ctx.cr[6].eq {
	pc = 0x829FB77C; continue 'dispatch;
	}
	// 829FB748: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 829FB74C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 829FB750: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FB754: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FB758: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829FB75C: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 829FB760: 419A0014  beq cr6, 0x829fb774
	if ctx.cr[6].eq {
	pc = 0x829FB774; continue 'dispatch;
	}
	// 829FB764: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829FB768: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829FB76C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829FB770: 419AFFE0  beq cr6, 0x829fb750
	if ctx.cr[6].eq {
	pc = 0x829FB750; continue 'dispatch;
	}
	// 829FB774: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 829FB778: 48000014  b 0x829fb78c
	pc = 0x829FB78C; continue 'dispatch;
	// 829FB77C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 829FB780: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FB784: 4B872075  bl 0x8226d7f8
	ctx.lr = 0x829FB788;
	sub_8226D7F8(ctx, base);
	// 829FB788: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 829FB78C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 829FB790: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829FB794: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FB798: 419A0144  beq cr6, 0x829fb8dc
	if ctx.cr[6].eq {
	pc = 0x829FB8DC; continue 'dispatch;
	}
	// 829FB79C: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 829FB7A0: 93A100C0  stw r29, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[29].u32 ) };
	// 829FB7A4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 829FB7A8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FB7AC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 829FB7B0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829FB7B4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829FB7B8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FB7BC: 4082FFE8  bne 0x829fb7a4
	if !ctx.cr[0].eq {
	pc = 0x829FB7A4; continue 'dispatch;
	}
	// 829FB7C0: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 829FB7C4: D3E10058  stfs f31, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829FB7C8: 11A0038C  vspltisw v13, 0
	for i in 0..4 {
		ctx.v[13].u32[i] = 0;
	}
	// 829FB7CC: 38E100E0  addi r7, r1, 0xe0
	ctx.r[7].s64 = ctx.r[1].s64 + 224;
            }
            0x829FB938 => {
    //   block [0x829FB938..0x829FB948)
	// 829FB938: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829FB93C: 4B81949D  bl 0x82214dd8
	ctx.lr = 0x829FB940;
	sub_82214DD8(ctx, base);
	// 829FB940: 38610220  addi r3, r1, 0x220
	ctx.r[3].s64 = ctx.r[1].s64 + 544;
	// 829FB944: 4BBA8ECD  bl 0x825a4810
	ctx.lr = 0x829FB948;
	sub_825A4810(ctx, base);
	pc = 0x829FB948; continue 'dispatch;
            }
            0x829FB948 => {
    //   block [0x829FB948..0x829FB954)
	// 829FB948: 382102D0  addi r1, r1, 0x2d0
	ctx.r[1].s64 = ctx.r[1].s64 + 720;
	// 829FB94C: CBE1FF98  lfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 829FB950: 482ADAEC  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FB958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829FB958 size=2488
    let mut pc: u32 = 0x829FB958;
    'dispatch: loop {
        match pc {
            0x829FB958 => {
    //   block [0x829FB958..0x829FB99C)
	// 829FB958: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FB95C: 482ADA99  bl 0x82ca93f4
	ctx.lr = 0x829FB960;
	sub_82CA93D0(ctx, base);
	// 829FB960: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 829FB964: 9421FDF0  stwu r1, -0x210(r1)
	ea = ctx.r[1].u32.wrapping_add(-528 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FB968: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 829FB96C: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 829FB970: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 829FB974: 38780004  addi r3, r24, 4
	ctx.r[3].s64 = ctx.r[24].s64 + 4;
	// 829FB978: 7EFABB78  mr r26, r23
	ctx.r[26].u64 = ctx.r[23].u64;
	// 829FB97C: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FB980: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FB984: 419A001C  beq cr6, 0x829fb9a0
	if ctx.cr[6].eq {
	pc = 0x829FB9A0; continue 'dispatch;
	}
	// 829FB988: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FB98C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FB990: 419A000C  beq cr6, 0x829fb99c
	if ctx.cr[6].eq {
	pc = 0x829FB99C; continue 'dispatch;
	}
	// 829FB994: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829FB998: 4800000C  b 0x829fb9a4
	pc = 0x829FB9A4; continue 'dispatch;
            }
            0x829FB99C => {
    //   block [0x829FB99C..0x829FB9A0)
	// 829FB99C: 4B79849D  bl 0x82193e38
	ctx.lr = 0x829FB9A0;
	sub_82193E38(ctx, base);
	pc = 0x829FB9A0; continue 'dispatch;
            }
            0x829FB9A0 => {
    //   block [0x829FB9A0..0x829FB9A4)
	// 829FB9A0: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x829FB9A4; continue 'dispatch;
            }
            0x829FB9A4 => {
    //   block [0x829FB9A4..0x829FB9D8)
	// 829FB9A4: 894B0024  lbz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 829FB9A8: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 829FB9AC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829FB9B0: 419A00D8  beq cr6, 0x829fba88
	if ctx.cr[6].eq {
	pc = 0x829FBA88; continue 'dispatch;
	}
	// 829FB9B4: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 829FB9B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FB9BC: 419A001C  beq cr6, 0x829fb9d8
	if ctx.cr[6].eq {
	pc = 0x829FB9D8; continue 'dispatch;
	}
	// 829FB9C0: 894A0018  lbz r10, 0x18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 829FB9C4: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 829FB9C8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 829FB9CC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829FB9D0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FB9D4: 480000B0  b 0x829fba84
	pc = 0x829FBA84; continue 'dispatch;
            }
            0x829FB9D8 => {
    //   block [0x829FB9D8..0x829FB9F4)
	// 829FB9D8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 829FB9DC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 829FB9E0: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 829FB9E4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 829FB9E8: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 829FB9EC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829FB9F0: 40810054  ble 0x829fba44
	if !ctx.cr[0].gt {
	pc = 0x829FBA44; continue 'dispatch;
	}
	pc = 0x829FB9F4; continue 'dispatch;
            }
            0x829FB9F4 => {
    //   block [0x829FB9F4..0x829FBA14)
	// 829FB9F4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829FB9F8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829FB9FC: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 829FBA00: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FBA04: 2F070018  cmpwi cr6, r7, 0x18
	ctx.cr[6].compare_i32(ctx.r[7].s32, 24, &mut ctx.xer);
	// 829FBA08: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829FBA0C: 41980008  blt cr6, 0x829fba14
	if ctx.cr[6].lt {
	pc = 0x829FBA14; continue 'dispatch;
	}
	// 829FBA10: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	pc = 0x829FBA14; continue 'dispatch;
            }
            0x829FBA14 => {
    //   block [0x829FBA14..0x829FBA30)
	// 829FBA14: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829FBA18: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829FBA1C: 419A0014  beq cr6, 0x829fba30
	if ctx.cr[6].eq {
	pc = 0x829FBA30; continue 'dispatch;
	}
	// 829FBA20: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829FBA24: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829FBA28: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829FBA2C: 4800000C  b 0x829fba38
	pc = 0x829FBA38; continue 'dispatch;
            }
            0x829FBA30 => {
    //   block [0x829FBA30..0x829FBA38)
	// 829FBA30: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829FBA34: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829FBA38; continue 'dispatch;
            }
            0x829FBA38 => {
    //   block [0x829FBA38..0x829FBA44)
	// 829FBA38: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829FBA3C: 4199FFB8  bgt cr6, 0x829fb9f4
	if ctx.cr[6].gt {
	pc = 0x829FB9F4; continue 'dispatch;
	}
	// 829FBA40: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x829FBA44; continue 'dispatch;
            }
            0x829FBA44 => {
    //   block [0x829FBA44..0x829FBA60)
	// 829FBA44: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 829FBA48: 419A0034  beq cr6, 0x829fba7c
	if ctx.cr[6].eq {
	pc = 0x829FBA7C; continue 'dispatch;
	}
	// 829FBA4C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FBA50: 2F0B0018  cmpwi cr6, r11, 0x18
	ctx.cr[6].compare_i32(ctx.r[11].s32, 24, &mut ctx.xer);
	// 829FBA54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829FBA58: 41990008  bgt cr6, 0x829fba60
	if ctx.cr[6].gt {
	pc = 0x829FBA60; continue 'dispatch;
	}
	// 829FBA5C: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x829FBA60; continue 'dispatch;
            }
            0x829FBA60 => {
    //   block [0x829FBA60..0x829FBA7C)
	// 829FBA60: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829FBA64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FBA68: 409A0014  bne cr6, 0x829fba7c
	if !ctx.cr[6].eq {
	pc = 0x829FBA7C; continue 'dispatch;
	}
	// 829FBA6C: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 829FBA70: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 829FBA74: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829FBA78: 48000008  b 0x829fba80
	pc = 0x829FBA80; continue 'dispatch;
            }
            0x829FBA7C => {
    //   block [0x829FBA7C..0x829FBA80)
	// 829FBA7C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x829FBA80; continue 'dispatch;
            }
            0x829FBA80 => {
    //   block [0x829FBA80..0x829FBA84)
	// 829FBA80: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x829FBA84; continue 'dispatch;
            }
            0x829FBA84 => {
    //   block [0x829FBA84..0x829FBA88)
	// 829FBA84: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	pc = 0x829FBA88; continue 'dispatch;
            }
            0x829FBA88 => {
    //   block [0x829FBA88..0x829FBAC4)
	// 829FBA88: 81780010  lwz r11, 0x10(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 829FBA8C: 3878000C  addi r3, r24, 0xc
	ctx.r[3].s64 = ctx.r[24].s64 + 12;
	// 829FBA90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FBA94: 419A00B0  beq cr6, 0x829fbb44
	if ctx.cr[6].eq {
	pc = 0x829FBB44; continue 'dispatch;
	}
	// 829FBA98: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FBA9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FBAA0: 419A00A0  beq cr6, 0x829fbb40
	if ctx.cr[6].eq {
	pc = 0x829FBB40; continue 'dispatch;
	}
	// 829FBAA4: 555B003E  slwi r27, r10, 0
	ctx.r[27].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 829FBAA8: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 829FBAAC: 419A0018  beq cr6, 0x829fbac4
	if ctx.cr[6].eq {
	pc = 0x829FBAC4; continue 'dispatch;
	}
	// 829FBAB0: 897B0090  lbz r11, 0x90(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(144 as u32) ) } as u64;
	// 829FBAB4: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829FBAB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829FBABC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FBAC0: 409A0008  bne cr6, 0x829fbac8
	if !ctx.cr[6].eq {
	pc = 0x829FBAC8; continue 'dispatch;
	}
	pc = 0x829FBAC4; continue 'dispatch;
            }
            0x829FBAC4 => {
    //   block [0x829FBAC4..0x829FBAC8)
	// 829FBAC4: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x829FBAC8; continue 'dispatch;
            }
            0x829FBAC8 => {
    //   block [0x829FBAC8..0x829FBB04)
	// 829FBAC8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829FBACC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FBAD0: 419A0834  beq cr6, 0x829fc304
	if ctx.cr[6].eq {
	pc = 0x829FC304; continue 'dispatch;
	}
	// 829FBAD4: 817B0024  lwz r11, 0x24(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) } as u64;
	// 829FBAD8: 556AF7FE  rlwinm r10, r11, 0x1e, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 829FBADC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FBAE0: 419A007C  beq cr6, 0x829fbb5c
	if ctx.cr[6].eq {
	pc = 0x829FBB5C; continue 'dispatch;
	}
	// 829FBAE4: 817B008C  lwz r11, 0x8c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(140 as u32) ) } as u64;
	// 829FBAE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FBAEC: 409A0070  bne cr6, 0x829fbb5c
	if !ctx.cr[6].eq {
	pc = 0x829FBB5C; continue 'dispatch;
	}
	// 829FBAF0: 817B004C  lwz r11, 0x4c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(76 as u32) ) } as u64;
	// 829FBAF4: 815B0048  lwz r10, 0x48(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 829FBAF8: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 829FBAFC: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829FBB00: 4081005C  ble 0x829fbb5c
	if !ctx.cr[0].gt {
	pc = 0x829FBB5C; continue 'dispatch;
	}
	pc = 0x829FBB04; continue 'dispatch;
            }
            0x829FBB04 => {
    //   block [0x829FBB04..0x829FBB24)
	// 829FBB04: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 829FBB08: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 829FBB0C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 829FBB10: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FBB14: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 829FBB18: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829FBB1C: 41980008  blt cr6, 0x829fbb24
	if ctx.cr[6].lt {
	pc = 0x829FBB24; continue 'dispatch;
	}
	// 829FBB20: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	pc = 0x829FBB24; continue 'dispatch;
            }
            0x829FBB24 => {
    //   block [0x829FBB24..0x829FBB40)
	// 829FBB24: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 829FBB28: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 829FBB2C: 419A0020  beq cr6, 0x829fbb4c
	if ctx.cr[6].eq {
	pc = 0x829FBB4C; continue 'dispatch;
	}
	// 829FBB30: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 829FBB34: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829FBB38: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829FBB3C: 48000018  b 0x829fbb54
	pc = 0x829FBB54; continue 'dispatch;
            }
            0x829FBB40 => {
    //   block [0x829FBB40..0x829FBB44)
	// 829FBB40: 4B7982F9  bl 0x82193e38
	ctx.lr = 0x829FBB44;
	sub_82193E38(ctx, base);
	pc = 0x829FBB44; continue 'dispatch;
            }
            0x829FBB44 => {
    //   block [0x829FBB44..0x829FBB4C)
	// 829FBB44: 7EFBBB78  mr r27, r23
	ctx.r[27].u64 = ctx.r[23].u64;
	// 829FBB48: 4BFFFF7C  b 0x829fbac4
	pc = 0x829FBAC4; continue 'dispatch;
            }
            0x829FBB4C => {
    //   block [0x829FBB4C..0x829FBB54)
	// 829FBB4C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 829FBB50: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x829FBB54; continue 'dispatch;
            }
            0x829FBB54 => {
    //   block [0x829FBB54..0x829FBB5C)
	// 829FBB54: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829FBB58: 4199FFAC  bgt cr6, 0x829fbb04
	if ctx.cr[6].gt {
	pc = 0x829FBB04; continue 'dispatch;
	}
	pc = 0x829FBB5C; continue 'dispatch;
            }
            0x829FBB5C => {
    //   block [0x829FBB5C..0x829FBB7C)
	// 829FBB5C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829FBB60: 83F90000  lwz r31, 0(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FBB64: 3B8B0CA0  addi r28, r11, 0xca0
	ctx.r[28].s64 = ctx.r[11].s64 + 3232;
	// 829FBB68: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829FBB6C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829FBB70: 409A003C  bne cr6, 0x829fbbac
	if !ctx.cr[6].eq {
	pc = 0x829FBBAC; continue 'dispatch;
	}
	// 829FBB74: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 829FBB78: 396B1B84  addi r11, r11, 0x1b84
	ctx.r[11].s64 = ctx.r[11].s64 + 7044;
	pc = 0x829FBB7C; continue 'dispatch;
            }
            0x829FBB7C => {
    //   block [0x829FBB7C..0x829FBBA0)
	// 829FBB7C: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FBB80: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FBB84: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829FBB88: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 829FBB8C: 419A0014  beq cr6, 0x829fbba0
	if ctx.cr[6].eq {
	pc = 0x829FBBA0; continue 'dispatch;
	}
	// 829FBB90: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829FBB94: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829FBB98: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829FBB9C: 419AFFE0  beq cr6, 0x829fbb7c
	if ctx.cr[6].eq {
	pc = 0x829FBB7C; continue 'dispatch;
	}
	pc = 0x829FBBA0; continue 'dispatch;
            }
            0x829FBBA0 => {
    //   block [0x829FBBA0..0x829FBBAC)
	// 829FBBA0: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 829FBBA4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 829FBBA8: 48000018  b 0x829fbbc0
	pc = 0x829FBBC0; continue 'dispatch;
            }
            0x829FBBAC => {
    //   block [0x829FBBAC..0x829FBBC0)
	// 829FBBAC: 388B1B84  addi r4, r11, 0x1b84
	ctx.r[4].s64 = ctx.r[11].s64 + 7044;
	// 829FBBB0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FBBB4: 4B871C45  bl 0x8226d7f8
	ctx.lr = 0x829FBBB8;
	sub_8226D7F8(ctx, base);
	// 829FBBB8: 7C6A0034  cntlzw r10, r3
	ctx.r[10].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 829FBBBC: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	pc = 0x829FBBC0; continue 'dispatch;
            }
            0x829FBBC0 => {
    //   block [0x829FBBC0..0x829FBBEC)
	// 829FBBC0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829FBBC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FBBC8: 419A0024  beq cr6, 0x829fbbec
	if ctx.cr[6].eq {
	pc = 0x829FBBEC; continue 'dispatch;
	}
	// 829FBBCC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829FBBD0: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 829FBBD4: 388BB780  addi r4, r11, -0x4880
	ctx.r[4].s64 = ctx.r[11].s64 + -18560;
	// 829FBBD8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829FBBDC: 4BAFF9FD  bl 0x824fb5d8
	ctx.lr = 0x829FBBE0;
	sub_824FB5D8(ctx, base);
	// 829FBBE0: 38210210  addi r1, r1, 0x210
	ctx.r[1].s64 = ctx.r[1].s64 + 528;
	// 829FBBE4: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 829FBBE8: 482AD85C  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x829FBBEC => {
    //   block [0x829FBBEC..0x829FBC00)
	// 829FBBEC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829FBBF0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829FBBF4: 409A003C  bne cr6, 0x829fbc30
	if !ctx.cr[6].eq {
	pc = 0x829FBC30; continue 'dispatch;
	}
	// 829FBBF8: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 829FBBFC: 396B1B98  addi r11, r11, 0x1b98
	ctx.r[11].s64 = ctx.r[11].s64 + 7064;
	pc = 0x829FBC00; continue 'dispatch;
            }
            0x829FBC00 => {
    //   block [0x829FBC00..0x829FBC24)
	// 829FBC00: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FBC04: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FBC08: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829FBC0C: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 829FBC10: 419A0014  beq cr6, 0x829fbc24
	if ctx.cr[6].eq {
	pc = 0x829FBC24; continue 'dispatch;
	}
	// 829FBC14: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829FBC18: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829FBC1C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829FBC20: 419AFFE0  beq cr6, 0x829fbc00
	if ctx.cr[6].eq {
	pc = 0x829FBC00; continue 'dispatch;
	}
	pc = 0x829FBC24; continue 'dispatch;
            }
            0x829FBC24 => {
    //   block [0x829FBC24..0x829FBC30)
	// 829FBC24: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 829FBC28: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 829FBC2C: 48000018  b 0x829fbc44
	pc = 0x829FBC44; continue 'dispatch;
            }
            0x829FBC30 => {
    //   block [0x829FBC30..0x829FBC44)
	// 829FBC30: 388B1B98  addi r4, r11, 0x1b98
	ctx.r[4].s64 = ctx.r[11].s64 + 7064;
	// 829FBC34: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FBC38: 4B871BC1  bl 0x8226d7f8
	ctx.lr = 0x829FBC3C;
	sub_8226D7F8(ctx, base);
	// 829FBC3C: 7C6A0034  cntlzw r10, r3
	ctx.r[10].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 829FBC40: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	pc = 0x829FBC44; continue 'dispatch;
            }
            0x829FBC44 => {
    //   block [0x829FBC44..0x829FBC70)
	// 829FBC44: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829FBC48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FBC4C: 419A0024  beq cr6, 0x829fbc70
	if ctx.cr[6].eq {
	pc = 0x829FBC70; continue 'dispatch;
	}
	// 829FBC50: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829FBC54: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 829FBC58: 388BB784  addi r4, r11, -0x487c
	ctx.r[4].s64 = ctx.r[11].s64 + -18556;
	// 829FBC5C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829FBC60: 4BAFF979  bl 0x824fb5d8
	ctx.lr = 0x829FBC64;
	sub_824FB5D8(ctx, base);
	// 829FBC64: 38210210  addi r1, r1, 0x210
	ctx.r[1].s64 = ctx.r[1].s64 + 528;
	// 829FBC68: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 829FBC6C: 482AD7D8  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x829FBC70 => {
    //   block [0x829FBC70..0x829FBC88)
	// 829FBC70: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829FBC74: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829FBC78: 3BCB1BD4  addi r30, r11, 0x1bd4
	ctx.r[30].s64 = ctx.r[11].s64 + 7124;
	// 829FBC7C: 409A0038  bne cr6, 0x829fbcb4
	if !ctx.cr[6].eq {
	pc = 0x829FBCB4; continue 'dispatch;
	}
	// 829FBC80: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 829FBC84: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x829FBC88; continue 'dispatch;
            }
            0x829FBC88 => {
    //   block [0x829FBC88..0x829FBCAC)
	// 829FBC88: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FBC8C: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FBC90: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829FBC94: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 829FBC98: 419A0014  beq cr6, 0x829fbcac
	if ctx.cr[6].eq {
	pc = 0x829FBCAC; continue 'dispatch;
	}
	// 829FBC9C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829FBCA0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829FBCA4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829FBCA8: 419AFFE0  beq cr6, 0x829fbc88
	if ctx.cr[6].eq {
	pc = 0x829FBC88; continue 'dispatch;
	}
	pc = 0x829FBCAC; continue 'dispatch;
            }
            0x829FBCAC => {
    //   block [0x829FBCAC..0x829FBCB4)
	// 829FBCAC: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 829FBCB0: 48000014  b 0x829fbcc4
	pc = 0x829FBCC4; continue 'dispatch;
            }
            0x829FBCB4 => {
    //   block [0x829FBCB4..0x829FBCC4)
	// 829FBCB4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829FBCB8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FBCBC: 4B871B3D  bl 0x8226d7f8
	ctx.lr = 0x829FBCC0;
	sub_8226D7F8(ctx, base);
	// 829FBCC0: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	pc = 0x829FBCC4; continue 'dispatch;
            }
            0x829FBCC4 => {
    //   block [0x829FBCC4..0x829FBCEC)
	// 829FBCC4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 829FBCC8: 556A063E  clrlwi r10, r11, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829FBCCC: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 829FBCD0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FBCD4: 3BAB1BE8  addi r29, r11, 0x1be8
	ctx.r[29].s64 = ctx.r[11].s64 + 7144;
	// 829FBCD8: 409A0060  bne cr6, 0x829fbd38
	if !ctx.cr[6].eq {
	pc = 0x829FBD38; continue 'dispatch;
	}
	// 829FBCDC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829FBCE0: 409A0038  bne cr6, 0x829fbd18
	if !ctx.cr[6].eq {
	pc = 0x829FBD18; continue 'dispatch;
	}
	// 829FBCE4: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 829FBCE8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829FBCEC; continue 'dispatch;
            }
            0x829FBCEC => {
    //   block [0x829FBCEC..0x829FBD10)
	// 829FBCEC: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FBCF0: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FBCF4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829FBCF8: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 829FBCFC: 419A0014  beq cr6, 0x829fbd10
	if ctx.cr[6].eq {
	pc = 0x829FBD10; continue 'dispatch;
	}
	// 829FBD00: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829FBD04: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829FBD08: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829FBD0C: 419AFFE0  beq cr6, 0x829fbcec
	if ctx.cr[6].eq {
	pc = 0x829FBCEC; continue 'dispatch;
	}
	pc = 0x829FBD10; continue 'dispatch;
            }
            0x829FBD10 => {
    //   block [0x829FBD10..0x829FBD18)
	// 829FBD10: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 829FBD14: 48000014  b 0x829fbd28
	pc = 0x829FBD28; continue 'dispatch;
            }
            0x829FBD18 => {
    //   block [0x829FBD18..0x829FBD28)
	// 829FBD18: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829FBD1C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FBD20: 4B871AD9  bl 0x8226d7f8
	ctx.lr = 0x829FBD24;
	sub_8226D7F8(ctx, base);
	// 829FBD24: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	pc = 0x829FBD28; continue 'dispatch;
            }
            0x829FBD28 => {
    //   block [0x829FBD28..0x829FBD38)
	// 829FBD28: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 829FBD2C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829FBD30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FBD34: 419A05D0  beq cr6, 0x829fc304
	if ctx.cr[6].eq {
	pc = 0x829FC304; continue 'dispatch;
	}
	pc = 0x829FBD38; continue 'dispatch;
            }
            0x829FBD38 => {
    //   block [0x829FBD38..0x829FBD48)
	// 829FBD38: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 829FBD3C: 92E10058  stw r23, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[23].u32 ) };
	// 829FBD40: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	// 829FBD44: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	pc = 0x829FBD48; continue 'dispatch;
            }
            0x829FBD48 => {
    //   block [0x829FBD48..0x829FBD68)
	// 829FBD48: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829FBD4C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FBD50: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829FBD54: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829FBD58: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829FBD5C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FBD60: 4082FFE8  bne 0x829fbd48
	if !ctx.cr[0].eq {
	pc = 0x829FBD48; continue 'dispatch;
	}
	// 829FBD64: 92E10070  stw r23, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[23].u32 ) };
	pc = 0x829FBD68; continue 'dispatch;
            }
            0x829FBD68 => {
    //   block [0x829FBD68..0x829FBD98)
	// 829FBD68: 7CA000A6  mfmsr r5
	ctx.r[5].u64 = ctx.msr;
	// 829FBD6C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FBD70: 7CC04028  lwarx r6, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[6].u64 = ctx.reserved.u32 as u64;
	// 829FBD74: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 829FBD78: 7CC0412D  stwcx. r6, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[6].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829FBD7C: 7CA10164  mtmsrd r5, 1
	ctx.msr = (ctx.r[5].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829FBD80: 4082FFE8  bne 0x829fbd68
	if !ctx.cr[0].eq {
	pc = 0x829FBD68; continue 'dispatch;
	}
	// 829FBD84: 83F90000  lwz r31, 0(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FBD88: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829FBD8C: 409A0038  bne cr6, 0x829fbdc4
	if !ctx.cr[6].eq {
	pc = 0x829FBDC4; continue 'dispatch;
	}
	// 829FBD90: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 829FBD94: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x829FBD98; continue 'dispatch;
            }
            0x829FBD98 => {
    //   block [0x829FBD98..0x829FBDBC)
	// 829FBD98: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FBD9C: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FBDA0: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829FBDA4: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 829FBDA8: 419A0014  beq cr6, 0x829fbdbc
	if ctx.cr[6].eq {
	pc = 0x829FBDBC; continue 'dispatch;
	}
	// 829FBDAC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829FBDB0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829FBDB4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829FBDB8: 419AFFE0  beq cr6, 0x829fbd98
	if ctx.cr[6].eq {
	pc = 0x829FBD98; continue 'dispatch;
	}
	pc = 0x829FBDBC; continue 'dispatch;
            }
            0x829FBDBC => {
    //   block [0x829FBDBC..0x829FBDC4)
	// 829FBDBC: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 829FBDC0: 48000014  b 0x829fbdd4
	pc = 0x829FBDD4; continue 'dispatch;
            }
            0x829FBDC4 => {
    //   block [0x829FBDC4..0x829FBDD4)
	// 829FBDC4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829FBDC8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FBDCC: 4B871A2D  bl 0x8226d7f8
	ctx.lr = 0x829FBDD0;
	sub_8226D7F8(ctx, base);
	// 829FBDD0: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	pc = 0x829FBDD4; continue 'dispatch;
            }
            0x829FBDD4 => {
    //   block [0x829FBDD4..0x829FBE00)
	// 829FBDD4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 829FBDD8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829FBDDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FBDE0: 419A0020  beq cr6, 0x829fbe00
	if ctx.cr[6].eq {
	pc = 0x829FBE00; continue 'dispatch;
	}
	// 829FBDE4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829FBDE8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829FBDEC: 388BB780  addi r4, r11, -0x4880
	ctx.r[4].s64 = ctx.r[11].s64 + -18560;
	// 829FBDF0: 4B8693B1  bl 0x822651a0
	ctx.lr = 0x829FBDF4;
	sub_822651A0(ctx, base);
	// 829FBDF4: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 829FBDF8: 388A1BFC  addi r4, r10, 0x1bfc
	ctx.r[4].s64 = ctx.r[10].s64 + 7164;
	// 829FBDFC: 48000078  b 0x829fbe74
	pc = 0x829FBE74; continue 'dispatch;
            }
            0x829FBE00 => {
    //   block [0x829FBE00..0x829FBE10)
	// 829FBE00: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829FBE04: 409A0038  bne cr6, 0x829fbe3c
	if !ctx.cr[6].eq {
	pc = 0x829FBE3C; continue 'dispatch;
	}
	// 829FBE08: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 829FBE0C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x829FBE10; continue 'dispatch;
            }
            0x829FBE10 => {
    //   block [0x829FBE10..0x829FBE34)
	// 829FBE10: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FBE14: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FBE18: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829FBE1C: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 829FBE20: 419A0014  beq cr6, 0x829fbe34
	if ctx.cr[6].eq {
	pc = 0x829FBE34; continue 'dispatch;
	}
	// 829FBE24: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829FBE28: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829FBE2C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829FBE30: 419AFFE0  beq cr6, 0x829fbe10
	if ctx.cr[6].eq {
	pc = 0x829FBE10; continue 'dispatch;
	}
	pc = 0x829FBE34; continue 'dispatch;
            }
            0x829FBE34 => {
    //   block [0x829FBE34..0x829FBE3C)
	// 829FBE34: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 829FBE38: 48000014  b 0x829fbe4c
	pc = 0x829FBE4C; continue 'dispatch;
            }
            0x829FBE3C => {
    //   block [0x829FBE3C..0x829FBE4C)
	// 829FBE3C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829FBE40: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FBE44: 4B8719B5  bl 0x8226d7f8
	ctx.lr = 0x829FBE48;
	sub_8226D7F8(ctx, base);
	// 829FBE48: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	pc = 0x829FBE4C; continue 'dispatch;
            }
            0x829FBE4C => {
    //   block [0x829FBE4C..0x829FBE74)
	// 829FBE4C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 829FBE50: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829FBE54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FBE58: 419A0024  beq cr6, 0x829fbe7c
	if ctx.cr[6].eq {
	pc = 0x829FBE7C; continue 'dispatch;
	}
	// 829FBE5C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 829FBE60: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829FBE64: 388BB784  addi r4, r11, -0x487c
	ctx.r[4].s64 = ctx.r[11].s64 + -18556;
	// 829FBE68: 4B869339  bl 0x822651a0
	ctx.lr = 0x829FBE6C;
	sub_822651A0(ctx, base);
	// 829FBE6C: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 829FBE70: 388A1C14  addi r4, r10, 0x1c14
	ctx.r[4].s64 = ctx.r[10].s64 + 7188;
	pc = 0x829FBE74; continue 'dispatch;
            }
            0x829FBE74 => {
    //   block [0x829FBE74..0x829FBE7C)
	// 829FBE74: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829FBE78: 4B8795C1  bl 0x82275438
	ctx.lr = 0x829FBE7C;
	sub_82275438(ctx, base);
	pc = 0x829FBE7C; continue 'dispatch;
            }
            0x829FBE7C => {
    //   block [0x829FBE7C..0x829FBEB0)
	// 829FBE7C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829FBE80: 4B9B4BB9  bl 0x823b0a38
	ctx.lr = 0x829FBE84;
	sub_823B0A38(ctx, base);
	// 829FBE84: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829FBE88: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829FBE8C: 4BAFF65D  bl 0x824fb4e8
	ctx.lr = 0x829FBE90;
	sub_824FB4E8(ctx, base);
	// 829FBE90: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829FBE94: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829FBE98: 419A0018  beq cr6, 0x829fbeb0
	if ctx.cr[6].eq {
	pc = 0x829FBEB0; continue 'dispatch;
	}
	// 829FBE9C: 897E0090  lbz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 829FBEA0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 829FBEA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829FBEA8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829FBEAC: 409A0008  bne cr6, 0x829fbeb4
	if !ctx.cr[6].eq {
	pc = 0x829FBEB4; continue 'dispatch;
	}
	pc = 0x829FBEB0; continue 'dispatch;
            }
            0x829FBEB0 => {
    //   block [0x829FBEB0..0x829FBEB4)
	// 829FBEB0: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x829FBEB4; continue 'dispatch;
            }
            0x829FBEB4 => {
    //   block [0x829FBEB4..0x829FC2F4)
	// 829FBEB4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829FBEB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829FBEBC: 419A0438  beq cr6, 0x829fc2f4
	if ctx.cr[6].eq {
	pc = 0x829FC2F4; continue 'dispatch;
	}
	// 829FBEC0: 7F1ED840  cmplw cr6, r30, r27
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[27].u32, &mut ctx.xer);
	// 829FBEC4: 409A0430  bne cr6, 0x829fc2f4
	if !ctx.cr[6].eq {
	pc = 0x829FC2F4; continue 'dispatch;
	}
	// 829FBEC8: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829FBECC: 3BE10058  addi r31, r1, 0x58
	ctx.r[31].s64 = ctx.r[1].s64 + 88;
	// 829FBED0: 4B778599  bl 0x82174468
	ctx.lr = 0x829FBED4;
	sub_82174468(ctx, base);
	// 829FBED4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829FBED8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829FBEDC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 829FBEE0: 4BFFD021  bl 0x829f8f00
	ctx.lr = 0x829FBEE4;
	sub_829F8F00(ctx, base);
	// 829FBEE4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FBEE8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 829FBEEC: 39210054  addi r9, r1, 0x54
	ctx.r[9].s64 = ctx.r[1].s64 + 84;
	// 829FBEF0: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 829FBEF4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 829FBEF8: C3EB9484  lfs f31, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829FBEFC: 3BB80090  addi r29, r24, 0x90
	ctx.r[29].s64 = ctx.r[24].s64 + 144;
	// 829FBF00: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	pc = 0x829FC2F4; continue 'dispatch;
            }
            0x829FC2F4 => {
    //   block [0x829FC2F4..0x829FC304)
	// 829FC2F4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829FC2F8: 4B818AE1  bl 0x82214dd8
	ctx.lr = 0x829FC2FC;
	sub_82214DD8(ctx, base);
	// 829FC2FC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829FC300: 4B818AD9  bl 0x82214dd8
	ctx.lr = 0x829FC304;
	sub_82214DD8(ctx, base);
	pc = 0x829FC304; continue 'dispatch;
            }
            0x829FC304 => {
    //   block [0x829FC304..0x829FC310)
	// 829FC304: 38210210  addi r1, r1, 0x210
	ctx.r[1].s64 = ctx.r[1].s64 + 528;
	// 829FC308: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 829FC30C: 482AD138  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FC310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FC310 size=116
    let mut pc: u32 = 0x829FC310;
    'dispatch: loop {
        match pc {
            0x829FC310 => {
    //   block [0x829FC310..0x829FC350)
	// 829FC310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FC314: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FC318: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FC31C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FC320: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FC324: 4B7E7415  bl 0x821e3738
	ctx.lr = 0x829FC328;
	sub_821E3738(ctx, base);
	// 829FC328: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 829FC32C: 4B822F2D  bl 0x8221f258
	ctx.lr = 0x829FC330;
	sub_8221F258(ctx, base);
	// 829FC330: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FC334: 419A001C  beq cr6, 0x829fc350
	if ctx.cr[6].eq {
	pc = 0x829FC350; continue 'dispatch;
	}
	// 829FC338: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829FC33C: 38BF0078  addi r5, r31, 0x78
	ctx.r[5].s64 = ctx.r[31].s64 + 120;
	// 829FC340: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829FC344: 4BC8402D  bl 0x82680370
	ctx.lr = 0x829FC348;
	sub_82680370(ctx, base);
	// 829FC348: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829FC34C: 48000008  b 0x829fc354
	pc = 0x829FC354; continue 'dispatch;
            }
            0x829FC350 => {
    //   block [0x829FC350..0x829FC354)
	// 829FC350: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829FC354; continue 'dispatch;
            }
            0x829FC354 => {
    //   block [0x829FC354..0x829FC384)
	// 829FC354: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FC358: 4B7BF759  bl 0x821bbab0
	ctx.lr = 0x829FC35C;
	sub_821BBAB0(ctx, base);
	// 829FC35C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829FC360: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FC364: 4B86FB05  bl 0x8226be68
	ctx.lr = 0x829FC368;
	sub_8226BE68(ctx, base);
	// 829FC368: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FC36C: 4B7BB7AD  bl 0x821b7b18
	ctx.lr = 0x829FC370;
	sub_821B7B18(ctx, base);
	// 829FC370: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FC374: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FC378: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FC37C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FC380: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FC388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FC388 size=160
    let mut pc: u32 = 0x829FC388;
    'dispatch: loop {
        match pc {
            0x829FC388 => {
    //   block [0x829FC388..0x829FC3F4)
	// 829FC388: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FC38C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829FC390: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829FC394: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FC398: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FC39C: 4B7E739D  bl 0x821e3738
	ctx.lr = 0x829FC3A0;
	sub_821E3738(ctx, base);
	// 829FC3A0: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 829FC3A4: 4B822EB5  bl 0x8221f258
	ctx.lr = 0x829FC3A8;
	sub_8221F258(ctx, base);
	// 829FC3A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FC3AC: 419A0048  beq cr6, 0x829fc3f4
	if ctx.cr[6].eq {
	pc = 0x829FC3F4; continue 'dispatch;
	}
	// 829FC3B0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 829FC3B4: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 829FC3B8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 829FC3BC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 829FC3C0: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 829FC3C4: 38EB1848  addi r7, r11, 0x1848
	ctx.r[7].s64 = ctx.r[11].s64 + 6216;
	// 829FC3C8: 38CAB7B0  addi r6, r10, -0x4850
	ctx.r[6].s64 = ctx.r[10].s64 + -18512;
	// 829FC3CC: 38A9B7CC  addi r5, r9, -0x4834
	ctx.r[5].s64 = ctx.r[9].s64 + -18484;
	// 829FC3D0: 90E30008  stw r7, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 829FC3D4: 38880E0C  addi r4, r8, 0xe0c
	ctx.r[4].s64 = ctx.r[8].s64 + 3596;
	// 829FC3D8: 90C30000  stw r6, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 829FC3DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FC3E0: 90A30008  stw r5, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 829FC3E4: 9083000C  stw r4, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 829FC3E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829FC3EC: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 829FC3F0: 48000008  b 0x829fc3f8
	pc = 0x829FC3F8; continue 'dispatch;
            }
            0x829FC3F4 => {
    //   block [0x829FC3F4..0x829FC3F8)
	// 829FC3F4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x829FC3F8; continue 'dispatch;
            }
            0x829FC3F8 => {
    //   block [0x829FC3F8..0x829FC428)
	// 829FC3F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FC3FC: 4B7BF6B5  bl 0x821bbab0
	ctx.lr = 0x829FC400;
	sub_821BBAB0(ctx, base);
	// 829FC400: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829FC404: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829FC408: 4B86FA61  bl 0x8226be68
	ctx.lr = 0x829FC40C;
	sub_8226BE68(ctx, base);
	// 829FC40C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FC410: 4B7BB709  bl 0x821b7b18
	ctx.lr = 0x829FC414;
	sub_821B7B18(ctx, base);
	// 829FC414: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829FC418: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829FC41C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829FC420: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829FC424: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FC428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FC428 size=220
    let mut pc: u32 = 0x829FC428;
    'dispatch: loop {
        match pc {
            0x829FC428 => {
    //   block [0x829FC428..0x829FC450)
	// 829FC428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FC42C: 482ACFD5  bl 0x82ca9400
	ctx.lr = 0x829FC430;
	sub_82CA93D0(ctx, base);
	// 829FC430: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FC434: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829FC438: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 829FC43C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 829FC440: 4B822E19  bl 0x8221f258
	ctx.lr = 0x829FC444;
	sub_8221F258(ctx, base);
	// 829FC444: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829FC448: 419A0008  beq cr6, 0x829fc450
	if ctx.cr[6].eq {
	pc = 0x829FC450; continue 'dispatch;
	}
	// 829FC44C: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x829FC450; continue 'dispatch;
            }
            0x829FC450 => {
    //   block [0x829FC450..0x829FC45C)
	// 829FC450: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829FC454: 41820008  beq 0x829fc45c
	if ctx.cr[0].eq {
	pc = 0x829FC45C; continue 'dispatch;
	}
	// 829FC458: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x829FC45C; continue 'dispatch;
            }
            0x829FC45C => {
    //   block [0x829FC45C..0x829FC498)
	// 829FC45C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829FC460: 907D0004  stw r3, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 829FC464: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 829FC468: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 829FC46C: 837A0004  lwz r27, 4(r26)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FC470: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FC474: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 829FC478: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FC47C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 829FC480: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829FC484: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 829FC488: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 829FC48C: EB810058  ld r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829FC490: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829FC494: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x829FC498; continue 'dispatch;
            }
            0x829FC498 => {
    //   block [0x829FC498..0x829FC4A8)
	// 829FC498: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829FC49C: 419A000C  beq cr6, 0x829fc4a8
	if ctx.cr[6].eq {
	pc = 0x829FC4A8; continue 'dispatch;
	}
	// 829FC4A0: 7F1ED040  cmplw cr6, r30, r26
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[26].u32, &mut ctx.xer);
	// 829FC4A4: 419A0008  beq cr6, 0x829fc4ac
	if ctx.cr[6].eq {
	pc = 0x829FC4AC; continue 'dispatch;
	}
	pc = 0x829FC4A8; continue 'dispatch;
            }
            0x829FC4A8 => {
    //   block [0x829FC4A8..0x829FC4AC)
	// 829FC4A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829FC4AC; continue 'dispatch;
            }
            0x829FC4AC => {
    //   block [0x829FC4AC..0x829FC4C0)
	// 829FC4AC: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 829FC4B0: 419A0048  beq cr6, 0x829fc4f8
	if ctx.cr[6].eq {
	pc = 0x829FC4F8; continue 'dispatch;
	}
	// 829FC4B4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829FC4B8: 409A0008  bne cr6, 0x829fc4c0
	if !ctx.cr[6].eq {
	pc = 0x829FC4C0; continue 'dispatch;
	}
	// 829FC4BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829FC4C0; continue 'dispatch;
            }
            0x829FC4C0 => {
    //   block [0x829FC4C0..0x829FC4D0)
	// 829FC4C0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FC4C4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829FC4C8: 409A0008  bne cr6, 0x829fc4d0
	if !ctx.cr[6].eq {
	pc = 0x829FC4D0; continue 'dispatch;
	}
	// 829FC4CC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829FC4D0; continue 'dispatch;
            }
            0x829FC4D0 => {
    //   block [0x829FC4D0..0x829FC4F0)
	// 829FC4D0: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 829FC4D4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829FC4D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829FC4DC: 4800002D  bl 0x829fc508
	ctx.lr = 0x829FC4E0;
	sub_829FC508(ctx, base);
	// 829FC4E0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FC4E4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829FC4E8: 409A0008  bne cr6, 0x829fc4f0
	if !ctx.cr[6].eq {
	pc = 0x829FC4F0; continue 'dispatch;
	}
	// 829FC4EC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x829FC4F0; continue 'dispatch;
            }
            0x829FC4F0 => {
    //   block [0x829FC4F0..0x829FC4F8)
	// 829FC4F0: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FC4F4: 4BFFFFA4  b 0x829fc498
	pc = 0x829FC498; continue 'dispatch;
            }
            0x829FC4F8 => {
    //   block [0x829FC4F8..0x829FC504)
	// 829FC4F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829FC4FC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829FC500: 482ACF50  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829FC508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829FC508 size=236
    let mut pc: u32 = 0x829FC508;
    'dispatch: loop {
        match pc {
            0x829FC508 => {
    //   block [0x829FC508..0x829FC540)
	// 829FC508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829FC50C: 482ACEF5  bl 0x82ca9400
	ctx.lr = 0x829FC510;
	sub_82CA93D0(ctx, base);
	// 829FC510: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829FC514: F88100E8  std r4, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[4].u64 ) };
	// 829FC518: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829FC51C: 834100EC  lwz r26, 0xec(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 829FC520: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 829FC524: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829FC528: 83DA0004  lwz r30, 4(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 829FC52C: 4B822D2D  bl 0x8221f258
	ctx.lr = 0x829FC530;
	sub_8221F258(ctx, base);
	// 829FC530: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829FC534: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829FC538: 419A0008  beq cr6, 0x829fc540
	if ctx.cr[6].eq {
	pc = 0x829FC540; continue 'dispatch;
	}
	// 829FC53C: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	pc = 0x829FC540; continue 'dispatch;
            }
            0x829FC540 => {
    //   block [0x829FC540..0x829FC550)
	// 829FC540: 3B9F0004  addi r28, r31, 4
	ctx.r[28].s64 = ctx.r[31].s64 + 4;
	// 829FC544: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829FC548: 419A0008  beq cr6, 0x829fc550
	if ctx.cr[6].eq {
	pc = 0x829FC550; continue 'dispatch;
	}
	// 829FC54C: 93DC0000  stw r30, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x829FC550; continue 'dispatch;
            }
            0x829FC550 => {
    //   block [0x829FC550..0x829FC564)
	// 829FC550: 355F0008  addic. r10, r31, 8
	ctx.xer.ca = (ctx.r[31].u32 > (!(8 as u32)));
	ctx.r[10].s64 = ctx.r[31].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 829FC554: 41820024  beq 0x829fc578
	if ctx.cr[0].eq {
	pc = 0x829FC578; continue 'dispatch;
	}
	// 829FC558: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 829FC55C: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 829FC560: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x829FC564; continue 'dispatch;
            }
            0x829FC564 => {
    //   block [0x829FC564..0x829FC578)
	// 829FC564: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FC568: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829FC56C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829FC570: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 829FC574: 4200FFF0  bdnz 0x829fc564
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x829FC564; continue 'dispatch;
	}
	pc = 0x829FC578; continue 'dispatch;
            }
            0x829FC578 => {
    //   block [0x829FC578..0x829FC5D4)
	// 829FC578: 3D600924  lis r11, 0x924
	ctx.r[11].s64 = 153354240;
	// 829FC57C: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FC580: 61699249  ori r9, r11, 0x9249
	ctx.r[9].u64 = ctx.r[11].u64 | 37449;
	// 829FC584: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 829FC588: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 829FC58C: 40980048  bge cr6, 0x829fc5d4
	if !ctx.cr[6].lt {
	pc = 0x829FC5D4; continue 'dispatch;
	}
	// 829FC590: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829FC594: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FC598: 388B2D94  addi r4, r11, 0x2d94
	ctx.r[4].s64 = ctx.r[11].s64 + 11668;
	// 829FC59C: 4B8F59A5  bl 0x822f1f40
	ctx.lr = 0x829FC5A0;
	sub_822F1F40(ctx, base);
	// 829FC5A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829FC5A4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829FC5A8: 4B8F5809  bl 0x822f1db0
	ctx.lr = 0x829FC5AC;
	sub_822F1DB0(ctx, base);
	// 829FC5AC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829FC5B0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829FC5B4: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 829FC5B8: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 829FC5BC: 4B8F5865  bl 0x822f1e20
	ctx.lr = 0x829FC5C0;
	sub_822F1E20(ctx, base);
	// 829FC5C0: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 829FC5C4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829FC5C8: 4BC7F219  bl 0x8267b7e0
	ctx.lr = 0x829FC5CC;
	sub_8267B7E0(ctx, base);
	// 829FC5CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829FC5D0: 4B775241  bl 0x82171810
	ctx.lr = 0x829FC5D4;
	sub_82171810(ctx, base);
	pc = 0x829FC5D4; continue 'dispatch;
            }
            0x829FC5D4 => {
    //   block [0x829FC5D4..0x829FC5F4)
	// 829FC5D4: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 829FC5D8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829FC5DC: 917B0008  stw r11, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 829FC5E0: 93FA0004  stw r31, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 829FC5E4: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 829FC5E8: 93EA0000  stw r31, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829FC5EC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 829FC5F0: 482ACE60  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


