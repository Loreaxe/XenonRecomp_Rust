pub fn sub_821B7468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B7468 size=880
    let mut pc: u32 = 0x821B7468;
    'dispatch: loop {
        match pc {
            0x821B7468 => {
    //   block [0x821B7468..0x821B74EC)
	// 821B7468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B746C: 48AF1F99  bl 0x82ca9404
	ctx.lr = 0x821B7470;
	sub_82CA93D0(ctx, base);
	// 821B7470: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B7474: F88100C8  std r4, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[4].u64 ) };
	// 821B7478: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821B747C: F8A100D0  std r5, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[5].u64 ) };
	// 821B7480: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 821B7484: 838100D4  lwz r28, 0xd4(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 821B7488: 397CFFF8  addi r11, r28, -8
	ctx.r[11].s64 = ctx.r[28].s64 + -8;
	// 821B748C: F8A10060  std r5, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u64 ) };
	// 821B7490: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 821B7494: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821B7498: 83A100CC  lwz r29, 0xcc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 821B749C: 7D5DE050  subf r10, r29, r28
	ctx.r[10].s64 = ctx.r[28].s64 - ctx.r[29].s64;
	// 821B74A0: 7D491E70  srawi r9, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 821B74A4: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 821B74A8: 7D280E70  srawi r8, r9, 1
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 1) as i64;
	// 821B74AC: 7CE80194  addze r7, r8
	tmp.s64 = ctx.r[8].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[8].u32);
	ctx.r[7].s64 = tmp.s64;
	// 821B74B0: 54EB1838  slwi r11, r7, 3
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B74B4: 7FEBEA14  add r31, r11, r29
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821B74B8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 821B74BC: EBC10058  ld r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B74C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821B74C4: 4BFFFE9D  bl 0x821b7360
	ctx.lr = 0x821B74C8;
	sub_821B7360(ctx, base);
	// 821B74C8: 393F0008  addi r9, r31, 8
	ctx.r[9].s64 = ctx.r[31].s64 + 8;
	// 821B74CC: FBC10060  std r30, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u64 ) };
	// 821B74D0: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821B74D4: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 821B74D8: E8C10060  ld r6, 0x60(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821B74DC: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 821B74E0: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B74E4: F8C10058  std r6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u64 ) };
	// 821B74E8: 40980058  bge cr6, 0x821b7540
	if !ctx.cr[6].lt {
	pc = 0x821B7540; continue 'dispatch;
	}
	pc = 0x821B74EC; continue 'dispatch;
            }
            0x821B74EC => {
    //   block [0x821B74EC..0x821B7504)
	// 821B74EC: 8167FFF8  lwz r11, -8(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B74F0: 81470000  lwz r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B74F4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821B74F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B74FC: 41980008  blt cr6, 0x821b7504
	if ctx.cr[6].lt {
	pc = 0x821B7504; continue 'dispatch;
	}
	// 821B7500: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821B7504; continue 'dispatch;
            }
            0x821B7504 => {
    //   block [0x821B7504..0x821B7524)
	// 821B7504: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B7508: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B750C: 409A0034  bne cr6, 0x821b7540
	if !ctx.cr[6].eq {
	pc = 0x821B7540; continue 'dispatch;
	}
	// 821B7510: 8167FFF8  lwz r11, -8(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B7514: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B7518: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B751C: 41980008  blt cr6, 0x821b7524
	if ctx.cr[6].lt {
	pc = 0x821B7524; continue 'dispatch;
	}
	// 821B7520: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821B7524; continue 'dispatch;
            }
            0x821B7524 => {
    //   block [0x821B7524..0x821B7540)
	// 821B7524: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B7528: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B752C: 409A0014  bne cr6, 0x821b7540
	if !ctx.cr[6].eq {
	pc = 0x821B7540; continue 'dispatch;
	}
	// 821B7530: 38E7FFF8  addi r7, r7, -8
	ctx.r[7].s64 = ctx.r[7].s64 + -8;
	// 821B7534: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 821B7538: 7F1D3840  cmplw cr6, r29, r7
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821B753C: 4198FFB0  blt cr6, 0x821b74ec
	if ctx.cr[6].lt {
	pc = 0x821B74EC; continue 'dispatch;
	}
	pc = 0x821B7540; continue 'dispatch;
            }
            0x821B7540 => {
    //   block [0x821B7540..0x821B7550)
	// 821B7540: 80A1005C  lwz r5, 0x5c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821B7544: 7F09E040  cmplw cr6, r9, r28
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821B7548: 40980054  bge cr6, 0x821b759c
	if !ctx.cr[6].lt {
	pc = 0x821B759C; continue 'dispatch;
	}
	// 821B754C: 81270000  lwz r9, 0(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821B7550; continue 'dispatch;
            }
            0x821B7550 => {
    //   block [0x821B7550..0x821B7564)
	// 821B7550: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7554: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B7558: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B755C: 41980008  blt cr6, 0x821b7564
	if ctx.cr[6].lt {
	pc = 0x821B7564; continue 'dispatch;
	}
	// 821B7560: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821B7564; continue 'dispatch;
            }
            0x821B7564 => {
    //   block [0x821B7564..0x821B7580)
	// 821B7564: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B7568: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B756C: 409A0030  bne cr6, 0x821b759c
	if !ctx.cr[6].eq {
	pc = 0x821B759C; continue 'dispatch;
	}
	// 821B7570: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821B7574: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B7578: 41980008  blt cr6, 0x821b7580
	if ctx.cr[6].lt {
	pc = 0x821B7580; continue 'dispatch;
	}
	// 821B757C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821B7580; continue 'dispatch;
            }
            0x821B7580 => {
    //   block [0x821B7580..0x821B759C)
	// 821B7580: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B7584: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B7588: 409A0014  bne cr6, 0x821b759c
	if !ctx.cr[6].eq {
	pc = 0x821B759C; continue 'dispatch;
	}
	// 821B758C: 38A50008  addi r5, r5, 8
	ctx.r[5].s64 = ctx.r[5].s64 + 8;
	// 821B7590: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 821B7594: 7F05E040  cmplw cr6, r5, r28
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821B7598: 4198FFB8  blt cr6, 0x821b7550
	if ctx.cr[6].lt {
	pc = 0x821B7550; continue 'dispatch;
	}
	pc = 0x821B759C; continue 'dispatch;
            }
            0x821B759C => {
    //   block [0x821B759C..0x821B75B4)
	// 821B759C: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B75A0: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B75A4: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821B75A8: F9410068  std r10, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u64 ) };
	// 821B75AC: 81010064  lwz r8, 0x64(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821B75B0: 80C1006C  lwz r6, 0x6c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	pc = 0x821B75B4; continue 'dispatch;
            }
            0x821B75B4 => {
    //   block [0x821B75B4..0x821B75BC)
	// 821B75B4: 7F08E040  cmplw cr6, r8, r28
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821B75B8: 40980080  bge cr6, 0x821b7638
	if !ctx.cr[6].lt {
	pc = 0x821B7638; continue 'dispatch;
	}
	pc = 0x821B75BC; continue 'dispatch;
            }
            0x821B75BC => {
    //   block [0x821B75BC..0x821B75D4)
	// 821B75BC: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B75C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B75C4: 81270000  lwz r9, 0(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B75C8: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821B75CC: 41980008  blt cr6, 0x821b75d4
	if ctx.cr[6].lt {
	pc = 0x821B75D4; continue 'dispatch;
	}
	// 821B75D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821B75D4; continue 'dispatch;
            }
            0x821B75D4 => {
    //   block [0x821B75D4..0x821B75F0)
	// 821B75D4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B75D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B75DC: 409A004C  bne cr6, 0x821b7628
	if !ctx.cr[6].eq {
	pc = 0x821B7628; continue 'dispatch;
	}
	// 821B75E0: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B75E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B75E8: 41980008  blt cr6, 0x821b75f0
	if ctx.cr[6].lt {
	pc = 0x821B75F0; continue 'dispatch;
	}
	// 821B75EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821B75F0; continue 'dispatch;
            }
            0x821B75F0 => {
    //   block [0x821B75F0..0x821B7628)
	// 821B75F0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B75F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B75F8: 409A0040  bne cr6, 0x821b7638
	if !ctx.cr[6].eq {
	pc = 0x821B7638; continue 'dispatch;
	}
	// 821B75FC: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B7600: 38A50008  addi r5, r5, 8
	ctx.r[5].s64 = ctx.r[5].s64 + 8;
	// 821B7604: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7608: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 821B760C: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821B7610: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821B7614: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821B7618: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B761C: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7620: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 821B7624: F9280000  std r9, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	pc = 0x821B7628; continue 'dispatch;
            }
            0x821B7628 => {
    //   block [0x821B7628..0x821B7638)
	// 821B7628: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 821B762C: 91010064  stw r8, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[8].u32 ) };
	// 821B7630: 7F08E040  cmplw cr6, r8, r28
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821B7634: 4198FF88  blt cr6, 0x821b75bc
	if ctx.cr[6].lt {
	pc = 0x821B75BC; continue 'dispatch;
	}
	pc = 0x821B7638; continue 'dispatch;
            }
            0x821B7638 => {
    //   block [0x821B7638..0x821B7640)
	// 821B7638: 7F06E840  cmplw cr6, r6, r29
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[29].u32, &mut ctx.xer);
	// 821B763C: 40990080  ble cr6, 0x821b76bc
	if !ctx.cr[6].gt {
	pc = 0x821B76BC; continue 'dispatch;
	}
	pc = 0x821B7640; continue 'dispatch;
            }
            0x821B7640 => {
    //   block [0x821B7640..0x821B765C)
	// 821B7640: 8146FFF8  lwz r10, -8(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B7644: 3966FFF8  addi r11, r6, -8
	ctx.r[11].s64 = ctx.r[6].s64 + -8;
	// 821B7648: 81270000  lwz r9, 0(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B764C: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821B7650: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B7654: 41980008  blt cr6, 0x821b765c
	if ctx.cr[6].lt {
	pc = 0x821B765C; continue 'dispatch;
	}
	// 821B7658: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821B765C; continue 'dispatch;
            }
            0x821B765C => {
    //   block [0x821B765C..0x821B767C)
	// 821B765C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821B7660: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B7664: 409A0048  bne cr6, 0x821b76ac
	if !ctx.cr[6].eq {
	pc = 0x821B76AC; continue 'dispatch;
	}
	// 821B7668: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B766C: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821B7670: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B7674: 41980008  blt cr6, 0x821b767c
	if ctx.cr[6].lt {
	pc = 0x821B767C; continue 'dispatch;
	}
	// 821B7678: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821B767C; continue 'dispatch;
            }
            0x821B767C => {
    //   block [0x821B767C..0x821B76AC)
	// 821B767C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821B7680: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B7684: 409A0034  bne cr6, 0x821b76b8
	if !ctx.cr[6].eq {
	pc = 0x821B76B8; continue 'dispatch;
	}
	// 821B7688: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821B768C: 38E7FFF8  addi r7, r7, -8
	ctx.r[7].s64 = ctx.r[7].s64 + -8;
	// 821B7690: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 821B7694: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7698: E8C70000  ld r6, 0(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 821B769C: 91270000  stw r9, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821B76A0: 808A0004  lwz r4, 4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B76A4: 90870004  stw r4, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 821B76A8: F8CA0000  std r6, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	pc = 0x821B76AC; continue 'dispatch;
            }
            0x821B76AC => {
    //   block [0x821B76AC..0x821B76B8)
	// 821B76AC: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 821B76B0: 7F1D3040  cmplw cr6, r29, r6
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B76B4: 4198FF8C  blt cr6, 0x821b7640
	if ctx.cr[6].lt {
	pc = 0x821B7640; continue 'dispatch;
	}
	pc = 0x821B76B8; continue 'dispatch;
            }
            0x821B76B8 => {
    //   block [0x821B76B8..0x821B76BC)
	// 821B76B8: 7F06E840  cmplw cr6, r6, r29
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[29].u32, &mut ctx.xer);
	pc = 0x821B76BC; continue 'dispatch;
            }
            0x821B76BC => {
    //   block [0x821B76BC..0x821B76E8)
	// 821B76BC: 409A0078  bne cr6, 0x821b7734
	if !ctx.cr[6].eq {
	pc = 0x821B7734; continue 'dispatch;
	}
	// 821B76C0: 7F08E040  cmplw cr6, r8, r28
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821B76C4: 419A00F8  beq cr6, 0x821b77bc
	if ctx.cr[6].eq {
	pc = 0x821B77BC; continue 'dispatch;
	}
	// 821B76C8: 7F054040  cmplw cr6, r5, r8
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B76CC: 419A001C  beq cr6, 0x821b76e8
	if ctx.cr[6].eq {
	pc = 0x821B76E8; continue 'dispatch;
	}
	// 821B76D0: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B76D4: E9470000  ld r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 821B76D8: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B76DC: 81250004  lwz r9, 4(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B76E0: 91270004  stw r9, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821B76E4: F9450000  std r10, 0(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	pc = 0x821B76E8; continue 'dispatch;
            }
            0x821B76E8 => {
    //   block [0x821B76E8..0x821B7734)
	// 821B76E8: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821B76EC: 38A50008  addi r5, r5, 8
	ctx.r[5].s64 = ctx.r[5].s64 + 8;
	// 821B76F0: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B76F4: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 821B76F8: 38E70008  addi r7, r7, 8
	ctx.r[7].s64 = ctx.r[7].s64 + 8;
	// 821B76FC: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 821B7700: 91010064  stw r8, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[8].u32 ) };
	// 821B7704: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 821B7708: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 821B770C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821B7710: F9410068  std r10, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u64 ) };
	// 821B7714: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821B7718: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 821B771C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7720: 908A0000  stw r4, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 821B7724: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7728: 906A0004  stw r3, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 821B772C: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821B7730: 4BFFFE84  b 0x821b75b4
	pc = 0x821B75B4; continue 'dispatch;
            }
            0x821B7734 => {
    //   block [0x821B7734..0x821B7768)
	// 821B7734: 7F08E040  cmplw cr6, r8, r28
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821B7738: 38C6FFF8  addi r6, r6, -8
	ctx.r[6].s64 = ctx.r[6].s64 + -8;
	// 821B773C: 409A0050  bne cr6, 0x821b778c
	if !ctx.cr[6].eq {
	pc = 0x821B778C; continue 'dispatch;
	}
	// 821B7740: 38E7FFF8  addi r7, r7, -8
	ctx.r[7].s64 = ctx.r[7].s64 + -8;
	// 821B7744: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 821B7748: 7F063840  cmplw cr6, r6, r7
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821B774C: 419A001C  beq cr6, 0x821b7768
	if ctx.cr[6].eq {
	pc = 0x821B7768; continue 'dispatch;
	}
	// 821B7750: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7754: E9460000  ld r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	// 821B7758: 91660000  stw r11, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B775C: 81270004  lwz r9, 4(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7760: 91260004  stw r9, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821B7764: F9470000  std r10, 0(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	pc = 0x821B7768; continue 'dispatch;
            }
            0x821B7768 => {
    //   block [0x821B7768..0x821B778C)
	// 821B7768: 38A5FFF8  addi r5, r5, -8
	ctx.r[5].s64 = ctx.r[5].s64 + -8;
	// 821B776C: E9670000  ld r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 821B7770: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 821B7774: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7778: 91470000  stw r10, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B777C: 81250004  lwz r9, 4(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7780: 91270004  stw r9, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821B7784: F9650000  std r11, 0(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821B7788: 4BFFFE2C  b 0x821b75b4
	pc = 0x821B75B4; continue 'dispatch;
            }
            0x821B778C => {
    //   block [0x821B778C..0x821B77BC)
	// 821B778C: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821B7790: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 821B7794: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7798: 91010064  stw r8, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[8].u32 ) };
	// 821B779C: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 821B77A0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821B77A4: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821B77A8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B77AC: 80860004  lwz r4, 4(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B77B0: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 821B77B4: F9260000  std r9, 0(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821B77B8: 4BFFFDFC  b 0x821b75b4
	pc = 0x821B75B4; continue 'dispatch;
            }
            0x821B77BC => {
    //   block [0x821B77BC..0x821B77D8)
	// 821B77BC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B77C0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B77C4: E9410058  ld r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B77C8: F97B0000  std r11, 0(r27)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821B77CC: F95B0008  std r10, 8(r27)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 821B77D0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821B77D4: 48AF1C80  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B77D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B77D8 size=408
    let mut pc: u32 = 0x821B77D8;
    'dispatch: loop {
        match pc {
            0x821B77D8 => {
    //   block [0x821B77D8..0x821B7810)
	// 821B77D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B77DC: 48AF1C25  bl 0x82ca9400
	ctx.lr = 0x821B77E0;
	sub_82CA93D0(ctx, base);
	// 821B77E0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B77E4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821B77E8: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 821B77EC: FB6100B0  std r27, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[27].u64 ) };
	// 821B77F0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821B77F4: FB4100B8  std r26, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[26].u64 ) };
	// 821B77F8: 83C100B4  lwz r30, 0xb4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 821B77FC: 83A100BC  lwz r29, 0xbc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 821B7800: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 821B7804: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 821B7808: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 821B780C: 40990098  ble cr6, 0x821b78a4
	if !ctx.cr[6].gt {
	pc = 0x821B78A4; continue 'dispatch;
	}
	pc = 0x821B7810; continue 'dispatch;
            }
            0x821B7810 => {
    //   block [0x821B7810..0x821B787C)
	// 821B7810: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821B7814: 409900B0  ble cr6, 0x821b78c4
	if !ctx.cr[6].gt {
	pc = 0x821B78C4; continue 'dispatch;
	}
	// 821B7818: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 821B781C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821B7820: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B7824: 4BFFFC45  bl 0x821b7468
	ctx.lr = 0x821B7828;
	sub_821B7468(ctx, base);
	// 821B7828: 7FEB0E70  srawi r11, r31, 1
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[31].s32 >> 1) as i64;
	// 821B782C: 8121005C  lwz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821B7830: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 821B7834: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B7838: 7CE9E850  subf r7, r9, r29
	ctx.r[7].s64 = ctx.r[29].s64 - ctx.r[9].s64;
	// 821B783C: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B7840: 7CDE4050  subf r6, r30, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[30].s64;
	// 821B7844: 7D4A0194  addze r10, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[10].s64 = tmp.s64;
	// 821B7848: 54E50038  rlwinm r5, r7, 0, 0, 0x1c
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 821B784C: 54C40038  rlwinm r4, r6, 0, 0, 0x1c
	ctx.r[4].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 821B7850: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B7854: 7F042800  cmpw cr6, r4, r5
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[5].s32, &mut ctx.xer);
	// 821B7858: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821B785C: 40980020  bge cr6, 0x821b787c
	if !ctx.cr[6].lt {
	pc = 0x821B787C; continue 'dispatch;
	}
	// 821B7860: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B7864: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B7868: 4BFFFF71  bl 0x821b77d8
	ctx.lr = 0x821B786C;
	sub_821B77D8(ctx, base);
	// 821B786C: EB610058  ld r27, 0x58(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B7870: FB6100B0  std r27, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[27].u64 ) };
	// 821B7874: 83C100B4  lwz r30, 0xb4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 821B7878: 4800001C  b 0x821b7894
	pc = 0x821B7894; continue 'dispatch;
            }
            0x821B787C => {
    //   block [0x821B787C..0x821B7894)
	// 821B787C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821B7880: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B7884: 4BFFFF55  bl 0x821b77d8
	ctx.lr = 0x821B7888;
	sub_821B77D8(ctx, base);
	// 821B7888: EB410050  ld r26, 0x50(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B788C: FB4100B8  std r26, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[26].u64 ) };
	// 821B7890: 83A100BC  lwz r29, 0xbc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	pc = 0x821B7894; continue 'dispatch;
            }
            0x821B7894 => {
    //   block [0x821B7894..0x821B78A4)
	// 821B7894: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 821B7898: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 821B789C: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 821B78A0: 4199FF70  bgt cr6, 0x821b7810
	if ctx.cr[6].gt {
	pc = 0x821B7810; continue 'dispatch;
	}
	pc = 0x821B78A4; continue 'dispatch;
            }
            0x821B78A4 => {
    //   block [0x821B78A4..0x821B78BC)
	// 821B78A4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821B78A8: 40990014  ble cr6, 0x821b78bc
	if !ctx.cr[6].gt {
	pc = 0x821B78BC; continue 'dispatch;
	}
	// 821B78AC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B78B0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821B78B4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B78B8: 480000B9  bl 0x821b7970
	ctx.lr = 0x821B78BC;
	sub_821B7970(ctx, base);
	pc = 0x821B78BC; continue 'dispatch;
            }
            0x821B78BC => {
    //   block [0x821B78BC..0x821B78C4)
	// 821B78BC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821B78C0: 48AF1B90  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B78C4 => {
    //   block [0x821B78C4..0x821B78F0)
	// 821B78C4: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 821B78C8: 4099FFDC  ble cr6, 0x821b78a4
	if !ctx.cr[6].gt {
	pc = 0x821B78A4; continue 'dispatch;
	}
	// 821B78CC: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 821B78D0: 7D7C1E70  srawi r28, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 821B78D4: 2F1C0001  cmpwi cr6, r28, 1
	ctx.cr[6].compare_i32(ctx.r[28].s32, 1, &mut ctx.xer);
	// 821B78D8: 4099003C  ble cr6, 0x821b7914
	if !ctx.cr[6].gt {
	pc = 0x821B7914; continue 'dispatch;
	}
	// 821B78DC: 7F8B0E70  srawi r11, r28, 1
	ctx.xer.ca = (ctx.r[28].s32 < 0) && ((ctx.r[28].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[28].s32 >> 1) as i64;
	// 821B78E0: 7FEB0195  addze. r31, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[31].s64 = tmp.s64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821B78E4: 40810030  ble 0x821b7914
	if !ctx.cr[0].gt {
	pc = 0x821B7914; continue 'dispatch;
	}
	// 821B78E8: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B78EC: 7FABF214  add r29, r11, r30
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	pc = 0x821B78F0; continue 'dispatch;
            }
            0x821B78F0 => {
    //   block [0x821B78F0..0x821B7914)
	// 821B78F0: 3BBDFFF8  addi r29, r29, -8
	ctx.r[29].s64 = ctx.r[29].s64 + -8;
	// 821B78F4: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 821B78F8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821B78FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B7900: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B7904: E8DD0000  ld r6, 0(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 821B7908: 488F1811  bl 0x82aa9118
	ctx.lr = 0x821B790C;
	sub_82AA9118(ctx, base);
	// 821B790C: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821B7910: 4199FFE0  bgt cr6, 0x821b78f0
	if ctx.cr[6].gt {
	pc = 0x821B78F0; continue 'dispatch;
	}
	pc = 0x821B7914; continue 'dispatch;
            }
            0x821B7914 => {
    //   block [0x821B7914..0x821B7924)
	// 821B7914: FB410050  std r26, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u64 ) };
	// 821B7918: 2F1C0001  cmpwi cr6, r28, 1
	ctx.cr[6].compare_i32(ctx.r[28].s32, 1, &mut ctx.xer);
	// 821B791C: 4099FFA0  ble cr6, 0x821b78bc
	if !ctx.cr[6].gt {
	pc = 0x821B78BC; continue 'dispatch;
	}
	// 821B7920: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x821B7924; continue 'dispatch;
            }
            0x821B7924 => {
    //   block [0x821B7924..0x821B7970)
	// 821B7924: 397FFFF8  addi r11, r31, -8
	ctx.r[11].s64 = ctx.r[31].s64 + -8;
	// 821B7928: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B792C: E8DFFFF8  ld r6, -8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) };
	// 821B7930: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B7934: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 821B7938: 7D1E5850  subf r8, r30, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 821B793C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B7940: 7D051E70  srawi r5, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 821B7944: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B7948: 80FE0004  lwz r7, 4(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B794C: 90E90004  stw r7, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821B7950: 488F17C9  bl 0x82aa9118
	ctx.lr = 0x821B7954;
	sub_82AA9118(ctx, base);
	// 821B7954: 3BFFFFF8  addi r31, r31, -8
	ctx.r[31].s64 = ctx.r[31].s64 + -8;
	// 821B7958: 7D7EF850  subf r11, r30, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 821B795C: 7D7C1E70  srawi r28, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 821B7960: 2F1C0001  cmpwi cr6, r28, 1
	ctx.cr[6].compare_i32(ctx.r[28].s32, 1, &mut ctx.xer);
	// 821B7964: 4199FFC0  bgt cr6, 0x821b7924
	if ctx.cr[6].gt {
	pc = 0x821B7924; continue 'dispatch;
	}
	// 821B7968: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821B796C: 48AF1AE4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B7970 size=252
    let mut pc: u32 = 0x821B7970;
    'dispatch: loop {
        match pc {
            0x821B7970 => {
    //   block [0x821B7970..0x821B79AC)
	// 821B7970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B7974: 48AF1A91  bl 0x82ca9404
	ctx.lr = 0x821B7978;
	sub_82CA93D0(ctx, base);
	// 821B7978: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B797C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821B7980: FB8100B0  std r28, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[28].u64 ) };
	// 821B7984: F88100B8  std r4, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[4].u64 ) };
	// 821B7988: 83A100B4  lwz r29, 0xb4(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 821B798C: 836100BC  lwz r27, 0xbc(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 821B7990: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 821B7994: 419A00D0  beq cr6, 0x821b7a64
	if ctx.cr[6].eq {
	pc = 0x821B7A64; continue 'dispatch;
	}
	// 821B7998: 3BFD0008  addi r31, r29, 8
	ctx.r[31].s64 = ctx.r[29].s64 + 8;
	// 821B799C: FB810060  std r28, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u64 ) };
	// 821B79A0: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 821B79A4: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 821B79A8: 419A00BC  beq cr6, 0x821b7a64
	if ctx.cr[6].eq {
	pc = 0x821B7A64; continue 'dispatch;
	}
	pc = 0x821B79AC; continue 'dispatch;
            }
            0x821B79AC => {
    //   block [0x821B79AC..0x821B79D4)
	// 821B79AC: EBDF0000  ld r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 821B79B0: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821B79B4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B79B8: FBC10058  std r30, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u64 ) };
	// 821B79BC: F8A10050  std r5, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u64 ) };
	// 821B79C0: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821B79C4: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B79C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B79CC: 41980008  blt cr6, 0x821b79d4
	if ctx.cr[6].lt {
	pc = 0x821B79D4; continue 'dispatch;
	}
	// 821B79D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821B79D4; continue 'dispatch;
            }
            0x821B79D4 => {
    //   block [0x821B79D4..0x821B7A00)
	// 821B79D4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B79D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B79DC: 419A0024  beq cr6, 0x821b7a00
	if ctx.cr[6].eq {
	pc = 0x821B7A00; continue 'dispatch;
	}
	// 821B79E0: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 821B79E4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821B79E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821B79EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821B79F0: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B79F4: 488F186D  bl 0x82aa9260
	ctx.lr = 0x821B79F8;
	sub_82AA9260(ctx, base);
	// 821B79F8: FBDD0000  std r30, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 821B79FC: 48000058  b 0x821b7a54
	pc = 0x821B7A54; continue 'dispatch;
            }
            0x821B7A00 => {
    //   block [0x821B7A00..0x821B7A08)
	// 821B7A00: F8A10058  std r5, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u64 ) };
	// 821B7A04: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	pc = 0x821B7A08; continue 'dispatch;
            }
            0x821B7A08 => {
    //   block [0x821B7A08..0x821B7A24)
	// 821B7A08: 394AFFF8  addi r10, r10, -8
	ctx.r[10].s64 = ctx.r[10].s64 + -8;
	// 821B7A0C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821B7A10: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7A14: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B7A18: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B7A1C: 41980008  blt cr6, 0x821b7a24
	if ctx.cr[6].lt {
	pc = 0x821B7A24; continue 'dispatch;
	}
	// 821B7A20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821B7A24; continue 'dispatch;
            }
            0x821B7A24 => {
    //   block [0x821B7A24..0x821B7A50)
	// 821B7A24: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B7A28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B7A2C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B7A30: 419A0020  beq cr6, 0x821b7a50
	if ctx.cr[6].eq {
	pc = 0x821B7A50; continue 'dispatch;
	}
	// 821B7A34: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7A38: E8E10058  ld r7, 0x58(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821B7A3C: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821B7A40: 80CA0004  lwz r6, 4(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7A44: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 821B7A48: 90CB0004  stw r6, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 821B7A4C: 4BFFFFBC  b 0x821b7a08
	pc = 0x821B7A08; continue 'dispatch;
            }
            0x821B7A50 => {
    //   block [0x821B7A50..0x821B7A54)
	// 821B7A50: FBCB0000  std r30, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	pc = 0x821B7A54; continue 'dispatch;
            }
            0x821B7A54 => {
    //   block [0x821B7A54..0x821B7A64)
	// 821B7A54: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 821B7A58: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 821B7A5C: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 821B7A60: 409AFF4C  bne cr6, 0x821b79ac
	if !ctx.cr[6].eq {
	pc = 0x821B79AC; continue 'dispatch;
	}
	pc = 0x821B7A64; continue 'dispatch;
            }
            0x821B7A64 => {
    //   block [0x821B7A64..0x821B7A6C)
	// 821B7A64: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821B7A68: 48AF19EC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7A70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B7A70 size=164
    let mut pc: u32 = 0x821B7A70;
    'dispatch: loop {
        match pc {
            0x821B7A70 => {
    //   block [0x821B7A70..0x821B7A90)
	// 821B7A70: 548B083C  slwi r11, r4, 1
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B7A74: 7D645A14  add r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 821B7A78: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B7A7C: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 821B7A80: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 821B7A84: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B7A88: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 821B7A8C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821B7A90; continue 'dispatch;
            }
            0x821B7A90 => {
    //   block [0x821B7A90..0x821B7A9C)
	// 821B7A90: 7F094840  cmplw cr6, r9, r9
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B7A94: 419A0008  beq cr6, 0x821b7a9c
	if ctx.cr[6].eq {
	pc = 0x821B7A9C; continue 'dispatch;
	}
	// 821B7A98: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821B7A9C; continue 'dispatch;
            }
            0x821B7A9C => {
    //   block [0x821B7A9C..0x821B7AB4)
	// 821B7A9C: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821B7AA0: 419A006C  beq cr6, 0x821b7b0c
	if ctx.cr[6].eq {
	pc = 0x821B7B0C; continue 'dispatch;
	}
	// 821B7AA4: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7AA8: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B7AAC: 409A0008  bne cr6, 0x821b7ab4
	if !ctx.cr[6].eq {
	pc = 0x821B7AB4; continue 'dispatch;
	}
	// 821B7AB0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821B7AB4; continue 'dispatch;
            }
            0x821B7AB4 => {
    //   block [0x821B7AB4..0x821B7AE8)
	// 821B7AB4: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B7AB8: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 821B7ABC: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 821B7AC0: 4099004C  ble cr6, 0x821b7b0c
	if !ctx.cr[6].gt {
	pc = 0x821B7B0C; continue 'dispatch;
	}
	// 821B7AC4: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7AC8: 80830024  lwz r4, 0x24(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B7ACC: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B7AD0: 409A0018  bne cr6, 0x821b7ae8
	if !ctx.cr[6].eq {
	pc = 0x821B7AE8; continue 'dispatch;
	}
	// 821B7AD4: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 821B7AD8: 80850004  lwz r4, 4(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7ADC: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821B7AE0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B7AE4: 419A0008  beq cr6, 0x821b7aec
	if ctx.cr[6].eq {
	pc = 0x821B7AEC; continue 'dispatch;
	}
	pc = 0x821B7AE8; continue 'dispatch;
            }
            0x821B7AE8 => {
    //   block [0x821B7AE8..0x821B7AEC)
	// 821B7AE8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821B7AEC; continue 'dispatch;
            }
            0x821B7AEC => {
    //   block [0x821B7AEC..0x821B7B04)
	// 821B7AEC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821B7AF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B7AF4: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 821B7AF8: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821B7AFC: 409A0008  bne cr6, 0x821b7b04
	if !ctx.cr[6].eq {
	pc = 0x821B7B04; continue 'dispatch;
	}
	// 821B7B00: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821B7B04; continue 'dispatch;
            }
            0x821B7B04 => {
    //   block [0x821B7B04..0x821B7B0C)
	// 821B7B04: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7B08: 4BFFFF88  b 0x821b7a90
	pc = 0x821B7A90; continue 'dispatch;
            }
            0x821B7B0C => {
    //   block [0x821B7B0C..0x821B7B14)
	// 821B7B0C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B7B10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B7B18 size=132
    let mut pc: u32 = 0x821B7B18;
    'dispatch: loop {
        match pc {
            0x821B7B18 => {
    //   block [0x821B7B18..0x821B7B38)
	// 821B7B18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B7B1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B7B20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B7B24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B7B28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B7B2C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7B30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B7B34: 419A0048  beq cr6, 0x821b7b7c
	if ctx.cr[6].eq {
	pc = 0x821B7B7C; continue 'dispatch;
	}
	pc = 0x821B7B38; continue 'dispatch;
            }
            0x821B7B38 => {
    //   block [0x821B7B38..0x821B7B7C)
	// 821B7B38: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821B7B3C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B7B40: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821B7B44: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821B7B48: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821B7B4C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B7B50: 4082FFE8  bne 0x821b7b38
	if !ctx.cr[0].eq {
	pc = 0x821B7B38; continue 'dispatch;
	}
	// 821B7B54: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821B7B58: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B7B5C: 409A0020  bne cr6, 0x821b7b7c
	if !ctx.cr[6].eq {
	pc = 0x821B7B7C; continue 'dispatch;
	}
	// 821B7B60: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7B64: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B7B68: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7B6C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B7B70: 4E800421  bctrl
	ctx.lr = 0x821B7B74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B7B74: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7B78: 480641C1  bl 0x8221bd38
	ctx.lr = 0x821B7B7C;
	sub_8221BD38(ctx, base);
            }
            0x821B7B7C => {
    //   block [0x821B7B7C..0x821B7B9C)
	// 821B7B7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B7B80: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B7B84: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821B7B88: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B7B8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B7B90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B7B94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B7B98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B7BA0 size=492
    let mut pc: u32 = 0x821B7BA0;
    'dispatch: loop {
        match pc {
            0x821B7BA0 => {
    //   block [0x821B7BA0..0x821B7C38)
	// 821B7BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B7BA4: 48AF1859  bl 0x82ca93fc
	ctx.lr = 0x821B7BA8;
	sub_82CA93D0(ctx, base);
	// 821B7BA8: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 821B7BAC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B7BB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B7BB4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B7BB8: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 821B7BBC: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 821B7BC0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821B7BC4: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 821B7BC8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821B7BCC: C00B9484  lfs f0, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B7BD0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821B7BD4: 390A303C  addi r8, r10, 0x303c
	ctx.r[8].s64 = ctx.r[10].s64 + 12348;
	// 821B7BD8: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821B7BDC: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 821B7BE0: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821B7BE4: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821B7BE8: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821B7BEC: 90BF0008  stw r5, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 821B7BF0: 3B9F0028  addi r28, r31, 0x28
	ctx.r[28].s64 = ctx.r[31].s64 + 40;
	// 821B7BF4: 90DF000C  stw r6, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 821B7BF8: 3B7F0030  addi r27, r31, 0x30
	ctx.r[27].s64 = ctx.r[31].s64 + 48;
	// 821B7BFC: 90FF0010  stw r7, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 821B7C00: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 821B7C04: 909F0020  stw r4, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 821B7C08: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 821B7C0C: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 821B7C10: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 821B7C14: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 821B7C18: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 821B7C1C: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B7C20: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7C24: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B7C28: 419A0078  beq cr6, 0x821b7ca0
	if ctx.cr[6].eq {
	pc = 0x821B7CA0; continue 'dispatch;
	}
	// 821B7C2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B7C30: 419A0040  beq cr6, 0x821b7c70
	if ctx.cr[6].eq {
	pc = 0x821B7C70; continue 'dispatch;
	}
	// 821B7C34: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x821B7C38; continue 'dispatch;
            }
            0x821B7C38 => {
    //   block [0x821B7C38..0x821B7C6C)
	// 821B7C38: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821B7C3C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B7C40: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821B7C44: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B7C48: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821B7C4C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B7C50: 4082FFE8  bne 0x821b7c38
	if !ctx.cr[0].eq {
	pc = 0x821B7C38; continue 'dispatch;
	}
	// 821B7C54: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B7C58: 409A0014  bne cr6, 0x821b7c6c
	if !ctx.cr[6].eq {
	pc = 0x821B7C6C; continue 'dispatch;
	}
	// 821B7C5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7C60: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B7C64: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B7C68: 4E800421  bctrl
	ctx.lr = 0x821B7C6C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821B7C6C => {
    //   block [0x821B7C6C..0x821B7C70)
	// 821B7C6C: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	pc = 0x821B7C70; continue 'dispatch;
            }
            0x821B7C70 => {
    //   block [0x821B7C70..0x821B7C84)
	// 821B7C70: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B7C74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B7C78: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 821B7C7C: 419A0024  beq cr6, 0x821b7ca0
	if ctx.cr[6].eq {
	pc = 0x821B7CA0; continue 'dispatch;
	}
	// 821B7C80: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x821B7C84; continue 'dispatch;
            }
            0x821B7C84 => {
    //   block [0x821B7C84..0x821B7CA0)
	// 821B7C84: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821B7C88: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B7C8C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821B7C90: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821B7C94: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821B7C98: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B7C9C: 4082FFE8  bne 0x821b7c84
	if !ctx.cr[0].eq {
	pc = 0x821B7C84; continue 'dispatch;
	}
	pc = 0x821B7CA0; continue 'dispatch;
            }
            0x821B7CA0 => {
    //   block [0x821B7CA0..0x821B7CE4)
	// 821B7CA0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B7CA4: 3FA0820A  lis r29, -0x7df6
	ctx.r[29].s64 = -2113273856;
	// 821B7CA8: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 821B7CAC: C3EB6B9C  lfs f31, 0x6b9c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27548 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B7CB0: 409A0058  bne cr6, 0x821b7d08
	if !ctx.cr[6].eq {
	pc = 0x821B7D08; continue 'dispatch;
	}
	// 821B7CB4: C01D9A80  lfs f0, -0x6580(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B7CB8: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821B7CBC: 40980028  bge cr6, 0x821b7ce4
	if !ctx.cr[6].lt {
	pc = 0x821B7CE4; continue 'dispatch;
	}
	// 821B7CC0: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 821B7CC4: 48067595  bl 0x8221f258
	ctx.lr = 0x821B7CC8;
	sub_8221F258(ctx, base);
	// 821B7CC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B7CCC: 419A0038  beq cr6, 0x821b7d04
	if ctx.cr[6].eq {
	pc = 0x821B7D04; continue 'dispatch;
	}
	// 821B7CD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821B7CD4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821B7CD8: 394B18C0  addi r10, r11, 0x18c0
	ctx.r[10].s64 = ctx.r[11].s64 + 6336;
	// 821B7CDC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B7CE0: 48000028  b 0x821b7d08
	pc = 0x821B7D08; continue 'dispatch;
            }
            0x821B7CE4 => {
    //   block [0x821B7CE4..0x821B7D04)
	// 821B7CE4: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 821B7CE8: 48067571  bl 0x8221f258
	ctx.lr = 0x821B7CEC;
	sub_8221F258(ctx, base);
	// 821B7CEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B7CF0: 419A0014  beq cr6, 0x821b7d04
	if ctx.cr[6].eq {
	pc = 0x821B7D04; continue 'dispatch;
	}
	// 821B7CF4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821B7CF8: 480D3E49  bl 0x8228bb40
	ctx.lr = 0x821B7CFC;
	sub_8228BB40(ctx, base);
	// 821B7CFC: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821B7D00: 48000008  b 0x821b7d08
	pc = 0x821B7D08; continue 'dispatch;
            }
            0x821B7D04 => {
    //   block [0x821B7D04..0x821B7D08)
	// 821B7D04: 7FDAF378  mr r26, r30
	ctx.r[26].u64 = ctx.r[30].u64;
	pc = 0x821B7D08; continue 'dispatch;
            }
            0x821B7D08 => {
    //   block [0x821B7D08..0x821B7D40)
	// 821B7D08: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 821B7D0C: 409A0058  bne cr6, 0x821b7d64
	if !ctx.cr[6].eq {
	pc = 0x821B7D64; continue 'dispatch;
	}
	// 821B7D10: C01D9A80  lfs f0, -0x6580(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B7D14: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821B7D18: 40980028  bge cr6, 0x821b7d40
	if !ctx.cr[6].lt {
	pc = 0x821B7D40; continue 'dispatch;
	}
	// 821B7D1C: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 821B7D20: 48067539  bl 0x8221f258
	ctx.lr = 0x821B7D24;
	sub_8221F258(ctx, base);
	// 821B7D24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B7D28: 419A0038  beq cr6, 0x821b7d60
	if ctx.cr[6].eq {
	pc = 0x821B7D60; continue 'dispatch;
	}
	// 821B7D2C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821B7D30: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821B7D34: 394B1770  addi r10, r11, 0x1770
	ctx.r[10].s64 = ctx.r[11].s64 + 6000;
	// 821B7D38: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B7D3C: 48000028  b 0x821b7d64
	pc = 0x821B7D64; continue 'dispatch;
            }
            0x821B7D40 => {
    //   block [0x821B7D40..0x821B7D60)
	// 821B7D40: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 821B7D44: 48067515  bl 0x8221f258
	ctx.lr = 0x821B7D48;
	sub_8221F258(ctx, base);
	// 821B7D48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B7D4C: 419A0014  beq cr6, 0x821b7d60
	if ctx.cr[6].eq {
	pc = 0x821B7D60; continue 'dispatch;
	}
	// 821B7D50: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821B7D54: 480719E5  bl 0x82229738
	ctx.lr = 0x821B7D58;
	sub_82229738(ctx, base);
	// 821B7D58: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821B7D5C: 48000008  b 0x821b7d64
	pc = 0x821B7D64; continue 'dispatch;
            }
            0x821B7D60 => {
    //   block [0x821B7D60..0x821B7D64)
	// 821B7D60: 7FD9F378  mr r25, r30
	ctx.r[25].u64 = ctx.r[30].u64;
	pc = 0x821B7D64; continue 'dispatch;
            }
            0x821B7D64 => {
    //   block [0x821B7D64..0x821B7D8C)
	// 821B7D64: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821B7D68: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B7D6C: 483ADEFD  bl 0x82565c68
	ctx.lr = 0x821B7D70;
	sub_82565C68(ctx, base);
	// 821B7D70: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821B7D74: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B7D78: 483ADEF1  bl 0x82565c68
	ctx.lr = 0x821B7D7C;
	sub_82565C68(ctx, base);
	// 821B7D7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B7D80: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821B7D84: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 821B7D88: 48AF16C4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B7D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B7D90 size=2088
    let mut pc: u32 = 0x821B7D90;
    'dispatch: loop {
        match pc {
            0x821B7D90 => {
    //   block [0x821B7D90..0x821B85B8)
	// 821B7D90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B7D94: 48AF1661  bl 0x82ca93f4
	ctx.lr = 0x821B7D98;
	sub_82CA93D0(ctx, base);
	// 821B7D98: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 821B7D9C: 48AF5F35  bl 0x82cadcd0
	ctx.lr = 0x821B7DA0;
	sub_82CADCA0(ctx, base);
	// 821B7DA0: 3980FF70  li r12, -0x90
	ctx.r[12].s64 = -144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B85E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B85E0 size=128
    let mut pc: u32 = 0x821B85E0;
    'dispatch: loop {
        match pc {
            0x821B85E0 => {
    //   block [0x821B85E0..0x821B8614)
	// 821B85E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B85E4: 48AF0E25  bl 0x82ca9408
	ctx.lr = 0x821B85E8;
	sub_82CA93D0(ctx, base);
	// 821B85E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B85EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B85F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821B85F4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821B85F8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 821B85FC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B8600: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8604: 409A0010  bne cr6, 0x821b8614
	if !ctx.cr[6].eq {
	pc = 0x821B8614; continue 'dispatch;
	}
	// 821B8608: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 821B860C: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 821B8610: 48000008  b 0x821b8618
	pc = 0x821B8618; continue 'dispatch;
            }
            0x821B8614 => {
    //   block [0x821B8614..0x821B8618)
	// 821B8614: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821B8618; continue 'dispatch;
            }
            0x821B8618 => {
    //   block [0x821B8618..0x821B8644)
	// 821B8618: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B861C: 480F13CD  bl 0x822a99e8
	ctx.lr = 0x821B8620;
	sub_822A99E8(ctx, base);
	// 821B8620: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821B8624: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821B8628: 419A001C  beq cr6, 0x821b8644
	if ctx.cr[6].eq {
	pc = 0x821B8644; continue 'dispatch;
	}
	// 821B862C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821B8630: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821B8634: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B8638: 48029831  bl 0x821e1e68
	ctx.lr = 0x821B863C;
	sub_821E1E68(ctx, base);
	// 821B863C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B8640: 409A0018  bne cr6, 0x821b8658
	if !ctx.cr[6].eq {
	pc = 0x821B8658; continue 'dispatch;
	}
	pc = 0x821B8644; continue 'dispatch;
            }
            0x821B8644 => {
    //   block [0x821B8644..0x821B8658)
	// 821B8644: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821B8648: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821B864C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821B8650: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B8654: 48029815  bl 0x821e1e68
	ctx.lr = 0x821B8658;
	sub_821E1E68(ctx, base);
	pc = 0x821B8658; continue 'dispatch;
            }
            0x821B8658 => {
    //   block [0x821B8658..0x821B8660)
	// 821B8658: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821B865C: 48AF0DFC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B8660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B8660 size=568
    let mut pc: u32 = 0x821B8660;
    'dispatch: loop {
        match pc {
            0x821B8660 => {
    //   block [0x821B8660..0x821B8898)
	// 821B8660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B8664: 48AF0DA5  bl 0x82ca9408
	ctx.lr = 0x821B8668;
	sub_82CA93D0(ctx, base);
	// 821B8668: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821B866C: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B8898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B8898 size=100
    let mut pc: u32 = 0x821B8898;
    'dispatch: loop {
        match pc {
            0x821B8898 => {
    //   block [0x821B8898..0x821B88E4)
	// 821B8898: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B889C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B88A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B88A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B88A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B88AC: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B88B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B88B4: 419A0030  beq cr6, 0x821b88e4
	if ctx.cr[6].eq {
	pc = 0x821B88E4; continue 'dispatch;
	}
	// 821B88B8: 4800F561  bl 0x821c7e18
	ctx.lr = 0x821B88BC;
	sub_821C7E18(ctx, base);
	// 821B88BC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B88C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B88C4: 419A0020  beq cr6, 0x821b88e4
	if ctx.cr[6].eq {
	pc = 0x821B88E4; continue 'dispatch;
	}
	// 821B88C8: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B88CC: 4800F395  bl 0x821c7c60
	ctx.lr = 0x821B88D0;
	sub_821C7C60(ctx, base);
	// 821B88D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B88D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B88D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B88DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B88E0: 4E800020  blr
	return;
            }
            0x821B88E4 => {
    //   block [0x821B88E4..0x821B88FC)
	// 821B88E4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B88E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B88EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B88F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B88F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B88F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B8900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B8900 size=1560
    let mut pc: u32 = 0x821B8900;
    'dispatch: loop {
        match pc {
            0x821B8900 => {
    //   block [0x821B8900..0x821B894C)
	// 821B8900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B8904: 48AF0AF9  bl 0x82ca93fc
	ctx.lr = 0x821B8908;
	sub_82CA93D0(ctx, base);
	// 821B8908: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 821B890C: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B8910: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821B8914: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821B8918: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 821B891C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821B8920: 4802AE19  bl 0x821e3738
	ctx.lr = 0x821B8924;
	sub_821E3738(ctx, base);
	// 821B8924: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B8928: 387B0004  addi r3, r27, 4
	ctx.r[3].s64 = ctx.r[27].s64 + 4;
	// 821B892C: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 821B8930: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8934: 419A001C  beq cr6, 0x821b8950
	if ctx.cr[6].eq {
	pc = 0x821B8950; continue 'dispatch;
	}
	// 821B8938: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B893C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B8940: 419A000C  beq cr6, 0x821b894c
	if ctx.cr[6].eq {
	pc = 0x821B894C; continue 'dispatch;
	}
	// 821B8944: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B8948: 4800000C  b 0x821b8954
	pc = 0x821B8954; continue 'dispatch;
            }
            0x821B894C => {
    //   block [0x821B894C..0x821B8950)
	// 821B894C: 4BFDB4ED  bl 0x82193e38
	ctx.lr = 0x821B8950;
	sub_82193E38(ctx, base);
	pc = 0x821B8950; continue 'dispatch;
            }
            0x821B8950 => {
    //   block [0x821B8950..0x821B8954)
	// 821B8950: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821B8954; continue 'dispatch;
            }
            0x821B8954 => {
    //   block [0x821B8954..0x821B8994)
	// 821B8954: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B8958: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 821B895C: 55492FFE  rlwinm r9, r10, 5, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x07FFFFFFu64;
	// 821B8960: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B8964: 419A00F4  beq cr6, 0x821b8a58
	if ctx.cr[6].eq {
	pc = 0x821B8A58; continue 'dispatch;
	}
	// 821B8968: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B896C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B8970: 419A0024  beq cr6, 0x821b8994
	if ctx.cr[6].eq {
	pc = 0x821B8994; continue 'dispatch;
	}
	// 821B8974: 894A005B  lbz r10, 0x5b(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(91 as u32) ) } as u64;
	// 821B8978: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B897C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821B8980: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B8984: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B8988: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B898C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821B8990: 480000CC  b 0x821b8a5c
	pc = 0x821B8A5C; continue 'dispatch;
            }
            0x821B8994 => {
    //   block [0x821B8994..0x821B89B0)
	// 821B8994: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B8998: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821B899C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821B89A0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821B89A4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B89A8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B89AC: 40810054  ble 0x821b8a00
	if !ctx.cr[0].gt {
	pc = 0x821B8A00; continue 'dispatch;
	}
	pc = 0x821B89B0; continue 'dispatch;
            }
            0x821B89B0 => {
    //   block [0x821B89B0..0x821B89D0)
	// 821B89B0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B89B4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B89B8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821B89BC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B89C0: 2F07005B  cmpwi cr6, r7, 0x5b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 91, &mut ctx.xer);
	// 821B89C4: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 821B89C8: 41980008  blt cr6, 0x821b89d0
	if ctx.cr[6].lt {
	pc = 0x821B89D0; continue 'dispatch;
	}
	// 821B89CC: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x821B89D0; continue 'dispatch;
            }
            0x821B89D0 => {
    //   block [0x821B89D0..0x821B89EC)
	// 821B89D0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821B89D4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B89D8: 419A0014  beq cr6, 0x821b89ec
	if ctx.cr[6].eq {
	pc = 0x821B89EC; continue 'dispatch;
	}
	// 821B89DC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821B89E0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B89E4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B89E8: 4800000C  b 0x821b89f4
	pc = 0x821B89F4; continue 'dispatch;
            }
            0x821B89EC => {
    //   block [0x821B89EC..0x821B89F4)
	// 821B89EC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821B89F0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821B89F4; continue 'dispatch;
            }
            0x821B89F4 => {
    //   block [0x821B89F4..0x821B8A00)
	// 821B89F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B89F8: 4199FFB8  bgt cr6, 0x821b89b0
	if ctx.cr[6].gt {
	pc = 0x821B89B0; continue 'dispatch;
	}
	// 821B89FC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821B8A00; continue 'dispatch;
            }
            0x821B8A00 => {
    //   block [0x821B8A00..0x821B8A1C)
	// 821B8A00: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B8A04: 419A0040  beq cr6, 0x821b8a44
	if ctx.cr[6].eq {
	pc = 0x821B8A44; continue 'dispatch;
	}
	// 821B8A08: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8A0C: 2F0B005B  cmpwi cr6, r11, 0x5b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 91, &mut ctx.xer);
	// 821B8A10: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821B8A14: 41990008  bgt cr6, 0x821b8a1c
	if ctx.cr[6].gt {
	pc = 0x821B8A1C; continue 'dispatch;
	}
	// 821B8A18: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821B8A1C; continue 'dispatch;
            }
            0x821B8A1C => {
    //   block [0x821B8A1C..0x821B8A44)
	// 821B8A1C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B8A20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8A24: 409A0020  bne cr6, 0x821b8a44
	if !ctx.cr[6].eq {
	pc = 0x821B8A44; continue 'dispatch;
	}
	// 821B8A28: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B8A2C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B8A30: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B8A34: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B8A38: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B8A3C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821B8A40: 4800001C  b 0x821b8a5c
	pc = 0x821B8A5C; continue 'dispatch;
            }
            0x821B8A44 => {
    //   block [0x821B8A44..0x821B8A58)
	// 821B8A44: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821B8A48: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B8A4C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B8A50: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821B8A54: 48000008  b 0x821b8a5c
	pc = 0x821B8A5C; continue 'dispatch;
            }
            0x821B8A58 => {
    //   block [0x821B8A58..0x821B8A5C)
	// 821B8A58: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821B8A5C; continue 'dispatch;
            }
            0x821B8A5C => {
    //   block [0x821B8A5C..0x821B8AA0)
	// 821B8A5C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B8A60: 3BA0000C  li r29, 0xc
	ctx.r[29].s64 = 12;
	// 821B8A64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8A68: 419A01C8  beq cr6, 0x821b8c30
	if ctx.cr[6].eq {
	pc = 0x821B8C30; continue 'dispatch;
	}
	// 821B8A6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B8A70: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821B8A74: 4805C085  bl 0x82214af8
	ctx.lr = 0x821B8A78;
	sub_82214AF8(ctx, base);
	// 821B8A78: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821B8A7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8A80: 419A01AC  beq cr6, 0x821b8c2c
	if ctx.cr[6].eq {
	pc = 0x821B8C2C; continue 'dispatch;
	}
	// 821B8A84: 813B0018  lwz r9, 0x18(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B8A88: 80DB001C  lwz r6, 0x1c(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B8A8C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821B8A90: 7D693050  subf r11, r9, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[9].s64;
	// 821B8A94: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821B8A98: 7D6BEBD7  divw. r11, r11, r29
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[29].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B8A9C: 4081005C  ble 0x821b8af8
	if !ctx.cr[0].gt {
	pc = 0x821B8AF8; continue 'dispatch;
	}
	pc = 0x821B8AA0; continue 'dispatch;
            }
            0x821B8AA0 => {
    //   block [0x821B8AA0..0x821B8AC8)
	// 821B8AA0: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B8AA4: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B8AA8: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821B8AAC: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B8AB0: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821B8AB4: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8AB8: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 821B8ABC: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 821B8AC0: 41980008  blt cr6, 0x821b8ac8
	if ctx.cr[6].lt {
	pc = 0x821B8AC8; continue 'dispatch;
	}
	// 821B8AC4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x821B8AC8; continue 'dispatch;
            }
            0x821B8AC8 => {
    //   block [0x821B8AC8..0x821B8AE4)
	// 821B8AC8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821B8ACC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B8AD0: 419A0014  beq cr6, 0x821b8ae4
	if ctx.cr[6].eq {
	pc = 0x821B8AE4; continue 'dispatch;
	}
	// 821B8AD4: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821B8AD8: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 821B8ADC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B8AE0: 4800000C  b 0x821b8aec
	pc = 0x821B8AEC; continue 'dispatch;
            }
            0x821B8AE4 => {
    //   block [0x821B8AE4..0x821B8AEC)
	// 821B8AE4: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821B8AE8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x821B8AEC; continue 'dispatch;
            }
            0x821B8AEC => {
    //   block [0x821B8AEC..0x821B8AF8)
	// 821B8AEC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B8AF0: 4199FFB0  bgt cr6, 0x821b8aa0
	if ctx.cr[6].gt {
	pc = 0x821B8AA0; continue 'dispatch;
	}
	// 821B8AF4: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	pc = 0x821B8AF8; continue 'dispatch;
            }
            0x821B8AF8 => {
    //   block [0x821B8AF8..0x821B8B14)
	// 821B8AF8: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B8AFC: 419A0034  beq cr6, 0x821b8b30
	if ctx.cr[6].eq {
	pc = 0x821B8B30; continue 'dispatch;
	}
	// 821B8B00: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8B04: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821B8B08: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821B8B0C: 41990008  bgt cr6, 0x821b8b14
	if ctx.cr[6].gt {
	pc = 0x821B8B14; continue 'dispatch;
	}
	// 821B8B10: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821B8B14; continue 'dispatch;
            }
            0x821B8B14 => {
    //   block [0x821B8B14..0x821B8B30)
	// 821B8B14: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B8B18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8B1C: 409A0014  bne cr6, 0x821b8b30
	if !ctx.cr[6].eq {
	pc = 0x821B8B30; continue 'dispatch;
	}
	// 821B8B20: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B8B24: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B8B28: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B8B2C: 48000008  b 0x821b8b34
	pc = 0x821B8B34; continue 'dispatch;
            }
            0x821B8B30 => {
    //   block [0x821B8B30..0x821B8B34)
	// 821B8B30: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x821B8B34; continue 'dispatch;
            }
            0x821B8B34 => {
    //   block [0x821B8B34..0x821B8B4C)
	// 821B8B34: 815B001C  lwz r10, 0x1c(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B8B38: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B8B3C: 419A0010  beq cr6, 0x821b8b4c
	if ctx.cr[6].eq {
	pc = 0x821B8B4C; continue 'dispatch;
	}
	// 821B8B40: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B8B44: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821B8B48: 48000008  b 0x821b8b50
	pc = 0x821B8B50; continue 'dispatch;
            }
            0x821B8B4C => {
    //   block [0x821B8B4C..0x821B8B50)
	// 821B8B4C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821B8B50; continue 'dispatch;
            }
            0x821B8B50 => {
    //   block [0x821B8B50..0x821B8B98)
	// 821B8B50: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B8B54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8B58: 419A00D4  beq cr6, 0x821b8c2c
	if ctx.cr[6].eq {
	pc = 0x821B8C2C; continue 'dispatch;
	}
	// 821B8B5C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B8B60: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 821B8B64: FB8100F8  std r28, 0xf8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[28].u64 ) };
	// 821B8B68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B8B6C: 394B5F1C  addi r10, r11, 0x5f1c
	ctx.r[10].s64 = ctx.r[11].s64 + 24348;
	// 821B8B70: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 821B8B74: 4BFD8B9D  bl 0x82191710
	ctx.lr = 0x821B8B78;
	sub_82191710(ctx, base);
	// 821B8B78: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8B7C: 817B0054  lwz r11, 0x54(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B8B80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8B84: 91210074  stw r9, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 821B8B88: 409A0010  bne cr6, 0x821b8b98
	if !ctx.cr[6].eq {
	pc = 0x821B8B98; continue 'dispatch;
	}
	// 821B8B8C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 821B8B90: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 821B8B94: 48000008  b 0x821b8b9c
	pc = 0x821B8B9C; continue 'dispatch;
            }
            0x821B8B98 => {
    //   block [0x821B8B98..0x821B8B9C)
	// 821B8B98: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821B8B9C; continue 'dispatch;
            }
            0x821B8B9C => {
    //   block [0x821B8B9C..0x821B8BCC)
	// 821B8B9C: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 821B8BA0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 821B8BA4: 48114505  bl 0x822cd0a8
	ctx.lr = 0x821B8BA8;
	sub_822CD0A8(ctx, base);
	// 821B8BA8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B8BAC: 480E62CD  bl 0x8229ee78
	ctx.lr = 0x821B8BB0;
	sub_8229EE78(ctx, base);
	// 821B8BB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B8BB4: 419A0018  beq cr6, 0x821b8bcc
	if ctx.cr[6].eq {
	pc = 0x821B8BCC; continue 'dispatch;
	}
	// 821B8BB8: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 821B8BBC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B8BC0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821B8BC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B8BC8: 409A0008  bne cr6, 0x821b8bd0
	if !ctx.cr[6].eq {
	pc = 0x821B8BD0; continue 'dispatch;
	}
	pc = 0x821B8BCC; continue 'dispatch;
            }
            0x821B8BCC => {
    //   block [0x821B8BCC..0x821B8BD0)
	// 821B8BCC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821B8BD0; continue 'dispatch;
            }
            0x821B8BD0 => {
    //   block [0x821B8BD0..0x821B8BF0)
	// 821B8BD0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B8BD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8BD8: 419A0018  beq cr6, 0x821b8bf0
	if ctx.cr[6].eq {
	pc = 0x821B8BF0; continue 'dispatch;
	}
	// 821B8BDC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B8BE0: 480E6299  bl 0x8229ee78
	ctx.lr = 0x821B8BE4;
	sub_8229EE78(ctx, base);
	// 821B8BE4: 4BFF97AD  bl 0x821b2390
	ctx.lr = 0x821B8BE8;
	sub_821B2390(ctx, base);
	// 821B8BE8: F86100F8  std r3, 0xf8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[3].u64 ) };
	// 821B8BEC: 48000008  b 0x821b8bf4
	pc = 0x821B8BF4; continue 'dispatch;
            }
            0x821B8BF0 => {
    //   block [0x821B8BF0..0x821B8BF4)
	// 821B8BF0: FB8100F8  std r28, 0xf8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[28].u64 ) };
	pc = 0x821B8BF4; continue 'dispatch;
            }
            0x821B8BF4 => {
    //   block [0x821B8BF4..0x821B8C2C)
	// 821B8BF4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B8BF8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B8BFC: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B8C00: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B8C04: 832A008C  lwz r25, 0x8c(r10)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B8C08: 4BFBB861  bl 0x82174468
	ctx.lr = 0x821B8C0C;
	sub_82174468(ctx, base);
	// 821B8C0C: 4BFF9785  bl 0x821b2390
	ctx.lr = 0x821B8C10;
	sub_821B2390(ctx, base);
	// 821B8C10: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821B8C14: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821B8C18: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 821B8C1C: 4811D9BD  bl 0x822d65d8
	ctx.lr = 0x821B8C20;
	sub_822D65D8(ctx, base);
	// 821B8C20: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821B8C24: 39092DC8  addi r8, r9, 0x2dc8
	ctx.r[8].s64 = ctx.r[9].s64 + 11720;
	// 821B8C28: 91010070  stw r8, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u32 ) };
	pc = 0x821B8C2C; continue 'dispatch;
            }
            0x821B8C2C => {
    //   block [0x821B8C2C..0x821B8C30)
	// 821B8C2C: 9B9F006C  stb r28, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[28].u8 ) };
	pc = 0x821B8C30; continue 'dispatch;
            }
            0x821B8C30 => {
    //   block [0x821B8C30..0x821B8C50)
	// 821B8C30: 386000B0  li r3, 0xb0
	ctx.r[3].s64 = 176;
	// 821B8C34: 48066625  bl 0x8221f258
	ctx.lr = 0x821B8C38;
	sub_8221F258(ctx, base);
	// 821B8C38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B8C3C: 419A0014  beq cr6, 0x821b8c50
	if ctx.cr[6].eq {
	pc = 0x821B8C50; continue 'dispatch;
	}
	// 821B8C40: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821B8C44: 4BFD51CD  bl 0x8218de10
	ctx.lr = 0x821B8C48;
	sub_8218DE10(ctx, base);
	// 821B8C48: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B8C4C: 48000008  b 0x821b8c54
	pc = 0x821B8C54; continue 'dispatch;
            }
            0x821B8C50 => {
    //   block [0x821B8C50..0x821B8C54)
	// 821B8C50: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	pc = 0x821B8C54; continue 'dispatch;
            }
            0x821B8C54 => {
    //   block [0x821B8C54..0x821B8C64)
	// 821B8C54: 897B0081  lbz r11, 0x81(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(129 as u32) ) } as u64;
	// 821B8C58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8C5C: 419A0008  beq cr6, 0x821b8c64
	if ctx.cr[6].eq {
	pc = 0x821B8C64; continue 'dispatch;
	}
	// 821B8C60: 9B440031  stb r26, 0x31(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(49 as u32), ctx.r[26].u8 ) };
	pc = 0x821B8C64; continue 'dispatch;
            }
            0x821B8C64 => {
    //   block [0x821B8C64..0x821B8C74)
	// 821B8C64: 897B0083  lbz r11, 0x83(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(131 as u32) ) } as u64;
	// 821B8C68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8C6C: 419A0008  beq cr6, 0x821b8c74
	if ctx.cr[6].eq {
	pc = 0x821B8C74; continue 'dispatch;
	}
	// 821B8C70: 9B440032  stb r26, 0x32(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(50 as u32), ctx.r[26].u8 ) };
	pc = 0x821B8C74; continue 'dispatch;
            }
            0x821B8C74 => {
    //   block [0x821B8C74..0x821B8C84)
	// 821B8C74: 897B0082  lbz r11, 0x82(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(130 as u32) ) } as u64;
	// 821B8C78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8C7C: 419A0008  beq cr6, 0x821b8c84
	if ctx.cr[6].eq {
	pc = 0x821B8C84; continue 'dispatch;
	}
	// 821B8C80: 9B440033  stb r26, 0x33(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(51 as u32), ctx.r[26].u8 ) };
	pc = 0x821B8C84; continue 'dispatch;
            }
            0x821B8C84 => {
    //   block [0x821B8C84..0x821B8C94)
	// 821B8C84: 897B0085  lbz r11, 0x85(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(133 as u32) ) } as u64;
	// 821B8C88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8C8C: 419A0008  beq cr6, 0x821b8c94
	if ctx.cr[6].eq {
	pc = 0x821B8C94; continue 'dispatch;
	}
	// 821B8C90: 9B44006E  stb r26, 0x6e(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(110 as u32), ctx.r[26].u8 ) };
	pc = 0x821B8C94; continue 'dispatch;
            }
            0x821B8C94 => {
    //   block [0x821B8C94..0x821B8D04)
	// 821B8C94: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821B8C98: 48002E19  bl 0x821bbab0
	ctx.lr = 0x821B8C9C;
	sub_821BBAB0(ctx, base);
	// 821B8C9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B8CA0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B8CA4: 480B31C5  bl 0x8226be68
	ctx.lr = 0x821B8CA8;
	sub_8226BE68(ctx, base);
	// 821B8CA8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821B8CAC: 4BFFEE6D  bl 0x821b7b18
	ctx.lr = 0x821B8CB0;
	sub_821B7B18(ctx, base);
	// 821B8CB0: 897B0084  lbz r11, 0x84(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(132 as u32) ) } as u64;
	// 821B8CB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8CB8: 419A0080  beq cr6, 0x821b8d38
	if ctx.cr[6].eq {
	pc = 0x821B8D38; continue 'dispatch;
	}
	// 821B8CBC: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 821B8CC0: 48066599  bl 0x8221f258
	ctx.lr = 0x821B8CC4;
	sub_8221F258(ctx, base);
	// 821B8CC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B8CC8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821B8CCC: 419A0038  beq cr6, 0x821b8d04
	if ctx.cr[6].eq {
	pc = 0x821B8D04; continue 'dispatch;
	}
	// 821B8CD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821B8CD4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821B8CD8: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 821B8CDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B8CE0: 480741F1  bl 0x8222ced0
	ctx.lr = 0x821B8CE4;
	sub_8222CED0(ctx, base);
	// 821B8CE4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821B8CE8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B8CEC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821B8CF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B8CF4: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 821B8CF8: 48811B89  bl 0x829ca880
	ctx.lr = 0x821B8CFC;
	sub_829CA880(ctx, base);
	// 821B8CFC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B8D00: 48000008  b 0x821b8d08
	pc = 0x821B8D08; continue 'dispatch;
            }
            0x821B8D04 => {
    //   block [0x821B8D04..0x821B8D08)
	// 821B8D04: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	pc = 0x821B8D08; continue 'dispatch;
            }
            0x821B8D08 => {
    //   block [0x821B8D08..0x821B8D38)
	// 821B8D08: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821B8D0C: 48002DA5  bl 0x821bbab0
	ctx.lr = 0x821B8D10;
	sub_821BBAB0(ctx, base);
	// 821B8D10: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B8D14: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B8D18: 480B3151  bl 0x8226be68
	ctx.lr = 0x821B8D1C;
	sub_8226BE68(ctx, base);
	// 821B8D1C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821B8D20: 4BFFEDF9  bl 0x821b7b18
	ctx.lr = 0x821B8D24;
	sub_821B7B18(ctx, base);
	// 821B8D24: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 821B8D28: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B8D2C: 419A000C  beq cr6, 0x821b8d38
	if ctx.cr[6].eq {
	pc = 0x821B8D38; continue 'dispatch;
	}
	// 821B8D30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B8D34: 4805C0A5  bl 0x82214dd8
	ctx.lr = 0x821B8D38;
	sub_82214DD8(ctx, base);
	pc = 0x821B8D38; continue 'dispatch;
            }
            0x821B8D38 => {
    //   block [0x821B8D38..0x821B8D68)
	// 821B8D38: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 821B8D3C: 4806651D  bl 0x8221f258
	ctx.lr = 0x821B8D40;
	sub_8221F258(ctx, base);
	// 821B8D40: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821B8D44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B8D48: 396B9490  addi r11, r11, -0x6b70
	ctx.r[11].s64 = ctx.r[11].s64 + -27504;
	// 821B8D4C: C3EBFFF4  lfs f31, -0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B8D50: 419A0084  beq cr6, 0x821b8dd4
	if ctx.cr[6].eq {
	pc = 0x821B8DD4; continue 'dispatch;
	}
	// 821B8D54: 895B0080  lbz r10, 0x80(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(128 as u32) ) } as u64;
	// 821B8D58: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B8D5C: 419A000C  beq cr6, 0x821b8d68
	if ctx.cr[6].eq {
	pc = 0x821B8D68; continue 'dispatch;
	}
	// 821B8D60: C1BB0078  lfs f13, 0x78(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B8D64: 48000008  b 0x821b8d6c
	pc = 0x821B8D6C; continue 'dispatch;
            }
            0x821B8D68 => {
    //   block [0x821B8D68..0x821B8D6C)
	// 821B8D68: FDA0F890  fmr f13, f31
	ctx.f[13].f64 = ctx.f[31].f64;
	pc = 0x821B8D6C; continue 'dispatch;
            }
            0x821B8D6C => {
    //   block [0x821B8D6C..0x821B8DD4)
	// 821B8D6C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821B8D70: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B8D74: D3E30008  stfs f31, 8(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821B8D78: 93630004  stw r27, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 821B8D7C: 392A1DEC  addi r9, r10, 0x1dec
	ctx.r[9].s64 = ctx.r[10].s64 + 7660;
	// 821B8D80: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821B8D84: D0030028  stfs f0, 0x28(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 821B8D88: 9B43000C  stb r26, 0xc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[26].u8 ) };
	// 821B8D8C: D3E3002C  stfs f31, 0x2c(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 821B8D90: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821B8D94: D1A30030  stfs f13, 0x30(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 821B8D98: 9B83000D  stb r28, 0xd(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(13 as u32), ctx.r[28].u8 ) };
	// 821B8D9C: D3E30034  stfs f31, 0x34(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821B8DA0: 9B83000E  stb r28, 0xe(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(14 as u32), ctx.r[28].u8 ) };
	// 821B8DA4: D3E30038  stfs f31, 0x38(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 821B8DA8: 9B830020  stb r28, 0x20(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[28].u8 ) };
	// 821B8DAC: D3E3003C  stfs f31, 0x3c(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 821B8DB0: 9B430040  stb r26, 0x40(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[26].u8 ) };
	// 821B8DB4: 9B830041  stb r28, 0x41(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(65 as u32), ctx.r[28].u8 ) };
	// 821B8DB8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B8DBC: 9B830042  stb r28, 0x42(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(66 as u32), ctx.r[28].u8 ) };
	// 821B8DC0: 9B830043  stb r28, 0x43(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(67 as u32), ctx.r[28].u8 ) };
	// 821B8DC4: 93830048  stw r28, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[28].u32 ) };
	// 821B8DC8: 9383004C  stw r28, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[28].u32 ) };
	// 821B8DCC: 9B430054  stb r26, 0x54(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[26].u8 ) };
	// 821B8DD0: 48000008  b 0x821b8dd8
	pc = 0x821B8DD8; continue 'dispatch;
            }
            0x821B8DD4 => {
    //   block [0x821B8DD4..0x821B8DD8)
	// 821B8DD4: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	pc = 0x821B8DD8; continue 'dispatch;
            }
            0x821B8DD8 => {
    //   block [0x821B8DD8..0x821B8E14)
	// 821B8DD8: 817B0088  lwz r11, 0x88(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(136 as u32) ) } as u64;
	// 821B8DDC: 3BFB0088  addi r31, r27, 0x88
	ctx.r[31].s64 = ctx.r[27].s64 + 136;
	// 821B8DE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8DE4: 419A00F8  beq cr6, 0x821b8edc
	if ctx.cr[6].eq {
	pc = 0x821B8EDC; continue 'dispatch;
	}
	// 821B8DE8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B8DEC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B8DF0: 419A00EC  beq cr6, 0x821b8edc
	if ctx.cr[6].eq {
	pc = 0x821B8EDC; continue 'dispatch;
	}
	// 821B8DF4: 813B0018  lwz r9, 0x18(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B8DF8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B8DFC: 80DB001C  lwz r6, 0x1c(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B8E00: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821B8E04: 7D693050  subf r11, r9, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[9].s64;
	// 821B8E08: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821B8E0C: 7D6BEBD7  divw. r11, r11, r29
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[29].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B8E10: 4081005C  ble 0x821b8e6c
	if !ctx.cr[0].gt {
	pc = 0x821B8E6C; continue 'dispatch;
	}
	pc = 0x821B8E14; continue 'dispatch;
            }
            0x821B8E14 => {
    //   block [0x821B8E14..0x821B8E3C)
	// 821B8E14: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B8E18: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B8E1C: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821B8E20: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B8E24: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 821B8E28: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8E2C: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 821B8E30: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 821B8E34: 41980008  blt cr6, 0x821b8e3c
	if ctx.cr[6].lt {
	pc = 0x821B8E3C; continue 'dispatch;
	}
	// 821B8E38: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x821B8E3C; continue 'dispatch;
            }
            0x821B8E3C => {
    //   block [0x821B8E3C..0x821B8E58)
	// 821B8E3C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821B8E40: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B8E44: 419A0014  beq cr6, 0x821b8e58
	if ctx.cr[6].eq {
	pc = 0x821B8E58; continue 'dispatch;
	}
	// 821B8E48: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821B8E4C: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 821B8E50: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B8E54: 4800000C  b 0x821b8e60
	pc = 0x821B8E60; continue 'dispatch;
            }
            0x821B8E58 => {
    //   block [0x821B8E58..0x821B8E60)
	// 821B8E58: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821B8E5C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x821B8E60; continue 'dispatch;
            }
            0x821B8E60 => {
    //   block [0x821B8E60..0x821B8E6C)
	// 821B8E60: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B8E64: 4199FFB0  bgt cr6, 0x821b8e14
	if ctx.cr[6].gt {
	pc = 0x821B8E14; continue 'dispatch;
	}
	// 821B8E68: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	pc = 0x821B8E6C; continue 'dispatch;
            }
            0x821B8E6C => {
    //   block [0x821B8E6C..0x821B8E88)
	// 821B8E6C: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B8E70: 419A0034  beq cr6, 0x821b8ea4
	if ctx.cr[6].eq {
	pc = 0x821B8EA4; continue 'dispatch;
	}
	// 821B8E74: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8E78: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821B8E7C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821B8E80: 41990008  bgt cr6, 0x821b8e88
	if ctx.cr[6].gt {
	pc = 0x821B8E88; continue 'dispatch;
	}
	// 821B8E84: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821B8E88; continue 'dispatch;
            }
            0x821B8E88 => {
    //   block [0x821B8E88..0x821B8EA4)
	// 821B8E88: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B8E8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8E90: 409A0014  bne cr6, 0x821b8ea4
	if !ctx.cr[6].eq {
	pc = 0x821B8EA4; continue 'dispatch;
	}
	// 821B8E94: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B8E98: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B8E9C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B8EA0: 48000008  b 0x821b8ea8
	pc = 0x821B8EA8; continue 'dispatch;
            }
            0x821B8EA4 => {
    //   block [0x821B8EA4..0x821B8EA8)
	// 821B8EA4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x821B8EA8; continue 'dispatch;
            }
            0x821B8EA8 => {
    //   block [0x821B8EA8..0x821B8EB8)
	// 821B8EA8: 815B001C  lwz r10, 0x1c(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B8EAC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B8EB0: 419A0008  beq cr6, 0x821b8eb8
	if ctx.cr[6].eq {
	pc = 0x821B8EB8; continue 'dispatch;
	}
	// 821B8EB4: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x821B8EB8; continue 'dispatch;
            }
            0x821B8EB8 => {
    //   block [0x821B8EB8..0x821B8EDC)
	// 821B8EB8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8EBC: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821B8EC0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B8EC4: 4E800421  bctrl
	ctx.lr = 0x821B8EC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B8EC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B8ECC: 48021F45  bl 0x821dae10
	ctx.lr = 0x821B8ED0;
	sub_821DAE10(ctx, base);
	// 821B8ED0: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 821B8ED4: 40990008  ble cr6, 0x821b8edc
	if !ctx.cr[6].gt {
	pc = 0x821B8EDC; continue 'dispatch;
	}
	// 821B8ED8: D03E0034  stfs f1, 0x34(r30)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), tmp.u32 ) };
            }
            0x821B8EDC => {
    //   block [0x821B8EDC..0x821B8EEC)
	// 821B8EDC: C01B007C  lfs f0, 0x7c(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B8EE0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821B8EE4: 40990008  ble cr6, 0x821b8eec
	if !ctx.cr[6].gt {
	pc = 0x821B8EEC; continue 'dispatch;
	}
	// 821B8EE8: D01E0038  stfs f0, 0x38(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), tmp.u32 ) };
	pc = 0x821B8EEC; continue 'dispatch;
            }
            0x821B8EEC => {
    //   block [0x821B8EEC..0x821B8F18)
	// 821B8EEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821B8EF0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821B8EF4: 48002BBD  bl 0x821bbab0
	ctx.lr = 0x821B8EF8;
	sub_821BBAB0(ctx, base);
	// 821B8EF8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B8EFC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B8F00: 480B2F69  bl 0x8226be68
	ctx.lr = 0x821B8F04;
	sub_8226BE68(ctx, base);
	// 821B8F04: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821B8F08: 4BFFEC11  bl 0x821b7b18
	ctx.lr = 0x821B8F0C;
	sub_821B7B18(ctx, base);
	// 821B8F0C: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 821B8F10: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 821B8F14: 48AF0538  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B8F18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B8F18 size=192
    let mut pc: u32 = 0x821B8F18;
    'dispatch: loop {
        match pc {
            0x821B8F18 => {
    //   block [0x821B8F18..0x821B8F54)
	// 821B8F18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B8F1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B8F20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821B8F24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B8F28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B8F2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B8F30: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821B8F34: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821B8F38: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8F3C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B8F40: 419A0080  beq cr6, 0x821b8fc0
	if ctx.cr[6].eq {
	pc = 0x821B8FC0; continue 'dispatch;
	}
	// 821B8F44: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821B8F48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B8F4C: 419A0044  beq cr6, 0x821b8f90
	if ctx.cr[6].eq {
	pc = 0x821B8F90; continue 'dispatch;
	}
	// 821B8F50: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x821B8F54; continue 'dispatch;
            }
            0x821B8F54 => {
    //   block [0x821B8F54..0x821B8F88)
	// 821B8F54: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821B8F58: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B8F5C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821B8F60: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B8F64: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821B8F68: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B8F6C: 4082FFE8  bne 0x821b8f54
	if !ctx.cr[0].eq {
	pc = 0x821B8F54; continue 'dispatch;
	}
	// 821B8F70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B8F74: 409A0014  bne cr6, 0x821b8f88
	if !ctx.cr[6].eq {
	pc = 0x821B8F88; continue 'dispatch;
	}
	// 821B8F78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8F7C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B8F80: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B8F84: 4E800421  bctrl
	ctx.lr = 0x821B8F88;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821B8F88 => {
    //   block [0x821B8F88..0x821B8F90)
	// 821B8F88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B8F8C: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	pc = 0x821B8F90; continue 'dispatch;
            }
            0x821B8F90 => {
    //   block [0x821B8F90..0x821B8FA4)
	// 821B8F90: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B8F94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B8F98: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 821B8F9C: 419A0024  beq cr6, 0x821b8fc0
	if ctx.cr[6].eq {
	pc = 0x821B8FC0; continue 'dispatch;
	}
	// 821B8FA0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x821B8FA4; continue 'dispatch;
            }
            0x821B8FA4 => {
    //   block [0x821B8FA4..0x821B8FC0)
	// 821B8FA4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821B8FA8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B8FAC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821B8FB0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821B8FB4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821B8FB8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821B8FBC: 4082FFE8  bne 0x821b8fa4
	if !ctx.cr[0].eq {
	pc = 0x821B8FA4; continue 'dispatch;
	}
	pc = 0x821B8FC0; continue 'dispatch;
            }
            0x821B8FC0 => {
    //   block [0x821B8FC0..0x821B8FD8)
	// 821B8FC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B8FC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B8FC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B8FCC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821B8FD0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B8FD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B8FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B8FD8 size=636
    let mut pc: u32 = 0x821B8FD8;
    'dispatch: loop {
        match pc {
            0x821B8FD8 => {
    //   block [0x821B8FD8..0x821B9004)
	// 821B8FD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B8FDC: 48AF0425  bl 0x82ca9400
	ctx.lr = 0x821B8FE0;
	sub_82CA93D0(ctx, base);
	// 821B8FE0: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 821B8FE4: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B8FE8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B8FEC: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 821B8FF0: 480ACFA1  bl 0x82265f90
	ctx.lr = 0x821B8FF4;
	sub_82265F90(ctx, base);
	// 821B8FF4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821B8FF8: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 821B8FFC: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821B9000: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x821B9004; continue 'dispatch;
            }
            0x821B9004 => {
    //   block [0x821B9004..0x821B9030)
	// 821B9004: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821B9008: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821B900C: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821B9010: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B9014: 4200FFF0  bdnz 0x821b9004
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821B9004; continue 'dispatch;
	}
	// 821B9018: C3E100E0  lfs f31, 0xe0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821B901C: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 821B9020: C01E0110  lfs f0, 0x110(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B9024: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821B9028: 419A0008  beq cr6, 0x821b9030
	if ctx.cr[6].eq {
	pc = 0x821B9030; continue 'dispatch;
	}
	// 821B902C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	pc = 0x821B9030; continue 'dispatch;
            }
            0x821B9030 => {
    //   block [0x821B9030..0x821B9048)
	// 821B9030: 8B6100E4  lbz r27, 0xe4(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 821B9034: 897E0114  lbz r11, 0x114(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(276 as u32) ) } as u64;
	// 821B9038: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 821B903C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B9040: 419A0008  beq cr6, 0x821b9048
	if ctx.cr[6].eq {
	pc = 0x821B9048; continue 'dispatch;
	}
	// 821B9044: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	pc = 0x821B9048; continue 'dispatch;
            }
            0x821B9048 => {
    //   block [0x821B9048..0x821B9254)
	// 821B9048: 396100C0  addi r11, r1, 0xc0
	ctx.r[11].s64 = ctx.r[1].s64 + 192;
	// 821B904C: 3BBE00F0  addi r29, r30, 0xf0
	ctx.r[29].s64 = ctx.r[30].s64 + 240;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821B9258 size=1480
    let mut pc: u32 = 0x821B9258;
    'dispatch: loop {
        match pc {
            0x821B9258 => {
    //   block [0x821B9258..0x821B92A0)
	// 821B9258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B925C: 48AF01A5  bl 0x82ca9400
	ctx.lr = 0x821B9260;
	sub_82CA93D0(ctx, base);
	// 821B9260: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B9264: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B9268: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821B926C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B9270: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 821B9274: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821B9278: 995A0044  stb r10, 0x44(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(68 as u32), ctx.r[10].u8 ) };
	// 821B927C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B9280: 8169008C  lwz r11, 0x8c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B9284: 890B0034  lbz r8, 0x34(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821B9288: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821B928C: 419A0014  beq cr6, 0x821b92a0
	if ctx.cr[6].eq {
	pc = 0x821B92A0; continue 'dispatch;
	}
	// 821B9290: 896B0036  lbz r11, 0x36(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(54 as u32) ) } as u64;
	// 821B9294: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9298: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B929C: 409A0008  bne cr6, 0x821b92a4
	if !ctx.cr[6].eq {
	pc = 0x821B92A4; continue 'dispatch;
	}
	pc = 0x821B92A0; continue 'dispatch;
            }
            0x821B92A0 => {
    //   block [0x821B92A0..0x821B92A4)
	// 821B92A0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x821B92A4; continue 'dispatch;
            }
            0x821B92A4 => {
    //   block [0x821B92A4..0x821B92E0)
	// 821B92A4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B92A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B92AC: 419A0060  beq cr6, 0x821b930c
	if ctx.cr[6].eq {
	pc = 0x821B930C; continue 'dispatch;
	}
	// 821B92B0: 817A002C  lwz r11, 0x2c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B92B4: 3BFA002C  addi r31, r26, 0x2c
	ctx.r[31].s64 = ctx.r[26].s64 + 44;
	// 821B92B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B92BC: 409A0040  bne cr6, 0x821b92fc
	if !ctx.cr[6].eq {
	pc = 0x821B92FC; continue 'dispatch;
	}
	// 821B92C0: 3860006C  li r3, 0x6c
	ctx.r[3].s64 = 108;
	// 821B92C4: 48065F95  bl 0x8221f258
	ctx.lr = 0x821B92C8;
	sub_8221F258(ctx, base);
	// 821B92C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B92CC: 419A0014  beq cr6, 0x821b92e0
	if ctx.cr[6].eq {
	pc = 0x821B92E0; continue 'dispatch;
	}
	// 821B92D0: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B92D4: 483F4295  bl 0x825ad568
	ctx.lr = 0x821B92D8;
	sub_825AD568(ctx, base);
	// 821B92D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821B92DC: 48000008  b 0x821b92e4
	pc = 0x821B92E4; continue 'dispatch;
            }
            0x821B92E0 => {
    //   block [0x821B92E0..0x821B92E4)
	// 821B92E0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	pc = 0x821B92E4; continue 'dispatch;
            }
            0x821B92E4 => {
    //   block [0x821B92E4..0x821B92FC)
	// 821B92E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B92E8: 480B9D71  bl 0x82273058
	ctx.lr = 0x821B92EC;
	sub_82273058(ctx, base);
	// 821B92EC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B92F0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B92F4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B92F8: 483F44F1  bl 0x825ad7e8
	ctx.lr = 0x821B92FC;
	sub_825AD7E8(ctx, base);
	pc = 0x821B92FC; continue 'dispatch;
            }
            0x821B92FC => {
    //   block [0x821B92FC..0x821B930C)
	// 821B92FC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821B9300: 482C99B1  bl 0x82482cb0
	ctx.lr = 0x821B9304;
	sub_82482CB0(ctx, base);
	// 821B9304: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821B9308: 48AF0148  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B930C => {
    //   block [0x821B930C..0x821B9338)
	// 821B930C: 807A0000  lwz r3, 0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9310: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 821B9314: 480E5B65  bl 0x8229ee78
	ctx.lr = 0x821B9318;
	sub_8229EE78(ctx, base);
	// 821B9318: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821B931C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821B9320: 419A0018  beq cr6, 0x821b9338
	if ctx.cr[6].eq {
	pc = 0x821B9338; continue 'dispatch;
	}
	// 821B9324: 897D0090  lbz r11, 0x90(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(144 as u32) ) } as u64;
	// 821B9328: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B932C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B9330: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B9334: 409A0008  bne cr6, 0x821b933c
	if !ctx.cr[6].eq {
	pc = 0x821B933C; continue 'dispatch;
	}
	pc = 0x821B9338; continue 'dispatch;
            }
            0x821B9338 => {
    //   block [0x821B9338..0x821B933C)
	// 821B9338: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x821B933C; continue 'dispatch;
            }
            0x821B933C => {
    //   block [0x821B933C..0x821B9390)
	// 821B933C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B9340: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	// 821B9344: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9348: 419A0128  beq cr6, 0x821b9470
	if ctx.cr[6].eq {
	pc = 0x821B9470; continue 'dispatch;
	}
	// 821B934C: 807A0000  lwz r3, 0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9350: 480E5B29  bl 0x8229ee78
	ctx.lr = 0x821B9354;
	sub_8229EE78(ctx, base);
	// 821B9354: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B9358: 556A67FE  rlwinm r10, r11, 0xc, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000FFFFFu64;
	// 821B935C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B9360: 419A00F4  beq cr6, 0x821b9454
	if ctx.cr[6].eq {
	pc = 0x821B9454; continue 'dispatch;
	}
	// 821B9364: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B9368: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B936C: 419A0024  beq cr6, 0x821b9390
	if ctx.cr[6].eq {
	pc = 0x821B9390; continue 'dispatch;
	}
	// 821B9370: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B9374: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B9378: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821B937C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B9380: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B9384: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B9388: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B938C: 480000CC  b 0x821b9458
	pc = 0x821B9458; continue 'dispatch;
            }
            0x821B9390 => {
    //   block [0x821B9390..0x821B93AC)
	// 821B9390: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B9394: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821B9398: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 821B939C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821B93A0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B93A4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B93A8: 40810054  ble 0x821b93fc
	if !ctx.cr[0].gt {
	pc = 0x821B93FC; continue 'dispatch;
	}
	pc = 0x821B93AC; continue 'dispatch;
            }
            0x821B93AC => {
    //   block [0x821B93AC..0x821B93CC)
	// 821B93AC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B93B0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B93B4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821B93B8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B93BC: 2F070014  cmpwi cr6, r7, 0x14
	ctx.cr[6].compare_i32(ctx.r[7].s32, 20, &mut ctx.xer);
	// 821B93C0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821B93C4: 41980008  blt cr6, 0x821b93cc
	if ctx.cr[6].lt {
	pc = 0x821B93CC; continue 'dispatch;
	}
	// 821B93C8: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x821B93CC; continue 'dispatch;
            }
            0x821B93CC => {
    //   block [0x821B93CC..0x821B93E8)
	// 821B93CC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821B93D0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B93D4: 419A0014  beq cr6, 0x821b93e8
	if ctx.cr[6].eq {
	pc = 0x821B93E8; continue 'dispatch;
	}
	// 821B93D8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821B93DC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B93E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B93E4: 4800000C  b 0x821b93f0
	pc = 0x821B93F0; continue 'dispatch;
            }
            0x821B93E8 => {
    //   block [0x821B93E8..0x821B93F0)
	// 821B93E8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821B93EC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821B93F0; continue 'dispatch;
            }
            0x821B93F0 => {
    //   block [0x821B93F0..0x821B93FC)
	// 821B93F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B93F4: 4199FFB8  bgt cr6, 0x821b93ac
	if ctx.cr[6].gt {
	pc = 0x821B93AC; continue 'dispatch;
	}
	// 821B93F8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821B93FC; continue 'dispatch;
            }
            0x821B93FC => {
    //   block [0x821B93FC..0x821B9418)
	// 821B93FC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B9400: 419A0040  beq cr6, 0x821b9440
	if ctx.cr[6].eq {
	pc = 0x821B9440; continue 'dispatch;
	}
	// 821B9404: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9408: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 821B940C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B9410: 41990008  bgt cr6, 0x821b9418
	if ctx.cr[6].gt {
	pc = 0x821B9418; continue 'dispatch;
	}
	// 821B9414: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x821B9418; continue 'dispatch;
            }
            0x821B9418 => {
    //   block [0x821B9418..0x821B9440)
	// 821B9418: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B941C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9420: 409A0020  bne cr6, 0x821b9440
	if !ctx.cr[6].eq {
	pc = 0x821B9440; continue 'dispatch;
	}
	// 821B9424: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B9428: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B942C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B9430: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B9434: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B9438: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B943C: 4800001C  b 0x821b9458
	pc = 0x821B9458; continue 'dispatch;
            }
            0x821B9440 => {
    //   block [0x821B9440..0x821B9454)
	// 821B9440: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821B9444: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B9448: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821B944C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B9450: 48000008  b 0x821b9458
	pc = 0x821B9458; continue 'dispatch;
            }
            0x821B9454 => {
    //   block [0x821B9454..0x821B9458)
	// 821B9454: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x821B9458; continue 'dispatch;
            }
            0x821B9458 => {
    //   block [0x821B9458..0x821B9470)
	// 821B9458: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B945C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9460: 419A0010  beq cr6, 0x821b9470
	if ctx.cr[6].eq {
	pc = 0x821B9470; continue 'dispatch;
	}
	// 821B9464: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821B9468: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B946C: 409A000C  bne cr6, 0x821b9478
	if !ctx.cr[6].eq {
	pc = 0x821B9478; continue 'dispatch;
	}
	pc = 0x821B9470; continue 'dispatch;
            }
            0x821B9470 => {
    //   block [0x821B9470..0x821B9478)
	// 821B9470: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B9474: 997C6BE9  stb r11, 0x6be9(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(27625 as u32), ctx.r[11].u8 ) };
	pc = 0x821B9478; continue 'dispatch;
            }
            0x821B9478 => {
    //   block [0x821B9478..0x821B94B8)
	// 821B9478: 3FC08349  lis r30, -0x7cb7
	ctx.r[30].s64 = -2092367872;
	// 821B947C: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 821B9480: 895E6BEA  lbz r10, 0x6bea(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(27626 as u32) ) } as u64;
	// 821B9484: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B9488: 419A0030  beq cr6, 0x821b94b8
	if ctx.cr[6].eq {
	pc = 0x821B94B8; continue 'dispatch;
	}
	// 821B948C: 809D007C  lwz r4, 0x7c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(124 as u32) ) } as u64;
	// 821B9490: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821B9494: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9498: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821B949C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821B94A0: 4E800421  bctrl
	ctx.lr = 0x821B94A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821B94A4: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 821B94A8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
            }
            0x821B94B8 => {
    //   block [0x821B94B8..0x821B9820)
	// 821B94B8: 897F6BEB  lbz r11, 0x6beb(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(27627 as u32) ) } as u64;
	// 821B94BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B94C0: 419A000C  beq cr6, 0x821b94cc
	if ctx.cr[6].eq {
	pc = 0x821B94CC; continue 'dispatch;
	}
	// 821B94C4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821B94C8: 482C9399  bl 0x82482860
	ctx.lr = 0x821B94CC;
	sub_82482860(ctx, base);
	// 821B94CC: 897E6BEA  lbz r11, 0x6bea(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(27626 as u32) ) } as u64;
	// 821B94D0: 807A0000  lwz r3, 0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B94D4: 997F6BEB  stb r11, 0x6beb(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(27627 as u32), ctx.r[11].u8 ) };
	// 821B94D8: 480E59A1  bl 0x8229ee78
	ctx.lr = 0x821B94DC;
	sub_8229EE78(ctx, base);
	// 821B94DC: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 821B94E0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821B94E4: 389A0004  addi r4, r26, 4
	ctx.r[4].s64 = ctx.r[26].s64 + 4;
	// 821B94E8: 387A0018  addi r3, r26, 0x18
	ctx.r[3].s64 = ctx.r[26].s64 + 24;
	// 821B94EC: 4BFF33C5  bl 0x821ac8b0
	ctx.lr = 0x821B94F0;
	sub_821AC8B0(ctx, base);
	// 821B94F0: 817A003C  lwz r11, 0x3c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(60 as u32) ) } as u64;
	// 821B94F4: 3BFA003C  addi r31, r26, 0x3c
	ctx.r[31].s64 = ctx.r[26].s64 + 60;
	// 821B94F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B94FC: 409A000C  bne cr6, 0x821b9508
	if !ctx.cr[6].eq {
	pc = 0x821B9508; continue 'dispatch;
	}
	// 821B9500: 83DA002C  lwz r30, 0x2c(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B9504: 48000008  b 0x821b950c
	pc = 0x821B950C; continue 'dispatch;
	// 821B9508: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821B950C: 389E0018  addi r4, r30, 0x18
	ctx.r[4].s64 = ctx.r[30].s64 + 24;
	// 821B9510: 387E002C  addi r3, r30, 0x2c
	ctx.r[3].s64 = ctx.r[30].s64 + 44;
	// 821B9514: 4BFE1245  bl 0x8219a758
	ctx.lr = 0x821B9518;
	sub_8219A758(ctx, base);
	// 821B9518: 897E0069  lbz r11, 0x69(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(105 as u32) ) } as u64;
	// 821B951C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9520: 419A0028  beq cr6, 0x821b9548
	if ctx.cr[6].eq {
	pc = 0x821B9548; continue 'dispatch;
	}
	// 821B9524: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B9528: 4BFFE5F1  bl 0x821b7b18
	ctx.lr = 0x821B952C;
	sub_821B7B18(ctx, base);
	// 821B952C: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 821B9530: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821B9534: 807A002C  lwz r3, 0x2c(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B9538: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B953C: 483F42AD  bl 0x825ad7e8
	ctx.lr = 0x821B9540;
	sub_825AD7E8(ctx, base);
	// 821B9540: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B9544: 997C6BE9  stb r11, 0x6be9(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(27625 as u32), ctx.r[11].u8 ) };
	// 821B9548: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821B954C: 480654DD  bl 0x8221ea28
	ctx.lr = 0x821B9550;
	sub_8221EA28(ctx, base);
	// 821B9550: C9810050  lfd f12, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B9554: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 821B9558: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821B955C: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821B9560: 387A0048  addi r3, r26, 0x48
	ctx.r[3].s64 = ctx.r[26].s64 + 72;
	// 821B9564: C80B70A0  lfd f0, 0x70a0(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(28832 as u32) ) };
	// 821B9568: C9AA70A8  lfd f13, 0x70a8(r10)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(28840 as u32) ) };
	// 821B956C: FD4B0028  fsub f10, f11, f0
	ctx.f[10].f64 = ctx.f[11].f64 - ctx.f[0].f64;
	// 821B9570: FD2A6824  fdiv f9, f10, f13
	ctx.f[9].f64 = ctx.f[10].f64 / ctx.f[13].f64;
	// 821B9574: FC204818  frsp f1, f9
	ctx.f[1].f64 = (ctx.f[9].f64 as f32) as f64;
	// 821B9578: 4BFD31F9  bl 0x8218c770
	ctx.lr = 0x821B957C;
	sub_8218C770(ctx, base);
	// 821B957C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9580: 3BDA0024  addi r30, r26, 0x24
	ctx.r[30].s64 = ctx.r[26].s64 + 36;
	// 821B9584: 7D280034  cntlzw r8, r9
	ctx.r[8].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821B9588: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B958C: 551DDFFE  rlwinm r29, r8, 0x1b, 0x1f, 0x1f
	ctx.r[29].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 821B9590: 4BFBA8A9  bl 0x82173e38
	ctx.lr = 0x821B9594;
	sub_82173E38(ctx, base);
	// 821B9594: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B9598: 419A0130  beq cr6, 0x821b96c8
	if ctx.cr[6].eq {
	pc = 0x821B96C8; continue 'dispatch;
	}
	// 821B959C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B95A0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 821B95A4: 4BFBA895  bl 0x82173e38
	ctx.lr = 0x821B95A8;
	sub_82173E38(ctx, base);
	// 821B95A8: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B95AC: 556A4FFE  rlwinm r10, r11, 9, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x007FFFFFu64;
	// 821B95B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B95B4: 419A00E8  beq cr6, 0x821b969c
	if ctx.cr[6].eq {
	pc = 0x821B969C; continue 'dispatch;
	}
	// 821B95B8: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B95BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B95C0: 419A0020  beq cr6, 0x821b95e0
	if ctx.cr[6].eq {
	pc = 0x821B95E0; continue 'dispatch;
	}
	// 821B95C4: 894B0057  lbz r10, 0x57(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(87 as u32) ) } as u64;
	// 821B95C8: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B95CC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821B95D0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821B95D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B95D8: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B95DC: 480000C4  b 0x821b96a0
	pc = 0x821B96A0; continue 'dispatch;
	// 821B95E0: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B95E4: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821B95E8: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 821B95EC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821B95F0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B95F4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B95F8: 40810054  ble 0x821b964c
	if !ctx.cr[0].gt {
	pc = 0x821B964C; continue 'dispatch;
	}
	// 821B95FC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B9600: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B9604: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821B9608: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B960C: 2F070057  cmpwi cr6, r7, 0x57
	ctx.cr[6].compare_i32(ctx.r[7].s32, 87, &mut ctx.xer);
	// 821B9610: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821B9614: 41980008  blt cr6, 0x821b961c
	if ctx.cr[6].lt {
	pc = 0x821B961C; continue 'dispatch;
	}
	// 821B9618: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 821B961C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821B9620: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B9624: 419A0014  beq cr6, 0x821b9638
	if ctx.cr[6].eq {
	pc = 0x821B9638; continue 'dispatch;
	}
	// 821B9628: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821B962C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B9630: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B9634: 4800000C  b 0x821b9640
	pc = 0x821B9640; continue 'dispatch;
	// 821B9638: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821B963C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821B9640: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B9644: 4199FFB8  bgt cr6, 0x821b95fc
	if ctx.cr[6].gt {
	pc = 0x821B95FC; continue 'dispatch;
	}
	// 821B9648: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B964C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B9650: 419A003C  beq cr6, 0x821b968c
	if ctx.cr[6].eq {
	pc = 0x821B968C; continue 'dispatch;
	}
	// 821B9654: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9658: 2F0B0057  cmpwi cr6, r11, 0x57
	ctx.cr[6].compare_i32(ctx.r[11].s32, 87, &mut ctx.xer);
	// 821B965C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B9660: 41990008  bgt cr6, 0x821b9668
	if ctx.cr[6].gt {
	pc = 0x821B9668; continue 'dispatch;
	}
	// 821B9664: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B9668: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B966C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9670: 409A001C  bne cr6, 0x821b968c
	if !ctx.cr[6].eq {
	pc = 0x821B968C; continue 'dispatch;
	}
	// 821B9674: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B9678: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B967C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B9680: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B9684: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B9688: 48000018  b 0x821b96a0
	pc = 0x821B96A0; continue 'dispatch;
	// 821B968C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821B9690: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B9694: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B9698: 48000008  b 0x821b96a0
	pc = 0x821B96A0; continue 'dispatch;
	// 821B969C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B96A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B96A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B96A8: 419A0020  beq cr6, 0x821b96c8
	if ctx.cr[6].eq {
	pc = 0x821B96C8; continue 'dispatch;
	}
	// 821B96AC: C01A0054  lfs f0, 0x54(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B96B0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821B96B4: C1BF00C0  lfs f13, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B96B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B96BC: ED80682A  fadds f12, f0, f13
	ctx.f[12].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 821B96C0: D19F00C0  stfs f12, 0xc0(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 821B96C4: 480EB33D  bl 0x822a4a00
	ctx.lr = 0x821B96C8;
	sub_822A4A00(ctx, base);
	// 821B96C8: 3BFA0034  addi r31, r26, 0x34
	ctx.r[31].s64 = ctx.r[26].s64 + 52;
	// 821B96CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B96D0: 4BFBA769  bl 0x82173e38
	ctx.lr = 0x821B96D4;
	sub_82173E38(ctx, base);
	// 821B96D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B96D8: 419A0134  beq cr6, 0x821b980c
	if ctx.cr[6].eq {
	pc = 0x821B980C; continue 'dispatch;
	}
	// 821B96DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B96E0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 821B96E4: 4BFBA755  bl 0x82173e38
	ctx.lr = 0x821B96E8;
	sub_82173E38(ctx, base);
	// 821B96E8: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 821B96EC: 556A4FFE  rlwinm r10, r11, 9, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x007FFFFFu64;
	// 821B96F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B96F4: 419A00E4  beq cr6, 0x821b97d8
	if ctx.cr[6].eq {
	pc = 0x821B97D8; continue 'dispatch;
	}
	// 821B96F8: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821B96FC: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821B9700: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9704: 419A001C  beq cr6, 0x821b9720
	if ctx.cr[6].eq {
	pc = 0x821B9720; continue 'dispatch;
	}
	// 821B9708: 896B0057  lbz r11, 0x57(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(87 as u32) ) } as u64;
	// 821B970C: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821B9710: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821B9714: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B9718: 83EA0004  lwz r31, 4(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B971C: 480000C0  b 0x821b97dc
	pc = 0x821B97DC; continue 'dispatch;
	// 821B9720: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821B9724: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 821B9728: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821B972C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B9730: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B9734: 40810054  ble 0x821b9788
	if !ctx.cr[0].gt {
	pc = 0x821B9788; continue 'dispatch;
	}
	// 821B9738: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821B973C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821B9740: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821B9744: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9748: 2F070057  cmpwi cr6, r7, 0x57
	ctx.cr[6].compare_i32(ctx.r[7].s32, 87, &mut ctx.xer);
	// 821B974C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821B9750: 41980008  blt cr6, 0x821b9758
	if ctx.cr[6].lt {
	pc = 0x821B9758; continue 'dispatch;
	}
	// 821B9754: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 821B9758: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821B975C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821B9760: 419A0014  beq cr6, 0x821b9774
	if ctx.cr[6].eq {
	pc = 0x821B9774; continue 'dispatch;
	}
	// 821B9764: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821B9768: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821B976C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821B9770: 4800000C  b 0x821b977c
	pc = 0x821B977C; continue 'dispatch;
	// 821B9774: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821B9778: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821B977C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B9780: 4199FFB8  bgt cr6, 0x821b9738
	if ctx.cr[6].gt {
	pc = 0x821B9738; continue 'dispatch;
	}
	// 821B9784: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821B9788: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821B978C: 419A003C  beq cr6, 0x821b97c8
	if ctx.cr[6].eq {
	pc = 0x821B97C8; continue 'dispatch;
	}
	// 821B9790: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9794: 2F0B0057  cmpwi cr6, r11, 0x57
	ctx.cr[6].compare_i32(ctx.r[11].s32, 87, &mut ctx.xer);
	// 821B9798: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B979C: 41990008  bgt cr6, 0x821b97a4
	if ctx.cr[6].gt {
	pc = 0x821B97A4; continue 'dispatch;
	}
	// 821B97A0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B97A4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B97A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B97AC: 409A001C  bne cr6, 0x821b97c8
	if !ctx.cr[6].eq {
	pc = 0x821B97C8; continue 'dispatch;
	}
	// 821B97B0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821B97B4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821B97B8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821B97BC: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B97C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B97C4: 48000018  b 0x821b97dc
	pc = 0x821B97DC; continue 'dispatch;
	// 821B97C8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821B97CC: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B97D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821B97D4: 48000008  b 0x821b97dc
	pc = 0x821B97DC; continue 'dispatch;
	// 821B97D8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821B97DC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821B97E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B97E4: 419A0028  beq cr6, 0x821b980c
	if ctx.cr[6].eq {
	pc = 0x821B980C; continue 'dispatch;
	}
	// 821B97E8: C01A0054  lfs f0, 0x54(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821B97EC: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 821B97F0: C1BF00C0  lfs f13, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821B97F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B97F8: ED80682A  fadds f12, f0, f13
	ctx.f[12].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 821B97FC: D19F00C0  stfs f12, 0xc0(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 821B9800: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821B9804: 5544DFFE  rlwinm r4, r10, 0x1b, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 821B9808: 480EB1F9  bl 0x822a4a00
	ctx.lr = 0x821B980C;
	sub_822A4A00(ctx, base);
	// 821B980C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B9810: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821B9814: 4BFFF7C5  bl 0x821b8fd8
	ctx.lr = 0x821B9818;
	sub_821B8FD8(ctx, base);
	// 821B9818: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821B981C: 48AEFC34  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B9820 size=184
    let mut pc: u32 = 0x821B9820;
    'dispatch: loop {
        match pc {
            0x821B9820 => {
    //   block [0x821B9820..0x821B98D8)
	// 821B9820: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 821B9824: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 821B9828: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B98D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B98D8 size=144
    let mut pc: u32 = 0x821B98D8;
    'dispatch: loop {
        match pc {
            0x821B98D8 => {
    //   block [0x821B98D8..0x821B9914)
	// 821B98D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B98DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B98E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B98E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B98E8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821B98EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B98F0: 396B4DE4  addi r11, r11, 0x4de4
	ctx.r[11].s64 = ctx.r[11].s64 + 19940;
	// 821B98F4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B98F8: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B98FC: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 821B9900: 7D071671  srawi. r7, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821B9904: 41820010  beq 0x821b9914
	if ctx.cr[0].eq {
	pc = 0x821B9914; continue 'dispatch;
	}
	// 821B9908: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821B990C: 419A0008  beq cr6, 0x821b9914
	if ctx.cr[6].eq {
	pc = 0x821B9914; continue 'dispatch;
	}
	// 821B9910: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x821B9914; continue 'dispatch;
            }
            0x821B9914 => {
    //   block [0x821B9914..0x821B9968)
	// 821B9914: 4BFFD51D  bl 0x821b6e30
	ctx.lr = 0x821B9918;
	sub_821B6E30(ctx, base);
	// 821B9918: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B991C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B9920: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 821B9924: 917F06F0  stw r11, 0x6f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1776 as u32), ctx.r[11].u32 ) };
	// 821B9928: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821B992C: 392AA978  addi r9, r10, -0x5688
	ctx.r[9].s64 = ctx.r[10].s64 + -22152;
	// 821B9930: 38A0007F  li r5, 0x7f
	ctx.r[5].s64 = 127;
	// 821B9934: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821B9938: 816803B8  lwz r11, 0x3b8(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(952 as u32) ) } as u64;
	// 821B993C: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 821B9940: 90E803B8  stw r7, 0x3b8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(952 as u32), ctx.r[7].u32 ) };
	// 821B9944: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 821B9948: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B994C: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 821B9950: 480E1601  bl 0x8229af50
	ctx.lr = 0x821B9954;
	sub_8229AF50(ctx, base);
	// 821B9954: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B9958: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B995C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B9960: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B9964: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B9968 size=160
    let mut pc: u32 = 0x821B9968;
    'dispatch: loop {
        match pc {
            0x821B9968 => {
    //   block [0x821B9968..0x821B99BC)
	// 821B9968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B996C: 48AEFAA1  bl 0x82ca940c
	ctx.lr = 0x821B9970;
	sub_82CA93D0(ctx, base);
	// 821B9970: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B9974: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821B9978: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821B997C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B9980: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 821B9984: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 821B9988: 48071259  bl 0x8222abe0
	ctx.lr = 0x821B998C;
	sub_8222ABE0(ctx, base);
	// 821B998C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821B9990: 3D60F0F0  lis r11, -0xf10
	ctx.r[11].s64 = -252706816;
	// 821B9994: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 821B9998: 616AF0F0  ori r10, r11, 0xf0f0
	ctx.r[10].u64 = ctx.r[11].u64 | 61680;
	// 821B999C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 821B99A0: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B99A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B99A8: 48071239  bl 0x8222abe0
	ctx.lr = 0x821B99AC;
	sub_8222ABE0(ctx, base);
	// 821B99AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B99B0: 419A000C  beq cr6, 0x821b99bc
	if ctx.cr[6].eq {
	pc = 0x821B99BC; continue 'dispatch;
	}
	// 821B99B4: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 821B99B8: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x821B99BC; continue 'dispatch;
            }
            0x821B99BC => {
    //   block [0x821B99BC..0x821B99F8)
	// 821B99BC: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 821B99C0: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 821B99C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B99C8: 48071219  bl 0x8222abe0
	ctx.lr = 0x821B99CC;
	sub_8222ABE0(ctx, base);
	// 821B99CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821B99D0: 419A0028  beq cr6, 0x821b99f8
	if ctx.cr[6].eq {
	pc = 0x821B99F8; continue 'dispatch;
	}
	// 821B99D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821B99D8: 394B113C  addi r10, r11, 0x113c
	ctx.r[10].s64 = ctx.r[11].s64 + 4412;
	// 821B99DC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B99E0: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B99E4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821B99E8: 811F0020  lwz r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821B99EC: 911E0000  stw r8, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821B99F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B99F4: 48AEFA68  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821B99F8 => {
    //   block [0x821B99F8..0x821B9A08)
	// 821B99F8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821B99FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B9A00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821B9A04: 48AEFA58  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9A08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B9A08 size=720
    let mut pc: u32 = 0x821B9A08;
    'dispatch: loop {
        match pc {
            0x821B9A08 => {
    //   block [0x821B9A08..0x821B9A64)
	// 821B9A08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B9A0C: 48AEF9E9  bl 0x82ca93f4
	ctx.lr = 0x821B9A10;
	sub_82CA93D0(ctx, base);
	// 821B9A10: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B9A14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B9A18: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 821B9A1C: 817F2A90  lwz r11, 0x2a90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10896 as u32) ) } as u64;
	// 821B9A20: 895F2ABC  lbz r10, 0x2abc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10940 as u32) ) } as u64;
	// 821B9A24: 554A06B5  rlwinm. r10, r10, 0, 0x1a, 0x1a
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B9A28: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9A2C: 418201C0  beq 0x821b9bec
	if ctx.cr[0].eq {
	pc = 0x821B9BEC; continue 'dispatch;
	}
	// 821B9A30: 3B7F33C0  addi r27, r31, 0x33c0
	ctx.r[27].s64 = ctx.r[31].s64 + 13248;
	// 821B9A34: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B9A38: 480002A1  bl 0x821b9cd8
	ctx.lr = 0x821B9A3C;
	sub_821B9CD8(ctx, base);
	// 821B9A3C: 3B9F3424  addi r28, r31, 0x3424
	ctx.r[28].s64 = ctx.r[31].s64 + 13348;
	// 821B9A40: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B9A44: 48000295  bl 0x821b9cd8
	ctx.lr = 0x821B9A48;
	sub_821B9CD8(ctx, base);
	// 821B9A48: 817F3384  lwz r11, 0x3384(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13188 as u32) ) } as u64;
	// 821B9A4C: 813F2C38  lwz r9, 0x2c38(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(11320 as u32) ) } as u64;
	// 821B9A50: 3D400100  lis r10, 0x100
	ctx.r[10].s64 = 16777216;
	// 821B9A54: 556B008F  rlwinm. r11, r11, 0, 2, 7
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B9A58: 7D5A4830  slw r26, r10, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[26].u64 = 0;
	} else {
		ctx.r[26].u64 = ((ctx.r[10].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 821B9A5C: 41820008  beq 0x821b9a64
	if ctx.cr[0].eq {
	pc = 0x821B9A64; continue 'dispatch;
	}
	// 821B9A60: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	pc = 0x821B9A64; continue 'dispatch;
            }
            0x821B9A64 => {
    //   block [0x821B9A64..0x821B9A90)
	// 821B9A64: 3F208000  lis r25, -0x8000
	ctx.r[25].s64 = -2147483648;
	// 821B9A68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B9A6C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821B9A70: 480ABB81  bl 0x822655f0
	ctx.lr = 0x821B9A74;
	sub_822655F0(ctx, base);
	// 821B9A74: 817F3438  lwz r11, 0x3438(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13368 as u32) ) } as u64;
	// 821B9A78: 3BDF3438  addi r30, r31, 0x3438
	ctx.r[30].s64 = ctx.r[31].s64 + 13368;
	// 821B9A7C: 3EE04000  lis r23, 0x4000
	ctx.r[23].s64 = 1073741824;
	// 821B9A80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9A84: 409A000C  bne cr6, 0x821b9a90
	if !ctx.cr[6].eq {
	pc = 0x821B9A90; continue 'dispatch;
	}
	// 821B9A88: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 821B9A8C: 4800001C  b 0x821b9aa8
	pc = 0x821B9AA8; continue 'dispatch;
            }
            0x821B9A90 => {
    //   block [0x821B9A90..0x821B9AA8)
	// 821B9A90: 5569653E  srwi r9, r11, 0x14
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(20);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B9A94: 556A00FE  clrlwi r10, r11, 3
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 821B9A98: 39690200  addi r11, r9, 0x200
	ctx.r[11].s64 = ctx.r[9].s64 + 512;
	// 821B9A9C: 556B04E6  rlwinm r11, r11, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B9AA0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821B9AA4: 7FB75850  subf r29, r23, r11
	ctx.r[29].s64 = ctx.r[11].s64 - ctx.r[23].s64;
	pc = 0x821B9AA8; continue 'dispatch;
            }
            0x821B9AA8 => {
    //   block [0x821B9AA8..0x821B9AC4)
	// 821B9AA8: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821B9AAC: 809F0030  lwz r4, 0x30(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821B9AB0: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B9AB4: 40990010  ble cr6, 0x821b9ac4
	if !ctx.cr[6].gt {
	pc = 0x821B9AC4; continue 'dispatch;
	}
	// 821B9AB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B9ABC: 4802F405  bl 0x821e8ec0
	ctx.lr = 0x821B9AC0;
	sub_821E8EC0(ctx, base);
	// 821B9AC0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	pc = 0x821B9AC4; continue 'dispatch;
            }
            0x821B9AC4 => {
    //   block [0x821B9AC4..0x821B9B10)
	// 821B9AC4: 3D6082BA  lis r11, -0x7d46
	ctx.r[11].s64 = -2101739520;
	// 821B9AC8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 821B9ACC: 38CB5EA0  addi r6, r11, 0x5ea0
	ctx.r[6].s64 = ctx.r[11].s64 + 24224;
	// 821B9AD0: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 821B9AD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B9AD8: 4803C579  bl 0x821f6050
	ctx.lr = 0x821B9ADC;
	sub_821F6050(ctx, base);
	// 821B9ADC: 907F0030  stw r3, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[3].u32 ) };
	// 821B9AE0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821B9AE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B9AE8: 480ABB09  bl 0x822655f0
	ctx.lr = 0x821B9AEC;
	sub_822655F0(ctx, base);
	// 821B9AEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B9AF0: 4802F3D1  bl 0x821e8ec0
	ctx.lr = 0x821B9AF4;
	sub_821E8EC0(ctx, base);
	// 821B9AF4: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B9AF8: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B9AFC: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	// 821B9B00: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B9B04: 4099000C  ble cr6, 0x821b9b10
	if !ctx.cr[6].gt {
	pc = 0x821B9B10; continue 'dispatch;
	}
	// 821B9B08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B9B0C: 48017AA5  bl 0x821d15b0
	ctx.lr = 0x821B9B10;
	sub_821D15B0(ctx, base);
	pc = 0x821B9B10; continue 'dispatch;
            }
            0x821B9B10 => {
    //   block [0x821B9B10..0x821B9B40)
	// 821B9B10: 3D608800  lis r11, -0x7800
	ctx.r[11].s64 = -2013265920;
	// 821B9B14: 93230004  stw r25, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 821B9B18: 39430008  addi r10, r3, 8
	ctx.r[10].s64 = ctx.r[3].s64 + 8;
	// 821B9B1C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B9B20: 915F3440  stw r10, 0x3440(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13376 as u32), ctx.r[10].u32 ) };
	// 821B9B24: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 821B9B28: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B9B2C: 3943000C  addi r10, r3, 0xc
	ctx.r[10].s64 = ctx.r[3].s64 + 12;
	// 821B9B30: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821B9B34: 4099000C  ble cr6, 0x821b9b40
	if !ctx.cr[6].gt {
	pc = 0x821B9B40; continue 'dispatch;
	}
	// 821B9B38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821B9B3C: 48017A75  bl 0x821d15b0
	ctx.lr = 0x821B9B40;
	sub_821D15B0(ctx, base);
	pc = 0x821B9B40; continue 'dispatch;
            }
            0x821B9B40 => {
    //   block [0x821B9B40..0x821B9B5C)
	// 821B9B40: 3D608900  lis r11, -0x7700
	ctx.r[11].s64 = -1996488704;
	// 821B9B44: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B9B48: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9B4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9B50: 409A000C  bne cr6, 0x821b9b5c
	if !ctx.cr[6].eq {
	pc = 0x821B9B5C; continue 'dispatch;
	}
	// 821B9B54: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 821B9B58: 4800001C  b 0x821b9b74
	pc = 0x821B9B74; continue 'dispatch;
            }
            0x821B9B5C => {
    //   block [0x821B9B5C..0x821B9B74)
	// 821B9B5C: 5569653E  srwi r9, r11, 0x14
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(20);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B9B60: 556A00FE  clrlwi r10, r11, 3
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 821B9B64: 39690200  addi r11, r9, 0x200
	ctx.r[11].s64 = ctx.r[9].s64 + 512;
	// 821B9B68: 556B04E6  rlwinm r11, r11, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B9B6C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821B9B70: 7D775850  subf r11, r23, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[23].s64;
	pc = 0x821B9B74; continue 'dispatch;
            }
            0x821B9B74 => {
    //   block [0x821B9B74..0x821B9B8C)
	// 821B9B74: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821B9B78: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9B7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9B80: 409A000C  bne cr6, 0x821b9b8c
	if !ctx.cr[6].eq {
	pc = 0x821B9B8C; continue 'dispatch;
	}
	// 821B9B84: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 821B9B88: 4800001C  b 0x821b9ba4
	pc = 0x821B9BA4; continue 'dispatch;
            }
            0x821B9B8C => {
    //   block [0x821B9B8C..0x821B9BA4)
	// 821B9B8C: 5569653E  srwi r9, r11, 0x14
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(20);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821B9B90: 556A00FE  clrlwi r10, r11, 3
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 821B9B94: 39690200  addi r11, r9, 0x200
	ctx.r[11].s64 = ctx.r[9].s64 + 512;
	// 821B9B98: 556B04E6  rlwinm r11, r11, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B9B9C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821B9BA0: 7D775850  subf r11, r23, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[23].s64;
	pc = 0x821B9BA4; continue 'dispatch;
            }
            0x821B9BA4 => {
    //   block [0x821B9BA4..0x821B9BEC)
	// 821B9BA4: 3943000C  addi r10, r3, 0xc
	ctx.r[10].s64 = ctx.r[3].s64 + 12;
	// 821B9BA8: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821B9BAC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821B9BB0: 915F3440  stw r10, 0x3440(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13376 as u32), ctx.r[10].u32 ) };
	// 821B9BB4: 93FB0010  stw r31, 0x10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 821B9BB8: 931B0004  stw r24, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 821B9BBC: 931B0008  stw r24, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	// 821B9BC0: 931B000C  stw r24, 0xc(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), ctx.r[24].u32 ) };
	// 821B9BC4: 931B0000  stw r24, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 821B9BC8: 480179E9  bl 0x821d15b0
	ctx.lr = 0x821B9BCC;
	sub_821D15B0(ctx, base);
	// 821B9BCC: 93FC0010  stw r31, 0x10(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 821B9BD0: 931C0004  stw r24, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 821B9BD4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821B9BD8: 931C0008  stw r24, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	// 821B9BDC: 931C000C  stw r24, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[24].u32 ) };
	// 821B9BE0: 931C0000  stw r24, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 821B9BE4: 480179CD  bl 0x821d15b0
	ctx.lr = 0x821B9BE8;
	sub_821D15B0(ctx, base);
	// 821B9BE8: 4800000C  b 0x821b9bf4
	pc = 0x821B9BF4; continue 'dispatch;
            }
            0x821B9BEC => {
    //   block [0x821B9BEC..0x821B9BF4)
	// 821B9BEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B9BF0: 4802F2D1  bl 0x821e8ec0
	ctx.lr = 0x821B9BF4;
	sub_821E8EC0(ctx, base);
	pc = 0x821B9BF4; continue 'dispatch;
            }
            0x821B9BF4 => {
    //   block [0x821B9BF4..0x821B9C14)
	// 821B9BF4: 817F3440  lwz r11, 0x3440(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13376 as u32) ) } as u64;
	// 821B9BF8: 387F3438  addi r3, r31, 0x3438
	ctx.r[3].s64 = ctx.r[31].s64 + 13368;
	// 821B9BFC: 815F3444  lwz r10, 0x3444(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13380 as u32) ) } as u64;
	// 821B9C00: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 821B9C04: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821B9C08: 4099000C  ble cr6, 0x821b9c14
	if !ctx.cr[6].gt {
	pc = 0x821B9C14; continue 'dispatch;
	}
	// 821B9C0C: 480179A5  bl 0x821d15b0
	ctx.lr = 0x821B9C10;
	sub_821D15B0(ctx, base);
	// 821B9C10: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x821B9C14; continue 'dispatch;
            }
            0x821B9C14 => {
    //   block [0x821B9C14..0x821B9CB4)
	// 821B9C14: 3D408400  lis r10, -0x7c00
	ctx.r[10].s64 = -2080374784;
	// 821B9C18: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 821B9C1C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821B9C20: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 821B9C24: 913F3440  stw r9, 0x3440(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13376 as u32), ctx.r[9].u32 ) };
	// 821B9C28: 897F2ABD  lbz r11, 0x2abd(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10941 as u32) ) } as u64;
	// 821B9C2C: 616B0080  ori r11, r11, 0x80
	ctx.r[11].u64 = ctx.r[11].u64 | 128;
	// 821B9C30: 895F2ABC  lbz r10, 0x2abc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10940 as u32) ) } as u64;
	// 821B9C34: 798CC7E6  rldicr r12, r12, 0x38, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(56) & 0xFFFFFFFFFFFFFFFF;
	// 821B9C38: 997F2ABD  stb r11, 0x2abd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(10941 as u32), ctx.r[11].u8 ) };
	// 821B9C3C: 714A00BF  andi. r10, r10, 0xbf
	ctx.r[10].u64 = ctx.r[10].u64 & 191;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821B9C40: 995F2ABC  stb r10, 0x2abc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(10940 as u32), ctx.r[10].u8 ) };
	// 821B9C44: E97F0010  ld r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B9C48: 616B0008  ori r11, r11, 8
	ctx.r[11].u64 = ctx.r[11].u64 | 8;
	// 821B9C4C: F97F0010  std r11, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821B9C50: 7D6B6378  or r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[12].u64;
	// 821B9C54: F97F0010  std r11, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821B9C58: 897F2ABF  lbz r11, 0x2abf(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10943 as u32) ) } as u64;
	// 821B9C5C: 556B06B5  rlwinm. r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B9C60: 41820054  beq 0x821b9cb4
	if ctx.cr[0].eq {
	pc = 0x821B9CB4; continue 'dispatch;
	}
	// 821B9C64: 389F3184  addi r4, r31, 0x3184
	ctx.r[4].s64 = ctx.r[31].s64 + 12676;
	// 821B9C68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B9C6C: 4803FF9D  bl 0x821f9c08
	ctx.lr = 0x821B9C70;
	sub_821F9C08(ctx, base);
	// 821B9C70: E97F0010  ld r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821B9C74: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 821B9C78: 616B0100  ori r11, r11, 0x100
	ctx.r[11].u64 = ctx.r[11].u64 | 256;
	// 821B9C7C: 798C2FE6  rldicr r12, r12, 0x25, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(37) & 0xFFFFFFFFFFFFFFFF;
	// 821B9C80: F97F0010  std r11, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821B9C84: 7D6B6378  or r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[12].u64;
	// 821B9C88: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 821B9C8C: F97F0010  std r11, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821B9C90: 798CCFE6  rldicr r12, r12, 0x39, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(57) & 0xFFFFFFFFFFFFFFFF;
	// 821B9C94: 7D6B6378  or r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[12].u64;
	// 821B9C98: 3D80FFEF  lis r12, -0x11
	ctx.r[12].s64 = -1114112;
	// 821B9C9C: F97F0010  std r11, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821B9CA0: 618CFFFE  ori r12, r12, 0xfffe
	ctx.r[12].u64 = ctx.r[12].u64 | 65534;
	// 821B9CA4: 798C2FE6  rldicr r12, r12, 0x25, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(37) & 0xFFFFFFFFFFFFFFFF;
	// 821B9CA8: E97F0028  ld r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	// 821B9CAC: 7D6B6038  and r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[12].u64;
	// 821B9CB0: F97F0028  std r11, 0x28(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u64 ) };
	pc = 0x821B9CB4; continue 'dispatch;
            }
            0x821B9CB4 => {
    //   block [0x821B9CB4..0x821B9CCC)
	// 821B9CB4: 897F2ABD  lbz r11, 0x2abd(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10941 as u32) ) } as u64;
	// 821B9CB8: 556B0673  rlwinm. r11, r11, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B9CBC: 41820010  beq 0x821b9ccc
	if ctx.cr[0].eq {
	pc = 0x821B9CCC; continue 'dispatch;
	}
	// 821B9CC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B9CC4: 4BFD9345  bl 0x82193008
	ctx.lr = 0x821B9CC8;
	sub_82193008(ctx, base);
	// 821B9CC8: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	pc = 0x821B9CCC; continue 'dispatch;
            }
            0x821B9CCC => {
    //   block [0x821B9CCC..0x821B9CD8)
	// 821B9CCC: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821B9CD0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821B9CD4: 48AEF770  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B9CD8 size=68
    let mut pc: u32 = 0x821B9CD8;
    'dispatch: loop {
        match pc {
            0x821B9CD8 => {
    //   block [0x821B9CD8..0x821B9D10)
	// 821B9CD8: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B9CDC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821B9CE0: 419A0030  beq cr6, 0x821b9d10
	if ctx.cr[6].eq {
	pc = 0x821B9D10; continue 'dispatch;
	}
	// 821B9CE4: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B9CE8: 3D00C000  lis r8, -0x4000
	ctx.r[8].s64 = -1073741824;
	// 821B9CEC: 554B653E  srwi r11, r10, 0x14
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shr(20);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821B9CF0: 554A00FE  clrlwi r10, r10, 3
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 821B9CF4: 396B0200  addi r11, r11, 0x200
	ctx.r[11].s64 = ctx.r[11].s64 + 512;
	// 821B9CF8: 556B04E6  rlwinm r11, r11, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821B9CFC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821B9D00: 3D6BC000  addis r11, r11, -0x4000
	ctx.r[11].s64 = ctx.r[11].s64 + -1073741824;
	// 821B9D04: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821B9D08: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821B9D0C: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	pc = 0x821B9D10; continue 'dispatch;
            }
            0x821B9D10 => {
    //   block [0x821B9D10..0x821B9D1C)
	// 821B9D10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821B9D14: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 821B9D18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B9D20 size=72
    let mut pc: u32 = 0x821B9D20;
    'dispatch: loop {
        match pc {
            0x821B9D20 => {
    //   block [0x821B9D20..0x821B9D4C)
	// 821B9D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B9D24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B9D28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821B9D2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B9D30: 81640074  lwz r11, 0x74(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(116 as u32) ) } as u64;
	// 821B9D34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821B9D38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9D3C: 419A0010  beq cr6, 0x821b9d4c
	if ctx.cr[6].eq {
	pc = 0x821B9D4C; continue 'dispatch;
	}
	// 821B9D40: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 821B9D44: 4869247D  bl 0x8284c1c0
	ctx.lr = 0x821B9D48;
	sub_8284C1C0(ctx, base);
	// 821B9D48: 48000008  b 0x821b9d50
	pc = 0x821B9D50; continue 'dispatch;
            }
            0x821B9D4C => {
    //   block [0x821B9D4C..0x821B9D50)
	// 821B9D4C: 480388E5  bl 0x821f2630
	ctx.lr = 0x821B9D50;
	sub_821F2630(ctx, base);
	pc = 0x821B9D50; continue 'dispatch;
            }
            0x821B9D50 => {
    //   block [0x821B9D50..0x821B9D68)
	// 821B9D50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821B9D54: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B9D58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B9D5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B9D60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821B9D64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821B9D68 size=132
    let mut pc: u32 = 0x821B9D68;
    'dispatch: loop {
        match pc {
            0x821B9D68 => {
    //   block [0x821B9D68..0x821B9D88)
	// 821B9D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B9D6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821B9D70: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821B9D74: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 821B9D78: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821B9D7C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821B9D80: 41990008  bgt cr6, 0x821b9d88
	if ctx.cr[6].gt {
	pc = 0x821B9D88; continue 'dispatch;
	}
	// 821B9D84: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821B9D88; continue 'dispatch;
            }
            0x821B9D88 => {
    //   block [0x821B9D88..0x821B9DD4)
	// 821B9D88: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821B9D8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B9D90: 419A0048  beq cr6, 0x821b9dd8
	if ctx.cr[6].eq {
	pc = 0x821B9DD8; continue 'dispatch;
	}
	// 821B9D94: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821B9D98: 40980040  bge cr6, 0x821b9dd8
	if !ctx.cr[6].lt {
	pc = 0x821B9DD8; continue 'dispatch;
	}
	// 821B9D9C: 81630334  lwz r11, 0x334(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(820 as u32) ) } as u64;
	// 821B9DA0: 548A2036  slwi r10, r4, 4
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821B9DA4: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821B9DA8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821B9DAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821B9DB0: 419A0028  beq cr6, 0x821b9dd8
	if ctx.cr[6].eq {
	pc = 0x821B9DD8; continue 'dispatch;
	}
	// 821B9DB4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821B9DB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821B9DBC: 419A0018  beq cr6, 0x821b9dd4
	if ctx.cr[6].eq {
	pc = 0x821B9DD4; continue 'dispatch;
	}
	// 821B9DC0: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821B9DC4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B9DC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B9DCC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B9DD0: 4E800020  blr
	return;
            }
            0x821B9DD4 => {
    //   block [0x821B9DD4..0x821B9DD8)
	// 821B9DD4: 4BFDA065  bl 0x82193e38
	ctx.lr = 0x821B9DD8;
	sub_82193E38(ctx, base);
	pc = 0x821B9DD8; continue 'dispatch;
            }
            0x821B9DD8 => {
    //   block [0x821B9DD8..0x821B9DEC)
	// 821B9DD8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821B9DDC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821B9DE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821B9DE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821B9DE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821B9DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821B9DF0 size=768
    let mut pc: u32 = 0x821B9DF0;
    'dispatch: loop {
        match pc {
            0x821B9DF0 => {
    //   block [0x821B9DF0..0x821BA0F0)
	// 821B9DF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821B9DF4: 48AEF609  bl 0x82ca93fc
	ctx.lr = 0x821B9DF8;
	sub_82CA93D0(ctx, base);
	// 821B9DF8: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 821B9DFC: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 821B9E00: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BA0F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BA0F0 size=252
    let mut pc: u32 = 0x821BA0F0;
    'dispatch: loop {
        match pc {
            0x821BA0F0 => {
    //   block [0x821BA0F0..0x821BA174)
	// 821BA0F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BA0F4: 48AEF315  bl 0x82ca9408
	ctx.lr = 0x821BA0F8;
	sub_82CA93D0(ctx, base);
	// 821BA0F8: 9421F450  stwu r1, -0xbb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-2992 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BA0FC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821BA100: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821BA104: 390BF7A8  addi r8, r11, -0x858
	ctx.r[8].s64 = ctx.r[11].s64 + -2136;
	// 821BA108: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821BA10C: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BA110: 81480008  lwz r10, 8(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BA114: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BA118: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821BA11C: 81490050  lwz r10, 0x50(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(80 as u32) ) } as u64;
	// 821BA120: 7CE61670  srawi r6, r7, 2
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[7].s32 >> 2) as i64;
	// 821BA124: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821BA128: 409800BC  bge cr6, 0x821ba1e4
	if !ctx.cr[6].lt {
	pc = 0x821BA1E4; continue 'dispatch;
	}
	// 821BA12C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821BA130: 7D2A582E  lwzx r9, r10, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821BA134: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821BA138: 419A00AC  beq cr6, 0x821ba1e4
	if ctx.cr[6].eq {
	pc = 0x821BA1E4; continue 'dispatch;
	}
	// 821BA13C: 553F003E  slwi r31, r9, 0
	ctx.r[31].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 821BA140: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BA144: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821BA148: 409A009C  bne cr6, 0x821ba1e4
	if !ctx.cr[6].eq {
	pc = 0x821BA1E4; continue 'dispatch;
	}
	// 821BA14C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821BA150: 419A0094  beq cr6, 0x821ba1e4
	if ctx.cr[6].eq {
	pc = 0x821BA1E4; continue 'dispatch;
	}
	// 821BA154: 897F0048  lbz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821BA158: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BA15C: 419A0088  beq cr6, 0x821ba1e4
	if ctx.cr[6].eq {
	pc = 0x821BA1E4; continue 'dispatch;
	}
	// 821BA160: 83DF0014  lwz r30, 0x14(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821BA164: 807E0E5C  lwz r3, 0xe5c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(3676 as u32) ) } as u64;
	// 821BA168: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821BA16C: 419A0008  beq cr6, 0x821ba174
	if ctx.cr[6].eq {
	pc = 0x821BA174; continue 'dispatch;
	}
	// 821BA170: 4801AFD9  bl 0x821d5148
	ctx.lr = 0x821BA174;
	sub_821D5148(ctx, base);
	pc = 0x821BA174; continue 'dispatch;
            }
            0x821BA174 => {
    //   block [0x821BA174..0x821BA188)
	// 821BA174: 807E0E64  lwz r3, 0xe64(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(3684 as u32) ) } as u64;
	// 821BA178: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821BA17C: 419A000C  beq cr6, 0x821ba188
	if ctx.cr[6].eq {
	pc = 0x821BA188; continue 'dispatch;
	}
	// 821BA180: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821BA184: 48086B65  bl 0x82240ce8
	ctx.lr = 0x821BA188;
	sub_82240CE8(ctx, base);
	pc = 0x821BA188; continue 'dispatch;
            }
            0x821BA188 => {
    //   block [0x821BA188..0x821BA1E4)
	// 821BA188: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BA18C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BA190: C82B02E8  lfd f1, 0x2e8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(744 as u32) ) };
	// 821BA194: 480D134D  bl 0x8228b4e0
	ctx.lr = 0x821BA198;
	sub_8228B4E0(ctx, base);
	// 821BA198: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BA19C: 48017B05  bl 0x821d1ca0
	ctx.lr = 0x821BA1A0;
	sub_821D1CA0(ctx, base);
	// 821BA1A0: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BA1A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BA1A8: 83CA0048  lwz r30, 0x48(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(72 as u32) ) } as u64;
	// 821BA1AC: 480D1BAD  bl 0x8228bd58
	ctx.lr = 0x821BA1B0;
	sub_8228BD58(ctx, base);
	// 821BA1B0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821BA1B4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821BA1B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821BA1BC: 38610410  addi r3, r1, 0x410
	ctx.r[3].s64 = ctx.r[1].s64 + 1040;
	// 821BA1C0: 480B3351  bl 0x8226d510
	ctx.lr = 0x821BA1C4;
	sub_8226D510(ctx, base);
	// 821BA1C4: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA1C8: 38810410  addi r4, r1, 0x410
	ctx.r[4].s64 = ctx.r[1].s64 + 1040;
	// 821BA1CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BA1D0: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA1D4: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821BA1D8: 4E800421  bctrl
	ctx.lr = 0x821BA1DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BA1DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BA1E0: 480BB129  bl 0x82275308
	ctx.lr = 0x821BA1E4;
	sub_82275308(ctx, base);
            }
            0x821BA1E4 => {
    //   block [0x821BA1E4..0x821BA1EC)
	// 821BA1E4: 38210BB0  addi r1, r1, 0xbb0
	ctx.r[1].s64 = ctx.r[1].s64 + 2992;
	// 821BA1E8: 48AEF270  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BA1F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BA1F0 size=328
    let mut pc: u32 = 0x821BA1F0;
    'dispatch: loop {
        match pc {
            0x821BA1F0 => {
    //   block [0x821BA1F0..0x821BA294)
	// 821BA1F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BA1F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821BA1F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821BA1FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BA200: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821BA204: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 821BA208: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821BA20C: 3CE08332  lis r7, -0x7cce
	ctx.r[7].s64 = -2093875200;
	// 821BA210: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 821BA214: 88AB6E61  lbz r5, 0x6e61(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28257 as u32) ) } as u64;
	// 821BA218: 3CC08332  lis r6, -0x7cce
	ctx.r[6].s64 = -2093875200;
	// 821BA21C: 91486E5C  stw r10, 0x6e5c(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(28252 as u32), ctx.r[10].u32 ) };
	// 821BA220: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821BA224: 7CA30034  cntlzw r3, r5
	ctx.r[3].u64 = if ctx.r[5].u32 == 0 { 32 } else { ctx.r[5].u32.leading_zeros() as u64 };
	// 821BA228: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821BA22C: 99271624  stb r9, 0x1624(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(5668 as u32), ctx.r[9].u8 ) };
	// 821BA230: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821BA234: 546ADFFE  rlwinm r10, r3, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x0000001Fu64;
	// 821BA238: 99061625  stb r8, 0x1625(r6)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[6].u32.wrapping_add(5669 as u32), ctx.r[8].u8 ) };
	// 821BA23C: 3BEBFB30  addi r31, r11, -0x4d0
	ctx.r[31].s64 = ctx.r[11].s64 + -1232;
	// 821BA240: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BA244: 419A00BC  beq cr6, 0x821ba300
	if ctx.cr[6].eq {
	pc = 0x821BA300; continue 'dispatch;
	}
	// 821BA248: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 821BA24C: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821BA250: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 821BA254: 38E96E50  addi r7, r9, 0x6e50
	ctx.r[7].s64 = ctx.r[9].s64 + 28240;
	// 821BA258: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 821BA25C: 816A8570  lwz r11, -0x7a90(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-31376 as u32) ) } as u64;
	// 821BA260: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 821BA264: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821BA268: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821BA26C: 916A8570  stw r11, -0x7a90(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-31376 as u32), ctx.r[11].u32 ) };
	// 821BA270: 7D43382E  lwzx r10, r3, r7
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 821BA274: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821BA278: 91486E58  stw r10, 0x6e58(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(28248 as u32), ctx.r[10].u32 ) };
	// 821BA27C: 69690001  xori r9, r11, 1
	ctx.r[9].u64 = ctx.r[11].u64 ^ 1;
	// 821BA280: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821BA284: 912A0010  stw r9, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 821BA288: 7CE8502E  lwzx r7, r8, r10
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821BA28C: 90EA0008  stw r7, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 821BA290: 908A0014  stw r4, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[4].u32 ) };
	pc = 0x821BA294; continue 'dispatch;
            }
            0x821BA294 => {
    //   block [0x821BA294..0x821BA2DC)
	// 821BA294: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BA298: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821BA29C: 419A0060  beq cr6, 0x821ba2fc
	if ctx.cr[6].eq {
	pc = 0x821BA2FC; continue 'dispatch;
	}
	// 821BA2A0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BA2A4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821BA2A8: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 821BA2AC: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BA2B0: 4098004C  bge cr6, 0x821ba2fc
	if !ctx.cr[6].lt {
	pc = 0x821BA2FC; continue 'dispatch;
	}
	// 821BA2B4: 7D06482E  lwzx r8, r6, r9
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821BA2B8: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821BA2BC: 806A000C  lwz r3, 0xc(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BA2C0: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BA2C4: 812700F8  lwz r9, 0xf8(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(248 as u32) ) } as u64;
	// 821BA2C8: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821BA2CC: 7F091840  cmplw cr6, r9, r3
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821BA2D0: 4198000C  blt cr6, 0x821ba2dc
	if ctx.cr[6].lt {
	pc = 0x821BA2DC; continue 'dispatch;
	}
	// 821BA2D4: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821BA2D8: 48000008  b 0x821ba2e0
	pc = 0x821BA2E0; continue 'dispatch;
            }
            0x821BA2DC => {
    //   block [0x821BA2DC..0x821BA2E0)
	// 821BA2DC: 912A0014  stw r9, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	pc = 0x821BA2E0; continue 'dispatch;
            }
            0x821BA2E0 => {
    //   block [0x821BA2E0..0x821BA2F0)
	// 821BA2E0: 9168001C  stw r11, 0x1c(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 821BA2E4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821BA2E8: 409A0008  bne cr6, 0x821ba2f0
	if !ctx.cr[6].eq {
	pc = 0x821BA2F0; continue 'dispatch;
	}
	// 821BA2EC: 908700B0  stw r4, 0xb0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(176 as u32), ctx.r[4].u32 ) };
	pc = 0x821BA2F0; continue 'dispatch;
            }
            0x821BA2F0 => {
    //   block [0x821BA2F0..0x821BA2FC)
	// 821BA2F0: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 821BA2F4: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 821BA2F8: 4BFFFF9C  b 0x821ba294
	pc = 0x821BA294; continue 'dispatch;
            }
            0x821BA2FC => {
    //   block [0x821BA2FC..0x821BA300)
	// 821BA2FC: 480EFDA5  bl 0x822aa0a0
	ctx.lr = 0x821BA300;
	sub_822AA0A0(ctx, base);
	pc = 0x821BA300; continue 'dispatch;
            }
            0x821BA300 => {
    //   block [0x821BA300..0x821BA31C)
	// 821BA300: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BA304: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BA308: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821BA30C: 40990010  ble cr6, 0x821ba31c
	if !ctx.cr[6].gt {
	pc = 0x821BA31C; continue 'dispatch;
	}
	// 821BA310: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 821BA314: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 821BA318: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	pc = 0x821BA31C; continue 'dispatch;
            }
            0x821BA31C => {
    //   block [0x821BA31C..0x821BA324)
	// 821BA31C: 419A0008  beq cr6, 0x821ba324
	if ctx.cr[6].eq {
	pc = 0x821BA324; continue 'dispatch;
	}
	// 821BA320: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x821BA324; continue 'dispatch;
            }
            0x821BA324 => {
    //   block [0x821BA324..0x821BA338)
	// 821BA324: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821BA328: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821BA32C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821BA330: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821BA334: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BA338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821BA338 size=288
    let mut pc: u32 = 0x821BA338;
    'dispatch: loop {
        match pc {
            0x821BA338 => {
    //   block [0x821BA338..0x821BA3A0)
	// 821BA338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BA33C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821BA340: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821BA344: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BA348: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821BA34C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821BA350: 392B4D60  addi r9, r11, 0x4d60
	ctx.r[9].s64 = ctx.r[11].s64 + 19808;
	// 821BA354: C02A9484  lfs f1, -0x6b7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821BA358: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BA35C: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BA360: 7D0A5850  subf r8, r10, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821BA364: 5507003A  rlwinm r7, r8, 0, 0, 0x1d
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 821BA368: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821BA36C: 419A0034  beq cr6, 0x821ba3a0
	if ctx.cr[6].eq {
	pc = 0x821BA3A0; continue 'dispatch;
	}
	// 821BA370: 83EBFFFC  lwz r31, -4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821BA374: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 821BA378: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 821BA37C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821BA380: 419A0020  beq cr6, 0x821ba3a0
	if ctx.cr[6].eq {
	pc = 0x821BA3A0; continue 'dispatch;
	}
	// 821BA384: 39600130  li r11, 0x130
	ctx.r[11].s64 = 304;
	// 821BA388: 3860007E  li r3, 0x7e
	ctx.r[3].s64 = 126;
	pc = 0x821BA3A0; continue 'dispatch;
            }
            0x821BA3A0 => {
    //   block [0x821BA3A0..0x821BA458)
	// 821BA3A0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821BA3A4: D0210050  stfs f1, 0x50(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821BA3A8: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 821BA3AC: D0210054  stfs f1, 0x54(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821BA3B0: 39210058  addi r9, r1, 0x58
	ctx.r[9].s64 = ctx.r[1].s64 + 88;
	// 821BA3B4: D0210058  stfs f1, 0x58(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821BA3B8: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 821BA3BC: D0210060  stfs f1, 0x60(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821BA3C0: 3860007E  li r3, 0x7e
	ctx.r[3].s64 = 126;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BA458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BA458 size=64
    let mut pc: u32 = 0x821BA458;
    'dispatch: loop {
        match pc {
            0x821BA458 => {
    //   block [0x821BA458..0x821BA484)
	// 821BA458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BA45C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821BA460: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821BA464: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BA468: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821BA46C: 989F002C  stb r4, 0x2c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[4].u8 ) };
	// 821BA470: 485A64B9  bl 0x82760928
	ctx.lr = 0x821BA474;
	sub_82760928(ctx, base);
	// 821BA474: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BA478: 419A000C  beq cr6, 0x821ba484
	if ctx.cr[6].eq {
	pc = 0x821BA484; continue 'dispatch;
	}
	// 821BA47C: 897F002C  lbz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821BA480: 99630024  stb r11, 0x24(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	pc = 0x821BA484; continue 'dispatch;
            }
            0x821BA484 => {
    //   block [0x821BA484..0x821BA498)
	// 821BA484: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821BA488: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821BA48C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821BA490: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821BA494: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BA498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821BA498 size=340
    let mut pc: u32 = 0x821BA498;
    'dispatch: loop {
        match pc {
            0x821BA498 => {
    //   block [0x821BA498..0x821BA59C)
	// 821BA498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BA49C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821BA4A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821BA4A4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BA4A8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821BA4AC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821BA4B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821BA4B4: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 821BA4B8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821BA4BC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 821BA4C0: C00A9484  lfs f0, -0x6b7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821BA4C4: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 821BA4C8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821BA4CC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821BA4D0: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 821BA4D4: 4801672D  bl 0x821d0c00
	ctx.lr = 0x821BA4D8;
	sub_821D0C00(ctx, base);
	// 821BA4D8: 8101005C  lwz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821BA4DC: 3BFF0048  addi r31, r31, 0x48
	ctx.r[31].s64 = ctx.r[31].s64 + 72;
	// 821BA4E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821BA4E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BA4E8: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 821BA4EC: 480C5D55  bl 0x82280240
	ctx.lr = 0x821BA4F0;
	sub_82280240(ctx, base);
	// 821BA4F0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821BA4F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BA4F8: 480089A1  bl 0x821c2e98
	ctx.lr = 0x821BA4FC;
	sub_821C2E98(ctx, base);
	// 821BA4FC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821BA500: 3CE08336  lis r7, -0x7cca
	ctx.r[7].s64 = -2093613056;
	// 821BA504: 3CC02000  lis r6, 0x2000
	ctx.r[6].s64 = 536870912;
	// 821BA508: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821BA50C: 80A50004  lwz r5, 4(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BA510: 80670364  lwz r3, 0x364(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(868 as u32) ) } as u64;
	// 821BA514: 4BFFC9CD  bl 0x821b6ee0
	ctx.lr = 0x821BA518;
	sub_821B6EE0(ctx, base);
	// 821BA518: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821BA51C: 3C808331  lis r4, -0x7ccf
	ctx.r[4].s64 = -2093940736;
	// 821BA520: 396B63A0  addi r11, r11, 0x63a0
	ctx.r[11].s64 = ctx.r[11].s64 + 25504;
	// 821BA524: 38646FCC  addi r3, r4, 0x6fcc
	ctx.r[3].s64 = ctx.r[4].s64 + 28620;
	// 821BA528: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821BA52C: 392A2390  addi r9, r10, 0x2390
	ctx.r[9].s64 = ctx.r[10].s64 + 9104;
	// 821BA530: 890B0915  lbz r8, 0x915(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2325 as u32) ) } as u64;
	// 821BA534: 80E30004  lwz r7, 4(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BA538: 1D082008  mulli r8, r8, 0x2008
	ctx.r[8].s32 = ((ctx.r[8].s32 as i64 * 8200 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 821BA53C: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821BA540: 814B0904  lwz r10, 0x904(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2308 as u32) ) } as u64;
	// 821BA544: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821BA548: 3949DFF8  addi r10, r9, -0x2008
	ctx.r[10].s64 = ctx.r[9].s64 + -8200;
	// 821BA54C: 419A008C  beq cr6, 0x821ba5d8
	if ctx.cr[6].eq {
	pc = 0x821BA5D8; continue 'dispatch;
	}
	// 821BA550: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821BA554: 810B0908  lwz r8, 0x908(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2312 as u32) ) } as u64;
	// 821BA558: 7D264038  and r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821BA55C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821BA560: 409A003C  bne cr6, 0x821ba59c
	if !ctx.cr[6].eq {
	pc = 0x821BA59C; continue 'dispatch;
	}
	// 821BA564: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821BA568: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821BA56C: 38AB0900  addi r5, r11, 0x900
	ctx.r[5].s64 = ctx.r[11].s64 + 2304;
	// 821BA570: 54C41838  slwi r4, r6, 3
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821BA574: 912B0908  stw r9, 0x908(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2312 as u32), ctx.r[9].u32 ) };
	// 821BA578: 7CA4512E  stwx r5, r4, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[10].u32), ctx.r[5].u32) };
	// 821BA57C: 812B0904  lwz r9, 0x904(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2308 as u32) ) } as u64;
	// 821BA580: 806A2004  lwz r3, 0x2004(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821BA584: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821BA588: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821BA58C: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821BA590: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821BA594: 38C90001  addi r6, r9, 1
	ctx.r[6].s64 = ctx.r[9].s64 + 1;
	// 821BA598: 90CA2004  stw r6, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[6].u32 ) };
	pc = 0x821BA59C; continue 'dispatch;
            }
            0x821BA59C => {
    //   block [0x821BA59C..0x821BA5D8)
	// 821BA59C: 894B0914  lbz r10, 0x914(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2324 as u32) ) } as u64;
	// 821BA5A0: 90EB0904  stw r7, 0x904(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2308 as u32), ctx.r[7].u32 ) };
	// 821BA5A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BA5A8: 409A0030  bne cr6, 0x821ba5d8
	if !ctx.cr[6].eq {
	pc = 0x821BA5D8; continue 'dispatch;
	}
	// 821BA5AC: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821BA5B0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821BA5B4: 390B0900  addi r8, r11, 0x900
	ctx.r[8].s64 = ctx.r[11].s64 + 2304;
	// 821BA5B8: 994B0914  stb r10, 0x914(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(2324 as u32), ctx.r[10].u8 ) };
	// 821BA5BC: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 821BA5C0: 81690DB0  lwz r11, 0xdb0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821BA5C4: 38C70DB8  addi r6, r7, 0xdb8
	ctx.r[6].s64 = ctx.r[7].s64 + 3512;
	// 821BA5C8: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821BA5CC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821BA5D0: 91690DB0  stw r11, 0xdb0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(3504 as u32), ctx.r[11].u32 ) };
	// 821BA5D4: 7D05312E  stwx r8, r5, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[6].u32), ctx.r[8].u32) };
	pc = 0x821BA5D8; continue 'dispatch;
            }
            0x821BA5D8 => {
    //   block [0x821BA5D8..0x821BA5EC)
	// 821BA5D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821BA5DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821BA5E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821BA5E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821BA5E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BA5F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BA5F0 size=784
    let mut pc: u32 = 0x821BA5F0;
    'dispatch: loop {
        match pc {
            0x821BA5F0 => {
    //   block [0x821BA5F0..0x821BA63C)
	// 821BA5F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BA5F4: 48AEEE05  bl 0x82ca93f8
	ctx.lr = 0x821BA5F8;
	sub_82CA93D0(ctx, base);
	// 821BA5F8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BA5FC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821BA600: F88100B8  std r4, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[4].u64 ) };
	// 821BA604: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 821BA608: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 821BA60C: FB2100C0  std r25, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[25].u64 ) };
	// 821BA610: 3B400018  li r26, 0x18
	ctx.r[26].s64 = 24;
	// 821BA614: FB0100C8  std r24, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[24].u64 ) };
	// 821BA618: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 821BA61C: 814100CC  lwz r10, 0xcc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 821BA620: 7D235050  subf r9, r3, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[3].s64;
	// 821BA624: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BA628: 7F69D3D6  divw r27, r9, r26
	ctx.r[27].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	// 821BA62C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BA630: 409A000C  bne cr6, 0x821ba63c
	if !ctx.cr[6].eq {
	pc = 0x821BA63C; continue 'dispatch;
	}
	// 821BA634: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821BA638: 48000010  b 0x821ba648
	pc = 0x821BA648; continue 'dispatch;
            }
            0x821BA63C => {
    //   block [0x821BA63C..0x821BA648)
	// 821BA63C: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BA640: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821BA644: 7D29D3D6  divw r9, r9, r26
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	pc = 0x821BA648; continue 'dispatch;
            }
            0x821BA648 => {
    //   block [0x821BA648..0x821BA67C)
	// 821BA648: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 821BA64C: 419A02AC  beq cr6, 0x821ba8f8
	if ctx.cr[6].eq {
	pc = 0x821BA8F8; continue 'dispatch;
	}
	// 821BA650: 80BD0008  lwz r5, 8(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BA654: 3D400AAA  lis r10, 0xaaa
	ctx.r[10].s64 = 178913280;
	// 821BA658: 7D0B2850  subf r8, r11, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 821BA65C: 614AAAAA  ori r10, r10, 0xaaaa
	ctx.r[10].u64 = ctx.r[10].u64 | 43690;
	// 821BA660: 7D68D3D6  divw r11, r8, r26
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[26].s32;
	// 821BA664: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821BA668: 7F07D840  cmplw cr6, r7, r27
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[27].u32, &mut ctx.xer);
	// 821BA66C: 40980010  bge cr6, 0x821ba67c
	if !ctx.cr[6].lt {
	pc = 0x821BA67C; continue 'dispatch;
	}
	// 821BA670: 4888CE59  bl 0x82a474c8
	ctx.lr = 0x821BA674;
	sub_82A474C8(ctx, base);
	// 821BA674: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821BA678: 48AEEDD0  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x821BA67C => {
    //   block [0x821BA67C..0x821BA6A0)
	// 821BA67C: 7D0BDA14  add r8, r11, r27
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 821BA680: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821BA684: 4098013C  bge cr6, 0x821ba7c0
	if !ctx.cr[6].lt {
	pc = 0x821BA7C0; continue 'dispatch;
	}
	// 821BA688: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821BA68C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821BA690: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821BA694: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821BA698: 41980008  blt cr6, 0x821ba6a0
	if ctx.cr[6].lt {
	pc = 0x821BA6A0; continue 'dispatch;
	}
	// 821BA69C: 7F8B4A14  add r28, r11, r9
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x821BA6A0; continue 'dispatch;
            }
            0x821BA6A0 => {
    //   block [0x821BA6A0..0x821BA6AC)
	// 821BA6A0: 7F1C4040  cmplw cr6, r28, r8
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821BA6A4: 40980008  bge cr6, 0x821ba6ac
	if !ctx.cr[6].lt {
	pc = 0x821BA6AC; continue 'dispatch;
	}
	// 821BA6A8: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	pc = 0x821BA6AC; continue 'dispatch;
            }
            0x821BA6AC => {
    //   block [0x821BA6AC..0x821BA6D0)
	// 821BA6AC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821BA6B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821BA6B4: 488C9A45  bl 0x82a840f8
	ctx.lr = 0x821BA6B8;
	sub_82A840F8(ctx, base);
	// 821BA6B8: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BA6BC: 83E100BC  lwz r31, 0xbc(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 821BA6C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821BA6C4: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821BA6C8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821BA6CC: 419A0040  beq cr6, 0x821ba70c
	if ctx.cr[6].eq {
	pc = 0x821BA70C; continue 'dispatch;
	}
	pc = 0x821BA6D0; continue 'dispatch;
            }
            0x821BA6D0 => {
    //   block [0x821BA6D0..0x821BA6E8)
	// 821BA6D0: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821BA6D4: 419A0028  beq cr6, 0x821ba6fc
	if ctx.cr[6].eq {
	pc = 0x821BA6FC; continue 'dispatch;
	}
	// 821BA6D8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821BA6DC: 7CAA2B78  mr r10, r5
	ctx.r[10].u64 = ctx.r[5].u64;
	// 821BA6E0: 39000006  li r8, 6
	ctx.r[8].s64 = 6;
	// 821BA6E4: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x821BA6E8; continue 'dispatch;
            }
            0x821BA6E8 => {
    //   block [0x821BA6E8..0x821BA6FC)
	// 821BA6E8: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA6EC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821BA6F0: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821BA6F4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821BA6F8: 4200FFF0  bdnz 0x821ba6e8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821BA6E8; continue 'dispatch;
	}
	pc = 0x821BA6FC; continue 'dispatch;
            }
            0x821BA6FC => {
    //   block [0x821BA6FC..0x821BA70C)
	// 821BA6FC: 39290018  addi r9, r9, 0x18
	ctx.r[9].s64 = ctx.r[9].s64 + 24;
	// 821BA700: 38A50018  addi r5, r5, 0x18
	ctx.r[5].s64 = ctx.r[5].s64 + 24;
	// 821BA704: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821BA708: 409AFFC8  bne cr6, 0x821ba6d0
	if !ctx.cr[6].eq {
	pc = 0x821BA6D0; continue 'dispatch;
	}
	pc = 0x821BA70C; continue 'dispatch;
            }
            0x821BA70C => {
    //   block [0x821BA70C..0x821BA730)
	// 821BA70C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821BA710: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821BA714: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 821BA718: 488CA281  bl 0x82a84998
	ctx.lr = 0x821BA71C;
	sub_82A84998(ctx, base);
	// 821BA71C: 80DD0008  lwz r6, 8(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BA720: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821BA724: 7F1F3040  cmplw cr6, r31, r6
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821BA728: 419A0044  beq cr6, 0x821ba76c
	if ctx.cr[6].eq {
	pc = 0x821BA76C; continue 'dispatch;
	}
	// 821BA72C: 7CEBF850  subf r7, r11, r31
	ctx.r[7].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	pc = 0x821BA730; continue 'dispatch;
            }
            0x821BA730 => {
    //   block [0x821BA730..0x821BA748)
	// 821BA730: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BA734: 419A0028  beq cr6, 0x821ba75c
	if ctx.cr[6].eq {
	pc = 0x821BA75C; continue 'dispatch;
	}
	// 821BA738: 7D475A14  add r10, r7, r11
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 821BA73C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 821BA740: 39000006  li r8, 6
	ctx.r[8].s64 = 6;
	// 821BA744: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x821BA748; continue 'dispatch;
            }
            0x821BA748 => {
    //   block [0x821BA748..0x821BA75C)
	// 821BA748: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA74C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821BA750: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821BA754: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 821BA758: 4200FFF0  bdnz 0x821ba748
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821BA748; continue 'dispatch;
	}
	pc = 0x821BA75C; continue 'dispatch;
            }
            0x821BA75C => {
    //   block [0x821BA75C..0x821BA76C)
	// 821BA75C: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 821BA760: 7D475A14  add r10, r7, r11
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 821BA764: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821BA768: 409AFFC8  bne cr6, 0x821ba730
	if !ctx.cr[6].eq {
	pc = 0x821BA730; continue 'dispatch;
	}
	pc = 0x821BA76C; continue 'dispatch;
            }
            0x821BA76C => {
    //   block [0x821BA76C..0x821BA78C)
	// 821BA76C: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BA770: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BA774: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BA778: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 821BA77C: 7D6AD3D6  divw r11, r10, r26
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[26].s32;
	// 821BA780: 7FEBDA14  add r31, r11, r27
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 821BA784: 419A0008  beq cr6, 0x821ba78c
	if ctx.cr[6].eq {
	pc = 0x821BA78C; continue 'dispatch;
	}
	// 821BA788: 480615B1  bl 0x8221bd38
	ctx.lr = 0x821BA78C;
	sub_8221BD38(ctx, base);
	pc = 0x821BA78C; continue 'dispatch;
            }
            0x821BA78C => {
    //   block [0x821BA78C..0x821BA7C0)
	// 821BA78C: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821BA790: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 821BA794: 578A083C  slwi r10, r28, 1
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821BA798: 7D3F5A14  add r9, r31, r11
	ctx.r[9].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 821BA79C: 7D5C5214  add r10, r28, r10
	ctx.r[10].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 821BA7A0: 552B1838  slwi r11, r9, 3
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821BA7A4: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821BA7A8: 7CEBF214  add r7, r11, r30
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821BA7AC: 7D0AF214  add r8, r10, r30
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 821BA7B0: 90FD0008  stw r7, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 821BA7B4: 911D000C  stw r8, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 821BA7B8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821BA7BC: 48AEEC8C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x821BA7C0 => {
    //   block [0x821BA7C0..0x821BA7F0)
	// 821BA7C0: 838100BC  lwz r28, 0xbc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 821BA7C4: 7D7C2850  subf r11, r28, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[28].s64;
	// 821BA7C8: 7D4BD3D6  divw r10, r11, r26
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[26].s32;
	// 821BA7CC: 576B083C  slwi r11, r27, 1
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821BA7D0: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 821BA7D4: 7D7B5A14  add r11, r27, r11
	ctx.r[11].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 821BA7D8: 409800B0  bge cr6, 0x821ba888
	if !ctx.cr[6].lt {
	pc = 0x821BA888; continue 'dispatch;
	}
	// 821BA7DC: 557E1838  slwi r30, r11, 3
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821BA7E0: 7F1C2840  cmplw cr6, r28, r5
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821BA7E4: 7D3EE214  add r9, r30, r28
	ctx.r[9].u64 = ctx.r[30].u64 + ctx.r[28].u64;
	// 821BA7E8: 419A0044  beq cr6, 0x821ba82c
	if ctx.cr[6].eq {
	pc = 0x821BA82C; continue 'dispatch;
	}
	// 821BA7EC: 7CFE4850  subf r7, r30, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[30].s64;
	pc = 0x821BA7F0; continue 'dispatch;
            }
            0x821BA7F0 => {
    //   block [0x821BA7F0..0x821BA808)
	// 821BA7F0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821BA7F4: 419A0028  beq cr6, 0x821ba81c
	if ctx.cr[6].eq {
	pc = 0x821BA81C; continue 'dispatch;
	}
	// 821BA7F8: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 821BA7FC: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 821BA800: 39000006  li r8, 6
	ctx.r[8].s64 = 6;
	// 821BA804: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x821BA808; continue 'dispatch;
            }
            0x821BA808 => {
    //   block [0x821BA808..0x821BA81C)
	// 821BA808: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA80C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821BA810: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821BA814: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821BA818: 4200FFF0  bdnz 0x821ba808
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821BA808; continue 'dispatch;
	}
	pc = 0x821BA81C; continue 'dispatch;
            }
            0x821BA81C => {
    //   block [0x821BA81C..0x821BA82C)
	// 821BA81C: 38E70018  addi r7, r7, 0x18
	ctx.r[7].s64 = ctx.r[7].s64 + 24;
	// 821BA820: 39290018  addi r9, r9, 0x18
	ctx.r[9].s64 = ctx.r[9].s64 + 24;
	// 821BA824: 7F072840  cmplw cr6, r7, r5
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821BA828: 409AFFC8  bne cr6, 0x821ba7f0
	if !ctx.cr[6].eq {
	pc = 0x821BA7F0; continue 'dispatch;
	}
	pc = 0x821BA82C; continue 'dispatch;
            }
            0x821BA82C => {
    //   block [0x821BA82C..0x821BA888)
	// 821BA82C: 80BD0008  lwz r5, 8(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BA830: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821BA834: FB210050  std r25, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u64 ) };
	// 821BA838: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821BA83C: 7D7C2850  subf r11, r28, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[28].s64;
	// 821BA840: 7D6BD3D6  divw r11, r11, r26
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[26].s32;
	// 821BA844: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821BA848: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821BA84C: 554B1838  slwi r11, r10, 3
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821BA850: 7D2B1A14  add r9, r11, r3
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 821BA854: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821BA858: EBE10050  ld r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821BA85C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BA860: 488CA139  bl 0x82a84998
	ctx.lr = 0x821BA864;
	sub_82A84998(ctx, base);
	// 821BA864: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BA868: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821BA86C: 7D1E5A14  add r8, r30, r11
	ctx.r[8].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 821BA870: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821BA874: 911D0008  stw r8, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 821BA878: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 821BA87C: 488C9F8D  bl 0x82a84808
	ctx.lr = 0x821BA880;
	sub_82A84808(ctx, base);
	// 821BA880: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821BA884: 48AEEBC4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x821BA888 => {
    //   block [0x821BA888..0x821BA8A0)
	// 821BA888: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821BA88C: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 821BA890: 7C8A2850  subf r4, r10, r5
	ctx.r[4].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 821BA894: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 821BA898: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821BA89C: 419A0040  beq cr6, 0x821ba8dc
	if ctx.cr[6].eq {
	pc = 0x821BA8DC; continue 'dispatch;
	}
	pc = 0x821BA8A0; continue 'dispatch;
            }
            0x821BA8A0 => {
    //   block [0x821BA8A0..0x821BA8B8)
	// 821BA8A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821BA8A4: 419A0028  beq cr6, 0x821ba8cc
	if ctx.cr[6].eq {
	pc = 0x821BA8CC; continue 'dispatch;
	}
	// 821BA8A8: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 821BA8AC: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 821BA8B0: 38E00006  li r7, 6
	ctx.r[7].s64 = 6;
	// 821BA8B4: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	pc = 0x821BA8B8; continue 'dispatch;
            }
            0x821BA8B8 => {
    //   block [0x821BA8B8..0x821BA8CC)
	// 821BA8B8: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BA8BC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821BA8C0: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821BA8C4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821BA8C8: 4200FFF0  bdnz 0x821ba8b8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821BA8B8; continue 'dispatch;
	}
	pc = 0x821BA8CC; continue 'dispatch;
            }
            0x821BA8CC => {
    //   block [0x821BA8CC..0x821BA8DC)
	// 821BA8CC: 39080018  addi r8, r8, 0x18
	ctx.r[8].s64 = ctx.r[8].s64 + 24;
	// 821BA8D0: 39290018  addi r9, r9, 0x18
	ctx.r[9].s64 = ctx.r[9].s64 + 24;
	// 821BA8D4: 7F082840  cmplw cr6, r8, r5
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821BA8D8: 409AFFC8  bne cr6, 0x821ba8a0
	if !ctx.cr[6].eq {
	pc = 0x821BA8A0; continue 'dispatch;
	}
	pc = 0x821BA8DC; continue 'dispatch;
            }
            0x821BA8DC => {
    //   block [0x821BA8DC..0x821BA8F8)
	// 821BA8DC: 913D0008  stw r9, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 821BA8E0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821BA8E4: 488C98F5  bl 0x82a841d8
	ctx.lr = 0x821BA8E8;
	sub_82A841D8(ctx, base);
	// 821BA8E8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821BA8EC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821BA8F0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 821BA8F4: 488C9F15  bl 0x82a84808
	ctx.lr = 0x821BA8F8;
	sub_82A84808(ctx, base);
	pc = 0x821BA8F8; continue 'dispatch;
            }
            0x821BA8F8 => {
    //   block [0x821BA8F8..0x821BA900)
	// 821BA8F8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821BA8FC: 48AEEB4C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BA900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821BA900 size=212
    let mut pc: u32 = 0x821BA900;
    'dispatch: loop {
        match pc {
            0x821BA900 => {
    //   block [0x821BA900..0x821BA9D4)
	// 821BA900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BA904: 48AEEB05  bl 0x82ca9408
	ctx.lr = 0x821BA908;
	sub_82CA93D0(ctx, base);
	// 821BA908: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BA9D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821BA9D8 size=640
    let mut pc: u32 = 0x821BA9D8;
    'dispatch: loop {
        match pc {
            0x821BA9D8 => {
    //   block [0x821BA9D8..0x821BAA4C)
	// 821BA9D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BA9DC: 48AEEA25  bl 0x82ca9400
	ctx.lr = 0x821BA9E0;
	sub_82CA93D0(ctx, base);
	// 821BA9E0: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 821BA9E4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BA9E8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821BA9EC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821BA9F0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821BA9F4: 3B6B9490  addi r27, r11, -0x6b70
	ctx.r[27].s64 = ctx.r[11].s64 + -27504;
	// 821BA9F8: 3B40FFFF  li r26, -1
	ctx.r[26].s64 = -1;
	// 821BA9FC: 815D0058  lwz r10, 0x58(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(88 as u32) ) } as u64;
	// 821BAA00: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BAA04: C3FBFFF4  lfs f31, -0xc(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821BAA08: 40990090  ble cr6, 0x821baa98
	if !ctx.cr[6].gt {
	pc = 0x821BAA98; continue 'dispatch;
	}
	// 821BAA0C: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 821BAA10: 48064849  bl 0x8221f258
	ctx.lr = 0x821BAA14;
	sub_8221F258(ctx, base);
	// 821BAA14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BAA18: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821BAA1C: 419A0178  beq cr6, 0x821bab94
	if ctx.cr[6].eq {
	pc = 0x821BAB94; continue 'dispatch;
	}
	// 821BAA20: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 821BAA24: 93A30004  stw r29, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 821BAA28: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 821BAA2C: 390B9260  addi r8, r11, -0x6da0
	ctx.r[8].s64 = ctx.r[11].s64 + -28064;
	// 821BAA30: 38C77088  addi r6, r7, 0x7088
	ctx.r[6].s64 = ctx.r[7].s64 + 28808;
	// 821BAA34: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821BAA38: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 821BAA3C: 93C3000C  stw r30, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 821BAA40: 80BD0058  lwz r5, 0x58(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(88 as u32) ) } as u64;
	// 821BAA44: 90A30010  stw r5, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[5].u32 ) };
	// 821BAA48: 93C30014  stw r30, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	pc = 0x821BAA4C; continue 'dispatch;
            }
            0x821BAA4C => {
    //   block [0x821BAA4C..0x821BAA98)
	// 821BAA4C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821BAA50: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BAA54: 7D403028  lwarx r10, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821BAA58: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821BAA5C: 7D40312D  stwcx. r10, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821BAA60: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BAA64: 4082FFE8  bne 0x821baa4c
	if !ctx.cr[0].eq {
	pc = 0x821BAA4C; continue 'dispatch;
	}
	// 821BAA68: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 821BAA6C: 93C30018  stw r30, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 821BAA70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821BAA74: 93C3001C  stw r30, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 821BAA78: 39442BF4  addi r10, r4, 0x2bf4
	ctx.r[10].s64 = ctx.r[4].s64 + 11252;
	// 821BAA7C: 93430020  stw r26, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[26].u32 ) };
	// 821BAA80: D3E30028  stfs f31, 0x28(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 821BAA84: 99630024  stb r11, 0x24(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 821BAA88: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821BAA8C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821BAA90: 93C3002C  stw r30, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 821BAA94: 48000104  b 0x821bab98
	pc = 0x821BAB98; continue 'dispatch;
            }
            0x821BAA98 => {
    //   block [0x821BAA98..0x821BAAC4)
	// 821BAA98: 817D005C  lwz r11, 0x5c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(92 as u32) ) } as u64;
	// 821BAA9C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821BAAA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BAAA4: 419A0020  beq cr6, 0x821baac4
	if ctx.cr[6].eq {
	pc = 0x821BAAC4; continue 'dispatch;
	}
	// 821BAAA8: 817D0060  lwz r11, 0x60(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) } as u64;
	// 821BAAAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BAAB0: 419A0014  beq cr6, 0x821baac4
	if ctx.cr[6].eq {
	pc = 0x821BAAC4; continue 'dispatch;
	}
	// 821BAAB4: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 821BAAB8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821BAABC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821BAAC0: 409A0008  bne cr6, 0x821baac8
	if !ctx.cr[6].eq {
	pc = 0x821BAAC8; continue 'dispatch;
	}
	pc = 0x821BAAC4; continue 'dispatch;
            }
            0x821BAAC4 => {
    //   block [0x821BAAC4..0x821BAAC8)
	// 821BAAC4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821BAAC8; continue 'dispatch;
            }
            0x821BAAC8 => {
    //   block [0x821BAAC8..0x821BAB0C)
	// 821BAAC8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821BAACC: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 821BAAD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BAAD4: 419A0090  beq cr6, 0x821bab64
	if ctx.cr[6].eq {
	pc = 0x821BAB64; continue 'dispatch;
	}
	// 821BAAD8: 48064781  bl 0x8221f258
	ctx.lr = 0x821BAADC;
	sub_8221F258(ctx, base);
	// 821BAADC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BAAE0: 419A00B4  beq cr6, 0x821bab94
	if ctx.cr[6].eq {
	pc = 0x821BAB94; continue 'dispatch;
	}
	// 821BAAE4: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 821BAAE8: 93A30004  stw r29, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 821BAAEC: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821BAAF0: 38EB9260  addi r7, r11, -0x6da0
	ctx.r[7].s64 = ctx.r[11].s64 + -28064;
	// 821BAAF4: 38C97088  addi r6, r9, 0x7088
	ctx.r[6].s64 = ctx.r[9].s64 + 28808;
	// 821BAAF8: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821BAAFC: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 821BAB00: 93C3000C  stw r30, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 821BAB04: 93C30010  stw r30, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 821BAB08: 93C30014  stw r30, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	pc = 0x821BAB0C; continue 'dispatch;
            }
            0x821BAB0C => {
    //   block [0x821BAB0C..0x821BAB64)
	// 821BAB0C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 821BAB10: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BAB14: 7D403028  lwarx r10, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821BAB18: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821BAB1C: 7D40312D  stwcx. r10, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821BAB20: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BAB24: 4082FFE8  bne 0x821bab0c
	if !ctx.cr[0].eq {
	pc = 0x821BAB0C; continue 'dispatch;
	}
	// 821BAB28: 809D005C  lwz r4, 0x5c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(92 as u32) ) } as u64;
	// 821BAB2C: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 821BAB30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821BAB34: 39452BF4  addi r10, r5, 0x2bf4
	ctx.r[10].s64 = ctx.r[5].s64 + 11252;
	// 821BAB38: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821BAB3C: 90830018  stw r4, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[4].u32 ) };
	// 821BAB40: 813D0060  lwz r9, 0x60(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) } as u64;
	// 821BAB44: 9123001C  stw r9, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 821BAB48: 811D0064  lwz r8, 0x64(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 821BAB4C: D3E30028  stfs f31, 0x28(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 821BAB50: 91030020  stw r8, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[8].u32 ) };
	// 821BAB54: 99630024  stb r11, 0x24(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 821BAB58: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821BAB5C: 93C3002C  stw r30, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 821BAB60: 48000038  b 0x821bab98
	pc = 0x821BAB98; continue 'dispatch;
            }
            0x821BAB64 => {
    //   block [0x821BAB64..0x821BAB94)
	// 821BAB64: 480646F5  bl 0x8221f258
	ctx.lr = 0x821BAB68;
	sub_8221F258(ctx, base);
	// 821BAB68: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821BAB6C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821BAB70: 419A0024  beq cr6, 0x821bab94
	if ctx.cr[6].eq {
	pc = 0x821BAB94; continue 'dispatch;
	}
	// 821BAB74: 38BD0054  addi r5, r29, 0x54
	ctx.r[5].s64 = ctx.r[29].s64 + 84;
	// 821BAB78: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821BAB7C: 487B7035  bl 0x82971bb0
	ctx.lr = 0x821BAB80;
	sub_82971BB0(ctx, base);
	// 821BAB80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821BAB84: 394B2BF4  addi r10, r11, 0x2bf4
	ctx.r[10].s64 = ctx.r[11].s64 + 11252;
	// 821BAB88: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821BAB8C: 93DC002C  stw r30, 0x2c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 821BAB90: 48000008  b 0x821bab98
	pc = 0x821BAB98; continue 'dispatch;
            }
            0x821BAB94 => {
    //   block [0x821BAB94..0x821BAB98)
	// 821BAB94: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	pc = 0x821BAB98; continue 'dispatch;
            }
            0x821BAB98 => {
    //   block [0x821BAB98..0x821BAC28)
	// 821BAB98: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821BAB9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BABA0: 48000F11  bl 0x821bbab0
	ctx.lr = 0x821BABA4;
	sub_821BBAB0(ctx, base);
	// 821BABA4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821BABA8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821BABAC: 480B12BD  bl 0x8226be68
	ctx.lr = 0x821BABB0;
	sub_8226BE68(ctx, base);
	// 821BABB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BABB4: 4BFFCF65  bl 0x821b7b18
	ctx.lr = 0x821BABB8;
	sub_821B7B18(ctx, base);
	// 821BABB8: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 821BABBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BABC0: 419A0088  beq cr6, 0x821bac48
	if ctx.cr[6].eq {
	pc = 0x821BAC48; continue 'dispatch;
	}
	// 821BABC4: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 821BABC8: 48064691  bl 0x8221f258
	ctx.lr = 0x821BABCC;
	sub_8221F258(ctx, base);
	// 821BABCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821BABD0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821BABD4: 419A0054  beq cr6, 0x821bac28
	if ctx.cr[6].eq {
	pc = 0x821BAC28; continue 'dispatch;
	}
	// 821BABD8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BABDC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821BABE0: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821BABE4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821BABE8: 4E800421  bctrl
	ctx.lr = 0x821BABEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BABEC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821BABF0: C01B0000  lfs f0, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821BABF4: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 821BABF8: 390921E0  addi r8, r9, 0x21e0
	ctx.r[8].s64 = ctx.r[9].s64 + 8672;
	// 821BABFC: D3FF0008  stfs f31, 8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821BAC00: D3FF000C  stfs f31, 0xc(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821BAC04: 935F0018  stw r26, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[26].u32 ) };
	// 821BAC08: D03F0010  stfs f1, 0x10(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821BAC0C: 9BDF001C  stb r30, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 821BAC10: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821BAC14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821BAC18: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821BAC1C: 9BDF001D  stb r30, 0x1d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(29 as u32), ctx.r[30].u8 ) };
	// 821BAC20: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821BAC24: 48000008  b 0x821bac2c
	pc = 0x821BAC2C; continue 'dispatch;
            }
            0x821BAC28 => {
    //   block [0x821BAC28..0x821BAC2C)
	// 821BAC28: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	pc = 0x821BAC2C; continue 'dispatch;
            }
            0x821BAC2C => {
    //   block [0x821BAC2C..0x821BAC48)
	// 821BAC2C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821BAC30: 48000E81  bl 0x821bbab0
	ctx.lr = 0x821BAC34;
	sub_821BBAB0(ctx, base);
	// 821BAC34: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821BAC38: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821BAC3C: 480B122D  bl 0x8226be68
	ctx.lr = 0x821BAC40;
	sub_8226BE68(ctx, base);
	// 821BAC40: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821BAC44: 4BFFCED5  bl 0x821b7b18
	ctx.lr = 0x821BAC48;
	sub_821B7B18(ctx, base);
	pc = 0x821BAC48; continue 'dispatch;
            }
            0x821BAC48 => {
    //   block [0x821BAC48..0x821BAC58)
	// 821BAC48: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821BAC4C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821BAC50: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 821BAC54: 48AEE7FC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BAC58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821BAC58 size=2556
    let mut pc: u32 = 0x821BAC58;
    'dispatch: loop {
        match pc {
            0x821BAC58 => {
    //   block [0x821BAC58..0x821BB654)
	// 821BAC58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BAC5C: 48AEE795  bl 0x82ca93f0
	ctx.lr = 0x821BAC60;
	sub_82CA93D0(ctx, base);
	// 821BAC60: DBA1FF90  stfd f29, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[29].u64 ) };
	// 821BAC64: DBC1FF98  stfd f30, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[30].u64 ) };
	// 821BAC68: DBE1FFA0  stfd f31, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 821BAC6C: 3980FF80  li r12, -0x80
	ctx.r[12].s64 = -128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BB658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821BB658 size=548
    let mut pc: u32 = 0x821BB658;
    'dispatch: loop {
        match pc {
            0x821BB658 => {
    //   block [0x821BB658..0x821BB874)
	// 821BB658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BB65C: 48AEDDAD  bl 0x82ca9408
	ctx.lr = 0x821BB660;
	sub_82CA93D0(ctx, base);
	// 821BB660: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BB664: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821BB668: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821BB66C: 3B8B9484  addi r28, r11, -0x6b7c
	ctx.r[28].s64 = ctx.r[11].s64 + -27516;
	// 821BB670: C03C0054  lfs f1, 0x54(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(84 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821BB674: 480349CD  bl 0x821f0040
	ctx.lr = 0x821BB678;
	sub_821F0040(ctx, base);
	// 821BB678: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821BB67C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BB680: 419A01F4  beq cr6, 0x821bb874
	if ctx.cr[6].eq {
	pc = 0x821BB874; continue 'dispatch;
	}
	// 821BB684: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BB688: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 821BB68C: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821BB690: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB694: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821BB698: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821BB69C: 4E800421  bctrl
	ctx.lr = 0x821BB6A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BB6A0: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BB6A4: 390100A0  addi r8, r1, 0xa0
	ctx.r[8].s64 = ctx.r[1].s64 + 160;
	// 821BB6A8: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 821BB6AC: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 821BB6B0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 821BB6B4: 8085007C  lwz r4, 0x7c(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(124 as u32) ) } as u64;
            }
            0x821BB874 => {
    //   block [0x821BB874..0x821BB87C)
	// 821BB874: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 821BB878: 48AEDBE0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BB880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821BB880 size=560
    let mut pc: u32 = 0x821BB880;
    'dispatch: loop {
        match pc {
            0x821BB880 => {
    //   block [0x821BB880..0x821BB924)
	// 821BB880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BB884: 48AEDB4D  bl 0x82ca93d0
	ctx.lr = 0x821BB888;
	sub_82CA93D0(ctx, base);
	// 821BB888: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BB88C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BB890: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 821BB894: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 821BB898: 3A400000  li r18, 0
	ctx.r[18].s64 = 0;
	// 821BB89C: 3DE08349  lis r15, -0x7cb7
	ctx.r[15].s64 = -2092367872;
	// 821BB8A0: 7E4A9378  mr r10, r18
	ctx.r[10].u64 = ctx.r[18].u64;
	// 821BB8A4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BB8A8: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 821BB8AC: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 821BB8B0: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 821BB8B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821BB8B8: 812F6C10  lwz r9, 0x6c10(r15)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(27664 as u32) ) } as u64;
	// 821BB8BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821BB8C0: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 821BB8C4: 3BE90001  addi r31, r9, 1
	ctx.r[31].s64 = ctx.r[9].s64 + 1;
	// 821BB8C8: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 821BB8CC: 93EF6C10  stw r31, 0x6c10(r15)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[15].u32.wrapping_add(27664 as u32), ctx.r[31].u32 ) };
	// 821BB8D0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821BB8D4: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BB8D8: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 821BB8DC: 82690064  lwz r19, 0x64(r9)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 821BB8E0: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 821BB8E4: 480AA145  bl 0x82265a28
	ctx.lr = 0x821BB8E8;
	sub_82265A28(ctx, base);
	// 821BB8E8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821BB8EC: 92410050  stw r18, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[18].u32 ) };
	// 821BB8F0: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 821BB8F4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821BB8F8: 409901B0  ble cr6, 0x821bbaa8
	if !ctx.cr[6].gt {
	pc = 0x821BBAA8; continue 'dispatch;
	}
	// 821BB8FC: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 821BB900: 7E549378  mr r20, r18
	ctx.r[20].u64 = ctx.r[18].u64;
	// 821BB904: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821BB908: 3A200001  li r17, 1
	ctx.r[17].s64 = 1;
	// 821BB90C: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 821BB910: 38EAFFFF  addi r7, r10, -1
	ctx.r[7].s64 = ctx.r[10].s64 + -1;
	// 821BB914: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821BB918: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 821BB91C: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 821BB920: 39CBA2F8  addi r14, r11, -0x5d08
	ctx.r[14].s64 = ctx.r[11].s64 + -23816;
	pc = 0x821BB924; continue 'dispatch;
            }
            0x821BB924 => {
    //   block [0x821BB924..0x821BB970)
	// 821BB924: 396E0004  addi r11, r14, 4
	ctx.r[11].s64 = ctx.r[14].s64 + 4;
	// 821BB928: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821BB92C: 81010064  lwz r8, 0x64(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821BB930: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821BB934: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821BB938: 7CB4582E  lwzx r5, r20, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[20].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821BB93C: 7D592E30  sraw r25, r10, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[25].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 821BB940: 7D0A2E30  sraw r10, r8, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> tmp.u32) as i64;
	// 821BB944: 7CEB2E30  sraw r11, r7, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> tmp.u32) as i64;
	// 821BB948: 3ACB0001  addi r22, r11, 1
	ctx.r[22].s64 = ctx.r[11].s64 + 1;
	// 821BB94C: 7CCB2E30  sraw r11, r6, r5
	tmp.u32 = ctx.r[5].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[6].s32 >> tmp.u32) as i64;
	// 821BB950: 7C99B051  subf. r4, r25, r22
	ctx.r[4].s64 = ctx.r[22].s64 - ctx.r[25].s64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821BB954: 3A0B0001  addi r16, r11, 1
	ctx.r[16].s64 = ctx.r[11].s64 + 1;
	// 821BB958: 41820134  beq 0x821bba8c
	if ctx.cr[0].eq {
	pc = 0x821BBA8C; continue 'dispatch;
	}
	// 821BB95C: 7D6A8051  subf. r11, r10, r16
	ctx.r[11].s64 = ctx.r[16].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BB960: 4182012C  beq 0x821bba8c
	if ctx.cr[0].eq {
	pc = 0x821BBA8C; continue 'dispatch;
	}
	// 821BB964: 7D555378  mr r21, r10
	ctx.r[21].u64 = ctx.r[10].u64;
	// 821BB968: 7F0A8000  cmpw cr6, r10, r16
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[16].s32, &mut ctx.xer);
	// 821BB96C: 40980120  bge cr6, 0x821bba8c
	if !ctx.cr[6].lt {
	pc = 0x821BBA8C; continue 'dispatch;
	}
	pc = 0x821BB970; continue 'dispatch;
            }
            0x821BB970 => {
    //   block [0x821BB970..0x821BB9A4)
	// 821BB970: 81730008  lwz r11, 8(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BB974: 7F37CB78  mr r23, r25
	ctx.r[23].u64 = ctx.r[25].u64;
	// 821BB978: 81530018  lwz r10, 0x18(r19)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(24 as u32) ) } as u64;
	// 821BB97C: 7F19B000  cmpw cr6, r25, r22
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[22].s32, &mut ctx.xer);
	// 821BB980: 7D725A14  add r11, r18, r11
	ctx.r[11].u64 = ctx.r[18].u64 + ctx.r[11].u64;
	// 821BB984: 7D4AA214  add r10, r10, r20
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[20].u64;
	// 821BB988: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BB98C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BB990: 7D69A9D6  mullw r11, r9, r21
	ctx.r[11].s32 = ((ctx.r[9].s32 as i64 * ctx.r[21].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821BB994: 7D0BCA14  add r8, r11, r25
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 821BB998: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821BB99C: 7F0B5214  add r24, r11, r10
	ctx.r[24].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821BB9A0: 409800D8  bge cr6, 0x821bba78
	if !ctx.cr[6].lt {
	pc = 0x821BBA78; continue 'dispatch;
	}
	pc = 0x821BB9A4; continue 'dispatch;
            }
            0x821BB9A4 => {
    //   block [0x821BB9A4..0x821BB9B0)
	// 821BB9A4: 83580000  lwz r26, 0(r24)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB9A8: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 821BB9AC: 419A00BC  beq cr6, 0x821bba68
	if ctx.cr[6].eq {
	pc = 0x821BBA68; continue 'dispatch;
	}
	pc = 0x821BB9B0; continue 'dispatch;
            }
            0x821BB9B0 => {
    //   block [0x821BB9B0..0x821BBA00)
	// 821BB9B0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB9B4: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821BB9B8: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821BB9BC: 409800A0  bge cr6, 0x821bba5c
	if !ctx.cr[6].lt {
	pc = 0x821BBA5C; continue 'dispatch;
	}
	// 821BB9C0: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 821BB9C4: 838B0004  lwz r28, 4(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BB9C8: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB9CC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821BB9D0: 48047C11  bl 0x822035e0
	ctx.lr = 0x821BB9D4;
	sub_822035E0(ctx, base);
	// 821BB9D4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821BB9D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BB9DC: 419A0070  beq cr6, 0x821bba4c
	if ctx.cr[6].eq {
	pc = 0x821BBA4C; continue 'dispatch;
	}
	// 821BB9E0: 83BB0004  lwz r29, 4(r27)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BB9E4: 3BDC0024  addi r30, r28, 0x24
	ctx.r[30].s64 = ctx.r[28].s64 + 36;
	// 821BB9E8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB9EC: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BB9F0: 2B1F00FE  cmplwi cr6, r31, 0xfe
	ctx.cr[6].compare_u32(ctx.r[31].u32, 254 as u32, &mut ctx.xer);
	// 821BB9F4: 4198000C  blt cr6, 0x821bba00
	if ctx.cr[6].lt {
	pc = 0x821BBA00; continue 'dispatch;
	}
	// 821BB9F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BB9FC: 48135255  bl 0x822f0c50
	ctx.lr = 0x821BBA00;
	sub_822F0C50(ctx, base);
	pc = 0x821BBA00; continue 'dispatch;
            }
            0x821BBA00 => {
    //   block [0x821BBA00..0x821BBA38)
	// 821BBA00: 57EBE8FA  rlwinm r11, r31, 0x1d, 3, 0x1d
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000007u64;
	// 821BBA04: 57EA06FE  clrlwi r10, r31, 0x1b
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x0000001Fu64;
	// 821BBA08: 7E295030  slw r9, r17, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[17].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 821BBA0C: 7D0BF02E  lwzx r8, r11, r30
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 821BBA10: 7D274038  and r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821BBA14: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821BBA18: 409A0020  bne cr6, 0x821bba38
	if !ctx.cr[6].eq {
	pc = 0x821BBA38; continue 'dispatch;
	}
	// 821BBA1C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821BBA20: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BBA24: 480446C5  bl 0x822000e8
	ctx.lr = 0x821BBA28;
	sub_822000E8(ctx, base);
	// 821BBA28: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821BBA2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BBA30: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 821BBA34: 409A0008  bne cr6, 0x821bba3c
	if !ctx.cr[6].eq {
	pc = 0x821BBA3C; continue 'dispatch;
	}
	pc = 0x821BBA38; continue 'dispatch;
            }
            0x821BBA38 => {
    //   block [0x821BBA38..0x821BBA3C)
	// 821BBA38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821BBA3C; continue 'dispatch;
            }
            0x821BBA3C => {
    //   block [0x821BBA3C..0x821BBA4C)
	// 821BBA3C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821BBA40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BBA44: 419A0008  beq cr6, 0x821bba4c
	if ctx.cr[6].eq {
	pc = 0x821BBA4C; continue 'dispatch;
	}
	// 821BBA48: 939B0008  stw r28, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	pc = 0x821BBA4C; continue 'dispatch;
            }
            0x821BBA4C => {
    //   block [0x821BBA4C..0x821BBA5C)
	// 821BBA4C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BBA50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BBA54: 409A0054  bne cr6, 0x821bbaa8
	if !ctx.cr[6].eq {
	pc = 0x821BBAA8; continue 'dispatch;
	}
	// 821BBA58: 83EF6C10  lwz r31, 0x6c10(r15)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(27664 as u32) ) } as u64;
	pc = 0x821BBA5C; continue 'dispatch;
            }
            0x821BBA5C => {
    //   block [0x821BBA5C..0x821BBA68)
	// 821BBA5C: 835A0004  lwz r26, 4(r26)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BBA60: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 821BBA64: 409AFF4C  bne cr6, 0x821bb9b0
	if !ctx.cr[6].eq {
	pc = 0x821BB9B0; continue 'dispatch;
	}
	pc = 0x821BBA68; continue 'dispatch;
            }
            0x821BBA68 => {
    //   block [0x821BBA68..0x821BBA78)
	// 821BBA68: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 821BBA6C: 3B180004  addi r24, r24, 4
	ctx.r[24].s64 = ctx.r[24].s64 + 4;
	// 821BBA70: 7F17B000  cmpw cr6, r23, r22
	ctx.cr[6].compare_i32(ctx.r[23].s32, ctx.r[22].s32, &mut ctx.xer);
	// 821BBA74: 4198FF30  blt cr6, 0x821bb9a4
	if ctx.cr[6].lt {
	pc = 0x821BB9A4; continue 'dispatch;
	}
	pc = 0x821BBA78; continue 'dispatch;
            }
            0x821BBA78 => {
    //   block [0x821BBA78..0x821BBA8C)
	// 821BBA78: 3AB50001  addi r21, r21, 1
	ctx.r[21].s64 = ctx.r[21].s64 + 1;
	// 821BBA7C: 7F158000  cmpw cr6, r21, r16
	ctx.cr[6].compare_i32(ctx.r[21].s32, ctx.r[16].s32, &mut ctx.xer);
	// 821BBA80: 4198FEF0  blt cr6, 0x821bb970
	if ctx.cr[6].lt {
	pc = 0x821BB970; continue 'dispatch;
	}
	// 821BBA84: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821BBA88: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	pc = 0x821BBA8C; continue 'dispatch;
            }
            0x821BBA8C => {
    //   block [0x821BBA8C..0x821BBAA8)
	// 821BBA8C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821BBA90: 3A520014  addi r18, r18, 0x14
	ctx.r[18].s64 = ctx.r[18].s64 + 20;
	// 821BBA94: 3A940010  addi r20, r20, 0x10
	ctx.r[20].s64 = ctx.r[20].s64 + 16;
	// 821BBA98: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821BBA9C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821BBAA0: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821BBAA4: 4198FE80  blt cr6, 0x821bb924
	if ctx.cr[6].lt {
	pc = 0x821BB924; continue 'dispatch;
	}
	pc = 0x821BBAA8; continue 'dispatch;
            }
            0x821BBAA8 => {
    //   block [0x821BBAA8..0x821BBAB0)
	// 821BBAA8: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 821BBAAC: 48AED974  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BBAB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BBAB0 size=116
    let mut pc: u32 = 0x821BBAB0;
    'dispatch: loop {
        match pc {
            0x821BBAB0 => {
    //   block [0x821BBAB0..0x821BBB04)
	// 821BBAB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BBAB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821BBAB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821BBABC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BBAC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821BBAC4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821BBAC8: 909F0000  stw r4, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 821BBACC: 419A0038  beq cr6, 0x821bbb04
	if ctx.cr[6].eq {
	pc = 0x821BBB04; continue 'dispatch;
	}
	// 821BBAD0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 821BBAD4: 48063785  bl 0x8221f258
	ctx.lr = 0x821BBAD8;
	sub_8221F258(ctx, base);
	// 821BBAD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BBADC: 419A0028  beq cr6, 0x821bbb04
	if ctx.cr[6].eq {
	pc = 0x821BBB04; continue 'dispatch;
	}
	// 821BBAE0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BBAE4: 3D208256  lis r9, -0x7daa
	ctx.r[9].s64 = -2108293120;
	// 821BBAE8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821BBAEC: 38E95FA0  addi r7, r9, 0x5fa0
	ctx.r[7].s64 = ctx.r[9].s64 + 24480;
	// 821BBAF0: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821BBAF4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821BBAF8: 90E30004  stw r7, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821BBAFC: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821BBB00: 48000008  b 0x821bbb08
	pc = 0x821BBB08; continue 'dispatch;
            }
            0x821BBB04 => {
    //   block [0x821BBB04..0x821BBB08)
	// 821BBB04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821BBB08; continue 'dispatch;
            }
            0x821BBB08 => {
    //   block [0x821BBB08..0x821BBB24)
	// 821BBB08: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821BBB0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BBB10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821BBB14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821BBB18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821BBB1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821BBB20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BBB28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821BBB28 size=164
    let mut pc: u32 = 0x821BBB28;
    'dispatch: loop {
        match pc {
            0x821BBB28 => {
    //   block [0x821BBB28..0x821BBB4C)
	// 821BBB28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BBB2C: 48AED8D5  bl 0x82ca9400
	ctx.lr = 0x821BBB30;
	sub_82CA93D0(ctx, base);
	// 821BBB30: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BBB34: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821BBB38: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 821BBB3C: 3BBA1028  addi r29, r26, 0x1028
	ctx.r[29].s64 = ctx.r[26].s64 + 4136;
	// 821BBB40: 3BDA0F38  addi r30, r26, 0xf38
	ctx.r[30].s64 = ctx.r[26].s64 + 3896;
	// 821BBB44: 7FFAD850  subf r31, r26, r27
	ctx.r[31].s64 = ctx.r[27].s64 - ctx.r[26].s64;
	// 821BBB48: 3B80000F  li r28, 0xf
	ctx.r[28].s64 = 15;
	pc = 0x821BBB4C; continue 'dispatch;
            }
            0x821BBB4C => {
    //   block [0x821BBB4C..0x821BBBCC)
	// 821BBB4C: 7C9FF214  add r4, r31, r30
	ctx.r[4].u64 = ctx.r[31].u64 + ctx.r[30].u64;
	// 821BBB50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BBB54: 4802BBB5  bl 0x821e7708
	ctx.lr = 0x821BBB58;
	sub_821E7708(ctx, base);
	// 821BBB58: 7C1FEC2E  lfsx f0, r31, r29
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821BBB5C: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821BBB60: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 821BBB64: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 821BBB68: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 821BBB6C: 4082FFE0  bne 0x821bbb4c
	if !ctx.cr[0].eq {
	pc = 0x821BBB4C; continue 'dispatch;
	}
	// 821BBB70: 38FB0C34  addi r7, r27, 0xc34
	ctx.r[7].s64 = ctx.r[27].s64 + 3124;
	// 821BBB74: 391B0020  addi r8, r27, 0x20
	ctx.r[8].s64 = ctx.r[27].s64 + 32;
	// 821BBB78: 395A0C30  addi r10, r26, 0xc30
	ctx.r[10].s64 = ctx.r[26].s64 + 3120;
	// 821BBB7C: 397A0010  addi r11, r26, 0x10
	ctx.r[11].s64 = ctx.r[26].s64 + 16;
	// 821BBB80: 39200061  li r9, 0x61
	ctx.r[9].s64 = 97;
	// 821BBB84: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BBBD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BBBD0 size=572
    let mut pc: u32 = 0x821BBBD0;
    'dispatch: loop {
        match pc {
            0x821BBBD0 => {
    //   block [0x821BBBD0..0x821BBE0C)
	// 821BBBD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BBBD4: 48AED835  bl 0x82ca9408
	ctx.lr = 0x821BBBD8;
	sub_82CA93D0(ctx, base);
	// 821BBBD8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BBBDC: 806300F0  lwz r3, 0xf0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(240 as u32) ) } as u64;
	// 821BBBE0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821BBBE4: 4806A715  bl 0x822262f8
	ctx.lr = 0x821BBBE8;
	sub_822262F8(ctx, base);
	// 821BBBE8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821BBBEC: 39400058  li r10, 0x58
	ctx.r[10].s64 = 88;
	// 821BBBF0: 3BEBB480  addi r31, r11, -0x4b80
	ctx.r[31].s64 = ctx.r[11].s64 + -19328;
	// 821BBBF4: 39200054  li r9, 0x54
	ctx.r[9].s64 = 84;
	// 821BBBF8: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 821BBBFC: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BBE10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BBE10 size=292
    let mut pc: u32 = 0x821BBE10;
    'dispatch: loop {
        match pc {
            0x821BBE10 => {
    //   block [0x821BBE10..0x821BBE60)
	// 821BBE10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BBE14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821BBE18: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BBE1C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821BBE20: 896A0010  lbz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821BBE24: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821BBE28: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821BBE2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BBE30: 419A0030  beq cr6, 0x821bbe60
	if ctx.cr[6].eq {
	pc = 0x821BBE60; continue 'dispatch;
	}
	// 821BBE34: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BBE38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BBE3C: 409A00E8  bne cr6, 0x821bbf24
	if !ctx.cr[6].eq {
	pc = 0x821BBF24; continue 'dispatch;
	}
	// 821BBE40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BBE44: 419A001C  beq cr6, 0x821bbe60
	if ctx.cr[6].eq {
	pc = 0x821BBE60; continue 'dispatch;
	}
	// 821BBE48: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821BBE4C: 810B0070  lwz r8, 0x70(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 821BBE50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821BBE54: 38E96B20  addi r7, r9, 0x6b20
	ctx.r[7].s64 = ctx.r[9].s64 + 27424;
	// 821BBE58: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821BBE5C: 419A0008  beq cr6, 0x821bbe64
	if ctx.cr[6].eq {
	pc = 0x821BBE64; continue 'dispatch;
	}
	pc = 0x821BBE60; continue 'dispatch;
            }
            0x821BBE60 => {
    //   block [0x821BBE60..0x821BBE64)
	// 821BBE60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821BBE64; continue 'dispatch;
            }
            0x821BBE64 => {
    //   block [0x821BBE64..0x821BBEB4)
	// 821BBE64: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821BBE68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BBE6C: 419A00B4  beq cr6, 0x821bbf20
	if ctx.cr[6].eq {
	pc = 0x821BBF20; continue 'dispatch;
	}
	// 821BBE70: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 821BBE74: 419A00AC  beq cr6, 0x821bbf20
	if ctx.cr[6].eq {
	pc = 0x821BBF20; continue 'dispatch;
	}
	// 821BBE78: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BBE7C: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821BBE80: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BBE84: 2F09000F  cmpwi cr6, r9, 0xf
	ctx.cr[6].compare_i32(ctx.r[9].s32, 15, &mut ctx.xer);
	// 821BBE88: 409A0098  bne cr6, 0x821bbf20
	if !ctx.cr[6].eq {
	pc = 0x821BBF20; continue 'dispatch;
	}
	// 821BBE8C: 816A0018  lwz r11, 0x18(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 821BBE90: 5489007E  clrlwi r9, r4, 1
	ctx.r[9].u64 = ctx.r[4].u32 as u64 & 0x7FFFFFFFu64;
	// 821BBE94: 54880000  rlwinm r8, r4, 0, 0, 0
	ctx.r[8].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	// 821BBE98: 20EB0020  subfic r7, r11, 0x20
	ctx.xer.ca = ctx.r[11].u32 <= 32 as u32;
	ctx.r[7].s64 = (32 as i64) - ctx.r[11].s64;
	// 821BBE9C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821BBEA0: 7D2B3C30  srw r11, r9, r7
	if (ctx.r[7].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[9].u32) >> ((ctx.r[7].u8 & 0x1F) as u32)) as u64;
	}
	// 821BBEA4: 409A0010  bne cr6, 0x821bbeb4
	if !ctx.cr[6].eq {
	pc = 0x821BBEB4; continue 'dispatch;
	}
	// 821BBEA8: 814A0050  lwz r10, 0x50(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 821BBEAC: 556B3830  slwi r11, r11, 7
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(7);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821BBEB0: 48000014  b 0x821bbec4
	pc = 0x821BBEC4; continue 'dispatch;
            }
            0x821BBEB4 => {
    //   block [0x821BBEB4..0x821BBEC4)
	// 821BBEB4: 55691838  slwi r9, r11, 3
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821BBEB8: 814A0058  lwz r10, 0x58(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821BBEBC: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821BBEC0: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	pc = 0x821BBEC4; continue 'dispatch;
            }
            0x821BBEC4 => {
    //   block [0x821BBEC4..0x821BBF20)
	// 821BBEC4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821BBEC8: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821BBECC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BBED0: 419A0050  beq cr6, 0x821bbf20
	if ctx.cr[6].eq {
	pc = 0x821BBF20; continue 'dispatch;
	}
	// 821BBED4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821BBED8: 894B6C68  lbz r10, 0x6c68(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(27752 as u32) ) } as u64;
	// 821BBEDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BBEE0: 409A0044  bne cr6, 0x821bbf24
	if !ctx.cr[6].eq {
	pc = 0x821BBF24; continue 'dispatch;
	}
	// 821BBEE4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821BBEE8: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 821BBEEC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821BBEF0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821BBEF4: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 821BBEF8: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821BBEFC: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BBF00: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 821BBF04: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BBF08: 80660000  lwz r3, 0(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BBF0C: 480A857D  bl 0x82264488
	ctx.lr = 0x821BBF10;
	sub_82264488(ctx, base);
	// 821BBF10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821BBF14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821BBF18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821BBF1C: 4E800020  blr
	return;
            }
            0x821BBF20 => {
    //   block [0x821BBF20..0x821BBF24)
	// 821BBF20: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x821BBF24; continue 'dispatch;
            }
            0x821BBF24 => {
    //   block [0x821BBF24..0x821BBF34)
	// 821BBF24: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821BBF28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821BBF2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821BBF30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BBF38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BBF38 size=328
    let mut pc: u32 = 0x821BBF38;
    'dispatch: loop {
        match pc {
            0x821BBF38 => {
    //   block [0x821BBF38..0x821BBFF8)
	// 821BBF38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BBF3C: 48AED4C5  bl 0x82ca9400
	ctx.lr = 0x821BBF40;
	sub_82CA93D0(ctx, base);
	// 821BBF40: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BBF44: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821BBF48: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821BBF4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BBF50: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 821BBF54: 48C8A5ED  bl 0x82e46540
	ctx.lr = 0x821BBF58;
	sub_82E46540(ctx, base);
	// 821BBF58: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821BBF5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BBF60: 838B002C  lwz r28, 0x2c(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821BBF64: 48C8A5DD  bl 0x82e46540
	ctx.lr = 0x821BBF68;
	sub_82E46540(ctx, base);
	// 821BBF68: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821BBF6C: 8363002C  lwz r27, 0x2c(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 821BBF70: 816A6AB8  lwz r11, 0x6ab8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821BBF74: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BBF78: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 821BBF7C: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BBF80: 80670018  lwz r3, 0x18(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 821BBF84: 80C30000  lwz r6, 0(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BBF88: 80A60058  lwz r5, 0x58(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(88 as u32) ) } as u64;
	// 821BBF8C: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 821BBF90: 4E800421  bctrl
	ctx.lr = 0x821BBF94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BBF94: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821BBF98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BBF9C: 48C8A5A5  bl 0x82e46540
	ctx.lr = 0x821BBFA0;
	sub_82E46540(ctx, base);
	// 821BBFA0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BBFA4: 38C30010  addi r6, r3, 0x10
	ctx.r[6].s64 = ctx.r[3].s64 + 16;
	// 821BBFA8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821BBFAC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821BBFB0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821BBFB4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BBFB8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821BBFBC: 4E800421  bctrl
	ctx.lr = 0x821BBFC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BBFC0: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821BBFC4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821BBFC8: 419A00B0  beq cr6, 0x821bc078
	if ctx.cr[6].eq {
	pc = 0x821BC078; continue 'dispatch;
	}
	// 821BBFCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BBFD0: 48C8A571  bl 0x82e46540
	ctx.lr = 0x821BBFD4;
	sub_82E46540(ctx, base);
	// 821BBFD4: 39630010  addi r11, r3, 0x10
	ctx.r[11].s64 = ctx.r[3].s64 + 16;
	// 821BBFD8: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821BBFDC: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 821BBFE0: 7D6A5A15  add. r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BBFE4: 41820014  beq 0x821bbff8
	if ctx.cr[0].eq {
	pc = 0x821BBFF8; continue 'dispatch;
	}
	// 821BBFE8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BBFEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BBFF0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821BBFF4: 409A0008  bne cr6, 0x821bbffc
	if !ctx.cr[6].eq {
	pc = 0x821BBFFC; continue 'dispatch;
	}
            }
            0x821BBFF8 => {
    //   block [0x821BBFF8..0x821BBFFC)
	// 821BBFF8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x821BBFFC; continue 'dispatch;
            }
            0x821BBFFC => {
    //   block [0x821BBFFC..0x821BC078)
	// 821BBFFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BC000: 48C8A541  bl 0x82e46540
	ctx.lr = 0x821BC004;
	sub_82E46540(ctx, base);
	// 821BC004: 89430020  lbz r10, 0x20(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 821BC008: 39630010  addi r11, r3, 0x10
	ctx.r[11].s64 = ctx.r[3].s64 + 16;
	// 821BC00C: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 821BC010: 7D6A5A15  add. r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BC014: 41820064  beq 0x821bc078
	if ctx.cr[0].eq {
	pc = 0x821BC078; continue 'dispatch;
	}
	// 821BC018: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BC01C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821BC020: 419A0058  beq cr6, 0x821bc078
	if ctx.cr[6].eq {
	pc = 0x821BC078; continue 'dispatch;
	}
	// 821BC024: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821BC028: 419A0050  beq cr6, 0x821bc078
	if ctx.cr[6].eq {
	pc = 0x821BC078; continue 'dispatch;
	}
	// 821BC02C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	pc = 0x821BC078; continue 'dispatch;
            }
            0x821BC078 => {
    //   block [0x821BC078..0x821BC080)
	// 821BC078: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821BC07C: 48AED3D4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BC080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BC080 size=236
    let mut pc: u32 = 0x821BC080;
    'dispatch: loop {
        match pc {
            0x821BC080 => {
    //   block [0x821BC080..0x821BC0B0)
	// 821BC080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BC084: 48AED381  bl 0x82ca9404
	ctx.lr = 0x821BC088;
	sub_82CA93D0(ctx, base);
	// 821BC088: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BC08C: 3D600AAA  lis r11, 0xaaa
	ctx.r[11].s64 = 178913280;
	// 821BC090: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821BC094: 616AAAAA  ori r10, r11, 0xaaaa
	ctx.r[10].u64 = ctx.r[11].u64 | 43690;
	// 821BC098: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821BC09C: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821BC0A0: 40990010  ble cr6, 0x821bc0b0
	if !ctx.cr[6].gt {
	pc = 0x821BC0B0; continue 'dispatch;
	}
	// 821BC0A4: 4888B425  bl 0x82a474c8
	ctx.lr = 0x821BC0A8;
	sub_82A474C8(ctx, base);
	// 821BC0A8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821BC0AC: 48AED3A8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x821BC0B0 => {
    //   block [0x821BC0B0..0x821BC0CC)
	// 821BC0B0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC0B4: 3B600018  li r27, 0x18
	ctx.r[27].s64 = 24;
	// 821BC0B8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821BC0BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC0C0: 409A000C  bne cr6, 0x821bc0cc
	if !ctx.cr[6].eq {
	pc = 0x821BC0CC; continue 'dispatch;
	}
	// 821BC0C4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821BC0C8: 48000010  b 0x821bc0d8
	pc = 0x821BC0D8; continue 'dispatch;
            }
            0x821BC0CC => {
    //   block [0x821BC0CC..0x821BC0D8)
	// 821BC0CC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BC0D0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821BC0D4: 7D69DBD6  divw r11, r9, r27
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	pc = 0x821BC0D8; continue 'dispatch;
            }
            0x821BC0D8 => {
    //   block [0x821BC0D8..0x821BC138)
	// 821BC0D8: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821BC0DC: 40980088  bge cr6, 0x821bc164
	if !ctx.cr[6].lt {
	pc = 0x821BC164; continue 'dispatch;
	}
	// 821BC0E0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821BC0E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BC0E8: 488C8011  bl 0x82a840f8
	ctx.lr = 0x821BC0EC;
	sub_82A840F8(ctx, base);
	// 821BC0EC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC0F0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BC0F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821BC0F8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 821BC0FC: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 821BC100: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821BC104: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821BC108: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821BC10C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821BC110: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821BC114: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821BC118: 488C8881  bl 0x82a84998
	ctx.lr = 0x821BC11C;
	sub_82A84998(ctx, base);
	// 821BC11C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC120: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BC124: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BC128: 7D034850  subf r8, r3, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[3].s64;
	// 821BC12C: 7FA8DBD6  divw r29, r8, r27
	ctx.r[29].s32 = ctx.r[8].s32 / ctx.r[27].s32;
	// 821BC130: 419A0008  beq cr6, 0x821bc138
	if ctx.cr[6].eq {
	pc = 0x821BC138; continue 'dispatch;
	}
	// 821BC134: 4805FC05  bl 0x8221bd38
	ctx.lr = 0x821BC138;
	sub_8221BD38(ctx, base);
	pc = 0x821BC138; continue 'dispatch;
            }
            0x821BC138 => {
    //   block [0x821BC138..0x821BC164)
	// 821BC138: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821BC13C: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 821BC140: 578A083C  slwi r10, r28, 1
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821BC144: 7D3D5A14  add r9, r29, r11
	ctx.r[9].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 821BC148: 7D5C5214  add r10, r28, r10
	ctx.r[10].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 821BC14C: 552B1838  slwi r11, r9, 3
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821BC150: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821BC154: 7CEBF214  add r7, r11, r30
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821BC158: 7D0AF214  add r8, r10, r30
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 821BC15C: 90FF0008  stw r7, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 821BC160: 911F000C  stw r8, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	pc = 0x821BC164; continue 'dispatch;
            }
            0x821BC164 => {
    //   block [0x821BC164..0x821BC16C)
	// 821BC164: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821BC168: 48AED2EC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BC170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BC170 size=284
    let mut pc: u32 = 0x821BC170;
    'dispatch: loop {
        match pc {
            0x821BC170 => {
    //   block [0x821BC170..0x821BC18C)
	// 821BC170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BC174: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821BC178: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821BC17C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821BC180: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BC184: 3BE30018  addi r31, r3, 0x18
	ctx.r[31].s64 = ctx.r[3].s64 + 24;
	// 821BC188: 3BC00017  li r30, 0x17
	ctx.r[30].s64 = 23;
	pc = 0x821BC18C; continue 'dispatch;
            }
            0x821BC18C => {
    //   block [0x821BC18C..0x821BC1A8)
	// 821BC18C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BC190: 80BFFFFC  lwz r5, -4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821BC194: 7F052040  cmplw cr6, r5, r4
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821BC198: 419A0010  beq cr6, 0x821bc1a8
	if ctx.cr[6].eq {
	pc = 0x821BC1A8; continue 'dispatch;
	}
	// 821BC19C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 821BC1A0: 488C7FD1  bl 0x82a84170
	ctx.lr = 0x821BC1A4;
	sub_82A84170(ctx, base);
	// 821BC1A4: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x821BC1A8; continue 'dispatch;
            }
            0x821BC1A8 => {
    //   block [0x821BC1A8..0x821BC250)
	// 821BC1A8: 387FFFF8  addi r3, r31, -8
	ctx.r[3].s64 = ctx.r[31].s64 + -8;
	// 821BC1AC: 480000E5  bl 0x821bc290
	ctx.lr = 0x821BC1B0;
	sub_821BC290(ctx, base);
	// 821BC1B0: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821BC1B4: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 821BC1B8: 4082FFD4  bne 0x821bc18c
	if !ctx.cr[0].eq {
	pc = 0x821BC18C; continue 'dispatch;
	}
	// 821BC1BC: 3FE08336  lis r31, -0x7cca
	ctx.r[31].s64 = -2093613056;
	// 821BC1C0: 897F05A1  lbz r11, 0x5a1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1441 as u32) ) } as u64;
	// 821BC1C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC1C8: 419A00AC  beq cr6, 0x821bc274
	if ctx.cr[6].eq {
	pc = 0x821BC274; continue 'dispatch;
	}
	// 821BC1CC: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821BC1D0: 3D408331  lis r10, -0x7ccf
	ctx.r[10].s64 = -2093940736;
	// 821BC1D4: 396B63A0  addi r11, r11, 0x63a0
	ctx.r[11].s64 = ctx.r[11].s64 + 25504;
	// 821BC1D8: 38EA6FAC  addi r7, r10, 0x6fac
	ctx.r[7].s64 = ctx.r[10].s64 + 28588;
	// 821BC1DC: 3D20834B  lis r9, -0x7cb5
	ctx.r[9].s64 = -2092236800;
	// 821BC1E0: 39092390  addi r8, r9, 0x2390
	ctx.r[8].s64 = ctx.r[9].s64 + 9104;
	// 821BC1E4: 88CB1A25  lbz r6, 0x1a25(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6693 as u32) ) } as u64;
	// 821BC1E8: 812B1A14  lwz r9, 0x1a14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6676 as u32) ) } as u64;
	// 821BC1EC: 1D462008  mulli r10, r6, 0x2008
	ctx.r[10].s32 = ((ctx.r[6].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821BC1F0: 80E70008  lwz r7, 8(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BC1F4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821BC1F8: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821BC1FC: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821BC200: 419A006C  beq cr6, 0x821bc26c
	if ctx.cr[6].eq {
	pc = 0x821BC26C; continue 'dispatch;
	}
	// 821BC204: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821BC208: 810B1A18  lwz r8, 0x1a18(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6680 as u32) ) } as u64;
	// 821BC20C: 7D264038  and r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821BC210: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821BC214: 409A003C  bne cr6, 0x821bc250
	if !ctx.cr[6].eq {
	pc = 0x821BC250; continue 'dispatch;
	}
	// 821BC218: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821BC21C: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821BC220: 38AB1A10  addi r5, r11, 0x1a10
	ctx.r[5].s64 = ctx.r[11].s64 + 6672;
	// 821BC224: 54C41838  slwi r4, r6, 3
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821BC228: 912B1A18  stw r9, 0x1a18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6680 as u32), ctx.r[9].u32 ) };
	// 821BC22C: 7CA4512E  stwx r5, r4, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[10].u32), ctx.r[5].u32) };
	// 821BC230: 812B1A14  lwz r9, 0x1a14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6676 as u32) ) } as u64;
	// 821BC234: 806A2004  lwz r3, 0x2004(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821BC238: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821BC23C: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821BC240: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821BC244: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821BC248: 38C90001  addi r6, r9, 1
	ctx.r[6].s64 = ctx.r[9].s64 + 1;
	// 821BC24C: 90CA2004  stw r6, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[6].u32 ) };
	pc = 0x821BC250; continue 'dispatch;
            }
            0x821BC250 => {
    //   block [0x821BC250..0x821BC26C)
	// 821BC250: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821BC254: 90EB1A14  stw r7, 0x1a14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6676 as u32), ctx.r[7].u32 ) };
	// 821BC258: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821BC25C: 994B1A24  stb r10, 0x1a24(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6692 as u32), ctx.r[10].u8 ) };
	// 821BC260: 386B1A10  addi r3, r11, 0x1a10
	ctx.r[3].s64 = ctx.r[11].s64 + 6672;
	// 821BC264: 992B1A1C  stb r9, 0x1a1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6684 as u32), ctx.r[9].u8 ) };
	// 821BC268: 480622E9  bl 0x8221e550
	ctx.lr = 0x821BC26C;
	sub_8221E550(ctx, base);
	pc = 0x821BC26C; continue 'dispatch;
            }
            0x821BC26C => {
    //   block [0x821BC26C..0x821BC274)
	// 821BC26C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821BC270: 997F05A1  stb r11, 0x5a1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1441 as u32), ctx.r[11].u8 ) };
	pc = 0x821BC274; continue 'dispatch;
            }
            0x821BC274 => {
    //   block [0x821BC274..0x821BC28C)
	// 821BC274: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821BC278: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821BC27C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821BC280: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821BC284: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821BC288: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BC290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BC290 size=268
    let mut pc: u32 = 0x821BC290;
    'dispatch: loop {
        match pc {
            0x821BC290 => {
    //   block [0x821BC290..0x821BC2BC)
	// 821BC290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BC294: 48AED175  bl 0x82ca9408
	ctx.lr = 0x821BC298;
	sub_82CA93D0(ctx, base);
	// 821BC298: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BC29C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821BC2A0: 39200018  li r9, 0x18
	ctx.r[9].s64 = 24;
	// 821BC2A4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821BC2A8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC2AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC2B0: 409A000C  bne cr6, 0x821bc2bc
	if !ctx.cr[6].eq {
	pc = 0x821BC2BC; continue 'dispatch;
	}
	// 821BC2B4: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 821BC2B8: 48000010  b 0x821bc2c8
	pc = 0x821BC2C8; continue 'dispatch;
            }
            0x821BC2BC => {
    //   block [0x821BC2BC..0x821BC2C8)
	// 821BC2BC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BC2C0: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821BC2C4: 7D484BD6  divw r10, r8, r9
	ctx.r[10].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	pc = 0x821BC2C8; continue 'dispatch;
            }
            0x821BC2C8 => {
    //   block [0x821BC2C8..0x821BC34C)
	// 821BC2C8: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BC2CC: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 821BC2D0: 7CEB4050  subf r7, r11, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 821BC2D4: 7C874BD6  divw r4, r7, r9
	ctx.r[4].s32 = ctx.r[7].s32 / ctx.r[9].s32;
	// 821BC2D8: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821BC2DC: 409900B8  ble cr6, 0x821bc394
	if !ctx.cr[6].gt {
	pc = 0x821BC394; continue 'dispatch;
	}
	// 821BC2E0: 93A10074  stw r29, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[29].u32 ) };
	// 821BC2E4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821BC2E8: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 821BC2EC: 93A1007C  stw r29, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[29].u32 ) };
	// 821BC2F0: 4BFFFD91  bl 0x821bc080
	ctx.lr = 0x821BC2F4;
	sub_821BC080(ctx, base);
	// 821BC2F4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BC2F8: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821BC2FC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821BC300: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC304: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 821BC308: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 821BC30C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 821BC310: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 821BC314: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 821BC318: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 821BC31C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821BC320: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821BC324: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821BC328: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821BC32C: 4BFFE2C5  bl 0x821ba5f0
	ctx.lr = 0x821BC330;
	sub_821BA5F0(ctx, base);
	// 821BC330: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BC334: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC338: 7F052040  cmplw cr6, r5, r4
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821BC33C: 419A0010  beq cr6, 0x821bc34c
	if ctx.cr[6].eq {
	pc = 0x821BC34C; continue 'dispatch;
	}
	// 821BC340: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 821BC344: 488C7E2D  bl 0x82a84170
	ctx.lr = 0x821BC348;
	sub_82A84170(ctx, base);
	// 821BC348: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x821BC34C; continue 'dispatch;
            }
            0x821BC34C => {
    //   block [0x821BC34C..0x821BC36C)
	// 821BC34C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC350: 3B9F000C  addi r28, r31, 0xc
	ctx.r[28].s64 = ctx.r[31].s64 + 12;
	// 821BC354: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 821BC358: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 821BC35C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BC360: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 821BC364: 419A0008  beq cr6, 0x821bc36c
	if ctx.cr[6].eq {
	pc = 0x821BC36C; continue 'dispatch;
	}
	// 821BC368: 4805F9D1  bl 0x8221bd38
	ctx.lr = 0x821BC36C;
	sub_8221BD38(ctx, base);
	pc = 0x821BC36C; continue 'dispatch;
            }
            0x821BC36C => {
    //   block [0x821BC36C..0x821BC394)
	// 821BC36C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821BC370: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 821BC374: 8121007C  lwz r9, 0x7c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 821BC378: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC37C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821BC380: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BC384: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821BC388: 913C0000  stw r9, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821BC38C: 419A0008  beq cr6, 0x821bc394
	if ctx.cr[6].eq {
	pc = 0x821BC394; continue 'dispatch;
	}
	// 821BC390: 4805F9A9  bl 0x8221bd38
	ctx.lr = 0x821BC394;
	sub_8221BD38(ctx, base);
	pc = 0x821BC394; continue 'dispatch;
            }
            0x821BC394 => {
    //   block [0x821BC394..0x821BC39C)
	// 821BC394: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821BC398: 48AED0C0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BC3A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821BC3A0 size=404
    let mut pc: u32 = 0x821BC3A0;
    'dispatch: loop {
        match pc {
            0x821BC3A0 => {
    //   block [0x821BC3A0..0x821BC3EC)
	// 821BC3A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BC3A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821BC3A8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BC3AC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821BC3B0: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821BC3B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC3B8: 419A0168  beq cr6, 0x821bc520
	if ctx.cr[6].eq {
	pc = 0x821BC520; continue 'dispatch;
	}
	// 821BC3BC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BC3C0: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 821BC3C4: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC3C8: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BC3CC: 4806FDED  bl 0x8222c1b8
	ctx.lr = 0x821BC3D0;
	sub_8222C1B8(ctx, base);
	// 821BC3D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BC3D4: 419A0018  beq cr6, 0x821bc3ec
	if ctx.cr[6].eq {
	pc = 0x821BC3EC; continue 'dispatch;
	}
	// 821BC3D8: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 821BC3DC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821BC3E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821BC3E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BC3E8: 409A0008  bne cr6, 0x821bc3f0
	if !ctx.cr[6].eq {
	pc = 0x821BC3F0; continue 'dispatch;
	}
	pc = 0x821BC3EC; continue 'dispatch;
            }
            0x821BC3EC => {
    //   block [0x821BC3EC..0x821BC3F0)
	// 821BC3EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821BC3F0; continue 'dispatch;
            }
            0x821BC3F0 => {
    //   block [0x821BC3F0..0x821BC438)
	// 821BC3F0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821BC3F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC3F8: 419A0128  beq cr6, 0x821bc520
	if ctx.cr[6].eq {
	pc = 0x821BC520; continue 'dispatch;
	}
	// 821BC3FC: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 821BC400: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821BC404: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 821BC408: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821BC40C: 419A00EC  beq cr6, 0x821bc4f8
	if ctx.cr[6].eq {
	pc = 0x821BC4F8; continue 'dispatch;
	}
	// 821BC410: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821BC414: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC418: 419A0020  beq cr6, 0x821bc438
	if ctx.cr[6].eq {
	pc = 0x821BC438; continue 'dispatch;
	}
	// 821BC41C: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 821BC420: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821BC424: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821BC428: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821BC42C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821BC430: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC434: 480000C8  b 0x821bc4fc
	pc = 0x821BC4FC; continue 'dispatch;
            }
            0x821BC438 => {
    //   block [0x821BC438..0x821BC458)
	// 821BC438: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821BC43C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821BC440: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821BC444: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821BC448: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821BC44C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821BC450: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BC454: 40810054  ble 0x821bc4a8
	if !ctx.cr[0].gt {
	pc = 0x821BC4A8; continue 'dispatch;
	}
	pc = 0x821BC458; continue 'dispatch;
            }
            0x821BC458 => {
    //   block [0x821BC458..0x821BC478)
	// 821BC458: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821BC45C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821BC460: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821BC464: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BC468: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 821BC46C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821BC470: 41980008  blt cr6, 0x821bc478
	if ctx.cr[6].lt {
	pc = 0x821BC478; continue 'dispatch;
	}
	// 821BC474: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x821BC478; continue 'dispatch;
            }
            0x821BC478 => {
    //   block [0x821BC478..0x821BC494)
	// 821BC478: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821BC47C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821BC480: 419A0014  beq cr6, 0x821bc494
	if ctx.cr[6].eq {
	pc = 0x821BC494; continue 'dispatch;
	}
	// 821BC484: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821BC488: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821BC48C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821BC490: 4800000C  b 0x821bc49c
	pc = 0x821BC49C; continue 'dispatch;
            }
            0x821BC494 => {
    //   block [0x821BC494..0x821BC49C)
	// 821BC494: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821BC498: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821BC49C; continue 'dispatch;
            }
            0x821BC49C => {
    //   block [0x821BC49C..0x821BC4A8)
	// 821BC49C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BC4A0: 4199FFB8  bgt cr6, 0x821bc458
	if ctx.cr[6].gt {
	pc = 0x821BC458; continue 'dispatch;
	}
	// 821BC4A4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821BC4A8; continue 'dispatch;
            }
            0x821BC4A8 => {
    //   block [0x821BC4A8..0x821BC4C4)
	// 821BC4A8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821BC4AC: 419A003C  beq cr6, 0x821bc4e8
	if ctx.cr[6].eq {
	pc = 0x821BC4E8; continue 'dispatch;
	}
	// 821BC4B0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BC4B4: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 821BC4B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821BC4BC: 41990008  bgt cr6, 0x821bc4c4
	if ctx.cr[6].gt {
	pc = 0x821BC4C4; continue 'dispatch;
	}
	// 821BC4C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821BC4C4; continue 'dispatch;
            }
            0x821BC4C4 => {
    //   block [0x821BC4C4..0x821BC4E8)
	// 821BC4C4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821BC4C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC4CC: 409A001C  bne cr6, 0x821bc4e8
	if !ctx.cr[6].eq {
	pc = 0x821BC4E8; continue 'dispatch;
	}
	// 821BC4D0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821BC4D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821BC4D8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821BC4DC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821BC4E0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC4E4: 48000018  b 0x821bc4fc
	pc = 0x821BC4FC; continue 'dispatch;
            }
            0x821BC4E8 => {
    //   block [0x821BC4E8..0x821BC4F8)
	// 821BC4E8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821BC4EC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821BC4F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC4F4: 48000008  b 0x821bc4fc
	pc = 0x821BC4FC; continue 'dispatch;
            }
            0x821BC4F8 => {
    //   block [0x821BC4F8..0x821BC4FC)
	// 821BC4F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821BC4FC; continue 'dispatch;
            }
            0x821BC4FC => {
    //   block [0x821BC4FC..0x821BC520)
	// 821BC4FC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821BC500: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BC504: 419A001C  beq cr6, 0x821bc520
	if ctx.cr[6].eq {
	pc = 0x821BC520; continue 'dispatch;
	}
	// 821BC508: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821BC50C: C1AB0088  lfs f13, 0x88(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821BC510: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821BC514: C00A9A80  lfs f0, -0x6580(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821BC518: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821BC51C: 41990008  bgt cr6, 0x821bc524
	if ctx.cr[6].gt {
	pc = 0x821BC524; continue 'dispatch;
	}
	pc = 0x821BC520; continue 'dispatch;
            }
            0x821BC520 => {
    //   block [0x821BC520..0x821BC524)
	// 821BC520: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x821BC524; continue 'dispatch;
            }
            0x821BC524 => {
    //   block [0x821BC524..0x821BC534)
	// 821BC524: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821BC528: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821BC52C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821BC530: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BC538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BC538 size=172
    let mut pc: u32 = 0x821BC538;
    'dispatch: loop {
        match pc {
            0x821BC538 => {
    //   block [0x821BC538..0x821BC590)
	// 821BC538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BC53C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821BC540: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821BC544: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821BC548: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BC54C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821BC550: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC554: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 821BC558: 485A43D1  bl 0x82760928
	ctx.lr = 0x821BC55C;
	sub_82760928(ctx, base);
	// 821BC55C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821BC560: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821BC564: 419A0068  beq cr6, 0x821bc5cc
	if ctx.cr[6].eq {
	pc = 0x821BC5CC; continue 'dispatch;
	}
	// 821BC568: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821BC56C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BC570: 480A35F1  bl 0x8225fb60
	ctx.lr = 0x821BC574;
	sub_8225FB60(ctx, base);
	// 821BC574: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821BC578: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821BC57C: 419A0050  beq cr6, 0x821bc5cc
	if ctx.cr[6].eq {
	pc = 0x821BC5CC; continue 'dispatch;
	}
	// 821BC580: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821BC584: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BC588: 4BFFC991  bl 0x821b8f18
	ctx.lr = 0x821BC58C;
	sub_821B8F18(ctx, base);
	// 821BC58C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	pc = 0x821BC590; continue 'dispatch;
            }
            0x821BC590 => {
    //   block [0x821BC590..0x821BC5CC)
	// 821BC590: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821BC594: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BC598: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821BC59C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821BC5A0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821BC5A4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BC5A8: 4082FFE8  bne 0x821bc590
	if !ctx.cr[0].eq {
	pc = 0x821BC590; continue 'dispatch;
	}
	// 821BC5AC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821BC5B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BC5B4: 409A0018  bne cr6, 0x821bc5cc
	if !ctx.cr[6].eq {
	pc = 0x821BC5CC; continue 'dispatch;
	}
	// 821BC5B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BC5BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BC5C0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC5C4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821BC5C8: 4E800421  bctrl
	ctx.lr = 0x821BC5CC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821BC5CC => {
    //   block [0x821BC5CC..0x821BC5E4)
	// 821BC5CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821BC5D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821BC5D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821BC5D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821BC5DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821BC5E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BC5E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821BC5E8 size=2780
    let mut pc: u32 = 0x821BC5E8;
    'dispatch: loop {
        match pc {
            0x821BC5E8 => {
    //   block [0x821BC5E8..0x821BC650)
	// 821BC5E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BC5EC: 48AECDE5  bl 0x82ca93d0
	ctx.lr = 0x821BC5F0;
	sub_82CA93D0(ctx, base);
	// 821BC5F0: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 821BC5F4: 48AF16DD  bl 0x82cadcd0
	ctx.lr = 0x821BC5F8;
	sub_82CADCA0(ctx, base);
	// 821BC5F8: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BC5FC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821BC600: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 821BC604: 93A101D4  stw r29, 0x1d4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(468 as u32), ctx.r[29].u32 ) };
	// 821BC608: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 821BC60C: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 821BC610: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC614: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821BC618: 5528A7FE  rlwinm r8, r9, 0x14, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000FFFu64;
	// 821BC61C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821BC620: 419A00F4  beq cr6, 0x821bc714
	if ctx.cr[6].eq {
	pc = 0x821BC714; continue 'dispatch;
	}
	// 821BC624: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821BC628: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BC62C: 419A0024  beq cr6, 0x821bc650
	if ctx.cr[6].eq {
	pc = 0x821BC650; continue 'dispatch;
	}
	// 821BC630: 894A002C  lbz r10, 0x2c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 821BC634: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821BC638: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821BC63C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821BC640: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC644: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821BC648: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821BC64C: 480000CC  b 0x821bc718
	pc = 0x821BC718; continue 'dispatch;
            }
            0x821BC650 => {
    //   block [0x821BC650..0x821BC66C)
	// 821BC650: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821BC654: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821BC658: 92E100B8  stw r23, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[23].u32 ) };
	// 821BC65C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821BC660: 914100BC  stw r10, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[10].u32 ) };
	// 821BC664: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BC668: 40810054  ble 0x821bc6bc
	if !ctx.cr[0].gt {
	pc = 0x821BC6BC; continue 'dispatch;
	}
	pc = 0x821BC66C; continue 'dispatch;
            }
            0x821BC66C => {
    //   block [0x821BC66C..0x821BC68C)
	// 821BC66C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821BC670: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821BC674: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821BC678: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BC67C: 2F07002C  cmpwi cr6, r7, 0x2c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 44, &mut ctx.xer);
	// 821BC680: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 821BC684: 41980008  blt cr6, 0x821bc68c
	if ctx.cr[6].lt {
	pc = 0x821BC68C; continue 'dispatch;
	}
	// 821BC688: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	pc = 0x821BC68C; continue 'dispatch;
            }
            0x821BC68C => {
    //   block [0x821BC68C..0x821BC6A8)
	// 821BC68C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821BC690: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821BC694: 419A0014  beq cr6, 0x821bc6a8
	if ctx.cr[6].eq {
	pc = 0x821BC6A8; continue 'dispatch;
	}
	// 821BC698: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821BC69C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821BC6A0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821BC6A4: 4800000C  b 0x821bc6b0
	pc = 0x821BC6B0; continue 'dispatch;
            }
            0x821BC6A8 => {
    //   block [0x821BC6A8..0x821BC6B0)
	// 821BC6A8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821BC6AC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821BC6B0; continue 'dispatch;
            }
            0x821BC6B0 => {
    //   block [0x821BC6B0..0x821BC6BC)
	// 821BC6B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BC6B4: 4199FFB8  bgt cr6, 0x821bc66c
	if ctx.cr[6].gt {
	pc = 0x821BC66C; continue 'dispatch;
	}
	// 821BC6B8: 914100BC  stw r10, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[10].u32 ) };
	pc = 0x821BC6BC; continue 'dispatch;
            }
            0x821BC6BC => {
    //   block [0x821BC6BC..0x821BC6D8)
	// 821BC6BC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821BC6C0: 419A0040  beq cr6, 0x821bc700
	if ctx.cr[6].eq {
	pc = 0x821BC700; continue 'dispatch;
	}
	// 821BC6C4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BC6C8: 2F0B002C  cmpwi cr6, r11, 0x2c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 44, &mut ctx.xer);
	// 821BC6CC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821BC6D0: 41990008  bgt cr6, 0x821bc6d8
	if ctx.cr[6].gt {
	pc = 0x821BC6D8; continue 'dispatch;
	}
	// 821BC6D4: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x821BC6D8; continue 'dispatch;
            }
            0x821BC6D8 => {
    //   block [0x821BC6D8..0x821BC700)
	// 821BC6D8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821BC6DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC6E0: 409A0020  bne cr6, 0x821bc700
	if !ctx.cr[6].eq {
	pc = 0x821BC700; continue 'dispatch;
	}
	// 821BC6E4: E96100B8  ld r11, 0xb8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	// 821BC6E8: F96100B8  std r11, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u64 ) };
	// 821BC6EC: 816100BC  lwz r11, 0xbc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 821BC6F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC6F4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821BC6F8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821BC6FC: 4800001C  b 0x821bc718
	pc = 0x821BC718; continue 'dispatch;
            }
            0x821BC700 => {
    //   block [0x821BC700..0x821BC714)
	// 821BC700: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821BC704: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC708: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821BC70C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821BC710: 48000008  b 0x821bc718
	pc = 0x821BC718; continue 'dispatch;
            }
            0x821BC714 => {
    //   block [0x821BC714..0x821BC718)
	// 821BC714: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x821BC718; continue 'dispatch;
            }
            0x821BC718 => {
    //   block [0x821BC718..0x821BC728)
	// 821BC718: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821BC71C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC720: 419A0008  beq cr6, 0x821bc728
	if ctx.cr[6].eq {
	pc = 0x821BC728; continue 'dispatch;
	}
	// 821BC724: 9BEA0060  stb r31, 0x60(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(96 as u32), ctx.r[31].u8 ) };
	pc = 0x821BC728; continue 'dispatch;
            }
            0x821BC728 => {
    //   block [0x821BC728..0x821BC768)
	// 821BC728: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821BC72C: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC730: C96B9660  lfd f11, -0x69a0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27040 as u32) ) };
	// 821BC734: 4804B0BD  bl 0x822077f0
	ctx.lr = 0x821BC738;
	sub_822077F0(ctx, base);
	// 821BC738: FC015824  fdiv f0, f1, f11
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64 / ctx.f[11].f64;
	// 821BC73C: 895D00B4  lbz r10, 0xb4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(180 as u32) ) } as u64;
	// 821BC740: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BC744: FF400018  frsp f26, f0
	ctx.f[26].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821BC748: 409A0130  bne cr6, 0x821bc878
	if !ctx.cr[6].eq {
	pc = 0x821BC878; continue 'dispatch;
	}
	// 821BC74C: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 821BC750: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC754: 419A0014  beq cr6, 0x821bc768
	if ctx.cr[6].eq {
	pc = 0x821BC768; continue 'dispatch;
	}
	// 821BC758: 815D0024  lwz r10, 0x24(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 821BC75C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821BC760: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BC764: 408200DC  bne 0x821bc840
	if !ctx.cr[0].eq {
	pc = 0x821BC840; continue 'dispatch;
	}
	pc = 0x821BC768; continue 'dispatch;
            }
            0x821BC768 => {
    //   block [0x821BC768..0x821BC784)
	// 821BC768: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 821BC76C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC770: 419A0014  beq cr6, 0x821bc784
	if ctx.cr[6].eq {
	pc = 0x821BC784; continue 'dispatch;
	}
	// 821BC774: 815D0034  lwz r10, 0x34(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 821BC778: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821BC77C: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BC780: 408200C0  bne 0x821bc840
	if !ctx.cr[0].eq {
	pc = 0x821BC840; continue 'dispatch;
	}
	pc = 0x821BC784; continue 'dispatch;
            }
            0x821BC784 => {
    //   block [0x821BC784..0x821BC7B8)
	// 821BC784: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC788: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821BC78C: 55493FFE  rlwinm r9, r10, 7, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x01FFFFFFu64;
	// 821BC790: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821BC794: 419A0078  beq cr6, 0x821bc80c
	if ctx.cr[6].eq {
	pc = 0x821BC80C; continue 'dispatch;
	}
	// 821BC798: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821BC79C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BC7A0: 409A0064  bne cr6, 0x821bc804
	if !ctx.cr[6].eq {
	pc = 0x821BC804; continue 'dispatch;
	}
	// 821BC7A4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821BC7A8: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821BC7AC: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821BC7B0: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BC7B4: 40810050  ble 0x821bc804
	if !ctx.cr[0].gt {
	pc = 0x821BC804; continue 'dispatch;
	}
	pc = 0x821BC7B8; continue 'dispatch;
            }
            0x821BC7B8 => {
    //   block [0x821BC7B8..0x821BC7D8)
	// 821BC7B8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821BC7BC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821BC7C0: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821BC7C4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BC7C8: 2F070019  cmpwi cr6, r7, 0x19
	ctx.cr[6].compare_i32(ctx.r[7].s32, 25, &mut ctx.xer);
	// 821BC7CC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 821BC7D0: 41980008  blt cr6, 0x821bc7d8
	if ctx.cr[6].lt {
	pc = 0x821BC7D8; continue 'dispatch;
	}
	// 821BC7D4: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	pc = 0x821BC7D8; continue 'dispatch;
            }
            0x821BC7D8 => {
    //   block [0x821BC7D8..0x821BC7F4)
	// 821BC7D8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821BC7DC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821BC7E0: 419A0014  beq cr6, 0x821bc7f4
	if ctx.cr[6].eq {
	pc = 0x821BC7F4; continue 'dispatch;
	}
	// 821BC7E4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821BC7E8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821BC7EC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821BC7F0: 4800000C  b 0x821bc7fc
	pc = 0x821BC7FC; continue 'dispatch;
            }
            0x821BC7F4 => {
    //   block [0x821BC7F4..0x821BC7FC)
	// 821BC7F4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821BC7F8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821BC7FC; continue 'dispatch;
            }
            0x821BC7FC => {
    //   block [0x821BC7FC..0x821BC804)
	// 821BC7FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BC800: 4199FFB8  bgt cr6, 0x821bc7b8
	if ctx.cr[6].gt {
	pc = 0x821BC7B8; continue 'dispatch;
	}
	pc = 0x821BC804; continue 'dispatch;
            }
            0x821BC804 => {
    //   block [0x821BC804..0x821BC80C)
	// 821BC804: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821BC808: 48000008  b 0x821bc810
	pc = 0x821BC810; continue 'dispatch;
            }
            0x821BC80C => {
    //   block [0x821BC80C..0x821BC810)
	// 821BC80C: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x821BC810; continue 'dispatch;
            }
            0x821BC810 => {
    //   block [0x821BC810..0x821BC840)
	// 821BC810: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821BC814: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC818: 409A0028  bne cr6, 0x821bc840
	if !ctx.cr[6].eq {
	pc = 0x821BC840; continue 'dispatch;
	}
	// 821BC81C: 897D003D  lbz r11, 0x3d(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(61 as u32) ) } as u64;
	// 821BC820: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC824: 419A003C  beq cr6, 0x821bc860
	if ctx.cr[6].eq {
	pc = 0x821BC860; continue 'dispatch;
	}
	// 821BC828: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821BC82C: 486AE03D  bl 0x8286a868
	ctx.lr = 0x821BC830;
	sub_8286A868(ctx, base);
	// 821BC830: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821BC834: 486AD02D  bl 0x82869860
	ctx.lr = 0x821BC838;
	sub_82869860(ctx, base);
	// 821BC838: 9AFD003D  stb r23, 0x3d(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(61 as u32), ctx.r[23].u8 ) };
	// 821BC83C: 48000024  b 0x821bc860
	pc = 0x821BC860; continue 'dispatch;
            }
            0x821BC840 => {
    //   block [0x821BC840..0x821BC860)
	// 821BC840: 897D003D  lbz r11, 0x3d(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(61 as u32) ) } as u64;
	// 821BC844: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC848: 409A0018  bne cr6, 0x821bc860
	if !ctx.cr[6].eq {
	pc = 0x821BC860; continue 'dispatch;
	}
	// 821BC84C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821BC850: 486AE019  bl 0x8286a868
	ctx.lr = 0x821BC854;
	sub_8286A868(ctx, base);
	// 821BC854: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821BC858: 486AD009  bl 0x82869860
	ctx.lr = 0x821BC85C;
	sub_82869860(ctx, base);
	// 821BC85C: 9BFD003D  stb r31, 0x3d(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(61 as u32), ctx.r[31].u8 ) };
	pc = 0x821BC860; continue 'dispatch;
            }
            0x821BC860 => {
    //   block [0x821BC860..0x821BC878)
	// 821BC860: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BC864: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821BC868: FC20D090  fmr f1, f26
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[26].f64;
	// 821BC86C: 814B0060  lwz r10, 0x60(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 821BC870: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821BC874: 4E800421  bctrl
	ctx.lr = 0x821BC878;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821BC878 => {
    //   block [0x821BC878..0x821BC8E8)
	// 821BC878: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821BC87C: 894B940F  lbz r10, -0x6bf1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-27633 as u32) ) } as u64;
	// 821BC880: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BC884: 419A0220  beq cr6, 0x821bcaa4
	if ctx.cr[6].eq {
	pc = 0x821BCAA4; continue 'dispatch;
	}
	// 821BC888: 897D007C  lbz r11, 0x7c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(124 as u32) ) } as u64;
	// 821BC88C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC890: 409A01F0  bne cr6, 0x821bca80
	if !ctx.cr[6].eq {
	pc = 0x821BCA80; continue 'dispatch;
	}
	// 821BC894: 817D0068  lwz r11, 0x68(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(104 as u32) ) } as u64;
	// 821BC898: 3BDD0068  addi r30, r29, 0x68
	ctx.r[30].s64 = ctx.r[29].s64 + 104;
	// 821BC89C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BC8A0: 409A01E0  bne cr6, 0x821bca80
	if !ctx.cr[6].eq {
	pc = 0x821BCA80; continue 'dispatch;
	}
	// 821BC8A4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC8A8: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	// 821BC8AC: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821BC8B0: 5528E7FE  rlwinm r8, r9, 0x1c, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000000Fu64;
	// 821BC8B4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821BC8B8: 419A00F4  beq cr6, 0x821bc9ac
	if ctx.cr[6].eq {
	pc = 0x821BC9AC; continue 'dispatch;
	}
	// 821BC8BC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821BC8C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BC8C4: 419A0024  beq cr6, 0x821bc8e8
	if ctx.cr[6].eq {
	pc = 0x821BC8E8; continue 'dispatch;
	}
	// 821BC8C8: 894A0064  lbz r10, 0x64(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(100 as u32) ) } as u64;
	// 821BC8CC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821BC8D0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821BC8D4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821BC8D8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC8DC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821BC8E0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821BC8E4: 480000CC  b 0x821bc9b0
	pc = 0x821BC9B0; continue 'dispatch;
            }
            0x821BC8E8 => {
    //   block [0x821BC8E8..0x821BC904)
	// 821BC8E8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821BC8EC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821BC8F0: 92E100B8  stw r23, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[23].u32 ) };
	// 821BC8F4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821BC8F8: 914100BC  stw r10, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[10].u32 ) };
	// 821BC8FC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BC900: 40810054  ble 0x821bc954
	if !ctx.cr[0].gt {
	pc = 0x821BC954; continue 'dispatch;
	}
	pc = 0x821BC904; continue 'dispatch;
            }
            0x821BC904 => {
    //   block [0x821BC904..0x821BC924)
	// 821BC904: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821BC908: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821BC90C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821BC910: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BC914: 2F070064  cmpwi cr6, r7, 0x64
	ctx.cr[6].compare_i32(ctx.r[7].s32, 100, &mut ctx.xer);
	// 821BC918: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 821BC91C: 41980008  blt cr6, 0x821bc924
	if ctx.cr[6].lt {
	pc = 0x821BC924; continue 'dispatch;
	}
	// 821BC920: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	pc = 0x821BC924; continue 'dispatch;
            }
            0x821BC924 => {
    //   block [0x821BC924..0x821BC940)
	// 821BC924: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821BC928: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821BC92C: 419A0014  beq cr6, 0x821bc940
	if ctx.cr[6].eq {
	pc = 0x821BC940; continue 'dispatch;
	}
	// 821BC930: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821BC934: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821BC938: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821BC93C: 4800000C  b 0x821bc948
	pc = 0x821BC948; continue 'dispatch;
            }
            0x821BC940 => {
    //   block [0x821BC940..0x821BC948)
	// 821BC940: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821BC944: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821BC948; continue 'dispatch;
            }
            0x821BC948 => {
    //   block [0x821BC948..0x821BC954)
	// 821BC948: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BC94C: 4199FFB8  bgt cr6, 0x821bc904
	if ctx.cr[6].gt {
	pc = 0x821BC904; continue 'dispatch;
	}
	// 821BC950: 914100BC  stw r10, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[10].u32 ) };
	pc = 0x821BC954; continue 'dispatch;
            }
            0x821BC954 => {
    //   block [0x821BC954..0x821BC970)
	// 821BC954: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821BC958: 419A0040  beq cr6, 0x821bc998
	if ctx.cr[6].eq {
	pc = 0x821BC998; continue 'dispatch;
	}
	// 821BC95C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BC960: 2F0B0064  cmpwi cr6, r11, 0x64
	ctx.cr[6].compare_i32(ctx.r[11].s32, 100, &mut ctx.xer);
	// 821BC964: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821BC968: 41990008  bgt cr6, 0x821bc970
	if ctx.cr[6].gt {
	pc = 0x821BC970; continue 'dispatch;
	}
	// 821BC96C: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x821BC970; continue 'dispatch;
            }
            0x821BC970 => {
    //   block [0x821BC970..0x821BC998)
	// 821BC970: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821BC974: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC978: 409A0020  bne cr6, 0x821bc998
	if !ctx.cr[6].eq {
	pc = 0x821BC998; continue 'dispatch;
	}
	// 821BC97C: E96100B8  ld r11, 0xb8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	// 821BC980: F96100B8  std r11, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u64 ) };
	// 821BC984: 816100BC  lwz r11, 0xbc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 821BC988: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC98C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821BC990: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821BC994: 4800001C  b 0x821bc9b0
	pc = 0x821BC9B0; continue 'dispatch;
            }
            0x821BC998 => {
    //   block [0x821BC998..0x821BC9AC)
	// 821BC998: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821BC99C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC9A0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821BC9A4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821BC9A8: 48000008  b 0x821bc9b0
	pc = 0x821BC9B0; continue 'dispatch;
            }
            0x821BC9AC => {
    //   block [0x821BC9AC..0x821BC9B0)
	// 821BC9AC: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x821BC9B0; continue 'dispatch;
            }
            0x821BC9B0 => {
    //   block [0x821BC9B0..0x821BCA58)
	// 821BC9B0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821BC9B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BC9B8: 419A00C8  beq cr6, 0x821bca80
	if ctx.cr[6].eq {
	pc = 0x821BCA80; continue 'dispatch;
	}
	// 821BC9BC: 806A0038  lwz r3, 0x38(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 821BC9C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BC9C4: 419A00BC  beq cr6, 0x821bca80
	if ctx.cr[6].eq {
	pc = 0x821BCA80; continue 'dispatch;
	}
	// 821BC9C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BC9CC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BC9D0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821BC9D4: 4E800421  bctrl
	ctx.lr = 0x821BC9D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BC9D8: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 821BC9DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821BC9E0: 38696798  addi r3, r9, 0x6798
	ctx.r[3].s64 = ctx.r[9].s64 + 26520;
	// 821BC9E4: 4841A17D  bl 0x825d6b60
	ctx.lr = 0x821BC9E8;
	sub_825D6B60(ctx, base);
	// 821BC9E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821BC9EC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821BC9F0: 419A0090  beq cr6, 0x821bca80
	if ctx.cr[6].eq {
	pc = 0x821BCA80; continue 'dispatch;
	}
	// 821BC9F4: 92E1009C  stw r23, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[23].u32 ) };
	// 821BC9F8: 38A1009C  addi r5, r1, 0x9c
	ctx.r[5].s64 = ctx.r[1].s64 + 156;
	// 821BC9FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821BCA00: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 821BCA04: 480F0675  bl 0x822ad078
	ctx.lr = 0x821BCA08;
	sub_822AD078(ctx, base);
	// 821BCA08: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821BCA0C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821BCA10: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 821BCA14: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821BCA18: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821BCA1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BCA20: 48AAC431  bl 0x82c68e50
	ctx.lr = 0x821BCA24;
	sub_82C68E50(ctx, base);
	// 821BCA24: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821BCA28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BCA2C: 419A002C  beq cr6, 0x821bca58
	if ctx.cr[6].eq {
	pc = 0x821BCA58; continue 'dispatch;
	}
	// 821BCA30: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821BCA34: 894BEBAD  lbz r10, -0x1453(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-5203 as u32) ) } as u64;
	// 821BCA38: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BCA3C: 419A0044  beq cr6, 0x821bca80
	if ctx.cr[6].eq {
	pc = 0x821BCA80; continue 'dispatch;
	}
	// 821BCA40: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCA44: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCA48: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821BCA4C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821BCA50: 4E800421  bctrl
	ctx.lr = 0x821BCA54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BCA54: 4800002C  b 0x821bca80
	pc = 0x821BCA80; continue 'dispatch;
            }
            0x821BCA58 => {
    //   block [0x821BCA58..0x821BCA7C)
	// 821BCA58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BCA5C: 486AE3AD  bl 0x8286ae08
	ctx.lr = 0x821BCA60;
	sub_8286AE08(ctx, base);
	// 821BCA60: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCA64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BCA68: 419A0014  beq cr6, 0x821bca7c
	if ctx.cr[6].eq {
	pc = 0x821BCA7C; continue 'dispatch;
	}
	// 821BCA6C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCA70: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BCA74: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821BCA78: 4E800421  bctrl
	ctx.lr = 0x821BCA7C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821BCA7C => {
    //   block [0x821BCA7C..0x821BCA80)
	// 821BCA7C: 92FE0000  stw r23, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	pc = 0x821BCA80; continue 'dispatch;
            }
            0x821BCA80 => {
    //   block [0x821BCA80..0x821BCA98)
	// 821BCA80: 897D007C  lbz r11, 0x7c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(124 as u32) ) } as u64;
	// 821BCA84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BCA88: 409A0010  bne cr6, 0x821bca98
	if !ctx.cr[6].eq {
	pc = 0x821BCA98; continue 'dispatch;
	}
	// 821BCA8C: 897D003C  lbz r11, 0x3c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) } as u64;
	// 821BCA90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BCA94: 419A0010  beq cr6, 0x821bcaa4
	if ctx.cr[6].eq {
	pc = 0x821BCAA4; continue 'dispatch;
	}
	pc = 0x821BCA98; continue 'dispatch;
            }
            0x821BCA98 => {
    //   block [0x821BCA98..0x821BCAA4)
	// 821BCA98: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821BCA9C: FC20D090  fmr f1, f26
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[26].f64;
	// 821BCAA0: 480F3B79  bl 0x822b0618
	ctx.lr = 0x821BCAA4;
	sub_822B0618(ctx, base);
	pc = 0x821BCAA4; continue 'dispatch;
            }
            0x821BCAA4 => {
    //   block [0x821BCAA4..0x821BCAC4)
	// 821BCAA4: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821BCAA8: 894BEBAE  lbz r10, -0x1452(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-5202 as u32) ) } as u64;
	// 821BCAAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BCAB0: 419A05E0  beq cr6, 0x821bd090
	if ctx.cr[6].eq {
	pc = 0x821BD090; continue 'dispatch;
	}
	// 821BCAB4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821BCAB8: 92E1009C  stw r23, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[23].u32 ) };
	// 821BCABC: 3B0B7088  addi r24, r11, 0x7088
	ctx.r[24].s64 = ctx.r[11].s64 + 28808;
	// 821BCAC0: 7F08C378  mr r8, r24
	ctx.r[8].u64 = ctx.r[24].u64;
	pc = 0x821BCAC4; continue 'dispatch;
            }
            0x821BCAC4 => {
    //   block [0x821BCAC4..0x821BCAF8)
	// 821BCAC4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821BCAC8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BCACC: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821BCAD0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821BCAD4: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821BCAD8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BCADC: 4082FFE8  bne 0x821bcac4
	if !ctx.cr[0].eq {
	pc = 0x821BCAC4; continue 'dispatch;
	}
	// 821BCAE0: 83FD0030  lwz r31, 0x30(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 821BCAE4: 3B3D002C  addi r25, r29, 0x2c
	ctx.r[25].s64 = ctx.r[29].s64 + 44;
	// 821BCAE8: 80FD0034  lwz r7, 0x34(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 821BCAEC: 7F1F3840  cmplw cr6, r31, r7
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821BCAF0: 40990008  ble cr6, 0x821bcaf8
	if !ctx.cr[6].gt {
	pc = 0x821BCAF8; continue 'dispatch;
	}
	// 821BCAF4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821BCAF8; continue 'dispatch;
            }
            0x821BCAF8 => {
    //   block [0x821BCAF8..0x821BCBA0)
	// 821BCAF8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821BCAFC: 3F80820E  lis r28, -0x7df2
	ctx.r[28].s64 = -2113011712;
	// 821BCB00: 394BB480  addi r10, r11, -0x4b80
	ctx.r[10].s64 = ctx.r[11].s64 + -19328;
	// 821BCB04: 3F60820B  lis r27, -0x7df5
	ctx.r[27].s64 = -2113208320;
	// 821BCB08: 38DCFDD8  addi r6, r28, -0x228
	ctx.r[6].s64 = ctx.r[28].s64 + -552;
	// 821BCB0C: 38BBF298  addi r5, r27, -0xd68
	ctx.r[5].s64 = ctx.r[27].s64 + -3432;
	// 821BCB10: C36BB480  lfs f27, -0x4b80(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19328 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 821BCB14: 3FA0820B  lis r29, -0x7df5
	ctx.r[29].s64 = -2113208320;
	// 821BCB18: 90C100A4  stw r6, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[6].u32 ) };
	// 821BCB1C: C3AA01D0  lfs f29, 0x1d0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(464 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821BCB20: 3F40820C  lis r26, -0x7df4
	ctx.r[26].s64 = -2113142784;
	// 821BCB24: C3CAE004  lfs f30, -0x1ffc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8188 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821BCB28: 90A100A0  stw r5, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[5].u32 ) };
	// 821BCB2C: C38ADE4C  lfs f28, -0x21b4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8628 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821BCB30: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 821BCB34: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 821BCB38: 3CE0820E  lis r7, -0x7df2
	ctx.r[7].s64 = -2113011712;
	// 821BCB3C: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 821BCB40: 3CA0820E  lis r5, -0x7df2
	ctx.r[5].s64 = -2113011712;
	// 821BCB44: 3C80820E  lis r4, -0x7df2
	ctx.r[4].s64 = -2113011712;
	// 821BCB48: 3C60820E  lis r3, -0x7df2
	ctx.r[3].s64 = -2113011712;
	// 821BCB4C: 3FC0820E  lis r30, -0x7df2
	ctx.r[30].s64 = -2113011712;
	// 821BCB50: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 821BCB54: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821BCB58: 39DDF290  addi r14, r29, -0xd70
	ctx.r[14].s64 = ctx.r[29].s64 + -3440;
	// 821BCB5C: 3B9AB9F4  addi r28, r26, -0x460c
	ctx.r[28].s64 = ctx.r[26].s64 + -17932;
	// 821BCB60: 3A89FFDF  addi r20, r9, -0x21
	ctx.r[20].s64 = ctx.r[9].s64 + -33;
	// 821BCB64: 3AC8FE20  addi r22, r8, -0x1e0
	ctx.r[22].s64 = ctx.r[8].s64 + -480;
	// 821BCB68: 3A47FE18  addi r18, r7, -0x1e8
	ctx.r[18].s64 = ctx.r[7].s64 + -488;
	// 821BCB6C: 3AA6FDEC  addi r21, r6, -0x214
	ctx.r[21].s64 = ctx.r[6].s64 + -532;
	// 821BCB70: 3A25FDE8  addi r17, r5, -0x218
	ctx.r[17].s64 = ctx.r[5].s64 + -536;
	// 821BCB74: 3A04FDE4  addi r16, r4, -0x21c
	ctx.r[16].s64 = ctx.r[4].s64 + -540;
	// 821BCB78: 3A63FDE0  addi r19, r3, -0x220
	ctx.r[19].s64 = ctx.r[3].s64 + -544;
	// 821BCB7C: 39FEFDDC  addi r15, r30, -0x224
	ctx.r[15].s64 = ctx.r[30].s64 + -548;
	// 821BCB80: 3B6AFDD4  addi r27, r10, -0x22c
	ctx.r[27].s64 = ctx.r[10].s64 + -556;
	// 821BCB84: 3BAB0B70  addi r29, r11, 0xb70
	ctx.r[29].s64 = ctx.r[11].s64 + 2928;
	// 821BCB88: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821BCB8C: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BCB90: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BCB94: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BCB98: 40990008  ble cr6, 0x821bcba0
	if !ctx.cr[6].gt {
	pc = 0x821BCBA0; continue 'dispatch;
	}
	// 821BCB9C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821BCBA0; continue 'dispatch;
            }
            0x821BCBA0 => {
    //   block [0x821BCBA0..0x821BCBAC)
	// 821BCBA0: 7F19C840  cmplw cr6, r25, r25
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[25].u32, &mut ctx.xer);
	// 821BCBA4: 419A0008  beq cr6, 0x821bcbac
	if ctx.cr[6].eq {
	pc = 0x821BCBAC; continue 'dispatch;
	}
	// 821BCBA8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821BCBAC; continue 'dispatch;
            }
            0x821BCBAC => {
    //   block [0x821BCBAC..0x821BCBBC)
	// 821BCBAC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BCBB0: 419A04B8  beq cr6, 0x821bd068
	if ctx.cr[6].eq {
	pc = 0x821BD068; continue 'dispatch;
	}
	// 821BCBB4: 7F09C378  mr r9, r24
	ctx.r[9].u64 = ctx.r[24].u64;
	// 821BCBB8: 93410090  stw r26, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[26].u32 ) };
	pc = 0x821BCBBC; continue 'dispatch;
            }
            0x821BCBBC => {
    //   block [0x821BCBBC..0x821BCBE8)
	// 821BCBBC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821BCBC0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BCBC4: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821BCBC8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821BCBCC: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821BCBD0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BCBD4: 4082FFE8  bne 0x821bcbbc
	if !ctx.cr[0].eq {
	pc = 0x821BCBBC; continue 'dispatch;
	}
	// 821BCBD8: 81190008  lwz r8, 8(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BCBDC: 7F1F4040  cmplw cr6, r31, r8
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821BCBE0: 41980008  blt cr6, 0x821bcbe8
	if ctx.cr[6].lt {
	pc = 0x821BCBE8; continue 'dispatch;
	}
	// 821BCBE4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821BCBE8; continue 'dispatch;
            }
            0x821BCBE8 => {
    //   block [0x821BCBE8..0x821BCC08)
	// 821BCBE8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCBEC: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BCBF0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCBF4: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821BCBF8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821BCBFC: 4E800421  bctrl
	ctx.lr = 0x821BCC00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BCC00: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821BCC04: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
            }
            0x821BCC08 => {
    //   block [0x821BCC08..0x821BCC34)
	// 821BCC08: 7FCB07B4  extsw r11, r30
	ctx.r[11].s64 = ctx.r[30].s32 as i64;
	// 821BCC0C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821BCC10: F96100C0  std r11, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u64 ) };
	// 821BCC14: C80100C0  lfd f0, 0xc0(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	// 821BCC18: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 821BCC1C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821BCC20: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821BCC24: ED6C0772  fmuls f11, f12, f29
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[29].f64) as f32) as f64);
	// 821BCC28: FF1F5800  fcmpu cr6, f31, f11
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[11].f64);
	// 821BCC2C: 40990008  ble cr6, 0x821bcc34
	if !ctx.cr[6].gt {
	pc = 0x821BCC34; continue 'dispatch;
	}
	// 821BCC30: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	pc = 0x821BCC34; continue 'dispatch;
            }
            0x821BCC34 => {
    //   block [0x821BCC34..0x821BCC60)
	// 821BCC34: 4801DD8D  bl 0x821da9c0
	ctx.lr = 0x821BCC38;
	sub_821DA9C0(ctx, base);
	// 821BCC38: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 821BCC3C: 2F1E000A  cmpwi cr6, r30, 0xa
	ctx.cr[6].compare_i32(ctx.r[30].s32, 10, &mut ctx.xer);
	// 821BCC40: 4198FFC8  blt cr6, 0x821bcc08
	if ctx.cr[6].lt {
	pc = 0x821BCC08; continue 'dispatch;
	}
	// 821BCC44: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821BCC48: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821BCC4C: 4801DD75  bl 0x821da9c0
	ctx.lr = 0x821BCC50;
	sub_821DA9C0(ctx, base);
	// 821BCC50: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BCC54: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BCC58: 41980008  blt cr6, 0x821bcc60
	if ctx.cr[6].lt {
	pc = 0x821BCC60; continue 'dispatch;
	}
	// 821BCC5C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821BCC60; continue 'dispatch;
            }
            0x821BCC60 => {
    //   block [0x821BCC60..0x821BCC84)
	// 821BCC60: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCC64: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821BCC68: 808100A0  lwz r4, 0xa0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 821BCC6C: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821BCC70: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 821BCC74: 552807FE  clrlwi r8, r9, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 821BCC78: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821BCC7C: 409A0008  bne cr6, 0x821bcc84
	if !ctx.cr[6].eq {
	pc = 0x821BCC84; continue 'dispatch;
	}
	// 821BCC80: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	pc = 0x821BCC84; continue 'dispatch;
            }
            0x821BCC84 => {
    //   block [0x821BCC84..0x821BCC98)
	// 821BCC84: 4801DD3D  bl 0x821da9c0
	ctx.lr = 0x821BCC88;
	sub_821DA9C0(ctx, base);
	// 821BCC88: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BCC8C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BCC90: 41980008  blt cr6, 0x821bcc98
	if ctx.cr[6].lt {
	pc = 0x821BCC98; continue 'dispatch;
	}
	// 821BCC94: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821BCC98; continue 'dispatch;
            }
            0x821BCC98 => {
    //   block [0x821BCC98..0x821BCCBC)
	// 821BCC98: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCC9C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821BCCA0: 808100A4  lwz r4, 0xa4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 821BCCA4: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821BCCA8: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 821BCCAC: 552807BC  rlwinm r8, r9, 0, 0x1e, 0x1e
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821BCCB0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821BCCB4: 409A0008  bne cr6, 0x821bccbc
	if !ctx.cr[6].eq {
	pc = 0x821BCCBC; continue 'dispatch;
	}
	// 821BCCB8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	pc = 0x821BCCBC; continue 'dispatch;
            }
            0x821BCCBC => {
    //   block [0x821BCCBC..0x821BCCD0)
	// 821BCCBC: 4801DD05  bl 0x821da9c0
	ctx.lr = 0x821BCCC0;
	sub_821DA9C0(ctx, base);
	// 821BCCC0: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BCCC4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BCCC8: 41980008  blt cr6, 0x821bccd0
	if ctx.cr[6].lt {
	pc = 0x821BCCD0; continue 'dispatch;
	}
	// 821BCCCC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821BCCD0; continue 'dispatch;
            }
            0x821BCCD0 => {
    //   block [0x821BCCD0..0x821BCCF4)
	// 821BCCD0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCCD4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821BCCD8: 7DC47378  mr r4, r14
	ctx.r[4].u64 = ctx.r[14].u64;
	// 821BCCDC: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821BCCE0: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 821BCCE4: 5528077A  rlwinm r8, r9, 0, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821BCCE8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821BCCEC: 409A0008  bne cr6, 0x821bccf4
	if !ctx.cr[6].eq {
	pc = 0x821BCCF4; continue 'dispatch;
	}
	// 821BCCF0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	pc = 0x821BCCF4; continue 'dispatch;
            }
            0x821BCCF4 => {
    //   block [0x821BCCF4..0x821BCD08)
	// 821BCCF4: 4801DCCD  bl 0x821da9c0
	ctx.lr = 0x821BCCF8;
	sub_821DA9C0(ctx, base);
	// 821BCCF8: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BCCFC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BCD00: 41980008  blt cr6, 0x821bcd08
	if ctx.cr[6].lt {
	pc = 0x821BCD08; continue 'dispatch;
	}
	// 821BCD04: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821BCD08; continue 'dispatch;
            }
            0x821BCD08 => {
    //   block [0x821BCD08..0x821BCD2C)
	// 821BCD08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCD0C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821BCD10: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 821BCD14: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821BCD18: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 821BCD1C: 55280738  rlwinm r8, r9, 0, 0x1c, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821BCD20: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821BCD24: 409A0008  bne cr6, 0x821bcd2c
	if !ctx.cr[6].eq {
	pc = 0x821BCD2C; continue 'dispatch;
	}
	// 821BCD28: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	pc = 0x821BCD2C; continue 'dispatch;
            }
            0x821BCD2C => {
    //   block [0x821BCD2C..0x821BCD40)
	// 821BCD2C: 4801DC95  bl 0x821da9c0
	ctx.lr = 0x821BCD30;
	sub_821DA9C0(ctx, base);
	// 821BCD30: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BCD34: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BCD38: 41980008  blt cr6, 0x821bcd40
	if ctx.cr[6].lt {
	pc = 0x821BCD40; continue 'dispatch;
	}
	// 821BCD3C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821BCD40; continue 'dispatch;
            }
            0x821BCD40 => {
    //   block [0x821BCD40..0x821BCD64)
	// 821BCD40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCD44: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821BCD48: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 821BCD4C: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821BCD50: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 821BCD54: 552806F6  rlwinm r8, r9, 0, 0x1b, 0x1b
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821BCD58: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821BCD5C: 409A0008  bne cr6, 0x821bcd64
	if !ctx.cr[6].eq {
	pc = 0x821BCD64; continue 'dispatch;
	}
	// 821BCD60: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	pc = 0x821BCD64; continue 'dispatch;
            }
            0x821BCD64 => {
    //   block [0x821BCD64..0x821BCD78)
	// 821BCD64: 4801DC5D  bl 0x821da9c0
	ctx.lr = 0x821BCD68;
	sub_821DA9C0(ctx, base);
	// 821BCD68: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BCD6C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BCD70: 41980008  blt cr6, 0x821bcd78
	if ctx.cr[6].lt {
	pc = 0x821BCD78; continue 'dispatch;
	}
	// 821BCD74: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821BCD78; continue 'dispatch;
            }
            0x821BCD78 => {
    //   block [0x821BCD78..0x821BCD9C)
	// 821BCD78: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCD7C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821BCD80: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 821BCD84: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821BCD88: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 821BCD8C: 552806B4  rlwinm r8, r9, 0, 0x1a, 0x1a
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821BCD90: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821BCD94: 409A0008  bne cr6, 0x821bcd9c
	if !ctx.cr[6].eq {
	pc = 0x821BCD9C; continue 'dispatch;
	}
	// 821BCD98: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	pc = 0x821BCD9C; continue 'dispatch;
            }
            0x821BCD9C => {
    //   block [0x821BCD9C..0x821BCDB0)
	// 821BCD9C: 4801DC25  bl 0x821da9c0
	ctx.lr = 0x821BCDA0;
	sub_821DA9C0(ctx, base);
	// 821BCDA0: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BCDA4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BCDA8: 41980008  blt cr6, 0x821bcdb0
	if ctx.cr[6].lt {
	pc = 0x821BCDB0; continue 'dispatch;
	}
	// 821BCDAC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821BCDB0; continue 'dispatch;
            }
            0x821BCDB0 => {
    //   block [0x821BCDB0..0x821BCDD4)
	// 821BCDB0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCDB4: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCDB8: C0230028  lfs f1, 0x28(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821BCDBC: 4811688D  bl 0x822d3648
	ctx.lr = 0x821BCDC0;
	sub_822D3648(ctx, base);
	// 821BCDC0: 81590008  lwz r10, 8(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BCDC4: FC600890  fmr f3, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[1].f64;
	// 821BCDC8: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821BCDCC: 41980008  blt cr6, 0x821bcdd4
	if ctx.cr[6].lt {
	pc = 0x821BCDD4; continue 'dispatch;
	}
	// 821BCDD0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821BCDD4; continue 'dispatch;
            }
            0x821BCDD4 => {
    //   block [0x821BCDD4..0x821BCDF8)
	// 821BCDD4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCDD8: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821BCDDC: C04A000C  lfs f2, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821BCDE0: FF02F000  fcmpu cr6, f2, f30
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[30].f64);
	// 821BCDE4: 409A0014  bne cr6, 0x821bcdf8
	if !ctx.cr[6].eq {
	pc = 0x821BCDF8; continue 'dispatch;
	}
	// 821BCDE8: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCDEC: C0230028  lfs f1, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821BCDF0: 48116859  bl 0x822d3648
	ctx.lr = 0x821BCDF4;
	sub_822D3648(ctx, base);
	// 821BCDF4: FC400890  fmr f2, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[1].f64;
	pc = 0x821BCDF8; continue 'dispatch;
            }
            0x821BCDF8 => {
    //   block [0x821BCDF8..0x821BCE08)
	// 821BCDF8: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BCDFC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BCE00: 41980008  blt cr6, 0x821bce08
	if ctx.cr[6].lt {
	pc = 0x821BCE08; continue 'dispatch;
	}
	// 821BCE04: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821BCE08; continue 'dispatch;
            }
            0x821BCE08 => {
    //   block [0x821BCE08..0x821BCE1C)
	// 821BCE08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCE0C: 7F08C378  mr r8, r24
	ctx.r[8].u64 = ctx.r[24].u64;
	// 821BCE10: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCE14: C0270020  lfs f1, 0x20(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(32 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821BCE18: 93410094  stw r26, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[26].u32 ) };
	pc = 0x821BCE1C; continue 'dispatch;
            }
            0x821BCE1C => {
    //   block [0x821BCE1C..0x821BCE84)
	// 821BCE1C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821BCE20: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BCE24: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821BCE28: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821BCE2C: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821BCE30: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BCE34: 4082FFE8  bne 0x821bce1c
	if !ctx.cr[0].eq {
	pc = 0x821BCE1C; continue 'dispatch;
	}
	// 821BCE38: FC80F890  fmr f4, f31
	ctx.f[4].f64 = ctx.f[31].f64;
	// 821BCE3C: D8810040  stfd f4, 0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(64 as u32), ctx.f[4].u64 ) };
	// 821BCE40: D8610038  stfd f3, 0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(56 as u32), ctx.f[3].u64 ) };
	// 821BCE44: E9210040  ld r9, 0x40(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(64 as u32) ) };
	// 821BCE48: E9010038  ld r8, 0x38(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(56 as u32) ) };
	// 821BCE4C: D8410030  stfd f2, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.f[2].u64 ) };
	// 821BCE50: D8210028  stfd f1, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[1].u64 ) };
	// 821BCE54: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 821BCE58: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821BCE5C: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 821BCE60: E8E10030  ld r7, 0x30(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(48 as u32) ) };
	// 821BCE64: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 821BCE68: 48026FE9  bl 0x821e3e50
	ctx.lr = 0x821BCE6C;
	sub_821E3E50(ctx, base);
	// 821BCE6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821BCE70: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821BCE74: 4802F985  bl 0x821ec7f8
	ctx.lr = 0x821BCE78;
	sub_821EC7F8(ctx, base);
	// 821BCE78: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 821BCE7C: 480098ED  bl 0x821c6768
	ctx.lr = 0x821BCE80;
	sub_821C6768(ctx, base);
	// 821BCE80: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	pc = 0x821BCE84; continue 'dispatch;
            }
            0x821BCE84 => {
    //   block [0x821BCE84..0x821BCEB4)
	// 821BCE84: 7CA000A6  mfmsr r5
	ctx.r[5].u64 = ctx.msr;
	// 821BCE88: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BCE8C: 7CC02028  lwarx r6, 0, r4
	// lwarx
	let ea = ctx.r[4].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[6].u64 = ctx.reserved.u32 as u64;
	// 821BCE90: 38C6FFFF  addi r6, r6, -1
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	// 821BCE94: 7CC0212D  stwcx. r6, 0, r4
	// stwcx.
	let addr = ctx.r[4].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[6].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821BCE98: 7CA10164  mtmsrd r5, 1
	ctx.msr = (ctx.r[5].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BCE9C: 4082FFE8  bne 0x821bce84
	if !ctx.cr[0].eq {
	pc = 0x821BCE84; continue 'dispatch;
	}
	// 821BCEA0: 80790008  lwz r3, 8(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BCEA4: 93410094  stw r26, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[26].u32 ) };
	// 821BCEA8: 7F1F1840  cmplw cr6, r31, r3
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821BCEAC: 41980008  blt cr6, 0x821bceb4
	if ctx.cr[6].lt {
	pc = 0x821BCEB4; continue 'dispatch;
	}
	// 821BCEB0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821BCEB4; continue 'dispatch;
            }
            0x821BCEB4 => {
    //   block [0x821BCEB4..0x821BCED0)
	// 821BCEB4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCEB8: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821BCEBC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BCEC0: 409A0010  bne cr6, 0x821bced0
	if !ctx.cr[6].eq {
	pc = 0x821BCED0; continue 'dispatch;
	}
	// 821BCEC4: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 821BCEC8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821BCECC: 4801DAF5  bl 0x821da9c0
	ctx.lr = 0x821BCED0;
	sub_821DA9C0(ctx, base);
	pc = 0x821BCED0; continue 'dispatch;
            }
            0x821BCED0 => {
    //   block [0x821BCED0..0x821BCEE4)
	// 821BCED0: 81610090  lwz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 821BCED4: 7E9EA378  mr r30, r20
	ctx.r[30].u64 = ctx.r[20].u64;
	// 821BCED8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BCEDC: 419A0008  beq cr6, 0x821bcee4
	if ctx.cr[6].eq {
	pc = 0x821BCEE4; continue 'dispatch;
	}
	// 821BCEE0: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821BCEE4; continue 'dispatch;
            }
            0x821BCEE4 => {
    //   block [0x821BCEE4..0x821BD068)
	// 821BCEE4: 7AEB0020  clrldi r11, r23, 0x20
	ctx.r[11].u64 = ctx.r[23].u64 & 0x00000000FFFFFFFFu64;
	// 821BCEE8: 814101D4  lwz r10, 0x1d4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 821BCEEC: D3C100B0  stfs f30, 0xb0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 821BCEF0: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 821BCEF4: F96100C8  std r11, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[11].u64 ) };
	// 821BCEF8: C80100C8  lfd f0, 0xc8(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) };
	// 821BCEFC: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 821BCF00: D3C100A8  stfs f30, 0xa8(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 821BCF04: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BCF08: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821BCF0C: D3C100AC  stfs f30, 0xac(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 821BCF10: 8089007C  lwz r4, 0x7c(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 821BCF14: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BCF18: ED6CDF3A  fmadds f11, f12, f28, f27
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[28].f64 + ctx.f[27].f64) as f32) as f64);
	// 821BCF1C: D16100B8  stfs f11, 0xb8(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 821BCF20: 80E80040  lwz r7, 0x40(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(64 as u32) ) } as u64;
	// 821BCF24: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 821BCF28: 4E800421  bctrl
	ctx.lr = 0x821BCF2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BCF2C: 38C100A8  addi r6, r1, 0xa8
	ctx.r[6].s64 = ctx.r[1].s64 + 168;
	// 821BCF30: 38A100AC  addi r5, r1, 0xac
	ctx.r[5].s64 = ctx.r[1].s64 + 172;
	// 821BCF34: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 821BCF38: 396100B8  addi r11, r1, 0xb8
	ctx.r[11].s64 = ctx.r[1].s64 + 184;
	// 821BCF3C: 394100D0  addi r10, r1, 0xd0
	ctx.r[10].s64 = ctx.r[1].s64 + 208;
            }
            0x821BD068 => {
    //   block [0x821BD068..0x821BD090)
	// 821BD068: 3861009C  addi r3, r1, 0x9c
	ctx.r[3].s64 = ctx.r[1].s64 + 156;
	// 821BD06C: 480096FD  bl 0x821c6768
	ctx.lr = 0x821BD070;
	sub_821C6768(ctx, base);
	// 821BD070: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821BD074: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BD078: 7D60C028  lwarx r11, 0, r24
	// lwarx
	let ea = ctx.r[24].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821BD07C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821BD080: 7D60C12D  stwcx. r11, 0, r24
	// stwcx.
	let addr = ctx.r[24].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821BD084: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BD088: 4082FFE8  bne 0x821bd070
	if !ctx.cr[0].eq {
	pc = 0x821BD070; continue 'dispatch;
	}
	// 821BD08C: 83A101D4  lwz r29, 0x1d4(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	pc = 0x821BD090; continue 'dispatch;
            }
            0x821BD090 => {
    //   block [0x821BD090..0x821BD0C4)
	// 821BD090: 897D00B4  lbz r11, 0xb4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(180 as u32) ) } as u64;
	// 821BD094: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BD098: 409A001C  bne cr6, 0x821bd0b4
	if !ctx.cr[6].eq {
	pc = 0x821BD0B4; continue 'dispatch;
	}
	// 821BD09C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821BD0A0: FC20D090  fmr f1, f26
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[26].f64;
	// 821BD0A4: 4BFBC075  bl 0x82179118
	ctx.lr = 0x821BD0A8;
	sub_82179118(ctx, base);
	// 821BD0A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821BD0AC: FC20D090  fmr f1, f26
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[26].f64;
	// 821BD0B0: 4BFBA8B1  bl 0x82177960
	ctx.lr = 0x821BD0B4;
	sub_82177960(ctx, base);
	// 821BD0B4: 382101C0  addi r1, r1, 0x1c0
	ctx.r[1].s64 = ctx.r[1].s64 + 448;
	// 821BD0B8: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 821BD0BC: 48AF0C61  bl 0x82cadd1c
	ctx.lr = 0x821BD0C0;
	sub_82CADCEC(ctx, base);
	// 821BD0C0: 48AEC360  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BD0C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821BD0C8 size=412
    let mut pc: u32 = 0x821BD0C8;
    'dispatch: loop {
        match pc {
            0x821BD0C8 => {
    //   block [0x821BD0C8..0x821BD13C)
	// 821BD0C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BD0CC: 48AEC331  bl 0x82ca93fc
	ctx.lr = 0x821BD0D0;
	sub_82CA93D0(ctx, base);
	// 821BD0D0: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 821BD0D4: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BD0D8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821BD0DC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821BD0E0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821BD0E4: 38A0000A  li r5, 0xa
	ctx.r[5].s64 = 10;
	// 821BD0E8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821BD0EC: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 821BD0F0: 48037391  bl 0x821f4480
	ctx.lr = 0x821BD0F4;
	sub_821F4480(ctx, base);
	// 821BD0F4: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 821BD0F8: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821BD0FC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BD100: 419A0154  beq cr6, 0x821bd254
	if ctx.cr[6].eq {
	pc = 0x821BD254; continue 'dispatch;
	}
	// 821BD104: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821BD108: 3D207FFF  lis r9, 0x7fff
	ctx.r[9].s64 = 2147418112;
	// 821BD10C: 3B2000D0  li r25, 0xd0
	ctx.r[25].s64 = 208;
	// 821BD110: 613BFFFF  ori r27, r9, 0xffff
	ctx.r[27].u64 = ctx.r[9].u64 | 65535;
	// 821BD114: C3EB9A80  lfs f31, -0x6580(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821BD118: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BD11C: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821BD120: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BD124: 419A0018  beq cr6, 0x821bd13c
	if ctx.cr[6].eq {
	pc = 0x821BD13C; continue 'dispatch;
	}
	// 821BD128: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821BD12C: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821BD130: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 821BD134: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821BD138: 41980008  blt cr6, 0x821bd140
	if ctx.cr[6].lt {
	pc = 0x821BD140; continue 'dispatch;
	}
	pc = 0x821BD13C; continue 'dispatch;
            }
            0x821BD13C => {
    //   block [0x821BD13C..0x821BD140)
	// 821BD13C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821BD140; continue 'dispatch;
            }
            0x821BD140 => {
    //   block [0x821BD140..0x821BD23C)
	// 821BD140: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821BD144: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821BD148: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821BD14C: 7FEA582E  lwzx r31, r10, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821BD150: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BD154: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD158: 81090068  lwz r8, 0x68(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(104 as u32) ) } as u64;
	// 821BD15C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821BD160: 4E800421  bctrl
	ctx.lr = 0x821BD164;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BD164: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821BD168: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821BD16C: 419A00D0  beq cr6, 0x821bd23c
	if ctx.cr[6].eq {
	pc = 0x821BD23C; continue 'dispatch;
	}
            }
            0x821BD23C => {
    //   block [0x821BD23C..0x821BD254)
	// 821BD23C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821BD240: 48042B39  bl 0x821ffd78
	ctx.lr = 0x821BD244;
	sub_821FFD78(ctx, base);
	// 821BD244: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 821BD248: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821BD24C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BD250: 409AFEC8  bne cr6, 0x821bd118
	if !ctx.cr[6].eq {
	pc = 0x821BD118; continue 'dispatch;
	}
	pc = 0x821BD254; continue 'dispatch;
            }
            0x821BD254 => {
    //   block [0x821BD254..0x821BD264)
	// 821BD254: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821BD258: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821BD25C: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 821BD260: 48AEC1EC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BD268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BD268 size=488
    let mut pc: u32 = 0x821BD268;
    'dispatch: loop {
        match pc {
            0x821BD268 => {
    //   block [0x821BD268..0x821BD2A0)
	// 821BD268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BD26C: 48AEC199  bl 0x82ca9404
	ctx.lr = 0x821BD270;
	sub_82CA93D0(ctx, base);
	// 821BD270: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BD274: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 821BD278: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821BD27C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821BD280: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BD284: 808BE50C  lwz r4, -0x1af4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6900 as u32) ) } as u64;
	// 821BD288: 480C7659  bl 0x822848e0
	ctx.lr = 0x821BD28C;
	sub_822848E0(ctx, base);
	// 821BD28C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BD290: 419A0010  beq cr6, 0x821bd2a0
	if ctx.cr[6].eq {
	pc = 0x821BD2A0; continue 'dispatch;
	}
	// 821BD294: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BD298: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821BD29C: 4800000C  b 0x821bd2a8
	pc = 0x821BD2A8; continue 'dispatch;
            }
            0x821BD2A0 => {
    //   block [0x821BD2A0..0x821BD2A8)
	// 821BD2A0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821BD2A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821BD2A8; continue 'dispatch;
            }
            0x821BD2A8 => {
    //   block [0x821BD2A8..0x821BD2D0)
	// 821BD2A8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821BD2AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BD2B0: 419A0198  beq cr6, 0x821bd448
	if ctx.cr[6].eq {
	pc = 0x821BD448; continue 'dispatch;
	}
	// 821BD2B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821BD2B8: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD2BC: 3BCB0CA0  addi r30, r11, 0xca0
	ctx.r[30].s64 = ctx.r[11].s64 + 3232;
	// 821BD2C0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821BD2C4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821BD2C8: 419A0008  beq cr6, 0x821bd2d0
	if ctx.cr[6].eq {
	pc = 0x821BD2D0; continue 'dispatch;
	}
	// 821BD2CC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x821BD2D0; continue 'dispatch;
            }
            0x821BD2D0 => {
    //   block [0x821BD2D0..0x821BD2E4)
	// 821BD2D0: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821BD2D4: 814AB2AC  lwz r10, -0x4d54(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19796 as u32) ) } as u64;
	// 821BD2D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BD2DC: 409A0034  bne cr6, 0x821bd310
	if !ctx.cr[6].eq {
	pc = 0x821BD310; continue 'dispatch;
	}
	// 821BD2E0: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	pc = 0x821BD2E4; continue 'dispatch;
            }
            0x821BD2E4 => {
    //   block [0x821BD2E4..0x821BD308)
	// 821BD2E4: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD2E8: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD2EC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821BD2F0: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821BD2F4: 419A0014  beq cr6, 0x821bd308
	if ctx.cr[6].eq {
	pc = 0x821BD308; continue 'dispatch;
	}
	// 821BD2F8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821BD2FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821BD300: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821BD304: 419AFFE0  beq cr6, 0x821bd2e4
	if ctx.cr[6].eq {
	pc = 0x821BD2E4; continue 'dispatch;
	}
	pc = 0x821BD308; continue 'dispatch;
            }
            0x821BD308 => {
    //   block [0x821BD308..0x821BD310)
	// 821BD308: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821BD30C: 48000014  b 0x821bd320
	pc = 0x821BD320; continue 'dispatch;
            }
            0x821BD310 => {
    //   block [0x821BD310..0x821BD320)
	// 821BD310: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 821BD314: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD318: 480B04E1  bl 0x8226d7f8
	ctx.lr = 0x821BD31C;
	sub_8226D7F8(ctx, base);
	// 821BD31C: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	pc = 0x821BD320; continue 'dispatch;
            }
            0x821BD320 => {
    //   block [0x821BD320..0x821BD340)
	// 821BD320: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821BD324: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821BD328: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BD32C: 409A0078  bne cr6, 0x821bd3a4
	if !ctx.cr[6].eq {
	pc = 0x821BD3A4; continue 'dispatch;
	}
	// 821BD330: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821BD334: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821BD338: 419A0008  beq cr6, 0x821bd340
	if ctx.cr[6].eq {
	pc = 0x821BD340; continue 'dispatch;
	}
	// 821BD33C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x821BD340; continue 'dispatch;
            }
            0x821BD340 => {
    //   block [0x821BD340..0x821BD354)
	// 821BD340: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821BD344: 814AB2F0  lwz r10, -0x4d10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19728 as u32) ) } as u64;
	// 821BD348: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BD34C: 409A0034  bne cr6, 0x821bd380
	if !ctx.cr[6].eq {
	pc = 0x821BD380; continue 'dispatch;
	}
	// 821BD350: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	pc = 0x821BD354; continue 'dispatch;
            }
            0x821BD354 => {
    //   block [0x821BD354..0x821BD378)
	// 821BD354: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD358: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD35C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821BD360: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821BD364: 419A0014  beq cr6, 0x821bd378
	if ctx.cr[6].eq {
	pc = 0x821BD378; continue 'dispatch;
	}
	// 821BD368: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821BD36C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821BD370: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821BD374: 419AFFE0  beq cr6, 0x821bd354
	if ctx.cr[6].eq {
	pc = 0x821BD354; continue 'dispatch;
	}
	pc = 0x821BD378; continue 'dispatch;
            }
            0x821BD378 => {
    //   block [0x821BD378..0x821BD380)
	// 821BD378: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821BD37C: 48000014  b 0x821bd390
	pc = 0x821BD390; continue 'dispatch;
            }
            0x821BD380 => {
    //   block [0x821BD380..0x821BD390)
	// 821BD380: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 821BD384: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD388: 480B0471  bl 0x8226d7f8
	ctx.lr = 0x821BD38C;
	sub_8226D7F8(ctx, base);
	// 821BD38C: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	pc = 0x821BD390; continue 'dispatch;
            }
            0x821BD390 => {
    //   block [0x821BD390..0x821BD3A4)
	// 821BD390: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821BD394: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821BD398: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BD39C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821BD3A0: 419A0008  beq cr6, 0x821bd3a8
	if ctx.cr[6].eq {
	pc = 0x821BD3A8; continue 'dispatch;
	}
	pc = 0x821BD3A4; continue 'dispatch;
            }
            0x821BD3A4 => {
    //   block [0x821BD3A4..0x821BD3A8)
	// 821BD3A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x821BD3A8; continue 'dispatch;
            }
            0x821BD3A8 => {
    //   block [0x821BD3A8..0x821BD3BC)
	// 821BD3A8: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821BD3AC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821BD3B0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821BD3B4: 419A0008  beq cr6, 0x821bd3bc
	if ctx.cr[6].eq {
	pc = 0x821BD3BC; continue 'dispatch;
	}
	// 821BD3B8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x821BD3BC; continue 'dispatch;
            }
            0x821BD3BC => {
    //   block [0x821BD3BC..0x821BD3D0)
	// 821BD3BC: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821BD3C0: 814AB2F4  lwz r10, -0x4d0c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19724 as u32) ) } as u64;
	// 821BD3C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BD3C8: 409A0034  bne cr6, 0x821bd3fc
	if !ctx.cr[6].eq {
	pc = 0x821BD3FC; continue 'dispatch;
	}
	// 821BD3CC: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	pc = 0x821BD3D0; continue 'dispatch;
            }
            0x821BD3D0 => {
    //   block [0x821BD3D0..0x821BD3F4)
	// 821BD3D0: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD3D4: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD3D8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821BD3DC: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821BD3E0: 419A0014  beq cr6, 0x821bd3f4
	if ctx.cr[6].eq {
	pc = 0x821BD3F4; continue 'dispatch;
	}
	// 821BD3E4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821BD3E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821BD3EC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821BD3F0: 419AFFE0  beq cr6, 0x821bd3d0
	if ctx.cr[6].eq {
	pc = 0x821BD3D0; continue 'dispatch;
	}
	pc = 0x821BD3F4; continue 'dispatch;
            }
            0x821BD3F4 => {
    //   block [0x821BD3F4..0x821BD3FC)
	// 821BD3F4: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821BD3F8: 48000014  b 0x821bd40c
	pc = 0x821BD40C; continue 'dispatch;
            }
            0x821BD3FC => {
    //   block [0x821BD3FC..0x821BD40C)
	// 821BD3FC: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 821BD400: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD404: 480B03F5  bl 0x8226d7f8
	ctx.lr = 0x821BD408;
	sub_8226D7F8(ctx, base);
	// 821BD408: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	pc = 0x821BD40C; continue 'dispatch;
            }
            0x821BD40C => {
    //   block [0x821BD40C..0x821BD424)
	// 821BD40C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821BD410: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821BD414: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BD418: 419A000C  beq cr6, 0x821bd424
	if ctx.cr[6].eq {
	pc = 0x821BD424; continue 'dispatch;
	}
	// 821BD41C: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 821BD420: 3B800002  li r28, 2
	ctx.r[28].s64 = 2;
	pc = 0x821BD424; continue 'dispatch;
            }
            0x821BD424 => {
    //   block [0x821BD424..0x821BD448)
	// 821BD424: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 821BD428: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BD42C: 419A001C  beq cr6, 0x821bd448
	if ctx.cr[6].eq {
	pc = 0x821BD448; continue 'dispatch;
	}
	// 821BD430: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821BD434: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821BD438: 389B007C  addi r4, r27, 0x7c
	ctx.r[4].s64 = ctx.r[27].s64 + 124;
	// 821BD43C: 816B6B08  lwz r11, 0x6b08(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821BD440: 806B002C  lwz r3, 0x2c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821BD444: 480F6135  bl 0x822b3578
	ctx.lr = 0x821BD448;
	sub_822B3578(ctx, base);
	pc = 0x821BD448; continue 'dispatch;
            }
            0x821BD448 => {
    //   block [0x821BD448..0x821BD450)
	// 821BD448: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821BD44C: 48AEC008  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BD450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BD450 size=116
    let mut pc: u32 = 0x821BD450;
    'dispatch: loop {
        match pc {
            0x821BD450 => {
    //   block [0x821BD450..0x821BD4C4)
	// 821BD450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BD454: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821BD458: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821BD45C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821BD460: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BD464: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821BD468: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821BD46C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821BD470: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821BD474: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BD478: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821BD47C: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BD480: 80680018  lwz r3, 0x18(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) } as u64;
	// 821BD484: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD488: 80C70058  lwz r6, 0x58(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(88 as u32) ) } as u64;
	// 821BD48C: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 821BD490: 4E800421  bctrl
	ctx.lr = 0x821BD494;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BD494: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD498: 80BF0038  lwz r5, 0x38(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821BD49C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821BD4A0: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821BD4A4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821BD4A8: 4E800421  bctrl
	ctx.lr = 0x821BD4AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BD4AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821BD4B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821BD4B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821BD4B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821BD4BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821BD4C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BD4C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BD4C8 size=164
    let mut pc: u32 = 0x821BD4C8;
    'dispatch: loop {
        match pc {
            0x821BD4C8 => {
    //   block [0x821BD4C8..0x821BD554)
	// 821BD4C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BD4CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821BD4D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821BD4D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821BD4D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BD4DC: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821BD4E0: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 821BD4E4: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 821BD4E8: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 821BD4EC: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 821BD4F0: 7D274B78  mr r7, r9
	ctx.r[7].u64 = ctx.r[9].u64;
	// 821BD4F4: 80DF0010  lwz r6, 0x10(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821BD4F8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 821BD4FC: 4805C3BD  bl 0x822198b8
	ctx.lr = 0x821BD500;
	sub_822198B8(ctx, base);
	// 821BD500: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821BD504: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821BD508: 93E30034  stw r31, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[31].u32 ) };
	// 821BD50C: 390A1638  addi r8, r10, 0x1638
	ctx.r[8].s64 = ctx.r[10].s64 + 5688;
	// 821BD510: 93C30038  stw r30, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 821BD514: 91230024  stw r9, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[9].u32 ) };
	// 821BD518: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821BD51C: 80FF0128  lwz r7, 0x128(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 821BD520: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821BD524: 40990030  ble cr6, 0x821bd554
	if !ctx.cr[6].gt {
	pc = 0x821BD554; continue 'dispatch;
	}
	// 821BD528: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BD52C: 3940000C  li r10, 0xc
	ctx.r[10].s64 = 12;
	// 821BD530: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821BD534: 81690D50  lwz r11, 0xd50(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3408 as u32) ) } as u64;
	// 821BD538: 810B004C  lwz r8, 0x4c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821BD53C: 80EB0048  lwz r7, 0x48(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821BD540: 7CC74050  subf r6, r7, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 821BD544: 7CA653D7  divw. r5, r6, r10
	ctx.r[5].s32 = ctx.r[6].s32 / ctx.r[10].s32;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 821BD548: 4182000C  beq 0x821bd554
	if ctx.cr[0].eq {
	pc = 0x821BD554; continue 'dispatch;
	}
	// 821BD54C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 821BD550: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	pc = 0x821BD554; continue 'dispatch;
            }
            0x821BD554 => {
    //   block [0x821BD554..0x821BD56C)
	// 821BD554: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821BD558: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821BD55C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821BD560: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821BD564: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821BD568: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BD570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821BD570 size=240
    let mut pc: u32 = 0x821BD570;
    'dispatch: loop {
        match pc {
            0x821BD570 => {
    //   block [0x821BD570..0x821BD660)
	// 821BD570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BD574: 48AEBE8D  bl 0x82ca9400
	ctx.lr = 0x821BD578;
	sub_82CA93D0(ctx, base);
	// 821BD578: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BD57C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821BD580: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821BD584: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821BD588: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BD58C: 806B0018  lwz r3, 0x18(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821BD590: 4804B581  bl 0x82208b10
	ctx.lr = 0x821BD594;
	sub_82208B10(ctx, base);
	// 821BD594: 3F80820A  lis r28, -0x7df6
	ctx.r[28].s64 = -2113273856;
	// 821BD598: 38600015  li r3, 0x15
	ctx.r[3].s64 = 21;
	// 821BD59C: 3B7C9490  addi r27, r28, -0x6b70
	ctx.r[27].s64 = ctx.r[28].s64 + -27504;
	// 821BD5A0: C03B1FF0  lfs f1, 0x1ff0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8176 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821BD5A4: 4802B6D5  bl 0x821e8c78
	ctx.lr = 0x821BD5A8;
	sub_821E8C78(ctx, base);
	// 821BD5A8: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 821BD5AC: C03F001C  lfs f1, 0x1c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821BD5B0: 4802B6C9  bl 0x821e8c78
	ctx.lr = 0x821BD5B4;
	sub_821E8C78(ctx, base);
	// 821BD5B4: 386000B2  li r3, 0xb2
	ctx.r[3].s64 = 178;
	// 821BD5B8: C03F0020  lfs f1, 0x20(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821BD5BC: 4802B6BD  bl 0x821e8c78
	ctx.lr = 0x821BD5C0;
	sub_821E8C78(ctx, base);
	// 821BD5C0: 38600019  li r3, 0x19
	ctx.r[3].s64 = 25;
	// 821BD5C4: E89F0014  ld r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	// 821BD5C8: 48048351  bl 0x82205918
	ctx.lr = 0x821BD5CC;
	sub_82205918(ctx, base);
	// 821BD5CC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 821BD5D0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821BD5D4: 80DF000C  lwz r6, 0xc(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BD5D8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 821BD5DC: 3D20834C  lis r9, -0x7cb4
	ctx.r[9].s64 = -2092171264;
	// 821BD5E0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821BD5E4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 821BD5E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821BD5EC: 3B49DED4  addi r26, r9, -0x212c
	ctx.r[26].s64 = ctx.r[9].s64 + -8492;
	// 821BD5F0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821BD5F4: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 821BD5F8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 821BD5FC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821BD600: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BD604: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BD608: 80AB0870  lwz r5, 0x870(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2160 as u32) ) } as u64;
	// 821BD60C: 480AADF5  bl 0x82268400
	ctx.lr = 0x821BD610;
	sub_82268400(ctx, base);
	// 821BD610: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BD614: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 821BD618: 80DF0010  lwz r6, 0x10(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821BD61C: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 821BD620: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BD624: 80AB0054  lwz r5, 0x54(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 821BD628: 480AADD9  bl 0x82268400
	ctx.lr = 0x821BD62C;
	sub_82268400(ctx, base);
	// 821BD62C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821BD630: C01BFFF4  lfs f0, -0xc(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821BD634: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821BD638: C1BC9490  lfs f13, -0x6b70(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821BD63C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821BD640: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821BD644: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BD648: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821BD64C: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821BD650: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 821BD654: 4802F97D  bl 0x821ecfd0
	ctx.lr = 0x821BD658;
	sub_821ECFD0(ctx, base);
	// 821BD658: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821BD65C: 48AEBDF4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BD660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BD660 size=312
    let mut pc: u32 = 0x821BD660;
    'dispatch: loop {
        match pc {
            0x821BD660 => {
    //   block [0x821BD660..0x821BD690)
	// 821BD660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BD664: 48AEBDA9  bl 0x82ca940c
	ctx.lr = 0x821BD668;
	sub_82CA93D0(ctx, base);
	// 821BD668: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BD66C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821BD670: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821BD674: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821BD678: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD67C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BD680: 419A0010  beq cr6, 0x821bd690
	if ctx.cr[6].eq {
	pc = 0x821BD690; continue 'dispatch;
	}
	// 821BD684: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BD688: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BD68C: 409A0024  bne cr6, 0x821bd6b0
	if !ctx.cr[6].eq {
	pc = 0x821BD6B0; continue 'dispatch;
	}
	pc = 0x821BD690; continue 'dispatch;
            }
            0x821BD690 => {
    //   block [0x821BD690..0x821BD6B0)
	// 821BD690: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821BD694: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821BD698: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 821BD69C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BD6A0: 4806F831  bl 0x8222ced0
	ctx.lr = 0x821BD6A4;
	sub_8222CED0(ctx, base);
	// 821BD6A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BD6A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821BD6AC: 48AEBDB0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821BD6B0 => {
    //   block [0x821BD6B0..0x821BD6E4)
	// 821BD6B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821BD6B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BD6B8: 388B0C08  addi r4, r11, 0xc08
	ctx.r[4].s64 = ctx.r[11].s64 + 3080;
	// 821BD6BC: 4802908D  bl 0x821e6748
	ctx.lr = 0x821BD6C0;
	sub_821E6748(ctx, base);
	// 821BD6C0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821BD6C4: 409800BC  bge cr6, 0x821bd780
	if !ctx.cr[6].lt {
	pc = 0x821BD780; continue 'dispatch;
	}
	// 821BD6C8: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 821BD6CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD6D0: 392AFFDF  addi r9, r10, -0x21
	ctx.r[9].s64 = ctx.r[10].s64 + -33;
	// 821BD6D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BD6D8: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 821BD6DC: 419A0008  beq cr6, 0x821bd6e4
	if ctx.cr[6].eq {
	pc = 0x821BD6E4; continue 'dispatch;
	}
	// 821BD6E0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821BD6E4; continue 'dispatch;
            }
            0x821BD6E4 => {
    //   block [0x821BD6E4..0x821BD700)
	// 821BD6E4: 894A0000  lbz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD6E8: 2B0A002E  cmplwi cr6, r10, 0x2e
	ctx.cr[6].compare_u32(ctx.r[10].u32, 46 as u32, &mut ctx.xer);
	// 821BD6EC: 419A0094  beq cr6, 0x821bd780
	if ctx.cr[6].eq {
	pc = 0x821BD780; continue 'dispatch;
	}
	// 821BD6F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BD6F4: 409A000C  bne cr6, 0x821bd700
	if !ctx.cr[6].eq {
	pc = 0x821BD700; continue 'dispatch;
	}
	// 821BD6F8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821BD6FC: 48000008  b 0x821bd704
	pc = 0x821BD704; continue 'dispatch;
            }
            0x821BD700 => {
    //   block [0x821BD700..0x821BD704)
	// 821BD700: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821BD704; continue 'dispatch;
            }
            0x821BD704 => {
    //   block [0x821BD704..0x821BD754)
	// 821BD704: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD708: 2B0B005C  cmplwi cr6, r11, 0x5c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 92 as u32, &mut ctx.xer);
	// 821BD70C: 419A0074  beq cr6, 0x821bd780
	if ctx.cr[6].eq {
	pc = 0x821BD780; continue 'dispatch;
	}
	// 821BD710: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821BD714: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BD718: 48032B29  bl 0x821f0240
	ctx.lr = 0x821BD71C;
	sub_821F0240(ctx, base);
	// 821BD71C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821BD720: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BD724: 419A0030  beq cr6, 0x821bd754
	if ctx.cr[6].eq {
	pc = 0x821BD754; continue 'dispatch;
	}
	// 821BD728: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BD72C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BD730: 40990024  ble cr6, 0x821bd754
	if !ctx.cr[6].gt {
	pc = 0x821BD754; continue 'dispatch;
	}
	// 821BD734: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD738: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821BD73C: 894BFFFF  lbz r10, -1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 821BD740: 2B0A005C  cmplwi cr6, r10, 0x5c
	ctx.cr[6].compare_u32(ctx.r[10].u32, 92 as u32, &mut ctx.xer);
	// 821BD744: 419A0010  beq cr6, 0x821bd754
	if ctx.cr[6].eq {
	pc = 0x821BD754; continue 'dispatch;
	}
	// 821BD748: 3880005C  li r4, 0x5c
	ctx.r[4].s64 = 92;
	// 821BD74C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BD750: 4BFD9B21  bl 0x82197270
	ctx.lr = 0x821BD754;
	sub_82197270(ctx, base);
	pc = 0x821BD754; continue 'dispatch;
            }
            0x821BD754 => {
    //   block [0x821BD754..0x821BD780)
	// 821BD754: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821BD758: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BD75C: 4802F09D  bl 0x821ec7f8
	ctx.lr = 0x821BD760;
	sub_821EC7F8(ctx, base);
	// 821BD760: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821BD764: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BD768: 48032AD9  bl 0x821f0240
	ctx.lr = 0x821BD76C;
	sub_821F0240(ctx, base);
	// 821BD76C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BD770: 48057669  bl 0x82214dd8
	ctx.lr = 0x821BD774;
	sub_82214DD8(ctx, base);
	// 821BD774: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BD778: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821BD77C: 48AEBCE0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821BD780 => {
    //   block [0x821BD780..0x821BD798)
	// 821BD780: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821BD784: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BD788: 48032AB9  bl 0x821f0240
	ctx.lr = 0x821BD78C;
	sub_821F0240(ctx, base);
	// 821BD78C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821BD790: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821BD794: 48AEBCC8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BD798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BD798 size=320
    let mut pc: u32 = 0x821BD798;
    'dispatch: loop {
        match pc {
            0x821BD798 => {
    //   block [0x821BD798..0x821BD81C)
	// 821BD798: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BD79C: 48AEBC71  bl 0x82ca940c
	ctx.lr = 0x821BD7A0;
	sub_82CA93D0(ctx, base);
	// 821BD7A0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BD7A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821BD7A8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821BD7AC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821BD7B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821BD7B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821BD7B8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821BD7BC: 48032A85  bl 0x821f0240
	ctx.lr = 0x821BD7C0;
	sub_821F0240(ctx, base);
	// 821BD7C0: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821BD7C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821BD7C8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821BD7CC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 821BD7D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821BD7D4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821BD7D8: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821BD7DC: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821BD7E0: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821BD7E4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 821BD7E8: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821BD7EC: 48221A85  bl 0x823df270
	ctx.lr = 0x821BD7F0;
	sub_823DF270(ctx, base);
	// 821BD7F0: 813F0028  lwz r9, 0x28(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821BD7F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821BD7F8: 81010064  lwz r8, 0x64(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821BD7FC: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821BD800: 419A001C  beq cr6, 0x821bd81c
	if ctx.cr[6].eq {
	pc = 0x821BD81C; continue 'dispatch;
	}
	// 821BD804: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 821BD808: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821BD80C: 482212D5  bl 0x823deae0
	ctx.lr = 0x821BD810;
	sub_823DEAE0(ctx, base);
	// 821BD810: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821BD814: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821BD818: 48AEBC44  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821BD81C => {
    //   block [0x821BD81C..0x821BD854)
	// 821BD81C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821BD820: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821BD824: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821BD828: 480B4201  bl 0x82271a28
	ctx.lr = 0x821BD82C;
	sub_82271A28(ctx, base);
	// 821BD82C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821BD830: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BD834: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821BD838: 419A0048  beq cr6, 0x821bd880
	if ctx.cr[6].eq {
	pc = 0x821BD880; continue 'dispatch;
	}
	// 821BD83C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BD840: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD844: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BD848: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821BD84C: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 821BD850: 419A0020  beq cr6, 0x821bd870
	if ctx.cr[6].eq {
	pc = 0x821BD870; continue 'dispatch;
	}
	pc = 0x821BD854; continue 'dispatch;
            }
            0x821BD854 => {
    //   block [0x821BD854..0x821BD870)
	// 821BD854: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821BD858: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BD85C: 7D605028  lwarx r11, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821BD860: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821BD864: 7D60512D  stwcx. r11, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821BD868: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BD86C: 4082FFE8  bne 0x821bd854
	if !ctx.cr[0].eq {
	pc = 0x821BD854; continue 'dispatch;
	}
	pc = 0x821BD870; continue 'dispatch;
            }
            0x821BD870 => {
    //   block [0x821BD870..0x821BD880)
	// 821BD870: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BD874: 409A0018  bne cr6, 0x821bd88c
	if !ctx.cr[6].eq {
	pc = 0x821BD88C; continue 'dispatch;
	}
	// 821BD878: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BD87C: 4BFFA29D  bl 0x821b7b18
	ctx.lr = 0x821BD880;
	sub_821B7B18(ctx, base);
	pc = 0x821BD880; continue 'dispatch;
            }
            0x821BD880 => {
    //   block [0x821BD880..0x821BD88C)
	// 821BD880: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821BD884: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821BD888: 48AEBBD4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821BD88C => {
    //   block [0x821BD88C..0x821BD8C4)
	// 821BD88C: 89630064  lbz r11, 0x64(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(100 as u32) ) } as u64;
	// 821BD890: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BD894: 409A0030  bne cr6, 0x821bd8c4
	if !ctx.cr[6].eq {
	pc = 0x821BD8C4; continue 'dispatch;
	}
	// 821BD898: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD89C: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821BD8A0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821BD8A4: 4E800421  bctrl
	ctx.lr = 0x821BD8A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BD8A8: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821BD8AC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821BD8B0: 419A0014  beq cr6, 0x821bd8c4
	if ctx.cr[6].eq {
	pc = 0x821BD8C4; continue 'dispatch;
	}
	// 821BD8B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821BD8B8: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821BD8BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821BD8C0: 48220519  bl 0x823dddd8
	ctx.lr = 0x821BD8C4;
	sub_823DDDD8(ctx, base);
            }
            0x821BD8C4 => {
    //   block [0x821BD8C4..0x821BD8D8)
	// 821BD8C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BD8C8: 4BFFA251  bl 0x821b7b18
	ctx.lr = 0x821BD8CC;
	sub_821B7B18(ctx, base);
	// 821BD8CC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821BD8D0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821BD8D4: 48AEBB88  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BD8D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821BD8D8 size=20
    let mut pc: u32 = 0x821BD8D8;
    'dispatch: loop {
        match pc {
            0x821BD8D8 => {
    //   block [0x821BD8D8..0x821BD8EC)
	// 821BD8D8: 8963001D  lbz r11, 0x1d(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(29 as u32) ) } as u64;
	// 821BD8DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BD8E0: 419A000C  beq cr6, 0x821bd8ec
	if ctx.cr[6].eq {
		sub_821BD8EC(ctx, base);
		return;
	}
	// 821BD8E4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821BD8E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BD8EC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821BD8EC size=40
    let mut pc: u32 = 0x821BD8EC;
    'dispatch: loop {
        match pc {
            0x821BD8EC => {
    //   block [0x821BD8EC..0x821BD914)
	// 821BD8EC: 8963001C  lbz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 821BD8F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BD8F4: 409AFFF0  bne cr6, 0x821bd8e4
	if !ctx.cr[6].eq {
		sub_821BD8D8(ctx, base);
		return;
	}
	// 821BD8F8: C0030008  lfs f0, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821BD8FC: C1A30010  lfs f13, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821BD900: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821BD904: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821BD908: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 821BD90C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821BD910: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BD918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BD918 size=868
    let mut pc: u32 = 0x821BD918;
    'dispatch: loop {
        match pc {
            0x821BD918 => {
    //   block [0x821BD918..0x821BD954)
	// 821BD918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BD91C: 48AEBADD  bl 0x82ca93f8
	ctx.lr = 0x821BD920;
	sub_82CA93D0(ctx, base);
	// 821BD920: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BD924: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821BD928: 3B60000C  li r27, 0xc
	ctx.r[27].s64 = 12;
	// 821BD92C: 3B590024  addi r26, r25, 0x24
	ctx.r[26].s64 = ctx.r[25].s64 + 36;
	// 821BD930: 8179002C  lwz r11, 0x2c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(44 as u32) ) } as u64;
	// 821BD934: 81590028  lwz r10, 0x28(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(40 as u32) ) } as u64;
	// 821BD938: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821BD93C: 7D09DBD6  divw r8, r9, r27
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	// 821BD940: 3788FFFF  addic. r28, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 821BD944: 4180008C  blt 0x821bd9d0
	if ctx.cr[0].lt {
	pc = 0x821BD9D0; continue 'dispatch;
	}
	// 821BD948: 578B083C  slwi r11, r28, 1
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821BD94C: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 821BD950: 557D103A  slwi r29, r11, 2
	ctx.r[29].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	pc = 0x821BD954; continue 'dispatch;
            }
            0x821BD954 => {
    //   block [0x821BD954..0x821BD970)
	// 821BD954: 81790028  lwz r11, 0x28(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(40 as u32) ) } as u64;
	// 821BD958: 7FFD5A14  add r31, r29, r11
	ctx.r[31].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 821BD95C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BD960: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BD964: 419A000C  beq cr6, 0x821bd970
	if ctx.cr[6].eq {
	pc = 0x821BD970; continue 'dispatch;
	}
	// 821BD968: 386B0244  addi r3, r11, 0x244
	ctx.r[3].s64 = ctx.r[11].s64 + 580;
	// 821BD96C: 4803E69D  bl 0x821fc008
	ctx.lr = 0x821BD970;
	sub_821FC008(ctx, base);
	pc = 0x821BD970; continue 'dispatch;
            }
            0x821BD970 => {
    //   block [0x821BD970..0x821BD9C4)
	// 821BD970: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BD974: 83D90000  lwz r30, 0(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BD978: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BD97C: 419A0048  beq cr6, 0x821bd9c4
	if ctx.cr[6].eq {
	pc = 0x821BD9C4; continue 'dispatch;
	}
	// 821BD980: 4803E871  bl 0x821fc1f0
	ctx.lr = 0x821BD984;
	sub_821FC1F0(ctx, base);
	// 821BD984: 387E0020  addi r3, r30, 0x20
	ctx.r[3].s64 = ctx.r[30].s64 + 32;
	// 821BD988: 831F0004  lwz r24, 4(r31)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BD98C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821BD990: 4802B279  bl 0x821e8c08
	ctx.lr = 0x821BD994;
	sub_821E8C08(ctx, base);
	// 821BD994: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BD998: 4803E671  bl 0x821fc008
	ctx.lr = 0x821BD99C;
	sub_821FC008(ctx, base);
	// 821BD99C: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 821BD9A0: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 821BD9A4: 419A0020  beq cr6, 0x821bd9c4
	if ctx.cr[6].eq {
	pc = 0x821BD9C4; continue 'dispatch;
	}
	// 821BD9A8: 817E0038  lwz r11, 0x38(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 821BD9AC: 387E0034  addi r3, r30, 0x34
	ctx.r[3].s64 = ctx.r[30].s64 + 52;
	// 821BD9B0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821BD9B4: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 821BD9B8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 821BD9BC: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821BD9C0: 488D99A9  bl 0x82a97368
	ctx.lr = 0x821BD9C4;
	sub_82A97368(ctx, base);
	pc = 0x821BD9C4; continue 'dispatch;
            }
            0x821BD9C4 => {
    //   block [0x821BD9C4..0x821BD9D0)
	// 821BD9C4: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 821BD9C8: 3BBDFFF4  addi r29, r29, -0xc
	ctx.r[29].s64 = ctx.r[29].s64 + -12;
	// 821BD9CC: 4080FF88  bge 0x821bd954
	if !ctx.cr[0].lt {
	pc = 0x821BD954; continue 'dispatch;
	}
	pc = 0x821BD9D0; continue 'dispatch;
            }
            0x821BD9D0 => {
    //   block [0x821BD9D0..0x821BDA08)
	// 821BD9D0: 83BA0004  lwz r29, 4(r26)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BD9D4: 83DA0008  lwz r30, 8(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BD9D8: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821BD9DC: 419A0084  beq cr6, 0x821bda60
	if ctx.cr[6].eq {
	pc = 0x821BDA60; continue 'dispatch;
	}
	// 821BD9E0: 7D7EF050  subf r11, r30, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[30].s64;
	// 821BD9E4: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821BD9E8: 7D6BDBD6  divw r11, r11, r27
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 821BD9EC: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821BD9F0: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821BD9F4: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821BD9F8: 7F6BEA14  add r27, r11, r29
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821BD9FC: 419A0050  beq cr6, 0x821bda4c
	if ctx.cr[6].eq {
	pc = 0x821BDA4C; continue 'dispatch;
	}
	// 821BDA00: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 821BDA04: 7F9EE850  subf r28, r30, r29
	ctx.r[28].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	pc = 0x821BDA08; continue 'dispatch;
            }
            0x821BDA08 => {
    //   block [0x821BDA08..0x821BDA30)
	// 821BDA08: 397FFFF8  addi r11, r31, -8
	ctx.r[11].s64 = ctx.r[31].s64 + -8;
	// 821BDA0C: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 821BDA10: 419A0020  beq cr6, 0x821bda30
	if ctx.cr[6].eq {
	pc = 0x821BDA30; continue 'dispatch;
	}
	// 821BDA14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821BDA18: 4803E5F1  bl 0x821fc008
	ctx.lr = 0x821BDA1C;
	sub_821FC008(ctx, base);
	// 821BDA1C: 807FFFFC  lwz r3, -4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821BDA20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BDA24: 907D0004  stw r3, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 821BDA28: 419A0008  beq cr6, 0x821bda30
	if ctx.cr[6].eq {
	pc = 0x821BDA30; continue 'dispatch;
	}
	// 821BDA2C: 4803E74D  bl 0x821fc178
	ctx.lr = 0x821BDA30;
	sub_821FC178(ctx, base);
	pc = 0x821BDA30; continue 'dispatch;
            }
            0x821BDA30 => {
    //   block [0x821BDA30..0x821BDA4C)
	// 821BDA30: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BDA34: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 821BDA38: 7D7CF92E  stwx r11, r28, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[28].u32.wrapping_add(ctx.r[31].u32), ctx.r[11].u32) };
	// 821BDA3C: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 821BDA40: 395FFFF8  addi r10, r31, -8
	ctx.r[10].s64 = ctx.r[31].s64 + -8;
	// 821BDA44: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821BDA48: 409AFFC0  bne cr6, 0x821bda08
	if !ctx.cr[6].eq {
	pc = 0x821BDA08; continue 'dispatch;
	}
	pc = 0x821BDA4C; continue 'dispatch;
            }
            0x821BDA4C => {
    //   block [0x821BDA4C..0x821BDA60)
	// 821BDA4C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821BDA50: 80BA0008  lwz r5, 8(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BDA54: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821BDA58: 488E3FB1  bl 0x82aa1a08
	ctx.lr = 0x821BDA5C;
	sub_82AA1A08(ctx, base);
	// 821BDA5C: 937A0008  stw r27, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	pc = 0x821BDA60; continue 'dispatch;
            }
            0x821BDA60 => {
    //   block [0x821BDA60..0x821BDA84)
	// 821BDA60: 81790020  lwz r11, 0x20(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(32 as u32) ) } as u64;
	// 821BDA64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BDA68: 419A020C  beq cr6, 0x821bdc74
	if ctx.cr[6].eq {
	pc = 0x821BDC74; continue 'dispatch;
	}
	// 821BDA6C: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 821BDA70: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 821BDA74: 3BB90010  addi r29, r25, 0x10
	ctx.r[29].s64 = ctx.r[25].s64 + 16;
	// 821BDA78: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821BDA7C: 3B6A2A40  addi r27, r10, 0x2a40
	ctx.r[27].s64 = ctx.r[10].s64 + 10816;
	// 821BDA80: 3B8B2A30  addi r28, r11, 0x2a30
	ctx.r[28].s64 = ctx.r[11].s64 + 10800;
	pc = 0x821BDA84; continue 'dispatch;
            }
            0x821BDA84 => {
    //   block [0x821BDA84..0x821BDA9C)
	// 821BDA84: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BDA88: 815D0010  lwz r10, 0x10(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 821BDA8C: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821BDA90: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821BDA94: 40990008  ble cr6, 0x821bda9c
	if !ctx.cr[6].gt {
	pc = 0x821BDA9C; continue 'dispatch;
	}
	// 821BDA98: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821BDA9C; continue 'dispatch;
            }
            0x821BDA9C => {
    //   block [0x821BDA9C..0x821BDAB0)
	// 821BDA9C: 392AFFFF  addi r9, r10, -1
	ctx.r[9].s64 = ctx.r[10].s64 + -1;
	// 821BDAA0: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821BDAA4: 4199000C  bgt cr6, 0x821bdab0
	if ctx.cr[6].gt {
	pc = 0x821BDAB0; continue 'dispatch;
	}
	// 821BDAA8: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BDAAC: 40980008  bge cr6, 0x821bdab4
	if !ctx.cr[6].lt {
	pc = 0x821BDAB4; continue 'dispatch;
	}
	pc = 0x821BDAB0; continue 'dispatch;
            }
            0x821BDAB0 => {
    //   block [0x821BDAB0..0x821BDAB4)
	// 821BDAB0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821BDAB4; continue 'dispatch;
            }
            0x821BDAB4 => {
    //   block [0x821BDAB4..0x821BDACC)
	// 821BDAB4: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 821BDAB8: 550BF0BE  srwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821BDABC: 550907BE  clrlwi r9, r8, 0x1e
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00000003u64;
	// 821BDAC0: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821BDAC4: 41980008  blt cr6, 0x821bdacc
	if ctx.cr[6].lt {
	pc = 0x821BDACC; continue 'dispatch;
	}
	// 821BDAC8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821BDACC; continue 'dispatch;
            }
            0x821BDACC => {
    //   block [0x821BDACC..0x821BDADC)
	// 821BDACC: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BDAD0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821BDAD4: 41990008  bgt cr6, 0x821bdadc
	if ctx.cr[6].gt {
	pc = 0x821BDADC; continue 'dispatch;
	}
	// 821BDAD8: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	pc = 0x821BDADC; continue 'dispatch;
            }
            0x821BDADC => {
    //   block [0x821BDADC..0x821BDB0C)
	// 821BDADC: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BDAE0: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821BDAE4: 5527103A  slwi r7, r9, 2
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821BDAE8: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 821BDAEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BDAF0: 7CC8502E  lwzx r6, r8, r10
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821BDAF4: 7D06382E  lwzx r8, r6, r7
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 821BDAF8: 419A0014  beq cr6, 0x821bdb0c
	if ctx.cr[6].eq {
	pc = 0x821BDB0C; continue 'dispatch;
	}
	// 821BDAFC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821BDB00: 917D0010  stw r11, 0x10(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 821BDB04: 40820008  bne 0x821bdb0c
	if !ctx.cr[0].eq {
	pc = 0x821BDB0C; continue 'dispatch;
	}
	// 821BDB08: 935D000C  stw r26, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	pc = 0x821BDB0C; continue 'dispatch;
            }
            0x821BDB0C => {
    //   block [0x821BDB0C..0x821BDB20)
	// 821BDB0C: 83E80248  lwz r31, 0x248(r8)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(584 as u32) ) } as u64;
	// 821BDB10: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821BDB14: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 821BDB18: 419A0054  beq cr6, 0x821bdb6c
	if ctx.cr[6].eq {
	pc = 0x821BDB6C; continue 'dispatch;
	}
	// 821BDB1C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	pc = 0x821BDB20; continue 'dispatch;
            }
            0x821BDB20 => {
    //   block [0x821BDB20..0x821BDB6C)
	// 821BDB20: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821BDB24: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BDB28: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821BDB2C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821BDB30: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821BDB34: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821BDB38: 4082FFE8  bne 0x821bdb20
	if !ctx.cr[0].eq {
	pc = 0x821BDB20; continue 'dispatch;
	}
	// 821BDB3C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821BDB40: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821BDB44: 409A0028  bne cr6, 0x821bdb6c
	if !ctx.cr[6].eq {
	pc = 0x821BDB6C; continue 'dispatch;
	}
	// 821BDB48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BDB4C: 556A073E  clrlwi r10, r11, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821BDB50: 2B0A0004  cmplwi cr6, r10, 4
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4 as u32, &mut ctx.xer);
	// 821BDB54: 409A0018  bne cr6, 0x821bdb6c
	if !ctx.cr[6].eq {
	pc = 0x821BDB6C; continue 'dispatch;
	}
	// 821BDB58: 556B0042  rlwinm r11, r11, 0, 1, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821BDB5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BDB60: 419A000C  beq cr6, 0x821bdb6c
	if ctx.cr[6].eq {
	pc = 0x821BDB6C; continue 'dispatch;
	}
	// 821BDB64: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821BDB68: 4803E611  bl 0x821fc178
	ctx.lr = 0x821BDB6C;
	sub_821FC178(ctx, base);
	pc = 0x821BDB6C; continue 'dispatch;
            }
            0x821BDB6C => {
    //   block [0x821BDB6C..0x821BDBB0)
	// 821BDB6C: 38680244  addi r3, r8, 0x244
	ctx.r[3].s64 = ctx.r[8].s64 + 580;
	// 821BDB70: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 821BDB74: 4803E495  bl 0x821fc008
	ctx.lr = 0x821BDB78;
	sub_821FC008(ctx, base);
	// 821BDB78: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821BDB7C: 83D90000  lwz r30, 0(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BDB80: 419A00D0  beq cr6, 0x821bdc50
	if ctx.cr[6].eq {
	pc = 0x821BDC50; continue 'dispatch;
	}
	// 821BDB84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BDB88: 4803E669  bl 0x821fc1f0
	ctx.lr = 0x821BDB8C;
	sub_821FC1F0(ctx, base);
	// 821BDB8C: 80FE0030  lwz r7, 0x30(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821BDB90: 397E0020  addi r11, r30, 0x20
	ctx.r[11].s64 = ctx.r[30].s64 + 32;
	// 821BDB94: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821BDB98: 419A0088  beq cr6, 0x821bdc20
	if ctx.cr[6].eq {
	pc = 0x821BDC20; continue 'dispatch;
	}
	// 821BDB9C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BDBA0: 7D493A14  add r10, r9, r7
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[7].u64;
	// 821BDBA4: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821BDBA8: 40990008  ble cr6, 0x821bdbb0
	if !ctx.cr[6].gt {
	pc = 0x821BDBB0; continue 'dispatch;
	}
	// 821BDBAC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821BDBB0; continue 'dispatch;
            }
            0x821BDBB0 => {
    //   block [0x821BDBB0..0x821BDBD0)
	// 821BDBB0: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821BDBB4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821BDBB8: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821BDBBC: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821BDBC0: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821BDBC4: 4199000C  bgt cr6, 0x821bdbd0
	if ctx.cr[6].gt {
	pc = 0x821BDBD0; continue 'dispatch;
	}
	// 821BDBC8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821BDBCC: 40980008  bge cr6, 0x821bdbd4
	if !ctx.cr[6].lt {
	pc = 0x821BDBD4; continue 'dispatch;
	}
	pc = 0x821BDBD0; continue 'dispatch;
            }
            0x821BDBD0 => {
    //   block [0x821BDBD0..0x821BDBD4)
	// 821BDBD0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821BDBD4; continue 'dispatch;
            }
            0x821BDBD4 => {
    //   block [0x821BDBD4..0x821BDBE0)
	// 821BDBD4: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821BDBD8: 41980008  blt cr6, 0x821bdbe0
	if ctx.cr[6].lt {
	pc = 0x821BDBE0; continue 'dispatch;
	}
	// 821BDBDC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821BDBE0; continue 'dispatch;
            }
            0x821BDBE0 => {
    //   block [0x821BDBE0..0x821BDBF0)
	// 821BDBE0: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BDBE4: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821BDBE8: 41990008  bgt cr6, 0x821bdbf0
	if ctx.cr[6].gt {
	pc = 0x821BDBF0; continue 'dispatch;
	}
	// 821BDBEC: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	pc = 0x821BDBF0; continue 'dispatch;
            }
            0x821BDBF0 => {
    //   block [0x821BDBF0..0x821BDC20)
	// 821BDBF0: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BDBF4: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821BDBF8: 7D48482E  lwzx r10, r8, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821BDBFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BDC00: 419A0020  beq cr6, 0x821bdc20
	if ctx.cr[6].eq {
	pc = 0x821BDC20; continue 'dispatch;
	}
	// 821BDC04: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BDC08: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821BDC0C: 409A0014  bne cr6, 0x821bdc20
	if !ctx.cr[6].eq {
	pc = 0x821BDC20; continue 'dispatch;
	}
	// 821BDC10: 3547FFFF  addic. r10, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821BDC14: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 821BDC18: 40820008  bne 0x821bdc20
	if !ctx.cr[0].eq {
	pc = 0x821BDC20; continue 'dispatch;
	}
	// 821BDC1C: 934B000C  stw r26, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	pc = 0x821BDC20; continue 'dispatch;
            }
            0x821BDC20 => {
    //   block [0x821BDC20..0x821BDC50)
	// 821BDC20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821BDC24: 4803E3E5  bl 0x821fc008
	ctx.lr = 0x821BDC28;
	sub_821FC008(ctx, base);
	// 821BDC28: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 821BDC2C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821BDC30: 419A0020  beq cr6, 0x821bdc50
	if ctx.cr[6].eq {
	pc = 0x821BDC50; continue 'dispatch;
	}
	// 821BDC34: 817E0038  lwz r11, 0x38(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 821BDC38: 387E0034  addi r3, r30, 0x34
	ctx.r[3].s64 = ctx.r[30].s64 + 52;
	// 821BDC3C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821BDC40: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 821BDC44: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 821BDC48: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821BDC4C: 488D971D  bl 0x82a97368
	ctx.lr = 0x821BDC50;
	sub_82A97368(ctx, base);
	pc = 0x821BDC50; continue 'dispatch;
            }
            0x821BDC50 => {
    //   block [0x821BDC50..0x821BDC74)
	// 821BDC50: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 821BDC54: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821BDC58: 4803E3B1  bl 0x821fc008
	ctx.lr = 0x821BDC5C;
	sub_821FC008(ctx, base);
	// 821BDC5C: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 821BDC60: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821BDC64: 4803E3A5  bl 0x821fc008
	ctx.lr = 0x821BDC68;
	sub_821FC008(ctx, base);
	// 821BDC68: 81790020  lwz r11, 0x20(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(32 as u32) ) } as u64;
	// 821BDC6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BDC70: 409AFE14  bne cr6, 0x821bda84
	if !ctx.cr[6].eq {
	pc = 0x821BDA84; continue 'dispatch;
	}
	pc = 0x821BDC74; continue 'dispatch;
            }
            0x821BDC74 => {
    //   block [0x821BDC74..0x821BDC7C)
	// 821BDC74: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821BDC78: 48AEB7D0  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BDC80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BDC80 size=484
    let mut pc: u32 = 0x821BDC80;
    'dispatch: loop {
        match pc {
            0x821BDC80 => {
    //   block [0x821BDC80..0x821BDCB0)
	// 821BDC80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BDC84: 48AEB779  bl 0x82ca93fc
	ctx.lr = 0x821BDC88;
	sub_82CA93D0(ctx, base);
	// 821BDC88: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BDC8C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821BDC90: 4BFF93D1  bl 0x821b7060
	ctx.lr = 0x821BDC94;
	sub_821B7060(ctx, base);
	// 821BDC94: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821BDC98: 394BA978  addi r10, r11, -0x5688
	ctx.r[10].s64 = ctx.r[11].s64 + -22152;
	// 821BDC9C: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BDCA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821BDCA4: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 821BDCA8: 419A0008  beq cr6, 0x821bdcb0
	if ctx.cr[6].eq {
	pc = 0x821BDCB0; continue 'dispatch;
	}
	// 821BDCAC: 4803E4CD  bl 0x821fc178
	ctx.lr = 0x821BDCB0;
	sub_821FC178(ctx, base);
	pc = 0x821BDCB0; continue 'dispatch;
            }
            0x821BDCB0 => {
    //   block [0x821BDCB0..0x821BDD2C)
	// 821BDCB0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 821BDCB4: 3FE0834A  lis r31, -0x7cb6
	ctx.r[31].s64 = -2092302336;
	// 821BDCB8: 394B2A30  addi r10, r11, 0x2a30
	ctx.r[10].s64 = ctx.r[11].s64 + 10800;
	// 821BDCBC: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 821BDCC0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821BDCC4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821BDCC8: 3889F820  addi r4, r9, -0x7e0
	ctx.r[4].s64 = ctx.r[9].s64 + -2016;
	// 821BDCCC: 807FF7E0  lwz r3, -0x820(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-2080 as u32) ) } as u64;
	// 821BDCD0: 4BFE74A1  bl 0x821a5170
	ctx.lr = 0x821BDCD4;
	sub_821A5170(ctx, base);
	// 821BDCD4: 3F40834A  lis r26, -0x7cb6
	ctx.r[26].s64 = -2092302336;
	// 821BDCD8: 807AF9C0  lwz r3, -0x640(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 821BDCDC: 480E325D  bl 0x822a0f38
	ctx.lr = 0x821BDCE0;
	sub_822A0F38(ctx, base);
	// 821BDCE0: 807FF7E0  lwz r3, -0x820(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-2080 as u32) ) } as u64;
	// 821BDCE4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821BDCE8: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BDCEC: 80E80000  lwz r7, 0(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821BDCF0: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 821BDCF4: 4E800421  bctrl
	ctx.lr = 0x821BDCF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821BDCF8: 807AF9C0  lwz r3, -0x640(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 821BDCFC: 480DDD95  bl 0x8229ba90
	ctx.lr = 0x821BDD00;
	sub_8229BA90(ctx, base);
	// 821BDD00: 4BFF9361  bl 0x821b7060
	ctx.lr = 0x821BDD04;
	sub_821B7060(ctx, base);
	// 821BDD04: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821BDD08: 3B8B4DE4  addi r28, r11, 0x4de4
	ctx.r[28].s64 = ctx.r[11].s64 + 19940;
	// 821BDD0C: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BDD10: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BDD14: 7CCB5050  subf r6, r11, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821BDD18: 7CC51670  srawi r5, r6, 2
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[6].s32 >> 2) as i64;
	// 821BDD1C: 37A5FFFF  addic. r29, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821BDD20: 41800040  blt 0x821bdd60
	if ctx.cr[0].lt {
	pc = 0x821BDD60; continue 'dispatch;
	}
	// 821BDD24: 57BB103A  slwi r27, r29, 2
	ctx.r[27].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 821BDD28: 48000008  b 0x821bdd30
	pc = 0x821BDD30; continue 'dispatch;
            }
            0x821BDD2C => {
    //   block [0x821BDD2C..0x821BDD30)
	// 821BDD2C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x821BDD30; continue 'dispatch;
            }
            0x821BDD30 => {
    //   block [0x821BDD30..0x821BDD3C)
	// 821BDD30: 7D7B582E  lwzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821BDD34: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 821BDD38: 3BCB0064  addi r30, r11, 0x64
	ctx.r[30].s64 = ctx.r[11].s64 + 100;
	pc = 0x821BDD3C; continue 'dispatch;
            }
            0x821BDD3C => {
    //   block [0x821BDD3C..0x821BDD60)
	// 821BDD3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821BDD40: 807AF9C0  lwz r3, -0x640(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 821BDD44: 480792DD  bl 0x82237020
	ctx.lr = 0x821BDD48;
	sub_82237020(ctx, base);
	// 821BDD48: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821BDD4C: 3BDEFFDC  addi r30, r30, -0x24
	ctx.r[30].s64 = ctx.r[30].s64 + -36;
	// 821BDD50: 4080FFEC  bge 0x821bdd3c
	if !ctx.cr[0].lt {
	pc = 0x821BDD3C; continue 'dispatch;
	}
	// 821BDD54: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821BDD58: 3B7BFFFC  addi r27, r27, -4
	ctx.r[27].s64 = ctx.r[27].s64 + -4;
	// 821BDD5C: 4080FFD0  bge 0x821bdd2c
	if !ctx.cr[0].lt {
	pc = 0x821BDD2C; continue 'dispatch;
	}
	pc = 0x821BDD60; continue 'dispatch;
            }
            0x821BDD60 => {
    //   block [0x821BDD60..0x821BDD90)
	// 821BDD60: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BDD64: 3880001B  li r4, 0x1b
	ctx.r[4].s64 = 27;
	// 821BDD68: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821BDD6C: 386B0D54  addi r3, r11, 0xd54
	ctx.r[3].s64 = ctx.r[11].s64 + 3412;
	// 821BDD70: 480D1721  bl 0x8228f490
	ctx.lr = 0x821BDD74;
	sub_8228F490(ctx, base);
	// 821BDD74: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BDD78: 3BC30004  addi r30, r3, 4
	ctx.r[30].s64 = ctx.r[3].s64 + 4;
	// 821BDD7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BDD80: 419A0010  beq cr6, 0x821bdd90
	if ctx.cr[6].eq {
	pc = 0x821BDD90; continue 'dispatch;
	}
	// 821BDD84: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BDD88: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821BDD8C: 7D2B1670  srawi r11, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 2) as i64;
	pc = 0x821BDD90; continue 'dispatch;
            }
            0x821BDD90 => {
    //   block [0x821BDD90..0x821BDD9C)
	// 821BDD90: 37EBFFFF  addic. r31, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821BDD94: 41800054  blt 0x821bdde8
	if ctx.cr[0].lt {
	pc = 0x821BDDE8; continue 'dispatch;
	}
	// 821BDD98: 57FD103A  slwi r29, r31, 2
	ctx.r[29].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	pc = 0x821BDD9C; continue 'dispatch;
            }
            0x821BDD9C => {
    //   block [0x821BDD9C..0x821BDDBC)
	// 821BDD9C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BDDA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BDDA4: 419A0018  beq cr6, 0x821bddbc
	if ctx.cr[6].eq {
	pc = 0x821BDDBC; continue 'dispatch;
	}
	// 821BDDA8: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BDDAC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821BDDB0: 7D2A1670  srawi r10, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 821BDDB4: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821BDDB8: 41980008  blt cr6, 0x821bddc0
	if ctx.cr[6].lt {
	pc = 0x821BDDC0; continue 'dispatch;
	}
	pc = 0x821BDDBC; continue 'dispatch;
            }
            0x821BDDBC => {
    //   block [0x821BDDBC..0x821BDDC0)
	// 821BDDBC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821BDDC0; continue 'dispatch;
            }
            0x821BDDC0 => {
    //   block [0x821BDDC0..0x821BDDDC)
	// 821BDDC0: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821BDDC4: 814B011C  lwz r10, 0x11c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(284 as u32) ) } as u64;
	// 821BDDC8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821BDDCC: 419A0010  beq cr6, 0x821bdddc
	if ctx.cr[6].eq {
	pc = 0x821BDDDC; continue 'dispatch;
	}
	// 821BDDD0: 388B0118  addi r4, r11, 0x118
	ctx.r[4].s64 = ctx.r[11].s64 + 280;
	// 821BDDD4: 807AF9C0  lwz r3, -0x640(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 821BDDD8: 48079249  bl 0x82237020
	ctx.lr = 0x821BDDDC;
	sub_82237020(ctx, base);
	pc = 0x821BDDDC; continue 'dispatch;
            }
            0x821BDDDC => {
    //   block [0x821BDDDC..0x821BDDE8)
	// 821BDDDC: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821BDDE0: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 821BDDE4: 4080FFB8  bge 0x821bdd9c
	if !ctx.cr[0].lt {
	pc = 0x821BDD9C; continue 'dispatch;
	}
	pc = 0x821BDDE8; continue 'dispatch;
            }
            0x821BDDE8 => {
    //   block [0x821BDDE8..0x821BDE0C)
	// 821BDDE8: 4BFF9049  bl 0x821b6e30
	ctx.lr = 0x821BDDEC;
	sub_821B6E30(ctx, base);
	// 821BDDEC: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821BDDF0: 816A6E98  lwz r11, 0x6e98(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28312 as u32) ) } as u64;
	// 821BDDF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BDDF8: 419A0014  beq cr6, 0x821bde0c
	if ctx.cr[6].eq {
	pc = 0x821BDE0C; continue 'dispatch;
	}
	// 821BDDFC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821BDE00: 992B01E4  stb r9, 0x1e4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(484 as u32), ctx.r[9].u8 ) };
	// 821BDE04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821BDE08: 916A6E98  stw r11, 0x6e98(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28312 as u32), ctx.r[11].u32 ) };
	pc = 0x821BDE0C; continue 'dispatch;
            }
            0x821BDE0C => {
    //   block [0x821BDE0C..0x821BDE5C)
	// 821BDE0C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821BDE10: 386BAC10  addi r3, r11, -0x53f0
	ctx.r[3].s64 = ctx.r[11].s64 + -21488;
	// 821BDE14: 4803E1F5  bl 0x821fc008
	ctx.lr = 0x821BDE18;
	sub_821FC008(ctx, base);
	// 821BDE18: 81390004  lwz r9, 4(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BDE1C: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821BDE20: 81090014  lwz r8, 0x14(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 821BDE24: 806AF9C4  lwz r3, -0x63c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-1596 as u32) ) } as u64;
	// 821BDE28: 80880008  lwz r4, 8(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 821BDE2C: 4BFFFAED  bl 0x821bd918
	ctx.lr = 0x821BDE30;
	sub_821BD918(ctx, base);
	// 821BDE30: 3CE08332  lis r7, -0x7cce
	ctx.r[7].s64 = -2093875200;
	// 821BDE34: 807AF9C0  lwz r3, -0x640(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 821BDE38: 3887AC08  addi r4, r7, -0x53f8
	ctx.r[4].s64 = ctx.r[7].s64 + -21496;
	// 821BDE3C: 4801BDB5  bl 0x821d9bf0
	ctx.lr = 0x821BDE40;
	sub_821D9BF0(ctx, base);
	// 821BDE40: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821BDE44: 388BAA5C  addi r4, r11, -0x55a4
	ctx.r[4].s64 = ctx.r[11].s64 + -21924;
	// 821BDE48: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BDE4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821BDE50: 419A000C  beq cr6, 0x821bde5c
	if ctx.cr[6].eq {
	pc = 0x821BDE5C; continue 'dispatch;
	}
	// 821BDE54: 807AF9C0  lwz r3, -0x640(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 821BDE58: 480791C9  bl 0x82237020
	ctx.lr = 0x821BDE5C;
	sub_82237020(ctx, base);
	pc = 0x821BDE5C; continue 'dispatch;
            }
            0x821BDE5C => {
    //   block [0x821BDE5C..0x821BDE64)
	// 821BDE5C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821BDE60: 48AEB5EC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BDE68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821BDE68 size=7824
    let mut pc: u32 = 0x821BDE68;
    'dispatch: loop {
        match pc {
            0x821BDE68 => {
    //   block [0x821BDE68..0x821BFCF8)
	// 821BDE68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BDE6C: 48AEB565  bl 0x82ca93d0
	ctx.lr = 0x821BDE70;
	sub_82CA93D0(ctx, base);
	// 821BDE70: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 821BDE74: 48AEFE3D  bl 0x82cadcb0
	ctx.lr = 0x821BDE78;
	sub_82CADCA0(ctx, base);
	// 821BDE78: 3981FEF0  addi r12, r1, -0x110
	ctx.r[12].s64 = ctx.r[1].s64 + -272;
	// 821BDE7C: 48E48B49  bl 0x830069c4
	ctx.lr = 0x821BDE80;
	sub_83006760(ctx, base);
	// 821BDE80: 9421FBC0  stwu r1, -0x440(r1)
	ea = ctx.r[1].u32.wrapping_add(-1088 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BDE84: 7C912378  mr r17, r4
	ctx.r[17].u64 = ctx.r[4].u64;
	// 821BDE88: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821BDE8C: 39000480  li r8, 0x480
	ctx.r[8].s64 = 1152;
	// 821BDE90: 9221045C  stw r17, 0x45c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1116 as u32), ctx.r[17].u32 ) };
	// 821BDE94: 38E100B0  addi r7, r1, 0xb0
	ctx.r[7].s64 = ctx.r[1].s64 + 176;
	// 821BDE98: 3D20834C  lis r9, -0x7cb4
	ctx.r[9].s64 = -2092171264;
	// 821BDE9C: 81510004  lwz r10, 4(r17)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) } as u64;
	// 821BDEA0: 39EB9410  addi r15, r11, -0x6bf0
	ctx.r[15].s64 = ctx.r[11].s64 + -27632;
	// 821BDEA4: 38A00490  li r5, 0x490
	ctx.r[5].s64 = 1168;
	// 821BDEA8: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 821BDEAC: 91E100DC  stw r15, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[15].u32 ) };
	// 821BDEB0: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821BDEB4: 8869EC7B  lbz r3, -0x1385(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(-4997 as u32) ) } as u64;
	// 821BDEB8: 39C00001  li r14, 1
	ctx.r[14].s64 = 1;
	// 821BDEBC: 80CA0014  lwz r6, 0x14(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821BDEC0: C00FFEC8  lfs f0, -0x138(r15)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(-312 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821BDEC4: 7DCA7378  mr r10, r14
	ctx.r[10].u64 = ctx.r[14].u64;
	// 821BDEC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BFCF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BFCF8 size=180
    let mut pc: u32 = 0x821BFCF8;
    'dispatch: loop {
        match pc {
            0x821BFCF8 => {
    //   block [0x821BFCF8..0x821BFDAC)
	// 821BFCF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BFCFC: 48AE970D  bl 0x82ca9408
	ctx.lr = 0x821BFD00;
	sub_82CA93D0(ctx, base);
	// 821BFD00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BFD04: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821BFD08: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821BFD0C: 3BAB0B7C  addi r29, r11, 0xb7c
	ctx.r[29].s64 = ctx.r[11].s64 + 2940;
	// 821BFD10: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821BFD14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821BFD18: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821BFD1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BFD20: 4BFD4119  bl 0x82193e38
	ctx.lr = 0x821BFD24;
	sub_82193E38(ctx, base);
	// 821BFD24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821BFD28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BFD2C: 4831219D  bl 0x824d1ec8
	ctx.lr = 0x821BFD30;
	sub_824D1EC8(ctx, base);
	// 821BFD30: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821BFD34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821BFD38: 3B8A0B7C  addi r28, r10, 0xb7c
	ctx.r[28].s64 = ctx.r[10].s64 + 2940;
	// 821BFD3C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821BFD40: 4BFD40F9  bl 0x82193e38
	ctx.lr = 0x821BFD44;
	sub_82193E38(ctx, base);
	// 821BFD44: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 821BFD48: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821BFD4C: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 821BFD50: 3BA9A950  addi r29, r9, -0x56b0
	ctx.r[29].s64 = ctx.r[9].s64 + -22192;
	// 821BFD54: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821BFD58: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 821BFD5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BFDB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821BFDB0 size=12
    let mut pc: u32 = 0x821BFDB0;
    'dispatch: loop {
        match pc {
            0x821BFDB0 => {
    //   block [0x821BFDB0..0x821BFDBC)
	// 821BFDB0: 81630034  lwz r11, 0x34(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 821BFDB4: 908B002C  stw r4, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[4].u32 ) };
	// 821BFDB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BFDC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821BFDC0 size=40
    let mut pc: u32 = 0x821BFDC0;
    'dispatch: loop {
        match pc {
            0x821BFDC0 => {
    //   block [0x821BFDC0..0x821BFDE0)
	// 821BFDC0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821BFDC4: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821BFDC8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821BFDCC: 41980014  blt cr6, 0x821bfde0
	if ctx.cr[6].lt {
	pc = 0x821BFDE0; continue 'dispatch;
	}
	// 821BFDD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821BFDD4: C00B0A44  lfs f0, 0xa44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2628 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821BFDD8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821BFDDC: 4099000C  ble cr6, 0x821bfde8
	if !ctx.cr[6].gt {
		crate::recompiler::externs::call(ctx, base, 0x821BFDE8);
		return;
	}
	pc = 0x821BFDE0; continue 'dispatch;
            }
            0x821BFDE0 => {
    //   block [0x821BFDE0..0x821BFDE8)
	// 821BFDE0: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821BFDE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BFDF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821BFDF0 size=36
    let mut pc: u32 = 0x821BFDF0;
    'dispatch: loop {
        match pc {
            0x821BFDF0 => {
    //   block [0x821BFDF0..0x821BFE14)
	// 821BFDF0: 81632934  lwz r11, 0x2934(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(10548 as u32) ) } as u64;
	// 821BFDF4: 508B2676  rlwimi r11, r4, 4, 0x19, 0x1b
	ctx.r[11].u64 = (((ctx.r[4].u32).rotate_left(4) as u64) & 0x0000000000000070) | (ctx.r[11].u64 & 0xFFFFFFFFFFFFFF8F);
	// 821BFDF8: 91632934  stw r11, 0x2934(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10548 as u32), ctx.r[11].u32 ) };
	// 821BFDFC: E9630010  ld r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	// 821BFE00: 616B0800  ori r11, r11, 0x800
	ctx.r[11].u64 = ctx.r[11].u64 | 2048;
	// 821BFE04: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821BFE08: 656B0002  oris r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 131072;
	// 821BFE0C: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821BFE10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BFE18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821BFE18 size=140
    let mut pc: u32 = 0x821BFE18;
    'dispatch: loop {
        match pc {
            0x821BFE18 => {
    //   block [0x821BFE18..0x821BFEA4)
	// 821BFE18: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821BFE1C: 3D4051EB  lis r10, 0x51eb
	ctx.r[10].s64 = 1374355456;
	// 821BFE20: 392BD9BC  addi r9, r11, -0x2644
	ctx.r[9].s64 = ctx.r[11].s64 + -9796;
	// 821BFE24: 6148851F  ori r8, r10, 0x851f
	ctx.r[8].u64 = ctx.r[10].u64 | 34079;
	// 821BFE28: 38E00064  li r7, 0x64
	ctx.r[7].s64 = 100;
	// 821BFE2C: C1ABD9BC  lfs f13, -0x2644(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9796 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821BFE30: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 821BFE34: C009E2AC  lfs f0, -0x1d54(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-7508 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821BFE38: ED810032  fmuls f12, f1, f0
	ctx.f[12].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 821BFE3C: C0060AA8  lfs f0, 0xaa8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2728 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821BFE40: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 821BFE44: D961FFF0  stfd f11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[11].u64 ) };
	// 821BFE48: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 821BFE4C: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 821BFE50: 7C854096  mulhw r4, r5, r8
	ctx.r[4].s64 = ((ctx.r[5].s32 as i64 * ctx.r[8].s32 as i64) >> 32);
	// 821BFE54: 7C6B3BD6  divw r3, r11, r7
	ctx.r[3].s32 = ctx.r[11].s32 / ctx.r[7].s32;
	// 821BFE58: 7C8B2E70  srawi r11, r4, 5
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[4].s32 >> 5) as i64;
	// 821BFE5C: 7C6907B4  extsw r9, r3
	ctx.r[9].s64 = ctx.r[3].s32 as i64;
	// 821BFE60: 556A0FFE  srwi r10, r11, 0x1f
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821BFE64: F921FFF0  std r9, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u64 ) };
	// 821BFE68: C941FFF0  lfd f10, -0x10(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821BFE6C: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821BFE70: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 821BFE74: 1CE80064  mulli r7, r8, 0x64
	ctx.r[7].s32 = ((ctx.r[8].s32 as i64 * 100 as i64) as i32);
	ctx.r[7].s64 = ctx.r[7].s32 as i64;
	// 821BFE78: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 821BFE7C: 7CC72850  subf r6, r7, r5
	ctx.r[6].s64 = ctx.r[5].s64 - ctx.r[7].s64;
	// 821BFE80: 7CC507B4  extsw r5, r6
	ctx.r[5].s64 = ctx.r[6].s32 as i64;
	// 821BFE84: ECE80032  fmuls f7, f8, f0
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 821BFE88: F8A1FFF0  std r5, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[5].u64 ) };
	// 821BFE8C: C8C1FFF0  lfd f6, -0x10(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821BFE90: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 821BFE94: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 821BFE98: EC640372  fmuls f3, f4, f13
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[13].f64) as f32) as f64);
	// 821BFE9C: EC23383A  fmadds f1, f3, f0, f7
	ctx.f[1].f64 = (((ctx.f[3].f64 * ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64);
	// 821BFEA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BFEA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821BFEA8 size=176
    let mut pc: u32 = 0x821BFEA8;
    'dispatch: loop {
        match pc {
            0x821BFEA8 => {
    //   block [0x821BFEA8..0x821BFEF4)
	// 821BFEA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BFEAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821BFEB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821BFEB4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821BFEB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BFEBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821BFEC0: FF011000  fcmpu cr6, f1, f2
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[2].f64);
	// 821BFEC4: C3FF0004  lfs f31, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821BFEC8: 4098002C  bge cr6, 0x821bfef4
	if !ctx.cr[6].lt {
	pc = 0x821BFEF4; continue 'dispatch;
	}
	// 821BFECC: 4BFFFF4D  bl 0x821bfe18
	ctx.lr = 0x821BFED0;
	sub_821BFE18(ctx, base);
	// 821BFED0: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 821BFED4: 41980068  blt cr6, 0x821bff3c
	if ctx.cr[6].lt {
	pc = 0x821BFF3C; continue 'dispatch;
	}
	// 821BFED8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BFEDC: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 821BFEE0: 4BFFFF39  bl 0x821bfe18
	ctx.lr = 0x821BFEE4;
	sub_821BFE18(ctx, base);
	// 821BFEE4: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 821BFEE8: 40980054  bge cr6, 0x821bff3c
	if !ctx.cr[6].lt {
	pc = 0x821BFF3C; continue 'dispatch;
	}
	// 821BFEEC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821BFEF0: 48000050  b 0x821bff40
	pc = 0x821BFF40; continue 'dispatch;
            }
            0x821BFEF4 => {
    //   block [0x821BFEF4..0x821BFF14)
	// 821BFEF4: 4BFFFF25  bl 0x821bfe18
	ctx.lr = 0x821BFEF8;
	sub_821BFE18(ctx, base);
	// 821BFEF8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821BFEFC: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 821BFF00: 396B9484  addi r11, r11, -0x6b7c
	ctx.r[11].s64 = ctx.r[11].s64 + -27516;
	// 821BFF04: 41980010  blt cr6, 0x821bff14
	if ctx.cr[6].lt {
	pc = 0x821BFF14; continue 'dispatch;
	}
	// 821BFF08: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821BFF0C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821BFF10: 41980024  blt cr6, 0x821bff34
	if ctx.cr[6].lt {
	pc = 0x821BFF34; continue 'dispatch;
	}
	pc = 0x821BFF14; continue 'dispatch;
            }
            0x821BFF14 => {
    //   block [0x821BFF14..0x821BFF34)
	// 821BFF14: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821BFF18: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821BFF1C: 41980020  blt cr6, 0x821bff3c
	if ctx.cr[6].lt {
	pc = 0x821BFF3C; continue 'dispatch;
	}
	// 821BFF20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821BFF24: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 821BFF28: 4BFFFEF1  bl 0x821bfe18
	ctx.lr = 0x821BFF2C;
	sub_821BFE18(ctx, base);
	// 821BFF2C: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 821BFF30: 4098000C  bge cr6, 0x821bff3c
	if !ctx.cr[6].lt {
	pc = 0x821BFF3C; continue 'dispatch;
	}
	pc = 0x821BFF34; continue 'dispatch;
            }
            0x821BFF34 => {
    //   block [0x821BFF34..0x821BFF3C)
	// 821BFF34: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821BFF38: 48000008  b 0x821bff40
	pc = 0x821BFF40; continue 'dispatch;
            }
            0x821BFF3C => {
    //   block [0x821BFF3C..0x821BFF40)
	// 821BFF3C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x821BFF40; continue 'dispatch;
            }
            0x821BFF40 => {
    //   block [0x821BFF40..0x821BFF58)
	// 821BFF40: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821BFF44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821BFF48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821BFF4C: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821BFF50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821BFF54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821BFF58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821BFF58 size=184
    let mut pc: u32 = 0x821BFF58;
    'dispatch: loop {
        match pc {
            0x821BFF58 => {
    //   block [0x821BFF58..0x821C0010)
	// 821BFF58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821BFF5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821BFF60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821BFF64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821BFF68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821BFF6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821BFF70: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821BFF74: 4BFD6DFD  bl 0x82196d70
	ctx.lr = 0x821BFF78;
	sub_82196D70(ctx, base);
	// 821BFF78: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 821BFF7C: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 821BFF80: 389E0030  addi r4, r30, 0x30
	ctx.r[4].s64 = ctx.r[30].s64 + 48;
	// 821BFF84: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C0010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C0010 size=260
    let mut pc: u32 = 0x821C0010;
    'dispatch: loop {
        match pc {
            0x821C0010 => {
    //   block [0x821C0010..0x821C0114)
	// 821C0010: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C0118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C0118 size=1028
    let mut pc: u32 = 0x821C0118;
    'dispatch: loop {
        match pc {
            0x821C0118 => {
    //   block [0x821C0118..0x821C051C)
	// 821C0118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C011C: 48AE92E1  bl 0x82ca93fc
	ctx.lr = 0x821C0120;
	sub_82CA93D0(ctx, base);
	// 821C0120: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 821C0124: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C0128: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 821C012C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821C0130: 3BFB0050  addi r31, r27, 0x50
	ctx.r[31].s64 = ctx.r[27].s64 + 80;
	// 821C0134: 3BDB0060  addi r30, r27, 0x60
	ctx.r[30].s64 = ctx.r[27].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C0520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821C0520 size=12
    let mut pc: u32 = 0x821C0520;
    'dispatch: loop {
        match pc {
            0x821C0520 => {
    //   block [0x821C0520..0x821C052C)
	// 821C0520: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821C0524: C02BBAB4  lfs f1, -0x454c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17740 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821C0528: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C0530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C0530 size=56
    let mut pc: u32 = 0x821C0530;
    'dispatch: loop {
        match pc {
            0x821C0530 => {
    //   block [0x821C0530..0x821C054C)
	// 821C0530: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821C0534: 419A0018  beq cr6, 0x821c054c
	if ctx.cr[6].eq {
	pc = 0x821C054C; continue 'dispatch;
	}
	// 821C0538: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 821C053C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821C0540: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C0544: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C0548: 409A0008  bne cr6, 0x821c0550
	if !ctx.cr[6].eq {
	pc = 0x821C0550; continue 'dispatch;
	}
	pc = 0x821C054C; continue 'dispatch;
            }
            0x821C054C => {
    //   block [0x821C054C..0x821C0550)
	// 821C054C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821C0550; continue 'dispatch;
            }
            0x821C0550 => {
    //   block [0x821C0550..0x821C0568)
	// 821C0550: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C0554: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C0558: 419A0010  beq cr6, 0x821c0568
	if ctx.cr[6].eq {
		sub_821C0568(ctx, base);
		return;
	}
	// 821C055C: 81640030  lwz r11, 0x30(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 821C0560: 556337FE  rlwinm r3, r11, 6, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x03FFFFFFu64;
	// 821C0564: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C0568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C0568 size=8
    let mut pc: u32 = 0x821C0568;
    'dispatch: loop {
        match pc {
            0x821C0568 => {
    //   block [0x821C0568..0x821C0570)
	// 821C0568: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821C056C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C0570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C0570 size=168
    let mut pc: u32 = 0x821C0570;
    'dispatch: loop {
        match pc {
            0x821C0570 => {
    //   block [0x821C0570..0x821C0618)
	// 821C0570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C0574: 48AE8E95  bl 0x82ca9408
	ctx.lr = 0x821C0578;
	sub_82CA93D0(ctx, base);
	// 821C0578: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C0618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C0618 size=48
    let mut pc: u32 = 0x821C0618;
    'dispatch: loop {
        match pc {
            0x821C0618 => {
    //   block [0x821C0618..0x821C0648)
	// 821C0618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C061C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C0620: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C0624: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821C0628: 8063002C  lwz r3, 0x2c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 821C062C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C0648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C0648 size=304
    let mut pc: u32 = 0x821C0648;
    'dispatch: loop {
        match pc {
            0x821C0648 => {
    //   block [0x821C0648..0x821C06A0)
	// 821C0648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C064C: 48AE8DAD  bl 0x82ca93f8
	ctx.lr = 0x821C0650;
	sub_82CA93D0(ctx, base);
	// 821C0650: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C0654: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C0658: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821C065C: 894B6B50  lbz r10, 0x6b50(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(27472 as u32) ) } as u64;
	// 821C0660: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C0664: 419A010C  beq cr6, 0x821c0770
	if ctx.cr[6].eq {
	pc = 0x821C0770; continue 'dispatch;
	}
	// 821C0668: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C066C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821C0670: 3B4B801C  addi r26, r11, -0x7fe4
	ctx.r[26].s64 = ctx.r[11].s64 + -32740;
	// 821C0674: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821C0678: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C067C: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C0680: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821C0684: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821C0688: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C068C: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 821C0690: 419A00E0  beq cr6, 0x821c0770
	if ctx.cr[6].eq {
	pc = 0x821C0770; continue 'dispatch;
	}
	// 821C0694: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 821C0698: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C069C: 3B6BFFDF  addi r27, r11, -0x21
	ctx.r[27].s64 = ctx.r[11].s64 + -33;
	pc = 0x821C06A0; continue 'dispatch;
            }
            0x821C06A0 => {
    //   block [0x821C06A0..0x821C06B4)
	// 821C06A0: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C06A4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 821C06A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C06AC: 419A0008  beq cr6, 0x821c06b4
	if ctx.cr[6].eq {
	pc = 0x821C06B4; continue 'dispatch;
	}
	// 821C06B0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821C06B4; continue 'dispatch;
            }
            0x821C06B4 => {
    //   block [0x821C06B4..0x821C06C8)
	// 821C06B4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C06B8: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 821C06BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C06C0: 419A0008  beq cr6, 0x821c06c8
	if ctx.cr[6].eq {
	pc = 0x821C06C8; continue 'dispatch;
	}
	// 821C06C4: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821C06C8; continue 'dispatch;
            }
            0x821C06C8 => {
    //   block [0x821C06C8..0x821C06CC)
	// 821C06C8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821C06CC; continue 'dispatch;
            }
            0x821C06CC => {
    //   block [0x821C06CC..0x821C06F0)
	// 821C06CC: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C06D0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821C06D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C06D8: 409AFFF4  bne cr6, 0x821c06cc
	if !ctx.cr[6].eq {
	pc = 0x821C06CC; continue 'dispatch;
	}
	// 821C06DC: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 821C06E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C06E4: 557D003E  slwi r29, r11, 0
	ctx.r[29].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 821C06E8: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821C06EC: 409A000C  bne cr6, 0x821c06f8
	if !ctx.cr[6].eq {
	pc = 0x821C06F8; continue 'dispatch;
	}
	pc = 0x821C06F0; continue 'dispatch;
            }
            0x821C06F0 => {
    //   block [0x821C06F0..0x821C06F8)
	// 821C06F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C06F4: 48000060  b 0x821c0754
	pc = 0x821C0754; continue 'dispatch;
            }
            0x821C06F8 => {
    //   block [0x821C06F8..0x821C0704)
	// 821C06F8: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C06FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C0700: 419A0050  beq cr6, 0x821c0750
	if ctx.cr[6].eq {
	pc = 0x821C0750; continue 'dispatch;
	}
	pc = 0x821C0704; continue 'dispatch;
            }
            0x821C0704 => {
    //   block [0x821C0704..0x821C0740)
	// 821C0704: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C0708: 7D630774  extsb r3, r11
	ctx.r[3].s64 = ctx.r[11].s8 as i64;
	// 821C070C: 4802E53D  bl 0x821eec48
	ctx.lr = 0x821C0710;
	sub_821EEC48(ctx, base);
	// 821C0710: 895E0000  lbz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C0714: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 821C0718: 7D430774  extsb r3, r10
	ctx.r[3].s64 = ctx.r[10].s8 as i64;
	// 821C071C: 4802E52D  bl 0x821eec48
	ctx.lr = 0x821C0720;
	sub_821EEC48(ctx, base);
	// 821C0720: 7F181800  cmpw cr6, r24, r3
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[3].s32, &mut ctx.xer);
	// 821C0724: 409A001C  bne cr6, 0x821c0740
	if !ctx.cr[6].eq {
	pc = 0x821C0740; continue 'dispatch;
	}
	// 821C0728: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821C072C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821C0730: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C0734: 48AF1555  bl 0x82cb1c88
	ctx.lr = 0x821C0738;
	sub_82CB1C88(ctx, base);
	// 821C0738: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821C073C: 419AFFB4  beq cr6, 0x821c06f0
	if ctx.cr[6].eq {
	pc = 0x821C06F0; continue 'dispatch;
	}
	pc = 0x821C0740; continue 'dispatch;
            }
            0x821C0740 => {
    //   block [0x821C0740..0x821C0750)
	// 821C0740: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821C0744: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C0748: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C074C: 409AFFB8  bne cr6, 0x821c0704
	if !ctx.cr[6].eq {
	pc = 0x821C0704; continue 'dispatch;
	}
	pc = 0x821C0750; continue 'dispatch;
            }
            0x821C0750 => {
    //   block [0x821C0750..0x821C0754)
	// 821C0750: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821C0754; continue 'dispatch;
            }
            0x821C0754 => {
    //   block [0x821C0754..0x821C0770)
	// 821C0754: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C0758: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C075C: 409A0014  bne cr6, 0x821c0770
	if !ctx.cr[6].eq {
	pc = 0x821C0770; continue 'dispatch;
	}
	// 821C0760: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C0764: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 821C0768: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C076C: 409AFF34  bne cr6, 0x821c06a0
	if !ctx.cr[6].eq {
	pc = 0x821C06A0; continue 'dispatch;
	}
	pc = 0x821C0770; continue 'dispatch;
            }
            0x821C0770 => {
    //   block [0x821C0770..0x821C0778)
	// 821C0770: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821C0774: 48AE8CD4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C0778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C0778 size=548
    let mut pc: u32 = 0x821C0778;
    'dispatch: loop {
        match pc {
            0x821C0778 => {
    //   block [0x821C0778..0x821C099C)
	// 821C0778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C077C: 48AE8C91  bl 0x82ca940c
	ctx.lr = 0x821C0780;
	sub_82CA93D0(ctx, base);
	// 821C0780: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C09A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C09A0 size=3812
    let mut pc: u32 = 0x821C09A0;
    'dispatch: loop {
        match pc {
            0x821C09A0 => {
    //   block [0x821C09A0..0x821C1884)
	// 821C09A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C09A4: 48AE8A2D  bl 0x82ca93d0
	ctx.lr = 0x821C09A8;
	sub_82CA93D0(ctx, base);
	// 821C09A8: DBA1FF50  stfd f29, -0xb0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-176 as u32), ctx.f[29].u64 ) };
	// 821C09AC: DBC1FF58  stfd f30, -0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.f[30].u64 ) };
	// 821C09B0: DBE1FF60  stfd f31, -0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 821C09B4: 3980FF30  li r12, -0xd0
	ctx.r[12].s64 = -208;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C1888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C1888 size=356
    let mut pc: u32 = 0x821C1888;
    'dispatch: loop {
        match pc {
            0x821C1888 => {
    //   block [0x821C1888..0x821C18C8)
	// 821C1888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C188C: 48AE7B79  bl 0x82ca9404
	ctx.lr = 0x821C1890;
	sub_82CA93D0(ctx, base);
	// 821C1890: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C1894: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821C1898: 48117211  bl 0x822d8aa8
	ctx.lr = 0x821C189C;
	sub_822D8AA8(ctx, base);
	// 821C189C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C18A0: 3B9B000C  addi r28, r27, 0xc
	ctx.r[28].s64 = ctx.r[27].s64 + 12;
	// 821C18A4: 997B00C7  stb r11, 0xc7(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(199 as u32), ctx.r[11].u8 ) };
	// 821C18A8: 815B0010  lwz r10, 0x10(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C18AC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821C18B0: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C18B4: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821C18B8: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C18BC: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 821C18C0: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821C18C4: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x821C18C8; continue 'dispatch;
            }
            0x821C18C8 => {
    //   block [0x821C18C8..0x821C18DC)
	// 821C18C8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C18CC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821C18D0: 419A000C  beq cr6, 0x821c18dc
	if ctx.cr[6].eq {
	pc = 0x821C18DC; continue 'dispatch;
	}
	// 821C18D4: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821C18D8: 419A0008  beq cr6, 0x821c18e0
	if ctx.cr[6].eq {
	pc = 0x821C18E0; continue 'dispatch;
	}
	pc = 0x821C18DC; continue 'dispatch;
            }
            0x821C18DC => {
    //   block [0x821C18DC..0x821C18E0)
	// 821C18DC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C18E0; continue 'dispatch;
            }
            0x821C18E0 => {
    //   block [0x821C18E0..0x821C18F4)
	// 821C18E0: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C18E4: 419A007C  beq cr6, 0x821c1960
	if ctx.cr[6].eq {
	pc = 0x821C1960; continue 'dispatch;
	}
	// 821C18E8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821C18EC: 409A0008  bne cr6, 0x821c18f4
	if !ctx.cr[6].eq {
	pc = 0x821C18F4; continue 'dispatch;
	}
	// 821C18F0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C18F4; continue 'dispatch;
            }
            0x821C18F4 => {
    //   block [0x821C18F4..0x821C1904)
	// 821C18F4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C18F8: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C18FC: 409A0008  bne cr6, 0x821c1904
	if !ctx.cr[6].eq {
	pc = 0x821C1904; continue 'dispatch;
	}
	// 821C1900: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C1904; continue 'dispatch;
            }
            0x821C1904 => {
    //   block [0x821C1904..0x821C1938)
	// 821C1904: 83FD0008  lwz r31, 8(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C1908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C190C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C1910: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821C1914: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C1918: 4E800421  bctrl
	ctx.lr = 0x821C191C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C191C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C1920: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C1924: 409A001C  bne cr6, 0x821c1940
	if !ctx.cr[6].eq {
	pc = 0x821C1940; continue 'dispatch;
	}
	// 821C1928: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C192C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C1930: 409A0008  bne cr6, 0x821c1938
	if !ctx.cr[6].eq {
	pc = 0x821C1938; continue 'dispatch;
	}
	// 821C1934: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
            }
            0x821C1938 => {
    //   block [0x821C1938..0x821C1940)
	// 821C1938: 83BD0000  lwz r29, 0(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C193C: 4BFFFF8C  b 0x821c18c8
	pc = 0x821C18C8; continue 'dispatch;
            }
            0x821C1940 => {
    //   block [0x821C1940..0x821C1958)
	// 821C1940: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C1944: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C1948: 809B00D0  lwz r4, 0xd0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(208 as u32) ) } as u64;
	// 821C194C: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821C1950: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C1954: 4E800421  bctrl
	ctx.lr = 0x821C1958;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821C1958 => {
    //   block [0x821C1958..0x821C1960)
	// 821C1958: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821C195C: 48AE7AF8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x821C1960 => {
    //   block [0x821C1960..0x821C1980)
	// 821C1960: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C1964: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821C1968: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C196C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C1970: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C1974: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 821C1978: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821C197C: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x821C1980; continue 'dispatch;
            }
            0x821C1980 => {
    //   block [0x821C1980..0x821C1994)
	// 821C1980: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C1984: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821C1988: 419A000C  beq cr6, 0x821c1994
	if ctx.cr[6].eq {
	pc = 0x821C1994; continue 'dispatch;
	}
	// 821C198C: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821C1990: 419A0008  beq cr6, 0x821c1998
	if ctx.cr[6].eq {
	pc = 0x821C1998; continue 'dispatch;
	}
	pc = 0x821C1994; continue 'dispatch;
            }
            0x821C1994 => {
    //   block [0x821C1994..0x821C1998)
	// 821C1994: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C1998; continue 'dispatch;
            }
            0x821C1998 => {
    //   block [0x821C1998..0x821C19AC)
	// 821C1998: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C199C: 419AFFBC  beq cr6, 0x821c1958
	if ctx.cr[6].eq {
	pc = 0x821C1958; continue 'dispatch;
	}
	// 821C19A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821C19A4: 409A0008  bne cr6, 0x821c19ac
	if !ctx.cr[6].eq {
	pc = 0x821C19AC; continue 'dispatch;
	}
	// 821C19A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C19AC; continue 'dispatch;
            }
            0x821C19AC => {
    //   block [0x821C19AC..0x821C19BC)
	// 821C19AC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C19B0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C19B4: 409A0008  bne cr6, 0x821c19bc
	if !ctx.cr[6].eq {
	pc = 0x821C19BC; continue 'dispatch;
	}
	// 821C19B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C19BC; continue 'dispatch;
            }
            0x821C19BC => {
    //   block [0x821C19BC..0x821C19E4)
	// 821C19BC: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C19C0: 809B00D0  lwz r4, 0xd0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(208 as u32) ) } as u64;
	// 821C19C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C19C8: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821C19CC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C19D0: 4E800421  bctrl
	ctx.lr = 0x821C19D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C19D4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C19D8: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821C19DC: 409A0008  bne cr6, 0x821c19e4
	if !ctx.cr[6].eq {
	pc = 0x821C19E4; continue 'dispatch;
	}
	// 821C19E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
            }
            0x821C19E4 => {
    //   block [0x821C19E4..0x821C19EC)
	// 821C19E4: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C19E8: 4BFFFF98  b 0x821c1980
	pc = 0x821C1980; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C19F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C19F0 size=972
    let mut pc: u32 = 0x821C19F0;
    'dispatch: loop {
        match pc {
            0x821C19F0 => {
    //   block [0x821C19F0..0x821C1AEC)
	// 821C19F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C19F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C19F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821C19FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C1A00: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C1A04: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821C1A08: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 821C1A0C: 394B2390  addi r10, r11, 0x2390
	ctx.r[10].s64 = ctx.r[11].s64 + 9104;
	// 821C1A10: 3D00834B  lis r8, -0x7cb5
	ctx.r[8].s64 = -2092236800;
	// 821C1A14: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821C1A18: 38687E70  addi r3, r8, 0x7e70
	ctx.r[3].s64 = ctx.r[8].s64 + 32368;
	// 821C1A1C: 83E90364  lwz r31, 0x364(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(868 as u32) ) } as u64;
	// 821C1A20: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821C1A24: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C1A28: 38CA2008  addi r6, r10, 0x2008
	ctx.r[6].s64 = ctx.r[10].s64 + 8200;
	// 821C1A2C: 99010050  stb r8, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u8 ) };
	// 821C1A30: 396B63A0  addi r11, r11, 0x63a0
	ctx.r[11].s64 = ctx.r[11].s64 + 25504;
	// 821C1A34: 55271838  slwi r7, r9, 3
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821C1A38: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821C1A3C: 3CA08349  lis r5, -0x7cb7
	ctx.r[5].s64 = -2092367872;
	// 821C1A40: 38890DB8  addi r4, r9, 0xdb8
	ctx.r[4].s64 = ctx.r[9].s64 + 3512;
	// 821C1A44: 7C67512E  stwx r3, r7, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32), ctx.r[3].u32) };
	// 821C1A48: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C1A4C: 80EA2000  lwz r7, 0x2000(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C1A50: 812A400C  lwz r9, 0x400c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821C1A54: 553E1838  slwi r30, r9, 3
	ctx.r[30].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821C1A58: 39280001  addi r9, r8, 1
	ctx.r[9].s64 = ctx.r[8].s64 + 1;
	// 821C1A5C: 54E8083C  slwi r8, r7, 1
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C1A60: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	// 821C1A64: 910A2000  stw r8, 0x2000(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8192 as u32), ctx.r[8].u32 ) };
	// 821C1A68: 7C7E312E  stwx r3, r30, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[6].u32), ctx.r[3].u32) };
	// 821C1A6C: 886B1A6D  lbz r3, 0x1a6d(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6765 as u32) ) } as u64;
	// 821C1A70: 80EA4008  lwz r7, 0x4008(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16392 as u32) ) } as u64;
	// 821C1A74: 80CB1A5C  lwz r6, 0x1a5c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6748 as u32) ) } as u64;
	// 821C1A78: 810A400C  lwz r8, 0x400c(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821C1A7C: 39280001  addi r9, r8, 1
	ctx.r[9].s64 = ctx.r[8].s64 + 1;
	// 821C1A80: 1D032008  mulli r8, r3, 0x2008
	ctx.r[8].s32 = ((ctx.r[3].s32 as i64 * 8200 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 821C1A84: 912A400C  stw r9, 0x400c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16396 as u32), ctx.r[9].u32 ) };
	// 821C1A88: 7D285214  add r9, r8, r10
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C1A8C: 54E8083C  slwi r8, r7, 1
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C1A90: 3929DFF8  addi r9, r9, -0x2008
	ctx.r[9].s64 = ctx.r[9].s64 + -8200;
	// 821C1A94: 910A4008  stw r8, 0x4008(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16392 as u32), ctx.r[8].u32 ) };
	// 821C1A98: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821C1A9C: 419A0088  beq cr6, 0x821c1b24
	if ctx.cr[6].eq {
	pc = 0x821C1B24; continue 'dispatch;
	}
	// 821C1AA0: 81092000  lwz r8, 0x2000(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C1AA4: 80EB1A60  lwz r7, 0x1a60(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6752 as u32) ) } as u64;
	// 821C1AA8: 7D063838  and r6, r8, r7
	ctx.r[6].u64 = ctx.r[8].u64 & ctx.r[7].u64;
	// 821C1AAC: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821C1AB0: 409A003C  bne cr6, 0x821c1aec
	if !ctx.cr[6].eq {
	pc = 0x821C1AEC; continue 'dispatch;
	}
	// 821C1AB4: 80C92004  lwz r6, 0x2004(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C1AB8: 7D083B78  or r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 821C1ABC: 386B1A58  addi r3, r11, 0x1a58
	ctx.r[3].s64 = ctx.r[11].s64 + 6744;
	// 821C1AC0: 54C71838  slwi r7, r6, 3
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821C1AC4: 910B1A60  stw r8, 0x1a60(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6752 as u32), ctx.r[8].u32 ) };
	// 821C1AC8: 7C67492E  stwx r3, r7, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[9].u32), ctx.r[3].u32) };
	// 821C1ACC: 810B1A5C  lwz r8, 0x1a5c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6748 as u32) ) } as u64;
	// 821C1AD0: 80C92004  lwz r6, 0x2004(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C1AD4: 54C71838  slwi r7, r6, 3
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821C1AD8: 7C674A14  add r3, r7, r9
	ctx.r[3].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 821C1ADC: 91030004  stw r8, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821C1AE0: 81092004  lwz r8, 0x2004(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C1AE4: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 821C1AE8: 91092004  stw r8, 0x2004(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8196 as u32), ctx.r[8].u32 ) };
	pc = 0x821C1AEC; continue 'dispatch;
            }
            0x821C1AEC => {
    //   block [0x821C1AEC..0x821C1B24)
	// 821C1AEC: 892B1A6C  lbz r9, 0x1a6c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6764 as u32) ) } as u64;
	// 821C1AF0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821C1AF4: 910B1A5C  stw r8, 0x1a5c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6748 as u32), ctx.r[8].u32 ) };
	// 821C1AF8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C1AFC: 409A0028  bne cr6, 0x821c1b24
	if !ctx.cr[6].eq {
	pc = 0x821C1B24; continue 'dispatch;
	}
	// 821C1B00: 81250DB0  lwz r9, 0xdb0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821C1B04: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821C1B08: 38EB1A58  addi r7, r11, 0x1a58
	ctx.r[7].s64 = ctx.r[11].s64 + 6744;
	// 821C1B0C: 5523103A  slwi r3, r9, 2
	ctx.r[3].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821C1B10: 990B1A6C  stb r8, 0x1a6c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6764 as u32), ctx.r[8].u8 ) };
	// 821C1B14: 38C90001  addi r6, r9, 1
	ctx.r[6].s64 = ctx.r[9].s64 + 1;
	// 821C1B18: 90C50DB0  stw r6, 0xdb0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 821C1B1C: 7CE3212E  stwx r7, r3, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[4].u32), ctx.r[7].u32) };
	// 821C1B20: 48000008  b 0x821c1b28
	pc = 0x821C1B28; continue 'dispatch;
            }
            0x821C1B24 => {
    //   block [0x821C1B24..0x821C1B28)
	// 821C1B24: 80C50DB0  lwz r6, 0xdb0(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3504 as u32) ) } as u64;
	pc = 0x821C1B28; continue 'dispatch;
            }
            0x821C1B28 => {
    //   block [0x821C1B28..0x821C1B90)
	// 821C1B28: 892B1A85  lbz r9, 0x1a85(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6789 as u32) ) } as u64;
	// 821C1B2C: 810B1A74  lwz r8, 0x1a74(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6772 as u32) ) } as u64;
	// 821C1B30: 1D292008  mulli r9, r9, 0x2008
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * 8200 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 821C1B34: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821C1B38: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 821C1B3C: 3929DFF8  addi r9, r9, -0x2008
	ctx.r[9].s64 = ctx.r[9].s64 + -8200;
	// 821C1B40: 419A0080  beq cr6, 0x821c1bc0
	if ctx.cr[6].eq {
	pc = 0x821C1BC0; continue 'dispatch;
	}
	// 821C1B44: 81092000  lwz r8, 0x2000(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C1B48: 80EB1A78  lwz r7, 0x1a78(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6776 as u32) ) } as u64;
	// 821C1B4C: 7D033838  and r3, r8, r7
	ctx.r[3].u64 = ctx.r[8].u64 & ctx.r[7].u64;
	// 821C1B50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821C1B54: 409A003C  bne cr6, 0x821c1b90
	if !ctx.cr[6].eq {
	pc = 0x821C1B90; continue 'dispatch;
	}
	// 821C1B58: 80692004  lwz r3, 0x2004(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C1B5C: 7D083B78  or r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 821C1B60: 38EB1A70  addi r7, r11, 0x1a70
	ctx.r[7].s64 = ctx.r[11].s64 + 6768;
	// 821C1B64: 54631838  slwi r3, r3, 3
	ctx.r[3].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821C1B68: 910B1A78  stw r8, 0x1a78(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6776 as u32), ctx.r[8].u32 ) };
	// 821C1B6C: 7CE3492E  stwx r7, r3, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[9].u32), ctx.r[7].u32) };
	// 821C1B70: 810B1A74  lwz r8, 0x1a74(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6772 as u32) ) } as u64;
	// 821C1B74: 80E92004  lwz r7, 0x2004(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C1B78: 54E71838  slwi r7, r7, 3
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821C1B7C: 7C674A14  add r3, r7, r9
	ctx.r[3].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 821C1B80: 91030004  stw r8, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821C1B84: 81092004  lwz r8, 0x2004(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C1B88: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 821C1B8C: 91092004  stw r8, 0x2004(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8196 as u32), ctx.r[8].u32 ) };
	pc = 0x821C1B90; continue 'dispatch;
            }
            0x821C1B90 => {
    //   block [0x821C1B90..0x821C1BC0)
	// 821C1B90: 892B1A84  lbz r9, 0x1a84(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6788 as u32) ) } as u64;
	// 821C1B94: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821C1B98: 910B1A74  stw r8, 0x1a74(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6772 as u32), ctx.r[8].u32 ) };
	// 821C1B9C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C1BA0: 409A0020  bne cr6, 0x821c1bc0
	if !ctx.cr[6].eq {
	pc = 0x821C1BC0; continue 'dispatch;
	}
	// 821C1BA4: 54C8103A  slwi r8, r6, 2
	ctx.r[8].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C1BA8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821C1BAC: 38EB1A70  addi r7, r11, 0x1a70
	ctx.r[7].s64 = ctx.r[11].s64 + 6768;
	// 821C1BB0: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 821C1BB4: 992B1A84  stb r9, 0x1a84(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6788 as u32), ctx.r[9].u8 ) };
	// 821C1BB8: 90C50DB0  stw r6, 0xdb0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 821C1BBC: 7CE8212E  stwx r7, r8, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32), ctx.r[7].u32) };
	pc = 0x821C1BC0; continue 'dispatch;
            }
            0x821C1BC0 => {
    //   block [0x821C1BC0..0x821C1C28)
	// 821C1BC0: 892B1AB5  lbz r9, 0x1ab5(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6837 as u32) ) } as u64;
	// 821C1BC4: 810B1AA4  lwz r8, 0x1aa4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6820 as u32) ) } as u64;
	// 821C1BC8: 1D292008  mulli r9, r9, 0x2008
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * 8200 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 821C1BCC: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821C1BD0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821C1BD4: 3929DFF8  addi r9, r9, -0x2008
	ctx.r[9].s64 = ctx.r[9].s64 + -8200;
	// 821C1BD8: 419A0080  beq cr6, 0x821c1c58
	if ctx.cr[6].eq {
	pc = 0x821C1C58; continue 'dispatch;
	}
	// 821C1BDC: 81092000  lwz r8, 0x2000(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C1BE0: 80EB1AA8  lwz r7, 0x1aa8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6824 as u32) ) } as u64;
	// 821C1BE4: 7D033838  and r3, r8, r7
	ctx.r[3].u64 = ctx.r[8].u64 & ctx.r[7].u64;
	// 821C1BE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821C1BEC: 409A003C  bne cr6, 0x821c1c28
	if !ctx.cr[6].eq {
	pc = 0x821C1C28; continue 'dispatch;
	}
	// 821C1BF0: 80692004  lwz r3, 0x2004(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C1BF4: 7D083B78  or r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 821C1BF8: 38EB1AA0  addi r7, r11, 0x1aa0
	ctx.r[7].s64 = ctx.r[11].s64 + 6816;
	// 821C1BFC: 54631838  slwi r3, r3, 3
	ctx.r[3].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821C1C00: 910B1AA8  stw r8, 0x1aa8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6824 as u32), ctx.r[8].u32 ) };
	// 821C1C04: 7CE3492E  stwx r7, r3, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[9].u32), ctx.r[7].u32) };
	// 821C1C08: 81092004  lwz r8, 0x2004(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C1C0C: 55071838  slwi r7, r8, 3
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821C1C10: 7CE74A14  add r7, r7, r9
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 821C1C14: 810B1AA4  lwz r8, 0x1aa4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6820 as u32) ) } as u64;
	// 821C1C18: 91070004  stw r8, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821C1C1C: 81092004  lwz r8, 0x2004(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C1C20: 38680001  addi r3, r8, 1
	ctx.r[3].s64 = ctx.r[8].s64 + 1;
	// 821C1C24: 90692004  stw r3, 0x2004(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8196 as u32), ctx.r[3].u32 ) };
	pc = 0x821C1C28; continue 'dispatch;
            }
            0x821C1C28 => {
    //   block [0x821C1C28..0x821C1C58)
	// 821C1C28: 892B1AB4  lbz r9, 0x1ab4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6836 as u32) ) } as u64;
	// 821C1C2C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821C1C30: 910B1AA4  stw r8, 0x1aa4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6820 as u32), ctx.r[8].u32 ) };
	// 821C1C34: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C1C38: 409A0020  bne cr6, 0x821c1c58
	if !ctx.cr[6].eq {
	pc = 0x821C1C58; continue 'dispatch;
	}
	// 821C1C3C: 54C8103A  slwi r8, r6, 2
	ctx.r[8].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C1C40: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821C1C44: 38EB1AA0  addi r7, r11, 0x1aa0
	ctx.r[7].s64 = ctx.r[11].s64 + 6816;
	// 821C1C48: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 821C1C4C: 992B1AB4  stb r9, 0x1ab4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6836 as u32), ctx.r[9].u8 ) };
	// 821C1C50: 90C50DB0  stw r6, 0xdb0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 821C1C54: 7CE8212E  stwx r7, r8, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32), ctx.r[7].u32) };
	pc = 0x821C1C58; continue 'dispatch;
            }
            0x821C1C58 => {
    //   block [0x821C1C58..0x821C1CCC)
	// 821C1C58: 3CE08331  lis r7, -0x7ccf
	ctx.r[7].s64 = -2093940736;
	// 821C1C5C: 886B1A9D  lbz r3, 0x1a9d(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6813 as u32) ) } as u64;
	// 821C1C60: 810B1A8C  lwz r8, 0x1a8c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6796 as u32) ) } as u64;
	// 821C1C64: 38E76FB8  addi r7, r7, 0x6fb8
	ctx.r[7].s64 = ctx.r[7].s64 + 28600;
	// 821C1C68: 1D232008  mulli r9, r3, 0x2008
	ctx.r[9].s32 = ((ctx.r[3].s32 as i64 * 8200 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 821C1C6C: 80E70004  lwz r7, 4(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C1C70: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821C1C74: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821C1C78: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C1C7C: 419A007C  beq cr6, 0x821c1cf8
	if ctx.cr[6].eq {
	pc = 0x821C1CF8; continue 'dispatch;
	}
	// 821C1C80: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C1C84: 810B1A90  lwz r8, 0x1a90(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6800 as u32) ) } as u64;
	// 821C1C88: 7D234038  and r3, r9, r8
	ctx.r[3].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821C1C8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821C1C90: 409A003C  bne cr6, 0x821c1ccc
	if !ctx.cr[6].eq {
	pc = 0x821C1CCC; continue 'dispatch;
	}
	// 821C1C94: 806A2004  lwz r3, 0x2004(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C1C98: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821C1C9C: 390B1A88  addi r8, r11, 0x1a88
	ctx.r[8].s64 = ctx.r[11].s64 + 6792;
	// 821C1CA0: 54631838  slwi r3, r3, 3
	ctx.r[3].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821C1CA4: 912B1A90  stw r9, 0x1a90(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6800 as u32), ctx.r[9].u32 ) };
	// 821C1CA8: 7D03512E  stwx r8, r3, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u32) };
	// 821C1CAC: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C1CB0: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C1CB4: 812B1A8C  lwz r9, 0x1a8c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6796 as u32) ) } as u64;
	// 821C1CB8: 7C685214  add r3, r8, r10
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C1CBC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C1CC0: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C1CC4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821C1CC8: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	pc = 0x821C1CCC; continue 'dispatch;
            }
            0x821C1CCC => {
    //   block [0x821C1CCC..0x821C1CF8)
	// 821C1CCC: 894B1A9C  lbz r10, 0x1a9c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6812 as u32) ) } as u64;
	// 821C1CD0: 90EB1A8C  stw r7, 0x1a8c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6796 as u32), ctx.r[7].u32 ) };
	// 821C1CD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C1CD8: 409A0020  bne cr6, 0x821c1cf8
	if !ctx.cr[6].eq {
	pc = 0x821C1CF8; continue 'dispatch;
	}
	// 821C1CDC: 54C8103A  slwi r8, r6, 2
	ctx.r[8].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C1CE0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C1CE4: 38EB1A88  addi r7, r11, 0x1a88
	ctx.r[7].s64 = ctx.r[11].s64 + 6792;
	// 821C1CE8: 39260001  addi r9, r6, 1
	ctx.r[9].s64 = ctx.r[6].s64 + 1;
	// 821C1CEC: 994B1A9C  stb r10, 0x1a9c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6812 as u32), ctx.r[10].u8 ) };
	// 821C1CF0: 91250DB0  stw r9, 0xdb0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(3504 as u32), ctx.r[9].u32 ) };
	// 821C1CF4: 7CE8212E  stwx r7, r8, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32), ctx.r[7].u32) };
	pc = 0x821C1CF8; continue 'dispatch;
            }
            0x821C1CF8 => {
    //   block [0x821C1CF8..0x821C1D14)
	// 821C1CF8: 4805C7A9  bl 0x8221e4a0
	ctx.lr = 0x821C1CFC;
	sub_8221E4A0(ctx, base);
	// 821C1CFC: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821C1D00: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821C1D04: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C1D08: 4099000C  ble cr6, 0x821c1d14
	if !ctx.cr[6].gt {
	pc = 0x821C1D14; continue 'dispatch;
	}
	// 821C1D0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C1D10: 480271B1  bl 0x821e8ec0
	ctx.lr = 0x821C1D14;
	sub_821E8EC0(ctx, base);
	pc = 0x821C1D14; continue 'dispatch;
            }
            0x821C1D14 => {
    //   block [0x821C1D14..0x821C1DBC)
	// 821C1D14: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 821C1D18: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821C1D1C: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 821C1D20: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821C1D24: 3CC0C000  lis r6, -0x4000
	ctx.r[6].s64 = -1073741824;
	// 821C1D28: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C1DC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C1DC0 size=120
    let mut pc: u32 = 0x821C1DC0;
    'dispatch: loop {
        match pc {
            0x821C1DC0 => {
    //   block [0x821C1DC0..0x821C1DE8)
	// 821C1DC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C1DC4: 48AE7649  bl 0x82ca940c
	ctx.lr = 0x821C1DC8;
	sub_82CA93D0(ctx, base);
	// 821C1DC8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C1DCC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C1DD0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821C1DD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C1DD8: 409A0010  bne cr6, 0x821c1de8
	if !ctx.cr[6].eq {
	pc = 0x821C1DE8; continue 'dispatch;
	}
	// 821C1DDC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 821C1DE0: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 821C1DE4: 48000008  b 0x821c1dec
	pc = 0x821C1DEC; continue 'dispatch;
            }
            0x821C1DE8 => {
    //   block [0x821C1DE8..0x821C1DEC)
	// 821C1DE8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821C1DEC; continue 'dispatch;
            }
            0x821C1DEC => {
    //   block [0x821C1DEC..0x821C1E0C)
	// 821C1DEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C1DF0: 48130151  bl 0x822f1f40
	ctx.lr = 0x821C1DF4;
	sub_822F1F40(ctx, base);
	// 821C1DF4: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 821C1DF8: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C1DFC: 2B1F0010  cmplwi cr6, r31, 0x10
	ctx.cr[6].compare_u32(ctx.r[31].u32, 16 as u32, &mut ctx.xer);
	// 821C1E00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C1E04: 40980008  bge cr6, 0x821c1e0c
	if !ctx.cr[6].lt {
	pc = 0x821C1E0C; continue 'dispatch;
	}
	// 821C1E08: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	pc = 0x821C1E0C; continue 'dispatch;
            }
            0x821C1E0C => {
    //   block [0x821C1E0C..0x821C1E2C)
	// 821C1E0C: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 821C1E10: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 821C1E14: 48031F45  bl 0x821f3d58
	ctx.lr = 0x821C1E18;
	sub_821F3D58(ctx, base);
	// 821C1E18: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821C1E1C: 2B1F0010  cmplwi cr6, r31, 0x10
	ctx.cr[6].compare_u32(ctx.r[31].u32, 16 as u32, &mut ctx.xer);
	// 821C1E20: 4198000C  blt cr6, 0x821c1e2c
	if ctx.cr[6].lt {
	pc = 0x821C1E2C; continue 'dispatch;
	}
	// 821C1E24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C1E28: 48059F11  bl 0x8221bd38
	ctx.lr = 0x821C1E2C;
	sub_8221BD38(ctx, base);
	pc = 0x821C1E2C; continue 'dispatch;
            }
            0x821C1E2C => {
    //   block [0x821C1E2C..0x821C1E38)
	// 821C1E2C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821C1E30: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821C1E34: 48AE7628  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C1E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C1E38 size=372
    let mut pc: u32 = 0x821C1E38;
    'dispatch: loop {
        match pc {
            0x821C1E38 => {
    //   block [0x821C1E38..0x821C1FAC)
	// 821C1E38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C1E3C: 48AE75CD  bl 0x82ca9408
	ctx.lr = 0x821C1E40;
	sub_82CA93D0(ctx, base);
	// 821C1E40: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821C1E44: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C1E48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C1E4C: 3B800020  li r28, 0x20
	ctx.r[28].s64 = 32;
	// 821C1E50: 3BA00030  li r29, 0x30
	ctx.r[29].s64 = 48;
	// 821C1E54: 3BC00010  li r30, 0x10
	ctx.r[30].s64 = 16;
	// 821C1E58: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C1FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C1FB0 size=68
    let mut pc: u32 = 0x821C1FB0;
    'dispatch: loop {
        match pc {
            0x821C1FB0 => {
    //   block [0x821C1FB0..0x821C1FF4)
	// 821C1FB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C1FB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C1FB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C1FBC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C1FC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C1FC4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821C1FC8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821C1FCC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821C1FD0: 480C1D61  bl 0x82283d30
	ctx.lr = 0x821C1FD4;
	sub_82283D30(ctx, base);
	// 821C1FD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C1FD8: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821C1FDC: 480B107D  bl 0x82273058
	ctx.lr = 0x821C1FE0;
	sub_82273058(ctx, base);
	// 821C1FE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821C1FE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C1FE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C1FEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C1FF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C1FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C1FF8 size=136
    let mut pc: u32 = 0x821C1FF8;
    'dispatch: loop {
        match pc {
            0x821C1FF8 => {
    //   block [0x821C1FF8..0x821C2080)
	// 821C1FF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C1FFC: 48AE7411  bl 0x82ca940c
	ctx.lr = 0x821C2000;
	sub_82CA93D0(ctx, base);
	// 821C2000: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C2004: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 821C2008: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C200C: 480660ED  bl 0x822280f8
	ctx.lr = 0x821C2010;
	sub_822280F8(ctx, base);
	// 821C2010: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821C2014: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821C2018: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C201C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821C2020: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C2024: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821C2028: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 821C202C: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821C2030: 48630641  bl 0x827f2670
	ctx.lr = 0x821C2034;
	sub_827F2670(ctx, base);
	// 821C2034: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821C2038: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821C203C: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 821C2040: 4E800421  bctrl
	ctx.lr = 0x821C2044;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C2044: 7C6907B4  extsw r9, r3
	ctx.r[9].s64 = ctx.r[3].s32 as i64;
	// 821C2048: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C204C: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 821C2050: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 821C2054: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821C2058: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 821C205C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821C2060: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821C2064: D1880000  stfs f12, 0(r8)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821C2068: 90E80004  stw r7, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821C206C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C2070: 38CB0008  addi r6, r11, 8
	ctx.r[6].s64 = ctx.r[11].s64 + 8;
	// 821C2074: 90DF0008  stw r6, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 821C2078: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821C207C: 48AE73E0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C2080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C2080 size=2076
    let mut pc: u32 = 0x821C2080;
    'dispatch: loop {
        match pc {
            0x821C2080 => {
    //   block [0x821C2080..0x821C20B8)
	// 821C2080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C2084: 48AE7385  bl 0x82ca9408
	ctx.lr = 0x821C2088;
	sub_82CA93D0(ctx, base);
	// 821C2088: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 821C208C: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821C2090: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C2094: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821C2098: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821C209C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821C20A0: 419A0018  beq cr6, 0x821c20b8
	if ctx.cr[6].eq {
	pc = 0x821C20B8; continue 'dispatch;
	}
	// 821C20A4: 897D0090  lbz r11, 0x90(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(144 as u32) ) } as u64;
	// 821C20A8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821C20AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C20B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C20B4: 409A0008  bne cr6, 0x821c20bc
	if !ctx.cr[6].eq {
	pc = 0x821C20BC; continue 'dispatch;
	}
	pc = 0x821C20B8; continue 'dispatch;
            }
            0x821C20B8 => {
    //   block [0x821C20B8..0x821C20BC)
	// 821C20B8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821C20BC; continue 'dispatch;
            }
            0x821C20BC => {
    //   block [0x821C20BC..0x821C2104)
	// 821C20BC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C20C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C20C4: 419A07BC  beq cr6, 0x821c2880
	if ctx.cr[6].eq {
	pc = 0x821C2880; continue 'dispatch;
	}
	// 821C20C8: 80BD002C  lwz r5, 0x2c(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 821C20CC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821C20D0: 54AA8FFE  rlwinm r10, r5, 0x11, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x00007FFFu64;
	// 821C20D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C20D8: 419A00E8  beq cr6, 0x821c21c0
	if ctx.cr[6].eq {
	pc = 0x821C21C0; continue 'dispatch;
	}
	// 821C20DC: 817D008C  lwz r11, 0x8c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C20E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C20E4: 419A0020  beq cr6, 0x821c2104
	if ctx.cr[6].eq {
	pc = 0x821C2104; continue 'dispatch;
	}
	// 821C20E8: 894B004F  lbz r10, 0x4f(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(79 as u32) ) } as u64;
	// 821C20EC: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C20F0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821C20F4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821C20F8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C20FC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2100: 480000C4  b 0x821c21c4
	pc = 0x821C21C4; continue 'dispatch;
            }
            0x821C2104 => {
    //   block [0x821C2104..0x821C2120)
	// 821C2104: 815D0048  lwz r10, 0x48(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C2108: 80DD004C  lwz r6, 0x4c(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 821C210C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821C2110: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821C2114: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C2118: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C211C: 40810054  ble 0x821c2170
	if !ctx.cr[0].gt {
	pc = 0x821C2170; continue 'dispatch;
	}
	pc = 0x821C2120; continue 'dispatch;
            }
            0x821C2120 => {
    //   block [0x821C2120..0x821C2140)
	// 821C2120: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821C2124: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C2128: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C212C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C2130: 2F07004F  cmpwi cr6, r7, 0x4f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 79, &mut ctx.xer);
	// 821C2134: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821C2138: 41980008  blt cr6, 0x821c2140
	if ctx.cr[6].lt {
	pc = 0x821C2140; continue 'dispatch;
	}
	// 821C213C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x821C2140; continue 'dispatch;
            }
            0x821C2140 => {
    //   block [0x821C2140..0x821C215C)
	// 821C2140: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821C2144: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C2148: 419A0014  beq cr6, 0x821c215c
	if ctx.cr[6].eq {
	pc = 0x821C215C; continue 'dispatch;
	}
	// 821C214C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821C2150: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C2154: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C2158: 4800000C  b 0x821c2164
	pc = 0x821C2164; continue 'dispatch;
            }
            0x821C215C => {
    //   block [0x821C215C..0x821C2164)
	// 821C215C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821C2160: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821C2164; continue 'dispatch;
            }
            0x821C2164 => {
    //   block [0x821C2164..0x821C2170)
	// 821C2164: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C2168: 4199FFB8  bgt cr6, 0x821c2120
	if ctx.cr[6].gt {
	pc = 0x821C2120; continue 'dispatch;
	}
	// 821C216C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821C2170; continue 'dispatch;
            }
            0x821C2170 => {
    //   block [0x821C2170..0x821C218C)
	// 821C2170: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C2174: 419A003C  beq cr6, 0x821c21b0
	if ctx.cr[6].eq {
	pc = 0x821C21B0; continue 'dispatch;
	}
	// 821C2178: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C217C: 2F0B004F  cmpwi cr6, r11, 0x4f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 79, &mut ctx.xer);
	// 821C2180: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C2184: 41990008  bgt cr6, 0x821c218c
	if ctx.cr[6].gt {
	pc = 0x821C218C; continue 'dispatch;
	}
	// 821C2188: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821C218C; continue 'dispatch;
            }
            0x821C218C => {
    //   block [0x821C218C..0x821C21B0)
	// 821C218C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C2190: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C2194: 409A001C  bne cr6, 0x821c21b0
	if !ctx.cr[6].eq {
	pc = 0x821C21B0; continue 'dispatch;
	}
	// 821C2198: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C219C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C21A0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821C21A4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C21A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C21AC: 48000018  b 0x821c21c4
	pc = 0x821C21C4; continue 'dispatch;
            }
            0x821C21B0 => {
    //   block [0x821C21B0..0x821C21C0)
	// 821C21B0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821C21B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C21B8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C21BC: 48000008  b 0x821c21c4
	pc = 0x821C21C4; continue 'dispatch;
            }
            0x821C21C0 => {
    //   block [0x821C21C0..0x821C21C4)
	// 821C21C0: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	pc = 0x821C21C4; continue 'dispatch;
            }
            0x821C21C4 => {
    //   block [0x821C21C4..0x821C21DC)
	// 821C21C4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821C21C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C21CC: 419A0010  beq cr6, 0x821c21dc
	if ctx.cr[6].eq {
	pc = 0x821C21DC; continue 'dispatch;
	}
	// 821C21D0: 896B003B  lbz r11, 0x3b(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(59 as u32) ) } as u64;
	// 821C21D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C21D8: 409A0014  bne cr6, 0x821c21ec
	if !ctx.cr[6].eq {
	pc = 0x821C21EC; continue 'dispatch;
	}
	pc = 0x821C21DC; continue 'dispatch;
            }
            0x821C21DC => {
    //   block [0x821C21DC..0x821C21EC)
	// 821C21DC: 83DD0030  lwz r30, 0x30(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 821C21E0: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 821C21E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C21E8: 419A00F4  beq cr6, 0x821c22dc
	if ctx.cr[6].eq {
	pc = 0x821C22DC; continue 'dispatch;
	}
	pc = 0x821C21EC; continue 'dispatch;
            }
            0x821C21EC => {
    //   block [0x821C21EC..0x821C2250)
	// 821C21EC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C21F0: 809D007C  lwz r4, 0x7c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(124 as u32) ) } as u64;
	// 821C21F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C21F8: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821C21FC: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C2200: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C2204: 810A0040  lwz r8, 0x40(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821C2208: 80E90058  lwz r7, 0x58(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 821C220C: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2210: 83E60008  lwz r31, 8(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C2214: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821C2218: 4E800421  bctrl
	ctx.lr = 0x821C221C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C221C: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2220: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821C2224: 3BCBB730  addi r30, r11, -0x48d0
	ctx.r[30].s64 = ctx.r[11].s64 + -18640;
	// 821C2228: C3FEDD54  lfs f31, -0x22ac(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-8876 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821C222C: 81650024  lwz r11, 0x24(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 821C2230: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C2234: 419A001C  beq cr6, 0x821c2250
	if ctx.cr[6].eq {
	pc = 0x821C2250; continue 'dispatch;
	}
	// 821C2238: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821C223C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
            }
            0x821C2250 => {
    //   block [0x821C2250..0x821C22DC)
	// 821C2250: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 821C2254: 809D007C  lwz r4, 0x7c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(124 as u32) ) } as u64;
	// 821C2258: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821C225C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C2260: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821C2264: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C2268: 4E800421  bctrl
	ctx.lr = 0x821C226C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C226C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2270: 81690024  lwz r11, 0x24(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(36 as u32) ) } as u64;
	// 821C2274: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C2278: 419A0018  beq cr6, 0x821c2290
	if ctx.cr[6].eq {
	pc = 0x821C2290; continue 'dispatch;
	}
	// 821C227C: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 821C2280: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
            }
            0x821C22DC => {
    //   block [0x821C22DC..0x821C2880)
	// 821C22DC: 817D0028  lwz r11, 0x28(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 821C22E0: 556AC7FE  rlwinm r10, r11, 0x18, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C22E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C22E8: 419A0020  beq cr6, 0x821c2308
	if ctx.cr[6].eq {
	pc = 0x821C2308; continue 'dispatch;
	}
	// 821C22EC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821C22F0: 394BB730  addi r10, r11, -0x48d0
	ctx.r[10].s64 = ctx.r[11].s64 + -18640;
	// 821C22F4: C02ADD60  lfs f1, -0x22a0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8864 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821C22F8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821C22FC: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 821C2300: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821C2304: 48AE7154  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 821C2308: 817D0040  lwz r11, 0x40(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(64 as u32) ) } as u64;
	// 821C230C: 556A8FFE  rlwinm r10, r11, 0x11, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00007FFFu64;
	// 821C2310: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C2314: 419A0020  beq cr6, 0x821c2334
	if ctx.cr[6].eq {
	pc = 0x821C2334; continue 'dispatch;
	}
	// 821C2318: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821C231C: 394BB730  addi r10, r11, -0x48d0
	ctx.r[10].s64 = ctx.r[11].s64 + -18640;
	// 821C2320: C02ADBA4  lfs f1, -0x245c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-9308 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821C2324: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821C2328: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 821C232C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821C2330: 48AE7128  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 821C2334: 54AA97FE  rlwinm r10, r5, 0x12, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x00003FFFu64;
	// 821C2338: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821C233C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C2340: 419A00E8  beq cr6, 0x821c2428
	if ctx.cr[6].eq {
	pc = 0x821C2428; continue 'dispatch;
	}
	// 821C2344: 817D008C  lwz r11, 0x8c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C2348: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C234C: 419A0020  beq cr6, 0x821c236c
	if ctx.cr[6].eq {
	pc = 0x821C236C; continue 'dispatch;
	}
	// 821C2350: 894B004E  lbz r10, 0x4e(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(78 as u32) ) } as u64;
	// 821C2354: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C2358: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821C235C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821C2360: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C2364: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2368: 480000C4  b 0x821c242c
	pc = 0x821C242C; continue 'dispatch;
	// 821C236C: 815D0048  lwz r10, 0x48(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C2370: 80DD004C  lwz r6, 0x4c(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 821C2374: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821C2378: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821C237C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C2380: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C2384: 40810054  ble 0x821c23d8
	if !ctx.cr[0].gt {
	pc = 0x821C23D8; continue 'dispatch;
	}
	// 821C2388: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821C238C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C2390: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C2394: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C2398: 2F07004E  cmpwi cr6, r7, 0x4e
	ctx.cr[6].compare_i32(ctx.r[7].s32, 78, &mut ctx.xer);
	// 821C239C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821C23A0: 41980008  blt cr6, 0x821c23a8
	if ctx.cr[6].lt {
	pc = 0x821C23A8; continue 'dispatch;
	}
	// 821C23A4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 821C23A8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821C23AC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C23B0: 419A0014  beq cr6, 0x821c23c4
	if ctx.cr[6].eq {
	pc = 0x821C23C4; continue 'dispatch;
	}
	// 821C23B4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821C23B8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C23BC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C23C0: 4800000C  b 0x821c23cc
	pc = 0x821C23CC; continue 'dispatch;
	// 821C23C4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821C23C8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821C23CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C23D0: 4199FFB8  bgt cr6, 0x821c2388
	if ctx.cr[6].gt {
	pc = 0x821C2388; continue 'dispatch;
	}
	// 821C23D4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C23D8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C23DC: 419A003C  beq cr6, 0x821c2418
	if ctx.cr[6].eq {
	pc = 0x821C2418; continue 'dispatch;
	}
	// 821C23E0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C23E4: 2F0B004E  cmpwi cr6, r11, 0x4e
	ctx.cr[6].compare_i32(ctx.r[11].s32, 78, &mut ctx.xer);
	// 821C23E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C23EC: 41990008  bgt cr6, 0x821c23f4
	if ctx.cr[6].gt {
	pc = 0x821C23F4; continue 'dispatch;
	}
	// 821C23F0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821C23F4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C23F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C23FC: 409A001C  bne cr6, 0x821c2418
	if !ctx.cr[6].eq {
	pc = 0x821C2418; continue 'dispatch;
	}
	// 821C2400: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C2404: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C2408: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821C240C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C2410: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2414: 48000018  b 0x821c242c
	pc = 0x821C242C; continue 'dispatch;
	// 821C2418: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821C241C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C2420: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2424: 48000008  b 0x821c242c
	pc = 0x821C242C; continue 'dispatch;
	// 821C2428: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 821C242C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821C2430: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C2434: 419A0018  beq cr6, 0x821c244c
	if ctx.cr[6].eq {
	pc = 0x821C244C; continue 'dispatch;
	}
	// 821C2438: C02B0014  lfs f1, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821C243C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821C2440: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 821C2444: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821C2448: 48AE7010  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 821C244C: 57CA37FE  rlwinm r10, r30, 6, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x03FFFFFFu64;
	// 821C2450: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821C2454: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C2458: 419A00E8  beq cr6, 0x821c2540
	if ctx.cr[6].eq {
	pc = 0x821C2540; continue 'dispatch;
	}
	// 821C245C: 817D008C  lwz r11, 0x8c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C2460: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C2464: 419A0020  beq cr6, 0x821c2484
	if ctx.cr[6].eq {
	pc = 0x821C2484; continue 'dispatch;
	}
	// 821C2468: 894B007A  lbz r10, 0x7a(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(122 as u32) ) } as u64;
	// 821C246C: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C2470: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821C2474: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821C2478: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C247C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2480: 480000C4  b 0x821c2544
	pc = 0x821C2544; continue 'dispatch;
	// 821C2484: 815D0048  lwz r10, 0x48(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C2488: 80DD004C  lwz r6, 0x4c(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 821C248C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821C2490: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821C2494: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C2498: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C249C: 40810054  ble 0x821c24f0
	if !ctx.cr[0].gt {
	pc = 0x821C24F0; continue 'dispatch;
	}
	// 821C24A0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821C24A4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C24A8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C24AC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C24B0: 2F07007A  cmpwi cr6, r7, 0x7a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 122, &mut ctx.xer);
	// 821C24B4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821C24B8: 41980008  blt cr6, 0x821c24c0
	if ctx.cr[6].lt {
	pc = 0x821C24C0; continue 'dispatch;
	}
	// 821C24BC: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 821C24C0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821C24C4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C24C8: 419A0014  beq cr6, 0x821c24dc
	if ctx.cr[6].eq {
	pc = 0x821C24DC; continue 'dispatch;
	}
	// 821C24CC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821C24D0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C24D4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C24D8: 4800000C  b 0x821c24e4
	pc = 0x821C24E4; continue 'dispatch;
	// 821C24DC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821C24E0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821C24E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C24E8: 4199FFB8  bgt cr6, 0x821c24a0
	if ctx.cr[6].gt {
	pc = 0x821C24A0; continue 'dispatch;
	}
	// 821C24EC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C24F0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C24F4: 419A003C  beq cr6, 0x821c2530
	if ctx.cr[6].eq {
	pc = 0x821C2530; continue 'dispatch;
	}
	// 821C24F8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C24FC: 2F0B007A  cmpwi cr6, r11, 0x7a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 122, &mut ctx.xer);
	// 821C2500: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C2504: 41990008  bgt cr6, 0x821c250c
	if ctx.cr[6].gt {
	pc = 0x821C250C; continue 'dispatch;
	}
	// 821C2508: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821C250C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C2510: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C2514: 409A001C  bne cr6, 0x821c2530
	if !ctx.cr[6].eq {
	pc = 0x821C2530; continue 'dispatch;
	}
	// 821C2518: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C251C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C2520: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821C2524: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C2528: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C252C: 48000018  b 0x821c2544
	pc = 0x821C2544; continue 'dispatch;
	// 821C2530: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821C2534: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C2538: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C253C: 48000008  b 0x821c2544
	pc = 0x821C2544; continue 'dispatch;
	// 821C2540: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 821C2544: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821C2548: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C254C: 419A0278  beq cr6, 0x821c27c4
	if ctx.cr[6].eq {
	pc = 0x821C27C4; continue 'dispatch;
	}
	// 821C2550: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821C2554: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821C2558: 3BEAB730  addi r31, r10, -0x48d0
	ctx.r[31].s64 = ctx.r[10].s64 + -18640;
	// 821C255C: C3FF148C  lfs f31, 0x148c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(5260 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821C2560: 480004B9  bl 0x821c2a18
	ctx.lr = 0x821C2564;
	sub_821C2A18(ctx, base);
	// 821C2564: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 821C2568: 41980130  blt cr6, 0x821c2698
	if ctx.cr[6].lt {
	pc = 0x821C2698; continue 'dispatch;
	}
	// 821C256C: 815D0024  lwz r10, 0x24(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 821C2570: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821C2574: 55497FFE  rlwinm r9, r10, 0xf, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0001FFFFu64;
	// 821C2578: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C257C: 419A00E8  beq cr6, 0x821c2664
	if ctx.cr[6].eq {
	pc = 0x821C2664; continue 'dispatch;
	}
	// 821C2580: 817D008C  lwz r11, 0x8c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C2584: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C2588: 419A0020  beq cr6, 0x821c25a8
	if ctx.cr[6].eq {
	pc = 0x821C25A8; continue 'dispatch;
	}
	// 821C258C: 894B0011  lbz r10, 0x11(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 821C2590: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C2594: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821C2598: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821C259C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C25A0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C25A4: 480000C4  b 0x821c2668
	pc = 0x821C2668; continue 'dispatch;
	// 821C25A8: 815D0048  lwz r10, 0x48(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C25AC: 80DD004C  lwz r6, 0x4c(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 821C25B0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821C25B4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821C25B8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C25BC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C25C0: 40810054  ble 0x821c2614
	if !ctx.cr[0].gt {
	pc = 0x821C2614; continue 'dispatch;
	}
	// 821C25C4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821C25C8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C25CC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C25D0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C25D4: 2F070011  cmpwi cr6, r7, 0x11
	ctx.cr[6].compare_i32(ctx.r[7].s32, 17, &mut ctx.xer);
	// 821C25D8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821C25DC: 41980008  blt cr6, 0x821c25e4
	if ctx.cr[6].lt {
	pc = 0x821C25E4; continue 'dispatch;
	}
	// 821C25E0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 821C25E4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821C25E8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C25EC: 419A0014  beq cr6, 0x821c2600
	if ctx.cr[6].eq {
	pc = 0x821C2600; continue 'dispatch;
	}
	// 821C25F0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821C25F4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C25F8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C25FC: 4800000C  b 0x821c2608
	pc = 0x821C2608; continue 'dispatch;
	// 821C2600: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821C2604: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821C2608: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C260C: 4199FFB8  bgt cr6, 0x821c25c4
	if ctx.cr[6].gt {
	pc = 0x821C25C4; continue 'dispatch;
	}
	// 821C2610: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C2614: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C2618: 419A003C  beq cr6, 0x821c2654
	if ctx.cr[6].eq {
	pc = 0x821C2654; continue 'dispatch;
	}
	// 821C261C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C2620: 2F0B0011  cmpwi cr6, r11, 0x11
	ctx.cr[6].compare_i32(ctx.r[11].s32, 17, &mut ctx.xer);
	// 821C2624: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C2628: 41990008  bgt cr6, 0x821c2630
	if ctx.cr[6].gt {
	pc = 0x821C2630; continue 'dispatch;
	}
	// 821C262C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821C2630: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C2634: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C2638: 409A001C  bne cr6, 0x821c2654
	if !ctx.cr[6].eq {
	pc = 0x821C2654; continue 'dispatch;
	}
	// 821C263C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C2640: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C2644: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821C2648: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C264C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2650: 48000018  b 0x821c2668
	pc = 0x821C2668; continue 'dispatch;
	// 821C2654: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821C2658: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C265C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2660: 48000008  b 0x821c2668
	pc = 0x821C2668; continue 'dispatch;
	// 821C2664: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 821C2668: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821C266C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C2670: 419A0024  beq cr6, 0x821c2694
	if ctx.cr[6].eq {
	pc = 0x821C2694; continue 'dispatch;
	}
	// 821C2674: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 821C2678: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821C267C: 480DC785  bl 0x8229ee00
	ctx.lr = 0x821C2680;
	sub_8229EE00(ctx, base);
	// 821C2680: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C2684: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C2688: 419A000C  beq cr6, 0x821c2694
	if ctx.cr[6].eq {
	pc = 0x821C2694; continue 'dispatch;
	}
	// 821C268C: C3FF3AB0  lfs f31, 0x3ab0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(15024 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821C2690: 48000008  b 0x821c2698
	pc = 0x821C2698; continue 'dispatch;
	// 821C2694: C3FF3AA8  lfs f31, 0x3aa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(15016 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821C2698: 57CA67FE  rlwinm r10, r30, 0xc, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x000FFFFFu64;
	// 821C269C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821C26A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C26A4: 419A00E8  beq cr6, 0x821c278c
	if ctx.cr[6].eq {
	pc = 0x821C278C; continue 'dispatch;
	}
	// 821C26A8: 817D008C  lwz r11, 0x8c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C26AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C26B0: 419A0020  beq cr6, 0x821c26d0
	if ctx.cr[6].eq {
	pc = 0x821C26D0; continue 'dispatch;
	}
	// 821C26B4: 894B0074  lbz r10, 0x74(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 821C26B8: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C26BC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821C26C0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821C26C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C26C8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C26CC: 480000C4  b 0x821c2790
	pc = 0x821C2790; continue 'dispatch;
	// 821C26D0: 815D0048  lwz r10, 0x48(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C26D4: 80DD004C  lwz r6, 0x4c(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 821C26D8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821C26DC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821C26E0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C26E4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C26E8: 40810054  ble 0x821c273c
	if !ctx.cr[0].gt {
	pc = 0x821C273C; continue 'dispatch;
	}
	// 821C26EC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821C26F0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C26F4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C26F8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C26FC: 2F070074  cmpwi cr6, r7, 0x74
	ctx.cr[6].compare_i32(ctx.r[7].s32, 116, &mut ctx.xer);
	// 821C2700: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821C2704: 41980008  blt cr6, 0x821c270c
	if ctx.cr[6].lt {
	pc = 0x821C270C; continue 'dispatch;
	}
	// 821C2708: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 821C270C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821C2710: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C2714: 419A0014  beq cr6, 0x821c2728
	if ctx.cr[6].eq {
	pc = 0x821C2728; continue 'dispatch;
	}
	// 821C2718: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821C271C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C2720: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C2724: 4800000C  b 0x821c2730
	pc = 0x821C2730; continue 'dispatch;
	// 821C2728: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821C272C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821C2730: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C2734: 4199FFB8  bgt cr6, 0x821c26ec
	if ctx.cr[6].gt {
	pc = 0x821C26EC; continue 'dispatch;
	}
	// 821C2738: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C273C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C2740: 419A003C  beq cr6, 0x821c277c
	if ctx.cr[6].eq {
	pc = 0x821C277C; continue 'dispatch;
	}
	// 821C2744: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C2748: 2F0B0074  cmpwi cr6, r11, 0x74
	ctx.cr[6].compare_i32(ctx.r[11].s32, 116, &mut ctx.xer);
	// 821C274C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C2750: 41990008  bgt cr6, 0x821c2758
	if ctx.cr[6].gt {
	pc = 0x821C2758; continue 'dispatch;
	}
	// 821C2754: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821C2758: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C275C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C2760: 409A001C  bne cr6, 0x821c277c
	if !ctx.cr[6].eq {
	pc = 0x821C277C; continue 'dispatch;
	}
	// 821C2764: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C2768: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C276C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821C2770: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C2774: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2778: 48000018  b 0x821c2790
	pc = 0x821C2790; continue 'dispatch;
	// 821C277C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821C2780: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C2784: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2788: 48000008  b 0x821c2790
	pc = 0x821C2790; continue 'dispatch;
	// 821C278C: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 821C2790: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821C2794: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C2798: 419A0018  beq cr6, 0x821c27b0
	if ctx.cr[6].eq {
	pc = 0x821C27B0; continue 'dispatch;
	}
	// 821C279C: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 821C27A0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821C27A4: 48117885  bl 0x822da028
	ctx.lr = 0x821C27A8;
	sub_822DA028(ctx, base);
	// 821C27A8: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C27AC: EFE1F83A  fmadds f31, f1, f0, f31
	ctx.f[31].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64);
	// 821C27B0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821C27B4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821C27B8: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 821C27BC: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821C27C0: 48AE6C98  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 821C27C4: 80DD0024  lwz r6, 0x24(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 821C27C8: 54CB4FFE  rlwinm r11, r6, 9, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x007FFFFFu64;
	// 821C27CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C27D0: 419A0078  beq cr6, 0x821c2848
	if ctx.cr[6].eq {
	pc = 0x821C2848; continue 'dispatch;
	}
	// 821C27D4: 817D008C  lwz r11, 0x8c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C27D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C27DC: 409A0064  bne cr6, 0x821c2840
	if !ctx.cr[6].eq {
	pc = 0x821C2840; continue 'dispatch;
	}
	// 821C27E0: 817D004C  lwz r11, 0x4c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 821C27E4: 815D0048  lwz r10, 0x48(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C27E8: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821C27EC: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C27F0: 40810050  ble 0x821c2840
	if !ctx.cr[0].gt {
	pc = 0x821C2840; continue 'dispatch;
	}
	// 821C27F4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821C27F8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C27FC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C2800: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C2804: 2F070017  cmpwi cr6, r7, 0x17
	ctx.cr[6].compare_i32(ctx.r[7].s32, 23, &mut ctx.xer);
	// 821C2808: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821C280C: 41980008  blt cr6, 0x821c2814
	if ctx.cr[6].lt {
	pc = 0x821C2814; continue 'dispatch;
	}
	// 821C2810: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 821C2814: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821C2818: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C281C: 419A0014  beq cr6, 0x821c2830
	if ctx.cr[6].eq {
	pc = 0x821C2830; continue 'dispatch;
	}
	// 821C2820: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821C2824: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C2828: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C282C: 4800000C  b 0x821c2838
	pc = 0x821C2838; continue 'dispatch;
	// 821C2830: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821C2834: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821C2838: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C283C: 4199FFB8  bgt cr6, 0x821c27f4
	if ctx.cr[6].gt {
	pc = 0x821C27F4; continue 'dispatch;
	}
	// 821C2840: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C2844: 48000008  b 0x821c284c
	pc = 0x821C284C; continue 'dispatch;
	// 821C2848: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821C284C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C2850: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C2854: 419A0010  beq cr6, 0x821c2864
	if ctx.cr[6].eq {
	pc = 0x821C2864; continue 'dispatch;
	}
	// 821C2858: 54CB67FE  rlwinm r11, r6, 0xc, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x000FFFFFu64;
	// 821C285C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C2860: 419AFAB8  beq cr6, 0x821c2318
	if ctx.cr[6].eq {
	pc = 0x821C2318; continue 'dispatch;
	}
	// 821C2864: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821C2868: 394BB730  addi r10, r11, -0x48d0
	ctx.r[10].s64 = ctx.r[11].s64 + -18640;
	// 821C286C: C02A148C  lfs f1, 0x148c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(5260 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821C2870: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821C2874: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 821C2878: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821C287C: 48AE6BDC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x821C2880 => {
    //   block [0x821C2880..0x821C289C)
	// 821C2880: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821C2884: 394BB730  addi r10, r11, -0x48d0
	ctx.r[10].s64 = ctx.r[11].s64 + -18640;
	// 821C2888: C02ADD54  lfs f1, -0x22ac(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8876 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821C288C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821C2890: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 821C2894: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821C2898: 48AE6BC0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C28A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C28A0 size=372
    let mut pc: u32 = 0x821C28A0;
    'dispatch: loop {
        match pc {
            0x821C28A0 => {
    //   block [0x821C28A0..0x821C28C8)
	// 821C28A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C28A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C28A8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C28AC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821C28B0: 419A0018  beq cr6, 0x821c28c8
	if ctx.cr[6].eq {
	pc = 0x821C28C8; continue 'dispatch;
	}
	// 821C28B4: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 821C28B8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821C28BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C28C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C28C4: 409A0008  bne cr6, 0x821c28cc
	if !ctx.cr[6].eq {
	pc = 0x821C28CC; continue 'dispatch;
	}
	pc = 0x821C28C8; continue 'dispatch;
            }
            0x821C28C8 => {
    //   block [0x821C28C8..0x821C28CC)
	// 821C28C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821C28CC; continue 'dispatch;
            }
            0x821C28CC => {
    //   block [0x821C28CC..0x821C2914)
	// 821C28CC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C28D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C28D4: 419A012C  beq cr6, 0x821c2a00
	if ctx.cr[6].eq {
	pc = 0x821C2A00; continue 'dispatch;
	}
	// 821C28D8: 81440030  lwz r10, 0x30(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 821C28DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C28E0: 554937FE  rlwinm r9, r10, 6, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x03FFFFFFu64;
	// 821C28E4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C28E8: 419A00E8  beq cr6, 0x821c29d0
	if ctx.cr[6].eq {
	pc = 0x821C29D0; continue 'dispatch;
	}
	// 821C28EC: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C28F0: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C28F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C28F8: 419A001C  beq cr6, 0x821c2914
	if ctx.cr[6].eq {
	pc = 0x821C2914; continue 'dispatch;
	}
	// 821C28FC: 896B007A  lbz r11, 0x7a(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(122 as u32) ) } as u64;
	// 821C2900: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821C2904: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821C2908: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C290C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C2910: 480000C4  b 0x821c29d4
	pc = 0x821C29D4; continue 'dispatch;
            }
            0x821C2914 => {
    //   block [0x821C2914..0x821C2930)
	// 821C2914: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 821C2918: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C291C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C2920: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821C2924: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821C2928: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C292C: 40810054  ble 0x821c2980
	if !ctx.cr[0].gt {
	pc = 0x821C2980; continue 'dispatch;
	}
	pc = 0x821C2930; continue 'dispatch;
            }
            0x821C2930 => {
    //   block [0x821C2930..0x821C2950)
	// 821C2930: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821C2934: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C2938: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C293C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C2940: 2F07007A  cmpwi cr6, r7, 0x7a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 122, &mut ctx.xer);
	// 821C2944: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821C2948: 41980008  blt cr6, 0x821c2950
	if ctx.cr[6].lt {
	pc = 0x821C2950; continue 'dispatch;
	}
	// 821C294C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x821C2950; continue 'dispatch;
            }
            0x821C2950 => {
    //   block [0x821C2950..0x821C296C)
	// 821C2950: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821C2954: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C2958: 419A0014  beq cr6, 0x821c296c
	if ctx.cr[6].eq {
	pc = 0x821C296C; continue 'dispatch;
	}
	// 821C295C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821C2960: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C2964: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C2968: 4800000C  b 0x821c2974
	pc = 0x821C2974; continue 'dispatch;
            }
            0x821C296C => {
    //   block [0x821C296C..0x821C2974)
	// 821C296C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821C2970: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821C2974; continue 'dispatch;
            }
            0x821C2974 => {
    //   block [0x821C2974..0x821C2980)
	// 821C2974: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C2978: 4199FFB8  bgt cr6, 0x821c2930
	if ctx.cr[6].gt {
	pc = 0x821C2930; continue 'dispatch;
	}
	// 821C297C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821C2980; continue 'dispatch;
            }
            0x821C2980 => {
    //   block [0x821C2980..0x821C299C)
	// 821C2980: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C2984: 419A003C  beq cr6, 0x821c29c0
	if ctx.cr[6].eq {
	pc = 0x821C29C0; continue 'dispatch;
	}
	// 821C2988: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C298C: 2F0B007A  cmpwi cr6, r11, 0x7a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 122, &mut ctx.xer);
	// 821C2990: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C2994: 41990008  bgt cr6, 0x821c299c
	if ctx.cr[6].gt {
	pc = 0x821C299C; continue 'dispatch;
	}
	// 821C2998: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821C299C; continue 'dispatch;
            }
            0x821C299C => {
    //   block [0x821C299C..0x821C29C0)
	// 821C299C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C29A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C29A4: 409A001C  bne cr6, 0x821c29c0
	if !ctx.cr[6].eq {
	pc = 0x821C29C0; continue 'dispatch;
	}
	// 821C29A8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C29AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C29B0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821C29B4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C29B8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C29BC: 48000018  b 0x821c29d4
	pc = 0x821C29D4; continue 'dispatch;
            }
            0x821C29C0 => {
    //   block [0x821C29C0..0x821C29D0)
	// 821C29C0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821C29C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C29C8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C29CC: 48000008  b 0x821c29d4
	pc = 0x821C29D4; continue 'dispatch;
            }
            0x821C29D0 => {
    //   block [0x821C29D0..0x821C29D4)
	// 821C29D0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821C29D4; continue 'dispatch;
            }
            0x821C29D4 => {
    //   block [0x821C29D4..0x821C2A00)
	// 821C29D4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821C29D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C29DC: 419A0024  beq cr6, 0x821c2a00
	if ctx.cr[6].eq {
	pc = 0x821C2A00; continue 'dispatch;
	}
	// 821C29E0: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C29E4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821C29E8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C29EC: 4E800421  bctrl
	ctx.lr = 0x821C29F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C29F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C29F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C29F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C29FC: 4E800020  blr
	return;
            }
            0x821C2A00 => {
    //   block [0x821C2A00..0x821C2A14)
	// 821C2A00: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821C2A04: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C2A08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C2A0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C2A10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C2A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821C2A18 size=32
    let mut pc: u32 = 0x821C2A18;
    'dispatch: loop {
        match pc {
            0x821C2A18 => {
    //   block [0x821C2A18..0x821C2A38)
	// 821C2A18: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821C2A1C: C003000C  lfs f0, 0xc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C2A20: 396B9490  addi r11, r11, -0x6b70
	ctx.r[11].s64 = ctx.r[11].s64 + -27504;
	// 821C2A24: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821C2A28: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821C2A2C: 4098000C  bge cr6, 0x821c2a38
	if !ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x821C2A38);
		return;
	}
	// 821C2A30: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821C2A34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C2A68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C2A68 size=700
    let mut pc: u32 = 0x821C2A68;
    'dispatch: loop {
        match pc {
            0x821C2A68 => {
    //   block [0x821C2A68..0x821C2AE0)
	// 821C2A68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C2A6C: 48AE6991  bl 0x82ca93fc
	ctx.lr = 0x821C2A70;
	sub_82CA93D0(ctx, base);
	// 821C2A70: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C2A74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C2A78: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 821C2A7C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 821C2A80: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 821C2A84: 933F0040  stw r25, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[25].u32 ) };
	// 821C2A88: 48852309  bl 0x82a14d90
	ctx.lr = 0x821C2A8C;
	sub_82A14D90(ctx, base);
	// 821C2A8C: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821C2A90: 3B80001C  li r28, 0x1c
	ctx.r[28].s64 = 28;
	// 821C2A94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C2A98: 409A01AC  bne cr6, 0x821c2c44
	if !ctx.cr[6].eq {
	pc = 0x821C2C44; continue 'dispatch;
	}
	// 821C2A9C: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C2AA0: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C2AA4: 811F0038  lwz r8, 0x38(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821C2AA8: 7CE95050  subf r7, r9, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821C2AAC: 7CC7E3D6  divw r6, r7, r28
	ctx.r[6].s32 = ctx.r[7].s32 / ctx.r[28].s32;
	// 821C2AB0: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C2AB4: 4198002C  blt cr6, 0x821c2ae0
	if ctx.cr[6].lt {
	pc = 0x821C2AE0; continue 'dispatch;
	}
	// 821C2AB8: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821C2ABC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821C2AC0: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 821C2AC4: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C2AC8: 932A0004  stw r25, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 821C2ACC: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C2AD0: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 821C2AD4: 913A0008  stw r9, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 821C2AD8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821C2ADC: 48AE6970  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821C2AE0 => {
    //   block [0x821C2AE0..0x821C2B18)
	// 821C2AE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C2AE4: 409A0160  bne cr6, 0x821c2c44
	if !ctx.cr[6].eq {
	pc = 0x821C2C44; continue 'dispatch;
	}
	// 821C2AE8: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821C2AEC: 3BBF000C  addi r29, r31, 0xc
	ctx.r[29].s64 = ctx.r[31].s64 + 12;
	// 821C2AF0: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C2AF4: 3BDF0038  addi r30, r31, 0x38
	ctx.r[30].s64 = ctx.r[31].s64 + 56;
	// 821C2AF8: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C2AFC: 1D0B001C  mulli r8, r11, 0x1c
	ctx.r[8].s32 = ((ctx.r[11].s32 as i64 * 28 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 821C2B00: 7D274B78  mr r7, r9
	ctx.r[7].u64 = ctx.r[9].u64;
	// 821C2B04: 7CC95050  subf r6, r9, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821C2B08: 7CA6E3D6  divw r5, r6, r28
	ctx.r[5].s32 = ctx.r[6].s32 / ctx.r[28].s32;
	// 821C2B0C: 7F68382E  lwzx r27, r8, r7
	ctx.r[27].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 821C2B10: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821C2B14: 40980060  bge cr6, 0x821c2b74
	if !ctx.cr[6].lt {
	pc = 0x821C2B74; continue 'dispatch;
	}
	pc = 0x821C2B18; continue 'dispatch;
            }
            0x821C2B18 => {
    //   block [0x821C2B18..0x821C2B74)
	// 821C2B18: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C2B1C: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C2B20: 1D2B001C  mulli r9, r11, 0x1c
	ctx.r[9].s32 = ((ctx.r[11].s32 as i64 * 28 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 821C2B24: 7D09502E  lwzx r8, r9, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821C2B28: 7F08D800  cmpw cr6, r8, r27
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[27].s32, &mut ctx.xer);
	// 821C2B2C: 409A0048  bne cr6, 0x821c2b74
	if !ctx.cr[6].eq {
	pc = 0x821C2B74; continue 'dispatch;
	}
	// 821C2B30: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 821C2B34: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821C2B38: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821C2B3C: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 821C2B40: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821C2B44: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C2B48: 488D4821  bl 0x82a97368
	ctx.lr = 0x821C2B4C;
	sub_82A97368(ctx, base);
	// 821C2B4C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C2B50: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 821C2B54: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821C2B58: 5549003E  slwi r9, r10, 0
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C2B5C: 811D0008  lwz r8, 8(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C2B60: 80FD0004  lwz r7, 4(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2B64: 7CC74050  subf r6, r7, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 821C2B68: 7CA6E3D6  divw r5, r6, r28
	ctx.r[5].s32 = ctx.r[6].s32 / ctx.r[28].s32;
	// 821C2B6C: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821C2B70: 4198FFA8  blt cr6, 0x821c2b18
	if ctx.cr[6].lt {
	pc = 0x821C2B18; continue 'dispatch;
	}
	pc = 0x821C2B74; continue 'dispatch;
            }
            0x821C2B74 => {
    //   block [0x821C2B74..0x821C2BA8)
	// 821C2B74: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821C2B78: 389F001C  addi r4, r31, 0x1c
	ctx.r[4].s64 = ctx.r[31].s64 + 28;
	// 821C2B7C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821C2B80: 90810058  stw r4, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u32 ) };
	// 821C2B84: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 821C2B88: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C2B8C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 821C2B90: E9010058  ld r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821C2B94: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821C2B98: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C2B9C: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 821C2BA0: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821C2BA4: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	pc = 0x821C2BA8; continue 'dispatch;
            }
            0x821C2BA8 => {
    //   block [0x821C2BA8..0x821C2BC8)
	// 821C2BA8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821C2BAC: 419A001C  beq cr6, 0x821c2bc8
	if ctx.cr[6].eq {
	pc = 0x821C2BC8; continue 'dispatch;
	}
	// 821C2BB0: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C2BB4: 811F0034  lwz r8, 0x34(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 821C2BB8: 7F094000  cmpw cr6, r9, r8
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[8].s32, &mut ctx.xer);
	// 821C2BBC: 419A000C  beq cr6, 0x821c2bc8
	if ctx.cr[6].eq {
	pc = 0x821C2BC8; continue 'dispatch;
	}
	// 821C2BC0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C2BC4: 4BFFFFE4  b 0x821c2ba8
	pc = 0x821C2BA8; continue 'dispatch;
            }
            0x821C2BC8 => {
    //   block [0x821C2BC8..0x821C2BD8)
	// 821C2BC8: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821C2BCC: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821C2BD0: 419A0008  beq cr6, 0x821c2bd8
	if ctx.cr[6].eq {
	pc = 0x821C2BD8; continue 'dispatch;
	}
	// 821C2BD4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C2BD8; continue 'dispatch;
            }
            0x821C2BD8 => {
    //   block [0x821C2BD8..0x821C2BF4)
	// 821C2BD8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821C2BDC: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2BE0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821C2BE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C2BE8: 419A000C  beq cr6, 0x821c2bf4
	if ctx.cr[6].eq {
	pc = 0x821C2BF4; continue 'dispatch;
	}
	// 821C2BEC: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821C2BF0: 419A0008  beq cr6, 0x821c2bf8
	if ctx.cr[6].eq {
	pc = 0x821C2BF8; continue 'dispatch;
	}
	pc = 0x821C2BF4; continue 'dispatch;
            }
            0x821C2BF4 => {
    //   block [0x821C2BF4..0x821C2BF8)
	// 821C2BF4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C2BF8; continue 'dispatch;
            }
            0x821C2BF8 => {
    //   block [0x821C2BF8..0x821C2C0C)
	// 821C2BF8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821C2BFC: 419A0048  beq cr6, 0x821c2c44
	if ctx.cr[6].eq {
	pc = 0x821C2C44; continue 'dispatch;
	}
	// 821C2C00: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C2C04: 409A0008  bne cr6, 0x821c2c0c
	if !ctx.cr[6].eq {
	pc = 0x821C2C0C; continue 'dispatch;
	}
	// 821C2C08: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C2C0C; continue 'dispatch;
            }
            0x821C2C0C => {
    //   block [0x821C2C0C..0x821C2C1C)
	// 821C2C0C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2C10: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821C2C14: 409A0008  bne cr6, 0x821c2c1c
	if !ctx.cr[6].eq {
	pc = 0x821C2C1C; continue 'dispatch;
	}
	// 821C2C18: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C2C1C; continue 'dispatch;
            }
            0x821C2C1C => {
    //   block [0x821C2C1C..0x821C2C44)
	// 821C2C1C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C2C20: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821C2C24: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C2C28: 3BCB0001  addi r30, r11, 1
	ctx.r[30].s64 = ctx.r[11].s64 + 1;
	// 821C2C2C: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 821C2C30: 480172B9  bl 0x821d9ee8
	ctx.lr = 0x821C2C34;
	sub_821D9EE8(ctx, base);
	// 821C2C34: 7FCB07B4  extsw r11, r30
	ctx.r[11].s64 = ctx.r[30].s32 as i64;
	// 821C2C38: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821C2C3C: C8010060  lfd f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821C2C40: 480000B4  b 0x821c2cf4
	pc = 0x821C2CF4; continue 'dispatch;
            }
            0x821C2C44 => {
    //   block [0x821C2C44..0x821C2C88)
	// 821C2C44: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821C2C48: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821C2C4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C2C50: 814A6AB8  lwz r10, 0x6ab8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821C2C54: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C2C58: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 821C2C5C: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2C60: 80E90078  lwz r7, 0x78(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(120 as u32) ) } as u64;
	// 821C2C64: 1D4724A1  mulli r10, r7, 0x24a1
	ctx.r[10].s32 = ((ctx.r[7].s32 as i64 * 9377 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821C2C68: 38CA24DF  addi r6, r10, 0x24df
	ctx.r[6].s64 = ctx.r[10].s64 + 9439;
	// 821C2C6C: 54CA983E  rotlwi r10, r6, 0x13
	ctx.r[10].u64 = ((ctx.r[6].u32).rotate_left(19)) as u64;
	// 821C2C70: 91490078  stw r10, 0x78(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 821C2C74: 419A0014  beq cr6, 0x821c2c88
	if ctx.cr[6].eq {
	pc = 0x821C2C88; continue 'dispatch;
	}
	// 821C2C78: 7D2A5B96  divwu r9, r10, r11
	ctx.r[9].u32 = ctx.r[10].u32 / ctx.r[11].u32;
	// 821C2C7C: 7D0959D6  mullw r8, r9, r11
	ctx.r[8].s32 = ((ctx.r[9].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 821C2C80: 7C885050  subf r4, r8, r10
	ctx.r[4].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821C2C84: 48000008  b 0x821c2c8c
	pc = 0x821C2C8C; continue 'dispatch;
            }
            0x821C2C88 => {
    //   block [0x821C2C88..0x821C2C8C)
	// 821C2C88: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	pc = 0x821C2C8C; continue 'dispatch;
            }
            0x821C2C8C => {
    //   block [0x821C2C8C..0x821C2CB8)
	// 821C2C8C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821C2C90: 3BDF001C  addi r30, r31, 0x1c
	ctx.r[30].s64 = ctx.r[31].s64 + 28;
	// 821C2C94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C2C98: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821C2C9C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C2CA0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C2CA4: 486CF5B5  bl 0x82892258
	ctx.lr = 0x821C2CA8;
	sub_82892258(ctx, base);
	// 821C2CA8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821C2CAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C2CB0: 409A0008  bne cr6, 0x821c2cb8
	if !ctx.cr[6].eq {
	pc = 0x821C2CB8; continue 'dispatch;
	}
	// 821C2CB4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C2CB8; continue 'dispatch;
            }
            0x821C2CB8 => {
    //   block [0x821C2CB8..0x821C2CCC)
	// 821C2CB8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2CBC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C2CC0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821C2CC4: 409A0008  bne cr6, 0x821c2ccc
	if !ctx.cr[6].eq {
	pc = 0x821C2CCC; continue 'dispatch;
	}
	// 821C2CC8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C2CCC; continue 'dispatch;
            }
            0x821C2CCC => {
    //   block [0x821C2CCC..0x821C2CF4)
	// 821C2CCC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C2CD0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821C2CD4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821C2CD8: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C2CDC: 3BCB0001  addi r30, r11, 1
	ctx.r[30].s64 = ctx.r[11].s64 + 1;
	// 821C2CE0: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 821C2CE4: 48017205  bl 0x821d9ee8
	ctx.lr = 0x821C2CE8;
	sub_821D9EE8(ctx, base);
	// 821C2CE8: 7FCB07B4  extsw r11, r30
	ctx.r[11].s64 = ctx.r[30].s32 as i64;
	// 821C2CEC: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821C2CF0: C8010060  lfd f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	pc = 0x821C2CF4; continue 'dispatch;
            }
            0x821C2CF4 => {
    //   block [0x821C2CF4..0x821C2D24)
	// 821C2CF4: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 821C2CF8: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C2CFC: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 821C2D00: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821C2D04: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821C2D08: D1890000  stfs f12, 0(r9)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821C2D0C: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821C2D10: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C2D14: 390B0008  addi r8, r11, 8
	ctx.r[8].s64 = ctx.r[11].s64 + 8;
	// 821C2D18: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 821C2D1C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821C2D20: 48AE672C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C2D28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C2D28 size=68
    let mut pc: u32 = 0x821C2D28;
    'dispatch: loop {
        match pc {
            0x821C2D28 => {
    //   block [0x821C2D28..0x821C2D6C)
	// 821C2D28: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C2D2C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821C2D30: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821C2D34: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C2D38: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821C2D3C: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2D40: 810A0078  lwz r8, 0x78(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(120 as u32) ) } as u64;
	// 821C2D44: 1D6824A1  mulli r11, r8, 0x24a1
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * 9377 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821C2D48: 38EB24DF  addi r7, r11, 0x24df
	ctx.r[7].s64 = ctx.r[11].s64 + 9439;
	// 821C2D4C: 54EB983E  rotlwi r11, r7, 0x13
	ctx.r[11].u64 = ((ctx.r[7].u32).rotate_left(19)) as u64;
	// 821C2D50: 916A0078  stw r11, 0x78(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 821C2D54: 419A0018  beq cr6, 0x821c2d6c
	if ctx.cr[6].eq {
		sub_821C2D6C(ctx, base);
		return;
	}
	// 821C2D58: 7D4B2396  divwu r10, r11, r4
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[4].u32;
	// 821C2D5C: 7D2A21D6  mullw r9, r10, r4
	ctx.r[9].s32 = ((ctx.r[10].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 821C2D60: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821C2D64: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 821C2D68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C2D6C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C2D6C size=12
    let mut pc: u32 = 0x821C2D6C;
    'dispatch: loop {
        match pc {
            0x821C2D6C => {
    //   block [0x821C2D6C..0x821C2D78)
	// 821C2D6C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C2D70: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 821C2D74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C2D78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C2D78 size=284
    let mut pc: u32 = 0x821C2D78;
    'dispatch: loop {
        match pc {
            0x821C2D78 => {
    //   block [0x821C2D78..0x821C2E58)
	// 821C2D78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C2D7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C2D80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821C2D84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C2D88: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C2D8C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821C2D90: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821C2D94: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C2D98: 556A05AC  rlwinm r10, r11, 0, 0x16, 0x16
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821C2D9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C2DA0: 419A00B8  beq cr6, 0x821c2e58
	if ctx.cr[6].eq {
	pc = 0x821C2E58; continue 'dispatch;
	}
	// 821C2DA4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821C2DA8: 4801BDA1  bl 0x821deb48
	ctx.lr = 0x821C2DAC;
	sub_821DEB48(ctx, base);
	// 821C2DAC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821C2DB0: C1810068  lfs f12, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821C2DB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C2DB8: 394B92D4  addi r10, r11, -0x6d2c
	ctx.r[10].s64 = ctx.r[11].s64 + -27948;
	// 821C2DBC: C1410064  lfs f10, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821C2DC0: C12B92D4  lfs f9, -0x6d2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821C2DC4: C00A01B0  lfs f0, 0x1b0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(432 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C2DC8: EDA00272  fmuls f13, f0, f9
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[9].f64) as f32) as f64);
	// 821C2DCC: ED0D502A  fadds f8, f13, f10
	ctx.f[8].f64 = ((ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64;
	// 821C2DD0: D1010054  stfs f8, 0x54(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821C2DD4: C0010060  lfs f0, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C2DD8: ED6C0028  fsubs f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 821C2DDC: ECEB0272  fmuls f7, f11, f9
	ctx.f[7].f64 = (((ctx.f[11].f64 * ctx.f[9].f64) as f32) as f64);
	// 821C2DE0: ECC7002A  fadds f6, f7, f0
	ctx.f[6].f64 = ((ctx.f[7].f64 + ctx.f[0].f64) as f32) as f64;
	// 821C2DE4: 4BFE7975  bl 0x821aa758
	ctx.lr = 0x821C2DE8;
	sub_821AA758(ctx, base);
	// 821C2DE8: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 821C2DEC: D101006C  stfs f8, 0x6c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821C2DF0: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 821C2DF4: 80DF0048  lwz r6, 0x48(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C2DF8: 38E9A63C  addi r7, r9, -0x59c4
	ctx.r[7].s64 = ctx.r[9].s64 + -22980;
	// 821C2DFC: 54C505EA  rlwinm r5, r6, 0, 0x17, 0x15
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 821C2E00: C009A63C  lfs f0, -0x59c4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-22980 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C2E04: ECA10032  fmuls f5, f1, f0
	ctx.f[5].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 821C2E08: C1A70004  lfs f13, 4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821C2E0C: 90BF0048  stw r5, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[5].u32 ) };
	// 821C2E10: EC05327A  fmadds f0, f5, f9, f6
	ctx.f[0].f64 = (((ctx.f[5].f64 * ctx.f[9].f64 + ctx.f[6].f64) as f32) as f64);
	// 821C2E14: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821C2E18: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C2E1C: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821C2E20: F8810050  std r4, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u64 ) };
	// 821C2E24: C0810054  lfs f4, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 821C2E28: EC602828  fsubs f3, f0, f5
	ctx.f[3].f64 = (((ctx.f[0].f64 - ctx.f[5].f64) as f32) as f64);
	// 821C2E2C: EC41237C  fnmsubs f2, f1, f13, f4
	ctx.f[2].f64 = -(((ctx.f[1].f64 * ctx.f[13].f64 - ctx.f[4].f64) as f32) as f64);
	// 821C2E30: D0610060  stfs f3, 0x60(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821C2E34: D0410064  stfs f2, 0x64(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821C2E38: 8168000C  lwz r11, 0xc(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C2E3C: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C2E40: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2E44: 80680008  lwz r3, 8(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C2E48: 907F0134  stw r3, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[3].u32 ) };
	// 821C2E4C: 913F0130  stw r9, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[9].u32 ) };
	// 821C2E50: 915F012C  stw r10, 0x12c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[10].u32 ) };
	// 821C2E54: 917F0138  stw r11, 0x138(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[11].u32 ) };
	pc = 0x821C2E58; continue 'dispatch;
            }
            0x821C2E58 => {
    //   block [0x821C2E58..0x821C2E94)
	// 821C2E58: C01F012C  lfs f0, 0x12c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C2E5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C2E60: C1BF0130  lfs f13, 0x130(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821C2E64: C19F0134  lfs f12, 0x134(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821C2E68: C17F0138  lfs f11, 0x138(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821C2E6C: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821C2E70: D1BE0004  stfs f13, 4(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821C2E74: D19E0008  stfs f12, 8(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821C2E78: D17E000C  stfs f11, 0xc(r30)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821C2E7C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821C2E80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C2E84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C2E88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821C2E8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C2E90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C2E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C2E98 size=196
    let mut pc: u32 = 0x821C2E98;
    'dispatch: loop {
        match pc {
            0x821C2E98 => {
    //   block [0x821C2E98..0x821C2EE8)
	// 821C2E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C2E9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C2EA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C2EA4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C2EA8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C2EAC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821C2EB0: 409A0088  bne cr6, 0x821c2f38
	if !ctx.cr[6].eq {
	pc = 0x821C2F38; continue 'dispatch;
	}
	// 821C2EB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C2EB8: 480DEAE1  bl 0x822a1998
	ctx.lr = 0x821C2EBC;
	sub_822A1998(ctx, base);
	// 821C2EBC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821C2EC0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821C2EC4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C2EC8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821C2ECC: 4805BC25  bl 0x8221eaf0
	ctx.lr = 0x821C2ED0;
	sub_8221EAF0(ctx, base);
	// 821C2ED0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821C2ED4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C2ED8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C2EDC: 419A0044  beq cr6, 0x821c2f20
	if ctx.cr[6].eq {
	pc = 0x821C2F20; continue 'dispatch;
	}
	// 821C2EE0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821C2EE4: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x821C2EE8; continue 'dispatch;
            }
            0x821C2EE8 => {
    //   block [0x821C2EE8..0x821C2F20)
	// 821C2EE8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821C2EEC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821C2EF0: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821C2EF4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821C2EF8: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821C2EFC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821C2F00: 4082FFE8  bne 0x821c2ee8
	if !ctx.cr[0].eq {
	pc = 0x821C2EE8; continue 'dispatch;
	}
	// 821C2F04: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821C2F08: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C2F0C: 409A0014  bne cr6, 0x821c2f20
	if !ctx.cr[6].eq {
	pc = 0x821C2F20; continue 'dispatch;
	}
	// 821C2F10: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C2F14: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2F18: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C2F1C: 4E800421  bctrl
	ctx.lr = 0x821C2F20;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821C2F20 => {
    //   block [0x821C2F20..0x821C2F38)
	// 821C2F20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C2F24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821C2F28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C2F2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C2F30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C2F34: 4E800020  blr
	return;
            }
            0x821C2F38 => {
    //   block [0x821C2F38..0x821C2F5C)
	// 821C2F38: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821C2F3C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821C2F40: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821C2F44: 4805BBAD  bl 0x8221eaf0
	ctx.lr = 0x821C2F48;
	sub_8221EAF0(ctx, base);
	// 821C2F48: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821C2F4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C2F50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C2F54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C2F58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C2F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C2F60 size=396
    let mut pc: u32 = 0x821C2F60;
    'dispatch: loop {
        match pc {
            0x821C2F60 => {
    //   block [0x821C2F60..0x821C2F8C)
	// 821C2F60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C2F64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C2F68: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C2F6C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821C2F70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C2F74: 419A0018  beq cr6, 0x821c2f8c
	if ctx.cr[6].eq {
	pc = 0x821C2F8C; continue 'dispatch;
	}
	// 821C2F78: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 821C2F7C: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821C2F80: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C2F84: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C2F88: 409A0008  bne cr6, 0x821c2f90
	if !ctx.cr[6].eq {
	pc = 0x821C2F90; continue 'dispatch;
	}
	pc = 0x821C2F8C; continue 'dispatch;
            }
            0x821C2F8C => {
    //   block [0x821C2F8C..0x821C2F90)
	// 821C2F8C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821C2F90; continue 'dispatch;
            }
            0x821C2F90 => {
    //   block [0x821C2F90..0x821C2FDC)
	// 821C2F90: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821C2F94: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C2F98: 419A0140  beq cr6, 0x821c30d8
	if ctx.cr[6].eq {
	pc = 0x821C30D8; continue 'dispatch;
	}
	// 821C2F9C: 812B0034  lwz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821C2FA0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821C2FA4: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 821C2FA8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821C2FAC: 419A00F8  beq cr6, 0x821c30a4
	if ctx.cr[6].eq {
	pc = 0x821C30A4; continue 'dispatch;
	}
	// 821C2FB0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C2FB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C2FB8: 419A0024  beq cr6, 0x821c2fdc
	if ctx.cr[6].eq {
	pc = 0x821C2FDC; continue 'dispatch;
	}
	// 821C2FBC: 892A0085  lbz r9, 0x85(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(133 as u32) ) } as u64;
	// 821C2FC0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C2FC4: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 821C2FC8: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821C2FCC: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C2FD0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821C2FD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C2FD8: 480000D0  b 0x821c30a8
	pc = 0x821C30A8; continue 'dispatch;
            }
            0x821C2FDC => {
    //   block [0x821C2FDC..0x821C2FFC)
	// 821C2FDC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C2FE0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821C2FE4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821C2FE8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 821C2FEC: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821C2FF0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C2FF4: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C2FF8: 40810054  ble 0x821c304c
	if !ctx.cr[0].gt {
	pc = 0x821C304C; continue 'dispatch;
	}
	pc = 0x821C2FFC; continue 'dispatch;
            }
            0x821C2FFC => {
    //   block [0x821C2FFC..0x821C301C)
	// 821C2FFC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821C3000: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C3004: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C3008: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C300C: 2F070085  cmpwi cr6, r7, 0x85
	ctx.cr[6].compare_i32(ctx.r[7].s32, 133, &mut ctx.xer);
	// 821C3010: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821C3014: 41980008  blt cr6, 0x821c301c
	if ctx.cr[6].lt {
	pc = 0x821C301C; continue 'dispatch;
	}
	// 821C3018: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x821C301C; continue 'dispatch;
            }
            0x821C301C => {
    //   block [0x821C301C..0x821C3038)
	// 821C301C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821C3020: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C3024: 419A0014  beq cr6, 0x821c3038
	if ctx.cr[6].eq {
	pc = 0x821C3038; continue 'dispatch;
	}
	// 821C3028: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821C302C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C3030: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C3034: 4800000C  b 0x821c3040
	pc = 0x821C3040; continue 'dispatch;
            }
            0x821C3038 => {
    //   block [0x821C3038..0x821C3040)
	// 821C3038: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821C303C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821C3040; continue 'dispatch;
            }
            0x821C3040 => {
    //   block [0x821C3040..0x821C304C)
	// 821C3040: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C3044: 4199FFB8  bgt cr6, 0x821c2ffc
	if ctx.cr[6].gt {
	pc = 0x821C2FFC; continue 'dispatch;
	}
	// 821C3048: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821C304C; continue 'dispatch;
            }
            0x821C304C => {
    //   block [0x821C304C..0x821C3068)
	// 821C304C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C3050: 419A0040  beq cr6, 0x821c3090
	if ctx.cr[6].eq {
	pc = 0x821C3090; continue 'dispatch;
	}
	// 821C3054: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C3058: 2F0B0085  cmpwi cr6, r11, 0x85
	ctx.cr[6].compare_i32(ctx.r[11].s32, 133, &mut ctx.xer);
	// 821C305C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C3060: 41990008  bgt cr6, 0x821c3068
	if ctx.cr[6].gt {
	pc = 0x821C3068; continue 'dispatch;
	}
	// 821C3064: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821C3068; continue 'dispatch;
            }
            0x821C3068 => {
    //   block [0x821C3068..0x821C3090)
	// 821C3068: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C306C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C3070: 409A0020  bne cr6, 0x821c3090
	if !ctx.cr[6].eq {
	pc = 0x821C3090; continue 'dispatch;
	}
	// 821C3074: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C3078: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821C307C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C3080: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3084: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821C3088: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C308C: 4800001C  b 0x821c30a8
	pc = 0x821C30A8; continue 'dispatch;
            }
            0x821C3090 => {
    //   block [0x821C3090..0x821C30A4)
	// 821C3090: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821C3094: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3098: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821C309C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C30A0: 48000008  b 0x821c30a8
	pc = 0x821C30A8; continue 'dispatch;
            }
            0x821C30A4 => {
    //   block [0x821C30A4..0x821C30A8)
	// 821C30A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821C30A8; continue 'dispatch;
            }
            0x821C30A8 => {
    //   block [0x821C30A8..0x821C30D8)
	// 821C30A8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C30AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C30B0: 419A0028  beq cr6, 0x821c30d8
	if ctx.cr[6].eq {
	pc = 0x821C30D8; continue 'dispatch;
	}
	// 821C30B4: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C30B8: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 821C30BC: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 821C30C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821C30C4: 4E800421  bctrl
	ctx.lr = 0x821C30C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C30C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C30CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C30D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C30D4: 4E800020  blr
	return;
            }
            0x821C30D8 => {
    //   block [0x821C30D8..0x821C30EC)
	// 821C30D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821C30DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C30E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C30E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C30E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C30F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C30F0 size=44
    let mut pc: u32 = 0x821C30F0;
    'dispatch: loop {
        match pc {
            0x821C30F0 => {
    //   block [0x821C30F0..0x821C311C)
	// 821C30F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C30F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C30F8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C30FC: 48040E9D  bl 0x82203f98
	ctx.lr = 0x821C3100;
	sub_82203F98(ctx, base);
	// 821C3100: 3963FFFE  addi r11, r3, -2
	ctx.r[11].s64 = ctx.r[3].s64 + -2;
	// 821C3104: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821C3108: 5543DFFE  rlwinm r3, r10, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 821C310C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C3110: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C3114: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C3118: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C3120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C3120 size=252
    let mut pc: u32 = 0x821C3120;
    'dispatch: loop {
        match pc {
            0x821C3120 => {
    //   block [0x821C3120..0x821C3154)
	// 821C3120: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C3124: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C3128: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C312C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C3130: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C3134: 897F0034  lbz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 821C3138: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C313C: 409A0030  bne cr6, 0x821c316c
	if !ctx.cr[6].eq {
	pc = 0x821C316C; continue 'dispatch;
	}
	// 821C3140: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821C3144: C1BF0030  lfs f13, 0x30(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821C3148: C00B9484  lfs f0, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C314C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821C3150: 4098001C  bge cr6, 0x821c316c
	if !ctx.cr[6].lt {
	pc = 0x821C316C; continue 'dispatch;
	}
	pc = 0x821C3154; continue 'dispatch;
            }
            0x821C3154 => {
    //   block [0x821C3154..0x821C316C)
	// 821C3154: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821C3158: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821C315C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C3160: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C3164: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C3168: 4E800020  blr
	return;
            }
            0x821C316C => {
    //   block [0x821C316C..0x821C31B8)
	// 821C316C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C3170: 2F0B001F  cmpwi cr6, r11, 0x1f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 31, &mut ctx.xer);
	// 821C3174: 409A0054  bne cr6, 0x821c31c8
	if !ctx.cr[6].eq {
	pc = 0x821C31C8; continue 'dispatch;
	}
	// 821C3178: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C317C: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 821C3180: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C3184: 419A0034  beq cr6, 0x821c31b8
	if ctx.cr[6].eq {
	pc = 0x821C31B8; continue 'dispatch;
	}
	// 821C3188: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C318C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C3190: 419A0084  beq cr6, 0x821c3214
	if ctx.cr[6].eq {
	pc = 0x821C3214; continue 'dispatch;
	}
	// 821C3194: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C3198: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C319C: 419A001C  beq cr6, 0x821c31b8
	if ctx.cr[6].eq {
	pc = 0x821C31B8; continue 'dispatch;
	}
	// 821C31A0: 4BFB0C99  bl 0x82173e38
	ctx.lr = 0x821C31A4;
	sub_82173E38(ctx, base);
	// 821C31A4: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 821C31A8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821C31AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C31B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C31B4: 409A0008  bne cr6, 0x821c31bc
	if !ctx.cr[6].eq {
	pc = 0x821C31BC; continue 'dispatch;
	}
	pc = 0x821C31B8; continue 'dispatch;
            }
            0x821C31B8 => {
    //   block [0x821C31B8..0x821C31BC)
	// 821C31B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821C31BC; continue 'dispatch;
            }
            0x821C31BC => {
    //   block [0x821C31BC..0x821C31C8)
	// 821C31BC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C31C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C31C4: 419AFF90  beq cr6, 0x821c3154
	if ctx.cr[6].eq {
	pc = 0x821C3154; continue 'dispatch;
	}
	pc = 0x821C31C8; continue 'dispatch;
            }
            0x821C31C8 => {
    //   block [0x821C31C8..0x821C3214)
	// 821C31C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821C31CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C31D0: 4801BBD1  bl 0x821deda0
	ctx.lr = 0x821C31D4;
	sub_821DEDA0(ctx, base);
	pc = 0x821C3214; continue 'dispatch;
            }
            0x821C3214 => {
    //   block [0x821C3214..0x821C321C)
	// 821C3214: 4BFD0C25  bl 0x82193e38
	ctx.lr = 0x821C3218;
	sub_82193E38(ctx, base);
	// 821C3218: 4BFFFFA0  b 0x821c31b8
	pc = 0x821C31B8; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C3220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C3220 size=400
    let mut pc: u32 = 0x821C3220;
    'dispatch: loop {
        match pc {
            0x821C3220 => {
    //   block [0x821C3220..0x821C324C)
	// 821C3220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C3224: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C3228: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C322C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821C3230: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C3234: 419A0018  beq cr6, 0x821c324c
	if ctx.cr[6].eq {
	pc = 0x821C324C; continue 'dispatch;
	}
	// 821C3238: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 821C323C: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821C3240: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C3244: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C3248: 409A0008  bne cr6, 0x821c3250
	if !ctx.cr[6].eq {
	pc = 0x821C3250; continue 'dispatch;
	}
	pc = 0x821C324C; continue 'dispatch;
            }
            0x821C324C => {
    //   block [0x821C324C..0x821C3250)
	// 821C324C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821C3250; continue 'dispatch;
            }
            0x821C3250 => {
    //   block [0x821C3250..0x821C329C)
	// 821C3250: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821C3254: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C3258: 419A0144  beq cr6, 0x821c339c
	if ctx.cr[6].eq {
	pc = 0x821C339C; continue 'dispatch;
	}
	// 821C325C: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821C3260: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821C3264: 5528F7FE  rlwinm r8, r9, 0x1e, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 821C3268: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821C326C: 419A00F8  beq cr6, 0x821c3364
	if ctx.cr[6].eq {
	pc = 0x821C3364; continue 'dispatch;
	}
	// 821C3270: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C3274: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C3278: 419A0024  beq cr6, 0x821c329c
	if ctx.cr[6].eq {
	pc = 0x821C329C; continue 'dispatch;
	}
	// 821C327C: 892A0022  lbz r9, 0x22(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(34 as u32) ) } as u64;
	// 821C3280: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C3284: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 821C3288: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821C328C: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3290: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821C3294: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C3298: 480000D0  b 0x821c3368
	pc = 0x821C3368; continue 'dispatch;
            }
            0x821C329C => {
    //   block [0x821C329C..0x821C32BC)
	// 821C329C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C32A0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821C32A4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821C32A8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 821C32AC: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821C32B0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C32B4: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C32B8: 40810054  ble 0x821c330c
	if !ctx.cr[0].gt {
	pc = 0x821C330C; continue 'dispatch;
	}
	pc = 0x821C32BC; continue 'dispatch;
            }
            0x821C32BC => {
    //   block [0x821C32BC..0x821C32DC)
	// 821C32BC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821C32C0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C32C4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C32C8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C32CC: 2F070022  cmpwi cr6, r7, 0x22
	ctx.cr[6].compare_i32(ctx.r[7].s32, 34, &mut ctx.xer);
	// 821C32D0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821C32D4: 41980008  blt cr6, 0x821c32dc
	if ctx.cr[6].lt {
	pc = 0x821C32DC; continue 'dispatch;
	}
	// 821C32D8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x821C32DC; continue 'dispatch;
            }
            0x821C32DC => {
    //   block [0x821C32DC..0x821C32F8)
	// 821C32DC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821C32E0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C32E4: 419A0014  beq cr6, 0x821c32f8
	if ctx.cr[6].eq {
	pc = 0x821C32F8; continue 'dispatch;
	}
	// 821C32E8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821C32EC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C32F0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C32F4: 4800000C  b 0x821c3300
	pc = 0x821C3300; continue 'dispatch;
            }
            0x821C32F8 => {
    //   block [0x821C32F8..0x821C3300)
	// 821C32F8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821C32FC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821C3300; continue 'dispatch;
            }
            0x821C3300 => {
    //   block [0x821C3300..0x821C330C)
	// 821C3300: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C3304: 4199FFB8  bgt cr6, 0x821c32bc
	if ctx.cr[6].gt {
	pc = 0x821C32BC; continue 'dispatch;
	}
	// 821C3308: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821C330C; continue 'dispatch;
            }
            0x821C330C => {
    //   block [0x821C330C..0x821C3328)
	// 821C330C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C3310: 419A0040  beq cr6, 0x821c3350
	if ctx.cr[6].eq {
	pc = 0x821C3350; continue 'dispatch;
	}
	// 821C3314: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C3318: 2F0B0022  cmpwi cr6, r11, 0x22
	ctx.cr[6].compare_i32(ctx.r[11].s32, 34, &mut ctx.xer);
	// 821C331C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C3320: 41990008  bgt cr6, 0x821c3328
	if ctx.cr[6].gt {
	pc = 0x821C3328; continue 'dispatch;
	}
	// 821C3324: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821C3328; continue 'dispatch;
            }
            0x821C3328 => {
    //   block [0x821C3328..0x821C3350)
	// 821C3328: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C332C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C3330: 409A0020  bne cr6, 0x821c3350
	if !ctx.cr[6].eq {
	pc = 0x821C3350; continue 'dispatch;
	}
	// 821C3334: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C3338: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821C333C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C3340: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3344: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821C3348: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C334C: 4800001C  b 0x821c3368
	pc = 0x821C3368; continue 'dispatch;
            }
            0x821C3350 => {
    //   block [0x821C3350..0x821C3364)
	// 821C3350: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821C3354: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3358: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821C335C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C3360: 48000008  b 0x821c3368
	pc = 0x821C3368; continue 'dispatch;
            }
            0x821C3364 => {
    //   block [0x821C3364..0x821C3368)
	// 821C3364: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821C3368; continue 'dispatch;
            }
            0x821C3368 => {
    //   block [0x821C3368..0x821C339C)
	// 821C3368: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C336C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C3370: 419A002C  beq cr6, 0x821c339c
	if ctx.cr[6].eq {
	pc = 0x821C339C; continue 'dispatch;
	}
	// 821C3374: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C3378: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 821C337C: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C3380: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821C3384: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821C3388: 4E800421  bctrl
	ctx.lr = 0x821C338C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C338C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C3390: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C3394: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C3398: 4E800020  blr
	return;
            }
            0x821C339C => {
    //   block [0x821C339C..0x821C33B0)
	// 821C339C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821C33A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C33A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C33A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C33AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C33B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C33B0 size=516
    let mut pc: u32 = 0x821C33B0;
    'dispatch: loop {
        match pc {
            0x821C33B0 => {
    //   block [0x821C33B0..0x821C3408)
	// 821C33B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C33B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C33B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821C33BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C33C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C33C4: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C33C8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821C33CC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821C33D0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 821C33D4: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 821C33D8: 556ADFFE  rlwinm r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821C33DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C33E0: 419A00D8  beq cr6, 0x821c34b8
	if ctx.cr[6].eq {
	pc = 0x821C34B8; continue 'dispatch;
	}
	// 821C33E4: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C33E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C33EC: 419A001C  beq cr6, 0x821c3408
	if ctx.cr[6].eq {
	pc = 0x821C3408; continue 'dispatch;
	}
	// 821C33F0: 894B0085  lbz r10, 0x85(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(133 as u32) ) } as u64;
	// 821C33F4: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C33F8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821C33FC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821C3400: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3404: 480000B0  b 0x821c34b4
	pc = 0x821C34B4; continue 'dispatch;
            }
            0x821C3408 => {
    //   block [0x821C3408..0x821C3424)
	// 821C3408: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C340C: 80BF004C  lwz r5, 0x4c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821C3410: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821C3414: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 821C3418: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C341C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C3420: 40810054  ble 0x821c3474
	if !ctx.cr[0].gt {
	pc = 0x821C3474; continue 'dispatch;
	}
	pc = 0x821C3424; continue 'dispatch;
            }
            0x821C3424 => {
    //   block [0x821C3424..0x821C3444)
	// 821C3424: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821C3428: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C342C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C3430: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C3434: 2F070085  cmpwi cr6, r7, 0x85
	ctx.cr[6].compare_i32(ctx.r[7].s32, 133, &mut ctx.xer);
	// 821C3438: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821C343C: 41980008  blt cr6, 0x821c3444
	if ctx.cr[6].lt {
	pc = 0x821C3444; continue 'dispatch;
	}
	// 821C3440: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x821C3444; continue 'dispatch;
            }
            0x821C3444 => {
    //   block [0x821C3444..0x821C3460)
	// 821C3444: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821C3448: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C344C: 419A0014  beq cr6, 0x821c3460
	if ctx.cr[6].eq {
	pc = 0x821C3460; continue 'dispatch;
	}
	// 821C3450: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821C3454: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C3458: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C345C: 4800000C  b 0x821c3468
	pc = 0x821C3468; continue 'dispatch;
            }
            0x821C3460 => {
    //   block [0x821C3460..0x821C3468)
	// 821C3460: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821C3464: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821C3468; continue 'dispatch;
            }
            0x821C3468 => {
    //   block [0x821C3468..0x821C3474)
	// 821C3468: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C346C: 4199FFB8  bgt cr6, 0x821c3424
	if ctx.cr[6].gt {
	pc = 0x821C3424; continue 'dispatch;
	}
	// 821C3470: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821C3474; continue 'dispatch;
            }
            0x821C3474 => {
    //   block [0x821C3474..0x821C3490)
	// 821C3474: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821C3478: 419A0034  beq cr6, 0x821c34ac
	if ctx.cr[6].eq {
	pc = 0x821C34AC; continue 'dispatch;
	}
	// 821C347C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C3480: 2F0B0085  cmpwi cr6, r11, 0x85
	ctx.cr[6].compare_i32(ctx.r[11].s32, 133, &mut ctx.xer);
	// 821C3484: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C3488: 41990008  bgt cr6, 0x821c3490
	if ctx.cr[6].gt {
	pc = 0x821C3490; continue 'dispatch;
	}
	// 821C348C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821C3490; continue 'dispatch;
            }
            0x821C3490 => {
    //   block [0x821C3490..0x821C34AC)
	// 821C3490: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C3494: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C3498: 409A0014  bne cr6, 0x821c34ac
	if !ctx.cr[6].eq {
	pc = 0x821C34AC; continue 'dispatch;
	}
	// 821C349C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C34A0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821C34A4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C34A8: 48000008  b 0x821c34b0
	pc = 0x821C34B0; continue 'dispatch;
            }
            0x821C34AC => {
    //   block [0x821C34AC..0x821C34B0)
	// 821C34AC: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	pc = 0x821C34B0; continue 'dispatch;
            }
            0x821C34B0 => {
    //   block [0x821C34B0..0x821C34B4)
	// 821C34B0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x821C34B4; continue 'dispatch;
            }
            0x821C34B4 => {
    //   block [0x821C34B4..0x821C34B8)
	// 821C34B4: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	pc = 0x821C34B8; continue 'dispatch;
            }
            0x821C34B8 => {
    //   block [0x821C34B8..0x821C34EC)
	// 821C34B8: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821C34BC: 556AFFFE  rlwinm r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821C34C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C34C4: 419A00D4  beq cr6, 0x821c3598
	if ctx.cr[6].eq {
	pc = 0x821C3598; continue 'dispatch;
	}
	// 821C34C8: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C34CC: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C34D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C34D4: 419A0018  beq cr6, 0x821c34ec
	if ctx.cr[6].eq {
	pc = 0x821C34EC; continue 'dispatch;
	}
	// 821C34D8: 896B0061  lbz r11, 0x61(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(97 as u32) ) } as u64;
	// 821C34DC: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821C34E0: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821C34E4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C34E8: 480000AC  b 0x821c3594
	pc = 0x821C3594; continue 'dispatch;
            }
            0x821C34EC => {
    //   block [0x821C34EC..0x821C3504)
	// 821C34EC: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821C34F0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821C34F4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821C34F8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C34FC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C3500: 40810054  ble 0x821c3554
	if !ctx.cr[0].gt {
	pc = 0x821C3554; continue 'dispatch;
	}
	pc = 0x821C3504; continue 'dispatch;
            }
            0x821C3504 => {
    //   block [0x821C3504..0x821C3524)
	// 821C3504: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821C3508: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C350C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C3510: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C3514: 2F070061  cmpwi cr6, r7, 0x61
	ctx.cr[6].compare_i32(ctx.r[7].s32, 97, &mut ctx.xer);
	// 821C3518: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821C351C: 41980008  blt cr6, 0x821c3524
	if ctx.cr[6].lt {
	pc = 0x821C3524; continue 'dispatch;
	}
	// 821C3520: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x821C3524; continue 'dispatch;
            }
            0x821C3524 => {
    //   block [0x821C3524..0x821C3540)
	// 821C3524: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821C3528: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C352C: 419A0014  beq cr6, 0x821c3540
	if ctx.cr[6].eq {
	pc = 0x821C3540; continue 'dispatch;
	}
	// 821C3530: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821C3534: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C3538: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C353C: 4800000C  b 0x821c3548
	pc = 0x821C3548; continue 'dispatch;
            }
            0x821C3540 => {
    //   block [0x821C3540..0x821C3548)
	// 821C3540: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821C3544: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821C3548; continue 'dispatch;
            }
            0x821C3548 => {
    //   block [0x821C3548..0x821C3554)
	// 821C3548: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C354C: 4199FFB8  bgt cr6, 0x821c3504
	if ctx.cr[6].gt {
	pc = 0x821C3504; continue 'dispatch;
	}
	// 821C3550: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821C3554; continue 'dispatch;
            }
            0x821C3554 => {
    //   block [0x821C3554..0x821C3570)
	// 821C3554: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C3558: 419A0034  beq cr6, 0x821c358c
	if ctx.cr[6].eq {
	pc = 0x821C358C; continue 'dispatch;
	}
	// 821C355C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C3560: 2F0B0061  cmpwi cr6, r11, 0x61
	ctx.cr[6].compare_i32(ctx.r[11].s32, 97, &mut ctx.xer);
	// 821C3564: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C3568: 41990008  bgt cr6, 0x821c3570
	if ctx.cr[6].gt {
	pc = 0x821C3570; continue 'dispatch;
	}
	// 821C356C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821C3570; continue 'dispatch;
            }
            0x821C3570 => {
    //   block [0x821C3570..0x821C358C)
	// 821C3570: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C3574: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C3578: 409A0014  bne cr6, 0x821c358c
	if !ctx.cr[6].eq {
	pc = 0x821C358C; continue 'dispatch;
	}
	// 821C357C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C3580: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821C3584: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C3588: 48000008  b 0x821c3590
	pc = 0x821C3590; continue 'dispatch;
            }
            0x821C358C => {
    //   block [0x821C358C..0x821C3590)
	// 821C358C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x821C3590; continue 'dispatch;
            }
            0x821C3590 => {
    //   block [0x821C3590..0x821C3594)
	// 821C3590: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x821C3594; continue 'dispatch;
            }
            0x821C3594 => {
    //   block [0x821C3594..0x821C3598)
	// 821C3594: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x821C3598; continue 'dispatch;
            }
            0x821C3598 => {
    //   block [0x821C3598..0x821C35B4)
	// 821C3598: 480ADDD1  bl 0x82271368
	ctx.lr = 0x821C359C;
	sub_82271368(ctx, base);
	// 821C359C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821C35A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C35A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C35A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821C35AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C35B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C35B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C35B8 size=68
    let mut pc: u32 = 0x821C35B8;
    'dispatch: loop {
        match pc {
            0x821C35B8 => {
    //   block [0x821C35B8..0x821C35E8)
	// 821C35B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C35BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C35C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C35C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C35C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C35CC: 897F0004  lbz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C35D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C35D4: 419A0014  beq cr6, 0x821c35e8
	if ctx.cr[6].eq {
	pc = 0x821C35E8; continue 'dispatch;
	}
	// 821C35D8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C35DC: 490F6379  bl 0x832b9954
	ctx.lr = 0x821C35E0;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 821C35E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C35E4: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	pc = 0x821C35E8; continue 'dispatch;
            }
            0x821C35E8 => {
    //   block [0x821C35E8..0x821C35FC)
	// 821C35E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C35EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C35F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C35F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C35F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C3600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C3600 size=112
    let mut pc: u32 = 0x821C3600;
    'dispatch: loop {
        match pc {
            0x821C3600 => {
    //   block [0x821C3600..0x821C3638)
	// 821C3600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C3604: 48AE5E01  bl 0x82ca9404
	ctx.lr = 0x821C3608;
	sub_82CA93D0(ctx, base);
	// 821C3608: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C360C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C3610: 547D2036  slwi r29, r3, 4
	ctx.r[29].u32 = ctx.r[3].u32.wrapping_shl(4);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 821C3614: 396BF970  addi r11, r11, -0x690
	ctx.r[11].s64 = ctx.r[11].s64 + -1680;
	// 821C3618: 7F7D5A14  add r27, r29, r11
	ctx.r[27].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 821C361C: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C3620: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3624: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821C3628: 7D1F1671  srawi. r31, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[8].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821C362C: 40810024  ble 0x821c3650
	if !ctx.cr[0].gt {
	pc = 0x821C3650; continue 'dispatch;
	}
	// 821C3630: 3B8B0004  addi r28, r11, 4
	ctx.r[28].s64 = ctx.r[11].s64 + 4;
	// 821C3634: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x821C3638; continue 'dispatch;
            }
            0x821C3638 => {
    //   block [0x821C3638..0x821C3650)
	// 821C3638: 7D7DE02E  lwzx r11, r29, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 821C363C: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 821C3640: 4888B5A1  bl 0x82a4ebe0
	ctx.lr = 0x821C3644;
	sub_82A4EBE0(ctx, base);
	// 821C3644: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821C3648: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 821C364C: 4082FFEC  bne 0x821c3638
	if !ctx.cr[0].eq {
	pc = 0x821C3638; continue 'dispatch;
	}
	pc = 0x821C3650; continue 'dispatch;
            }
            0x821C3650 => {
    //   block [0x821C3650..0x821C3670)
	// 821C3650: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C3654: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821C3658: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821C365C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821C3660: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821C3664: 480E9A15  bl 0x822ad078
	ctx.lr = 0x821C3668;
	sub_822AD078(ctx, base);
	// 821C3668: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821C366C: 48AE5DE8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C3670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C3670 size=488
    let mut pc: u32 = 0x821C3670;
    'dispatch: loop {
        match pc {
            0x821C3670 => {
    //   block [0x821C3670..0x821C36F0)
	// 821C3670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C3674: 48AE5D89  bl 0x82ca93fc
	ctx.lr = 0x821C3678;
	sub_82CA93D0(ctx, base);
	// 821C3678: 9421F030  stwu r1, -0xfd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-4048 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C367C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C3680: 837F0004  lwz r27, 4(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3684: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821C3688: 83DB0014  lwz r30, 0x14(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C368C: 480BA485  bl 0x8227db10
	ctx.lr = 0x821C3690;
	sub_8227DB10(ctx, base);
	// 821C3690: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C3694: 4BFBDC05  bl 0x82181298
	ctx.lr = 0x821C3698;
	sub_82181298(ctx, base);
	// 821C3698: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C369C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821C36A0: 806BF7F4  lwz r3, -0x80c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2060 as u32) ) } as u64;
	// 821C36A4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C36A8: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C36AC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821C36B0: 4E800421  bctrl
	ctx.lr = 0x821C36B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C36B4: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 821C36B8: 3D008332  lis r8, -0x7cce
	ctx.r[8].s64 = -2093875200;
	// 821C36BC: 3CC08332  lis r6, -0x7cce
	ctx.r[6].s64 = -2093875200;
	// 821C36C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C36C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C36C8: 88A76E61  lbz r5, 0x6e61(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(28257 as u32) ) } as u64;
	// 821C36CC: 99681624  stb r11, 0x1624(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(5668 as u32), ctx.r[11].u8 ) };
	// 821C36D0: 7CA40034  cntlzw r4, r5
	ctx.r[4].u64 = if ctx.r[5].u32 == 0 { 32 } else { ctx.r[5].u32.leading_zeros() as u64 };
	// 821C36D4: 99461625  stb r10, 0x1625(r6)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[6].u32.wrapping_add(5669 as u32), ctx.r[10].u8 ) };
	// 821C36D8: 5483DFFE  rlwinm r3, r4, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[4].u32 as u64 & 0x0000001Fu64;
	// 821C36DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821C36E0: 419A0010  beq cr6, 0x821c36f0
	if ctx.cr[6].eq {
	pc = 0x821C36F0; continue 'dispatch;
	}
	// 821C36E4: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 821C36E8: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821C36EC: 916A8570  stw r11, -0x7a90(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-31376 as u32), ctx.r[11].u32 ) };
            }
            0x821C36F0 => {
    //   block [0x821C36F0..0x821C37E4)
	// 821C36F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C36F4: 4BFF61E5  bl 0x821b98d8
	ctx.lr = 0x821C36F8;
	sub_821B98D8(ctx, base);
	// 821C36F8: 4BFF6AF9  bl 0x821ba1f0
	ctx.lr = 0x821C36FC;
	sub_821BA1F0(ctx, base);
	// 821C36FC: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 821C3700: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 821C3704: 392AA978  addi r9, r10, -0x5688
	ctx.r[9].s64 = ctx.r[10].s64 + -22152;
	// 821C3708: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821C370C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821C3710: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821C3714: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821C3718: 3BA10058  addi r29, r1, 0x58
	ctx.r[29].s64 = ctx.r[1].s64 + 88;
	// 821C371C: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 821C3720: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3724: 480374AD  bl 0x821fabd0
	ctx.lr = 0x821C3728;
	sub_821FABD0(ctx, base);
	// 821C3728: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 821C372C: 3C80834A  lis r4, -0x7cb6
	ctx.r[4].s64 = -2092302336;
	// 821C3730: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 821C3734: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821C3738: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 821C373C: 80DC0000  lwz r6, 0(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C3740: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821C3744: 80FD0000  lwz r7, 0(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C3748: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 821C374C: 7D4A1670  srawi r10, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 821C3750: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821C3754: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821C3758: 7D6A0194  addze r11, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[11].s64 = tmp.s64;
	// 821C375C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821C3760: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821C3764: 8084F9C0  lwz r4, -0x640(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 821C3768: 48038629  bl 0x821fbd90
	ctx.lr = 0x821C376C;
	sub_821FBD90(ctx, base);
	// 821C376C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821C3770: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821C3774: 3B4BAA5C  addi r26, r11, -0x55a4
	ctx.r[26].s64 = ctx.r[11].s64 + -21924;
	// 821C3778: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821C377C: 4803846D  bl 0x821fbbe8
	ctx.lr = 0x821C3780;
	sub_821FBBE8(ctx, base);
	// 821C3780: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821C3784: 4803880D  bl 0x821fbf90
	ctx.lr = 0x821C3788;
	sub_821FBF90(ctx, base);
	// 821C3788: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C378C: 809E0E60  lwz r4, 0xe60(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(3680 as u32) ) } as u64;
	// 821C3790: 4BFE9829  bl 0x821acfb8
	ctx.lr = 0x821C3794;
	sub_821ACFB8(ctx, base);
	// 821C3794: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3798: 480BF4A1  bl 0x82282c38
	ctx.lr = 0x821C379C;
	sub_82282C38(ctx, base);
	// 821C379C: 480D2E45  bl 0x822965e0
	ctx.lr = 0x821C37A0;
	sub_822965E0(ctx, base);
	// 821C37A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C37A4: 4BFEABDD  bl 0x821ae380
	ctx.lr = 0x821C37A8;
	sub_821AE380(ctx, base);
	// 821C37A8: 3F20834A  lis r25, -0x7cb6
	ctx.r[25].s64 = -2092302336;
	// 821C37AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821C37B0: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821C37B4: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 821C37B8: 8099F7DC  lwz r4, -0x824(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-2084 as u32) ) } as u64;
	// 821C37BC: 480A9D55  bl 0x8226d510
	ctx.lr = 0x821C37C0;
	sub_8226D510(ctx, base);
	// 821C37C0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C37C4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821C37C8: 3BCB4DE4  addi r30, r11, 0x4de4
	ctx.r[30].s64 = ctx.r[11].s64 + 19940;
	// 821C37CC: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C37D0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C37D4: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821C37D8: 7D491671  srawi. r9, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821C37DC: 41820040  beq 0x821c381c
	if ctx.cr[0].eq {
	pc = 0x821C381C; continue 'dispatch;
	}
	// 821C37E0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x821C37E4; continue 'dispatch;
            }
            0x821C37E4 => {
    //   block [0x821C37E4..0x821C381C)
	// 821C37E4: 7C7C582E  lwzx r3, r28, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821C37E8: 480B7D61  bl 0x8227b548
	ctx.lr = 0x821C37EC;
	sub_8227B548(ctx, base);
	// 821C37EC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C37F0: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 821C37F4: 7C7C582E  lwzx r3, r28, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821C37F8: 480A5479  bl 0x82268c70
	ctx.lr = 0x821C37FC;
	sub_82268C70(ctx, base);
	// 821C37FC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3800: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821C3804: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C3808: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 821C380C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821C3810: 7D491670  srawi r9, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 821C3814: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821C3818: 4198FFCC  blt cr6, 0x821c37e4
	if ctx.cr[6].lt {
	pc = 0x821C37E4; continue 'dispatch;
	}
	pc = 0x821C381C; continue 'dispatch;
            }
            0x821C381C => {
    //   block [0x821C381C..0x821C3858)
	// 821C381C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C3820: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 821C3824: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821C3828: 806BF7EC  lwz r3, -0x814(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2068 as u32) ) } as u64;
	// 821C382C: 480C7345  bl 0x8228ab70
	ctx.lr = 0x821C3830;
	sub_8228AB70(ctx, base);
	// 821C3830: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821C3834: 8099F7DC  lwz r4, -0x824(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-2084 as u32) ) } as u64;
	// 821C3838: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821C383C: 38610820  addi r3, r1, 0x820
	ctx.r[3].s64 = ctx.r[1].s64 + 2080;
	// 821C3840: 480A9CD1  bl 0x8226d510
	ctx.lr = 0x821C3844;
	sub_8226D510(ctx, base);
	// 821C3844: 38610820  addi r3, r1, 0x820
	ctx.r[3].s64 = ctx.r[1].s64 + 2080;
	// 821C3848: 809B0014  lwz r4, 0x14(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C384C: 4BFD429D  bl 0x82197ae8
	ctx.lr = 0x821C3850;
	sub_82197AE8(ctx, base);
	// 821C3850: 38210FD0  addi r1, r1, 0xfd0
	ctx.r[1].s64 = ctx.r[1].s64 + 4048;
	// 821C3854: 48AE5BF8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C3858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C3858 size=1028
    let mut pc: u32 = 0x821C3858;
    'dispatch: loop {
        match pc {
            0x821C3858 => {
    //   block [0x821C3858..0x821C38D4)
	// 821C3858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C385C: 48AE5BA5  bl 0x82ca9400
	ctx.lr = 0x821C3860;
	sub_82CA93D0(ctx, base);
	// 821C3860: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 821C3864: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C3868: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821C386C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821C3870: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821C3874: 4805B495  bl 0x8221ed08
	ctx.lr = 0x821C3878;
	sub_8221ED08(ctx, base);
	// 821C3878: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821C387C: 906BF808  stw r3, -0x7f8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-2040 as u32), ctx.r[3].u32 ) };
	// 821C3880: 48073AB9  bl 0x82237338
	ctx.lr = 0x821C3884;
	sub_82237338(ctx, base);
	// 821C3884: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821C3888: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 821C388C: 3F408336  lis r26, -0x7cca
	ctx.r[26].s64 = -2093613056;
	// 821C3890: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 821C3894: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 821C3898: 81496E10  lwz r10, 0x6e10(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28176 as u32) ) } as u64;
	// 821C389C: 817D70C4  lwz r11, 0x70c4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28868 as u32) ) } as u64;
	// 821C38A0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821C38A4: DBFAF7F8  stfd f31, -0x808(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[26].u32.wrapping_add(-2056 as u32), ctx.f[31].u64 ) };
	// 821C38A8: 93E86E14  stw r31, 0x6e14(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(28180 as u32), ctx.r[31].u32 ) };
	// 821C38AC: 2B0B1800  cmplwi cr6, r11, 0x1800
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6144 as u32, &mut ctx.xer);
	// 821C38B0: DBE76E18  stfd f31, 0x6e18(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(28184 as u32), ctx.f[31].u64 ) };
	// 821C38B4: 91496E10  stw r10, 0x6e10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28176 as u32), ctx.r[10].u32 ) };
	// 821C38B8: 419A00A0  beq cr6, 0x821c3958
	if ctx.cr[6].eq {
	pc = 0x821C3958; continue 'dispatch;
	}
	// 821C38BC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821C38C0: 3BEB0308  addi r31, r11, 0x308
	ctx.r[31].s64 = ctx.r[11].s64 + 776;
	// 821C38C4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C38C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821C38CC: 419A0008  beq cr6, 0x821c38d4
	if ctx.cr[6].eq {
	pc = 0x821C38D4; continue 'dispatch;
	}
	// 821C38D0: 48979EF9  bl 0x82b3d7c8
	ctx.lr = 0x821C38D4;
	sub_82B3D7C8(ctx, base);
	pc = 0x821C38D4; continue 'dispatch;
            }
            0x821C38D4 => {
    //   block [0x821C38D4..0x821C38E4)
	// 821C38D4: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C38D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821C38DC: 419A0008  beq cr6, 0x821c38e4
	if ctx.cr[6].eq {
	pc = 0x821C38E4; continue 'dispatch;
	}
	// 821C38E0: 48979EE9  bl 0x82b3d7c8
	ctx.lr = 0x821C38E4;
	sub_82B3D7C8(ctx, base);
	pc = 0x821C38E4; continue 'dispatch;
            }
            0x821C38E4 => {
    //   block [0x821C38E4..0x821C3904)
	// 821C38E4: 3FC08336  lis r30, -0x7cca
	ctx.r[30].s64 = -2093613056;
	// 821C38E8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821C38EC: 807E0364  lwz r3, 0x364(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(868 as u32) ) } as u64;
	// 821C38F0: 489DEF41  bl 0x82ba2830
	ctx.lr = 0x821C38F4;
	sub_82BA2830(ctx, base);
	// 821C38F4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821C38F8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821C38FC: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 821C3900: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x821C3904; continue 'dispatch;
            }
            0x821C3904 => {
    //   block [0x821C3904..0x821C3920)
	// 821C3904: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821C3908: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821C390C: 4200FFF8  bdnz 0x821c3904
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821C3904; continue 'dispatch;
	}
	// 821C3910: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821C3914: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821C3918: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 821C391C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x821C3920; continue 'dispatch;
            }
            0x821C3920 => {
    //   block [0x821C3920..0x821C3958)
	// 821C3920: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821C3924: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821C3928: 4200FFF8  bdnz 0x821c3920
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821C3920; continue 'dispatch;
	}
	// 821C392C: 3D600002  lis r11, 2
	ctx.r[11].s64 = 131072;
	// 821C3930: 807E0364  lwz r3, 0x364(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(868 as u32) ) } as u64;
	// 821C3934: 3D400060  lis r10, 0x60
	ctx.r[10].s64 = 6291456;
	// 821C3938: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821C393C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821C3940: 39601800  li r11, 0x1800
	ctx.r[11].s64 = 6144;
	// 821C3944: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 821C3948: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 821C394C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821C3950: 917D70C4  stw r11, 0x70c4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28868 as u32), ctx.r[11].u32 ) };
	// 821C3954: 489DEEDD  bl 0x82ba2830
	ctx.lr = 0x821C3958;
	sub_82BA2830(ctx, base);
	pc = 0x821C3958; continue 'dispatch;
            }
            0x821C3958 => {
    //   block [0x821C3958..0x821C397C)
	// 821C3958: 3FE08336  lis r31, -0x7cca
	ctx.r[31].s64 = -2093613056;
	// 821C395C: 897FCBD1  lbz r11, -0x342f(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-13359 as u32) ) } as u64;
	// 821C3960: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C3964: 419A0018  beq cr6, 0x821c397c
	if ctx.cr[6].eq {
	pc = 0x821C397C; continue 'dispatch;
	}
	// 821C3968: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821C396C: 386BDEE4  addi r3, r11, -0x211c
	ctx.r[3].s64 = ctx.r[11].s64 + -8476;
	// 821C3970: 489BFA09  bl 0x82b83378
	ctx.lr = 0x821C3974;
	sub_82B83378(ctx, base);
	// 821C3974: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C3978: 997FCBD1  stb r11, -0x342f(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(-13359 as u32), ctx.r[11].u8 ) };
	pc = 0x821C397C; continue 'dispatch;
            }
            0x821C397C => {
    //   block [0x821C397C..0x821C3A28)
	// 821C397C: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821C3980: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821C3984: 3BEB2390  addi r31, r11, 0x2390
	ctx.r[31].s64 = ctx.r[11].s64 + 9104;
	// 821C3988: 390A7E70  addi r8, r10, 0x7e70
	ctx.r[8].s64 = ctx.r[10].s64 + 32368;
	// 821C398C: 38FF2008  addi r7, r31, 0x2008
	ctx.r[7].s64 = ctx.r[31].s64 + 8200;
	// 821C3990: 817F2004  lwz r11, 0x2004(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C3994: 55661838  slwi r6, r11, 3
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821C3998: 7D06F92E  stwx r8, r6, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[31].u32), ctx.r[8].u32) };
	// 821C399C: 815F2004  lwz r10, 0x2004(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C39A0: 813F2000  lwz r9, 0x2000(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C39A4: 817F400C  lwz r11, 0x400c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821C39A8: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821C39AC: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	// 821C39B0: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821C39B4: 917F2004  stw r11, 0x2004(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8196 as u32), ctx.r[11].u32 ) };
	// 821C39B8: 915F2000  stw r10, 0x2000(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8192 as u32), ctx.r[10].u32 ) };
	// 821C39BC: 7D05392E  stwx r8, r5, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[7].u32), ctx.r[8].u32) };
	// 821C39C0: 817F400C  lwz r11, 0x400c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821C39C4: 815F4008  lwz r10, 0x4008(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16392 as u32) ) } as u64;
	// 821C39C8: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821C39CC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821C39D0: 915F4008  stw r10, 0x4008(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16392 as u32), ctx.r[10].u32 ) };
	// 821C39D4: 917F400C  stw r11, 0x400c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16396 as u32), ctx.r[11].u32 ) };
	// 821C39D8: 480FF289  bl 0x822c2c60
	ctx.lr = 0x821C39DC;
	sub_822C2C60(ctx, base);
	// 821C39DC: 3C60834A  lis r3, -0x7cb6
	ctx.r[3].s64 = -2092302336;
	// 821C39E0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C39E4: 390360B8  addi r8, r3, 0x60b8
	ctx.r[8].s64 = ctx.r[3].s64 + 24760;
	// 821C39E8: 388BF838  addi r4, r11, -0x7c8
	ctx.r[4].s64 = ctx.r[11].s64 + -1992;
	// 821C39EC: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 821C39F0: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C39F4: 81280008  lwz r9, 8(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C39F8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C39FC: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 821C3A00: 816360B8  lwz r11, 0x60b8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24760 as u32) ) } as u64;
	// 821C3A04: 3867F820  addi r3, r7, -0x7e0
	ctx.r[3].s64 = ctx.r[7].s64 + -2016;
	// 821C3A08: 8108000C  lwz r8, 0xc(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C3A0C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821C3A10: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 821C3A14: 4BFB7985  bl 0x8217b398
	ctx.lr = 0x821C3A18;
	sub_8217B398(ctx, base);
	// 821C3A18: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C3A1C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821C3A20: 3BCBF9B0  addi r30, r11, -0x650
	ctx.r[30].s64 = ctx.r[11].s64 + -1616;
	// 821C3A24: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	pc = 0x821C3A28; continue 'dispatch;
            }
            0x821C3A28 => {
    //   block [0x821C3A28..0x821C3A44)
	// 821C3A28: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C3A2C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C3A30: 419A0014  beq cr6, 0x821c3a44
	if ctx.cr[6].eq {
	pc = 0x821C3A44; continue 'dispatch;
	}
	// 821C3A34: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821C3A38: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821C3A3C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821C3A40: 4811C3C9  bl 0x822dfe08
	ctx.lr = 0x821C3A44;
	sub_822DFE08(ctx, base);
	pc = 0x821C3A44; continue 'dispatch;
            }
            0x821C3A44 => {
    //   block [0x821C3A44..0x821C3AE4)
	// 821C3A44: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 821C3A48: 397E0010  addi r11, r30, 0x10
	ctx.r[11].s64 = ctx.r[30].s64 + 16;
	// 821C3A4C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 821C3A50: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821C3A54: 4198FFD4  blt cr6, 0x821c3a28
	if ctx.cr[6].lt {
	pc = 0x821C3A28; continue 'dispatch;
	}
	// 821C3A58: 2F1BFFFF  cmpwi cr6, r27, -1
	ctx.cr[6].compare_i32(ctx.r[27].s32, -1, &mut ctx.xer);
	// 821C3A5C: 419A00F8  beq cr6, 0x821c3b54
	if ctx.cr[6].eq {
	pc = 0x821C3B54; continue 'dispatch;
	}
	// 821C3A60: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C3A64: 394BF7A8  addi r10, r11, -0x858
	ctx.r[10].s64 = ctx.r[11].s64 + -2136;
	// 821C3A68: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3A6C: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C3A70: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821C3A74: 7D281670  srawi r8, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 821C3A78: 7F1B4040  cmplw cr6, r27, r8
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821C3A7C: 409800D8  bge cr6, 0x821c3b54
	if !ctx.cr[6].lt {
	pc = 0x821C3B54; continue 'dispatch;
	}
	// 821C3A80: 576A103A  slwi r10, r27, 2
	ctx.r[10].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821C3A84: 7D2A582E  lwzx r9, r10, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821C3A88: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C3A8C: 419A00C8  beq cr6, 0x821c3b54
	if ctx.cr[6].eq {
	pc = 0x821C3B54; continue 'dispatch;
	}
	// 821C3A90: 553E003E  slwi r30, r9, 0
	ctx.r[30].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821C3A94: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3A98: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821C3A9C: 409A00B8  bne cr6, 0x821c3b54
	if !ctx.cr[6].eq {
	pc = 0x821C3B54; continue 'dispatch;
	}
	// 821C3AA0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821C3AA4: 419A00B0  beq cr6, 0x821c3b54
	if ctx.cr[6].eq {
	pc = 0x821C3B54; continue 'dispatch;
	}
	// 821C3AA8: 809E0014  lwz r4, 0x14(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C3AAC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821C3AB0: 4BFBE0B9  bl 0x82181b68
	ctx.lr = 0x821C3AB4;
	sub_82181B68(ctx, base);
	// 821C3AB4: 897E0048  lbz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C3AB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C3ABC: 419A008C  beq cr6, 0x821c3b48
	if ctx.cr[6].eq {
	pc = 0x821C3B48; continue 'dispatch;
	}
	// 821C3AC0: 807E0014  lwz r3, 0x14(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C3AC4: 48030AB5  bl 0x821f4578
	ctx.lr = 0x821C3AC8;
	sub_821F4578(ctx, base);
	// 821C3AC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C3ACC: 4800E1D5  bl 0x821d1ca0
	ctx.lr = 0x821C3AD0;
	sub_821D1CA0(ctx, base);
	// 821C3AD0: 83BE0014  lwz r29, 0x14(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C3AD4: 807D0E5C  lwz r3, 0xe5c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3676 as u32) ) } as u64;
	// 821C3AD8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821C3ADC: 419A0008  beq cr6, 0x821c3ae4
	if ctx.cr[6].eq {
	pc = 0x821C3AE4; continue 'dispatch;
	}
	// 821C3AE0: 48011669  bl 0x821d5148
	ctx.lr = 0x821C3AE4;
	sub_821D5148(ctx, base);
	pc = 0x821C3AE4; continue 'dispatch;
            }
            0x821C3AE4 => {
    //   block [0x821C3AE4..0x821C3AF8)
	// 821C3AE4: 807D0E64  lwz r3, 0xe64(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3684 as u32) ) } as u64;
	// 821C3AE8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821C3AEC: 419A000C  beq cr6, 0x821c3af8
	if ctx.cr[6].eq {
	pc = 0x821C3AF8; continue 'dispatch;
	}
	// 821C3AF0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821C3AF4: 4807D1F5  bl 0x82240ce8
	ctx.lr = 0x821C3AF8;
	sub_82240CE8(ctx, base);
	pc = 0x821C3AF8; continue 'dispatch;
            }
            0x821C3AF8 => {
    //   block [0x821C3AF8..0x821C3B40)
	// 821C3AF8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821C3AFC: 480FCEED  bl 0x822c09e8
	ctx.lr = 0x821C3B00;
	sub_822C09E8(ctx, base);
	// 821C3B00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C3B04: C83AF7F8  lfd f1, -0x808(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[26].u32.wrapping_add(-2056 as u32) ) };
	// 821C3B08: 480C79D9  bl 0x8228b4e0
	ctx.lr = 0x821C3B0C;
	sub_8228B4E0(ctx, base);
	// 821C3B0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C3B10: 4801F671  bl 0x821e3180
	ctx.lr = 0x821C3B14;
	sub_821E3180(ctx, base);
	// 821C3B14: 807E0014  lwz r3, 0x14(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C3B18: 480CBA39  bl 0x8228f550
	ctx.lr = 0x821C3B1C;
	sub_8228F550(ctx, base);
	// 821C3B1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821C3B20: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821C3B24: 419A001C  beq cr6, 0x821c3b40
	if ctx.cr[6].eq {
	pc = 0x821C3B40; continue 'dispatch;
	}
	// 821C3B28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C3B2C: 996A6E70  stb r11, 0x6e70(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28272 as u32), ctx.r[11].u8 ) };
	// 821C3B30: 4809FA41  bl 0x82263570
	ctx.lr = 0x821C3B34;
	sub_82263570(ctx, base);
	// 821C3B34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C3B38: 48000129  bl 0x821c3c60
	ctx.lr = 0x821C3B3C;
	sub_821C3C60(ctx, base);
	// 821C3B3C: 48000050  b 0x821c3b8c
	pc = 0x821C3B8C; continue 'dispatch;
            }
            0x821C3B40 => {
    //   block [0x821C3B40..0x821C3B48)
	// 821C3B40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C3B44: 996A6E70  stb r11, 0x6e70(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28272 as u32), ctx.r[11].u8 ) };
	pc = 0x821C3B48; continue 'dispatch;
            }
            0x821C3B48 => {
    //   block [0x821C3B48..0x821C3B54)
	// 821C3B48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C3B4C: 48000115  bl 0x821c3c60
	ctx.lr = 0x821C3B50;
	sub_821C3C60(ctx, base);
	// 821C3B50: 4800003C  b 0x821c3b8c
	pc = 0x821C3B8C; continue 'dispatch;
            }
            0x821C3B54 => {
    //   block [0x821C3B54..0x821C3B84)
	// 821C3B54: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821C3B58: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821C3B5C: 386AF9CC  addi r3, r10, -0x634
	ctx.r[3].s64 = ctx.r[10].s64 + -1588;
	// 821C3B60: C02B9490  lfs f1, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821C3B64: 4801F0A5  bl 0x821e2c08
	ctx.lr = 0x821C3B68;
	sub_821E2C08(ctx, base);
	// 821C3B68: 4BFF3219  bl 0x821b6d80
	ctx.lr = 0x821C3B6C;
	sub_821B6D80(ctx, base);
	// 821C3B6C: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 821C3B70: 8069FA0C  lwz r3, -0x5f4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-1524 as u32) ) } as u64;
	// 821C3B74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821C3B78: 419A000C  beq cr6, 0x821c3b84
	if ctx.cr[6].eq {
	pc = 0x821C3B84; continue 'dispatch;
	}
	// 821C3B7C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821C3B80: 480F1451  bl 0x822b4fd0
	ctx.lr = 0x821C3B84;
	sub_822B4FD0(ctx, base);
	pc = 0x821C3B84; continue 'dispatch;
            }
            0x821C3B84 => {
    //   block [0x821C3B84..0x821C3B8C)
	// 821C3B84: 4BFCE3CD  bl 0x82191f50
	ctx.lr = 0x821C3B88;
	sub_82191F50(ctx, base);
	// 821C3B88: 480F13B1  bl 0x822b4f38
	ctx.lr = 0x821C3B8C;
	sub_822B4F38(ctx, base);
	pc = 0x821C3B8C; continue 'dispatch;
            }
            0x821C3B8C => {
    //   block [0x821C3B8C..0x821C3BEC)
	// 821C3B8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C3B90: 48036449  bl 0x821f9fd8
	ctx.lr = 0x821C3B94;
	sub_821F9FD8(ctx, base);
	// 821C3B94: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821C3B98: 4BFFFA69  bl 0x821c3600
	ctx.lr = 0x821C3B9C;
	sub_821C3600(ctx, base);
	// 821C3B9C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C3BA0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821C3BA4: 806BF84C  lwz r3, -0x7b4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1972 as u32) ) } as u64;
	// 821C3BA8: 91430014  stw r10, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 821C3BAC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3BB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C3BB4: 419A0038  beq cr6, 0x821c3bec
	if ctx.cr[6].eq {
	pc = 0x821C3BEC; continue 'dispatch;
	}
	// 821C3BB8: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C3BBC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C3BC0: 409A002C  bne cr6, 0x821c3bec
	if !ctx.cr[6].eq {
	pc = 0x821C3BEC; continue 'dispatch;
	}
	// 821C3BC4: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C3BC8: 39200061  li r9, 0x61
	ctx.r[9].s64 = 97;
	// 821C3BCC: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C3BD0: 38EAFFF0  addi r7, r10, -0x10
	ctx.r[7].s64 = ctx.r[10].s64 + -16;
	// 821C3BD4: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821C3BD8: 91280008  stw r9, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 821C3BDC: 80C30014  lwz r6, 0x14(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C3BE0: 90C80004  stw r6, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 821C3BE4: 91030014  stw r8, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 821C3BE8: 48000008  b 0x821c3bf0
	pc = 0x821C3BF0; continue 'dispatch;
            }
            0x821C3BEC => {
    //   block [0x821C3BEC..0x821C3BF0)
	// 821C3BEC: 48A2774D  bl 0x82beb338
	ctx.lr = 0x821C3BF0;
	sub_82BEB338(ctx, base);
	pc = 0x821C3BF0; continue 'dispatch;
            }
            0x821C3BF0 => {
    //   block [0x821C3BF0..0x821C3BF4)
	// 821C3BF0: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	pc = 0x821C3BF4; continue 'dispatch;
            }
            0x821C3BF4 => {
    //   block [0x821C3BF4..0x821C3C4C)
	// 821C3BF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C3BF8: 4805B751  bl 0x8221f348
	ctx.lr = 0x821C3BFC;
	sub_8221F348(ctx, base);
	// 821C3BFC: 3BDE2008  addi r30, r30, 0x2008
	ctx.r[30].s64 = ctx.r[30].s64 + 8200;
	// 821C3C00: 397F4010  addi r11, r31, 0x4010
	ctx.r[11].s64 = ctx.r[31].s64 + 16400;
	// 821C3C04: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821C3C08: 4198FFEC  blt cr6, 0x821c3bf4
	if ctx.cr[6].lt {
	pc = 0x821C3BF4; continue 'dispatch;
	}
	// 821C3C0C: 4806E6BD  bl 0x822322c8
	ctx.lr = 0x821C3C10;
	sub_822322C8(ctx, base);
	// 821C3C10: 4805A891  bl 0x8221e4a0
	ctx.lr = 0x821C3C14;
	sub_8221E4A0(ctx, base);
	// 821C3C14: 4BFF316D  bl 0x821b6d80
	ctx.lr = 0x821C3C18;
	sub_821B6D80(ctx, base);
	// 821C3C18: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C3C1C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821C3C20: 388B6338  addi r4, r11, 0x6338
	ctx.r[4].s64 = ctx.r[11].s64 + 25400;
	// 821C3C24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C3C28: 4803CB49  bl 0x82200770
	ctx.lr = 0x821C3C2C;
	sub_82200770(ctx, base);
	// 821C3C2C: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821C3C30: 386A632C  addi r3, r10, 0x632c
	ctx.r[3].s64 = ctx.r[10].s64 + 25388;
	// 821C3C34: 489AE23D  bl 0x82b71e70
	ctx.lr = 0x821C3C38;
	sub_82B71E70(ctx, base);
	// 821C3C38: 89010054  lbz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C3C3C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821C3C40: 419A000C  beq cr6, 0x821c3c4c
	if ctx.cr[6].eq {
	pc = 0x821C3C4C; continue 'dispatch;
	}
	// 821C3C44: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821C3C48: 490F5D0D  bl 0x832b9954
	ctx.lr = 0x821C3C4C;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x821C3C4C; continue 'dispatch;
            }
            0x821C3C4C => {
    //   block [0x821C3C4C..0x821C3C5C)
	// 821C3C4C: 4BFE220D  bl 0x821a5e58
	ctx.lr = 0x821C3C50;
	sub_821A5E58(ctx, base);
	// 821C3C50: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821C3C54: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 821C3C58: 48AE57F8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C3C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C3C60 size=496
    let mut pc: u32 = 0x821C3C60;
    'dispatch: loop {
        match pc {
            0x821C3C60 => {
    //   block [0x821C3C60..0x821C3C98)
	// 821C3C60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C3C64: 48AE579D  bl 0x82ca9400
	ctx.lr = 0x821C3C68;
	sub_82CA93D0(ctx, base);
	// 821C3C68: 9421F7A0  stwu r1, -0x860(r1)
	ea = ctx.r[1].u32.wrapping_add(-2144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C3C6C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821C3C70: 897D0048  lbz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C3C74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C3C78: 409A0020  bne cr6, 0x821c3c98
	if !ctx.cr[6].eq {
	pc = 0x821C3C98; continue 'dispatch;
	}
	// 821C3C7C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821C3C80: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821C3C84: 386AF9CC  addi r3, r10, -0x634
	ctx.r[3].s64 = ctx.r[10].s64 + -1588;
	// 821C3C88: C02B9490  lfs f1, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821C3C8C: 4801EF7D  bl 0x821e2c08
	ctx.lr = 0x821C3C90;
	sub_821E2C08(ctx, base);
	// 821C3C90: 38210860  addi r1, r1, 0x860
	ctx.r[1].s64 = ctx.r[1].s64 + 2144;
	// 821C3C94: 48AE57BC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x821C3C98 => {
    //   block [0x821C3C98..0x821C3CD8)
	// 821C3C98: 817D05D0  lwz r11, 0x5d0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1488 as u32) ) } as u64;
	// 821C3C9C: 815D05D4  lwz r10, 0x5d4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1492 as u32) ) } as u64;
	// 821C3CA0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C3CA4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 821C3CA8: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821C3CAC: 409A002C  bne cr6, 0x821c3cd8
	if !ctx.cr[6].eq {
	pc = 0x821C3CD8; continue 'dispatch;
	}
	// 821C3CB0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821C3CB4: 409A0024  bne cr6, 0x821c3cd8
	if !ctx.cr[6].eq {
	pc = 0x821C3CD8; continue 'dispatch;
	}
	// 821C3CB8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C3CBC: 394B5FE8  addi r10, r11, 0x5fe8
	ctx.r[10].s64 = ctx.r[11].s64 + 24552;
	// 821C3CC0: 816B5FE8  lwz r11, 0x5fe8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24552 as u32) ) } as u64;
	// 821C3CC4: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3CC8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 821C3CCC: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821C3CD0: E9210060  ld r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821C3CD4: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	pc = 0x821C3CD8; continue 'dispatch;
            }
            0x821C3CD8 => {
    //   block [0x821C3CD8..0x821C3D0C)
	// 821C3CD8: 817D05D8  lwz r11, 0x5d8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1496 as u32) ) } as u64;
	// 821C3CDC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821C3CE0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821C3CE4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C3CE8: 419A0024  beq cr6, 0x821c3d0c
	if ctx.cr[6].eq {
	pc = 0x821C3D0C; continue 'dispatch;
	}
	// 821C3CEC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821C3CF0: 419A0024  beq cr6, 0x821c3d14
	if ctx.cr[6].eq {
	pc = 0x821C3D14; continue 'dispatch;
	}
	// 821C3CF4: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821C3CF8: 419A0014  beq cr6, 0x821c3d0c
	if ctx.cr[6].eq {
	pc = 0x821C3D0C; continue 'dispatch;
	}
	// 821C3CFC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821C3D00: 409A0018  bne cr6, 0x821c3d18
	if !ctx.cr[6].eq {
	pc = 0x821C3D18; continue 'dispatch;
	}
	// 821C3D04: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821C3D08: 48000010  b 0x821c3d18
	pc = 0x821C3D18; continue 'dispatch;
            }
            0x821C3D0C => {
    //   block [0x821C3D0C..0x821C3D14)
	// 821C3D0C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821C3D10: 48000008  b 0x821c3d18
	pc = 0x821C3D18; continue 'dispatch;
            }
            0x821C3D14 => {
    //   block [0x821C3D14..0x821C3D18)
	// 821C3D14: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	pc = 0x821C3D18; continue 'dispatch;
            }
            0x821C3D18 => {
    //   block [0x821C3D18..0x821C3D6C)
	// 821C3D18: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821C3D1C: 480C6D15  bl 0x8228aa30
	ctx.lr = 0x821C3D20;
	sub_8228AA30(ctx, base);
	// 821C3D20: 4BFF3111  bl 0x821b6e30
	ctx.lr = 0x821C3D24;
	sub_821B6E30(ctx, base);
	// 821C3D24: 4BFD7BE5  bl 0x8219b908
	ctx.lr = 0x821C3D28;
	sub_8219B908(ctx, base);
	// 821C3D28: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C3D2C: 894B6E21  lbz r10, 0x6e21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28193 as u32) ) } as u64;
	// 821C3D30: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C3D34: 419A0038  beq cr6, 0x821c3d6c
	if ctx.cr[6].eq {
	pc = 0x821C3D6C; continue 'dispatch;
	}
	// 821C3D38: 488C7BD1  bl 0x82a8b908
	ctx.lr = 0x821C3D3C;
	sub_82A8B908(ctx, base);
	// 821C3D3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821C3D40: 419A002C  beq cr6, 0x821c3d6c
	if ctx.cr[6].eq {
	pc = 0x821C3D6C; continue 'dispatch;
	}
	// 821C3D44: 488C7BC5  bl 0x82a8b908
	ctx.lr = 0x821C3D48;
	sub_82A8B908(ctx, base);
	// 821C3D48: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821C3D4C: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 821C3D50: 394B02B0  addi r10, r11, 0x2b0
	ctx.r[10].s64 = ctx.r[11].s64 + 688;
	// 821C3D54: 3CC00020  lis r6, 0x20
	ctx.r[6].s64 = 2097152;
	// 821C3D58: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 821C3D5C: 906A0028  stw r3, 0x28(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(40 as u32), ctx.r[3].u32 ) };
	// 821C3D60: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3D64: 80690364  lwz r3, 0x364(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(868 as u32) ) } as u64;
	// 821C3D68: 4BFF3179  bl 0x821b6ee0
	ctx.lr = 0x821C3D6C;
	sub_821B6EE0(ctx, base);
	pc = 0x821C3D6C; continue 'dispatch;
            }
            0x821C3D6C => {
    //   block [0x821C3D6C..0x821C3DAC)
	// 821C3D6C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C3D70: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821C3D74: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 821C3D78: 806BF820  lwz r3, -0x7e0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2016 as u32) ) } as u64;
	// 821C3D7C: 836AF7F8  lwz r27, -0x808(r10)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-2056 as u32) ) } as u64;
	// 821C3D80: 83E9F7DC  lwz r31, -0x824(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-2084 as u32) ) } as u64;
	// 821C3D84: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C3D88: 80E80024  lwz r7, 0x24(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(36 as u32) ) } as u64;
	// 821C3D8C: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 821C3D90: 4E800421  bctrl
	ctx.lr = 0x821C3D94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C3D94: 93E100B0  stw r31, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[31].u32 ) };
	// 821C3D98: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821C3D9C: 93A100B4  stw r29, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[29].u32 ) };
	// 821C3DA0: 3BE101E0  addi r31, r1, 0x1e0
	ctx.r[31].s64 = ctx.r[1].s64 + 480;
	// 821C3DA4: 938101D0  stw r28, 0x1d0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(464 as u32), ctx.r[28].u32 ) };
	// 821C3DA8: 3BC00004  li r30, 4
	ctx.r[30].s64 = 4;
            }
            0x821C3DAC => {
    //   block [0x821C3DAC..0x821C3DE4)
	// 821C3DAC: 3D6082B9  lis r11, -0x7d47
	ctx.r[11].s64 = -2101805056;
	// 821C3DB0: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 821C3DB4: 38CB6E78  addi r6, r11, 0x6e78
	ctx.r[6].s64 = ctx.r[11].s64 + 28280;
	// 821C3DB8: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 821C3DBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C3DC0: 4805BD49  bl 0x8221fb08
	ctx.lr = 0x821C3DC4;
	sub_8221FB08(ctx, base);
	// 821C3DC4: 939F0100  stw r28, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[28].u32 ) };
	// 821C3DC8: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821C3DCC: 3BFF0110  addi r31, r31, 0x110
	ctx.r[31].s64 = ctx.r[31].s64 + 272;
	// 821C3DD0: 4080FFDC  bge 0x821c3dac
	if !ctx.cr[0].lt {
	pc = 0x821C3DAC; continue 'dispatch;
	}
	// 821C3DD4: 397D0190  addi r11, r29, 0x190
	ctx.r[11].s64 = ctx.r[29].s64 + 400;
	// 821C3DD8: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 821C3DDC: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821C3DE0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x821C3DE4; continue 'dispatch;
            }
            0x821C3DE4 => {
    //   block [0x821C3DE4..0x821C3E50)
	// 821C3DE4: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821C3DE8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821C3DEC: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821C3DF0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C3DF4: 4200FFF0  bdnz 0x821c3de4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821C3DE4; continue 'dispatch;
	}
	// 821C3DF8: 39600060  li r11, 0x60
	ctx.r[11].s64 = 96;
	// 821C3DFC: 39400050  li r10, 0x50
	ctx.r[10].s64 = 80;
	// 821C3E00: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 821C3E04: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 821C3E08: 38BD02F0  addi r5, r29, 0x2f0
	ctx.r[5].s64 = ctx.r[29].s64 + 752;
	// 821C3E0C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C3E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C3E50 size=24
    let mut pc: u32 = 0x821C3E50;
    'dispatch: loop {
        match pc {
            0x821C3E50 => {
    //   block [0x821C3E50..0x821C3E68)
	// 821C3E50: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C3E54: 81440014  lwz r10, 0x14(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C3E58: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821C3E5C: 4098000C  bge cr6, 0x821c3e68
	if !ctx.cr[6].lt {
		sub_821C3E68(ctx, base);
		return;
	}
	// 821C3E60: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 821C3E64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C3E68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C3E68 size=12
    let mut pc: u32 = 0x821C3E68;
    'dispatch: loop {
        match pc {
            0x821C3E68 => {
    //   block [0x821C3E68..0x821C3E74)
	// 821C3E68: 4099000C  ble cr6, 0x821c3e74
	if !ctx.cr[6].gt {
		sub_821C3E74(ctx, base);
		return;
	}
	// 821C3E6C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821C3E70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C3E74(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821C3E74 size=52
    let mut pc: u32 = 0x821C3E74;
    'dispatch: loop {
        match pc {
            0x821C3E74 => {
    //   block [0x821C3E74..0x821C3EA8)
	// 821C3E74: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 821C3E78: 81440018  lwz r10, 0x18(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 821C3E7C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821C3E80: 4198FFE0  blt cr6, 0x821c3e60
	if ctx.cr[6].lt {
		sub_821C3E50(ctx, base);
		return;
	}
	// 821C3E84: 4199FFE8  bgt cr6, 0x821c3e6c
	if ctx.cr[6].gt {
		sub_821C3E68(ctx, base);
		return;
	}
	// 821C3E88: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C3E8C: 8144001C  lwz r10, 0x1c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C3E90: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821C3E94: 4198FFCC  blt cr6, 0x821c3e60
	if ctx.cr[6].lt {
		sub_821C3E50(ctx, base);
		return;
	}
	// 821C3E98: 7D6B5010  subfc r11, r11, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[11].u32;
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821C3E9C: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 821C3EA0: 556307FE  clrlwi r3, r11, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821C3EA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C3EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C3EA8 size=548
    let mut pc: u32 = 0x821C3EA8;
    'dispatch: loop {
        match pc {
            0x821C3EA8 => {
    //   block [0x821C3EA8..0x821C3EF0)
	// 821C3EA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C3EAC: 48AE5545  bl 0x82ca93f0
	ctx.lr = 0x821C3EB0;
	sub_82CA93D0(ctx, base);
	// 821C3EB0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C3EB4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 821C3EB8: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 821C3EBC: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 821C3EC0: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 821C3EC4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821C3EC8: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 821C3ECC: 8158000C  lwz r10, 0xc(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C3ED0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C3ED4: 7EEB51D6  mullw r23, r11, r10
	ctx.r[23].s32 = ((ctx.r[11].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[23].s64 = ctx.r[23].s32 as i64;
	// 821C3ED8: 3B57FFFF  addi r26, r23, -1
	ctx.r[26].s64 = ctx.r[23].s64 + -1;
	// 821C3EDC: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 821C3EE0: 2B1D0001  cmplwi cr6, r29, 1
	ctx.cr[6].compare_u32(ctx.r[29].u32, 1 as u32, &mut ctx.xer);
	// 821C3EE4: 4099005C  ble cr6, 0x821c3f40
	if !ctx.cr[6].gt {
	pc = 0x821C3F40; continue 'dispatch;
	}
	// 821C3EE8: 83980008  lwz r28, 8(r24)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C3EEC: 83780004  lwz r27, 4(r24)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x821C3EF0; continue 'dispatch;
            }
            0x821C3EF0 => {
    //   block [0x821C3EF0..0x821C3F28)
	// 821C3EF0: 7D7DFA14  add r11, r29, r31
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[31].u64;
	// 821C3EF4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 821C3EF8: 557EF87E  srwi r30, r11, 1
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821C3EFC: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C3F00: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 821C3F04: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C3F08: 7C8BDA14  add r4, r11, r27
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 821C3F0C: 4BFFFF45  bl 0x821c3e50
	ctx.lr = 0x821C3F10;
	sub_821C3E50(ctx, base);
	// 821C3F10: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 821C3F14: 41820028  beq 0x821c3f3c
	if ctx.cr[0].eq {
	pc = 0x821C3F3C; continue 'dispatch;
	}
	// 821C3F18: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821C3F1C: 4099000C  ble cr6, 0x821c3f28
	if !ctx.cr[6].gt {
	pc = 0x821C3F28; continue 'dispatch;
	}
	// 821C3F20: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 821C3F24: 48000008  b 0x821c3f2c
	pc = 0x821C3F2C; continue 'dispatch;
            }
            0x821C3F28 => {
    //   block [0x821C3F28..0x821C3F2C)
	// 821C3F28: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	pc = 0x821C3F2C; continue 'dispatch;
            }
            0x821C3F2C => {
    //   block [0x821C3F2C..0x821C3F3C)
	// 821C3F2C: 7D7FE850  subf r11, r31, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[31].s64;
	// 821C3F30: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821C3F34: 4199FFBC  bgt cr6, 0x821c3ef0
	if ctx.cr[6].gt {
	pc = 0x821C3EF0; continue 'dispatch;
	}
	// 821C3F38: 48000008  b 0x821c3f40
	pc = 0x821C3F40; continue 'dispatch;
            }
            0x821C3F3C => {
    //   block [0x821C3F3C..0x821C3F40)
	// 821C3F3C: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	pc = 0x821C3F40; continue 'dispatch;
            }
            0x821C3F40 => {
    //   block [0x821C3F40..0x821C3F6C)
	// 821C3F40: 83980008  lwz r28, 8(r24)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C3F44: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C3F48: 83780004  lwz r27, 4(r24)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C3F4C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 821C3F50: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 821C3F54: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C3F58: 7C8BDA14  add r4, r11, r27
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 821C3F5C: 4BFFFEF5  bl 0x821c3e50
	ctx.lr = 0x821C3F60;
	sub_821C3E50(ctx, base);
	// 821C3F60: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 821C3F64: 40810008  ble 0x821c3f6c
	if !ctx.cr[0].gt {
	pc = 0x821C3F6C; continue 'dispatch;
	}
	// 821C3F68: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	pc = 0x821C3F6C; continue 'dispatch;
            }
            0x821C3F6C => {
    //   block [0x821C3F6C..0x821C3F80)
	// 821C3F6C: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 821C3F70: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 821C3F74: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821C3F78: 2B1D0001  cmplwi cr6, r29, 1
	ctx.cr[6].compare_u32(ctx.r[29].u32, 1 as u32, &mut ctx.xer);
	// 821C3F7C: 40990054  ble cr6, 0x821c3fd0
	if !ctx.cr[6].gt {
	pc = 0x821C3FD0; continue 'dispatch;
	}
	pc = 0x821C3F80; continue 'dispatch;
            }
            0x821C3F80 => {
    //   block [0x821C3F80..0x821C3FB8)
	// 821C3F80: 7D7DFA14  add r11, r29, r31
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[31].u64;
	// 821C3F84: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821C3F88: 557EF87E  srwi r30, r11, 1
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821C3F8C: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C3F90: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 821C3F94: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C3F98: 7C8BDA14  add r4, r11, r27
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 821C3F9C: 4BFFFEB5  bl 0x821c3e50
	ctx.lr = 0x821C3FA0;
	sub_821C3E50(ctx, base);
	// 821C3FA0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 821C3FA4: 41820028  beq 0x821c3fcc
	if ctx.cr[0].eq {
	pc = 0x821C3FCC; continue 'dispatch;
	}
	// 821C3FA8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821C3FAC: 4099000C  ble cr6, 0x821c3fb8
	if !ctx.cr[6].gt {
	pc = 0x821C3FB8; continue 'dispatch;
	}
	// 821C3FB0: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 821C3FB4: 48000008  b 0x821c3fbc
	pc = 0x821C3FBC; continue 'dispatch;
            }
            0x821C3FB8 => {
    //   block [0x821C3FB8..0x821C3FBC)
	// 821C3FB8: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	pc = 0x821C3FBC; continue 'dispatch;
            }
            0x821C3FBC => {
    //   block [0x821C3FBC..0x821C3FCC)
	// 821C3FBC: 7D7FE850  subf r11, r31, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[31].s64;
	// 821C3FC0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821C3FC4: 4199FFBC  bgt cr6, 0x821c3f80
	if ctx.cr[6].gt {
	pc = 0x821C3F80; continue 'dispatch;
	}
	// 821C3FC8: 48000008  b 0x821c3fd0
	pc = 0x821C3FD0; continue 'dispatch;
            }
            0x821C3FCC => {
    //   block [0x821C3FCC..0x821C3FD0)
	// 821C3FCC: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	pc = 0x821C3FD0; continue 'dispatch;
            }
            0x821C3FD0 => {
    //   block [0x821C3FD0..0x821C3FF4)
	// 821C3FD0: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C3FD4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821C3FD8: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 821C3FDC: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C3FE0: 7C8BDA14  add r4, r11, r27
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 821C3FE4: 4BFFFE6D  bl 0x821c3e50
	ctx.lr = 0x821C3FE8;
	sub_821C3E50(ctx, base);
	// 821C3FE8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 821C3FEC: 40810008  ble 0x821c3ff4
	if !ctx.cr[0].gt {
	pc = 0x821C3FF4; continue 'dispatch;
	}
	// 821C3FF0: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	pc = 0x821C3FF4; continue 'dispatch;
            }
            0x821C3FF4 => {
    //   block [0x821C3FF4..0x821C4010)
	// 821C3FF4: 7F1FD040  cmplw cr6, r31, r26
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[26].u32, &mut ctx.xer);
	// 821C3FF8: 40980048  bge cr6, 0x821c4040
	if !ctx.cr[6].lt {
	pc = 0x821C4040; continue 'dispatch;
	}
	// 821C3FFC: 8119001C  lwz r8, 0x1c(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C4000: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 821C4004: 7F1FB840  cmplw cr6, r31, r23
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[23].u32, &mut ctx.xer);
	// 821C4008: 4098007C  bge cr6, 0x821c4084
	if !ctx.cr[6].lt {
	pc = 0x821C4084; continue 'dispatch;
	}
	// 821C400C: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	pc = 0x821C4010; continue 'dispatch;
            }
            0x821C4010 => {
    //   block [0x821C4010..0x821C4040)
	// 821C4010: 81380008  lwz r9, 8(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C4014: 7D4B482E  lwzx r10, r11, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821C4018: 7D0B492E  stwx r8, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[8].u32) };
	// 821C401C: 8139001C  lwz r9, 0x1c(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C4020: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 821C4024: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821C4028: 419A005C  beq cr6, 0x821c4084
	if ctx.cr[6].eq {
	pc = 0x821C4084; continue 'dispatch;
	}
	// 821C402C: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 821C4030: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821C4034: 7F07B840  cmplw cr6, r7, r23
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[23].u32, &mut ctx.xer);
	// 821C4038: 4198FFD8  blt cr6, 0x821c4010
	if ctx.cr[6].lt {
	pc = 0x821C4010; continue 'dispatch;
	}
	// 821C403C: 48000048  b 0x821c4084
	pc = 0x821C4084; continue 'dispatch;
            }
            0x821C4040 => {
    //   block [0x821C4040..0x821C4054)
	// 821C4040: 40990044  ble cr6, 0x821c4084
	if !ctx.cr[6].gt {
	pc = 0x821C4084; continue 'dispatch;
	}
	// 821C4044: 7F1AF840  cmplw cr6, r26, r31
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821C4048: 40980028  bge cr6, 0x821c4070
	if !ctx.cr[6].lt {
	pc = 0x821C4070; continue 'dispatch;
	}
	// 821C404C: 574A103A  slwi r10, r26, 2
	ctx.r[10].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821C4050: 7D7AF850  subf r11, r26, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[26].s64;
	pc = 0x821C4054; continue 'dispatch;
            }
            0x821C4054 => {
    //   block [0x821C4054..0x821C4070)
	// 821C4054: 81380008  lwz r9, 8(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C4058: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C405C: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821C4060: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821C4064: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C4068: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821C406C: 4082FFE8  bne 0x821c4054
	if !ctx.cr[0].eq {
	pc = 0x821C4054; continue 'dispatch;
	}
	pc = 0x821C4070; continue 'dispatch;
            }
            0x821C4070 => {
    //   block [0x821C4070..0x821C4084)
	// 821C4070: 81580008  lwz r10, 8(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C4074: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C4078: 8139001C  lwz r9, 0x1c(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C407C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821C4080: 912BFFFC  stw r9, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[9].u32 ) };
	pc = 0x821C4084; continue 'dispatch;
            }
            0x821C4084 => {
    //   block [0x821C4084..0x821C40CC)
	// 821C4084: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C4088: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821C408C: C0160004  lfs f0, 4(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C4090: D0190004  stfs f0, 4(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821C4094: C0160008  lfs f0, 8(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C4098: D0190008  stfs f0, 8(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821C409C: C016000C  lfs f0, 0xc(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C40A0: D019000C  stfs f0, 0xc(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821C40A4: C0160010  lfs f0, 0x10(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C40A8: D0190010  stfs f0, 0x10(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821C40AC: 81760014  lwz r11, 0x14(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C40B0: 91790014  stw r11, 0x14(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 821C40B4: 81760018  lwz r11, 0x18(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(24 as u32) ) } as u64;
	// 821C40B8: 91790018  stw r11, 0x18(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 821C40BC: 8176001C  lwz r11, 0x1c(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C40C0: 9179001C  stw r11, 0x1c(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 821C40C4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821C40C8: 48AE5378  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C40D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C40D0 size=532
    let mut pc: u32 = 0x821C40D0;
    'dispatch: loop {
        match pc {
            0x821C40D0 => {
    //   block [0x821C40D0..0x821C4114)
	// 821C40D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C40D4: 48AE5331  bl 0x82ca9404
	ctx.lr = 0x821C40D8;
	sub_82CA93D0(ctx, base);
	// 821C40D8: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 821C40DC: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 821C40E0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C40E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821C40E8: 4809C8D1  bl 0x822609b8
	ctx.lr = 0x821C40EC;
	sub_822609B8(ctx, base);
	// 821C40EC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 821C40F0: C3C3004C  lfs f30, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821C40F4: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 821C40F8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C40FC: 838B0008  lwz r28, 8(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C4100: 281C0000  cmplwi r28, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821C4104: 418201D0  beq 0x821c42d4
	if ctx.cr[0].eq {
	pc = 0x821C42D4; continue 'dispatch;
	}
	// 821C4108: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821C410C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 821C4110: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x821C4114; continue 'dispatch;
            }
            0x821C4114 => {
    //   block [0x821C4114..0x821C41D4)
	// 821C4114: 83FC0004  lwz r31, 4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C4118: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C411C: 480001CD  bl 0x821c42e8
	ctx.lr = 0x821C4120;
	sub_821C42E8(ctx, base);
	// 821C4120: 897E0020  lbz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 821C4124: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821C4128: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821C412C: 41820148  beq 0x821c4274
	if ctx.cr[0].eq {
	pc = 0x821C4274; continue 'dispatch;
	}
	// 821C4130: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C4134: C01F003C  lfs f0, 0x3c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C4138: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C413C: C1BF0034  lfs f13, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821C4140: 7D6BE9D6  mullw r11, r11, r29
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[29].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821C4144: C19F0038  lfs f12, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821C4148: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C414C: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821C4150: C145000C  lfs f10, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821C4154: EC005028  fsubs f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 821C4158: C1650010  lfs f11, 0x10(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821C415C: C1250004  lfs f9, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821C4160: FF0BF800  fcmpu cr6, f11, f31
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[31].f64);
	// 821C4164: C1450008  lfs f10, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821C4168: EDAD4828  fsubs f13, f13, f9
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[9].f64) as f32) as f64);
	// 821C416C: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 821C4170: 419A00D0  beq cr6, 0x821c4240
	if ctx.cr[6].eq {
	pc = 0x821C4240; continue 'dispatch;
	}
	// 821C4174: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 821C4178: C15E0018  lfs f10, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821C417C: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 821C4180: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 821C4184: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 821C4188: 419900B8  bgt cr6, 0x821c4240
	if ctx.cr[6].gt {
	pc = 0x821C4240; continue 'dispatch;
	}
	// 821C418C: FF0BF000  fcmpu cr6, f11, f30
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[30].f64);
	// 821C4190: 409800E4  bge cr6, 0x821c4274
	if !ctx.cr[6].lt {
	pc = 0x821C4274; continue 'dispatch;
	}
	// 821C4194: FC004890  fmr f0, f9
	ctx.f[0].f64 = ctx.f[9].f64;
	// 821C4198: C1BE001C  lfs f13, 0x1c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821C419C: C19F0034  lfs f12, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821C41A0: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 821C41A4: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821C41A8: C19F0038  lfs f12, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821C41AC: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821C41B0: C19F003C  lfs f12, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821C41B4: D181006C  stfs f12, 0x6c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821C41B8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821C41BC: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 821C41C0: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821C41C4: 41980010  blt cr6, 0x821c41d4
	if ctx.cr[6].lt {
	pc = 0x821C41D4; continue 'dispatch;
	}
	// 821C41C8: 39610074  addi r11, r1, 0x74
	ctx.r[11].s64 = ctx.r[1].s64 + 116;
	// 821C41CC: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 821C41D0: 48000018  b 0x821c41e8
	pc = 0x821C41E8; continue 'dispatch;
            }
            0x821C41D4 => {
    //   block [0x821C41D4..0x821C41E8)
	// 821C41D4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821C41D8: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 821C41DC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821C41E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C41E4: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	pc = 0x821C41E8; continue 'dispatch;
            }
            0x821C41E8 => {
    //   block [0x821C41E8..0x821C4208)
	// 821C41E8: C005000C  lfs f0, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C41EC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821C41F0: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 821C41F4: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821C41F8: 41980010  blt cr6, 0x821c4208
	if ctx.cr[6].lt {
	pc = 0x821C4208; continue 'dispatch;
	}
	// 821C41FC: 39610078  addi r11, r1, 0x78
	ctx.r[11].s64 = ctx.r[1].s64 + 120;
	// 821C4200: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 821C4204: 48000018  b 0x821c421c
	pc = 0x821C421C; continue 'dispatch;
            }
            0x821C4208 => {
    //   block [0x821C4208..0x821C421C)
	// 821C4208: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 821C420C: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 821C4210: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C4214: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C4218: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	pc = 0x821C421C; continue 'dispatch;
            }
            0x821C421C => {
    //   block [0x821C421C..0x821C4240)
	// 821C421C: 8165001C  lwz r11, 0x1c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C4220: C01E0010  lfs f0, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C4224: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821C4228: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 821C422C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C4230: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821C4234: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 821C4238: 4BFFFC71  bl 0x821c3ea8
	ctx.lr = 0x821C423C;
	sub_821C3EA8(ctx, base);
	// 821C423C: 48000038  b 0x821c4274
	pc = 0x821C4274; continue 'dispatch;
            }
            0x821C4240 => {
    //   block [0x821C4240..0x821C4250)
	// 821C4240: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C4244: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C4248: 419A0008  beq cr6, 0x821c4250
	if ctx.cr[6].eq {
	pc = 0x821C4250; continue 'dispatch;
	}
	// 821C424C: 93650000  stw r27, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	pc = 0x821C4250; continue 'dispatch;
            }
            0x821C4250 => {
    //   block [0x821C4250..0x821C4274)
	// 821C4250: C01F0034  lfs f0, 0x34(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C4254: D0050004  stfs f0, 4(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821C4258: C01F0038  lfs f0, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C425C: D0050008  stfs f0, 8(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821C4260: C01F003C  lfs f0, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C4264: D005000C  stfs f0, 0xc(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821C4268: C01E0014  lfs f0, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C426C: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 821C4270: D0050010  stfs f0, 0x10(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(16 as u32), tmp.u32 ) };
	pc = 0x821C4274; continue 'dispatch;
            }
            0x821C4274 => {
    //   block [0x821C4274..0x821C4298)
	// 821C4274: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C4278: 393D0001  addi r9, r29, 1
	ctx.r[9].s64 = ctx.r[29].s64 + 1;
	// 821C427C: 7D6AE9D6  mullw r11, r10, r29
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * ctx.r[29].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821C4280: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821C4284: 7D4951D6  mullw r10, r9, r10
	ctx.r[10].s32 = ((ctx.r[9].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821C4288: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821C428C: 4098003C  bge cr6, 0x821c42c8
	if !ctx.cr[6].lt {
	pc = 0x821C42C8; continue 'dispatch;
	}
	// 821C4290: 55692834  slwi r9, r11, 5
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C4294: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	pc = 0x821C4298; continue 'dispatch;
            }
            0x821C4298 => {
    //   block [0x821C4298..0x821C42BC)
	// 821C4298: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C429C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821C42A0: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C42A4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821C42A8: 419A0014  beq cr6, 0x821c42bc
	if ctx.cr[6].eq {
	pc = 0x821C42BC; continue 'dispatch;
	}
	// 821C42AC: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C42B0: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 821C42B4: 40980008  bge cr6, 0x821c42bc
	if !ctx.cr[6].lt {
	pc = 0x821C42BC; continue 'dispatch;
	}
	// 821C42B8: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	pc = 0x821C42BC; continue 'dispatch;
            }
            0x821C42BC => {
    //   block [0x821C42BC..0x821C42C8)
	// 821C42BC: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821C42C0: 39290020  addi r9, r9, 0x20
	ctx.r[9].s64 = ctx.r[9].s64 + 32;
	// 821C42C4: 4082FFD4  bne 0x821c4298
	if !ctx.cr[0].eq {
	pc = 0x821C4298; continue 'dispatch;
	}
	pc = 0x821C42C8; continue 'dispatch;
            }
            0x821C42C8 => {
    //   block [0x821C42C8..0x821C42D4)
	// 821C42C8: 839C000C  lwz r28, 0xc(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C42CC: 281C0000  cmplwi r28, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821C42D0: 4082FE44  bne 0x821c4114
	if !ctx.cr[0].eq {
	pc = 0x821C4114; continue 'dispatch;
	}
	pc = 0x821C42D4; continue 'dispatch;
            }
            0x821C42D4 => {
    //   block [0x821C42D4..0x821C42E4)
	// 821C42D4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821C42D8: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 821C42DC: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 821C42E0: 48AE5174  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C42E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C42E8 size=20
    let mut pc: u32 = 0x821C42E8;
    'dispatch: loop {
        match pc {
            0x821C42E8 => {
    //   block [0x821C42E8..0x821C42FC)
	// 821C42E8: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C42EC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821C42F0: 4082000C  bne 0x821c42fc
	if !ctx.cr[0].eq {
		crate::recompiler::externs::call(ctx, base, 0x821C42FC);
		return;
	}
	// 821C42F4: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 821C42F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C4320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C4320 size=88
    let mut pc: u32 = 0x821C4320;
    'dispatch: loop {
        match pc {
            0x821C4320 => {
    //   block [0x821C4320..0x821C4364)
	// 821C4320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C4324: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C4328: DBE1FFF0  stfd f31, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 821C432C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C4330: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 821C4334: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821C4338: 4BFFFFB1  bl 0x821c42e8
	ctx.lr = 0x821C433C;
	sub_821C42E8(ctx, base);
	// 821C433C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 821C4340: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 821C4344: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C4348: 7F035040  cmplw cr6, r3, r10
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821C434C: 40980018  bge cr6, 0x821c4364
	if !ctx.cr[6].lt {
	pc = 0x821C4364; continue 'dispatch;
	}
	// 821C4350: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821C4354: 1D43001C  mulli r10, r3, 0x1c
	ctx.r[10].s32 = ((ctx.r[3].s32 as i64 * 28 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821C4358: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821C435C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821C4360: D3EB000C  stfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x821C4364; continue 'dispatch;
            }
            0x821C4364 => {
    //   block [0x821C4364..0x821C4378)
	// 821C4364: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C4368: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C436C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C4370: CBE1FFF0  lfd f31, -0x10(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C4374: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C4378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C4378 size=1732
    let mut pc: u32 = 0x821C4378;
    'dispatch: loop {
        match pc {
            0x821C4378 => {
    //   block [0x821C4378..0x821C43B0)
	// 821C4378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C437C: 48AE5075  bl 0x82ca93f0
	ctx.lr = 0x821C4380;
	sub_82CA93D0(ctx, base);
	// 821C4380: DBC1FF98  stfd f30, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[30].u64 ) };
	// 821C4384: DBE1FFA0  stfd f31, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 821C4388: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C438C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821C4390: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821C4394: 3860007A  li r3, 0x7a
	ctx.r[3].s64 = 122;
	// 821C4398: 897B00D8  lbz r11, 0xd8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(216 as u32) ) } as u64;
	// 821C439C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C43A0: 419A0010  beq cr6, 0x821c43b0
	if ctx.cr[6].eq {
	pc = 0x821C43B0; continue 'dispatch;
	}
	// 821C43A4: 48067E6D  bl 0x8222c210
	ctx.lr = 0x821C43A8;
	sub_8222C210(ctx, base);
	// 821C43A8: 3860007C  li r3, 0x7c
	ctx.r[3].s64 = 124;
	// 821C43AC: 4800000C  b 0x821c43b8
	pc = 0x821C43B8; continue 'dispatch;
            }
            0x821C43B0 => {
    //   block [0x821C43B0..0x821C43B8)
	// 821C43B0: 48067E61  bl 0x8222c210
	ctx.lr = 0x821C43B4;
	sub_8222C210(ctx, base);
	// 821C43B4: 3860007B  li r3, 0x7b
	ctx.r[3].s64 = 123;
	pc = 0x821C43B8; continue 'dispatch;
            }
            0x821C43B8 => {
    //   block [0x821C43B8..0x821C43F4)
	// 821C43B8: 48044759  bl 0x82208b10
	ctx.lr = 0x821C43BC;
	sub_82208B10(ctx, base);
	// 821C43BC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C43C0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C43C4: 3EE08336  lis r23, -0x7cca
	ctx.r[23].s64 = -2093613056;
	// 821C43C8: 7958FFE6  rldicr r24, r10, 0x3f, 0x3f
	ctx.r[24].u64 = (ctx.r[10].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821C43CC: E96B1760  ld r11, 0x1760(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(5984 as u32) ) };
	// 821C43D0: 79690004  rldicr r9, r11, 0, 0
	ctx.r[9].u64 = (ctx.r[11].u64).rotate_left(0) & 0x8000000000000000;
	// 821C43D4: 2B290000  cmpldi cr6, r9, 0
	ctx.cr[6].compare_u64(ctx.r[9].u64, 0, &mut ctx.xer);
	// 821C43D8: 419A001C  beq cr6, 0x821c43f4
	if ctx.cr[6].eq {
	pc = 0x821C43F4; continue 'dispatch;
	}
	// 821C43DC: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 821C43E0: 80770364  lwz r3, 0x364(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(868 as u32) ) } as u64;
	// 821C43E4: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 821C43E8: 38BF06B0  addi r5, r31, 0x6b0
	ctx.r[5].s64 = ctx.r[31].s64 + 1712;
	// 821C43EC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821C43F0: 48056491  bl 0x8221a880
	ctx.lr = 0x821C43F4;
	sub_8221A880(ctx, base);
	pc = 0x821C43F4; continue 'dispatch;
            }
            0x821C43F4 => {
    //   block [0x821C43F4..0x821C4430)
	// 821C43F4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C43F8: 815B0284  lwz r10, 0x284(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(644 as u32) ) } as u64;
	// 821C43FC: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821C4400: 390B60B8  addi r8, r11, 0x60b8
	ctx.r[8].s64 = ctx.r[11].s64 + 24760;
	// 821C4404: 38E99484  addi r7, r9, -0x6b7c
	ctx.r[7].s64 = ctx.r[9].s64 + -27516;
	// 821C4408: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 821C440C: 83EB60B8  lwz r31, 0x60b8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24760 as u32) ) } as u64;
	// 821C4410: C3E99484  lfs f31, -0x6b7c(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821C4414: 83C80004  lwz r30, 4(r8)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C4418: 83A80008  lwz r29, 8(r8)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C441C: C3C7000C  lfs f30, 0xc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821C4420: 8388000C  lwz r28, 0xc(r8)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C4424: 419A000C  beq cr6, 0x821c4430
	if ctx.cr[6].eq {
	pc = 0x821C4430; continue 'dispatch;
	}
	// 821C4428: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821C442C: 48000008  b 0x821c4434
	pc = 0x821C4434; continue 'dispatch;
            }
            0x821C4430 => {
    //   block [0x821C4430..0x821C4434)
	// 821C4430: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	pc = 0x821C4434; continue 'dispatch;
            }
            0x821C4434 => {
    //   block [0x821C4434..0x821C4A3C)
	// 821C4434: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 821C4438: 48024841  bl 0x821e8c78
	ctx.lr = 0x821C443C;
	sub_821E8C78(ctx, base);
	// 821C443C: 7D7FE850  subf r11, r31, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[31].s64;
	// 821C4440: 7D5EE050  subf r10, r30, r28
	ctx.r[10].s64 = ctx.r[28].s64 - ctx.r[30].s64;
	// 821C4444: D3E10054  stfs f31, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821C4448: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 821C444C: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821C4450: 7D4807B4  extsw r8, r10
	ctx.r[8].s64 = ctx.r[10].s32 as i64;
	// 821C4454: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 821C4458: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821C445C: F9010060  std r8, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u64 ) };
	// 821C4460: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821C4464: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 821C4468: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 821C446C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 821C4470: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821C4474: 38600073  li r3, 0x73
	ctx.r[3].s64 = 115;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C4A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C4A40 size=1284
    let mut pc: u32 = 0x821C4A40;
    'dispatch: loop {
        match pc {
            0x821C4A40 => {
    //   block [0x821C4A40..0x821C4B14)
	// 821C4A40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C4A44: 48AE49C9  bl 0x82ca940c
	ctx.lr = 0x821C4A48;
	sub_82CA93D0(ctx, base);
	// 821C4A48: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C4A4C: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 821C4A50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C4A54: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821C4A58: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821C4A5C: 3860006E  li r3, 0x6e
	ctx.r[3].s64 = 110;
	// 821C4A60: 996A05A1  stb r11, 0x5a1(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(1441 as u32), ctx.r[11].u8 ) };
	// 821C4A64: 4805C89D  bl 0x82221300
	ctx.lr = 0x821C4A68;
	sub_82221300(ctx, base);
	// 821C4A68: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821C4A6C: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 821C4A70: 4805CAF1  bl 0x82221560
	ctx.lr = 0x821C4A74;
	sub_82221560(ctx, base);
	// 821C4A74: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 821C4A78: 38E00071  li r7, 0x71
	ctx.r[7].s64 = 113;
	// 821C4A7C: 386943D8  addi r3, r9, 0x43d8
	ctx.r[3].s64 = ctx.r[9].s64 + 17368;
	// 821C4A80: 38C0006F  li r6, 0x6f
	ctx.r[6].s64 = 111;
	// 821C4A84: 38A00070  li r5, 0x70
	ctx.r[5].s64 = 112;
	// 821C4A88: 3880006E  li r4, 0x6e
	ctx.r[4].s64 = 110;
	// 821C4A8C: 4805BE6D  bl 0x822208f8
	ctx.lr = 0x821C4A90;
	sub_822208F8(ctx, base);
	// 821C4A90: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821C4A94: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821C4A98: 396B63A0  addi r11, r11, 0x63a0
	ctx.r[11].s64 = ctx.r[11].s64 + 25504;
	// 821C4A9C: 38AA2390  addi r5, r10, 0x2390
	ctx.r[5].s64 = ctx.r[10].s64 + 9104;
	// 821C4AA0: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821C4AA4: 3C808349  lis r4, -0x7cb7
	ctx.r[4].s64 = -2092367872;
	// 821C4AA8: 386A0DB8  addi r3, r10, 0xdb8
	ctx.r[3].s64 = ctx.r[10].s64 + 3512;
	// 821C4AAC: 890B00D5  lbz r8, 0xd5(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(213 as u32) ) } as u64;
	// 821C4AB0: 814B00C4  lwz r10, 0xc4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) } as u64;
	// 821C4AB4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 821C4AB8: 1D482008  mulli r10, r8, 0x2008
	ctx.r[10].s32 = ((ctx.r[8].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821C4ABC: 7D4A2A14  add r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[5].u64;
	// 821C4AC0: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C4AC4: 419A0084  beq cr6, 0x821c4b48
	if ctx.cr[6].eq {
	pc = 0x821C4B48; continue 'dispatch;
	}
	// 821C4AC8: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C4ACC: 810B00C8  lwz r8, 0xc8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(200 as u32) ) } as u64;
	// 821C4AD0: 7D274038  and r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821C4AD4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C4AD8: 409A003C  bne cr6, 0x821c4b14
	if !ctx.cr[6].eq {
	pc = 0x821C4B14; continue 'dispatch;
	}
	// 821C4ADC: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C4AE0: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821C4AE4: 38CB00C0  addi r6, r11, 0xc0
	ctx.r[6].s64 = ctx.r[11].s64 + 192;
	// 821C4AE8: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C4AEC: 912B00C8  stw r9, 0xc8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(200 as u32), ctx.r[9].u32 ) };
	// 821C4AF0: 7CC8512E  stwx r6, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[6].u32) };
	// 821C4AF4: 812B00C4  lwz r9, 0xc4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) } as u64;
	// 821C4AF8: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C4AFC: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C4B00: 7CC85214  add r6, r8, r10
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C4B04: 91260004  stw r9, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C4B08: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C4B0C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821C4B10: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	pc = 0x821C4B14; continue 'dispatch;
            }
            0x821C4B14 => {
    //   block [0x821C4B14..0x821C4B48)
	// 821C4B14: 894B00D4  lbz r10, 0xd4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 821C4B18: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821C4B1C: 912B00C4  stw r9, 0xc4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(196 as u32), ctx.r[9].u32 ) };
	// 821C4B20: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C4B24: 409A0024  bne cr6, 0x821c4b48
	if !ctx.cr[6].eq {
	pc = 0x821C4B48; continue 'dispatch;
	}
	// 821C4B28: 81440DB0  lwz r10, 0xdb0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821C4B2C: 390B00C0  addi r8, r11, 0xc0
	ctx.r[8].s64 = ctx.r[11].s64 + 192;
	// 821C4B30: 992B00D4  stb r9, 0xd4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[9].u8 ) };
	// 821C4B34: 5546103A  slwi r6, r10, 2
	ctx.r[6].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821C4B38: 38EA0001  addi r7, r10, 1
	ctx.r[7].s64 = ctx.r[10].s64 + 1;
	// 821C4B3C: 90E40DB0  stw r7, 0xdb0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(3504 as u32), ctx.r[7].u32 ) };
	// 821C4B40: 7D06192E  stwx r8, r6, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[3].u32), ctx.r[8].u32) };
	// 821C4B44: 48000008  b 0x821c4b4c
	pc = 0x821C4B4C; continue 'dispatch;
            }
            0x821C4B48 => {
    //   block [0x821C4B48..0x821C4B4C)
	// 821C4B48: 80E40DB0  lwz r7, 0xdb0(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(3504 as u32) ) } as u64;
	pc = 0x821C4B4C; continue 'dispatch;
            }
            0x821C4B4C => {
    //   block [0x821C4B4C..0x821C4BB4)
	// 821C4B4C: 894B00BD  lbz r10, 0xbd(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(189 as u32) ) } as u64;
	// 821C4B50: 812B00AC  lwz r9, 0xac(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(172 as u32) ) } as u64;
	// 821C4B54: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821C4B58: 7D4A2A14  add r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[5].u64;
	// 821C4B5C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C4B60: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C4B64: 419A0080  beq cr6, 0x821c4be4
	if ctx.cr[6].eq {
	pc = 0x821C4BE4; continue 'dispatch;
	}
	// 821C4B68: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C4B6C: 810B00B0  lwz r8, 0xb0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(176 as u32) ) } as u64;
	// 821C4B70: 7D264038  and r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821C4B74: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821C4B78: 409A003C  bne cr6, 0x821c4bb4
	if !ctx.cr[6].eq {
	pc = 0x821C4BB4; continue 'dispatch;
	}
	// 821C4B7C: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C4B80: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821C4B84: 390B00A8  addi r8, r11, 0xa8
	ctx.r[8].s64 = ctx.r[11].s64 + 168;
	// 821C4B88: 54C61838  slwi r6, r6, 3
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821C4B8C: 912B00B0  stw r9, 0xb0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(176 as u32), ctx.r[9].u32 ) };
	// 821C4B90: 7D06512E  stwx r8, r6, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u32) };
	// 821C4B94: 812B00AC  lwz r9, 0xac(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(172 as u32) ) } as u64;
	// 821C4B98: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C4B9C: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C4BA0: 7CC85214  add r6, r8, r10
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C4BA4: 91260004  stw r9, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C4BA8: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C4BAC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821C4BB0: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	pc = 0x821C4BB4; continue 'dispatch;
            }
            0x821C4BB4 => {
    //   block [0x821C4BB4..0x821C4BE4)
	// 821C4BB4: 894B00BC  lbz r10, 0xbc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) } as u64;
	// 821C4BB8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821C4BBC: 912B00AC  stw r9, 0xac(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(172 as u32), ctx.r[9].u32 ) };
	// 821C4BC0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C4BC4: 409A0020  bne cr6, 0x821c4be4
	if !ctx.cr[6].eq {
	pc = 0x821C4BE4; continue 'dispatch;
	}
	// 821C4BC8: 54E9103A  slwi r9, r7, 2
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C4BCC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C4BD0: 390B00A8  addi r8, r11, 0xa8
	ctx.r[8].s64 = ctx.r[11].s64 + 168;
	// 821C4BD4: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 821C4BD8: 994B00BC  stb r10, 0xbc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(188 as u32), ctx.r[10].u8 ) };
	// 821C4BDC: 90E40DB0  stw r7, 0xdb0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(3504 as u32), ctx.r[7].u32 ) };
	// 821C4BE0: 7D09192E  stwx r8, r9, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[3].u32), ctx.r[8].u32) };
	pc = 0x821C4BE4; continue 'dispatch;
            }
            0x821C4BE4 => {
    //   block [0x821C4BE4..0x821C4C4C)
	// 821C4BE4: 894B19F5  lbz r10, 0x19f5(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6645 as u32) ) } as u64;
	// 821C4BE8: 812B19E4  lwz r9, 0x19e4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6628 as u32) ) } as u64;
	// 821C4BEC: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821C4BF0: 7D4A2A14  add r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[5].u64;
	// 821C4BF4: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 821C4BF8: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C4BFC: 419A0080  beq cr6, 0x821c4c7c
	if ctx.cr[6].eq {
	pc = 0x821C4C7C; continue 'dispatch;
	}
	// 821C4C00: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C4C04: 810B19E8  lwz r8, 0x19e8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6632 as u32) ) } as u64;
	// 821C4C08: 7D264038  and r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821C4C0C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821C4C10: 409A003C  bne cr6, 0x821c4c4c
	if !ctx.cr[6].eq {
	pc = 0x821C4C4C; continue 'dispatch;
	}
	// 821C4C14: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C4C18: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821C4C1C: 390B19E0  addi r8, r11, 0x19e0
	ctx.r[8].s64 = ctx.r[11].s64 + 6624;
	// 821C4C20: 54C61838  slwi r6, r6, 3
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821C4C24: 912B19E8  stw r9, 0x19e8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6632 as u32), ctx.r[9].u32 ) };
	// 821C4C28: 7D06512E  stwx r8, r6, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u32) };
	// 821C4C2C: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C4C30: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C4C34: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C4C38: 812B19E4  lwz r9, 0x19e4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6628 as u32) ) } as u64;
	// 821C4C3C: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C4C40: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C4C44: 38C90001  addi r6, r9, 1
	ctx.r[6].s64 = ctx.r[9].s64 + 1;
	// 821C4C48: 90CA2004  stw r6, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[6].u32 ) };
	pc = 0x821C4C4C; continue 'dispatch;
            }
            0x821C4C4C => {
    //   block [0x821C4C4C..0x821C4C7C)
	// 821C4C4C: 894B19F4  lbz r10, 0x19f4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6644 as u32) ) } as u64;
	// 821C4C50: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821C4C54: 912B19E4  stw r9, 0x19e4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6628 as u32), ctx.r[9].u32 ) };
	// 821C4C58: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C4C5C: 409A0020  bne cr6, 0x821c4c7c
	if !ctx.cr[6].eq {
	pc = 0x821C4C7C; continue 'dispatch;
	}
	// 821C4C60: 54E9103A  slwi r9, r7, 2
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C4C64: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C4C68: 390B19E0  addi r8, r11, 0x19e0
	ctx.r[8].s64 = ctx.r[11].s64 + 6624;
	// 821C4C6C: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 821C4C70: 994B19F4  stb r10, 0x19f4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6644 as u32), ctx.r[10].u8 ) };
	// 821C4C74: 90E40DB0  stw r7, 0xdb0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(3504 as u32), ctx.r[7].u32 ) };
	// 821C4C78: 7D09192E  stwx r8, r9, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[3].u32), ctx.r[8].u32) };
	pc = 0x821C4C7C; continue 'dispatch;
            }
            0x821C4C7C => {
    //   block [0x821C4C7C..0x821C4CE4)
	// 821C4C7C: 894B1A0D  lbz r10, 0x1a0d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6669 as u32) ) } as u64;
	// 821C4C80: 812B19FC  lwz r9, 0x19fc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6652 as u32) ) } as u64;
	// 821C4C84: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821C4C88: 7D4A2A14  add r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[5].u64;
	// 821C4C8C: 2B0900AA  cmplwi cr6, r9, 0xaa
	ctx.cr[6].compare_u32(ctx.r[9].u32, 170 as u32, &mut ctx.xer);
	// 821C4C90: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C4C94: 419A0080  beq cr6, 0x821c4d14
	if ctx.cr[6].eq {
	pc = 0x821C4D14; continue 'dispatch;
	}
	// 821C4C98: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C4C9C: 810B1A00  lwz r8, 0x1a00(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6656 as u32) ) } as u64;
	// 821C4CA0: 7D264038  and r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821C4CA4: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821C4CA8: 409A003C  bne cr6, 0x821c4ce4
	if !ctx.cr[6].eq {
	pc = 0x821C4CE4; continue 'dispatch;
	}
	// 821C4CAC: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C4CB0: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821C4CB4: 390B19F8  addi r8, r11, 0x19f8
	ctx.r[8].s64 = ctx.r[11].s64 + 6648;
	// 821C4CB8: 54C61838  slwi r6, r6, 3
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821C4CBC: 912B1A00  stw r9, 0x1a00(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6656 as u32), ctx.r[9].u32 ) };
	// 821C4CC0: 7D06512E  stwx r8, r6, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u32) };
	// 821C4CC4: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C4CC8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C4CCC: 812B19FC  lwz r9, 0x19fc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6652 as u32) ) } as u64;
	// 821C4CD0: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C4CD4: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C4CD8: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C4CDC: 38C90001  addi r6, r9, 1
	ctx.r[6].s64 = ctx.r[9].s64 + 1;
	// 821C4CE0: 90CA2004  stw r6, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[6].u32 ) };
	pc = 0x821C4CE4; continue 'dispatch;
            }
            0x821C4CE4 => {
    //   block [0x821C4CE4..0x821C4D14)
	// 821C4CE4: 894B1A0C  lbz r10, 0x1a0c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6668 as u32) ) } as u64;
	// 821C4CE8: 392000AA  li r9, 0xaa
	ctx.r[9].s64 = 170;
	// 821C4CEC: 912B19FC  stw r9, 0x19fc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6652 as u32), ctx.r[9].u32 ) };
	// 821C4CF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C4CF4: 409A0020  bne cr6, 0x821c4d14
	if !ctx.cr[6].eq {
	pc = 0x821C4D14; continue 'dispatch;
	}
	// 821C4CF8: 54E9103A  slwi r9, r7, 2
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C4CFC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C4D00: 390B19F8  addi r8, r11, 0x19f8
	ctx.r[8].s64 = ctx.r[11].s64 + 6648;
	// 821C4D04: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 821C4D08: 994B1A0C  stb r10, 0x1a0c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6668 as u32), ctx.r[10].u8 ) };
	// 821C4D0C: 90E40DB0  stw r7, 0xdb0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(3504 as u32), ctx.r[7].u32 ) };
	// 821C4D10: 7D09192E  stwx r8, r9, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[3].u32), ctx.r[8].u32) };
	pc = 0x821C4D14; continue 'dispatch;
            }
            0x821C4D14 => {
    //   block [0x821C4D14..0x821C4D88)
	// 821C4D14: 3D008331  lis r8, -0x7ccf
	ctx.r[8].s64 = -2093940736;
	// 821C4D18: 88CB008D  lbz r6, 0x8d(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(141 as u32) ) } as u64;
	// 821C4D1C: 812B007C  lwz r9, 0x7c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821C4D20: 39087064  addi r8, r8, 0x7064
	ctx.r[8].s64 = ctx.r[8].s64 + 28772;
	// 821C4D24: 1D462008  mulli r10, r6, 0x2008
	ctx.r[10].s32 = ((ctx.r[6].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821C4D28: 80C80008  lwz r6, 8(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C4D2C: 7D4A2A14  add r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[5].u64;
	// 821C4D30: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C4D34: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C4D38: 419A007C  beq cr6, 0x821c4db4
	if ctx.cr[6].eq {
	pc = 0x821C4DB4; continue 'dispatch;
	}
	// 821C4D3C: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C4D40: 810B0080  lwz r8, 0x80(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 821C4D44: 7D254038  and r5, r9, r8
	ctx.r[5].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821C4D48: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821C4D4C: 409A003C  bne cr6, 0x821c4d88
	if !ctx.cr[6].eq {
	pc = 0x821C4D88; continue 'dispatch;
	}
	// 821C4D50: 80AA2004  lwz r5, 0x2004(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C4D54: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821C4D58: 390B0078  addi r8, r11, 0x78
	ctx.r[8].s64 = ctx.r[11].s64 + 120;
	// 821C4D5C: 54A51838  slwi r5, r5, 3
	ctx.r[5].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821C4D60: 912B0080  stw r9, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 821C4D64: 7D05512E  stwx r8, r5, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u32) };
	// 821C4D68: 812B007C  lwz r9, 0x7c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821C4D6C: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C4D70: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C4D74: 7CA85214  add r5, r8, r10
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C4D78: 91250004  stw r9, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C4D7C: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C4D80: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821C4D84: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	pc = 0x821C4D88; continue 'dispatch;
            }
            0x821C4D88 => {
    //   block [0x821C4D88..0x821C4DB4)
	// 821C4D88: 894B008C  lbz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C4D8C: 90CB007C  stw r6, 0x7c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(124 as u32), ctx.r[6].u32 ) };
	// 821C4D90: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C4D94: 409A0020  bne cr6, 0x821c4db4
	if !ctx.cr[6].eq {
	pc = 0x821C4DB4; continue 'dispatch;
	}
	// 821C4D98: 54E8103A  slwi r8, r7, 2
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C4D9C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C4DA0: 38CB0078  addi r6, r11, 0x78
	ctx.r[6].s64 = ctx.r[11].s64 + 120;
	// 821C4DA4: 39270001  addi r9, r7, 1
	ctx.r[9].s64 = ctx.r[7].s64 + 1;
	// 821C4DA8: 994B008C  stb r10, 0x8c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), ctx.r[10].u8 ) };
	// 821C4DAC: 91240DB0  stw r9, 0xdb0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(3504 as u32), ctx.r[9].u32 ) };
	// 821C4DB0: 7CC8192E  stwx r6, r8, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[3].u32), ctx.r[6].u32) };
	pc = 0x821C4DB4; continue 'dispatch;
            }
            0x821C4DB4 => {
    //   block [0x821C4DB4..0x821C4DD4)
	// 821C4DB4: 83FD0004  lwz r31, 4(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C4DB8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821C4DBC: 389F0150  addi r4, r31, 0x150
	ctx.r[4].s64 = ctx.r[31].s64 + 336;
	// 821C4DC0: 480ABF11  bl 0x82270cd0
	ctx.lr = 0x821C4DC4;
	sub_82270CD0(ctx, base);
	// 821C4DC4: 397F0110  addi r11, r31, 0x110
	ctx.r[11].s64 = ctx.r[31].s64 + 272;
	// 821C4DC8: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 821C4DCC: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821C4DD0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x821C4DD4; continue 'dispatch;
            }
            0x821C4DD4 => {
    //   block [0x821C4DD4..0x821C4F44)
	// 821C4DD4: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821C4DD8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821C4DDC: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821C4DE0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C4DE4: 4200FFF0  bdnz 0x821c4dd4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821C4DD4; continue 'dispatch;
	}
	// 821C4DE8: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 821C4DEC: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 821C4DF0: 480ABEE1  bl 0x82270cd0
	ctx.lr = 0x821C4DF4;
	sub_82270CD0(ctx, base);
	// 821C4DF4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821C4DF8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821C4DFC: 3BCB9490  addi r30, r11, -0x6b70
	ctx.r[30].s64 = ctx.r[11].s64 + -27504;
	// 821C4E00: 39210094  addi r9, r1, 0x94
	ctx.r[9].s64 = ctx.r[1].s64 + 148;
	// 821C4E04: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 821C4E08: 38E10098  addi r7, r1, 0x98
	ctx.r[7].s64 = ctx.r[1].s64 + 152;
	// 821C4E0C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821C4E10: C01EFFF4  lfs f0, -0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C4E14: 3CA0820A  lis r5, -0x7df6
	ctx.r[5].s64 = -2113273856;
	// 821C4E18: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821C4E1C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C4F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C4F48 size=1796
    let mut pc: u32 = 0x821C4F48;
    'dispatch: loop {
        match pc {
            0x821C4F48 => {
    //   block [0x821C4F48..0x821C564C)
	// 821C4F48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C4F4C: 48AE44BD  bl 0x82ca9408
	ctx.lr = 0x821C4F50;
	sub_82CA93D0(ctx, base);
	// 821C4F50: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C4F54: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821C4F58: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821C4F5C: 39200470  li r9, 0x470
	ctx.r[9].s64 = 1136;
	// 821C4F60: 3BAB93BC  addi r29, r11, -0x6c44
	ctx.r[29].s64 = ctx.r[11].s64 + -27716;
	// 821C4F64: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 821C4F68: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C4F6C: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 821C4F70: C01D3800  lfs f0, 0x3800(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(14336 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C4F74: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 821C4F78: 80CA0014  lwz r6, 0x14(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C4F7C: C1879A80  lfs f12, -0x6580(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821C4F80: C1BD2E64  lfs f13, 0x2e64(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(11876 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821C4F84: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C5650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C5650 size=196
    let mut pc: u32 = 0x821C5650;
    'dispatch: loop {
        match pc {
            0x821C5650 => {
    //   block [0x821C5650..0x821C5714)
	// 821C5650: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 821C5654: 39800020  li r12, 0x20
	ctx.r[12].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C5718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C5718 size=76
    let mut pc: u32 = 0x821C5718;
    'dispatch: loop {
        match pc {
            0x821C5718 => {
    //   block [0x821C5718..0x821C5750)
	// 821C5718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C571C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C5720: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C5724: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C5728: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C572C: 897F000C  lbz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C5730: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5734: 419A001C  beq cr6, 0x821c5750
	if ctx.cr[6].eq {
	pc = 0x821C5750; continue 'dispatch;
	}
	// 821C5738: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 821C573C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C5740: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5744: 4826068D  bl 0x82425dd0
	ctx.lr = 0x821C5748;
	sub_82425DD0(ctx, base);
	// 821C5748: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C574C: 997F000C  stb r11, 0xc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	pc = 0x821C5750; continue 'dispatch;
            }
            0x821C5750 => {
    //   block [0x821C5750..0x821C5764)
	// 821C5750: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C5754: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C5758: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C575C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C5760: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C5768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C5768 size=1096
    let mut pc: u32 = 0x821C5768;
    'dispatch: loop {
        match pc {
            0x821C5768 => {
    //   block [0x821C5768..0x821C57A4)
	// 821C5768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C576C: 48AE3C75  bl 0x82ca93e0
	ctx.lr = 0x821C5770;
	sub_82CA93D0(ctx, base);
	// 821C5770: DBE1FF80  stfd f31, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 821C5774: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C5778: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C577C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821C5780: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821C5784: 3BEB8214  addi r31, r11, -0x7dec
	ctx.r[31].s64 = ctx.r[11].s64 + -32236;
	// 821C5788: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C578C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5790: 419A00E8  beq cr6, 0x821c5878
	if ctx.cr[6].eq {
	pc = 0x821C5878; continue 'dispatch;
	}
	// 821C5794: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5798: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 821C579C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C57A0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x821C57A4; continue 'dispatch;
            }
            0x821C57A4 => {
    //   block [0x821C57A4..0x821C57B8)
	// 821C57A4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821C57A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C57AC: 419A000C  beq cr6, 0x821c57b8
	if ctx.cr[6].eq {
	pc = 0x821C57B8; continue 'dispatch;
	}
	// 821C57B0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821C57B4: 419A0008  beq cr6, 0x821c57bc
	if ctx.cr[6].eq {
	pc = 0x821C57BC; continue 'dispatch;
	}
	pc = 0x821C57B8; continue 'dispatch;
            }
            0x821C57B8 => {
    //   block [0x821C57B8..0x821C57BC)
	// 821C57B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C57BC; continue 'dispatch;
            }
            0x821C57BC => {
    //   block [0x821C57BC..0x821C57EC)
	// 821C57BC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C57C0: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821C57C4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C57C8: 419A00A8  beq cr6, 0x821c5870
	if ctx.cr[6].eq {
	pc = 0x821C5870; continue 'dispatch;
	}
	// 821C57CC: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821C57D0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821C57D4: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821C57D8: 488D6D41  bl 0x82a9c518
	ctx.lr = 0x821C57DC;
	sub_82A9C518(ctx, base);
	// 821C57DC: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821C57E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C57E4: 409A0008  bne cr6, 0x821c57ec
	if !ctx.cr[6].eq {
	pc = 0x821C57EC; continue 'dispatch;
	}
	// 821C57E8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C57EC; continue 'dispatch;
            }
            0x821C57EC => {
    //   block [0x821C57EC..0x821C5800)
	// 821C57EC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C57F0: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821C57F4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821C57F8: 409A0008  bne cr6, 0x821c5800
	if !ctx.cr[6].eq {
	pc = 0x821C5800; continue 'dispatch;
	}
	// 821C57FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C5800; continue 'dispatch;
            }
            0x821C5800 => {
    //   block [0x821C5800..0x821C5844)
	// 821C5800: 394B000C  addi r10, r11, 0xc
	ctx.r[10].s64 = ctx.r[11].s64 + 12;
	// 821C5804: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C5808: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	// 821C580C: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C5810: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C5814: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C5818: 419AFF8C  beq cr6, 0x821c57a4
	if ctx.cr[6].eq {
	pc = 0x821C57A4; continue 'dispatch;
	}
	// 821C581C: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5820: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821C5824: 419A0020  beq cr6, 0x821c5844
	if ctx.cr[6].eq {
	pc = 0x821C5844; continue 'dispatch;
	}
	// 821C5828: 550B003E  slwi r11, r8, 0
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C582C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5830: 419AFF74  beq cr6, 0x821c57a4
	if ctx.cr[6].eq {
	pc = 0x821C57A4; continue 'dispatch;
	}
	// 821C5834: 2F090002  cmpwi cr6, r9, 2
	ctx.cr[6].compare_i32(ctx.r[9].s32, 2, &mut ctx.xer);
	// 821C5838: 409A0018  bne cr6, 0x821c5850
	if !ctx.cr[6].eq {
	pc = 0x821C5850; continue 'dispatch;
	}
	// 821C583C: 4852B955  bl 0x826f1190
	ctx.lr = 0x821C5840;
	sub_826F1190(ctx, base);
	// 821C5840: 4BFFFF64  b 0x821c57a4
	pc = 0x821C57A4; continue 'dispatch;
            }
            0x821C5844 => {
    //   block [0x821C5844..0x821C5850)
	// 821C5844: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821C5848: 4BFCE5F1  bl 0x82193e38
	ctx.lr = 0x821C584C;
	sub_82193E38(ctx, base);
	// 821C584C: 4BFFFF58  b 0x821c57a4
	pc = 0x821C57A4; continue 'dispatch;
            }
            0x821C5850 => {
    //   block [0x821C5850..0x821C5860)
	// 821C5850: 2F090003  cmpwi cr6, r9, 3
	ctx.cr[6].compare_i32(ctx.r[9].s32, 3, &mut ctx.xer);
	// 821C5854: 409A000C  bne cr6, 0x821c5860
	if !ctx.cr[6].eq {
	pc = 0x821C5860; continue 'dispatch;
	}
	// 821C5858: 4852BBC1  bl 0x826f1418
	ctx.lr = 0x821C585C;
	sub_826F1418(ctx, base);
	// 821C585C: 4BFFFF48  b 0x821c57a4
	pc = 0x821C57A4; continue 'dispatch;
            }
            0x821C5860 => {
    //   block [0x821C5860..0x821C5870)
	// 821C5860: 2F090004  cmpwi cr6, r9, 4
	ctx.cr[6].compare_i32(ctx.r[9].s32, 4, &mut ctx.xer);
	// 821C5864: 409AFF40  bne cr6, 0x821c57a4
	if !ctx.cr[6].eq {
	pc = 0x821C57A4; continue 'dispatch;
	}
	// 821C5868: 4852BA79  bl 0x826f12e0
	ctx.lr = 0x821C586C;
	sub_826F12E0(ctx, base);
	// 821C586C: 4BFFFF38  b 0x821c57a4
	pc = 0x821C57A4; continue 'dispatch;
            }
            0x821C5870 => {
    //   block [0x821C5870..0x821C5878)
	// 821C5870: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C5874: 4829036D  bl 0x82455be0
	ctx.lr = 0x821C5878;
	sub_82455BE0(ctx, base);
	pc = 0x821C5878; continue 'dispatch;
            }
            0x821C5878 => {
    //   block [0x821C5878..0x821C5920)
	// 821C5878: 897E0020  lbz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 821C587C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5880: 419A0324  beq cr6, 0x821c5ba4
	if ctx.cr[6].eq {
	pc = 0x821C5BA4; continue 'dispatch;
	}
	// 821C5884: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5888: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821C588C: 419A0318  beq cr6, 0x821c5ba4
	if ctx.cr[6].eq {
	pc = 0x821C5BA4; continue 'dispatch;
	}
	// 821C5890: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 821C5894: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821C5898: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C589C: 997F6BC6  stb r11, 0x6bc6(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(27590 as u32), ctx.r[11].u8 ) };
	// 821C58A0: 48BB2BD1  bl 0x82d78470
	ctx.lr = 0x821C58A4;
	sub_82D78470(ctx, base);
	// 821C58A4: 3E40834C  lis r18, -0x7cb4
	ctx.r[18].s64 = -2092171264;
	// 821C58A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C58AC: 997F6BC6  stb r11, 0x6bc6(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(27590 as u32), ctx.r[11].u8 ) };
	// 821C58B0: 8972EA0E  lbz r11, -0x15f2(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[18].u32.wrapping_add(-5618 as u32) ) } as u64;
	// 821C58B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C58B8: 419A02EC  beq cr6, 0x821c5ba4
	if ctx.cr[6].eq {
	pc = 0x821C5BA4; continue 'dispatch;
	}
	// 821C58BC: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C58C0: 48BB3601  bl 0x82d78ec0
	ctx.lr = 0x821C58C4;
	sub_82D78EC0(ctx, base);
	// 821C58C4: 82ED0000  lwz r23, 0(r13)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C58C8: 3AC00004  li r22, 4
	ctx.r[22].s64 = 4;
	// 821C58CC: 38A0002E  li r5, 0x2e
	ctx.r[5].s64 = 46;
	// 821C58D0: 38800044  li r4, 0x44
	ctx.r[4].s64 = 68;
	// 821C58D4: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 821C58D8: 7C76B82E  lwzx r3, r22, r23
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 821C58DC: 48B8F96D  bl 0x82d55248
	ctx.lr = 0x821C58E0;
	sub_82D55248(ctx, base);
	// 821C58E0: 39600044  li r11, 0x44
	ctx.r[11].s64 = 68;
	// 821C58E4: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 821C58E8: 48BBD581  bl 0x82d82e68
	ctx.lr = 0x821C58EC;
	sub_82D82E68(ctx, base);
	// 821C58EC: 8153000C  lwz r10, 0xc(r19)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C58F0: 3B930008  addi r28, r19, 8
	ctx.r[28].s64 = ctx.r[19].s64 + 8;
	// 821C58F4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821C58F8: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 821C58FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C5900: 419A00E0  beq cr6, 0x821c59e0
	if ctx.cr[6].eq {
	pc = 0x821C59E0; continue 'dispatch;
	}
	// 821C5904: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821C5908: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 821C590C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821C5910: 3EA0834C  lis r21, -0x7cb4
	ctx.r[21].s64 = -2092171264;
	// 821C5914: 3E80834C  lis r20, -0x7cb4
	ctx.r[20].s64 = -2092171264;
	// 821C5918: 3B0B0CA0  addi r24, r11, 0xca0
	ctx.r[24].s64 = ctx.r[11].s64 + 3232;
	// 821C591C: 3B6A6E58  addi r27, r10, 0x6e58
	ctx.r[27].s64 = ctx.r[10].s64 + 28248;
	pc = 0x821C5920; continue 'dispatch;
            }
            0x821C5920 => {
    //   block [0x821C5920..0x821C594C)
	// 821C5920: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5924: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821C5928: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821C592C: 7FDA582E  lwzx r30, r26, r11
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821C5930: 809E0070  lwz r4, 0x70(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) } as u64;
	// 821C5934: 4806759D  bl 0x8222ced0
	ctx.lr = 0x821C5938;
	sub_8222CED0(ctx, base);
	// 821C5938: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C593C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5940: 409A0038  bne cr6, 0x821c5978
	if !ctx.cr[6].eq {
	pc = 0x821C5978; continue 'dispatch;
	}
	// 821C5944: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 821C5948: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x821C594C; continue 'dispatch;
            }
            0x821C594C => {
    //   block [0x821C594C..0x821C5970)
	// 821C594C: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5950: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5954: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821C5958: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821C595C: 419A0014  beq cr6, 0x821c5970
	if ctx.cr[6].eq {
	pc = 0x821C5970; continue 'dispatch;
	}
	// 821C5960: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821C5964: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821C5968: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821C596C: 419AFFE0  beq cr6, 0x821c594c
	if ctx.cr[6].eq {
	pc = 0x821C594C; continue 'dispatch;
	}
	pc = 0x821C5970; continue 'dispatch;
            }
            0x821C5970 => {
    //   block [0x821C5970..0x821C5978)
	// 821C5970: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821C5974: 48000014  b 0x821c5988
	pc = 0x821C5988; continue 'dispatch;
            }
            0x821C5978 => {
    //   block [0x821C5978..0x821C5988)
	// 821C5978: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821C597C: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5980: 480A7E79  bl 0x8226d7f8
	ctx.lr = 0x821C5984;
	sub_8226D7F8(ctx, base);
	// 821C5984: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	pc = 0x821C5988; continue 'dispatch;
            }
            0x821C5988 => {
    //   block [0x821C5988..0x821C59A8)
	// 821C5988: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821C598C: 557FDFFE  rlwinm r31, r11, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821C5990: 4804F449  bl 0x82214dd8
	ctx.lr = 0x821C5994;
	sub_82214DD8(ctx, base);
	// 821C5994: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 821C5998: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C599C: 419A000C  beq cr6, 0x821c59a8
	if ctx.cr[6].eq {
	pc = 0x821C59A8; continue 'dispatch;
	}
	// 821C59A0: 8974EA0F  lbz r11, -0x15f1(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[20].u32.wrapping_add(-5617 as u32) ) } as u64;
	// 821C59A4: 48000014  b 0x821c59b8
	pc = 0x821C59B8; continue 'dispatch;
            }
            0x821C59A8 => {
    //   block [0x821C59A8..0x821C59B8)
	// 821C59A8: 897E00D8  lbz r11, 0xd8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(216 as u32) ) } as u64;
	// 821C59AC: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 821C59B0: 409A0010  bne cr6, 0x821c59c0
	if !ctx.cr[6].eq {
	pc = 0x821C59C0; continue 'dispatch;
	}
	// 821C59B4: 8975EA10  lbz r11, -0x15f0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[21].u32.wrapping_add(-5616 as u32) ) } as u64;
	pc = 0x821C59B8; continue 'dispatch;
            }
            0x821C59B8 => {
    //   block [0x821C59B8..0x821C59C0)
	// 821C59B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C59BC: 419A0010  beq cr6, 0x821c59cc
	if ctx.cr[6].eq {
	pc = 0x821C59CC; continue 'dispatch;
	}
	pc = 0x821C59C0; continue 'dispatch;
            }
            0x821C59C0 => {
    //   block [0x821C59C0..0x821C59CC)
	// 821C59C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821C59C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821C59C8: 48BBDA21  bl 0x82d833e8
	ctx.lr = 0x821C59CC;
	sub_82D833E8(ctx, base);
	pc = 0x821C59CC; continue 'dispatch;
            }
            0x821C59CC => {
    //   block [0x821C59CC..0x821C59E0)
	// 821C59CC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C59D0: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 821C59D4: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 821C59D8: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C59DC: 409AFF44  bne cr6, 0x821c5920
	if !ctx.cr[6].eq {
	pc = 0x821C5920; continue 'dispatch;
	}
	pc = 0x821C59E0; continue 'dispatch;
            }
            0x821C59E0 => {
    //   block [0x821C59E0..0x821C5A18)
	// 821C59E0: 38A0000D  li r5, 0xd
	ctx.r[5].s64 = 13;
	// 821C59E4: 7C76B82E  lwzx r3, r22, r23
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 821C59E8: 38800018  li r4, 0x18
	ctx.r[4].s64 = 24;
	// 821C59EC: 48B8F85D  bl 0x82d55248
	ctx.lr = 0x821C59F0;
	sub_82D55248(ctx, base);
	// 821C59F0: 39600018  li r11, 0x18
	ctx.r[11].s64 = 24;
	// 821C59F4: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 821C59F8: 48C85A11  bl 0x82e4b408
	ctx.lr = 0x821C59FC;
	sub_82E4B408(ctx, base);
	// 821C59FC: A15D0004  lhz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5A00: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821C5A04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C5A08: 419A0010  beq cr6, 0x821c5a18
	if ctx.cr[6].eq {
	pc = 0x821C5A18; continue 'dispatch;
	}
	// 821C5A0C: A17D0006  lhz r11, 6(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(6 as u32) ) } as u64;
	// 821C5A10: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 821C5A14: B15D0006  sth r10, 6(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	pc = 0x821C5A18; continue 'dispatch;
            }
            0x821C5A18 => {
    //   block [0x821C5A18..0x821C5A3C)
	// 821C5A18: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C5A1C: 3BFE000C  addi r31, r30, 0xc
	ctx.r[31].s64 = ctx.r[30].s64 + 12;
	// 821C5A20: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C5A24: 556900BE  clrlwi r9, r11, 2
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 821C5A28: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821C5A2C: 409A0010  bne cr6, 0x821c5a3c
	if !ctx.cr[6].eq {
	pc = 0x821C5A3C; continue 'dispatch;
	}
	// 821C5A30: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 821C5A34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C5A38: 48B91561  bl 0x82d56f98
	ctx.lr = 0x821C5A3C;
	sub_82D56F98(ctx, base);
	pc = 0x821C5A3C; continue 'dispatch;
            }
            0x821C5A3C => {
    //   block [0x821C5A3C..0x821C5AE8)
	// 821C5A3C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5A40: 38A00019  li r5, 0x19
	ctx.r[5].s64 = 25;
	// 821C5A44: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5A48: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 821C5A4C: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C5A50: 7C76B82E  lwzx r3, r22, r23
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 821C5A54: 7FA9512E  stwx r29, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[29].u32) };
	// 821C5A58: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5A5C: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 821C5A60: 911F0004  stw r8, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821C5A64: 48B8F7E5  bl 0x82d55248
	ctx.lr = 0x821C5A68;
	sub_82D55248(ctx, base);
	// 821C5A68: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 821C5A6C: 3CC0820B  lis r6, -0x7df5
	ctx.r[6].s64 = -2113208320;
	// 821C5A70: B0E30004  sth r7, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u16 ) };
	// 821C5A74: 38866E64  addi r4, r6, 0x6e64
	ctx.r[4].s64 = ctx.r[6].s64 + 28260;
	// 821C5A78: 4828D709  bl 0x82453180
	ctx.lr = 0x821C5A7C;
	sub_82453180(ctx, base);
	// 821C5A7C: 3C80834C  lis r4, -0x7cb4
	ctx.r[4].s64 = -2092171264;
	// 821C5A80: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821C5A84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C5A88: 3D208202  lis r9, -0x7dfe
	ctx.r[9].s64 = -2113798144;
	// 821C5A8C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821C5A90: 8964EA11  lbz r11, -0x15ef(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(-5615 as u32) ) } as u64;
	// 821C5A94: 38E96A98  addi r7, r9, 0x6a98
	ctx.r[7].s64 = ctx.r[9].s64 + 27288;
	// 821C5A98: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821C5A9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C5AA0: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 821C5AA4: 88CA0000  lbz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5AA8: 48C86951  bl 0x82e4c3f8
	ctx.lr = 0x821C5AAC;
	sub_82E4C3F8(ctx, base);
	// 821C5AAC: A11F0004  lhz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5AB0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821C5AB4: 419A0034  beq cr6, 0x821c5ae8
	if ctx.cr[6].eq {
	pc = 0x821C5AE8; continue 'dispatch;
	}
	// 821C5AB8: A17F0006  lhz r11, 6(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 821C5ABC: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 821C5AC0: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 821C5AC4: B13F0006  sth r9, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 821C5AC8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821C5ACC: 409A001C  bne cr6, 0x821c5ae8
	if !ctx.cr[6].eq {
	pc = 0x821C5AE8; continue 'dispatch;
	}
	// 821C5AD0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5AD4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821C5AD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C5ADC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5AE0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C5AE4: 4E800421  bctrl
	ctx.lr = 0x821C5AE8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821C5AE8 => {
    //   block [0x821C5AE8..0x821C5B24)
	// 821C5AE8: A17E0004  lhz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5AEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5AF0: 419A0034  beq cr6, 0x821c5b24
	if ctx.cr[6].eq {
	pc = 0x821C5B24; continue 'dispatch;
	}
	// 821C5AF4: A17E0006  lhz r11, 6(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 821C5AF8: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 821C5AFC: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 821C5B00: B13E0006  sth r9, 6(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 821C5B04: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821C5B08: 409A001C  bne cr6, 0x821c5b24
	if !ctx.cr[6].eq {
	pc = 0x821C5B24; continue 'dispatch;
	}
	// 821C5B0C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5B10: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821C5B14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C5B18: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5B1C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C5B20: 4E800421  bctrl
	ctx.lr = 0x821C5B24;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821C5B24 => {
    //   block [0x821C5B24..0x821C5B60)
	// 821C5B24: A17D0004  lhz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5B28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5B2C: 419A0034  beq cr6, 0x821c5b60
	if ctx.cr[6].eq {
	pc = 0x821C5B60; continue 'dispatch;
	}
	// 821C5B30: A17D0006  lhz r11, 6(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(6 as u32) ) } as u64;
	// 821C5B34: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 821C5B38: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 821C5B3C: B13D0006  sth r9, 6(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 821C5B40: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821C5B44: 409A001C  bne cr6, 0x821c5b60
	if !ctx.cr[6].eq {
	pc = 0x821C5B60; continue 'dispatch;
	}
	// 821C5B48: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5B4C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821C5B50: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821C5B54: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5B58: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C5B5C: 4E800421  bctrl
	ctx.lr = 0x821C5B60;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821C5B60 => {
    //   block [0x821C5B60..0x821C5B9C)
	// 821C5B60: A1730004  lhz r11, 4(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[19].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5B64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5B68: 419A0034  beq cr6, 0x821c5b9c
	if ctx.cr[6].eq {
	pc = 0x821C5B9C; continue 'dispatch;
	}
	// 821C5B6C: A1730006  lhz r11, 6(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[19].u32.wrapping_add(6 as u32) ) } as u64;
	// 821C5B70: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 821C5B74: 7D490734  extsh r9, r10
	ctx.r[9].s64 = ctx.r[10].s16 as i64;
	// 821C5B78: B1330006  sth r9, 6(r19)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[19].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 821C5B7C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821C5B80: 409A001C  bne cr6, 0x821c5b9c
	if !ctx.cr[6].eq {
	pc = 0x821C5B9C; continue 'dispatch;
	}
	// 821C5B84: 81730000  lwz r11, 0(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5B88: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821C5B8C: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 821C5B90: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5B94: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C5B98: 4E800421  bctrl
	ctx.lr = 0x821C5B9C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821C5B9C => {
    //   block [0x821C5B9C..0x821C5BA4)
	// 821C5B9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C5BA0: 9972EA0E  stb r11, -0x15f2(r18)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[18].u32.wrapping_add(-5618 as u32), ctx.r[11].u8 ) };
	pc = 0x821C5BA4; continue 'dispatch;
            }
            0x821C5BA4 => {
    //   block [0x821C5BA4..0x821C5BB0)
	// 821C5BA4: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 821C5BA8: CBE1FF80  lfd f31, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 821C5BAC: 48AE3884  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C5BB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C5BB0 size=2248
    let mut pc: u32 = 0x821C5BB0;
    'dispatch: loop {
        match pc {
            0x821C5BB0 => {
    //   block [0x821C5BB0..0x821C5C44)
	// 821C5BB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C5BB4: 48AE384D  bl 0x82ca9400
	ctx.lr = 0x821C5BB8;
	sub_82CA93D0(ctx, base);
	// 821C5BB8: DBA1FFB0  stfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[29].u64 ) };
	// 821C5BBC: DBC1FFB8  stfd f30, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 821C5BC0: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 821C5BC4: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C5BC8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821C5BCC: C01C0038  lfs f0, 0x38(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C5BD0: D03C0038  stfs f1, 0x38(r28)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 821C5BD4: EFA10028  fsubs f29, f1, f0
	ctx.f[29].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 821C5BD8: 480BE539  bl 0x82284110
	ctx.lr = 0x821C5BDC;
	sub_82284110(ctx, base);
	// 821C5BDC: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 821C5BE0: 817D6B08  lwz r11, 0x6b08(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821C5BE4: 806B001C  lwz r3, 0x1c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C5BE8: 48026E49  bl 0x821eca30
	ctx.lr = 0x821C5BEC;
	sub_821ECA30(ctx, base);
	// 821C5BEC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C5BF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5BF4: 409A0870  bne cr6, 0x821c6464
	if !ctx.cr[6].eq {
	pc = 0x821C6464; continue 'dispatch;
	}
	// 821C5BF8: 897C0030  lbz r11, 0x30(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 821C5BFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5C00: 419A0864  beq cr6, 0x821c6464
	if ctx.cr[6].eq {
	pc = 0x821C6464; continue 'dispatch;
	}
	// 821C5C04: 387C0010  addi r3, r28, 0x10
	ctx.r[3].s64 = ctx.r[28].s64 + 16;
	// 821C5C08: 489A3629  bl 0x82b69230
	ctx.lr = 0x821C5C0C;
	sub_82B69230(ctx, base);
	// 821C5C0C: 815C0028  lwz r10, 0x28(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) } as u64;
	// 821C5C10: 813C0024  lwz r9, 0x24(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 821C5C14: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 821C5C18: 3BDC0020  addi r30, r28, 0x20
	ctx.r[30].s64 = ctx.r[28].s64 + 32;
	// 821C5C1C: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821C5C20: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821C5C24: 7CE85BD7  divw. r7, r8, r11
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[11].s32;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821C5C28: 41820090  beq 0x821c5cb8
	if ctx.cr[0].eq {
	pc = 0x821C5CB8; continue 'dispatch;
	}
	// 821C5C2C: 553F003E  slwi r31, r9, 0
	ctx.r[31].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 821C5C30: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 821C5C34: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C5C38: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821C5C3C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C5C40: 419A0078  beq cr6, 0x821c5cb8
	if ctx.cr[6].eq {
	pc = 0x821C5CB8; continue 'dispatch;
	}
	pc = 0x821C5C44; continue 'dispatch;
            }
            0x821C5C44 => {
    //   block [0x821C5C44..0x821C5CA4)
	// 821C5C44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821C5C48: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821C5C4C: 4821877D  bl 0x823de3c8
	ctx.lr = 0x821C5C50;
	sub_823DE3C8(ctx, base);
	// 821C5C50: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C5C54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5C58: 419A004C  beq cr6, 0x821c5ca4
	if ctx.cr[6].eq {
	pc = 0x821C5CA4; continue 'dispatch;
	}
	// 821C5C5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821C5C60: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821C5C64: 4821832D  bl 0x823ddf90
	ctx.lr = 0x821C5C68;
	sub_823DDF90(ctx, base);
	// 821C5C68: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821C5C6C: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 821C5C70: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C5C74: 4821966D  bl 0x823df2e0
	ctx.lr = 0x821C5C78;
	sub_823DF2E0(ctx, base);
	// 821C5C78: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C5C7C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821C5C80: 3864FFD0  addi r3, r4, -0x30
	ctx.r[3].s64 = ctx.r[4].s64 + -48;
	// 821C5C84: 48204C1D  bl 0x823ca8a0
	ctx.lr = 0x821C5C88;
	sub_823CA8A0(ctx, base);
	// 821C5C88: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C5C8C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C5C90: 392BFFD0  addi r9, r11, -0x30
	ctx.r[9].s64 = ctx.r[11].s64 + -48;
	// 821C5C94: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821C5C98: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C5C9C: 913E0008  stw r9, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 821C5CA0: 4800000C  b 0x821c5cac
	pc = 0x821C5CAC; continue 'dispatch;
            }
            0x821C5CA4 => {
    //   block [0x821C5CA4..0x821C5CAC)
	// 821C5CA4: 3BFF0030  addi r31, r31, 0x30
	ctx.r[31].s64 = ctx.r[31].s64 + 48;
	// 821C5CA8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	pc = 0x821C5CAC; continue 'dispatch;
            }
            0x821C5CAC => {
    //   block [0x821C5CAC..0x821C5CB8)
	// 821C5CAC: 817C0028  lwz r11, 0x28(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) } as u64;
	// 821C5CB0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C5CB4: 409AFF90  bne cr6, 0x821c5c44
	if !ctx.cr[6].eq {
	pc = 0x821C5C44; continue 'dispatch;
	}
	pc = 0x821C5CB8; continue 'dispatch;
            }
            0x821C5CB8 => {
    //   block [0x821C5CB8..0x821C5D24)
	// 821C5CB8: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C5CBC: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 821C5CC0: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5CC4: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821C5CC8: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821C5CCC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821C5CD0: 419A0054  beq cr6, 0x821c5d24
	if ctx.cr[6].eq {
	pc = 0x821C5D24; continue 'dispatch;
	}
	// 821C5CD4: 807B6AB8  lwz r3, 0x6ab8(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821C5CD8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5CDC: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C5CE0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C5CE4: 4E800421  bctrl
	ctx.lr = 0x821C5CE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C5CE8: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 821C5CEC: 807C0048  lwz r3, 0x48(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C5CF0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5CF4: 388B00A0  addi r4, r11, 0xa0
	ctx.r[4].s64 = ctx.r[11].s64 + 160;
	// 821C5CF8: 480D55F1  bl 0x8229b2e8
	ctx.lr = 0x821C5CFC;
	sub_8229B2E8(ctx, base);
	// 821C5CFC: 807B6AB8  lwz r3, 0x6ab8(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821C5D00: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5D04: 80E80014  lwz r7, 0x14(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C5D08: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 821C5D0C: 4E800421  bctrl
	ctx.lr = 0x821C5D10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C5D10: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 821C5D14: 807C004C  lwz r3, 0x4c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(76 as u32) ) } as u64;
	// 821C5D18: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5D1C: 388B0020  addi r4, r11, 0x20
	ctx.r[4].s64 = ctx.r[11].s64 + 32;
	// 821C5D20: 480D55C9  bl 0x8229b2e8
	ctx.lr = 0x821C5D24;
	sub_8229B2E8(ctx, base);
            }
            0x821C5D24 => {
    //   block [0x821C5D24..0x821C5D3C)
	// 821C5D24: 83DC0004  lwz r30, 4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5D28: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C5D2C: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 821C5D30: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C5D34: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821C5D38: 419A0120  beq cr6, 0x821c5e58
	if ctx.cr[6].eq {
	pc = 0x821C5E58; continue 'dispatch;
	}
	pc = 0x821C5D3C; continue 'dispatch;
            }
            0x821C5D3C => {
    //   block [0x821C5D3C..0x821C5D54)
	// 821C5D3C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5D40: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5D44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5D48: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 821C5D4C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 821C5D50: 419A0020  beq cr6, 0x821c5d70
	if ctx.cr[6].eq {
	pc = 0x821C5D70; continue 'dispatch;
	}
	pc = 0x821C5D54; continue 'dispatch;
            }
            0x821C5D54 => {
    //   block [0x821C5D54..0x821C5D70)
	// 821C5D54: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821C5D58: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821C5D5C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821C5D60: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821C5D64: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821C5D68: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821C5D6C: 4082FFE8  bne 0x821c5d54
	if !ctx.cr[0].eq {
	pc = 0x821C5D54; continue 'dispatch;
	}
	pc = 0x821C5D70; continue 'dispatch;
            }
            0x821C5D70 => {
    //   block [0x821C5D70..0x821C5D88)
	// 821C5D70: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5D74: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5D78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5D7C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 821C5D80: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 821C5D84: 419A0020  beq cr6, 0x821c5da4
	if ctx.cr[6].eq {
	pc = 0x821C5DA4; continue 'dispatch;
	}
	pc = 0x821C5D88; continue 'dispatch;
            }
            0x821C5D88 => {
    //   block [0x821C5D88..0x821C5DA4)
	// 821C5D88: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821C5D8C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821C5D90: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821C5D94: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821C5D98: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821C5D9C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821C5DA0: 4082FFE8  bne 0x821c5d88
	if !ctx.cr[0].eq {
	pc = 0x821C5D88; continue 'dispatch;
	}
	pc = 0x821C5DA4; continue 'dispatch;
            }
            0x821C5DA4 => {
    //   block [0x821C5DA4..0x821C5DBC)
	// 821C5DA4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821C5DA8: 409A0014  bne cr6, 0x821c5dbc
	if !ctx.cr[6].eq {
	pc = 0x821C5DBC; continue 'dispatch;
	}
	// 821C5DAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821C5DB0: 4BFF1D69  bl 0x821b7b18
	ctx.lr = 0x821C5DB4;
	sub_821B7B18(ctx, base);
	// 821C5DB4: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821C5DB8: 48000058  b 0x821c5e10
	pc = 0x821C5E10; continue 'dispatch;
            }
            0x821C5DBC => {
    //   block [0x821C5DBC..0x821C5DEC)
	// 821C5DBC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5DC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C5DC4: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C5DC8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C5DCC: 4E800421  bctrl
	ctx.lr = 0x821C5DD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C5DD0: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C5DD4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C5DD8: 409A0014  bne cr6, 0x821c5dec
	if !ctx.cr[6].eq {
	pc = 0x821C5DEC; continue 'dispatch;
	}
	// 821C5DDC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821C5DE0: 4BFF1D39  bl 0x821b7b18
	ctx.lr = 0x821C5DE4;
	sub_821B7B18(ctx, base);
	// 821C5DE4: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821C5DE8: 48000028  b 0x821c5e10
	pc = 0x821C5E10; continue 'dispatch;
            }
            0x821C5DEC => {
    //   block [0x821C5DEC..0x821C5E10)
	// 821C5DEC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C5DF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C5DF4: 889C0044  lbz r4, 0x44(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(68 as u32) ) } as u64;
	// 821C5DF8: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C5DFC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C5E00: 4E800421  bctrl
	ctx.lr = 0x821C5E04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C5E04: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821C5E08: 4BFF1D11  bl 0x821b7b18
	ctx.lr = 0x821C5E0C;
	sub_821B7B18(ctx, base);
	// 821C5E0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
            }
            0x821C5E10 => {
    //   block [0x821C5E10..0x821C5E28)
	// 821C5E10: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C5E14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5E18: 419A0010  beq cr6, 0x821c5e28
	if ctx.cr[6].eq {
	pc = 0x821C5E28; continue 'dispatch;
	}
	// 821C5E1C: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 821C5E20: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821C5E24: 48000020  b 0x821c5e44
	pc = 0x821C5E44; continue 'dispatch;
            }
            0x821C5E28 => {
    //   block [0x821C5E28..0x821C5E44)
	// 821C5E28: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821C5E2C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C5E30: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821C5E34: 48217FA5  bl 0x823dddd8
	ctx.lr = 0x821C5E38;
	sub_823DDDD8(ctx, base);
	// 821C5E38: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821C5E3C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821C5E40: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x821C5E44; continue 'dispatch;
            }
            0x821C5E44 => {
    //   block [0x821C5E44..0x821C5E58)
	// 821C5E44: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821C5E48: 4BFF1CD1  bl 0x821b7b18
	ctx.lr = 0x821C5E4C;
	sub_821B7B18(ctx, base);
	// 821C5E4C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C5E50: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C5E54: 409AFEE8  bne cr6, 0x821c5d3c
	if !ctx.cr[6].eq {
	pc = 0x821C5D3C; continue 'dispatch;
	}
	pc = 0x821C5E58; continue 'dispatch;
            }
            0x821C5E58 => {
    //   block [0x821C5E58..0x821C5EA8)
	// 821C5E58: 897C0044  lbz r11, 0x44(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(68 as u32) ) } as u64;
	// 821C5E5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5E60: 419A0604  beq cr6, 0x821c6464
	if ctx.cr[6].eq {
	pc = 0x821C6464; continue 'dispatch;
	}
	// 821C5E64: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C5E68: 394BC080  addi r10, r11, -0x3f80
	ctx.r[10].s64 = ctx.r[11].s64 + -16256;
	// 821C5E6C: 892A0030  lbz r9, 0x30(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821C5E70: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C5E74: 419A05D8  beq cr6, 0x821c644c
	if ctx.cr[6].eq {
	pc = 0x821C644C; continue 'dispatch;
	}
	// 821C5E78: 817C0040  lwz r11, 0x40(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) } as u64;
	// 821C5E7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5E80: 419A05CC  beq cr6, 0x821c644c
	if ctx.cr[6].eq {
	pc = 0x821C644C; continue 'dispatch;
	}
	// 821C5E84: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821C5E88: 895C003C  lbz r10, 0x3c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(60 as u32) ) } as u64;
	// 821C5E8C: C19C0034  lfs f12, 0x34(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821C5E90: 392BBC68  addi r9, r11, -0x4398
	ctx.r[9].s64 = ctx.r[11].s64 + -17304;
	// 821C5E94: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C5E98: C3C9D81C  lfs f30, -0x27e4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821C5E9C: 419A000C  beq cr6, 0x821c5ea8
	if ctx.cr[6].eq {
	pc = 0x821C5EA8; continue 'dispatch;
	}
	// 821C5EA0: D3DC0034  stfs f30, 0x34(r28)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821C5EA4: 9B5C003C  stb r26, 0x3c(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(60 as u32), ctx.r[26].u8 ) };
	pc = 0x821C5EA8; continue 'dispatch;
            }
            0x821C5EA8 => {
    //   block [0x821C5EA8..0x821C5ED4)
	// 821C5EA8: C01C0034  lfs f0, 0x34(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C5EAC: C3E9D828  lfs f31, -0x27d8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10200 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821C5EB0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821C5EB4: 40980030  bge cr6, 0x821c5ee4
	if !ctx.cr[6].lt {
	pc = 0x821C5EE4; continue 'dispatch;
	}
	// 821C5EB8: 897C0031  lbz r11, 0x31(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(49 as u32) ) } as u64;
	// 821C5EBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5EC0: 419A0014  beq cr6, 0x821c5ed4
	if ctx.cr[6].eq {
	pc = 0x821C5ED4; continue 'dispatch;
	}
	// 821C5EC4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821C5EC8: C1ABC4A8  lfs f13, -0x3b58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821C5ECC: EC0D077A  fmadds f0, f13, f29, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[29].f64 + ctx.f[0].f64) as f32) as f64);
	// 821C5ED0: 48000010  b 0x821c5ee0
	pc = 0x821C5EE0; continue 'dispatch;
            }
            0x821C5ED4 => {
    //   block [0x821C5ED4..0x821C5EE0)
	// 821C5ED4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821C5ED8: C1ABC4A4  lfs f13, -0x3b5c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-15196 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821C5EDC: EC0D077C  fnmsubs f0, f13, f29, f0
	ctx.f[0].f64 = -(((ctx.f[13].f64 * ctx.f[29].f64 - ctx.f[0].f64) as f32) as f64);
	pc = 0x821C5EE0; continue 'dispatch;
            }
            0x821C5EE0 => {
    //   block [0x821C5EE0..0x821C5EE4)
	// 821C5EE0: D01C0034  stfs f0, 0x34(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(52 as u32), tmp.u32 ) };
	pc = 0x821C5EE4; continue 'dispatch;
            }
            0x821C5EE4 => {
    //   block [0x821C5EE4..0x821C5F68)
	// 821C5EE4: C01C0034  lfs f0, 0x34(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C5EE8: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 821C5EEC: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 821C5EF0: 7D400026  mfcr r10
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[10].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 821C5EF4: 5548DF7A  rlwinm r8, r10, 0x1b, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 821C5EF8: 5547F77A  rlwinm r7, r10, 0x1e, 0x1d, 0x1d
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 821C5EFC: 38CB0E68  addi r6, r11, 0xe68
	ctx.r[6].s64 = ctx.r[11].s64 + 3688;
	// 821C5F00: 7D053B78  or r5, r8, r7
	ctx.r[5].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 821C5F04: 7DA62C2E  lfsx f13, r6, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821C5F08: FD6DF02E  fsel f11, f13, f0, f30
	ctx.f[11].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[30].f64 };
	// 821C5F0C: ED4BF828  fsubs f10, f11, f31
	ctx.f[10].f64 = (((ctx.f[11].f64 - ctx.f[31].f64) as f32) as f64);
	// 821C5F10: FF0AF000  fcmpu cr6, f10, f30
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[30].f64);
	// 821C5F14: 7C800026  mfcr r4
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[4].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 821C5F18: 5483DF7A  rlwinm r3, r4, 0x1b, 0x1d, 0x1d
	ctx.r[3].u64 = ctx.r[4].u32 as u64 & 0x0000001Fu64;
	// 821C5F1C: 548BF77A  rlwinm r11, r4, 0x1e, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000003u64;
	// 821C5F20: 7C6A5B78  or r10, r3, r11
	ctx.r[10].u64 = ctx.r[3].u64 | ctx.r[11].u64;
	// 821C5F24: 7D26542E  lfsx f9, r6, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821C5F28: FD095FEE  fsel f8, f9, f31, f11
	ctx.f[8].f64 = if ctx.f[9].f64 >= 0.0 { ctx.f[31].f64 } else { ctx.f[11].f64 };
	// 821C5F2C: D11C0034  stfs f8, 0x34(r28)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821C5F30: FC004090  fmr f0, f8
	ctx.f[0].f64 = ctx.f[8].f64;
	// 821C5F34: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 821C5F38: 419A052C  beq cr6, 0x821c6464
	if ctx.cr[6].eq {
	pc = 0x821C6464; continue 'dispatch;
	}
	// 821C5F3C: 817D6B08  lwz r11, 0x6b08(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821C5F40: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821C5F44: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821C5F48: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C5F4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C5F50: 419A0018  beq cr6, 0x821c5f68
	if ctx.cr[6].eq {
	pc = 0x821C5F68; continue 'dispatch;
	}
	// 821C5F54: 814A0020  lwz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 821C5F58: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821C5F5C: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 821C5F60: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 821C5F64: 41990008  bgt cr6, 0x821c5f6c
	if ctx.cr[6].gt {
	pc = 0x821C5F6C; continue 'dispatch;
	}
	pc = 0x821C5F68; continue 'dispatch;
            }
            0x821C5F68 => {
    //   block [0x821C5F68..0x821C5F6C)
	// 821C5F68: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C5F6C; continue 'dispatch;
            }
            0x821C5F6C => {
    //   block [0x821C5F6C..0x821C6000)
	// 821C5F6C: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821C5F70: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821C5F74: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821C5F78: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C5F7C: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821C5F80: 808A7D1C  lwz r4, 0x7d1c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32028 as u32) ) } as u64;
	// 821C5F84: C0490A54  lfs f2, 0xa54(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2644 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821C5F88: 48238349  bl 0x823fe2d0
	ctx.lr = 0x821C5F8C;
	sub_823FE2D0(ctx, base);
	// 821C5F8C: C01C0034  lfs f0, 0x34(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C5F90: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821C5F94: 4198006C  blt cr6, 0x821c6000
	if ctx.cr[6].lt {
	pc = 0x821C6000; continue 'dispatch;
	}
	// 821C5F98: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821C5F9C: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 821C5FA0: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 821C5FA4: 807C0040  lwz r3, 0x40(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) } as u64;
	// 821C5FA8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x821C6000; continue 'dispatch;
            }
            0x821C6000 => {
    //   block [0x821C6000..0x821C644C)
	// 821C6000: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821C6004: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C6008: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 821C600C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C6010: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C6014: 480661A5  bl 0x8222c1b8
	ctx.lr = 0x821C6018;
	sub_8222C1B8(ctx, base);
	// 821C6018: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C601C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821C6020: 419A0018  beq cr6, 0x821c6038
	if ctx.cr[6].eq {
	pc = 0x821C6038; continue 'dispatch;
	}
	// 821C6024: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 821C6028: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821C602C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C6030: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C6034: 409A0008  bne cr6, 0x821c603c
	if !ctx.cr[6].eq {
	pc = 0x821C603C; continue 'dispatch;
	}
	// 821C6038: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821C603C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C6040: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C6044: 419A0420  beq cr6, 0x821c6464
	if ctx.cr[6].eq {
	pc = 0x821C6464; continue 'dispatch;
	}
	// 821C6048: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821C604C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821C6050: 55499FFE  rlwinm r9, r10, 0x13, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00001FFFu64;
	// 821C6054: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C6058: 419A00E8  beq cr6, 0x821c6140
	if ctx.cr[6].eq {
	pc = 0x821C6140; continue 'dispatch;
	}
	// 821C605C: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C6060: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C6064: 419A0020  beq cr6, 0x821c6084
	if ctx.cr[6].eq {
	pc = 0x821C6084; continue 'dispatch;
	}
	// 821C6068: 894B004D  lbz r10, 0x4d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(77 as u32) ) } as u64;
	// 821C606C: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C6070: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821C6074: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821C6078: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C607C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C6080: 480000C4  b 0x821c6144
	pc = 0x821C6144; continue 'dispatch;
	// 821C6084: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C6088: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821C608C: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 821C6090: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821C6094: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821C6098: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C609C: 40810054  ble 0x821c60f0
	if !ctx.cr[0].gt {
	pc = 0x821C60F0; continue 'dispatch;
	}
	// 821C60A0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821C60A4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C60A8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C60AC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C60B0: 2F07004D  cmpwi cr6, r7, 0x4d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 77, &mut ctx.xer);
	// 821C60B4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821C60B8: 41980008  blt cr6, 0x821c60c0
	if ctx.cr[6].lt {
	pc = 0x821C60C0; continue 'dispatch;
	}
	// 821C60BC: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 821C60C0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821C60C4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C60C8: 419A0014  beq cr6, 0x821c60dc
	if ctx.cr[6].eq {
	pc = 0x821C60DC; continue 'dispatch;
	}
	// 821C60CC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821C60D0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C60D4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C60D8: 4800000C  b 0x821c60e4
	pc = 0x821C60E4; continue 'dispatch;
	// 821C60DC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821C60E0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821C60E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C60E8: 4199FFB8  bgt cr6, 0x821c60a0
	if ctx.cr[6].gt {
	pc = 0x821C60A0; continue 'dispatch;
	}
	// 821C60EC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821C60F0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C60F4: 419A003C  beq cr6, 0x821c6130
	if ctx.cr[6].eq {
	pc = 0x821C6130; continue 'dispatch;
	}
	// 821C60F8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C60FC: 2F0B004D  cmpwi cr6, r11, 0x4d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 77, &mut ctx.xer);
	// 821C6100: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C6104: 41990008  bgt cr6, 0x821c610c
	if ctx.cr[6].gt {
	pc = 0x821C610C; continue 'dispatch;
	}
	// 821C6108: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821C610C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C6110: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C6114: 409A001C  bne cr6, 0x821c6130
	if !ctx.cr[6].eq {
	pc = 0x821C6130; continue 'dispatch;
	}
	// 821C6118: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821C611C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C6120: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821C6124: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821C6128: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C612C: 48000018  b 0x821c6144
	pc = 0x821C6144; continue 'dispatch;
	// 821C6130: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821C6134: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C6138: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C613C: 48000008  b 0x821c6144
	pc = 0x821C6144; continue 'dispatch;
	// 821C6140: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 821C6144: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821C6148: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C614C: 419A0318  beq cr6, 0x821c6464
	if ctx.cr[6].eq {
	pc = 0x821C6464; continue 'dispatch;
	}
	// 821C6150: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C6154: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821C6158: 812A0044  lwz r9, 0x44(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 821C615C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821C6160: 4E800421  bctrl
	ctx.lr = 0x821C6164;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C6164: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821C6168: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C616C: 419A0018  beq cr6, 0x821c6184
	if ctx.cr[6].eq {
	pc = 0x821C6184; continue 'dispatch;
	}
	// 821C6170: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 821C6174: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821C6178: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C617C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C6180: 409A0008  bne cr6, 0x821c6188
	if !ctx.cr[6].eq {
	pc = 0x821C6188; continue 'dispatch;
	}
	// 821C6184: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 821C6188: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821C618C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C6190: 419A02D4  beq cr6, 0x821c6464
	if ctx.cr[6].eq {
	pc = 0x821C6464; continue 'dispatch;
	}
	// 821C6194: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821C6198: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821C619C: 554997FE  rlwinm r9, r10, 0x12, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00003FFFu64;
	// 821C61A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C61A4: 419A00F4  beq cr6, 0x821c6298
	if ctx.cr[6].eq {
	pc = 0x821C6298; continue 'dispatch;
	}
	// 821C61A8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C61AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C61B0: 419A0024  beq cr6, 0x821c61d4
	if ctx.cr[6].eq {
	pc = 0x821C61D4; continue 'dispatch;
	}
	// 821C61B4: 894A004E  lbz r10, 0x4e(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(78 as u32) ) } as u64;
	// 821C61B8: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C61BC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821C61C0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821C61C4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C61C8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821C61CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C61D0: 480000CC  b 0x821c629c
	pc = 0x821C629C; continue 'dispatch;
	// 821C61D4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C61D8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821C61DC: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 821C61E0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821C61E4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821C61E8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C61EC: 40810054  ble 0x821c6240
	if !ctx.cr[0].gt {
	pc = 0x821C6240; continue 'dispatch;
	}
	// 821C61F0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821C61F4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C61F8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C61FC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C6200: 2F07004E  cmpwi cr6, r7, 0x4e
	ctx.cr[6].compare_i32(ctx.r[7].s32, 78, &mut ctx.xer);
	// 821C6204: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821C6208: 41980008  blt cr6, 0x821c6210
	if ctx.cr[6].lt {
	pc = 0x821C6210; continue 'dispatch;
	}
	// 821C620C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 821C6210: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821C6214: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C6218: 419A0014  beq cr6, 0x821c622c
	if ctx.cr[6].eq {
	pc = 0x821C622C; continue 'dispatch;
	}
	// 821C621C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821C6220: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C6224: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C6228: 4800000C  b 0x821c6234
	pc = 0x821C6234; continue 'dispatch;
	// 821C622C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821C6230: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821C6234: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C6238: 4199FFB8  bgt cr6, 0x821c61f0
	if ctx.cr[6].gt {
	pc = 0x821C61F0; continue 'dispatch;
	}
	// 821C623C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821C6240: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C6244: 419A0040  beq cr6, 0x821c6284
	if ctx.cr[6].eq {
	pc = 0x821C6284; continue 'dispatch;
	}
	// 821C6248: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C624C: 2F0B004E  cmpwi cr6, r11, 0x4e
	ctx.cr[6].compare_i32(ctx.r[11].s32, 78, &mut ctx.xer);
	// 821C6250: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C6254: 41990008  bgt cr6, 0x821c625c
	if ctx.cr[6].gt {
	pc = 0x821C625C; continue 'dispatch;
	}
	// 821C6258: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821C625C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C6260: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C6264: 409A0020  bne cr6, 0x821c6284
	if !ctx.cr[6].eq {
	pc = 0x821C6284; continue 'dispatch;
	}
	// 821C6268: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821C626C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821C6270: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821C6274: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C6278: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821C627C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C6280: 4800001C  b 0x821c629c
	pc = 0x821C629C; continue 'dispatch;
	// 821C6284: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821C6288: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C628C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821C6290: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C6294: 48000008  b 0x821c629c
	pc = 0x821C629C; continue 'dispatch;
	// 821C6298: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821C629C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C62A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C62A4: 419A01C0  beq cr6, 0x821c6464
	if ctx.cr[6].eq {
	pc = 0x821C6464; continue 'dispatch;
	}
	// 821C62A8: 8963001A  lbz r11, 0x1a(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(26 as u32) ) } as u64;
	// 821C62AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C62B0: 419A01B4  beq cr6, 0x821c6464
	if ctx.cr[6].eq {
	pc = 0x821C6464; continue 'dispatch;
	}
	// 821C62B4: C01C0034  lfs f0, 0x34(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C62B8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821C62BC: 41980020  blt cr6, 0x821c62dc
	if ctx.cr[6].lt {
	pc = 0x821C62DC; continue 'dispatch;
	}
	// 821C62C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821C62C4: 4865B735  bl 0x828219f8
	ctx.lr = 0x821C62C8;
	sub_828219F8(ctx, base);
	// 821C62C8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821C62CC: CBA1FFB0  lfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 821C62D0: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 821C62D4: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 821C62D8: 48AE3178  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 821C62DC: 8963001B  lbz r11, 0x1b(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(27 as u32) ) } as u64;
	// 821C62E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C62E4: 419A0180  beq cr6, 0x821c6464
	if ctx.cr[6].eq {
	pc = 0x821C6464; continue 'dispatch;
	}
	// 821C62E8: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821C62EC: 3880006D  li r4, 0x6d
	ctx.r[4].s64 = 109;
	// 821C62F0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C62F4: 80AB00A8  lwz r5, 0xa8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) } as u64;
	// 821C62F8: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 821C62FC: 4828A575  bl 0x82450870
	ctx.lr = 0x821C6300;
	sub_82450870(ctx, base);
	// 821C6300: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C6304: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C6308: 409A015C  bne cr6, 0x821c6464
	if !ctx.cr[6].eq {
	pc = 0x821C6464; continue 'dispatch;
	}
	// 821C630C: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821C6310: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821C6314: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 821C6318: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C631C: 419A00E8  beq cr6, 0x821c6404
	if ctx.cr[6].eq {
	pc = 0x821C6404; continue 'dispatch;
	}
	// 821C6320: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C6324: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C6328: 419A0020  beq cr6, 0x821c6348
	if ctx.cr[6].eq {
	pc = 0x821C6348; continue 'dispatch;
	}
	// 821C632C: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 821C6330: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C6334: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821C6338: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821C633C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C6340: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C6344: 480000C4  b 0x821c6408
	pc = 0x821C6408; continue 'dispatch;
	// 821C6348: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C634C: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821C6350: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 821C6354: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821C6358: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821C635C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C6360: 40810054  ble 0x821c63b4
	if !ctx.cr[0].gt {
	pc = 0x821C63B4; continue 'dispatch;
	}
	// 821C6364: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821C6368: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C636C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C6370: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C6374: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 821C6378: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821C637C: 41980008  blt cr6, 0x821c6384
	if ctx.cr[6].lt {
	pc = 0x821C6384; continue 'dispatch;
	}
	// 821C6380: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 821C6384: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821C6388: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C638C: 419A0014  beq cr6, 0x821c63a0
	if ctx.cr[6].eq {
	pc = 0x821C63A0; continue 'dispatch;
	}
	// 821C6390: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821C6394: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C6398: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C639C: 4800000C  b 0x821c63a8
	pc = 0x821C63A8; continue 'dispatch;
	// 821C63A0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821C63A4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821C63A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C63AC: 4199FFB8  bgt cr6, 0x821c6364
	if ctx.cr[6].gt {
	pc = 0x821C6364; continue 'dispatch;
	}
	// 821C63B0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821C63B4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C63B8: 419A003C  beq cr6, 0x821c63f4
	if ctx.cr[6].eq {
	pc = 0x821C63F4; continue 'dispatch;
	}
	// 821C63BC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C63C0: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 821C63C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C63C8: 41990008  bgt cr6, 0x821c63d0
	if ctx.cr[6].gt {
	pc = 0x821C63D0; continue 'dispatch;
	}
	// 821C63CC: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821C63D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C63D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C63D8: 409A001C  bne cr6, 0x821c63f4
	if !ctx.cr[6].eq {
	pc = 0x821C63F4; continue 'dispatch;
	}
	// 821C63DC: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821C63E0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C63E4: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821C63E8: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821C63EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C63F0: 48000018  b 0x821c6408
	pc = 0x821C6408; continue 'dispatch;
	// 821C63F4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821C63F8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C63FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C6400: 48000008  b 0x821c6408
	pc = 0x821C6408; continue 'dispatch;
	// 821C6404: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 821C6408: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821C640C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C6410: 419A0054  beq cr6, 0x821c6464
	if ctx.cr[6].eq {
	pc = 0x821C6464; continue 'dispatch;
	}
	// 821C6414: 896B0028  lbz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821C6418: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C641C: 419A0048  beq cr6, 0x821c6464
	if ctx.cr[6].eq {
	pc = 0x821C6464; continue 'dispatch;
	}
	// 821C6420: 3880006D  li r4, 0x6d
	ctx.r[4].s64 = 109;
	// 821C6424: 80650004  lwz r3, 4(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C6428: 4BFEEE39  bl 0x821b5260
	ctx.lr = 0x821C642C;
	sub_821B5260(ctx, base);
	// 821C642C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C6430: D3DC0034  stfs f30, 0x34(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821C6434: 997C003C  stb r11, 0x3c(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(60 as u32), ctx.r[11].u8 ) };
	// 821C6438: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821C643C: CBA1FFB0  lfd f29, -0x50(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 821C6440: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 821C6444: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 821C6448: 48AE3008  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x821C644C => {
    //   block [0x821C644C..0x821C6464)
	// 821C644C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821C6450: 9B5C0031  stb r26, 0x31(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(49 as u32), ctx.r[26].u8 ) };
	// 821C6454: 935C0040  stw r26, 0x40(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(64 as u32), ctx.r[26].u32 ) };
	// 821C6458: 394BBC68  addi r10, r11, -0x4398
	ctx.r[10].s64 = ctx.r[11].s64 + -17304;
	// 821C645C: C00AD81C  lfs f0, -0x27e4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C6460: D01C0034  stfs f0, 0x34(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(52 as u32), tmp.u32 ) };
	pc = 0x821C6464; continue 'dispatch;
            }
            0x821C6464 => {
    //   block [0x821C6464..0x821C6478)
	// 821C6464: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821C6468: CBA1FFB0  lfd f29, -0x50(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 821C646C: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 821C6470: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 821C6474: 48AE2FDC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C6478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C6478 size=652
    let mut pc: u32 = 0x821C6478;
    'dispatch: loop {
        match pc {
            0x821C6478 => {
    //   block [0x821C6478..0x821C64A4)
	// 821C6478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C647C: 48AE2F85  bl 0x82ca9400
	ctx.lr = 0x821C6480;
	sub_82CA93D0(ctx, base);
	// 821C6480: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C6484: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C6488: 897F2ABC  lbz r11, 0x2abc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10940 as u32) ) } as u64;
	// 821C648C: 556B06B5  rlwinm. r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C6490: 40820014  bne 0x821c64a4
	if !ctx.cr[0].eq {
	pc = 0x821C64A4; continue 'dispatch;
	}
	// 821C6494: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C6498: 917F31B0  stw r11, 0x31b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12720 as u32), ctx.r[11].u32 ) };
	// 821C649C: 480DFA4D  bl 0x822a5ee8
	ctx.lr = 0x821C64A0;
	sub_822A5EE8(ctx, base);
	// 821C64A0: 48000008  b 0x821c64a8
	pc = 0x821C64A8; continue 'dispatch;
            }
            0x821C64A4 => {
    //   block [0x821C64A4..0x821C64A8)
	// 821C64A4: 48022A1D  bl 0x821e8ec0
	ctx.lr = 0x821C64A8;
	sub_821E8EC0(ctx, base);
	pc = 0x821C64A8; continue 'dispatch;
            }
            0x821C64A8 => {
    //   block [0x821C64A8..0x821C64C8)
	// 821C64A8: 817F3440  lwz r11, 0x3440(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13376 as u32) ) } as u64;
	// 821C64AC: 387F3438  addi r3, r31, 0x3438
	ctx.r[3].s64 = ctx.r[31].s64 + 13368;
	// 821C64B0: 815F3444  lwz r10, 0x3444(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13380 as u32) ) } as u64;
	// 821C64B4: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 821C64B8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821C64BC: 4099000C  ble cr6, 0x821c64c8
	if !ctx.cr[6].gt {
	pc = 0x821C64C8; continue 'dispatch;
	}
	// 821C64C0: 4800B0F1  bl 0x821d15b0
	ctx.lr = 0x821C64C4;
	sub_821D15B0(ctx, base);
	// 821C64C4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x821C64C8; continue 'dispatch;
            }
            0x821C64C8 => {
    //   block [0x821C64C8..0x821C6534)
	// 821C64C8: 3D408300  lis r10, -0x7d00
	ctx.r[10].s64 = -2097152000;
	// 821C64CC: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 821C64D0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821C64D4: 817F2934  lwz r11, 0x2934(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10548 as u32) ) } as u64;
	// 821C64D8: 895F2ABF  lbz r10, 0x2abf(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10943 as u32) ) } as u64;
	// 821C64DC: 891F2ABC  lbz r8, 0x2abc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10940 as u32) ) } as u64;
	// 821C64E0: 61080040  ori r8, r8, 0x40
	ctx.r[8].u64 = ctx.r[8].u64 | 64;
	// 821C64E4: 556BE77E  rlwinm r11, r11, 0x1c, 0x1d, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821C64E8: 913F3440  stw r9, 0x3440(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13376 as u32), ctx.r[9].u32 ) };
	// 821C64EC: 554A06B5  rlwinm. r10, r10, 0, 0x1a, 0x1a
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821C64F0: 991F2ABC  stb r8, 0x2abc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(10940 as u32), ctx.r[8].u8 ) };
	// 821C64F4: 917F31A0  stw r11, 0x31a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12704 as u32), ctx.r[11].u32 ) };
	// 821C64F8: 4182003C  beq 0x821c6534
	if ctx.cr[0].eq {
	pc = 0x821C6534; continue 'dispatch;
	}
	// 821C64FC: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 821C6500: E97F0028  ld r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	// 821C6504: 815F2880  lwz r10, 0x2880(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10368 as u32) ) } as u64;
	// 821C6508: 798C2FE6  rldicr r12, r12, 0x25, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(37) & 0xFFFFFFFFFFFFFFFF;
	// 821C650C: 813F3378  lwz r9, 0x3378(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13176 as u32) ) } as u64;
	// 821C6510: 554A04BE  clrlwi r10, r10, 0x12
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00003FFFu64;
	// 821C6514: 7D6B6378  or r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[12].u64;
	// 821C6518: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821C651C: F97F0028  std r11, 0x28(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u64 ) };
	// 821C6520: 419A0014  beq cr6, 0x821c6534
	if ctx.cr[6].eq {
	pc = 0x821C6534; continue 'dispatch;
	}
	// 821C6524: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 821C6528: 798CCFE6  rldicr r12, r12, 0x39, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(57) & 0xFFFFFFFFFFFFFFFF;
	// 821C652C: 7D6B6378  or r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[12].u64;
	// 821C6530: F97F0028  std r11, 0x28(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u64 ) };
	pc = 0x821C6534; continue 'dispatch;
            }
            0x821C6534 => {
    //   block [0x821C6534..0x821C659C)
	// 821C6534: 897F2ABD  lbz r11, 0x2abd(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10941 as u32) ) } as u64;
	// 821C6538: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821C653C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821C6540: 616B0040  ori r11, r11, 0x40
	ctx.r[11].u64 = ctx.r[11].u64 | 64;
	// 821C6544: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C6548: 997F2ABD  stb r11, 0x2abd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(10941 as u32), ctx.r[11].u8 ) };
	// 821C654C: E97F0010  ld r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 821C6550: 616B0008  ori r11, r11, 8
	ctx.r[11].u64 = ctx.r[11].u64 | 8;
	// 821C6554: F97F0010  std r11, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821C6558: 915F319C  stw r10, 0x319c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12700 as u32), ctx.r[10].u32 ) };
	// 821C655C: 480DFFFD  bl 0x822a6558
	ctx.lr = 0x821C6560;
	sub_822A6558(ctx, base);
	// 821C6560: 817F3384  lwz r11, 0x3384(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13188 as u32) ) } as u64;
	// 821C6564: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C6568: 40820194  bne 0x821c66fc
	if !ctx.cr[0].eq {
	pc = 0x821C66FC; continue 'dispatch;
	}
	// 821C656C: 897F2ABF  lbz r11, 0x2abf(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10943 as u32) ) } as u64;
	// 821C6570: 556B06B5  rlwinm. r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C6574: 41820188  beq 0x821c66fc
	if ctx.cr[0].eq {
	pc = 0x821C66FC; continue 'dispatch;
	}
	// 821C6578: 817F31CC  lwz r11, 0x31cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12748 as u32) ) } as u64;
	// 821C657C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 821C6580: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 821C6584: 7F7ADB78  mr r26, r27
	ctx.r[26].u64 = ctx.r[27].u64;
	// 821C6588: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C658C: 40990050  ble cr6, 0x821c65dc
	if !ctx.cr[6].gt {
	pc = 0x821C65DC; continue 'dispatch;
	}
	// 821C6590: 5567003E  slwi r7, r11, 0
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821C6594: 395F31DC  addi r10, r31, 0x31dc
	ctx.r[10].s64 = ctx.r[31].s64 + 12764;
	// 821C6598: 397F32C4  addi r11, r31, 0x32c4
	ctx.r[11].s64 = ctx.r[31].s64 + 12996;
	pc = 0x821C659C; continue 'dispatch;
            }
            0x821C659C => {
    //   block [0x821C659C..0x821C65C0)
	// 821C659C: 810BFFFC  lwz r8, -4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821C65A0: 812AFFFC  lwz r9, -4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821C65A4: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C65A8: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C65AC: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821C65B0: 7D053050  subf r8, r5, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[5].s64;
	// 821C65B4: 7F1C4840  cmplw cr6, r28, r9
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821C65B8: 41990008  bgt cr6, 0x821c65c0
	if ctx.cr[6].gt {
	pc = 0x821C65C0; continue 'dispatch;
	}
	// 821C65BC: 7D3C4B78  mr r28, r9
	ctx.r[28].u64 = ctx.r[9].u64;
	pc = 0x821C65C0; continue 'dispatch;
            }
            0x821C65C0 => {
    //   block [0x821C65C0..0x821C65CC)
	// 821C65C0: 7F1A4040  cmplw cr6, r26, r8
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821C65C4: 41990008  bgt cr6, 0x821c65cc
	if ctx.cr[6].gt {
	pc = 0x821C65CC; continue 'dispatch;
	}
	// 821C65C8: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	pc = 0x821C65CC; continue 'dispatch;
            }
            0x821C65CC => {
    //   block [0x821C65CC..0x821C65DC)
	// 821C65CC: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821C65D0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821C65D4: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 821C65D8: 4082FFC4  bne 0x821c659c
	if !ctx.cr[0].eq {
	pc = 0x821C659C; continue 'dispatch;
	}
	pc = 0x821C65DC; continue 'dispatch;
            }
            0x821C65DC => {
    //   block [0x821C65DC..0x821C6688)
	// 821C65DC: 389F3168  addi r4, r31, 0x3168
	ctx.r[4].s64 = ctx.r[31].s64 + 12648;
	// 821C65E0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821C65E4: 38A0001C  li r5, 0x1c
	ctx.r[5].s64 = 28;
	// 821C65E8: 48AE2E99  bl 0x82ca9480
	ctx.lr = 0x821C65EC;
	sub_82CA9480(ctx, base);
	// 821C65EC: 817F3184  lwz r11, 0x3184(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12676 as u32) ) } as u64;
	// 821C65F0: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 821C65F4: 813F3188  lwz r9, 0x3188(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12680 as u32) ) } as u64;
	// 821C65F8: 811F318C  lwz r8, 0x318c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12684 as u32) ) } as u64;
	// 821C65FC: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 821C6600: 80DF3190  lwz r6, 0x3190(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12688 as u32) ) } as u64;
	// 821C6604: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C6608: 38871AA8  addi r4, r7, 0x1aa8
	ctx.r[4].s64 = ctx.r[7].s64 + 6824;
	// 821C660C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821C6610: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C6614: 910A0008  stw r8, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 821C6618: 90CA000C  stw r6, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 821C661C: 4803393D  bl 0x821f9f58
	ctx.lr = 0x821C6620;
	sub_821F9F58(ctx, base);
	// 821C6620: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821C6624: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C6628: 388B1590  addi r4, r11, 0x1590
	ctx.r[4].s64 = ctx.r[11].s64 + 5520;
	// 821C662C: 480335DD  bl 0x821f9c08
	ctx.lr = 0x821C6630;
	sub_821F9C08(ctx, base);
	// 821C6630: 817F337C  lwz r11, 0x337c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13180 as u32) ) } as u64;
	// 821C6634: 815F3380  lwz r10, 0x3380(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13184 as u32) ) } as u64;
	// 821C6638: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821C663C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C6640: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 821C6644: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 821C6648: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821C664C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821C6650: 4809EFA1  bl 0x822655f0
	ctx.lr = 0x821C6654;
	sub_822655F0(ctx, base);
	// 821C6654: 3BDF3390  addi r30, r31, 0x3390
	ctx.r[30].s64 = ctx.r[31].s64 + 13200;
	// 821C6658: 811F33A4  lwz r8, 0x33a4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13220 as u32) ) } as u64;
	// 821C665C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821C6660: C03F33A0  lfs f1, 0x33a0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821C6664: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 821C6668: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 821C666C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C6670: 4801C971  bl 0x821e2fe0
	ctx.lr = 0x821C6674;
	sub_821E2FE0(ctx, base);
	// 821C6674: 897F2ABF  lbz r11, 0x2abf(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10943 as u32) ) } as u64;
	// 821C6678: 3BA0000F  li r29, 0xf
	ctx.r[29].s64 = 15;
	// 821C667C: 556B06F7  rlwinm. r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C6680: 40820008  bne 0x821c6688
	if !ctx.cr[0].eq {
	pc = 0x821C6688; continue 'dispatch;
	}
	// 821C6684: 3BA0003F  li r29, 0x3f
	ctx.r[29].s64 = 63;
	pc = 0x821C6688; continue 'dispatch;
            }
            0x821C6688 => {
    //   block [0x821C6688..0x821C66FC)
	// 821C6688: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821C668C: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 821C6690: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C6694: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 821C6698: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 821C669C: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 821C66A0: 4809EF51  bl 0x822655f0
	ctx.lr = 0x821C66A4;
	sub_822655F0(ctx, base);
	// 821C66A4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 821C66A8: 811F33A4  lwz r8, 0x33a4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13220 as u32) ) } as u64;
	// 821C66AC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821C66B0: C03F33A0  lfs f1, 0x33a0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821C66B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821C66B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C66BC: 4801C925  bl 0x821e2fe0
	ctx.lr = 0x821C66C0;
	sub_821E2FE0(ctx, base);
	// 821C66C0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821C66C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C66C8: 4809EF29  bl 0x822655f0
	ctx.lr = 0x821C66CC;
	sub_822655F0(ctx, base);
	// 821C66CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C66D0: 81410088  lwz r10, 0x88(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 821C66D4: C0C10084  lfs f6, 0x84(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821C66D8: C0A10080  lfs f5, 0x80(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821C66DC: C081007C  lfs f4, 0x7c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 821C66E0: C0610078  lfs f3, 0x78(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 821C66E4: C0410074  lfs f2, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821C66E8: C0210070  lfs f1, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821C66EC: 48033615  bl 0x821f9d00
	ctx.lr = 0x821C66F0;
	sub_821F9D00(ctx, base);
	// 821C66F0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821C66F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C66F8: 48033511  bl 0x821f9c08
	ctx.lr = 0x821C66FC;
	sub_821F9C08(ctx, base);
	pc = 0x821C66FC; continue 'dispatch;
            }
            0x821C66FC => {
    //   block [0x821C66FC..0x821C6704)
	// 821C66FC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821C6700: 48AE2D50  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C6708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C6708 size=92
    let mut pc: u32 = 0x821C6708;
    'dispatch: loop {
        match pc {
            0x821C6708 => {
    //   block [0x821C6708..0x821C6764)
	// 821C6708: 548BD97E  srwi r11, r4, 5
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shr(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C670C: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C6710: 548906FE  clrlwi r9, r4, 0x1b
	ctx.r[9].u64 = ctx.r[4].u32 as u64 & 0x0000001Fu64;
	// 821C6714: 396B09E0  addi r11, r11, 0x9e0
	ctx.r[11].s64 = ctx.r[11].s64 + 2528;
	// 821C6718: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821C671C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C6720: 554A07FE  clrlwi r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 821C6724: 7D084830  slw r8, r8, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[8].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 821C6728: 7CEB182E  lwzx r7, r11, r3
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 821C672C: 7D4A4830  slw r10, r10, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[10].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 821C6730: 7CE94078  andc r9, r7, r8
	ctx.r[9].u64 = ctx.r[7].u64 & !ctx.r[8].u64;
	// 821C6734: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821C6738: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 821C673C: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 821C6740: 7D4B192E  stwx r10, r11, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), ctx.r[10].u32) };
	// 821C6744: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 821C6748: 4082FFC0  bne 0x821c6708
	if !ctx.cr[0].eq {
	pc = 0x821C6708; continue 'dispatch;
	}
	// 821C674C: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 821C6750: E9630020  ld r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	// 821C6754: 798CC7E6  rldicr r12, r12, 0x38, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(56) & 0xFFFFFFFFFFFFFFFF;
	// 821C6758: 7D6B6378  or r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[12].u64;
	// 821C675C: F9630020  std r11, 0x20(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u64 ) };
	// 821C6760: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C6768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C6768 size=140
    let mut pc: u32 = 0x821C6768;
    'dispatch: loop {
        match pc {
            0x821C6768 => {
    //   block [0x821C6768..0x821C6790)
	// 821C6768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C676C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C6770: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821C6774: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C6778: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C677C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821C6780: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C6784: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C6788: 419A0054  beq cr6, 0x821c67dc
	if ctx.cr[6].eq {
	pc = 0x821C67DC; continue 'dispatch;
	}
	// 821C678C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	pc = 0x821C6790; continue 'dispatch;
            }
            0x821C6790 => {
    //   block [0x821C6790..0x821C67D4)
	// 821C6790: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821C6794: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821C6798: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821C679C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821C67A0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821C67A4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821C67A8: 4082FFE8  bne 0x821c6790
	if !ctx.cr[0].eq {
	pc = 0x821C6790; continue 'dispatch;
	}
	// 821C67AC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821C67B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C67B4: 41990020  bgt cr6, 0x821c67d4
	if ctx.cr[6].gt {
	pc = 0x821C67D4; continue 'dispatch;
	}
	// 821C67B8: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C67BC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821C67C0: 419A0014  beq cr6, 0x821c67d4
	if ctx.cr[6].eq {
	pc = 0x821C67D4; continue 'dispatch;
	}
	// 821C67C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C67C8: 48979259  bl 0x82b3fa20
	ctx.lr = 0x821C67CC;
	sub_82B3FA20(ctx, base);
	// 821C67CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C67D0: 48055569  bl 0x8221bd38
	ctx.lr = 0x821C67D4;
	sub_8221BD38(ctx, base);
	pc = 0x821C67D4; continue 'dispatch;
            }
            0x821C67D4 => {
    //   block [0x821C67D4..0x821C67DC)
	// 821C67D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C67D8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x821C67DC; continue 'dispatch;
            }
            0x821C67DC => {
    //   block [0x821C67DC..0x821C67F4)
	// 821C67DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821C67E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C67E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C67E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821C67EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C67F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C67F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C67F8 size=88
    let mut pc: u32 = 0x821C67F8;
    'dispatch: loop {
        match pc {
            0x821C67F8 => {
    //   block [0x821C67F8..0x821C6818)
	// 821C67F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C67FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C6800: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C6804: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C6808: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C680C: 4BFFFF5D  bl 0x821c6768
	ctx.lr = 0x821C6810;
	sub_821C6768(ctx, base);
	// 821C6810: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C6814: 390B708C  addi r8, r11, 0x708c
	ctx.r[8].s64 = ctx.r[11].s64 + 28812;
	pc = 0x821C6818; continue 'dispatch;
            }
            0x821C6818 => {
    //   block [0x821C6818..0x821C6850)
	// 821C6818: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821C681C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821C6820: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821C6824: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821C6828: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821C682C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821C6830: 4082FFE8  bne 0x821c6818
	if !ctx.cr[0].eq {
	pc = 0x821C6818; continue 'dispatch;
	}
	// 821C6834: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821C6838: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821C683C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C6840: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C6844: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C6848: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C684C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C6850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C6850 size=16
    let mut pc: u32 = 0x821C6850;
    'dispatch: loop {
        match pc {
            0x821C6850 => {
    //   block [0x821C6850..0x821C6860)
	// 821C6850: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 821C6854: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821C6858: 480C0558  b 0x82286db0
	sub_82286DB0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C6860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C6860 size=136
    let mut pc: u32 = 0x821C6860;
    'dispatch: loop {
        match pc {
            0x821C6860 => {
    //   block [0x821C6860..0x821C68B8)
	// 821C6860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C6864: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C6868: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C686C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C6870: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821C6874: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821C6878: 480AF619  bl 0x82275e90
	ctx.lr = 0x821C687C;
	sub_82275E90(ctx, base);
	// 821C687C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821C6880: 419A0050  beq cr6, 0x821c68d0
	if ctx.cr[6].eq {
	pc = 0x821C68D0; continue 'dispatch;
	}
	// 821C6884: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821C6888: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821C688C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821C6890: 419A0028  beq cr6, 0x821c68b8
	if ctx.cr[6].eq {
	pc = 0x821C68B8; continue 'dispatch;
	}
	// 821C6894: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821C6898: 409A0020  bne cr6, 0x821c68b8
	if !ctx.cr[6].eq {
	pc = 0x821C68B8; continue 'dispatch;
	}
	// 821C689C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C68A0: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C68A4: 816BE454  lwz r11, -0x1bac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 821C68A8: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C68AC: 409A000C  bne cr6, 0x821c68b8
	if !ctx.cr[6].eq {
	pc = 0x821C68B8; continue 'dispatch;
	}
	// 821C68B0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C68B4: 394BE460  addi r10, r11, -0x1ba0
	ctx.r[10].s64 = ctx.r[11].s64 + -7072;
	pc = 0x821C68B8; continue 'dispatch;
            }
            0x821C68B8 => {
    //   block [0x821C68B8..0x821C68D0)
	// 821C68B8: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C68BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821C68C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C68C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C68C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C68CC: 4E800020  blr
	return;
            }
            0x821C68D0 => {
    //   block [0x821C68D0..0x821C68E8)
	// 821C68D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C68D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821C68D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C68DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C68E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C68E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C68E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C68E8 size=1200
    let mut pc: u32 = 0x821C68E8;
    'dispatch: loop {
        match pc {
            0x821C68E8 => {
    //   block [0x821C68E8..0x821C6978)
	// 821C68E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C68EC: 48AE2B1D  bl 0x82ca9408
	ctx.lr = 0x821C68F0;
	sub_82CA93D0(ctx, base);
	// 821C68F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C68F4: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821C68F8: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821C68FC: 396B63A0  addi r11, r11, 0x63a0
	ctx.r[11].s64 = ctx.r[11].s64 + 25504;
	// 821C6900: 3BEA2390  addi r31, r10, 0x2390
	ctx.r[31].s64 = ctx.r[10].s64 + 9104;
	// 821C6904: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821C6908: 3FC08349  lis r30, -0x7cb7
	ctx.r[30].s64 = -2092367872;
	// 821C690C: 3BA90DB8  addi r29, r9, 0xdb8
	ctx.r[29].s64 = ctx.r[9].s64 + 3512;
	// 821C6910: 894B00D5  lbz r10, 0xd5(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(213 as u32) ) } as u64;
	// 821C6914: 812B00C4  lwz r9, 0xc4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) } as u64;
	// 821C6918: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821C691C: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 821C6920: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 821C6924: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C6928: 419A0084  beq cr6, 0x821c69ac
	if ctx.cr[6].eq {
	pc = 0x821C69AC; continue 'dispatch;
	}
	// 821C692C: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C6930: 810B00C8  lwz r8, 0xc8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(200 as u32) ) } as u64;
	// 821C6934: 7D274038  and r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821C6938: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C693C: 409A003C  bne cr6, 0x821c6978
	if !ctx.cr[6].eq {
	pc = 0x821C6978; continue 'dispatch;
	}
	// 821C6940: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6944: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821C6948: 38CB00C0  addi r6, r11, 0xc0
	ctx.r[6].s64 = ctx.r[11].s64 + 192;
	// 821C694C: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821C6950: 912B00C8  stw r9, 0xc8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(200 as u32), ctx.r[9].u32 ) };
	// 821C6954: 7CC5512E  stwx r6, r5, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32), ctx.r[6].u32) };
	// 821C6958: 812B00C4  lwz r9, 0xc4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) } as u64;
	// 821C695C: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6960: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C6964: 7CE85214  add r7, r8, r10
	ctx.r[7].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C6968: 91270004  stw r9, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C696C: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6970: 38C90001  addi r6, r9, 1
	ctx.r[6].s64 = ctx.r[9].s64 + 1;
	// 821C6974: 90CA2004  stw r6, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[6].u32 ) };
	pc = 0x821C6978; continue 'dispatch;
            }
            0x821C6978 => {
    //   block [0x821C6978..0x821C69AC)
	// 821C6978: 894B00D4  lbz r10, 0xd4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 821C697C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821C6980: 912B00C4  stw r9, 0xc4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(196 as u32), ctx.r[9].u32 ) };
	// 821C6984: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C6988: 409A0024  bne cr6, 0x821c69ac
	if !ctx.cr[6].eq {
	pc = 0x821C69AC; continue 'dispatch;
	}
	// 821C698C: 815E0DB0  lwz r10, 0xdb0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821C6990: 390B00C0  addi r8, r11, 0xc0
	ctx.r[8].s64 = ctx.r[11].s64 + 192;
	// 821C6994: 992B00D4  stb r9, 0xd4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[9].u8 ) };
	// 821C6998: 5547103A  slwi r7, r10, 2
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821C699C: 38CA0001  addi r6, r10, 1
	ctx.r[6].s64 = ctx.r[10].s64 + 1;
	// 821C69A0: 90DE0DB0  stw r6, 0xdb0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 821C69A4: 7D07E92E  stwx r8, r7, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[29].u32), ctx.r[8].u32) };
	// 821C69A8: 48000008  b 0x821c69b0
	pc = 0x821C69B0; continue 'dispatch;
            }
            0x821C69AC => {
    //   block [0x821C69AC..0x821C69B0)
	// 821C69AC: 80DE0DB0  lwz r6, 0xdb0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(3504 as u32) ) } as u64;
	pc = 0x821C69B0; continue 'dispatch;
            }
            0x821C69B0 => {
    //   block [0x821C69B0..0x821C6A18)
	// 821C69B0: 894B00ED  lbz r10, 0xed(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(237 as u32) ) } as u64;
	// 821C69B4: 812B00DC  lwz r9, 0xdc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(220 as u32) ) } as u64;
	// 821C69B8: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821C69BC: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 821C69C0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C69C4: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C69C8: 419A0080  beq cr6, 0x821c6a48
	if ctx.cr[6].eq {
	pc = 0x821C6A48; continue 'dispatch;
	}
	// 821C69CC: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C69D0: 810B00E0  lwz r8, 0xe0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(224 as u32) ) } as u64;
	// 821C69D4: 7D274038  and r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821C69D8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C69DC: 409A003C  bne cr6, 0x821c6a18
	if !ctx.cr[6].eq {
	pc = 0x821C6A18; continue 'dispatch;
	}
	// 821C69E0: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C69E4: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821C69E8: 38AB00D8  addi r5, r11, 0xd8
	ctx.r[5].s64 = ctx.r[11].s64 + 216;
	// 821C69EC: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C69F0: 912B00E0  stw r9, 0xe0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(224 as u32), ctx.r[9].u32 ) };
	// 821C69F4: 7CA8512E  stwx r5, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[5].u32) };
	// 821C69F8: 812B00DC  lwz r9, 0xdc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(220 as u32) ) } as u64;
	// 821C69FC: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6A00: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C6A04: 7CA85214  add r5, r8, r10
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C6A08: 91250004  stw r9, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C6A0C: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6A10: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821C6A14: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	pc = 0x821C6A18; continue 'dispatch;
            }
            0x821C6A18 => {
    //   block [0x821C6A18..0x821C6A48)
	// 821C6A18: 894B00EC  lbz r10, 0xec(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(236 as u32) ) } as u64;
	// 821C6A1C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821C6A20: 912B00DC  stw r9, 0xdc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(220 as u32), ctx.r[9].u32 ) };
	// 821C6A24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C6A28: 409A0020  bne cr6, 0x821c6a48
	if !ctx.cr[6].eq {
	pc = 0x821C6A48; continue 'dispatch;
	}
	// 821C6A2C: 54C9103A  slwi r9, r6, 2
	ctx.r[9].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C6A30: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C6A34: 390B00D8  addi r8, r11, 0xd8
	ctx.r[8].s64 = ctx.r[11].s64 + 216;
	// 821C6A38: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 821C6A3C: 994B00EC  stb r10, 0xec(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(236 as u32), ctx.r[10].u8 ) };
	// 821C6A40: 90DE0DB0  stw r6, 0xdb0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 821C6A44: 7D09E92E  stwx r8, r9, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[29].u32), ctx.r[8].u32) };
	pc = 0x821C6A48; continue 'dispatch;
            }
            0x821C6A48 => {
    //   block [0x821C6A48..0x821C6ABC)
	// 821C6A48: 3D008331  lis r8, -0x7ccf
	ctx.r[8].s64 = -2093940736;
	// 821C6A4C: 894B0105  lbz r10, 0x105(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(261 as u32) ) } as u64;
	// 821C6A50: 812B00F4  lwz r9, 0xf4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(244 as u32) ) } as u64;
	// 821C6A54: 38A8701C  addi r5, r8, 0x701c
	ctx.r[5].s64 = ctx.r[8].s64 + 28700;
	// 821C6A58: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821C6A5C: 80E50010  lwz r7, 0x10(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C6A60: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 821C6A64: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821C6A68: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C6A6C: 419A007C  beq cr6, 0x821c6ae8
	if ctx.cr[6].eq {
	pc = 0x821C6AE8; continue 'dispatch;
	}
	// 821C6A70: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C6A74: 810B00F8  lwz r8, 0xf8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(248 as u32) ) } as u64;
	// 821C6A78: 7D3C4038  and r28, r9, r8
	ctx.r[28].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821C6A7C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821C6A80: 409A003C  bne cr6, 0x821c6abc
	if !ctx.cr[6].eq {
	pc = 0x821C6ABC; continue 'dispatch;
	}
	// 821C6A84: 838A2004  lwz r28, 0x2004(r10)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6A88: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821C6A8C: 390B00F0  addi r8, r11, 0xf0
	ctx.r[8].s64 = ctx.r[11].s64 + 240;
	// 821C6A90: 579C1838  slwi r28, r28, 3
	ctx.r[28].u32 = ctx.r[28].u32.wrapping_shl(3);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 821C6A94: 912B00F8  stw r9, 0xf8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(248 as u32), ctx.r[9].u32 ) };
	// 821C6A98: 7D1C512E  stwx r8, r28, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[28].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u32) };
	// 821C6A9C: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6AA0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C6AA4: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C6AA8: 812B00F4  lwz r9, 0xf4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(244 as u32) ) } as u64;
	// 821C6AAC: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C6AB0: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6AB4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821C6AB8: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	pc = 0x821C6ABC; continue 'dispatch;
            }
            0x821C6ABC => {
    //   block [0x821C6ABC..0x821C6AE8)
	// 821C6ABC: 894B0104  lbz r10, 0x104(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) } as u64;
	// 821C6AC0: 90EB00F4  stw r7, 0xf4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(244 as u32), ctx.r[7].u32 ) };
	// 821C6AC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C6AC8: 409A0020  bne cr6, 0x821c6ae8
	if !ctx.cr[6].eq {
	pc = 0x821C6AE8; continue 'dispatch;
	}
	// 821C6ACC: 54C9103A  slwi r9, r6, 2
	ctx.r[9].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C6AD0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C6AD4: 390B00F0  addi r8, r11, 0xf0
	ctx.r[8].s64 = ctx.r[11].s64 + 240;
	// 821C6AD8: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 821C6ADC: 994B0104  stb r10, 0x104(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(260 as u32), ctx.r[10].u8 ) };
	// 821C6AE0: 90DE0DB0  stw r6, 0xdb0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 821C6AE4: 7D09E92E  stwx r8, r9, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[29].u32), ctx.r[8].u32) };
	pc = 0x821C6AE8; continue 'dispatch;
            }
            0x821C6AE8 => {
    //   block [0x821C6AE8..0x821C6B54)
	// 821C6AE8: 894B011D  lbz r10, 0x11d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(285 as u32) ) } as u64;
	// 821C6AEC: 80E50014  lwz r7, 0x14(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C6AF0: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821C6AF4: 812B010C  lwz r9, 0x10c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(268 as u32) ) } as u64;
	// 821C6AF8: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 821C6AFC: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821C6B00: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C6B04: 419A007C  beq cr6, 0x821c6b80
	if ctx.cr[6].eq {
	pc = 0x821C6B80; continue 'dispatch;
	}
	// 821C6B08: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C6B0C: 810B0110  lwz r8, 0x110(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(272 as u32) ) } as u64;
	// 821C6B10: 7D254038  and r5, r9, r8
	ctx.r[5].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821C6B14: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821C6B18: 409A003C  bne cr6, 0x821c6b54
	if !ctx.cr[6].eq {
	pc = 0x821C6B54; continue 'dispatch;
	}
	// 821C6B1C: 80AA2004  lwz r5, 0x2004(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6B20: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821C6B24: 390B0108  addi r8, r11, 0x108
	ctx.r[8].s64 = ctx.r[11].s64 + 264;
	// 821C6B28: 54A51838  slwi r5, r5, 3
	ctx.r[5].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821C6B2C: 912B0110  stw r9, 0x110(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(272 as u32), ctx.r[9].u32 ) };
	// 821C6B30: 7D05512E  stwx r8, r5, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u32) };
	// 821C6B34: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6B38: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C6B3C: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C6B40: 812B010C  lwz r9, 0x10c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(268 as u32) ) } as u64;
	// 821C6B44: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C6B48: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6B4C: 38A90001  addi r5, r9, 1
	ctx.r[5].s64 = ctx.r[9].s64 + 1;
	// 821C6B50: 90AA2004  stw r5, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[5].u32 ) };
	pc = 0x821C6B54; continue 'dispatch;
            }
            0x821C6B54 => {
    //   block [0x821C6B54..0x821C6B80)
	// 821C6B54: 894B011C  lbz r10, 0x11c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(284 as u32) ) } as u64;
	// 821C6B58: 90EB010C  stw r7, 0x10c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(268 as u32), ctx.r[7].u32 ) };
	// 821C6B5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C6B60: 409A0020  bne cr6, 0x821c6b80
	if !ctx.cr[6].eq {
	pc = 0x821C6B80; continue 'dispatch;
	}
	// 821C6B64: 54C9103A  slwi r9, r6, 2
	ctx.r[9].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C6B68: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C6B6C: 390B0108  addi r8, r11, 0x108
	ctx.r[8].s64 = ctx.r[11].s64 + 264;
	// 821C6B70: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 821C6B74: 994B011C  stb r10, 0x11c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(284 as u32), ctx.r[10].u8 ) };
	// 821C6B78: 90DE0DB0  stw r6, 0xdb0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 821C6B7C: 7D09E92E  stwx r8, r9, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[29].u32), ctx.r[8].u32) };
	pc = 0x821C6B80; continue 'dispatch;
            }
            0x821C6B80 => {
    //   block [0x821C6B80..0x821C6BE8)
	// 821C6B80: 894B00BD  lbz r10, 0xbd(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(189 as u32) ) } as u64;
	// 821C6B84: 812B00AC  lwz r9, 0xac(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(172 as u32) ) } as u64;
	// 821C6B88: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821C6B8C: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 821C6B90: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 821C6B94: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C6B98: 419A0080  beq cr6, 0x821c6c18
	if ctx.cr[6].eq {
	pc = 0x821C6C18; continue 'dispatch;
	}
	// 821C6B9C: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C6BA0: 810B00B0  lwz r8, 0xb0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(176 as u32) ) } as u64;
	// 821C6BA4: 7D274038  and r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821C6BA8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C6BAC: 409A003C  bne cr6, 0x821c6be8
	if !ctx.cr[6].eq {
	pc = 0x821C6BE8; continue 'dispatch;
	}
	// 821C6BB0: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6BB4: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821C6BB8: 38AB00A8  addi r5, r11, 0xa8
	ctx.r[5].s64 = ctx.r[11].s64 + 168;
	// 821C6BBC: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C6BC0: 912B00B0  stw r9, 0xb0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(176 as u32), ctx.r[9].u32 ) };
	// 821C6BC4: 7CA8512E  stwx r5, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[5].u32) };
	// 821C6BC8: 812B00AC  lwz r9, 0xac(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(172 as u32) ) } as u64;
	// 821C6BCC: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6BD0: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C6BD4: 7CA85214  add r5, r8, r10
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C6BD8: 91250004  stw r9, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C6BDC: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6BE0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821C6BE4: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	pc = 0x821C6BE8; continue 'dispatch;
            }
            0x821C6BE8 => {
    //   block [0x821C6BE8..0x821C6C18)
	// 821C6BE8: 894B00BC  lbz r10, 0xbc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) } as u64;
	// 821C6BEC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821C6BF0: 912B00AC  stw r9, 0xac(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(172 as u32), ctx.r[9].u32 ) };
	// 821C6BF4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C6BF8: 409A0020  bne cr6, 0x821c6c18
	if !ctx.cr[6].eq {
	pc = 0x821C6C18; continue 'dispatch;
	}
	// 821C6BFC: 54C9103A  slwi r9, r6, 2
	ctx.r[9].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C6C00: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C6C04: 390B00A8  addi r8, r11, 0xa8
	ctx.r[8].s64 = ctx.r[11].s64 + 168;
	// 821C6C08: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 821C6C0C: 994B00BC  stb r10, 0xbc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(188 as u32), ctx.r[10].u8 ) };
	// 821C6C10: 90DE0DB0  stw r6, 0xdb0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 821C6C14: 7D09E92E  stwx r8, r9, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[29].u32), ctx.r[8].u32) };
	pc = 0x821C6C18; continue 'dispatch;
            }
            0x821C6C18 => {
    //   block [0x821C6C18..0x821C6C80)
	// 821C6C18: 894B0045  lbz r10, 0x45(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(69 as u32) ) } as u64;
	// 821C6C1C: 812B0034  lwz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821C6C20: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821C6C24: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 821C6C28: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C6C2C: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C6C30: 419A0080  beq cr6, 0x821c6cb0
	if ctx.cr[6].eq {
	pc = 0x821C6CB0; continue 'dispatch;
	}
	// 821C6C34: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C6C38: 810B0038  lwz r8, 0x38(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 821C6C3C: 7D274038  and r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821C6C40: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C6C44: 409A003C  bne cr6, 0x821c6c80
	if !ctx.cr[6].eq {
	pc = 0x821C6C80; continue 'dispatch;
	}
	// 821C6C48: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6C4C: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821C6C50: 38AB0030  addi r5, r11, 0x30
	ctx.r[5].s64 = ctx.r[11].s64 + 48;
	// 821C6C54: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C6C58: 912B0038  stw r9, 0x38(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 821C6C5C: 7CA8512E  stwx r5, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[5].u32) };
	// 821C6C60: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6C64: 812B0034  lwz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821C6C68: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C6C6C: 7CA85214  add r5, r8, r10
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C6C70: 91250004  stw r9, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C6C74: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6C78: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821C6C7C: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	pc = 0x821C6C80; continue 'dispatch;
            }
            0x821C6C80 => {
    //   block [0x821C6C80..0x821C6CB0)
	// 821C6C80: 894B0044  lbz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 821C6C84: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821C6C88: 912B0034  stw r9, 0x34(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), ctx.r[9].u32 ) };
	// 821C6C8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C6C90: 409A0020  bne cr6, 0x821c6cb0
	if !ctx.cr[6].eq {
	pc = 0x821C6CB0; continue 'dispatch;
	}
	// 821C6C94: 54C9103A  slwi r9, r6, 2
	ctx.r[9].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C6C98: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C6C9C: 390B0030  addi r8, r11, 0x30
	ctx.r[8].s64 = ctx.r[11].s64 + 48;
	// 821C6CA0: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 821C6CA4: 994B0044  stb r10, 0x44(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), ctx.r[10].u8 ) };
	// 821C6CA8: 90DE0DB0  stw r6, 0xdb0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 821C6CAC: 7D09E92E  stwx r8, r9, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[29].u32), ctx.r[8].u32) };
	pc = 0x821C6CB0; continue 'dispatch;
            }
            0x821C6CB0 => {
    //   block [0x821C6CB0..0x821C6D24)
	// 821C6CB0: 3D008331  lis r8, -0x7ccf
	ctx.r[8].s64 = -2093940736;
	// 821C6CB4: 88EB008D  lbz r7, 0x8d(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(141 as u32) ) } as u64;
	// 821C6CB8: 812B007C  lwz r9, 0x7c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821C6CBC: 38A87064  addi r5, r8, 0x7064
	ctx.r[5].s64 = ctx.r[8].s64 + 28772;
	// 821C6CC0: 1D472008  mulli r10, r7, 0x2008
	ctx.r[10].s32 = ((ctx.r[7].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821C6CC4: 80E50008  lwz r7, 8(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C6CC8: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 821C6CCC: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821C6CD0: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C6CD4: 419A007C  beq cr6, 0x821c6d50
	if ctx.cr[6].eq {
	pc = 0x821C6D50; continue 'dispatch;
	}
	// 821C6CD8: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C6CDC: 810B0080  lwz r8, 0x80(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 821C6CE0: 7D254038  and r5, r9, r8
	ctx.r[5].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821C6CE4: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821C6CE8: 409A003C  bne cr6, 0x821c6d24
	if !ctx.cr[6].eq {
	pc = 0x821C6D24; continue 'dispatch;
	}
	// 821C6CEC: 80AA2004  lwz r5, 0x2004(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6CF0: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821C6CF4: 390B0078  addi r8, r11, 0x78
	ctx.r[8].s64 = ctx.r[11].s64 + 120;
	// 821C6CF8: 54A51838  slwi r5, r5, 3
	ctx.r[5].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821C6CFC: 912B0080  stw r9, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 821C6D00: 7D05512E  stwx r8, r5, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u32) };
	// 821C6D04: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6D08: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C6D0C: 812B007C  lwz r9, 0x7c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821C6D10: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C6D14: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C6D18: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C6D1C: 38A90001  addi r5, r9, 1
	ctx.r[5].s64 = ctx.r[9].s64 + 1;
	// 821C6D20: 90AA2004  stw r5, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[5].u32 ) };
	pc = 0x821C6D24; continue 'dispatch;
            }
            0x821C6D24 => {
    //   block [0x821C6D24..0x821C6D50)
	// 821C6D24: 894B008C  lbz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C6D28: 90EB007C  stw r7, 0x7c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(124 as u32), ctx.r[7].u32 ) };
	// 821C6D2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C6D30: 409A0020  bne cr6, 0x821c6d50
	if !ctx.cr[6].eq {
	pc = 0x821C6D50; continue 'dispatch;
	}
	// 821C6D34: 54C8103A  slwi r8, r6, 2
	ctx.r[8].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C6D38: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C6D3C: 38EB0078  addi r7, r11, 0x78
	ctx.r[7].s64 = ctx.r[11].s64 + 120;
	// 821C6D40: 39260001  addi r9, r6, 1
	ctx.r[9].s64 = ctx.r[6].s64 + 1;
	// 821C6D44: 994B008C  stb r10, 0x8c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), ctx.r[10].u8 ) };
	// 821C6D48: 913E0DB0  stw r9, 0xdb0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(3504 as u32), ctx.r[9].u32 ) };
	// 821C6D4C: 7CE8E92E  stwx r7, r8, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[29].u32), ctx.r[7].u32) };
	pc = 0x821C6D50; continue 'dispatch;
            }
            0x821C6D50 => {
    //   block [0x821C6D50..0x821C6D98)
	// 821C6D50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C6D54: 814B0050  lwz r10, 0x50(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 821C6D58: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C6D5C: 4E800421  bctrl
	ctx.lr = 0x821C6D60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C6D60: 3D20834C  lis r9, -0x7cb4
	ctx.r[9].s64 = -2092171264;
	// 821C6D64: 3D008336  lis r8, -0x7cca
	ctx.r[8].s64 = -2093613056;
	// 821C6D68: 38E9DF40  addi r7, r9, -0x20c0
	ctx.r[7].s64 = ctx.r[9].s64 + -8384;
	// 821C6D6C: 3CC08349  lis r6, -0x7cb7
	ctx.r[6].s64 = -2092367872;
	// 821C6D70: 81680364  lwz r11, 0x364(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(868 as u32) ) } as u64;
	// 821C6D74: 8147003C  lwz r10, 0x3c(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(60 as u32) ) } as u64;
	// 821C6D78: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 821C6D7C: 914B2E2C  stw r10, 0x2e2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(11820 as u32), ctx.r[10].u32 ) };
	// 821C6D80: 914670B8  stw r10, 0x70b8(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(28856 as u32), ctx.r[10].u32 ) };
	// 821C6D84: E8850010  ld r4, 0x10(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) };
	// 821C6D88: 64830008  oris r3, r4, 8
	ctx.r[3].u64 = ctx.r[4].u64 | 524288;
	// 821C6D8C: F8650010  std r3, 0x10(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(16 as u32), ctx.r[3].u64 ) };
	// 821C6D90: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821C6D94: 48AE26C4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C6D98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C6D98 size=20
    let mut pc: u32 = 0x821C6D98;
    'dispatch: loop {
        match pc {
            0x821C6D98 => {
    //   block [0x821C6D98..0x821C6DAC)
	// 821C6D98: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C6D9C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821C6DA0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821C6DA4: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 821C6DA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C6DB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C6DB0 size=180
    let mut pc: u32 = 0x821C6DB0;
    'dispatch: loop {
        match pc {
            0x821C6DB0 => {
    //   block [0x821C6DB0..0x821C6DCC)
	// 821C6DB0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821C6DB4: 419A0018  beq cr6, 0x821c6dcc
	if ctx.cr[6].eq {
	pc = 0x821C6DCC; continue 'dispatch;
	}
	// 821C6DB8: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 821C6DBC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821C6DC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C6DC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C6DC8: 409A0008  bne cr6, 0x821c6dd0
	if !ctx.cr[6].eq {
	pc = 0x821C6DD0; continue 'dispatch;
	}
	pc = 0x821C6DCC; continue 'dispatch;
            }
            0x821C6DCC => {
    //   block [0x821C6DCC..0x821C6DD0)
	// 821C6DCC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821C6DD0; continue 'dispatch;
            }
            0x821C6DD0 => {
    //   block [0x821C6DD0..0x821C6DE8)
	// 821C6DD0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C6DD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C6DD8: 419A008C  beq cr6, 0x821c6e64
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x821C6E64);
		return;
	}
	// 821C6DDC: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C6DE0: 39030010  addi r8, r3, 0x10
	ctx.r[8].s64 = ctx.r[3].s64 + 16;
	// 821C6DE4: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	pc = 0x821C6DE8; continue 'dispatch;
            }
            0x821C6DE8 => {
    //   block [0x821C6DE8..0x821C6DF8)
	// 821C6DE8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C6DEC: 7F084040  cmplw cr6, r8, r8
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821C6DF0: 419A0008  beq cr6, 0x821c6df8
	if ctx.cr[6].eq {
	pc = 0x821C6DF8; continue 'dispatch;
	}
	// 821C6DF4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C6DF8; continue 'dispatch;
            }
            0x821C6DF8 => {
    //   block [0x821C6DF8..0x821C6E10)
	// 821C6DF8: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821C6DFC: 419A0068  beq cr6, 0x821c6e64
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x821C6E64);
		return;
	}
	// 821C6E00: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C6E04: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821C6E08: 409A0008  bne cr6, 0x821c6e10
	if !ctx.cr[6].eq {
	pc = 0x821C6E10; continue 'dispatch;
	}
	// 821C6E0C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C6E10; continue 'dispatch;
            }
            0x821C6E10 => {
    //   block [0x821C6E10..0x821C6E3C)
	// 821C6E10: E94B0008  ld r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821C6E14: 80C40014  lwz r6, 0x14(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C6E18: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 821C6E1C: 80A1FFF0  lwz r5, -0x10(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 821C6E20: 7F053040  cmplw cr6, r5, r6
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C6E24: 409A0018  bne cr6, 0x821c6e3c
	if !ctx.cr[6].eq {
	pc = 0x821C6E3C; continue 'dispatch;
	}
	// 821C6E28: 81440018  lwz r10, 0x18(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 821C6E2C: 80C1FFF4  lwz r6, -0xc(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 821C6E30: 7F065040  cmplw cr6, r6, r10
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821C6E34: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C6E38: 419A0008  beq cr6, 0x821c6e40
	if ctx.cr[6].eq {
	pc = 0x821C6E40; continue 'dispatch;
	}
	pc = 0x821C6E3C; continue 'dispatch;
            }
            0x821C6E3C => {
    //   block [0x821C6E3C..0x821C6E40)
	// 821C6E3C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821C6E40; continue 'dispatch;
            }
            0x821C6E40 => {
    //   block [0x821C6E40..0x821C6E5C)
	// 821C6E40: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821C6E44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C6E48: 409A0014  bne cr6, 0x821c6e5c
	if !ctx.cr[6].eq {
	pc = 0x821C6E5C; continue 'dispatch;
	}
	// 821C6E4C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821C6E50: 409AFF98  bne cr6, 0x821c6de8
	if !ctx.cr[6].eq {
	pc = 0x821C6DE8; continue 'dispatch;
	}
	// 821C6E54: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 821C6E58: 4BFFFF90  b 0x821c6de8
	pc = 0x821C6DE8; continue 'dispatch;
            }
            0x821C6E5C => {
    //   block [0x821C6E5C..0x821C6E64)
	// 821C6E5C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821C6E60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C6E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C6E70 size=236
    let mut pc: u32 = 0x821C6E70;
    'dispatch: loop {
        match pc {
            0x821C6E70 => {
    //   block [0x821C6E70..0x821C6EA8)
	// 821C6E70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C6E74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C6E78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C6E7C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C6E80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C6E84: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821C6E88: 409A0020  bne cr6, 0x821c6ea8
	if !ctx.cr[6].eq {
	pc = 0x821C6EA8; continue 'dispatch;
	}
	// 821C6E8C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C6E90: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821C6E94: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821C6E98: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C6E9C: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 821C6EA0: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 821C6EA4: 4800002C  b 0x821c6ed0
	pc = 0x821C6ED0; continue 'dispatch;
            }
            0x821C6EA8 => {
    //   block [0x821C6EA8..0x821C6EAC)
	// 821C6EA8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	pc = 0x821C6EAC; continue 'dispatch;
            }
            0x821C6EAC => {
    //   block [0x821C6EAC..0x821C6ED0)
	// 821C6EAC: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C6EB0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821C6EB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C6EB8: 409AFFF4  bne cr6, 0x821c6eac
	if !ctx.cr[6].eq {
	pc = 0x821C6EAC; continue 'dispatch;
	}
	// 821C6EBC: 7D645850  subf r11, r4, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 821C6EC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C6EC4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C6EC8: 5565003E  slwi r5, r11, 0
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821C6ECC: 4885D60D  bl 0x82a244d8
	ctx.lr = 0x821C6ED0;
	sub_82A244D8(ctx, base);
	pc = 0x821C6ED0; continue 'dispatch;
            }
            0x821C6ED0 => {
    //   block [0x821C6ED0..0x821C6F38)
	// 821C6ED0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C6ED4: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 821C6ED8: 806BFFF0  lwz r3, -0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) } as u64;
	// 821C6EDC: 480615FD  bl 0x822284d8
	ctx.lr = 0x821C6EE0;
	sub_822284D8(ctx, base);
	// 821C6EE0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C6EE4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821C6EE8: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C6EEC: 392A9700  addi r9, r10, -0x6900
	ctx.r[9].s64 = ctx.r[10].s64 + -26880;
	// 821C6EF0: 910BFFF8  stw r8, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[8].u32 ) };
	// 821C6EF4: 80E30004  lwz r7, 4(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C6EF8: 90EBFFFC  stw r7, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[7].u32 ) };
	// 821C6EFC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C6F00: 394BFFF8  addi r10, r11, -8
	ctx.r[10].s64 = ctx.r[11].s64 + -8;
	// 821C6F04: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821C6F08: 419A0030  beq cr6, 0x821c6f38
	if ctx.cr[6].eq {
	pc = 0x821C6F38; continue 'dispatch;
	}
	// 821C6F0C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C6F10: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821C6F14: 409A0024  bne cr6, 0x821c6f38
	if !ctx.cr[6].eq {
	pc = 0x821C6F38; continue 'dispatch;
	}
	// 821C6F18: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 821C6F1C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821C6F20: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821C6F24: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C6F28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C6F2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C6F30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C6F34: 4E800020  blr
	return;
            }
            0x821C6F38 => {
    //   block [0x821C6F38..0x821C6F5C)
	// 821C6F38: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 821C6F3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C6F40: 48019449  bl 0x821e0388
	ctx.lr = 0x821C6F44;
	sub_821E0388(ctx, base);
	// 821C6F44: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821C6F48: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C6F4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C6F50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C6F54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C6F58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C6F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821C6F60 size=28
    let mut pc: u32 = 0x821C6F60;
    'dispatch: loop {
        match pc {
            0x821C6F60 => {
    //   block [0x821C6F60..0x821C6F7C)
	// 821C6F60: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C6F64: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821C6F68: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C6F6C: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821C6F70: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C6F74: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821C6F78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C6F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C6F80 size=224
    let mut pc: u32 = 0x821C6F80;
    'dispatch: loop {
        match pc {
            0x821C6F80 => {
    //   block [0x821C6F80..0x821C6FE8)
	// 821C6F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C6F84: 48AE2485  bl 0x82ca9408
	ctx.lr = 0x821C6F88;
	sub_82CA93D0(ctx, base);
	// 821C6F88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C6F8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821C6F90: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821C6F94: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821C6F98: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821C6F9C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 821C6FA0: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821C6FA4: 393F0020  addi r9, r31, 0x20
	ctx.r[9].s64 = ctx.r[31].s64 + 32;
	// 821C6FA8: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821C6FAC: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 821C6FB0: E91E0020  ld r8, 0x20(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) };
	// 821C6FB4: F91F0020  std r8, 0x20(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[8].u64 ) };
	// 821C6FB8: E8FE0028  ld r7, 0x28(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	// 821C6FBC: F8FF0028  std r7, 0x28(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[7].u64 ) };
	// 821C6FC0: 915F0014  stw r10, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 821C6FC4: 40990094  ble cr6, 0x821c7058
	if !ctx.cr[6].gt {
	pc = 0x821C7058; continue 'dispatch;
	}
	// 821C6FC8: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 821C6FCC: 4883E025  bl 0x82a04ff0
	ctx.lr = 0x821C6FD0;
	sub_82A04FF0(ctx, base);
	// 821C6FD0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821C6FD4: 419A006C  beq cr6, 0x821c7040
	if ctx.cr[6].eq {
	pc = 0x821C7040; continue 'dispatch;
	}
	// 821C6FD8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821C6FDC: 419A007C  beq cr6, 0x821c7058
	if ctx.cr[6].eq {
	pc = 0x821C7058; continue 'dispatch;
	}
	// 821C6FE0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821C6FE4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	pc = 0x821C6FE8; continue 'dispatch;
            }
            0x821C6FE8 => {
    //   block [0x821C6FE8..0x821C7014)
	// 821C6FE8: 811C0004  lwz r8, 4(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C6FEC: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 821C6FF0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C6FF4: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C6FF8: 7CEB2A14  add r7, r11, r5
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 821C6FFC: 7D68302E  lwzx r11, r8, r6
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 821C7000: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C7004: 7C8B4214  add r4, r11, r8
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 821C7008: 548B2036  slwi r11, r4, 4
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C700C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821C7010: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x821C7014; continue 'dispatch;
            }
            0x821C7014 => {
    //   block [0x821C7014..0x821C7040)
	// 821C7014: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821C7018: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821C701C: F9470000  std r10, 0(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 821C7020: 38E70008  addi r7, r7, 8
	ctx.r[7].s64 = ctx.r[7].s64 + 8;
	// 821C7024: 4200FFF0  bdnz 0x821c7014
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821C7014; continue 'dispatch;
	}
	// 821C7028: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821C702C: 38C60008  addi r6, r6, 8
	ctx.r[6].s64 = ctx.r[6].s64 + 8;
	// 821C7030: 38A50030  addi r5, r5, 0x30
	ctx.r[5].s64 = ctx.r[5].s64 + 48;
	// 821C7034: 4082FFB4  bne 0x821c6fe8
	if !ctx.cr[0].eq {
	pc = 0x821C6FE8; continue 'dispatch;
	}
	// 821C7038: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821C703C: 48AE241C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x821C7040 => {
    //   block [0x821C7040..0x821C7058)
	// 821C7040: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C7044: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C7048: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C704C: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 821C7050: 55652036  slwi r5, r11, 4
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821C7054: 48041445  bl 0x82208498
	ctx.lr = 0x821C7058;
	sub_82208498(ctx, base);
	pc = 0x821C7058; continue 'dispatch;
            }
            0x821C7058 => {
    //   block [0x821C7058..0x821C7060)
	// 821C7058: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821C705C: 48AE23FC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C7060 size=280
    let mut pc: u32 = 0x821C7060;
    'dispatch: loop {
        match pc {
            0x821C7060 => {
    //   block [0x821C7060..0x821C7088)
	// 821C7060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C7064: 48AE239D  bl 0x82ca9400
	ctx.lr = 0x821C7068;
	sub_82CA93D0(ctx, base);
	// 821C7068: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C706C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821C7070: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821C7074: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821C7078: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 821C707C: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 821C7080: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 821C7084: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821C7088; continue 'dispatch;
            }
            0x821C7088 => {
    //   block [0x821C7088..0x821C70B0)
	// 821C7088: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C708C: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 821C7090: 419A0020  beq cr6, 0x821c70b0
	if ctx.cr[6].eq {
	pc = 0x821C70B0; continue 'dispatch;
	}
	// 821C7094: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821C7098: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 821C709C: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 821C70A0: 4198FFE8  blt cr6, 0x821c7088
	if ctx.cr[6].lt {
	pc = 0x821C7088; continue 'dispatch;
	}
	// 821C70A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821C70A8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821C70AC: 48AE23A4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x821C70B0 => {
    //   block [0x821C70B0..0x821C7128)
	// 821C70B0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C70B4: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 821C70B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C70BC: 409A0074  bne cr6, 0x821c7130
	if !ctx.cr[6].eq {
	pc = 0x821C7130; continue 'dispatch;
	}
	// 821C70C0: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 821C70C4: 48058195  bl 0x8221f258
	ctx.lr = 0x821C70C8;
	sub_8221F258(ctx, base);
	// 821C70C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821C70CC: 419A005C  beq cr6, 0x821c7128
	if ctx.cr[6].eq {
	pc = 0x821C7128; continue 'dispatch;
	}
	// 821C70D0: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 821C70D4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821C70D8: 392BFF08  addi r9, r11, -0xf8
	ctx.r[9].s64 = ctx.r[11].s64 + -248;
	// 821C70DC: 390A9160  addi r8, r10, -0x6ea0
	ctx.r[8].s64 = ctx.r[10].s64 + -28320;
	// 821C70E0: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821C70E4: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 821C70E8: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 821C70EC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821C70F0: 93C3000C  stw r30, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 821C70F4: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 821C70F8: 93C30010  stw r30, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 821C70FC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821C7100: 93C30014  stw r30, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	pc = 0x821C7128; continue 'dispatch;
            }
            0x821C7128 => {
    //   block [0x821C7128..0x821C7130)
	// 821C7128: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821C712C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x821C7130; continue 'dispatch;
            }
            0x821C7130 => {
    //   block [0x821C7130..0x821C7178)
	// 821C7130: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 821C7134: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C7138: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821C713C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821C7140: 4BFFFE41  bl 0x821c6f80
	ctx.lr = 0x821C7144;
	sub_821C6F80(ctx, base);
	// 821C7144: 897D0029  lbz r11, 0x29(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(41 as u32) ) } as u64;
	// 821C7148: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C714C: 409A0020  bne cr6, 0x821c716c
	if !ctx.cr[6].eq {
	pc = 0x821C716C; continue 'dispatch;
	}
	// 821C7150: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821C7154: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821C7158: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821C715C: 386BE8D8  addi r3, r11, -0x1728
	ctx.r[3].s64 = ctx.r[11].s64 + -5928;
	// 821C7160: 4887CE91  bl 0x82a43ff0
	ctx.lr = 0x821C7164;
	sub_82A43FF0(ctx, base);
	// 821C7164: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C7168: 995D0029  stb r10, 0x29(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(41 as u32), ctx.r[10].u8 ) };
	// 821C716C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C7170: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821C7174: 48AE22DC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C7178 size=264
    let mut pc: u32 = 0x821C7178;
    'dispatch: loop {
        match pc {
            0x821C7178 => {
    //   block [0x821C7178..0x821C7268)
	// 821C7178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C717C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C7180: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821C7184: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C7188: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C718C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821C7190: 817E0170  lwz r11, 0x170(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(368 as u32) ) } as u64;
	// 821C7194: 83EB0038  lwz r31, 0x38(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 821C7198: 895F0038  lbz r10, 0x38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821C719C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C71A0: 419A00C8  beq cr6, 0x821c7268
	if ctx.cr[6].eq {
	pc = 0x821C7268; continue 'dispatch;
	}
	// 821C71A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821C71A8: 809E00E8  lwz r4, 0xe8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(232 as u32) ) } as u64;
	// 821C71AC: 4906AAED  bl 0x83231c98
	ctx.lr = 0x821C71B0;
	sub_83231C98(ctx, base);
	// 821C71B0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821C71B4: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821C71B8: E8A30000  ld r5, 0(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821C71BC: 38EB9060  addi r7, r11, -0x6fa0
	ctx.r[7].s64 = ctx.r[11].s64 + -28576;
	// 821C71C0: E8630008  ld r3, 8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	// 821C71C4: 38C99160  addi r6, r9, -0x6ea0
	ctx.r[6].s64 = ctx.r[9].s64 + -28320;
	// 821C71C8: 817E0168  lwz r11, 0x168(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(360 as u32) ) } as u64;
	// 821C71CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821C71D0: E95F0040  ld r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	// 821C71D4: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 821C71D8: E91F0048  ld r8, 0x48(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	// 821C71DC: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	pc = 0x821C7268; continue 'dispatch;
            }
            0x821C7268 => {
    //   block [0x821C7268..0x821C7280)
	// 821C7268: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821C726C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C7270: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C7274: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821C7278: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C727C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C7280 size=392
    let mut pc: u32 = 0x821C7280;
    'dispatch: loop {
        match pc {
            0x821C7280 => {
    //   block [0x821C7280..0x821C72B0)
	// 821C7280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C7284: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C7288: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C728C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C7290: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C7294: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821C7298: 419A0018  beq cr6, 0x821c72b0
	if ctx.cr[6].eq {
	pc = 0x821C72B0; continue 'dispatch;
	}
	// 821C729C: 89650090  lbz r11, 0x90(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(144 as u32) ) } as u64;
	// 821C72A0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821C72A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C72A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C72AC: 409A0008  bne cr6, 0x821c72b4
	if !ctx.cr[6].eq {
	pc = 0x821C72B4; continue 'dispatch;
	}
	pc = 0x821C72B0; continue 'dispatch;
            }
            0x821C72B0 => {
    //   block [0x821C72B0..0x821C72B4)
	// 821C72B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821C72B4; continue 'dispatch;
            }
            0x821C72B4 => {
    //   block [0x821C72B4..0x821C72FC)
	// 821C72B4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C72B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C72BC: 419A0134  beq cr6, 0x821c73f0
	if ctx.cr[6].eq {
	pc = 0x821C73F0; continue 'dispatch;
	}
	// 821C72C0: 81450028  lwz r10, 0x28(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(40 as u32) ) } as u64;
	// 821C72C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C72C8: 5549F7FE  rlwinm r9, r10, 0x1e, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 821C72CC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C72D0: 419A00EC  beq cr6, 0x821c73bc
	if ctx.cr[6].eq {
	pc = 0x821C73BC; continue 'dispatch;
	}
	// 821C72D4: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C72D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C72DC: 419A0020  beq cr6, 0x821c72fc
	if ctx.cr[6].eq {
	pc = 0x821C72FC; continue 'dispatch;
	}
	// 821C72E0: 894B0022  lbz r10, 0x22(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(34 as u32) ) } as u64;
	// 821C72E4: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C72E8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821C72EC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821C72F0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C72F4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C72F8: 480000C8  b 0x821c73c0
	pc = 0x821C73C0; continue 'dispatch;
            }
            0x821C72FC => {
    //   block [0x821C72FC..0x821C731C)
	// 821C72FC: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C7300: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C7304: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 821C7308: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821C730C: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821C7310: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C7314: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C7318: 40810054  ble 0x821c736c
	if !ctx.cr[0].gt {
	pc = 0x821C736C; continue 'dispatch;
	}
	pc = 0x821C731C; continue 'dispatch;
            }
            0x821C731C => {
    //   block [0x821C731C..0x821C733C)
	// 821C731C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821C7320: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C7324: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C7328: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C732C: 2F070022  cmpwi cr6, r7, 0x22
	ctx.cr[6].compare_i32(ctx.r[7].s32, 34, &mut ctx.xer);
	// 821C7330: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821C7334: 41980008  blt cr6, 0x821c733c
	if ctx.cr[6].lt {
	pc = 0x821C733C; continue 'dispatch;
	}
	// 821C7338: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x821C733C; continue 'dispatch;
            }
            0x821C733C => {
    //   block [0x821C733C..0x821C7358)
	// 821C733C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821C7340: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C7344: 419A0014  beq cr6, 0x821c7358
	if ctx.cr[6].eq {
	pc = 0x821C7358; continue 'dispatch;
	}
	// 821C7348: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821C734C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C7350: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C7354: 4800000C  b 0x821c7360
	pc = 0x821C7360; continue 'dispatch;
            }
            0x821C7358 => {
    //   block [0x821C7358..0x821C7360)
	// 821C7358: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821C735C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821C7360; continue 'dispatch;
            }
            0x821C7360 => {
    //   block [0x821C7360..0x821C736C)
	// 821C7360: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C7364: 4199FFB8  bgt cr6, 0x821c731c
	if ctx.cr[6].gt {
	pc = 0x821C731C; continue 'dispatch;
	}
	// 821C7368: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821C736C; continue 'dispatch;
            }
            0x821C736C => {
    //   block [0x821C736C..0x821C7388)
	// 821C736C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C7370: 419A003C  beq cr6, 0x821c73ac
	if ctx.cr[6].eq {
	pc = 0x821C73AC; continue 'dispatch;
	}
	// 821C7374: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C7378: 2F0B0022  cmpwi cr6, r11, 0x22
	ctx.cr[6].compare_i32(ctx.r[11].s32, 34, &mut ctx.xer);
	// 821C737C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C7380: 41990008  bgt cr6, 0x821c7388
	if ctx.cr[6].gt {
	pc = 0x821C7388; continue 'dispatch;
	}
	// 821C7384: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821C7388; continue 'dispatch;
            }
            0x821C7388 => {
    //   block [0x821C7388..0x821C73AC)
	// 821C7388: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C738C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C7390: 409A001C  bne cr6, 0x821c73ac
	if !ctx.cr[6].eq {
	pc = 0x821C73AC; continue 'dispatch;
	}
	// 821C7394: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C7398: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C739C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821C73A0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C73A4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C73A8: 48000018  b 0x821c73c0
	pc = 0x821C73C0; continue 'dispatch;
            }
            0x821C73AC => {
    //   block [0x821C73AC..0x821C73BC)
	// 821C73AC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821C73B0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C73B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C73B8: 48000008  b 0x821c73c0
	pc = 0x821C73C0; continue 'dispatch;
            }
            0x821C73BC => {
    //   block [0x821C73BC..0x821C73C0)
	// 821C73BC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821C73C0; continue 'dispatch;
            }
            0x821C73C0 => {
    //   block [0x821C73C0..0x821C73F0)
	// 821C73C0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821C73C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C73C8: 419A0028  beq cr6, 0x821c73f0
	if ctx.cr[6].eq {
	pc = 0x821C73F0; continue 'dispatch;
	}
	// 821C73CC: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C73D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C73D4: 81240008  lwz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C73D8: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821C73DC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821C73E0: 4E800421  bctrl
	ctx.lr = 0x821C73E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C73E4: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
            }
            0x821C73F0 => {
    //   block [0x821C73F0..0x821C7408)
	// 821C73F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C73F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821C73F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C73FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C7400: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C7404: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C7408 size=132
    let mut pc: u32 = 0x821C7408;
    'dispatch: loop {
        match pc {
            0x821C7408 => {
    //   block [0x821C7408..0x821C743C)
	// 821C7408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C740C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C7410: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821C7414: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C7418: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C741C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C7420: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 821C7424: 3BCAFFDF  addi r30, r10, -0x21
	ctx.r[30].s64 = ctx.r[10].s64 + -33;
	// 821C7428: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C742C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C7430: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C7434: 419A0008  beq cr6, 0x821c743c
	if ctx.cr[6].eq {
	pc = 0x821C743C; continue 'dispatch;
	}
	// 821C7438: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821C743C; continue 'dispatch;
            }
            0x821C743C => {
    //   block [0x821C743C..0x821C7464)
	// 821C743C: 7C840774  extsb r4, r4
	ctx.r[4].s64 = ctx.r[4].s8 as i64;
	// 821C7440: 48AE2DD1  bl 0x82caa210
	ctx.lr = 0x821C7444;
	sub_82CAA210(ctx, base);
	// 821C7444: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821C7448: 419A0028  beq cr6, 0x821c7470
	if ctx.cr[6].eq {
	pc = 0x821C7470; continue 'dispatch;
	}
	// 821C744C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C7450: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C7454: 409A0010  bne cr6, 0x821c7464
	if !ctx.cr[6].eq {
	pc = 0x821C7464; continue 'dispatch;
	}
	// 821C7458: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821C745C: 7C6B1850  subf r3, r11, r3
	ctx.r[3].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 821C7460: 48000014  b 0x821c7474
	pc = 0x821C7474; continue 'dispatch;
            }
            0x821C7464 => {
    //   block [0x821C7464..0x821C7470)
	// 821C7464: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C7468: 7C6B1850  subf r3, r11, r3
	ctx.r[3].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 821C746C: 48000008  b 0x821c7474
	pc = 0x821C7474; continue 'dispatch;
            }
            0x821C7470 => {
    //   block [0x821C7470..0x821C7474)
	// 821C7470: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x821C7474; continue 'dispatch;
            }
            0x821C7474 => {
    //   block [0x821C7474..0x821C748C)
	// 821C7474: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821C7478: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C747C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C7480: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821C7484: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C7488: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C7490 size=248
    let mut pc: u32 = 0x821C7490;
    'dispatch: loop {
        match pc {
            0x821C7490 => {
    //   block [0x821C7490..0x821C74DC)
	// 821C7490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C7494: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C7498: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821C749C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C74A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C74A4: 89630020  lbz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 821C74A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C74AC: 419A00C0  beq cr6, 0x821c756c
	if ctx.cr[6].eq {
	pc = 0x821C756C; continue 'dispatch;
	}
	// 821C74B0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C74B4: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821C74B8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C74BC: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821C74C0: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C74C4: 81680068  lwz r11, 0x68(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(104 as u32) ) } as u64;
	// 821C74C8: 88EB004B  lbz r7, 0x4b(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(75 as u32) ) } as u64;
	// 821C74CC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C74D0: 419A000C  beq cr6, 0x821c74dc
	if ctx.cr[6].eq {
	pc = 0x821C74DC; continue 'dispatch;
	}
	// 821C74D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C74D8: 48000008  b 0x821c74e0
	pc = 0x821C74E0; continue 'dispatch;
            }
            0x821C74DC => {
    //   block [0x821C74DC..0x821C74E0)
	// 821C74DC: 896B0049  lbz r11, 0x49(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(73 as u32) ) } as u64;
	pc = 0x821C74E0; continue 'dispatch;
            }
            0x821C74E0 => {
    //   block [0x821C74E0..0x821C74F8)
	// 821C74E0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C74E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C74E8: 419A0084  beq cr6, 0x821c756c
	if ctx.cr[6].eq {
	pc = 0x821C756C; continue 'dispatch;
	}
	// 821C74EC: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C74F0: 3BC3000C  addi r30, r3, 0xc
	ctx.r[30].s64 = ctx.r[3].s64 + 12;
	// 821C74F4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821C74F8; continue 'dispatch;
            }
            0x821C74F8 => {
    //   block [0x821C74F8..0x821C7508)
	// 821C74F8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C74FC: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821C7500: 419A0008  beq cr6, 0x821c7508
	if ctx.cr[6].eq {
	pc = 0x821C7508; continue 'dispatch;
	}
	// 821C7504: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C7508; continue 'dispatch;
            }
            0x821C7508 => {
    //   block [0x821C7508..0x821C7520)
	// 821C7508: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C750C: 419A0060  beq cr6, 0x821c756c
	if ctx.cr[6].eq {
	pc = 0x821C756C; continue 'dispatch;
	}
	// 821C7510: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C7514: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C7518: 409A0008  bne cr6, 0x821c7520
	if !ctx.cr[6].eq {
	pc = 0x821C7520; continue 'dispatch;
	}
	// 821C751C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C7520; continue 'dispatch;
            }
            0x821C7520 => {
    //   block [0x821C7520..0x821C754C)
	// 821C7520: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C7524: 8963000D  lbz r11, 0xd(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(13 as u32) ) } as u64;
	// 821C7528: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C752C: 409A0020  bne cr6, 0x821c754c
	if !ctx.cr[6].eq {
	pc = 0x821C754C; continue 'dispatch;
	}
	// 821C7530: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C7534: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C7538: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C753C: 4E800421  bctrl
	ctx.lr = 0x821C7540;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C7540: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C7544: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C7548: 409A001C  bne cr6, 0x821c7564
	if !ctx.cr[6].eq {
	pc = 0x821C7564; continue 'dispatch;
	}
            }
            0x821C754C => {
    //   block [0x821C754C..0x821C755C)
	// 821C754C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C7550: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C7554: 409A0008  bne cr6, 0x821c755c
	if !ctx.cr[6].eq {
	pc = 0x821C755C; continue 'dispatch;
	}
	// 821C7558: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C755C; continue 'dispatch;
            }
            0x821C755C => {
    //   block [0x821C755C..0x821C7564)
	// 821C755C: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C7560: 4BFFFF98  b 0x821c74f8
	pc = 0x821C74F8; continue 'dispatch;
            }
            0x821C7564 => {
    //   block [0x821C7564..0x821C756C)
	// 821C7564: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821C7568: 48000008  b 0x821c7570
	pc = 0x821C7570; continue 'dispatch;
            }
            0x821C756C => {
    //   block [0x821C756C..0x821C7570)
	// 821C756C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x821C7570; continue 'dispatch;
            }
            0x821C7570 => {
    //   block [0x821C7570..0x821C7588)
	// 821C7570: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821C7574: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C7578: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C757C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821C7580: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C7584: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C7588 size=504
    let mut pc: u32 = 0x821C7588;
    'dispatch: loop {
        match pc {
            0x821C7588 => {
    //   block [0x821C7588..0x821C75E0)
	// 821C7588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C758C: 48AE1E81  bl 0x82ca940c
	ctx.lr = 0x821C7590;
	sub_82CA93D0(ctx, base);
	// 821C7590: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C7594: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821C7598: 4BFFFEF9  bl 0x821c7490
	ctx.lr = 0x821C759C;
	sub_821C7490(ctx, base);
	// 821C759C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C75A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C75A4: 419A01D0  beq cr6, 0x821c7774
	if ctx.cr[6].eq {
	pc = 0x821C7774; continue 'dispatch;
	}
	// 821C75A8: 897E0020  lbz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 821C75AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C75B0: 419A01C4  beq cr6, 0x821c7774
	if ctx.cr[6].eq {
	pc = 0x821C7774; continue 'dispatch;
	}
	// 821C75B4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C75B8: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821C75BC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C75C0: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821C75C4: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C75C8: 816A0068  lwz r11, 0x68(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(104 as u32) ) } as u64;
	// 821C75CC: 890B004B  lbz r8, 0x4b(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(75 as u32) ) } as u64;
	// 821C75D0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821C75D4: 419A000C  beq cr6, 0x821c75e0
	if ctx.cr[6].eq {
	pc = 0x821C75E0; continue 'dispatch;
	}
	// 821C75D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C75DC: 48000008  b 0x821c75e4
	pc = 0x821C75E4; continue 'dispatch;
            }
            0x821C75E0 => {
    //   block [0x821C75E0..0x821C75E4)
	// 821C75E0: 896B0049  lbz r11, 0x49(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(73 as u32) ) } as u64;
	pc = 0x821C75E4; continue 'dispatch;
            }
            0x821C75E4 => {
    //   block [0x821C75E4..0x821C7618)
	// 821C75E4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C75E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C75EC: 419A0188  beq cr6, 0x821c7774
	if ctx.cr[6].eq {
	pc = 0x821C7774; continue 'dispatch;
	}
	// 821C75F0: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C75F4: 48064BC5  bl 0x8222c1b8
	ctx.lr = 0x821C75F8;
	sub_8222C1B8(ctx, base);
	// 821C75F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C75FC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821C7600: 419A0018  beq cr6, 0x821c7618
	if ctx.cr[6].eq {
	pc = 0x821C7618; continue 'dispatch;
	}
	// 821C7604: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 821C7608: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821C760C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C7610: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C7614: 409A0008  bne cr6, 0x821c761c
	if !ctx.cr[6].eq {
	pc = 0x821C761C; continue 'dispatch;
	}
	pc = 0x821C7618; continue 'dispatch;
            }
            0x821C7618 => {
    //   block [0x821C7618..0x821C761C)
	// 821C7618: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821C761C; continue 'dispatch;
            }
            0x821C761C => {
    //   block [0x821C761C..0x821C7680)
	// 821C761C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C7620: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C7624: 419A0150  beq cr6, 0x821c7774
	if ctx.cr[6].eq {
	pc = 0x821C7774; continue 'dispatch;
	}
	// 821C7628: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C762C: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C7630: 816B6B08  lwz r11, 0x6b08(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821C7634: 806B0020  lwz r3, 0x20(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821C7638: 480FFD21  bl 0x822c7358
	ctx.lr = 0x821C763C;
	sub_822C7358(ctx, base);
	// 821C763C: 7F03E840  cmplw cr6, r3, r29
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[29].u32, &mut ctx.xer);
	// 821C7640: 419A0134  beq cr6, 0x821c7774
	if ctx.cr[6].eq {
	pc = 0x821C7774; continue 'dispatch;
	}
	// 821C7644: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 821C7648: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C764C: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 821C7650: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C7654: 419A00EC  beq cr6, 0x821c7740
	if ctx.cr[6].eq {
	pc = 0x821C7740; continue 'dispatch;
	}
	// 821C7658: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C765C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C7660: 419A0020  beq cr6, 0x821c7680
	if ctx.cr[6].eq {
	pc = 0x821C7680; continue 'dispatch;
	}
	// 821C7664: 894B0085  lbz r10, 0x85(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(133 as u32) ) } as u64;
	// 821C7668: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C766C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821C7670: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821C7674: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C7678: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C767C: 480000C8  b 0x821c7744
	pc = 0x821C7744; continue 'dispatch;
            }
            0x821C7680 => {
    //   block [0x821C7680..0x821C76A0)
	// 821C7680: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C7684: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C7688: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821C768C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821C7690: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821C7694: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C7698: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C769C: 40810054  ble 0x821c76f0
	if !ctx.cr[0].gt {
	pc = 0x821C76F0; continue 'dispatch;
	}
	pc = 0x821C76A0; continue 'dispatch;
            }
            0x821C76A0 => {
    //   block [0x821C76A0..0x821C76C0)
	// 821C76A0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821C76A4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C76A8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C76AC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C76B0: 2F070085  cmpwi cr6, r7, 0x85
	ctx.cr[6].compare_i32(ctx.r[7].s32, 133, &mut ctx.xer);
	// 821C76B4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821C76B8: 41980008  blt cr6, 0x821c76c0
	if ctx.cr[6].lt {
	pc = 0x821C76C0; continue 'dispatch;
	}
	// 821C76BC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x821C76C0; continue 'dispatch;
            }
            0x821C76C0 => {
    //   block [0x821C76C0..0x821C76DC)
	// 821C76C0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821C76C4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C76C8: 419A0014  beq cr6, 0x821c76dc
	if ctx.cr[6].eq {
	pc = 0x821C76DC; continue 'dispatch;
	}
	// 821C76CC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821C76D0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C76D4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C76D8: 4800000C  b 0x821c76e4
	pc = 0x821C76E4; continue 'dispatch;
            }
            0x821C76DC => {
    //   block [0x821C76DC..0x821C76E4)
	// 821C76DC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821C76E0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821C76E4; continue 'dispatch;
            }
            0x821C76E4 => {
    //   block [0x821C76E4..0x821C76F0)
	// 821C76E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C76E8: 4199FFB8  bgt cr6, 0x821c76a0
	if ctx.cr[6].gt {
	pc = 0x821C76A0; continue 'dispatch;
	}
	// 821C76EC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821C76F0; continue 'dispatch;
            }
            0x821C76F0 => {
    //   block [0x821C76F0..0x821C770C)
	// 821C76F0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C76F4: 419A003C  beq cr6, 0x821c7730
	if ctx.cr[6].eq {
	pc = 0x821C7730; continue 'dispatch;
	}
	// 821C76F8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C76FC: 2F0B0085  cmpwi cr6, r11, 0x85
	ctx.cr[6].compare_i32(ctx.r[11].s32, 133, &mut ctx.xer);
	// 821C7700: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C7704: 41990008  bgt cr6, 0x821c770c
	if ctx.cr[6].gt {
	pc = 0x821C770C; continue 'dispatch;
	}
	// 821C7708: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821C770C; continue 'dispatch;
            }
            0x821C770C => {
    //   block [0x821C770C..0x821C7730)
	// 821C770C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C7710: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C7714: 409A001C  bne cr6, 0x821c7730
	if !ctx.cr[6].eq {
	pc = 0x821C7730; continue 'dispatch;
	}
	// 821C7718: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C771C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C7720: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821C7724: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C7728: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C772C: 48000018  b 0x821c7744
	pc = 0x821C7744; continue 'dispatch;
            }
            0x821C7730 => {
    //   block [0x821C7730..0x821C7740)
	// 821C7730: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821C7734: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C7738: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C773C: 48000008  b 0x821c7744
	pc = 0x821C7744; continue 'dispatch;
            }
            0x821C7740 => {
    //   block [0x821C7740..0x821C7744)
	// 821C7740: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821C7744; continue 'dispatch;
            }
            0x821C7744 => {
    //   block [0x821C7744..0x821C7774)
	// 821C7744: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821C7748: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C774C: 419A0028  beq cr6, 0x821c7774
	if ctx.cr[6].eq {
	pc = 0x821C7774; continue 'dispatch;
	}
	// 821C7750: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821C7754: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C7758: 4803C841  bl 0x82203f98
	ctx.lr = 0x821C775C;
	sub_82203F98(ctx, base);
	// 821C775C: 3963FFFC  addi r11, r3, -4
	ctx.r[11].s64 = ctx.r[3].s64 + -4;
	// 821C7760: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821C7764: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 821C7768: 69230001  xori r3, r9, 1
	ctx.r[3].u64 = ctx.r[9].u64 ^ 1;
	// 821C776C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821C7770: 48AE1CEC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821C7774 => {
    //   block [0x821C7774..0x821C7780)
	// 821C7774: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821C7778: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821C777C: 48AE1CE0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C7780 size=644
    let mut pc: u32 = 0x821C7780;
    'dispatch: loop {
        match pc {
            0x821C7780 => {
    //   block [0x821C7780..0x821C7888)
	// 821C7780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C7784: 48AE1C85  bl 0x82ca9408
	ctx.lr = 0x821C7788;
	sub_82CA93D0(ctx, base);
	// 821C7788: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C778C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C7790: 4BFFFDF9  bl 0x821c7588
	ctx.lr = 0x821C7794;
	sub_821C7588(ctx, base);
	// 821C7794: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C7798: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C779C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C77A0: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821C77A4: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C77A8: 83C900A8  lwz r30, 0xa8(r9)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(168 as u32) ) } as u64;
	// 821C77AC: 419A00DC  beq cr6, 0x821c7888
	if ctx.cr[6].eq {
	pc = 0x821C7888; continue 'dispatch;
	}
	// 821C77B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C77B4: 48415C15  bl 0x825dd3c8
	ctx.lr = 0x821C77B8;
	sub_825DD3C8(ctx, base);
	// 821C77B8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C77BC: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C77C0: 7D690034  cntlzw r9, r11
	ctx.r[9].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821C77C4: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 821C77C8: 690B0001  xori r11, r8, 1
	ctx.r[11].u64 = ctx.r[8].u64 ^ 1;
	// 821C77CC: 396B0032  addi r11, r11, 0x32
	ctx.r[11].s64 = ctx.r[11].s64 + 50;
	// 821C77D0: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821C77D4: 419A00C8  beq cr6, 0x821c789c
	if ctx.cr[6].eq {
	pc = 0x821C789C; continue 'dispatch;
	}
	// 821C77D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C77DC: 48415BED  bl 0x825dd3c8
	ctx.lr = 0x821C77E0;
	sub_825DD3C8(ctx, base);
	// 821C77E0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C77E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821C77E8: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821C77EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C77F0: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 821C77F4: 692B0001  xori r11, r9, 1
	ctx.r[11].u64 = ctx.r[9].u64 ^ 1;
	// 821C77F8: 396B0032  addi r11, r11, 0x32
	ctx.r[11].s64 = ctx.r[11].s64 + 50;
	// 821C77FC: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 821C7800: 48417671  bl 0x825dee70
	ctx.lr = 0x821C7804;
	sub_825DEE70(ctx, base);
	// 821C7804: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 821C7808: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 821C780C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821C7810: 38870AF8  addi r4, r7, 0xaf8
	ctx.r[4].s64 = ctx.r[7].s64 + 2808;
	// 821C7814: 81686B08  lwz r11, 0x6b08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821C7818: 80CB0020  lwz r6, 0x20(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821C781C: 83BF0004  lwz r29, 4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C7820: 8386001C  lwz r28, 0x1c(r6)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C7824: 4810EBE5  bl 0x822d6408
	ctx.lr = 0x821C7828;
	sub_822D6408(ctx, base);
	// 821C7828: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821C782C: 80FF001C  lwz r7, 0x1c(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C7830: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821C7834: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 821C7838: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821C783C: 48215E75  bl 0x823dd6b0
	ctx.lr = 0x821C7840;
	sub_823DD6B0(ctx, base);
	// 821C7840: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821C7844: 4BFFEFB5  bl 0x821c67f8
	ctx.lr = 0x821C7848;
	sub_821C67F8(ctx, base);
	// 821C7848: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 821C784C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821C7850: 38840CA0  addi r4, r4, 0xca0
	ctx.r[4].s64 = ctx.r[4].s64 + 3232;
	// 821C7854: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821C7858: 48065679  bl 0x8222ced0
	ctx.lr = 0x821C785C;
	sub_8222CED0(ctx, base);
	// 821C785C: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 821C7860: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821C7864: 80FF001C  lwz r7, 0x1c(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C7868: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821C786C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821C7870: 48215CA9  bl 0x823dd518
	ctx.lr = 0x821C7874;
	sub_823DD518(ctx, base);
	// 821C7874: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821C7878: 4804D561  bl 0x82214dd8
	ctx.lr = 0x821C787C;
	sub_82214DD8(ctx, base);
	// 821C787C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C7880: 4804D559  bl 0x82214dd8
	ctx.lr = 0x821C7884;
	sub_82214DD8(ctx, base);
	// 821C7884: 48000018  b 0x821c789c
	pc = 0x821C789C; continue 'dispatch;
            }
            0x821C7888 => {
    //   block [0x821C7888..0x821C789C)
	// 821C7888: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C788C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C7890: 419A000C  beq cr6, 0x821c789c
	if ctx.cr[6].eq {
	pc = 0x821C789C; continue 'dispatch;
	}
	// 821C7894: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C7898: 48415601  bl 0x825dce98
	ctx.lr = 0x821C789C;
	sub_825DCE98(ctx, base);
	pc = 0x821C789C; continue 'dispatch;
            }
            0x821C789C => {
    //   block [0x821C789C..0x821C790C)
	// 821C789C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C78A0: 4BFFFBF1  bl 0x821c7490
	ctx.lr = 0x821C78A4;
	sub_821C7490(ctx, base);
	// 821C78A4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C78A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C78AC: 419A0150  beq cr6, 0x821c79fc
	if ctx.cr[6].eq {
	pc = 0x821C79FC; continue 'dispatch;
	}
	// 821C78B0: 388000E2  li r4, 0xe2
	ctx.r[4].s64 = 226;
	// 821C78B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C78B8: 48288FB9  bl 0x82450870
	ctx.lr = 0x821C78BC;
	sub_82450870(ctx, base);
	// 821C78BC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C78C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C78C4: 409A0138  bne cr6, 0x821c79fc
	if !ctx.cr[6].eq {
	pc = 0x821C79FC; continue 'dispatch;
	}
	// 821C78C8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C78CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821C78D0: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821C78D4: 55494FFE  rlwinm r9, r10, 9, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x007FFFFFu64;
	// 821C78D8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C78DC: 419A00F4  beq cr6, 0x821c79d0
	if ctx.cr[6].eq {
	pc = 0x821C79D0; continue 'dispatch;
	}
	// 821C78E0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C78E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C78E8: 419A0024  beq cr6, 0x821c790c
	if ctx.cr[6].eq {
	pc = 0x821C790C; continue 'dispatch;
	}
	// 821C78EC: 894A0017  lbz r10, 0x17(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(23 as u32) ) } as u64;
	// 821C78F0: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C78F4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821C78F8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821C78FC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C7900: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821C7904: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C7908: 480000CC  b 0x821c79d4
	pc = 0x821C79D4; continue 'dispatch;
            }
            0x821C790C => {
    //   block [0x821C790C..0x821C7928)
	// 821C790C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821C7910: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821C7914: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 821C7918: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821C791C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821C7920: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C7924: 40810054  ble 0x821c7978
	if !ctx.cr[0].gt {
	pc = 0x821C7978; continue 'dispatch;
	}
	pc = 0x821C7928; continue 'dispatch;
            }
            0x821C7928 => {
    //   block [0x821C7928..0x821C7948)
	// 821C7928: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821C792C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C7930: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C7934: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C7938: 2F070017  cmpwi cr6, r7, 0x17
	ctx.cr[6].compare_i32(ctx.r[7].s32, 23, &mut ctx.xer);
	// 821C793C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821C7940: 41980008  blt cr6, 0x821c7948
	if ctx.cr[6].lt {
	pc = 0x821C7948; continue 'dispatch;
	}
	// 821C7944: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x821C7948; continue 'dispatch;
            }
            0x821C7948 => {
    //   block [0x821C7948..0x821C7964)
	// 821C7948: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821C794C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C7950: 419A0014  beq cr6, 0x821c7964
	if ctx.cr[6].eq {
	pc = 0x821C7964; continue 'dispatch;
	}
	// 821C7954: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821C7958: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C795C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821C7960: 4800000C  b 0x821c796c
	pc = 0x821C796C; continue 'dispatch;
            }
            0x821C7964 => {
    //   block [0x821C7964..0x821C796C)
	// 821C7964: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821C7968: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821C796C; continue 'dispatch;
            }
            0x821C796C => {
    //   block [0x821C796C..0x821C7978)
	// 821C796C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C7970: 4199FFB8  bgt cr6, 0x821c7928
	if ctx.cr[6].gt {
	pc = 0x821C7928; continue 'dispatch;
	}
	// 821C7974: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x821C7978; continue 'dispatch;
            }
            0x821C7978 => {
    //   block [0x821C7978..0x821C7994)
	// 821C7978: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C797C: 419A0040  beq cr6, 0x821c79bc
	if ctx.cr[6].eq {
	pc = 0x821C79BC; continue 'dispatch;
	}
	// 821C7980: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C7984: 2F0B0017  cmpwi cr6, r11, 0x17
	ctx.cr[6].compare_i32(ctx.r[11].s32, 23, &mut ctx.xer);
	// 821C7988: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C798C: 41990008  bgt cr6, 0x821c7994
	if ctx.cr[6].gt {
	pc = 0x821C7994; continue 'dispatch;
	}
	// 821C7990: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x821C7994; continue 'dispatch;
            }
            0x821C7994 => {
    //   block [0x821C7994..0x821C79BC)
	// 821C7994: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C7998: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C799C: 409A0020  bne cr6, 0x821c79bc
	if !ctx.cr[6].eq {
	pc = 0x821C79BC; continue 'dispatch;
	}
	// 821C79A0: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821C79A4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821C79A8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821C79AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C79B0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821C79B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C79B8: 4800001C  b 0x821c79d4
	pc = 0x821C79D4; continue 'dispatch;
            }
            0x821C79BC => {
    //   block [0x821C79BC..0x821C79D0)
	// 821C79BC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821C79C0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C79C4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821C79C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C79CC: 48000008  b 0x821c79d4
	pc = 0x821C79D4; continue 'dispatch;
            }
            0x821C79D0 => {
    //   block [0x821C79D0..0x821C79D4)
	// 821C79D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x821C79D4; continue 'dispatch;
            }
            0x821C79D4 => {
    //   block [0x821C79D4..0x821C79FC)
	// 821C79D4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C79D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C79DC: 419A0020  beq cr6, 0x821c79fc
	if ctx.cr[6].eq {
	pc = 0x821C79FC; continue 'dispatch;
	}
	// 821C79E0: 480CD6D1  bl 0x822950b0
	ctx.lr = 0x821C79E4;
	sub_822950B0(ctx, base);
	// 821C79E4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C79E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C79EC: 419A0010  beq cr6, 0x821c79fc
	if ctx.cr[6].eq {
	pc = 0x821C79FC; continue 'dispatch;
	}
	// 821C79F0: 388000E2  li r4, 0xe2
	ctx.r[4].s64 = 226;
	// 821C79F4: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C79F8: 4BFED869  bl 0x821b5260
	ctx.lr = 0x821C79FC;
	sub_821B5260(ctx, base);
	pc = 0x821C79FC; continue 'dispatch;
            }
            0x821C79FC => {
    //   block [0x821C79FC..0x821C7A04)
	// 821C79FC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821C7A00: 48AE1A58  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7A08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C7A08 size=244
    let mut pc: u32 = 0x821C7A08;
    'dispatch: loop {
        match pc {
            0x821C7A08 => {
    //   block [0x821C7A08..0x821C7A60)
	// 821C7A08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C7A0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C7A10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821C7A14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C7A18: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C7A1C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821C7A20: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821C7A24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821C7A28: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C7A2C: C0230020  lfs f1, 0x20(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821C7A30: 480109E9  bl 0x821d8418
	ctx.lr = 0x821C7A34;
	sub_821D8418(ctx, base);
	// 821C7A34: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 821C7A38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821C7A3C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821C7A40: 48053151  bl 0x8221ab90
	ctx.lr = 0x821C7A44;
	sub_8221AB90(ctx, base);
	// 821C7A44: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 821C7A48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C7A4C: 409A002C  bne cr6, 0x821c7a78
	if !ctx.cr[6].eq {
	pc = 0x821C7A78; continue 'dispatch;
	}
	// 821C7A50: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 821C7A54: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 821C7A58: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821C7A5C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x821C7A60; continue 'dispatch;
            }
            0x821C7A60 => {
    //   block [0x821C7A60..0x821C7A78)
	// 821C7A60: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821C7A64: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821C7A68: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821C7A6C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C7A70: 4200FFF0  bdnz 0x821c7a60
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821C7A60; continue 'dispatch;
	}
	// 821C7A74: 4800006C  b 0x821c7ae0
	pc = 0x821C7AE0; continue 'dispatch;
            }
            0x821C7A78 => {
    //   block [0x821C7A78..0x821C7ACC)
	// 821C7A78: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C7A7C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821C7A80: C0230020  lfs f1, 0x20(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821C7A84: 48010995  bl 0x821d8418
	ctx.lr = 0x821C7A88;
	sub_821D8418(ctx, base);
	// 821C7A88: 38BF0060  addi r5, r31, 0x60
	ctx.r[5].s64 = ctx.r[31].s64 + 96;
	// 821C7A8C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821C7A90: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 821C7A94: 480530FD  bl 0x8221ab90
	ctx.lr = 0x821C7A98;
	sub_8221AB90(ctx, base);
	// 821C7A98: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 821C7A9C: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 821C7AA0: C03F00A8  lfs f1, 0xa8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821C7AA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C7AA8: 486C7961  bl 0x8288f408
	ctx.lr = 0x821C7AAC;
	sub_8288F408(ctx, base);
	// 821C7AAC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821C7AB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C7AB4: C02B9054  lfs f1, -0x6fac(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28588 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821C7AB8: 480ADE41  bl 0x822758f8
	ctx.lr = 0x821C7ABC;
	sub_822758F8(ctx, base);
	// 821C7ABC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821C7AC0: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 821C7AC4: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821C7AC8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x821C7ACC; continue 'dispatch;
            }
            0x821C7ACC => {
    //   block [0x821C7ACC..0x821C7AE0)
	// 821C7ACC: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821C7AD0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821C7AD4: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821C7AD8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C7ADC: 4200FFF0  bdnz 0x821c7acc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821C7ACC; continue 'dispatch;
	}
	pc = 0x821C7AE0; continue 'dispatch;
            }
            0x821C7AE0 => {
    //   block [0x821C7AE0..0x821C7AFC)
	// 821C7AE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C7AE4: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 821C7AE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C7AEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C7AF0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821C7AF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C7AF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821C7B00 size=92
    let mut pc: u32 = 0x821C7B00;
    'dispatch: loop {
        match pc {
            0x821C7B00 => {
    //   block [0x821C7B00..0x821C7B5C)
	// 821C7B00: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821C7B04: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821C7B08: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 821C7B0C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821C7B10: 81696AB8  lwz r11, 0x6ab8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821C7B14: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C7B18: 80CB000C  lwz r6, 0xc(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C7B1C: 80A60058  lwz r5, 0x58(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(88 as u32) ) } as u64;
	// 821C7B20: 80850004  lwz r4, 4(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C7B24: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C7B28: 816B0454  lwz r11, 0x454(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1108 as u32) ) } as u64;
	// 821C7B2C: 90E80004  stw r7, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821C7B30: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 821C7B34: 7D2707B4  extsw r7, r9
	ctx.r[7].s64 = ctx.r[9].s32 as i64;
	// 821C7B38: F8E1FFF0  std r7, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[7].u64 ) };
	// 821C7B3C: C801FFF0  lfd f0, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C7B40: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 821C7B44: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821C7B48: D1880000  stfs f12, 0(r8)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821C7B4C: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C7B50: 38CB0008  addi r6, r11, 8
	ctx.r[6].s64 = ctx.r[11].s64 + 8;
	// 821C7B54: 90CA0008  stw r6, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 821C7B58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C7B60 size=252
    let mut pc: u32 = 0x821C7B60;
    'dispatch: loop {
        match pc {
            0x821C7B60 => {
    //   block [0x821C7B60..0x821C7BA8)
	// 821C7B60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C7B64: 48AE18A9  bl 0x82ca940c
	ctx.lr = 0x821C7B68;
	sub_82CA93D0(ctx, base);
	// 821C7B68: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821C7B6C: 38E30114  addi r7, r3, 0x114
	ctx.r[7].s64 = ctx.r[3].s64 + 276;
	// 821C7B70: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 821C7B74: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821C7B78: C80B9660  lfd f0, -0x69a0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27040 as u32) ) };
	// 821C7B7C: FC010032  fmul f0, f1, f0
	ctx.f[0].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 821C7B80: 8167000C  lwz r11, 0xc(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C7B84: 81470010  lwz r10, 0x10(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C7B88: 80A99650  lwz r5, -0x69b0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 821C7B8C: 7CCA5A14  add r6, r10, r11
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821C7B90: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C7B94: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821C7B98: D9A1FFD0  stfd f13, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[13].u64 ) };
	// 821C7B9C: 83E1FFD4  lwz r31, -0x2c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-44 as u32) ) } as u64;
	// 821C7BA0: 40990008  ble cr6, 0x821c7ba8
	if !ctx.cr[6].gt {
	pc = 0x821C7BA8; continue 'dispatch;
	}
	// 821C7BA4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C7BA8; continue 'dispatch;
            }
            0x821C7BA8 => {
    //   block [0x821C7BA8..0x821C7BB4)
	// 821C7BA8: 83A7000C  lwz r29, 0xc(r7)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C7BAC: 81470010  lwz r10, 0x10(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(16 as u32) ) } as u64;
	// 821C7BB0: 7FCAEA14  add r30, r10, r29
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	pc = 0x821C7BB4; continue 'dispatch;
            }
            0x821C7BB4 => {
    //   block [0x821C7BB4..0x821C7BC0)
	// 821C7BB4: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821C7BB8: 40990008  ble cr6, 0x821c7bc0
	if !ctx.cr[6].gt {
	pc = 0x821C7BC0; continue 'dispatch;
	}
	// 821C7BBC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C7BC0; continue 'dispatch;
            }
            0x821C7BC0 => {
    //   block [0x821C7BC0..0x821C7BCC)
	// 821C7BC0: 7F073840  cmplw cr6, r7, r7
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821C7BC4: 419A0008  beq cr6, 0x821c7bcc
	if ctx.cr[6].eq {
	pc = 0x821C7BCC; continue 'dispatch;
	}
	// 821C7BC8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C7BCC; continue 'dispatch;
            }
            0x821C7BCC => {
    //   block [0x821C7BCC..0x821C7BE4)
	// 821C7BCC: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821C7BD0: 419A0088  beq cr6, 0x821c7c58
	if ctx.cr[6].eq {
	pc = 0x821C7C58; continue 'dispatch;
	}
	// 821C7BD4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821C7BD8: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C7BDC: 41980008  blt cr6, 0x821c7be4
	if ctx.cr[6].lt {
	pc = 0x821C7BE4; continue 'dispatch;
	}
	// 821C7BE0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C7BE4; continue 'dispatch;
            }
            0x821C7BE4 => {
    //   block [0x821C7BE4..0x821C7BF4)
	// 821C7BE4: 81270008  lwz r9, 8(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C7BE8: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C7BEC: 41990008  bgt cr6, 0x821c7bf4
	if ctx.cr[6].gt {
	pc = 0x821C7BF4; continue 'dispatch;
	}
	// 821C7BF0: 7D495850  subf r10, r9, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	pc = 0x821C7BF4; continue 'dispatch;
            }
            0x821C7BF4 => {
    //   block [0x821C7BF4..0x821C7C1C)
	// 821C7BF4: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C7BF8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821C7BFC: 7D4A402E  lwzx r10, r10, r8
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821C7C00: 814A0018  lwz r10, 0x18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 821C7C04: 7F0A2000  cmpw cr6, r10, r4
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[4].s32, &mut ctx.xer);
	// 821C7C08: 409A003C  bne cr6, 0x821c7c44
	if !ctx.cr[6].eq {
	pc = 0x821C7C44; continue 'dispatch;
	}
	// 821C7C0C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821C7C10: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C7C14: 41980008  blt cr6, 0x821c7c1c
	if ctx.cr[6].lt {
	pc = 0x821C7C1C; continue 'dispatch;
	}
	// 821C7C18: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C7C1C; continue 'dispatch;
            }
            0x821C7C1C => {
    //   block [0x821C7C1C..0x821C7C28)
	// 821C7C1C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C7C20: 41990008  bgt cr6, 0x821c7c28
	if ctx.cr[6].gt {
	pc = 0x821C7C28; continue 'dispatch;
	}
	// 821C7C24: 7D495850  subf r10, r9, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	pc = 0x821C7C28; continue 'dispatch;
            }
            0x821C7C28 => {
    //   block [0x821C7C28..0x821C7C44)
	// 821C7C28: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821C7C2C: 7D2A402E  lwzx r9, r10, r8
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821C7C30: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C7C34: 7D0AFA14  add r8, r10, r31
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 821C7C38: 7F082800  cmpw cr6, r8, r5
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[5].s32, &mut ctx.xer);
	// 821C7C3C: 40990008  ble cr6, 0x821c7c44
	if !ctx.cr[6].gt {
	pc = 0x821C7C44; continue 'dispatch;
	}
	// 821C7C40: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	pc = 0x821C7C44; continue 'dispatch;
            }
            0x821C7C44 => {
    //   block [0x821C7C44..0x821C7C50)
	// 821C7C44: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821C7C48: 41980008  blt cr6, 0x821c7c50
	if ctx.cr[6].lt {
	pc = 0x821C7C50; continue 'dispatch;
	}
	// 821C7C4C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C7C50; continue 'dispatch;
            }
            0x821C7C50 => {
    //   block [0x821C7C50..0x821C7C58)
	// 821C7C50: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821C7C54: 4BFFFF60  b 0x821c7bb4
	pc = 0x821C7BB4; continue 'dispatch;
            }
            0x821C7C58 => {
    //   block [0x821C7C58..0x821C7C5C)
	// 821C7C58: 48AE1804  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C7C60 size=128
    let mut pc: u32 = 0x821C7C60;
    'dispatch: loop {
        match pc {
            0x821C7C60 => {
    //   block [0x821C7C60..0x821C7CC4)
	// 821C7C60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C7C64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C7C68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821C7C6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C7C70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C7C74: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C7C78: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821C7C7C: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821C7C80: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C7C84: 806A0080  lwz r3, 0x80(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 821C7C88: 480AD259  bl 0x82274ee0
	ctx.lr = 0x821C7C8C;
	sub_82274EE0(ctx, base);
	// 821C7C8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C7C90: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821C7C94: 419A0030  beq cr6, 0x821c7cc4
	if ctx.cr[6].eq {
	pc = 0x821C7CC4; continue 'dispatch;
	}
	// 821C7C98: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C7C9C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C7CA0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C7CA4: 4E800421  bctrl
	ctx.lr = 0x821C7CA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C7CA8: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C7CAC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C7CB0: 419A0014  beq cr6, 0x821c7cc4
	if ctx.cr[6].eq {
	pc = 0x821C7CC4; continue 'dispatch;
	}
	// 821C7CB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C7CB8: 809E0024  lwz r4, 0x24(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 821C7CBC: 480D487D  bl 0x8229c538
	ctx.lr = 0x821C7CC0;
	sub_8229C538(ctx, base);
	// 821C7CC0: 48000008  b 0x821c7cc8
	pc = 0x821C7CC8; continue 'dispatch;
            }
            0x821C7CC4 => {
    //   block [0x821C7CC4..0x821C7CC8)
	// 821C7CC4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x821C7CC8; continue 'dispatch;
            }
            0x821C7CC8 => {
    //   block [0x821C7CC8..0x821C7CE0)
	// 821C7CC8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821C7CCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C7CD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C7CD4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821C7CD8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C7CDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C7CE0 size=80
    let mut pc: u32 = 0x821C7CE0;
    'dispatch: loop {
        match pc {
            0x821C7CE0 => {
    //   block [0x821C7CE0..0x821C7D0C)
	// 821C7CE0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C7CE4: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821C7CE8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C7CEC: 816A008C  lwz r11, 0x8c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C7CF0: 892B0034  lbz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821C7CF4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C7CF8: 419A0014  beq cr6, 0x821c7d0c
	if ctx.cr[6].eq {
	pc = 0x821C7D0C; continue 'dispatch;
	}
	// 821C7CFC: 896B0035  lbz r11, 0x35(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(53 as u32) ) } as u64;
	// 821C7D00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C7D04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C7D08: 409A0008  bne cr6, 0x821c7d10
	if !ctx.cr[6].eq {
	pc = 0x821C7D10; continue 'dispatch;
	}
	pc = 0x821C7D0C; continue 'dispatch;
            }
            0x821C7D0C => {
    //   block [0x821C7D0C..0x821C7D10)
	// 821C7D0C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821C7D10; continue 'dispatch;
            }
            0x821C7D10 => {
    //   block [0x821C7D10..0x821C7D28)
	// 821C7D10: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C7D14: 806A009C  lwz r3, 0x9c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) } as u64;
	// 821C7D18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C7D1C: 419A000C  beq cr6, 0x821c7d28
	if ctx.cr[6].eq {
	pc = 0x821C7D28; continue 'dispatch;
	}
	// 821C7D20: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821C7D24: 4809C50C  b 0x82264230
	sub_82264230(ctx, base);
	return;
            }
            0x821C7D28 => {
    //   block [0x821C7D28..0x821C7D30)
	// 821C7D28: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821C7D2C: 4809C504  b 0x82264230
	sub_82264230(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C7D30 size=140
    let mut pc: u32 = 0x821C7D30;
    'dispatch: loop {
        match pc {
            0x821C7D30 => {
    //   block [0x821C7D30..0x821C7DA0)
	// 821C7D30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C7D34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C7D38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C7D3C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821C7D40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C7D44: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 821C7D48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C7D4C: 480707D5  bl 0x82238520
	ctx.lr = 0x821C7D50;
	sub_82238520(ctx, base);
	// 821C7D50: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C7D54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C7D58: 419A0048  beq cr6, 0x821c7da0
	if ctx.cr[6].eq {
	pc = 0x821C7DA0; continue 'dispatch;
	}
	// 821C7D5C: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C7D60: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 821C7D64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C7D68: 7D6A07B4  extsw r10, r11
	ctx.r[10].s64 = ctx.r[11].s32 as i64;
	// 821C7D6C: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821C7D70: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821C7D74: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 821C7D78: FFE06818  frsp f31, f13
	ctx.f[31].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821C7D7C: 48319E95  bl 0x824e1c10
	ctx.lr = 0x821C7D80;
	sub_824E1C10(ctx, base);
	// 821C7D80: ED81F82A  fadds f12, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = ((ctx.f[1].f64 + ctx.f[31].f64) as f32) as f64;
	// 821C7D84: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 821C7D88: D9610050  stfd f11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[11].u64 ) };
	// 821C7D8C: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C7D90: 7D28FE70  srawi r8, r9, 0x1f
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 31) as i64;
	// 821C7D94: 7D074838  and r7, r8, r9
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 821C7D98: 7C674850  subf r3, r7, r9
	ctx.r[3].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 821C7D9C: 48000008  b 0x821c7da4
	pc = 0x821C7DA4; continue 'dispatch;
            }
            0x821C7DA0 => {
    //   block [0x821C7DA0..0x821C7DA4)
	// 821C7DA0: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	pc = 0x821C7DA4; continue 'dispatch;
            }
            0x821C7DA4 => {
    //   block [0x821C7DA4..0x821C7DBC)
	// 821C7DA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821C7DA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C7DAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C7DB0: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821C7DB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C7DB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7DC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C7DC0 size=88
    let mut pc: u32 = 0x821C7DC0;
    'dispatch: loop {
        match pc {
            0x821C7DC0 => {
    //   block [0x821C7DC0..0x821C7E04)
	// 821C7DC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C7DC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C7DC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C7DCC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C7DD0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C7DD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C7DD8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 821C7DDC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C7DE0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C7DE4: 4E800421  bctrl
	ctx.lr = 0x821C7DE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C7DE8: 2F030008  cmpwi cr6, r3, 8
	ctx.cr[6].compare_i32(ctx.r[3].s32, 8, &mut ctx.xer);
	// 821C7DEC: 409A0018  bne cr6, 0x821c7e04
	if !ctx.cr[6].eq {
	pc = 0x821C7E04; continue 'dispatch;
	}
	// 821C7DF0: 897F0068  lbz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 821C7DF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C7DF8: 419A000C  beq cr6, 0x821c7e04
	if ctx.cr[6].eq {
	pc = 0x821C7E04; continue 'dispatch;
	}
	// 821C7DFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C7E00: 4877B339  bl 0x82943138
	ctx.lr = 0x821C7E04;
	sub_82943138(ctx, base);
            }
            0x821C7E04 => {
    //   block [0x821C7E04..0x821C7E18)
	// 821C7E04: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C7E08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C7E0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C7E10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C7E14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C7E18 size=112
    let mut pc: u32 = 0x821C7E18;
    'dispatch: loop {
        match pc {
            0x821C7E18 => {
    //   block [0x821C7E18..0x821C7E54)
	// 821C7E18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C7E1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C7E20: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C7E24: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C7E28: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821C7E2C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C7E30: 812A0080  lwz r9, 0x80(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 821C7E34: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C7E38: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C7E3C: 54EA003E  slwi r10, r7, 0
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821C7E40: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C7E44: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821C7E48: 409A000C  bne cr6, 0x821c7e54
	if !ctx.cr[6].eq {
	pc = 0x821C7E54; continue 'dispatch;
	}
	// 821C7E4C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 821C7E50: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C7E54; continue 'dispatch;
            }
            0x821C7E54 => {
    //   block [0x821C7E54..0x821C7E88)
	// 821C7E54: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C7E58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C7E5C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C7E60: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C7E64: 4E800421  bctrl
	ctx.lr = 0x821C7E68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C7E68: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C7E6C: 7D280034  cntlzw r8, r9
	ctx.r[8].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821C7E70: 5507DFFE  rlwinm r7, r8, 0x1b, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 821C7E74: 68E30001  xori r3, r7, 1
	ctx.r[3].u64 = ctx.r[7].u64 ^ 1;
	// 821C7E78: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C7E7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C7E80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C7E84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C7E88 size=316
    let mut pc: u32 = 0x821C7E88;
    'dispatch: loop {
        match pc {
            0x821C7E88 => {
    //   block [0x821C7E88..0x821C7FC4)
	// 821C7E88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C7E8C: 48AE1575  bl 0x82ca9400
	ctx.lr = 0x821C7E90;
	sub_82CA93D0(ctx, base);
	// 821C7E90: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 821C7E94: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C7E98: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 821C7E9C: 39400080  li r10, 0x80
	ctx.r[10].s64 = 128;
	// 821C7EA0: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 821C7EA4: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821C7EA8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821C7EAC: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C7EB0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821C7EB4: C0089A80  lfs f0, -0x6580(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C7EB8: 80EB0014  lwz r7, 0x14(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C7EBC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C7FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C7FC8 size=324
    let mut pc: u32 = 0x821C7FC8;
    'dispatch: loop {
        match pc {
            0x821C7FC8 => {
    //   block [0x821C7FC8..0x821C8080)
	// 821C7FC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C7FCC: 48AE143D  bl 0x82ca9408
	ctx.lr = 0x821C7FD0;
	sub_82CA93D0(ctx, base);
	// 821C7FD0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C7FD4: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 821C7FD8: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 821C7FDC: 3D00820F  lis r8, -0x7df1
	ctx.r[8].s64 = -2112946176;
	// 821C7FE0: 3CE0820F  lis r7, -0x7df1
	ctx.r[7].s64 = -2112946176;
	// 821C7FE4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821C7FE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C7FEC: 38A96B68  addi r5, r9, 0x6b68
	ctx.r[5].s64 = ctx.r[9].s64 + 27496;
	// 821C7FF0: 38CA6B58  addi r6, r10, 0x6b58
	ctx.r[6].s64 = ctx.r[10].s64 + 27480;
	// 821C7FF4: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 821C7FF8: 38886B74  addi r4, r8, 0x6b74
	ctx.r[4].s64 = ctx.r[8].s64 + 27508;
	// 821C7FFC: 90A10098  stw r5, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[5].u32 ) };
	// 821C8000: 38676B78  addi r3, r7, 0x6b78
	ctx.r[3].s64 = ctx.r[7].s64 + 27512;
	// 821C8004: 90C10090  stw r6, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[6].u32 ) };
	// 821C8008: 908100A0  stw r4, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[4].u32 ) };
	// 821C800C: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 821C8010: 906100AC  stw r3, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[3].u32 ) };
	// 821C8014: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821C8018: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 821C801C: 392AA978  addi r9, r10, -0x5688
	ctx.r[9].s64 = ctx.r[10].s64 + -22152;
	// 821C8020: 916100A8  stw r11, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 821C8024: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821C8028: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C802C: 48032BA5  bl 0x821fabd0
	ctx.lr = 0x821C8030;
	sub_821FABD0(ctx, base);
	// 821C8030: 81010078  lwz r8, 0x78(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 821C8034: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821C8038: 80E1007C  lwz r7, 0x7c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 821C803C: 7D060E70  srawi r6, r8, 1
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[8].s32 >> 1) as i64;
	// 821C8040: 3BEBAA38  addi r31, r11, -0x55c8
	ctx.r[31].s64 = ctx.r[11].s64 + -21960;
	// 821C8044: 7CA60194  addze r5, r6
	tmp.s64 = ctx.r[6].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[6].u32);
	ctx.r[5].s64 = tmp.s64;
	// 821C8048: 7CEB0E70  srawi r11, r7, 1
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> 1) as i64;
	// 821C804C: 3FC0834A  lis r30, -0x7cb6
	ctx.r[30].s64 = -2092302336;
	// 821C8050: 90A10058  stw r5, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u32 ) };
	// 821C8054: 7D4B0194  addze r10, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[10].s64 = tmp.s64;
	// 821C8058: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C805C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821C8060: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821C8064: 839EF9C0  lwz r28, -0x640(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 821C8068: 480BF679  bl 0x822876e0
	ctx.lr = 0x821C806C;
	sub_822876E0(ctx, base);
	// 821C806C: 80C30000  lwz r6, 0(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C8070: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 821C8074: 2F060061  cmpwi cr6, r6, 0x61
	ctx.cr[6].compare_i32(ctx.r[6].s32, 97, &mut ctx.xer);
	// 821C8078: 409A0008  bne cr6, 0x821c8080
	if !ctx.cr[6].eq {
	pc = 0x821C8080; continue 'dispatch;
	}
	// 821C807C: 38E0003A  li r7, 0x3a
	ctx.r[7].s64 = 58;
	pc = 0x821C8080; continue 'dispatch;
            }
            0x821C8080 => {
    //   block [0x821C8080..0x821C810C)
	// 821C8080: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821C8084: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821C8088: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821C808C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 821C8090: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821C8094: 48033CFD  bl 0x821fbd90
	ctx.lr = 0x821C8098;
	sub_821FBD90(ctx, base);
	// 821C8098: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821C809C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821C80A0: 48033B49  bl 0x821fbbe8
	ctx.lr = 0x821C80A4;
	sub_821FBBE8(ctx, base);
	// 821C80A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821C80A8: 48033EE9  bl 0x821fbf90
	ctx.lr = 0x821C80AC;
	sub_821FBF90(ctx, base);
	// 821C80AC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C80B0: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 821C80B4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 821C80B8: 38EAA990  addi r7, r10, -0x5670
	ctx.r[7].s64 = ctx.r[10].s64 + -22128;
	// 821C80BC: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 821C80C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821C80C4: 806BF7E8  lwz r3, -0x818(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2072 as u32) ) } as u64;
	// 821C80C8: 480C2BF1  bl 0x8228acb8
	ctx.lr = 0x821C80CC;
	sub_8228ACB8(ctx, base);
	// 821C80CC: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821C80D0: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821C80D4: 807EF9C0  lwz r3, -0x640(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 821C80D8: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 821C80DC: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 821C80E0: 81696E5C  lwz r11, 0x6e5c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28252 as u32) ) } as u64;
	// 821C80E4: 7CEB5214  add r7, r11, r10
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821C80E8: 20C70000  subfic r6, r7, 0
	ctx.xer.ca = ctx.r[7].u32 <= 0 as u32;
	ctx.r[6].s64 = (0 as i64) - ctx.r[7].s64;
	// 821C80EC: 7CA63110  subfe r5, r6, r6
	let x = (!ctx.r[6].u32);
	let y = ctx.r[6].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[5].u32 = res;
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 821C80F0: 54AB07FE  clrlwi r11, r5, 0x1f
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x00000001u64;
	// 821C80F4: 99686E23  stb r11, 0x6e23(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(28195 as u32), ctx.r[11].u8 ) };
	// 821C80F8: 4806EF29  bl 0x82237020
	ctx.lr = 0x821C80FC;
	sub_82237020(ctx, base);
	// 821C80FC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821C8100: 48033E91  bl 0x821fbf90
	ctx.lr = 0x821C8104;
	sub_821FBF90(ctx, base);
	// 821C8104: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821C8108: 48AE1350  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C8110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C8110 size=200
    let mut pc: u32 = 0x821C8110;
    'dispatch: loop {
        match pc {
            0x821C8110 => {
    //   block [0x821C8110..0x821C8160)
	// 821C8110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C8114: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C8118: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C811C: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 821C8120: 546B083C  slwi r11, r3, 1
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C8124: 392ADED4  addi r9, r10, -0x212c
	ctx.r[9].s64 = ctx.r[10].s64 + -8492;
	// 821C8128: 7D035A14  add r8, r3, r11
	ctx.r[8].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 821C812C: 38E00004  li r7, 4
	ctx.r[7].s64 = 4;
	// 821C8130: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821C8134: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 821C8138: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 821C813C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8140: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821C8144: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8148: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C814C: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 821C8150: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821C8154: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821C8158: 41990008  bgt cr6, 0x821c8160
	if ctx.cr[6].gt {
	pc = 0x821C8160; continue 'dispatch;
	}
	// 821C815C: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	pc = 0x821C8160; continue 'dispatch;
            }
            0x821C8160 => {
    //   block [0x821C8160..0x821C81C8)
	// 821C8160: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C8164: 2F060001  cmpwi cr6, r6, 1
	ctx.cr[6].compare_i32(ctx.r[6].s32, 1, &mut ctx.xer);
	// 821C8168: 41980060  blt cr6, 0x821c81c8
	if ctx.cr[6].lt {
	pc = 0x821C81C8; continue 'dispatch;
	}
	// 821C816C: 7D6A1670  srawi r10, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 821C8170: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821C8174: 7CEA0194  addze r7, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[7].s64 = tmp.s64;
	// 821C8178: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 821C817C: 792AFFE6  rldicr r10, r9, 0x3f, 0x3f
	ctx.r[10].u64 = (ctx.r[9].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821C8180: 7CE407B4  extsw r4, r7
	ctx.r[4].s64 = ctx.r[7].s32 as i64;
	// 821C8184: 7D432436  srd r3, r10, r4
	if (ctx.r[4].u8 & 0x40) != 0 {
		ctx.r[3].u64 = 0;
	} else {
		ctx.r[3].u64 = (ctx.r[10].u64) >> ((ctx.r[4].u8 & 0x3F) as u32);
	}
	// 821C8188: E9281760  ld r9, 0x1760(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(5984 as u32) ) };
	// 821C818C: 7C694838  and r9, r3, r9
	ctx.r[9].u64 = ctx.r[3].u64 & ctx.r[9].u64;
	// 821C8190: 2B290000  cmpldi cr6, r9, 0
	ctx.cr[6].compare_u64(ctx.r[9].u64, 0, &mut ctx.xer);
	// 821C8194: 419A0034  beq cr6, 0x821c81c8
	if ctx.cr[6].eq {
	pc = 0x821C81C8; continue 'dispatch;
	}
	// 821C8198: 7D265A14  add r9, r6, r11
	ctx.r[9].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 821C819C: 5568F0BE  srwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C81A0: 38E9FFFF  addi r7, r9, -1
	ctx.r[7].s64 = ctx.r[9].s64 + -1;
	// 821C81A4: 3C808336  lis r4, -0x7cca
	ctx.r[4].s64 = -2093613056;
	// 821C81A8: 54E3F0BE  srwi r3, r7, 2
	ctx.r[3].u32 = ctx.r[7].u32.wrapping_shr(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821C81AC: 7D281850  subf r9, r8, r3
	ctx.r[9].s64 = ctx.r[3].s64 - ctx.r[8].s64;
	// 821C81B0: 79270020  clrldi r7, r9, 0x20
	ctx.r[7].u64 = ctx.r[9].u64 & 0x00000000FFFFFFFFu64;
	// 821C81B4: 80640364  lwz r3, 0x364(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(868 as u32) ) } as u64;
	// 821C81B8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 821C81BC: 7D4B3E34  srad r11, r10, r7
	tmp.u64 = (ctx.r[7].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[10].s64 < 0) && ((ctx.r[10].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[11].s64 = ctx.r[10].s64 >> tmp.u64;
	// 821C81C0: 7D674436  srd r7, r11, r8
	if (ctx.r[8].u8 & 0x40) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = (ctx.r[11].u64) >> ((ctx.r[8].u8 & 0x3F) as u32);
	}
	// 821C81C4: 480526BD  bl 0x8221a880
	ctx.lr = 0x821C81C8;
	sub_8221A880(ctx, base);
	pc = 0x821C81C8; continue 'dispatch;
            }
            0x821C81C8 => {
    //   block [0x821C81C8..0x821C81D8)
	// 821C81C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C81CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C81D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C81D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C81D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C81D8 size=2424
    let mut pc: u32 = 0x821C81D8;
    'dispatch: loop {
        match pc {
            0x821C81D8 => {
    //   block [0x821C81D8..0x821C8208)
	// 821C81D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C81DC: 48AE1211  bl 0x82ca93ec
	ctx.lr = 0x821C81E0;
	sub_82CA93D0(ctx, base);
	// 821C81E0: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C81E4: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821C81E8: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	// 821C81EC: 3B8B2390  addi r28, r11, 0x2390
	ctx.r[28].s64 = ctx.r[11].s64 + 9104;
	// 821C81F0: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821C81F4: 9AC10058  stb r22, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[22].u8 ) };
	// 821C81F8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821C81FC: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 821C8200: 397C2004  addi r11, r28, 0x2004
	ctx.r[11].s64 = ctx.r[28].s64 + 8196;
	// 821C8204: 392A7E70  addi r9, r10, 0x7e70
	ctx.r[9].s64 = ctx.r[10].s64 + 32368;
	pc = 0x821C8208; continue 'dispatch;
            }
            0x821C8208 => {
    //   block [0x821C8208..0x821C828C)
	// 821C8208: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C820C: 391C6014  addi r8, r28, 0x6014
	ctx.r[8].s64 = ctx.r[28].s64 + 24596;
	// 821C8210: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821C8214: 7CEA5A14  add r7, r10, r11
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821C8218: 9127DFFC  stw r9, -0x2004(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(-8196 as u32), ctx.r[9].u32 ) };
	// 821C821C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C8220: 80CBFFFC  lwz r6, -4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821C8224: 54C4083C  slwi r4, r6, 1
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821C8228: 38AA0001  addi r5, r10, 1
	ctx.r[5].s64 = ctx.r[10].s64 + 1;
	// 821C822C: 908BFFFC  stw r4, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[4].u32 ) };
	// 821C8230: 90AB0000  stw r5, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 821C8234: 396B2008  addi r11, r11, 0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + 8200;
	// 821C8238: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 821C823C: 4198FFCC  blt cr6, 0x821c8208
	if ctx.cr[6].lt {
	pc = 0x821C8208; continue 'dispatch;
	}
	// 821C8240: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821C8244: 807B00C0  lwz r3, 0xc0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(192 as u32) ) } as u64;
	// 821C8248: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821C824C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821C8250: 480568A1  bl 0x8221eaf0
	ctx.lr = 0x821C8254;
	sub_8221EAF0(ctx, base);
	// 821C8254: 817B00C0  lwz r11, 0xc0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(192 as u32) ) } as u64;
	// 821C8258: 3D407FFF  lis r10, 0x7fff
	ctx.r[10].s64 = 2147418112;
	// 821C825C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 821C8260: 6149FFFF  ori r9, r10, 0xffff
	ctx.r[9].u64 = ctx.r[10].u64 | 65535;
	// 821C8264: 810B0054  lwz r8, 0x54(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 821C8268: 7F084800  cmpw cr6, r8, r9
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821C826C: 419A08D4  beq cr6, 0x821c8b40
	if ctx.cr[6].eq {
	pc = 0x821C8B40; continue 'dispatch;
	}
	// 821C8270: 3D40834F  lis r10, -0x7cb1
	ctx.r[10].s64 = -2091974656;
	// 821C8274: 816A6EC0  lwz r11, 0x6ec0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28352 as u32) ) } as u64;
	// 821C8278: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821C827C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C8280: 409A000C  bne cr6, 0x821c828c
	if !ctx.cr[6].eq {
	pc = 0x821C828C; continue 'dispatch;
	}
	// 821C8284: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 821C8288: 916A6EC0  stw r11, 0x6ec0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28352 as u32), ctx.r[11].u32 ) };
	pc = 0x821C828C; continue 'dispatch;
            }
            0x821C828C => {
    //   block [0x821C828C..0x821C837C)
	// 821C828C: 81750004  lwz r11, 4(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8290: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821C8294: C82B02E8  lfd f1, 0x2e8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(744 as u32) ) };
	// 821C8298: 488B9FE1  bl 0x82a82278
	ctx.lr = 0x821C829C;
	sub_82A82278(ctx, base);
	// 821C829C: 386000BC  li r3, 0xbc
	ctx.r[3].s64 = 188;
	// 821C82A0: 48063F71  bl 0x8222c210
	ctx.lr = 0x821C82A4;
	sub_8222C210(ctx, base);
	// 821C82A4: 386000BD  li r3, 0xbd
	ctx.r[3].s64 = 189;
	// 821C82A8: 48040869  bl 0x82208b10
	ctx.lr = 0x821C82AC;
	sub_82208B10(ctx, base);
	// 821C82AC: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 821C82B0: 3EE08336  lis r23, -0x7cca
	ctx.r[23].s64 = -2093613056;
	// 821C82B4: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821C82B8: 392ADF40  addi r9, r10, -0x20c0
	ctx.r[9].s64 = ctx.r[10].s64 + -8384;
	// 821C82BC: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821C82C0: 3BEB63A0  addi r31, r11, 0x63a0
	ctx.r[31].s64 = ctx.r[11].s64 + 25504;
	// 821C82C4: 3B2A0DB8  addi r25, r10, 0xdb8
	ctx.r[25].s64 = ctx.r[10].s64 + 3512;
	// 821C82C8: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 821C82CC: 3F408349  lis r26, -0x7cb7
	ctx.r[26].s64 = -2092367872;
	// 821C82D0: 81770364  lwz r11, 0x364(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(868 as u32) ) } as u64;
	// 821C82D4: 81490014  lwz r10, 0x14(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C82D8: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 821C82DC: 914B2E2C  stw r10, 0x2e2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(11820 as u32), ctx.r[10].u32 ) };
	// 821C82E0: E8C70010  ld r6, 0x10(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(16 as u32) ) };
	// 821C82E4: 64C50008  oris r5, r6, 8
	ctx.r[5].u64 = ctx.r[6].u64 | 524288;
	// 821C82E8: F8A70010  std r5, 0x10(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(16 as u32), ctx.r[5].u64 ) };
	// 821C82EC: 889B0100  lbz r4, 0x100(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(256 as u32) ) } as u64;
	// 821C82F0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821C82F4: 914870B8  stw r10, 0x70b8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(28856 as u32), ctx.r[10].u32 ) };
	// 821C82F8: 419A00B8  beq cr6, 0x821c83b0
	if ctx.cr[6].eq {
	pc = 0x821C83B0; continue 'dispatch;
	}
	// 821C82FC: 897B0101  lbz r11, 0x101(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(257 as u32) ) } as u64;
	// 821C8300: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C8304: 419A00AC  beq cr6, 0x821c83b0
	if ctx.cr[6].eq {
	pc = 0x821C83B0; continue 'dispatch;
	}
	// 821C8308: 3D208331  lis r9, -0x7ccf
	ctx.r[9].s64 = -2093940736;
	// 821C830C: 891F0105  lbz r8, 0x105(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(261 as u32) ) } as u64;
	// 821C8310: 815F00F4  lwz r10, 0xf4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 821C8314: 38E9701C  addi r7, r9, 0x701c
	ctx.r[7].s64 = ctx.r[9].s64 + 28700;
	// 821C8318: 1D682008  mulli r11, r8, 0x2008
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821C831C: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8320: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 821C8324: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821C8328: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821C832C: 419A0084  beq cr6, 0x821c83b0
	if ctx.cr[6].eq {
	pc = 0x821C83B0; continue 'dispatch;
	}
	// 821C8330: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C8334: 813F00F8  lwz r9, 0xf8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 821C8338: 7D275038  and r7, r9, r10
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[10].u64;
	// 821C833C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C8340: 409A003C  bne cr6, 0x821c837c
	if !ctx.cr[6].eq {
	pc = 0x821C837C; continue 'dispatch;
	}
	// 821C8344: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C8348: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 821C834C: 38DF00F0  addi r6, r31, 0xf0
	ctx.r[6].s64 = ctx.r[31].s64 + 240;
	// 821C8350: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821C8354: 915F00F8  stw r10, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[10].u32 ) };
	// 821C8358: 7CC5592E  stwx r6, r5, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u32) };
	// 821C835C: 815F00F4  lwz r10, 0xf4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 821C8360: 808B2004  lwz r4, 0x2004(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C8364: 54891838  slwi r9, r4, 3
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C8368: 7C695A14  add r3, r9, r11
	ctx.r[3].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821C836C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821C8370: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C8374: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821C8378: 914B2004  stw r10, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[10].u32 ) };
	pc = 0x821C837C; continue 'dispatch;
            }
            0x821C837C => {
    //   block [0x821C837C..0x821C83B0)
	// 821C837C: 897F0104  lbz r11, 0x104(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 821C8380: 911F00F4  stw r8, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[8].u32 ) };
	// 821C8384: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C8388: 409A0028  bne cr6, 0x821c83b0
	if !ctx.cr[6].eq {
	pc = 0x821C83B0; continue 'dispatch;
	}
	// 821C838C: 817A0DB0  lwz r11, 0xdb0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821C8390: 7ECAB378  mr r10, r22
	ctx.r[10].u64 = ctx.r[22].u64;
	// 821C8394: 393F00F0  addi r9, r31, 0xf0
	ctx.r[9].s64 = ctx.r[31].s64 + 240;
	// 821C8398: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C839C: 995F0104  stb r10, 0x104(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[10].u8 ) };
	// 821C83A0: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 821C83A4: 907A0DB0  stw r3, 0xdb0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(3504 as u32), ctx.r[3].u32 ) };
	// 821C83A8: 7D28C92E  stwx r9, r8, r25
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[25].u32), ctx.r[9].u32) };
	// 821C83AC: 48000008  b 0x821c83b4
	pc = 0x821C83B4; continue 'dispatch;
            }
            0x821C83B0 => {
    //   block [0x821C83B0..0x821C83B4)
	// 821C83B0: 807A0DB0  lwz r3, 0xdb0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(3504 as u32) ) } as u64;
	pc = 0x821C83B4; continue 'dispatch;
            }
            0x821C83B4 => {
    //   block [0x821C83B4..0x821C842C)
	// 821C83B4: 893B0100  lbz r9, 0x100(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(256 as u32) ) } as u64;
	// 821C83B8: 891F00BD  lbz r8, 0xbd(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(189 as u32) ) } as u64;
	// 821C83BC: 7D270034  cntlzw r7, r9
	ctx.r[7].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821C83C0: 815F00AC  lwz r10, 0xac(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 821C83C4: 1D682008  mulli r11, r8, 0x2008
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821C83C8: 54E6DFFE  rlwinm r6, r7, 0x1b, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 821C83CC: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 821C83D0: 68C80001  xori r8, r6, 1
	ctx.r[8].u64 = ctx.r[6].u64 ^ 1;
	// 821C83D4: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821C83D8: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821C83DC: 419A007C  beq cr6, 0x821c8458
	if ctx.cr[6].eq {
	pc = 0x821C8458; continue 'dispatch;
	}
	// 821C83E0: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C83E4: 813F00B0  lwz r9, 0xb0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 821C83E8: 7D275038  and r7, r9, r10
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[10].u64;
	// 821C83EC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C83F0: 409A003C  bne cr6, 0x821c842c
	if !ctx.cr[6].eq {
	pc = 0x821C842C; continue 'dispatch;
	}
	// 821C83F4: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C83F8: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 821C83FC: 38DF00A8  addi r6, r31, 0xa8
	ctx.r[6].s64 = ctx.r[31].s64 + 168;
	// 821C8400: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821C8404: 915F00B0  stw r10, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[10].u32 ) };
	// 821C8408: 7CC5592E  stwx r6, r5, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u32) };
	// 821C840C: 815F00AC  lwz r10, 0xac(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 821C8410: 808B2004  lwz r4, 0x2004(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C8414: 54891838  slwi r9, r4, 3
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C8418: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821C841C: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821C8420: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C8424: 38EA0001  addi r7, r10, 1
	ctx.r[7].s64 = ctx.r[10].s64 + 1;
	// 821C8428: 90EB2004  stw r7, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	pc = 0x821C842C; continue 'dispatch;
            }
            0x821C842C => {
    //   block [0x821C842C..0x821C8458)
	// 821C842C: 897F00BC  lbz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 821C8430: 911F00AC  stw r8, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[8].u32 ) };
	// 821C8434: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C8438: 409A0020  bne cr6, 0x821c8458
	if !ctx.cr[6].eq {
	pc = 0x821C8458; continue 'dispatch;
	}
	// 821C843C: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821C8440: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 821C8444: 393F00A8  addi r9, r31, 0xa8
	ctx.r[9].s64 = ctx.r[31].s64 + 168;
	// 821C8448: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 821C844C: 997F00BC  stb r11, 0xbc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[11].u8 ) };
	// 821C8450: 907A0DB0  stw r3, 0xdb0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(3504 as u32), ctx.r[3].u32 ) };
	// 821C8454: 7D2AC92E  stwx r9, r10, r25
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[25].u32), ctx.r[9].u32) };
	pc = 0x821C8458; continue 'dispatch;
            }
            0x821C8458 => {
    //   block [0x821C8458..0x821C84CC)
	// 821C8458: 891F0045  lbz r8, 0x45(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(69 as u32) ) } as u64;
	// 821C845C: 893B0100  lbz r9, 0x100(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(256 as u32) ) } as u64;
	// 821C8460: 1D682008  mulli r11, r8, 0x2008
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821C8464: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 821C8468: 7D270034  cntlzw r7, r9
	ctx.r[7].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821C846C: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 821C8470: 54E8DFFE  rlwinm r8, r7, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 821C8474: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821C8478: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821C847C: 419A007C  beq cr6, 0x821c84f8
	if ctx.cr[6].eq {
	pc = 0x821C84F8; continue 'dispatch;
	}
	// 821C8480: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C8484: 813F0038  lwz r9, 0x38(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821C8488: 7D275038  and r7, r9, r10
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[10].u64;
	// 821C848C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821C8490: 409A003C  bne cr6, 0x821c84cc
	if !ctx.cr[6].eq {
	pc = 0x821C84CC; continue 'dispatch;
	}
	// 821C8494: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C8498: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 821C849C: 38DF0030  addi r6, r31, 0x30
	ctx.r[6].s64 = ctx.r[31].s64 + 48;
	// 821C84A0: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821C84A4: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 821C84A8: 7CC5592E  stwx r6, r5, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u32) };
	// 821C84AC: 808B2004  lwz r4, 0x2004(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C84B0: 54891838  slwi r9, r4, 3
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C84B4: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 821C84B8: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821C84BC: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821C84C0: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C84C4: 38EA0001  addi r7, r10, 1
	ctx.r[7].s64 = ctx.r[10].s64 + 1;
	// 821C84C8: 90EB2004  stw r7, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	pc = 0x821C84CC; continue 'dispatch;
            }
            0x821C84CC => {
    //   block [0x821C84CC..0x821C84F8)
	// 821C84CC: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 821C84D0: 911F0034  stw r8, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[8].u32 ) };
	// 821C84D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C84D8: 409A0020  bne cr6, 0x821c84f8
	if !ctx.cr[6].eq {
	pc = 0x821C84F8; continue 'dispatch;
	}
	// 821C84DC: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821C84E0: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 821C84E4: 393F0030  addi r9, r31, 0x30
	ctx.r[9].s64 = ctx.r[31].s64 + 48;
	// 821C84E8: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 821C84EC: 997F0044  stb r11, 0x44(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u8 ) };
	// 821C84F0: 907A0DB0  stw r3, 0xdb0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(3504 as u32), ctx.r[3].u32 ) };
	// 821C84F4: 7D2AC92E  stwx r9, r10, r25
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[25].u32), ctx.r[9].u32) };
	pc = 0x821C84F8; continue 'dispatch;
            }
            0x821C84F8 => {
    //   block [0x821C84F8..0x821C8540)
	// 821C84F8: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821C84FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C8500: 392BDED4  addi r9, r11, -0x212c
	ctx.r[9].s64 = ctx.r[11].s64 + -8492;
	// 821C8504: 795DFFE6  rldicr r29, r10, 0x3f, 0x3f
	ctx.r[29].u64 = (ctx.r[10].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821C8508: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C850C: 83CB0300  lwz r30, 0x300(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(768 as u32) ) } as u64;
	// 821C8510: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 821C8514: 419A016C  beq cr6, 0x821c8680
	if ctx.cr[6].eq {
	pc = 0x821C8680; continue 'dispatch;
	}
	// 821C8518: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821C851C: 41980024  blt cr6, 0x821c8540
	if ctx.cr[6].lt {
	pc = 0x821C8540; continue 'dispatch;
	}
	// 821C8520: 397E0020  addi r11, r30, 0x20
	ctx.r[11].s64 = ctx.r[30].s64 + 32;
	// 821C8524: 80770364  lwz r3, 0x364(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(868 as u32) ) } as u64;
	// 821C8528: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821C852C: 80B80004  lwz r5, 4(r24)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8530: 796A0020  clrldi r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 821C8534: 7FA65436  srd r6, r29, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[29].u64) >> ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 821C8538: 4BFEE9A9  bl 0x821b6ee0
	ctx.lr = 0x821C853C;
	sub_821B6EE0(ctx, base);
	// 821C853C: 807A0DB0  lwz r3, 0xdb0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(3504 as u32) ) } as u64;
	pc = 0x821C8540; continue 'dispatch;
            }
            0x821C8540 => {
    //   block [0x821C8540..0x821C85CC)
	// 821C8540: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C8544: 395F0AB0  addi r10, r31, 0xab0
	ctx.r[10].s64 = ctx.r[31].s64 + 2736;
	// 821C8548: 7D3E5A14  add r9, r30, r11
	ctx.r[9].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 821C854C: 3D608331  lis r11, -0x7ccf
	ctx.r[11].s64 = -2093940736;
	// 821C8550: 55271838  slwi r7, r9, 3
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821C8554: 390B6F38  addi r8, r11, 0x6f38
	ctx.r[8].s64 = ctx.r[11].s64 + 28472;
	// 821C8558: 7D675214  add r11, r7, r10
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 821C855C: 81280008  lwz r9, 8(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C8560: 88CB0015  lbz r6, 0x15(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821C8564: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8568: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 821C856C: 1D462008  mulli r10, r6, 0x2008
	ctx.r[10].s32 = ((ctx.r[6].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821C8570: 7D4AE214  add r10, r10, r28
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 821C8574: 7F054840  cmplw cr6, r5, r9
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821C8578: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C857C: 419A0074  beq cr6, 0x821c85f0
	if ctx.cr[6].eq {
	pc = 0x821C85F0; continue 'dispatch;
	}
	// 821C8580: 80CA2000  lwz r6, 0x2000(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C8584: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C8588: 7CBE3038  and r30, r5, r6
	ctx.r[30].u64 = ctx.r[5].u64 & ctx.r[6].u64;
	// 821C858C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821C8590: 409A003C  bne cr6, 0x821c85cc
	if !ctx.cr[6].eq {
	pc = 0x821C85CC; continue 'dispatch;
	}
	// 821C8594: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C8598: 7CA63378  or r6, r5, r6
	ctx.r[6].u64 = ctx.r[5].u64 | ctx.r[6].u64;
	// 821C859C: 55251838  slwi r5, r9, 3
	ctx.r[5].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821C85A0: 90CB0008  stw r6, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 821C85A4: 7D65512E  stwx r11, r5, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 821C85A8: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C85AC: 80AA2004  lwz r5, 0x2004(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C85B0: 54A91838  slwi r9, r5, 3
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C85B4: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821C85B8: 90C90004  stw r6, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 821C85BC: 81280008  lwz r9, 8(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C85C0: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C85C4: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 821C85C8: 910A2004  stw r8, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[8].u32 ) };
	pc = 0x821C85CC; continue 'dispatch;
            }
            0x821C85CC => {
    //   block [0x821C85CC..0x821C85F0)
	// 821C85CC: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C85D0: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 821C85D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C85D8: 409A0018  bne cr6, 0x821c85f0
	if !ctx.cr[6].eq {
	pc = 0x821C85F0; continue 'dispatch;
	}
	// 821C85DC: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821C85E0: 9ACB0014  stb r22, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[22].u8 ) };
	// 821C85E4: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 821C85E8: 907A0DB0  stw r3, 0xdb0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(3504 as u32), ctx.r[3].u32 ) };
	// 821C85EC: 7D6AC92E  stwx r11, r10, r25
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[25].u32), ctx.r[11].u32) };
	pc = 0x821C85F0; continue 'dispatch;
            }
            0x821C85F0 => {
    //   block [0x821C85F0..0x821C865C)
	// 821C85F0: 397F0C90  addi r11, r31, 0xc90
	ctx.r[11].s64 = ctx.r[31].s64 + 3216;
	// 821C85F4: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 821C85F8: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821C85FC: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8600: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821C8604: 7D4AE214  add r10, r10, r28
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 821C8608: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821C860C: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C8610: 419A0070  beq cr6, 0x821c8680
	if ctx.cr[6].eq {
	pc = 0x821C8680; continue 'dispatch;
	}
	// 821C8614: 810A2000  lwz r8, 0x2000(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C8618: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C861C: 7CE64038  and r6, r7, r8
	ctx.r[6].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 821C8620: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821C8624: 409A0038  bne cr6, 0x821c865c
	if !ctx.cr[6].eq {
	pc = 0x821C865C; continue 'dispatch;
	}
	// 821C8628: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C862C: 7CE54378  or r5, r7, r8
	ctx.r[5].u64 = ctx.r[7].u64 | ctx.r[8].u64;
	// 821C8630: 54C41838  slwi r4, r6, 3
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821C8634: 90AB0008  stw r5, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 821C8638: 7D64512E  stwx r11, r4, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 821C863C: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C8640: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C8644: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8648: 7CC85214  add r6, r8, r10
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C864C: 90E60004  stw r7, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821C8650: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C8654: 38A80001  addi r5, r8, 1
	ctx.r[5].s64 = ctx.r[8].s64 + 1;
	// 821C8658: 90AA2004  stw r5, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[5].u32 ) };
	pc = 0x821C865C; continue 'dispatch;
            }
            0x821C865C => {
    //   block [0x821C865C..0x821C8680)
	// 821C865C: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C8660: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C8664: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C8668: 409A0018  bne cr6, 0x821c8680
	if !ctx.cr[6].eq {
	pc = 0x821C8680; continue 'dispatch;
	}
	// 821C866C: 5469103A  slwi r9, r3, 2
	ctx.r[9].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C8670: 9ACB0014  stb r22, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[22].u8 ) };
	// 821C8674: 39430001  addi r10, r3, 1
	ctx.r[10].s64 = ctx.r[3].s64 + 1;
	// 821C8678: 915A0DB0  stw r10, 0xdb0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821C867C: 7D69C92E  stwx r11, r9, r25
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[25].u32), ctx.r[11].u32) };
	pc = 0x821C8680; continue 'dispatch;
            }
            0x821C8680 => {
    //   block [0x821C8680..0x821C86AC)
	// 821C8680: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C8684: E96B1760  ld r11, 0x1760(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(5984 as u32) ) };
	// 821C8688: 796A0004  rldicr r10, r11, 0, 0
	ctx.r[10].u64 = (ctx.r[11].u64).rotate_left(0) & 0x8000000000000000;
	// 821C868C: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 821C8690: 419A001C  beq cr6, 0x821c86ac
	if ctx.cr[6].eq {
	pc = 0x821C86AC; continue 'dispatch;
	}
	// 821C8694: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 821C8698: 80770364  lwz r3, 0x364(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(868 as u32) ) } as u64;
	// 821C869C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 821C86A0: 38B506B0  addi r5, r21, 0x6b0
	ctx.r[5].s64 = ctx.r[21].s64 + 1712;
	// 821C86A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821C86A8: 480521D9  bl 0x8221a880
	ctx.lr = 0x821C86AC;
	sub_8221A880(ctx, base);
	pc = 0x821C86AC; continue 'dispatch;
            }
            0x821C86AC => {
    //   block [0x821C86AC..0x821C86C0)
	// 821C86AC: 81750004  lwz r11, 4(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C86B0: 394100D0  addi r10, r1, 0xd0
	ctx.r[10].s64 = ctx.r[1].s64 + 208;
	// 821C86B4: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821C86B8: 396B0150  addi r11, r11, 0x150
	ctx.r[11].s64 = ctx.r[11].s64 + 336;
	// 821C86BC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x821C86C0; continue 'dispatch;
            }
            0x821C86C0 => {
    //   block [0x821C86C0..0x821C8B40)
	// 821C86C0: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821C86C4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821C86C8: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821C86CC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821C86D0: 4200FFF0  bdnz 0x821c86c0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821C86C0; continue 'dispatch;
	}
	// 821C86D4: 396000A0  li r11, 0xa0
	ctx.r[11].s64 = 160;
	// 821C86D8: 39410100  addi r10, r1, 0x100
	ctx.r[10].s64 = ctx.r[1].s64 + 256;
	// 821C86DC: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 821C86E0: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	pc = 0x821C8B40; continue 'dispatch;
            }
            0x821C8B40 => {
    //   block [0x821C8B40..0x821C8B50)
	// 821C8B40: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821C8B44: 4805679D  bl 0x8221f2e0
	ctx.lr = 0x821C8B48;
	sub_8221F2E0(ctx, base);
	// 821C8B48: 382101B0  addi r1, r1, 0x1b0
	ctx.r[1].s64 = ctx.r[1].s64 + 432;
	// 821C8B4C: 48AE08F0  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C8B50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C8B50 size=208
    let mut pc: u32 = 0x821C8B50;
    'dispatch: loop {
        match pc {
            0x821C8B50 => {
    //   block [0x821C8B50..0x821C8B90)
	// 821C8B50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C8B54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C8B58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821C8B5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C8B60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C8B64: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821C8B68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C8B6C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821C8B70: 419A0094  beq cr6, 0x821c8c04
	if ctx.cr[6].eq {
	pc = 0x821C8C04; continue 'dispatch;
	}
	// 821C8B74: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C8B78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C8B7C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8B80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821C8B84: 4E800421  bctrl
	ctx.lr = 0x821C8B88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C8B88: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 821C8B8C: 396B581C  addi r11, r11, 0x581c
	ctx.r[11].s64 = ctx.r[11].s64 + 22556;
            }
            0x821C8B90 => {
    //   block [0x821C8B90..0x821C8BA8)
	// 821C8B90: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821C8B94: 419A0044  beq cr6, 0x821c8bd8
	if ctx.cr[6].eq {
	pc = 0x821C8BD8; continue 'dispatch;
	}
	// 821C8B98: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 821C8B9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821C8BA0: 4082FFF0  bne 0x821c8b90
	if !ctx.cr[0].eq {
	pc = 0x821C8B90; continue 'dispatch;
	}
	// 821C8BA4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821C8BA8; continue 'dispatch;
            }
            0x821C8BA8 => {
    //   block [0x821C8BA8..0x821C8BD0)
	// 821C8BA8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C8BAC: 41820058  beq 0x821c8c04
	if ctx.cr[0].eq {
	pc = 0x821C8C04; continue 'dispatch;
	}
	// 821C8BB0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C8BB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C8BB8: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 821C8BBC: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 821C8BC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821C8BC4: 4E800421  bctrl
	ctx.lr = 0x821C8BC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C8BC8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821C8BCC: 40820014  bne 0x821c8be0
	if !ctx.cr[0].eq {
	pc = 0x821C8BE0; continue 'dispatch;
	}
            }
            0x821C8BD0 => {
    //   block [0x821C8BD0..0x821C8BD8)
	// 821C8BD0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821C8BD4: 48000034  b 0x821c8c08
	pc = 0x821C8C08; continue 'dispatch;
            }
            0x821C8BD8 => {
    //   block [0x821C8BD8..0x821C8BE0)
	// 821C8BD8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821C8BDC: 4BFFFFCC  b 0x821c8ba8
	pc = 0x821C8BA8; continue 'dispatch;
            }
            0x821C8BE0 => {
    //   block [0x821C8BE0..0x821C8C04)
	// 821C8BE0: 809F006C  lwz r4, 0x6c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 821C8BE4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8BE8: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821C8BEC: 419AFFE4  beq cr6, 0x821c8bd0
	if ctx.cr[6].eq {
	pc = 0x821C8BD0; continue 'dispatch;
	}
	// 821C8BF0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C8BF4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C8BF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821C8BFC: 4E800421  bctrl
	ctx.lr = 0x821C8C00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C8C00: 4BFFFFD0  b 0x821c8bd0
	pc = 0x821C8BD0; continue 'dispatch;
            }
            0x821C8C04 => {
    //   block [0x821C8C04..0x821C8C08)
	// 821C8C04: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x821C8C08; continue 'dispatch;
            }
            0x821C8C08 => {
    //   block [0x821C8C08..0x821C8C20)
	// 821C8C08: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821C8C0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C8C10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C8C14: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821C8C18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C8C1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C8C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C8C20 size=564
    let mut pc: u32 = 0x821C8C20;
    'dispatch: loop {
        match pc {
            0x821C8C20 => {
    //   block [0x821C8C20..0x821C8C50)
	// 821C8C20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C8C24: 48AE07E1  bl 0x82ca9404
	ctx.lr = 0x821C8C28;
	sub_82CA93D0(ctx, base);
	// 821C8C28: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C8C2C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821C8C30: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821C8C34: 386000A5  li r3, 0xa5
	ctx.r[3].s64 = 165;
	// 821C8C38: 897C00D8  lbz r11, 0xd8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(216 as u32) ) } as u64;
	// 821C8C3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C8C40: 419A0010  beq cr6, 0x821c8c50
	if ctx.cr[6].eq {
	pc = 0x821C8C50; continue 'dispatch;
	}
	// 821C8C44: 480635CD  bl 0x8222c210
	ctx.lr = 0x821C8C48;
	sub_8222C210(ctx, base);
	// 821C8C48: 386000A7  li r3, 0xa7
	ctx.r[3].s64 = 167;
	// 821C8C4C: 4800000C  b 0x821c8c58
	pc = 0x821C8C58; continue 'dispatch;
            }
            0x821C8C50 => {
    //   block [0x821C8C50..0x821C8C58)
	// 821C8C50: 480635C1  bl 0x8222c210
	ctx.lr = 0x821C8C54;
	sub_8222C210(ctx, base);
	// 821C8C54: 386000A6  li r3, 0xa6
	ctx.r[3].s64 = 166;
	pc = 0x821C8C58; continue 'dispatch;
            }
            0x821C8C58 => {
    //   block [0x821C8C58..0x821C8C94)
	// 821C8C58: 4803FEB9  bl 0x82208b10
	ctx.lr = 0x821C8C5C;
	sub_82208B10(ctx, base);
	// 821C8C5C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C8C60: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C8C64: 3FA08336  lis r29, -0x7cca
	ctx.r[29].s64 = -2093613056;
	// 821C8C68: 795EFFE6  rldicr r30, r10, 0x3f, 0x3f
	ctx.r[30].u64 = (ctx.r[10].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821C8C6C: E96B1760  ld r11, 0x1760(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(5984 as u32) ) };
	// 821C8C70: 79690004  rldicr r9, r11, 0, 0
	ctx.r[9].u64 = (ctx.r[11].u64).rotate_left(0) & 0x8000000000000000;
	// 821C8C74: 2B290000  cmpldi cr6, r9, 0
	ctx.cr[6].compare_u64(ctx.r[9].u64, 0, &mut ctx.xer);
	// 821C8C78: 419A001C  beq cr6, 0x821c8c94
	if ctx.cr[6].eq {
	pc = 0x821C8C94; continue 'dispatch;
	}
	// 821C8C7C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 821C8C80: 807D0364  lwz r3, 0x364(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(868 as u32) ) } as u64;
	// 821C8C84: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 821C8C88: 38BF06B0  addi r5, r31, 0x6b0
	ctx.r[5].s64 = ctx.r[31].s64 + 1712;
	// 821C8C8C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821C8C90: 48051BF1  bl 0x8221a880
	ctx.lr = 0x821C8C94;
	sub_8221A880(ctx, base);
	pc = 0x821C8C94; continue 'dispatch;
            }
            0x821C8C94 => {
    //   block [0x821C8C94..0x821C8CD8)
	// 821C8C94: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821C8C98: 389C00D0  addi r4, r28, 0xd0
	ctx.r[4].s64 = ctx.r[28].s64 + 208;
	// 821C8C9C: 394BDED4  addi r10, r11, -0x212c
	ctx.r[10].s64 = ctx.r[11].s64 + -8492;
	// 821C8CA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C8CA4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8CA8: 83EB0BD0  lwz r31, 0xbd0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3024 as u32) ) } as u64;
	// 821C8CAC: 48003EE5  bl 0x821ccb90
	ctx.lr = 0x821C8CB0;
	sub_821CCB90(ctx, base);
	// 821C8CB0: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821C8CB4: 41980024  blt cr6, 0x821c8cd8
	if ctx.cr[6].lt {
	pc = 0x821C8CD8; continue 'dispatch;
	}
	// 821C8CB8: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 821C8CBC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C8CC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821C8CC4: 807D0364  lwz r3, 0x364(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(868 as u32) ) } as u64;
	// 821C8CC8: 79690020  clrldi r9, r11, 0x20
	ctx.r[9].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 821C8CCC: 7FC64C36  srd r6, r30, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[30].u64) >> ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 821C8CD0: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8CD4: 4BFEE20D  bl 0x821b6ee0
	ctx.lr = 0x821C8CD8;
	sub_821B6EE0(ctx, base);
	pc = 0x821C8CD8; continue 'dispatch;
            }
            0x821C8CD8 => {
    //   block [0x821C8CD8..0x821C8D8C)
	// 821C8CD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821C8CDC: 4BFEEE3D  bl 0x821b7b18
	ctx.lr = 0x821C8CE0;
	sub_821B7B18(ctx, base);
	// 821C8CE0: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C8CE4: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821C8CE8: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 821C8CEC: 38EA63A0  addi r7, r10, 0x63a0
	ctx.r[7].s64 = ctx.r[10].s64 + 25504;
	// 821C8CF0: 55661838  slwi r6, r11, 3
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821C8CF4: 39671050  addi r11, r7, 0x1050
	ctx.r[11].s64 = ctx.r[7].s64 + 4176;
	// 821C8CF8: 3D408331  lis r10, -0x7ccf
	ctx.r[10].s64 = -2093940736;
	// 821C8CFC: 7D665A14  add r11, r6, r11
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 821C8D00: 390A6FC0  addi r8, r10, 0x6fc0
	ctx.r[8].s64 = ctx.r[10].s64 + 28608;
	// 821C8D04: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821C8D08: 3D20834B  lis r9, -0x7cb5
	ctx.r[9].s64 = -2092236800;
	// 821C8D0C: 3BAA0DB8  addi r29, r10, 0xdb8
	ctx.r[29].s64 = ctx.r[10].s64 + 3512;
	// 821C8D10: 38A92390  addi r5, r9, 0x2390
	ctx.r[5].s64 = ctx.r[9].s64 + 9104;
	// 821C8D14: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8D18: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 821C8D1C: 3FC08349  lis r30, -0x7cb7
	ctx.r[30].s64 = -2092367872;
	// 821C8D20: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821C8D24: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8D28: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821C8D2C: 7D4A2A14  add r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[5].u64;
	// 821C8D30: 7D3F4B78  mr r31, r9
	ctx.r[31].u64 = ctx.r[9].u64;
	// 821C8D34: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821C8D38: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C8D3C: 419A007C  beq cr6, 0x821c8db8
	if ctx.cr[6].eq {
	pc = 0x821C8DB8; continue 'dispatch;
	}
	// 821C8D40: 808A2000  lwz r4, 0x2000(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C8D44: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C8D48: 7C7B2038  and r27, r3, r4
	ctx.r[27].u64 = ctx.r[3].u64 & ctx.r[4].u64;
	// 821C8D4C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 821C8D50: 409A003C  bne cr6, 0x821c8d8c
	if !ctx.cr[6].eq {
	pc = 0x821C8D8C; continue 'dispatch;
	}
	// 821C8D54: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C8D58: 7C642378  or r4, r3, r4
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[4].u64;
	// 821C8D5C: 55231838  slwi r3, r9, 3
	ctx.r[3].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821C8D60: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 821C8D64: 7D63512E  stwx r11, r3, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 821C8D68: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8D6C: 806A2004  lwz r3, 0x2004(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C8D70: 54691838  slwi r9, r3, 3
	ctx.r[9].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C8D74: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821C8D78: 90890004  stw r4, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 821C8D7C: 808A2004  lwz r4, 0x2004(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C8D80: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 821C8D84: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8D88: 908A2004  stw r4, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[4].u32 ) };
	pc = 0x821C8D8C; continue 'dispatch;
            }
            0x821C8D8C => {
    //   block [0x821C8D8C..0x821C8DB8)
	// 821C8D8C: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C8D90: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821C8D94: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C8D98: 409A0020  bne cr6, 0x821c8db8
	if !ctx.cr[6].eq {
	pc = 0x821C8DB8; continue 'dispatch;
	}
	// 821C8D9C: 815E0DB0  lwz r10, 0xdb0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821C8DA0: 9B8B0014  stb r28, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[28].u8 ) };
	// 821C8DA4: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C8DA8: 388A0001  addi r4, r10, 1
	ctx.r[4].s64 = ctx.r[10].s64 + 1;
	// 821C8DAC: 909E0DB0  stw r4, 0xdb0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(3504 as u32), ctx.r[4].u32 ) };
	// 821C8DB0: 7D68E92E  stwx r11, r8, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[29].u32), ctx.r[11].u32) };
	// 821C8DB4: 48000008  b 0x821c8dbc
	pc = 0x821C8DBC; continue 'dispatch;
            }
            0x821C8DB8 => {
    //   block [0x821C8DB8..0x821C8DBC)
	// 821C8DB8: 809E0DB0  lwz r4, 0xdb0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(3504 as u32) ) } as u64;
	pc = 0x821C8DBC; continue 'dispatch;
            }
            0x821C8DBC => {
    //   block [0x821C8DBC..0x821C8E28)
	// 821C8DBC: 39671230  addi r11, r7, 0x1230
	ctx.r[11].s64 = ctx.r[7].s64 + 4656;
	// 821C8DC0: 7D665A14  add r11, r6, r11
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 821C8DC4: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821C8DC8: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8DCC: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821C8DD0: 7D4A2A14  add r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[5].u64;
	// 821C8DD4: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821C8DD8: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821C8DDC: 419A0070  beq cr6, 0x821c8e4c
	if ctx.cr[6].eq {
	pc = 0x821C8E4C; continue 'dispatch;
	}
	// 821C8DE0: 810A2000  lwz r8, 0x2000(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821C8DE4: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C8DE8: 7CE64038  and r6, r7, r8
	ctx.r[6].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 821C8DEC: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821C8DF0: 409A0038  bne cr6, 0x821c8e28
	if !ctx.cr[6].eq {
	pc = 0x821C8E28; continue 'dispatch;
	}
	// 821C8DF4: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C8DF8: 7CE54378  or r5, r7, r8
	ctx.r[5].u64 = ctx.r[7].u64 | ctx.r[8].u64;
	// 821C8DFC: 54C31838  slwi r3, r6, 3
	ctx.r[3].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821C8E00: 90AB0008  stw r5, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 821C8E04: 7D63512E  stwx r11, r3, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 821C8E08: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8E0C: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C8E10: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C8E14: 7CC85214  add r6, r8, r10
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821C8E18: 90E60004  stw r7, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821C8E1C: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821C8E20: 38A80001  addi r5, r8, 1
	ctx.r[5].s64 = ctx.r[8].s64 + 1;
	// 821C8E24: 90AA2004  stw r5, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[5].u32 ) };
	pc = 0x821C8E28; continue 'dispatch;
            }
            0x821C8E28 => {
    //   block [0x821C8E28..0x821C8E4C)
	// 821C8E28: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C8E2C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821C8E30: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821C8E34: 409A0018  bne cr6, 0x821c8e4c
	if !ctx.cr[6].eq {
	pc = 0x821C8E4C; continue 'dispatch;
	}
	// 821C8E38: 5489103A  slwi r9, r4, 2
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C8E3C: 9B8B0014  stb r28, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[28].u8 ) };
	// 821C8E40: 39440001  addi r10, r4, 1
	ctx.r[10].s64 = ctx.r[4].s64 + 1;
	// 821C8E44: 915E0DB0  stw r10, 0xdb0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821C8E48: 7D69E92E  stwx r11, r9, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[29].u32), ctx.r[11].u32) };
	pc = 0x821C8E4C; continue 'dispatch;
            }
            0x821C8E4C => {
    //   block [0x821C8E4C..0x821C8E54)
	// 821C8E4C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821C8E50: 48AE0604  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C8E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C8E58 size=68
    let mut pc: u32 = 0x821C8E58;
    'dispatch: loop {
        match pc {
            0x821C8E58 => {
    //   block [0x821C8E58..0x821C8E88)
	// 821C8E58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C8E5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C8E60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C8E64: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C8E68: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821C8E6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C8E70: 480B2321  bl 0x8227b190
	ctx.lr = 0x821C8E74;
	sub_8227B190(ctx, base);
	// 821C8E74: 817F06FC  lwz r11, 0x6fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1788 as u32) ) } as u64;
	// 821C8E78: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821C8E7C: 409A000C  bne cr6, 0x821c8e88
	if !ctx.cr[6].eq {
	pc = 0x821C8E88; continue 'dispatch;
	}
	// 821C8E80: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8E84: 48000225  bl 0x821c90a8
	ctx.lr = 0x821C8E88;
	sub_821C90A8(ctx, base);
	pc = 0x821C8E88; continue 'dispatch;
            }
            0x821C8E88 => {
    //   block [0x821C8E88..0x821C8E9C)
	// 821C8E88: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821C8E8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C8E90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C8E94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C8E98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C8EA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C8EA0 size=268
    let mut pc: u32 = 0x821C8EA0;
    'dispatch: loop {
        match pc {
            0x821C8EA0 => {
    //   block [0x821C8EA0..0x821C8EE0)
	// 821C8EA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C8EA4: 48AE0569  bl 0x82ca940c
	ctx.lr = 0x821C8EA8;
	sub_82CA93D0(ctx, base);
	// 821C8EA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C8EAC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821C8EB0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821C8EB4: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821C8EB8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C8EBC: 812A0080  lwz r9, 0x80(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 821C8EC0: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8EC4: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8EC8: 54EA003E  slwi r10, r7, 0
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821C8ECC: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8ED0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821C8ED4: 409A000C  bne cr6, 0x821c8ee0
	if !ctx.cr[6].eq {
	pc = 0x821C8EE0; continue 'dispatch;
	}
	// 821C8ED8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 821C8EDC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C8EE0; continue 'dispatch;
            }
            0x821C8EE0 => {
    //   block [0x821C8EE0..0x821C8F20)
	// 821C8EE0: 83EB0008  lwz r31, 8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C8EE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C8EE8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C8EEC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8EF0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C8EF4: 4E800421  bctrl
	ctx.lr = 0x821C8EF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C8EF8: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 821C8EFC: 419A0024  beq cr6, 0x821c8f20
	if ctx.cr[6].eq {
	pc = 0x821C8F20; continue 'dispatch;
	}
	// 821C8F00: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C8F04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C8F08: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8F0C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C8F10: 4E800421  bctrl
	ctx.lr = 0x821C8F14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C8F14: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 821C8F18: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821C8F1C: 409A0008  bne cr6, 0x821c8f24
	if !ctx.cr[6].eq {
	pc = 0x821C8F24; continue 'dispatch;
	}
            }
            0x821C8F20 => {
    //   block [0x821C8F20..0x821C8F24)
	// 821C8F20: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	pc = 0x821C8F24; continue 'dispatch;
            }
            0x821C8F24 => {
    //   block [0x821C8F24..0x821C8FA4)
	// 821C8F24: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C8F28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C8F2C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8F30: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C8F34: 4E800421  bctrl
	ctx.lr = 0x821C8F38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C8F38: 3923FFFC  addi r9, r3, -4
	ctx.r[9].s64 = ctx.r[3].s64 + -4;
	// 821C8F3C: 57A8063E  clrlwi r8, r29, 0x18
	ctx.r[8].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 821C8F40: 7D270034  cntlzw r7, r9
	ctx.r[7].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821C8F44: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821C8F48: 54E6DFFE  rlwinm r6, r7, 0x1b, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 821C8F4C: 68CB0001  xori r11, r6, 1
	ctx.r[11].u64 = ctx.r[6].u64 ^ 1;
	// 821C8F50: 409A0054  bne cr6, 0x821c8fa4
	if !ctx.cr[6].eq {
	pc = 0x821C8FA4; continue 'dispatch;
	}
	// 821C8F54: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821C8F58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C8F5C: 419A0048  beq cr6, 0x821c8fa4
	if ctx.cr[6].eq {
	pc = 0x821C8FA4; continue 'dispatch;
	}
	// 821C8F60: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C8F64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C8F68: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821C8F6C: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821C8F70: 480F8DB9  bl 0x822c1d28
	ctx.lr = 0x821C8F74;
	sub_822C1D28(ctx, base);
	// 821C8F74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C8F78: 4BFBCC49  bl 0x82185bc0
	ctx.lr = 0x821C8F7C;
	sub_82185BC0(ctx, base);
	// 821C8F7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C8F80: 480F8EE1  bl 0x822c1e60
	ctx.lr = 0x821C8F84;
	sub_822C1E60(ctx, base);
	// 821C8F84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C8F88: 4BFBCD69  bl 0x82185cf0
	ctx.lr = 0x821C8F8C;
	sub_82185CF0(ctx, base);
	// 821C8F8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C8F90: 480F8C61  bl 0x822c1bf0
	ctx.lr = 0x821C8F94;
	sub_822C1BF0(ctx, base);
	// 821C8F94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C8F98: 4BFBCFF1  bl 0x82185f88
	ctx.lr = 0x821C8F9C;
	sub_82185F88(ctx, base);
	// 821C8F9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821C8FA0: 480F8999  bl 0x822c1938
	ctx.lr = 0x821C8FA4;
	sub_822C1938(ctx, base);
            }
            0x821C8FA4 => {
    //   block [0x821C8FA4..0x821C8FAC)
	// 821C8FA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821C8FA8: 48AE04B4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C8FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C8FB0 size=244
    let mut pc: u32 = 0x821C8FB0;
    'dispatch: loop {
        match pc {
            0x821C8FB0 => {
    //   block [0x821C8FB0..0x821C90A4)
	// 821C8FB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C8FB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C8FB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821C8FBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C8FC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C8FC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C8FC8: 4BFC3CB9  bl 0x8218cc80
	ctx.lr = 0x821C8FCC;
	sub_8218CC80(ctx, base);
	// 821C8FCC: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 821C8FD0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8FD4: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C8FD8: 48068A51  bl 0x82231a28
	ctx.lr = 0x821C8FDC;
	sub_82231A28(ctx, base);
	// 821C8FDC: 813F0058  lwz r9, 0x58(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 821C8FE0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C8FE4: 386B00B4  addi r3, r11, 0xb4
	ctx.r[3].s64 = ctx.r[11].s64 + 180;
	// 821C8FE8: 485D7E31  bl 0x827a0e18
	ctx.lr = 0x821C8FEC;
	sub_827A0E18(ctx, base);
	// 821C8FEC: 807F008C  lwz r3, 0x8c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821C8FF0: 4BFCCF21  bl 0x82195f10
	ctx.lr = 0x821C8FF4;
	sub_82195F10(ctx, base);
	// 821C8FF4: 3FC0834A  lis r30, -0x7cb6
	ctx.r[30].s64 = -2092302336;
	// 821C8FF8: 807EE9EC  lwz r3, -0x1614(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-5652 as u32) ) } as u64;
	// 821C8FFC: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C9000: 80E80018  lwz r7, 0x18(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) } as u64;
	// 821C9004: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 821C9008: 4E800421  bctrl
	ctx.lr = 0x821C900C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C900C: 3CA0820A  lis r5, -0x7df6
	ctx.r[5].s64 = -2113273856;
	// 821C9010: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821C9014: 809F009C  lwz r4, 0x9c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 821C9018: 807F007C  lwz r3, 0x7c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 821C901C: C0259490  lfs f1, -0x6b70(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821C9020: 48003EB9  bl 0x821cced8
	ctx.lr = 0x821C9024;
	sub_821CCED8(ctx, base);
	// 821C9024: 809F0080  lwz r4, 0x80(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 821C9028: 80640004  lwz r3, 4(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C902C: 4BFAD295  bl 0x821762c0
	ctx.lr = 0x821C9030;
	sub_821762C0(ctx, base);
	// 821C9030: 817F00FC  lwz r11, 0xfc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 821C9034: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821C9038: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 821C903C: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 821C9040: 995F0108  stb r10, 0x108(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[10].u8 ) };
	// 821C9044: 913F00FC  stw r9, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[9].u32 ) };
	// 821C9048: 482835F1  bl 0x8244c638
	ctx.lr = 0x821C904C;
	sub_8244C638(ctx, base);
	// 821C904C: 807F009C  lwz r3, 0x9c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 821C9050: 4BFC1531  bl 0x8218a580
	ctx.lr = 0x821C9054;
	sub_8218A580(ctx, base);
	// 821C9054: 811F00A4  lwz r8, 0xa4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 821C9058: 80680004  lwz r3, 4(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C905C: 4BFBB965  bl 0x821849c0
	ctx.lr = 0x821C9060;
	sub_821849C0(ctx, base);
	// 821C9060: 80FF00A8  lwz r7, 0xa8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 821C9064: 80670004  lwz r3, 4(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C9068: 480B2F29  bl 0x8227bf90
	ctx.lr = 0x821C906C;
	sub_8227BF90(ctx, base);
	// 821C906C: 807EE9EC  lwz r3, -0x1614(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-5652 as u32) ) } as u64;
	// 821C9070: 80C30000  lwz r6, 0(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C9074: 80A6001C  lwz r5, 0x1c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) } as u64;
	// 821C9078: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 821C907C: 4E800421  bctrl
	ctx.lr = 0x821C9080;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C9080: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821C9084: 807F00AC  lwz r3, 0xac(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 821C9088: 4BFCC619  bl 0x821956a0
	ctx.lr = 0x821C908C;
	sub_821956A0(ctx, base);
	// 821C908C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821C9090: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821C9094: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821C9098: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821C909C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821C90A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C90A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C90A8 size=288
    let mut pc: u32 = 0x821C90A8;
    'dispatch: loop {
        match pc {
            0x821C90A8 => {
    //   block [0x821C90A8..0x821C90E8)
	// 821C90A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C90AC: 48AE0359  bl 0x82ca9404
	ctx.lr = 0x821C90B0;
	sub_82CA93D0(ctx, base);
	// 821C90B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C90B4: 3F608336  lis r27, -0x7cca
	ctx.r[27].s64 = -2093613056;
	// 821C90B8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821C90BC: 817BF94C  lwz r11, -0x6b4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-1716 as u32) ) } as u64;
	// 821C90C0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821C90C4: 409A00F4  bne cr6, 0x821c91b8
	if !ctx.cr[6].eq {
	pc = 0x821C91B8; continue 'dispatch;
	}
	// 821C90C8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821C90CC: 3B8B4FF8  addi r28, r11, 0x4ff8
	ctx.r[28].s64 = ctx.r[11].s64 + 20472;
	// 821C90D0: 83FC0004  lwz r31, 4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C90D4: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C90D8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C90DC: 4099000C  ble cr6, 0x821c90e8
	if !ctx.cr[6].gt {
	pc = 0x821C90E8; continue 'dispatch;
	}
	// 821C90E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 821C90E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C90E8; continue 'dispatch;
            }
            0x821C90E8 => {
    //   block [0x821C90E8..0x821C90EC)
	// 821C90E8: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	pc = 0x821C90EC; continue 'dispatch;
            }
            0x821C90EC => {
    //   block [0x821C90EC..0x821C9100)
	// 821C90EC: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821C90F0: 419A0034  beq cr6, 0x821c9124
	if ctx.cr[6].eq {
	pc = 0x821C9124; continue 'dispatch;
	}
	// 821C90F4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C90F8: 41980008  blt cr6, 0x821c9100
	if ctx.cr[6].lt {
	pc = 0x821C9100; continue 'dispatch;
	}
	// 821C90FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C9100; continue 'dispatch;
            }
            0x821C9100 => {
    //   block [0x821C9100..0x821C911C)
	// 821C9100: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821C9104: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C9108: 48966699  bl 0x82b2f7a0
	ctx.lr = 0x821C910C;
	sub_82B2F7A0(ctx, base);
	// 821C910C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C9110: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C9114: 41980008  blt cr6, 0x821c911c
	if ctx.cr[6].lt {
	pc = 0x821C911C; continue 'dispatch;
	}
	// 821C9118: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C911C; continue 'dispatch;
            }
            0x821C911C => {
    //   block [0x821C911C..0x821C9124)
	// 821C911C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 821C9120: 4BFFFFCC  b 0x821c90ec
	pc = 0x821C90EC; continue 'dispatch;
            }
            0x821C9124 => {
    //   block [0x821C9124..0x821C9134)
	// 821C9124: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C9128: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C912C: 40990008  ble cr6, 0x821c9134
	if !ctx.cr[6].gt {
	pc = 0x821C9134; continue 'dispatch;
	}
	// 821C9130: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C9134; continue 'dispatch;
            }
            0x821C9134 => {
    //   block [0x821C9134..0x821C9144)
	// 821C9134: 7D5E5378  mr r30, r10
	ctx.r[30].u64 = ctx.r[10].u64;
	// 821C9138: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C913C: 40990008  ble cr6, 0x821c9144
	if !ctx.cr[6].gt {
	pc = 0x821C9144; continue 'dispatch;
	}
	// 821C9140: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C9144; continue 'dispatch;
            }
            0x821C9144 => {
    //   block [0x821C9144..0x821C9148)
	// 821C9144: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	pc = 0x821C9148; continue 'dispatch;
            }
            0x821C9148 => {
    //   block [0x821C9148..0x821C915C)
	// 821C9148: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 821C914C: 419A0068  beq cr6, 0x821c91b4
	if ctx.cr[6].eq {
	pc = 0x821C91B4; continue 'dispatch;
	}
	// 821C9150: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C9154: 41980008  blt cr6, 0x821c915c
	if ctx.cr[6].lt {
	pc = 0x821C915C; continue 'dispatch;
	}
	// 821C9158: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C915C; continue 'dispatch;
            }
            0x821C915C => {
    //   block [0x821C915C..0x821C918C)
	// 821C915C: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C9160: 815F00DC  lwz r10, 0xdc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 821C9164: 813F00D8  lwz r9, 0xd8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 821C9168: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821C916C: 5507003A  rlwinm r7, r8, 0, 0, 0x1d
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 821C9170: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821C9174: 419A002C  beq cr6, 0x821c91a0
	if ctx.cr[6].eq {
	pc = 0x821C91A0; continue 'dispatch;
	}
	// 821C9178: 807F00E8  lwz r3, 0xe8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 821C917C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821C9180: 419A000C  beq cr6, 0x821c918c
	if ctx.cr[6].eq {
	pc = 0x821C918C; continue 'dispatch;
	}
	// 821C9184: 489707E5  bl 0x82b39968
	ctx.lr = 0x821C9188;
	sub_82B39968(ctx, base);
	// 821C9188: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x821C918C; continue 'dispatch;
            }
            0x821C918C => {
    //   block [0x821C918C..0x821C91A0)
	// 821C918C: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 821C9190: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821C9194: 419A000C  beq cr6, 0x821c91a0
	if ctx.cr[6].eq {
	pc = 0x821C91A0; continue 'dispatch;
	}
	// 821C9198: 489707D1  bl 0x82b39968
	ctx.lr = 0x821C919C;
	sub_82B39968(ctx, base);
	// 821C919C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x821C91A0; continue 'dispatch;
            }
            0x821C91A0 => {
    //   block [0x821C91A0..0x821C91AC)
	// 821C91A0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C91A4: 41980008  blt cr6, 0x821c91ac
	if ctx.cr[6].lt {
	pc = 0x821C91AC; continue 'dispatch;
	}
	// 821C91A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C91AC; continue 'dispatch;
            }
            0x821C91AC => {
    //   block [0x821C91AC..0x821C91B4)
	// 821C91AC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 821C91B0: 4BFFFF98  b 0x821c9148
	pc = 0x821C9148; continue 'dispatch;
            }
            0x821C91B4 => {
    //   block [0x821C91B4..0x821C91B8)
	// 821C91B4: 817BF94C  lwz r11, -0x6b4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-1716 as u32) ) } as u64;
	pc = 0x821C91B8; continue 'dispatch;
            }
            0x821C91B8 => {
    //   block [0x821C91B8..0x821C91C8)
	// 821C91B8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821C91BC: 917BF94C  stw r11, -0x6b4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(-1716 as u32), ctx.r[11].u32 ) };
	// 821C91C0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821C91C4: 48AE0290  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C91C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C91C8 size=56
    let mut pc: u32 = 0x821C91C8;
    'dispatch: loop {
        match pc {
            0x821C91C8 => {
    //   block [0x821C91C8..0x821C91DC)
	// 821C91C8: 81633098  lwz r11, 0x3098(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12440 as u32) ) } as u64;
	// 821C91CC: 90832E54  stw r4, 0x2e54(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(11860 as u32), ctx.r[4].u32 ) };
	// 821C91D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C91D4: 409A0008  bne cr6, 0x821c91dc
	if !ctx.cr[6].eq {
	pc = 0x821C91DC; continue 'dispatch;
	}
	// 821C91D8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x821C91DC; continue 'dispatch;
            }
            0x821C91DC => {
    //   block [0x821C91DC..0x821C9200)
	// 821C91DC: 816328DC  lwz r11, 0x28dc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(10460 as u32) ) } as u64;
	// 821C91E0: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 821C91E4: 51640036  rlwimi r4, r11, 0, 0, 0x1b
	ctx.r[4].u64 = (((ctx.r[11].u32).rotate_left(0) as u64) & 0x00000000FFFFFFF0) | (ctx.r[4].u64 & 0xFFFFFFFF0000000F);
	// 821C91E8: 798C2FE6  rldicr r12, r12, 0x25, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(37) & 0xFFFFFFFFFFFFFFFF;
	// 821C91EC: 908328DC  stw r4, 0x28dc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10460 as u32), ctx.r[4].u32 ) };
	// 821C91F0: E9630010  ld r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	// 821C91F4: 7D6B6378  or r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[12].u64;
	// 821C91F8: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821C91FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C9200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C9200 size=152
    let mut pc: u32 = 0x821C9200;
    'dispatch: loop {
        match pc {
            0x821C9200 => {
    //   block [0x821C9200..0x821C9230)
	// 821C9200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C9204: 48AE0205  bl 0x82ca9408
	ctx.lr = 0x821C9208;
	sub_82CA93D0(ctx, base);
	// 821C9208: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C920C: 548B083C  slwi r11, r4, 1
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C9210: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821C9214: 7D645A14  add r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 821C9218: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 821C921C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821C9220: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 821C9224: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 821C9228: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C922C: 83EA0000  lwz r31, 0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821C9230; continue 'dispatch;
            }
            0x821C9230 => {
    //   block [0x821C9230..0x821C9240)
	// 821C9230: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C9234: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821C9238: 419A0008  beq cr6, 0x821c9240
	if ctx.cr[6].eq {
	pc = 0x821C9240; continue 'dispatch;
	}
	// 821C923C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C9240; continue 'dispatch;
            }
            0x821C9240 => {
    //   block [0x821C9240..0x821C9258)
	// 821C9240: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C9244: 419A004C  beq cr6, 0x821c9290
	if ctx.cr[6].eq {
	pc = 0x821C9290; continue 'dispatch;
	}
	// 821C9248: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C924C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C9250: 409A0008  bne cr6, 0x821c9258
	if !ctx.cr[6].eq {
	pc = 0x821C9258; continue 'dispatch;
	}
	// 821C9254: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C9258; continue 'dispatch;
            }
            0x821C9258 => {
    //   block [0x821C9258..0x821C9288)
	// 821C9258: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821C925C: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 821C9260: 7F0AE000  cmpw cr6, r10, r28
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[28].s32, &mut ctx.xer);
	// 821C9264: 4099002C  ble cr6, 0x821c9290
	if !ctx.cr[6].gt {
	pc = 0x821C9290; continue 'dispatch;
	}
	// 821C9268: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821C926C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821C9270: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821C9274: 489804DD  bl 0x82b49750
	ctx.lr = 0x821C9278;
	sub_82B49750(ctx, base);
	// 821C9278: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C927C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821C9280: 409A0008  bne cr6, 0x821c9288
	if !ctx.cr[6].eq {
	pc = 0x821C9288; continue 'dispatch;
	}
	// 821C9284: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821C9288; continue 'dispatch;
            }
            0x821C9288 => {
    //   block [0x821C9288..0x821C9290)
	// 821C9288: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C928C: 4BFFFFA4  b 0x821c9230
	pc = 0x821C9230; continue 'dispatch;
            }
            0x821C9290 => {
    //   block [0x821C9290..0x821C9298)
	// 821C9290: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821C9294: 48AE01C4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C9298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C9298 size=360
    let mut pc: u32 = 0x821C9298;
    'dispatch: loop {
        match pc {
            0x821C9298 => {
    //   block [0x821C9298..0x821C93F4)
	// 821C9298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C929C: 48AE016D  bl 0x82ca9408
	ctx.lr = 0x821C92A0;
	sub_82CA93D0(ctx, base);
	// 821C92A0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C92A4: 3FA08336  lis r29, -0x7cca
	ctx.r[29].s64 = -2093613056;
	// 821C92A8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821C92AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821C92B0: 817DF028  lwz r11, -0xfd8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-4056 as u32) ) } as u64;
	// 821C92B4: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 821C92B8: 4098013C  bge cr6, 0x821c93f4
	if !ctx.cr[6].lt {
	pc = 0x821C93F4; continue 'dispatch;
	}
	// 821C92BC: 809E007C  lwz r4, 0x7c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 821C92C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821C92C4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C92C8: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821C92CC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821C92D0: 4E800421  bctrl
	ctx.lr = 0x821C92D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C92D4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821C92D8: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 821C92DC: 809E007C  lwz r4, 0x7c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 821C92E0: 3BEBCB94  addi r31, r11, -0x346c
	ctx.r[31].s64 = ctx.r[11].s64 + -13420;
	// 821C92E4: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 821C92E8: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 821C92EC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821C92F0: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821C92F4: C01FC8F0  lfs f0, -0x3710(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-14096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C92F8: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
            }
            0x821C93F4 => {
    //   block [0x821C93F4..0x821C9400)
	// 821C93F4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821C93F8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821C93FC: 48AE005C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C9400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821C9400 size=384
    let mut pc: u32 = 0x821C9400;
    'dispatch: loop {
        match pc {
            0x821C9400 => {
    //   block [0x821C9400..0x821C9448)
	// 821C9400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C9404: 48AE0009  bl 0x82ca940c
	ctx.lr = 0x821C9408;
	sub_82CA93D0(ctx, base);
	// 821C9408: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C940C: 3D608331  lis r11, -0x7ccf
	ctx.r[11].s64 = -2093940736;
	// 821C9410: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821C9414: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821C9418: 892B5E6F  lbz r9, 0x5e6f(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24175 as u32) ) } as u64;
	// 821C941C: C00A9490  lfs f0, -0x6b70(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821C9420: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821C9424: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821C9428: 419A0020  beq cr6, 0x821c9448
	if ctx.cr[6].eq {
	pc = 0x821C9448; continue 'dispatch;
	}
	// 821C942C: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 821C9430: 39400060  li r10, 0x60
	ctx.r[10].s64 = 96;
	// 821C9434: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	pc = 0x821C9448; continue 'dispatch;
            }
            0x821C9448 => {
    //   block [0x821C9448..0x821C9580)
	// 821C9448: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821C944C: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821C9450: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 821C9454: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 821C9458: 798CEFE6  rldicr r12, r12, 0x3d, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(61) & 0xFFFFFFFFFFFFFFFF;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C9580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C9580 size=196
    let mut pc: u32 = 0x821C9580;
    'dispatch: loop {
        match pc {
            0x821C9580 => {
    //   block [0x821C9580..0x821C9644)
	// 821C9580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C9584: 48ADFE81  bl 0x82ca9404
	ctx.lr = 0x821C9588;
	sub_82CA93D0(ctx, base);
	// 821C9588: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C958C: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 821C9590: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821C9594: 4805EB65  bl 0x822280f8
	ctx.lr = 0x821C9598;
	sub_822280F8(ctx, base);
	// 821C9598: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821C959C: 39210051  addi r9, r1, 0x51
	ctx.r[9].s64 = ctx.r[1].s64 + 81;
	// 821C95A0: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 821C95A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821C95A8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821C95AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821C95B0: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 821C95B4: 99690000  stb r11, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 821C95B8: 83C80004  lwz r30, 4(r8)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821C95BC: 83A80000  lwz r29, 0(r8)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C95C0: 4805EB39  bl 0x822280f8
	ctx.lr = 0x821C95C4;
	sub_822280F8(ctx, base);
	// 821C95C4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C95C8: 4805DF99  bl 0x82227560
	ctx.lr = 0x821C95CC;
	sub_82227560(ctx, base);
	// 821C95CC: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 821C95D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821C95D4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821C95D8: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821C95DC: 481388BD  bl 0x82301e98
	ctx.lr = 0x821C95E0;
	sub_82301E98(ctx, base);
	// 821C95E0: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 821C95E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821C95E8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821C95EC: 88610051  lbz r3, 0x51(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 821C95F0: 481388A9  bl 0x82301e98
	ctx.lr = 0x821C95F4;
	sub_82301E98(ctx, base);
	// 821C95F4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821C95F8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821C95FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821C9600: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 821C9604: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 821C9608: 4E800421  bctrl
	ctx.lr = 0x821C960C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821C960C: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C9610: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C9614: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821C9618: 7CE40034  cntlzw r4, r7
	ctx.r[4].u64 = if ctx.r[7].u32 == 0 { 32 } else { ctx.r[7].u32.leading_zeros() as u64 };
	// 821C961C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821C9620: 548BDFFE  rlwinm r11, r4, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x0000001Fu64;
	// 821C9624: 696A0001  xori r10, r11, 1
	ctx.r[10].u64 = ctx.r[11].u64 ^ 1;
	// 821C9628: 90A60004  stw r5, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 821C962C: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821C9630: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821C9634: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 821C9638: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 821C963C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821C9640: 48ADFE14  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C9648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C9648 size=12
    let mut pc: u32 = 0x821C9648;
    'dispatch: loop {
        match pc {
            0x821C9648 => {
    //   block [0x821C9648..0x821C9654)
	// 821C9648: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821C964C: 806B006C  lwz r3, 0x6c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 821C9650: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C9658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C9658 size=2052
    let mut pc: u32 = 0x821C9658;
    'dispatch: loop {
        match pc {
            0x821C9658 => {
    //   block [0x821C9658..0x821C9E5C)
	// 821C9658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C965C: 48ADFD99  bl 0x82ca93f4
	ctx.lr = 0x821C9660;
	sub_82CA93D0(ctx, base);
	// 821C9660: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 821C9664: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C9E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821C9E88 size=192
    let mut pc: u32 = 0x821C9E88;
    'dispatch: loop {
        match pc {
            0x821C9E88 => {
    //   block [0x821C9E88..0x821C9EB0)
	// 821C9E88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C9E8C: 48ADF57D  bl 0x82ca9408
	ctx.lr = 0x821C9E90;
	sub_82CA93D0(ctx, base);
	// 821C9E90: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821C9E94: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821C9E98: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821C9E9C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821C9EA0: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821C9EA4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821C9EA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C9EAC: 419A0094  beq cr6, 0x821c9f40
	if ctx.cr[6].eq {
	pc = 0x821C9F40; continue 'dispatch;
	}
	pc = 0x821C9EB0; continue 'dispatch;
            }
            0x821C9EB0 => {
    //   block [0x821C9EB0..0x821C9F00)
	// 821C9EB0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821C9EB4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821C9EB8: 80DD0000  lwz r6, 0(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C9EBC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821C9EC0: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 821C9EC4: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 821C9EC8: 4801BAA9  bl 0x821e5970
	ctx.lr = 0x821C9ECC;
	sub_821E5970(ctx, base);
	// 821C9ECC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821C9ED0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821C9ED4: 419A004C  beq cr6, 0x821c9f20
	if ctx.cr[6].eq {
	pc = 0x821C9F20; continue 'dispatch;
	}
	// 821C9ED8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821C9EDC: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 821C9EE0: 81260000  lwz r9, 0(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C9EE4: 39460004  addi r10, r6, 4
	ctx.r[10].s64 = ctx.r[6].s64 + 4;
	// 821C9EE8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821C9EEC: 5529C23E  srwi r9, r9, 8
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shr(8);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821C9EF0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821C9EF4: 4098002C  bge cr6, 0x821c9f20
	if !ctx.cr[6].lt {
	pc = 0x821C9F20; continue 'dispatch;
	}
	// 821C9EF8: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821C9EFC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	pc = 0x821C9F00; continue 'dispatch;
            }
            0x821C9F00 => {
    //   block [0x821C9F00..0x821C9F20)
	// 821C9F00: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821C9F04: 7F08F040  cmplw cr6, r8, r30
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821C9F08: 409A0018  bne cr6, 0x821c9f20
	if !ctx.cr[6].eq {
	pc = 0x821C9F20; continue 'dispatch;
	}
	// 821C9F0C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821C9F10: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821C9F14: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821C9F18: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821C9F1C: 4198FFE4  blt cr6, 0x821c9f00
	if ctx.cr[6].lt {
	pc = 0x821C9F00; continue 'dispatch;
	}
	pc = 0x821C9F20; continue 'dispatch;
            }
            0x821C9F20 => {
    //   block [0x821C9F20..0x821C9F3C)
	// 821C9F20: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821C9F24: 409A0018  bne cr6, 0x821c9f3c
	if !ctx.cr[6].eq {
	pc = 0x821C9F3C; continue 'dispatch;
	}
	// 821C9F28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821C9F2C: 4801B9AD  bl 0x821e58d8
	ctx.lr = 0x821C9F30;
	sub_821E58D8(ctx, base);
	// 821C9F30: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821C9F34: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821C9F38: 409AFF78  bne cr6, 0x821c9eb0
	if !ctx.cr[6].eq {
	pc = 0x821C9EB0; continue 'dispatch;
	}
	pc = 0x821C9F3C; continue 'dispatch;
            }
            0x821C9F3C => {
    //   block [0x821C9F3C..0x821C9F40)
	// 821C9F3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x821C9F40; continue 'dispatch;
            }
            0x821C9F40 => {
    //   block [0x821C9F40..0x821C9F48)
	// 821C9F40: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821C9F44: 48ADF514  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821C9F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821C9F48 size=228
    let mut pc: u32 = 0x821C9F48;
    'dispatch: loop {
        match pc {
            0x821C9F48 => {
    //   block [0x821C9F48..0x821CA02C)
	// 821C9F48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821C9F4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821C9F50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821C9F54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821C9F58: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CA030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CA030 size=212
    let mut pc: u32 = 0x821CA030;
    'dispatch: loop {
        match pc {
            0x821CA030 => {
    //   block [0x821CA030..0x821CA104)
	// 821CA030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CA034: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821CA038: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CA03C: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 821CA040: 39800080  li r12, 0x80
	ctx.r[12].s64 = 128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CA108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CA108 size=1248
    let mut pc: u32 = 0x821CA108;
    'dispatch: loop {
        match pc {
            0x821CA108 => {
    //   block [0x821CA108..0x821CA130)
	// 821CA108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CA10C: 48ADF2D5  bl 0x82ca93e0
	ctx.lr = 0x821CA110;
	sub_82CA93D0(ctx, base);
	// 821CA110: DBE1FF80  stfd f31, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 821CA114: 9421FE30  stwu r1, -0x1d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-464 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CA118: 7CB22B78  mr r18, r5
	ctx.r[18].u64 = ctx.r[5].u64;
	// 821CA11C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821CA120: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 821CA124: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 821CA128: 2B120000  cmplwi cr6, r18, 0
	ctx.cr[6].compare_u32(ctx.r[18].u32, 0 as u32, &mut ctx.xer);
	// 821CA12C: 409A0014  bne cr6, 0x821ca140
	if !ctx.cr[6].eq {
	pc = 0x821CA140; continue 'dispatch;
	}
	pc = 0x821CA130; continue 'dispatch;
            }
            0x821CA130 => {
    //   block [0x821CA130..0x821CA140)
	// 821CA130: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821CA134: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 821CA138: CBE1FF80  lfd f31, -0x80(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 821CA13C: 48ADF2F4  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            0x821CA140 => {
    //   block [0x821CA140..0x821CA18C)
	// 821CA140: 817500B0  lwz r11, 0xb0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(176 as u32) ) } as u64;
	// 821CA144: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CA148: 4099FFE8  ble cr6, 0x821ca130
	if !ctx.cr[6].gt {
	pc = 0x821CA130; continue 'dispatch;
	}
	// 821CA14C: 3FC08336  lis r30, -0x7cca
	ctx.r[30].s64 = -2093613056;
	// 821CA150: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821CA154: 3CC08349  lis r6, -0x7cb7
	ctx.r[6].s64 = -2092367872;
	// 821CA158: 3A800008  li r20, 8
	ctx.r[20].s64 = 8;
	// 821CA15C: 393F06B0  addi r9, r31, 0x6b0
	ctx.r[9].s64 = ctx.r[31].s64 + 1712;
	// 821CA160: 817E0364  lwz r11, 0x364(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(868 as u32) ) } as u64;
	// 821CA164: 39010110  addi r8, r1, 0x110
	ctx.r[8].s64 = ctx.r[1].s64 + 272;
	// 821CA168: 814A10AC  lwz r10, 0x10ac(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4268 as u32) ) } as u64;
	// 821CA16C: 7E87A378  mr r7, r20
	ctx.r[7].u64 = ctx.r[20].u64;
	// 821CA170: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 821CA174: 914B2E2C  stw r10, 0x2e2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(11820 as u32), ctx.r[10].u32 ) };
	// 821CA178: E8850010  ld r4, 0x10(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) };
	// 821CA17C: 64830008  oris r3, r4, 8
	ctx.r[3].u64 = ctx.r[4].u64 | 524288;
	// 821CA180: 914670B8  stw r10, 0x70b8(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(28856 as u32), ctx.r[10].u32 ) };
	// 821CA184: F8650010  std r3, 0x10(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(16 as u32), ctx.r[3].u64 ) };
	// 821CA188: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	pc = 0x821CA18C; continue 'dispatch;
            }
            0x821CA18C => {
    //   block [0x821CA18C..0x821CA1D8)
	// 821CA18C: E9690000  ld r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 821CA190: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 821CA194: F9680000  std r11, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821CA198: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 821CA19C: 4200FFF0  bdnz 0x821ca18c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821CA18C; continue 'dispatch;
	}
	// 821CA1A0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CA1A4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821CA1A8: 388B0150  addi r4, r11, 0x150
	ctx.r[4].s64 = ctx.r[11].s64 + 336;
	// 821CA1AC: 480A6B25  bl 0x82270cd0
	ctx.lr = 0x821CA1B0;
	sub_82270CD0(ctx, base);
	// 821CA1B0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821CA1B4: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 821CA1B8: 480A6B19  bl 0x82270cd0
	ctx.lr = 0x821CA1BC;
	sub_82270CD0(ctx, base);
	// 821CA1BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821CA1C0: 38600162  li r3, 0x162
	ctx.r[3].s64 = 354;
	// 821CA1C4: 4BFFDF4D  bl 0x821c8110
	ctx.lr = 0x821CA1C8;
	sub_821C8110(ctx, base);
	// 821CA1C8: 394100D0  addi r10, r1, 0xd0
	ctx.r[10].s64 = ctx.r[1].s64 + 208;
	// 821CA1CC: 39610110  addi r11, r1, 0x110
	ctx.r[11].s64 = ctx.r[1].s64 + 272;
	// 821CA1D0: 7E89A378  mr r9, r20
	ctx.r[9].u64 = ctx.r[20].u64;
	// 821CA1D4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x821CA1D8; continue 'dispatch;
            }
            0x821CA1D8 => {
    //   block [0x821CA1D8..0x821CA21C)
	// 821CA1D8: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821CA1DC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821CA1E0: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821CA1E4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821CA1E8: 4200FFF0  bdnz 0x821ca1d8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821CA1D8; continue 'dispatch;
	}
	// 821CA1EC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821CA1F0: E96B1760  ld r11, 0x1760(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(5984 as u32) ) };
	// 821CA1F4: 796A0004  rldicr r10, r11, 0, 0
	ctx.r[10].u64 = (ctx.r[11].u64).rotate_left(0) & 0x8000000000000000;
	// 821CA1F8: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 821CA1FC: 419A0020  beq cr6, 0x821ca21c
	if ctx.cr[6].eq {
	pc = 0x821CA21C; continue 'dispatch;
	}
	// 821CA200: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821CA204: 807E0364  lwz r3, 0x364(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(868 as u32) ) } as u64;
	// 821CA208: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 821CA20C: 78E7FFE6  rldicr r7, r7, 0x3f, 0x3f
	ctx.r[7].u64 = (ctx.r[7].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821CA210: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 821CA214: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821CA218: 48050669  bl 0x8221a880
	ctx.lr = 0x821CA21C;
	sub_8221A880(ctx, base);
	pc = 0x821CA21C; continue 'dispatch;
            }
            0x821CA21C => {
    //   block [0x821CA21C..0x821CA5E8)
	// 821CA21C: 39600690  li r11, 0x690
	ctx.r[11].s64 = 1680;
	// 821CA220: 38600126  li r3, 0x126
	ctx.r[3].s64 = 294;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CA5E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CA5E8 size=420
    let mut pc: u32 = 0x821CA5E8;
    'dispatch: loop {
        match pc {
            0x821CA5E8 => {
    //   block [0x821CA5E8..0x821CA700)
	// 821CA5E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CA5EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821CA5F0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CA5F4: 816306FC  lwz r11, 0x6fc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1788 as u32) ) } as u64;
	// 821CA5F8: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 821CA5FC: 419A0180  beq cr6, 0x821ca77c
	if ctx.cr[6].eq {
	pc = 0x821CA77C; continue 'dispatch;
	}
	// 821CA600: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821CA604: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821CA608: 3CE08332  lis r7, -0x7cce
	ctx.r[7].s64 = -2093875200;
	// 821CA60C: 3CC08332  lis r6, -0x7cce
	ctx.r[6].s64 = -2093875200;
	// 821CA610: 3CA08332  lis r5, -0x7cce
	ctx.r[5].s64 = -2093875200;
	// 821CA614: 896B6E61  lbz r11, 0x6e61(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28257 as u32) ) } as u64;
	// 821CA618: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 821CA61C: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 821CA620: 99471626  stb r10, 0x1626(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(5670 as u32), ctx.r[10].u8 ) };
	// 821CA624: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CA628: 99261627  stb r9, 0x1627(r6)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[6].u32.wrapping_add(5671 as u32), ctx.r[9].u8 ) };
	// 821CA62C: 99051628  stb r8, 0x1628(r5)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[5].u32.wrapping_add(5672 as u32), ctx.r[8].u8 ) };
	// 821CA630: 409A014C  bne cr6, 0x821ca77c
	if !ctx.cr[6].eq {
	pc = 0x821CA77C; continue 'dispatch;
	}
	// 821CA634: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821CA638: 894B6E60  lbz r10, 0x6e60(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28256 as u32) ) } as u64;
	// 821CA63C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CA640: 419A013C  beq cr6, 0x821ca77c
	if ctx.cr[6].eq {
	pc = 0x821CA77C; continue 'dispatch;
	}
	// 821CA644: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821CA648: 99010050  stb r8, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u8 ) };
	// 821CA64C: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821CA650: 396B2390  addi r11, r11, 0x2390
	ctx.r[11].s64 = ctx.r[11].s64 + 9104;
	// 821CA654: 38EA7E70  addi r7, r10, 0x7e70
	ctx.r[7].s64 = ctx.r[10].s64 + 32368;
	// 821CA658: 38CB2008  addi r6, r11, 0x2008
	ctx.r[6].s64 = ctx.r[11].s64 + 8200;
	// 821CA65C: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821CA660: 55451838  slwi r5, r10, 3
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821CA664: 7CE5592E  stwx r7, r5, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 821CA668: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821CA66C: 810B2000  lwz r8, 0x2000(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821CA670: 814B400C  lwz r10, 0x400c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821CA674: 55451838  slwi r5, r10, 3
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821CA678: 39490001  addi r10, r9, 1
	ctx.r[10].s64 = ctx.r[9].s64 + 1;
	// 821CA67C: 5509083C  slwi r9, r8, 1
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821CA680: 914B2004  stw r10, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[10].u32 ) };
	// 821CA684: 912B2000  stw r9, 0x2000(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8192 as u32), ctx.r[9].u32 ) };
	// 821CA688: 7CE5312E  stwx r7, r5, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[6].u32), ctx.r[7].u32) };
	// 821CA68C: 814B400C  lwz r10, 0x400c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821CA690: 812B4008  lwz r9, 0x4008(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16392 as u32) ) } as u64;
	// 821CA694: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821CA698: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821CA69C: 912B4008  stw r9, 0x4008(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16392 as u32), ctx.r[9].u32 ) };
	// 821CA6A0: 914B400C  stw r10, 0x400c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16396 as u32), ctx.r[10].u32 ) };
	// 821CA6A4: 80C4001C  lwz r6, 0x1c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 821CA6A8: 2F06FFFF  cmpwi cr6, r6, -1
	ctx.cr[6].compare_i32(ctx.r[6].s32, -1, &mut ctx.xer);
	// 821CA6AC: 419A00C8  beq cr6, 0x821ca774
	if ctx.cr[6].eq {
	pc = 0x821CA774; continue 'dispatch;
	}
	// 821CA6B0: 80840004  lwz r4, 4(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CA6B4: 816400F0  lwz r11, 0xf0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(240 as u32) ) } as u64;
	// 821CA6B8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821CA6BC: 419A0084  beq cr6, 0x821ca740
	if ctx.cr[6].eq {
	pc = 0x821CA740; continue 'dispatch;
	}
	// 821CA6C0: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821CA6C4: 419A0044  beq cr6, 0x821ca708
	if ctx.cr[6].eq {
	pc = 0x821CA708; continue 'dispatch;
	}
	// 821CA6C8: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821CA6CC: 409A00A8  bne cr6, 0x821ca774
	if !ctx.cr[6].eq {
	pc = 0x821CA774; continue 'dispatch;
	}
	// 821CA6D0: 816400B4  lwz r11, 0xb4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(180 as u32) ) } as u64;
	// 821CA6D4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CA6D8: 8145002C  lwz r10, 0x2c(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(44 as u32) ) } as u64;
	// 821CA6DC: 892A0028  lbz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 821CA6E0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821CA6E4: 419A001C  beq cr6, 0x821ca700
	if ctx.cr[6].eq {
	pc = 0x821CA700; continue 'dispatch;
	}
	// 821CA6E8: 48890131  bl 0x82a5a818
	ctx.lr = 0x821CA6EC;
	sub_82A5A818(ctx, base);
	// 821CA6EC: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821CA6F0: 816A6E5C  lwz r11, 0x6e5c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28252 as u32) ) } as u64;
	// 821CA6F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821CA6F8: 916A6E5C  stw r11, 0x6e5c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28252 as u32), ctx.r[11].u32 ) };
	// 821CA6FC: 48000078  b 0x821ca774
	pc = 0x821CA774; continue 'dispatch;
            }
            0x821CA700 => {
    //   block [0x821CA700..0x821CA708)
	// 821CA700: 4888F6D1  bl 0x82a59dd0
	ctx.lr = 0x821CA704;
	sub_82A59DD0(ctx, base);
	// 821CA704: 48000070  b 0x821ca774
	pc = 0x821CA774; continue 'dispatch;
            }
            0x821CA708 => {
    //   block [0x821CA708..0x821CA738)
	// 821CA708: 816400B4  lwz r11, 0xb4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(180 as u32) ) } as u64;
	// 821CA70C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CA710: 81450040  lwz r10, 0x40(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(64 as u32) ) } as u64;
	// 821CA714: 892A0034  lbz r9, 0x34(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) } as u64;
	// 821CA718: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821CA71C: 419A001C  beq cr6, 0x821ca738
	if ctx.cr[6].eq {
	pc = 0x821CA738; continue 'dispatch;
	}
	// 821CA720: 4888F091  bl 0x82a597b0
	ctx.lr = 0x821CA724;
	sub_82A597B0(ctx, base);
	// 821CA724: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821CA728: 816A6E5C  lwz r11, 0x6e5c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28252 as u32) ) } as u64;
	// 821CA72C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821CA730: 916A6E5C  stw r11, 0x6e5c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28252 as u32), ctx.r[11].u32 ) };
	// 821CA734: 48000040  b 0x821ca774
	pc = 0x821CA774; continue 'dispatch;
            }
            0x821CA738 => {
    //   block [0x821CA738..0x821CA740)
	// 821CA738: 4BFE7EC1  bl 0x821b25f8
	ctx.lr = 0x821CA73C;
	sub_821B25F8(ctx, base);
	// 821CA73C: 48000038  b 0x821ca774
	pc = 0x821CA774; continue 'dispatch;
            }
            0x821CA740 => {
    //   block [0x821CA740..0x821CA770)
	// 821CA740: 816400B4  lwz r11, 0xb4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(180 as u32) ) } as u64;
	// 821CA744: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CA748: 81450030  lwz r10, 0x30(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(48 as u32) ) } as u64;
	// 821CA74C: 892A0034  lbz r9, 0x34(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) } as u64;
	// 821CA750: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821CA754: 419A001C  beq cr6, 0x821ca770
	if ctx.cr[6].eq {
	pc = 0x821CA770; continue 'dispatch;
	}
	// 821CA758: 4888EEC9  bl 0x82a59620
	ctx.lr = 0x821CA75C;
	sub_82A59620(ctx, base);
	// 821CA75C: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821CA760: 816A6E5C  lwz r11, 0x6e5c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28252 as u32) ) } as u64;
	// 821CA764: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821CA768: 916A6E5C  stw r11, 0x6e5c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28252 as u32), ctx.r[11].u32 ) };
	// 821CA76C: 48000008  b 0x821ca774
	pc = 0x821CA774; continue 'dispatch;
            }
            0x821CA770 => {
    //   block [0x821CA770..0x821CA774)
	// 821CA770: 48000021  bl 0x821ca790
	ctx.lr = 0x821CA774;
	sub_821CA790(ctx, base);
	pc = 0x821CA774; continue 'dispatch;
            }
            0x821CA774 => {
    //   block [0x821CA774..0x821CA77C)
	// 821CA774: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821CA778: 48054B69  bl 0x8221f2e0
	ctx.lr = 0x821CA77C;
	sub_8221F2E0(ctx, base);
	pc = 0x821CA77C; continue 'dispatch;
            }
            0x821CA77C => {
    //   block [0x821CA77C..0x821CA78C)
	// 821CA77C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821CA780: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821CA784: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821CA788: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CA790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821CA790 size=2504
    let mut pc: u32 = 0x821CA790;
    'dispatch: loop {
        match pc {
            0x821CA790 => {
    //   block [0x821CA790..0x821CA7D8)
	// 821CA790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CA794: 48ADEC61  bl 0x82ca93f4
	ctx.lr = 0x821CA798;
	sub_82CA93D0(ctx, base);
	// 821CA798: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CA79C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821CA7A0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821CA7A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821CA7A8: 3B8B9490  addi r28, r11, -0x6b70
	ctx.r[28].s64 = ctx.r[11].s64 + -27504;
	// 821CA7AC: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 821CA7B0: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821CA7B4: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 821CA7B8: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 821CA7BC: 3B6B0024  addi r27, r11, 0x24
	ctx.r[27].s64 = ctx.r[11].s64 + 36;
	// 821CA7C0: C01CFFF4  lfs f0, -0xc(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821CA7C4: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 821CA7C8: C1AB0030  lfs f13, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821CA7CC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821CA7D0: 41990008  bgt cr6, 0x821ca7d8
	if ctx.cr[6].gt {
	pc = 0x821CA7D8; continue 'dispatch;
	}
	// 821CA7D4: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	pc = 0x821CA7D8; continue 'dispatch;
            }
            0x821CA7D8 => {
    //   block [0x821CA7D8..0x821CB158)
	// 821CA7D8: 1001038C  vspltisw v0, 1
	for i in 0..4 {
		ctx.v[0].u32[i] = 1;
	}
	// 821CA7DC: 394100F0  addi r10, r1, 0xf0
	ctx.r[10].s64 = ctx.r[1].s64 + 240;
	// 821CA7E0: 11A0038C  vspltisw v13, 0
	for i in 0..4 {
		ctx.v[13].u32[i] = 0;
	}
	// 821CA7E4: 39210100  addi r9, r1, 0x100
	ctx.r[9].s64 = ctx.r[1].s64 + 256;
	// 821CA7E8: 39010110  addi r8, r1, 0x110
	ctx.r[8].s64 = ctx.r[1].s64 + 272;
	// 821CA7EC: 93010120  stw r24, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[24].u32 ) };
	// 821CA7F0: 9B010124  stb r24, 0x124(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), ctx.r[24].u8 ) };
	// 821CA7F4: 388B0050  addi r4, r11, 0x50
	ctx.r[4].s64 = ctx.r[11].s64 + 80;
	// 821CA7F8: 1180030A  vcfux v12, v0, 0
	// vcfux/vcuxwfp128: ctx.v[12].f32[i] = ( ctx.v[0].u32[i] as f32 ) * (2.0f32).powi(0);
	for i in 0..4 { ctx.v[12].f32[i] = (ctx.v[0].u32[i] as f32) * (2.0f32).powi(0); }
	// 821CA7FC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CB158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CB158 size=72
    let mut pc: u32 = 0x821CB158;
    'dispatch: loop {
        match pc {
            0x821CB158 => {
    //   block [0x821CB158..0x821CB1A0)
	// 821CB158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CB15C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821CB160: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CB164: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821CB168: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 821CB16C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821CB170: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821CB174: 38E90F94  addi r7, r9, 0xf94
	ctx.r[7].s64 = ctx.r[9].s64 + 3988;
	// 821CB178: 99010054  stb r8, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u8 ) };
	// 821CB17C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821CB180: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CB1A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CB1A0 size=652
    let mut pc: u32 = 0x821CB1A0;
    'dispatch: loop {
        match pc {
            0x821CB1A0 => {
    //   block [0x821CB1A0..0x821CB1D4)
	// 821CB1A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CB1A4: 48ADE25D  bl 0x82ca9400
	ctx.lr = 0x821CB1A8;
	sub_82CA93D0(ctx, base);
	// 821CB1A8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CB1AC: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CB1B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821CB1B4: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CB1B8: 81260004  lwz r9, 4(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB1BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CB1C0: F88100B8  std r4, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[4].u64 ) };
	// 821CB1C4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821CB1C8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821CB1CC: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821CB1D0: 419A0020  beq cr6, 0x821cb1f0
	if ctx.cr[6].eq {
	pc = 0x821CB1F0; continue 'dispatch;
	}
	pc = 0x821CB1D4; continue 'dispatch;
            }
            0x821CB1D4 => {
    //   block [0x821CB1D4..0x821CB1F0)
	// 821CB1D4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821CB1D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CB1DC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821CB1E0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821CB1E4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821CB1E8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CB1EC: 4082FFE8  bne 0x821cb1d4
	if !ctx.cr[0].eq {
	pc = 0x821CB1D4; continue 'dispatch;
	}
	pc = 0x821CB1F0; continue 'dispatch;
            }
            0x821CB1F0 => {
    //   block [0x821CB1F0..0x821CB208)
	// 821CB1F0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB1F4: 3B60000C  li r27, 0xc
	ctx.r[27].s64 = 12;
	// 821CB1F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CB1FC: 409A000C  bne cr6, 0x821cb208
	if !ctx.cr[6].eq {
	pc = 0x821CB208; continue 'dispatch;
	}
	// 821CB200: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821CB204: 48000010  b 0x821cb214
	pc = 0x821CB214; continue 'dispatch;
            }
            0x821CB208 => {
    //   block [0x821CB208..0x821CB214)
	// 821CB208: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CB20C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821CB210: 7D29DBD6  divw r9, r9, r27
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	pc = 0x821CB214; continue 'dispatch;
            }
            0x821CB214 => {
    //   block [0x821CB214..0x821CB248)
	// 821CB214: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CB218: 3D401555  lis r10, 0x1555
	ctx.r[10].s64 = 357892096;
	// 821CB21C: 7D0B2850  subf r8, r11, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 821CB220: 614A5555  ori r10, r10, 0x5555
	ctx.r[10].u64 = ctx.r[10].u64 | 21845;
	// 821CB224: 7D68DBD6  divw r11, r8, r27
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[27].s32;
	// 821CB228: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821CB22C: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 821CB230: 40980018  bge cr6, 0x821cb248
	if !ctx.cr[6].lt {
	pc = 0x821CB248; continue 'dispatch;
	}
	// 821CB234: 4887C295  bl 0x82a474c8
	ctx.lr = 0x821CB238;
	sub_82A474C8(ctx, base);
	// 821CB238: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821CB23C: 4BFEC8DD  bl 0x821b7b18
	ctx.lr = 0x821CB240;
	sub_821B7B18(ctx, base);
	// 821CB240: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821CB244: 48ADE20C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x821CB248 => {
    //   block [0x821CB248..0x821CB26C)
	// 821CB248: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 821CB24C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821CB250: 409800F8  bge cr6, 0x821cb348
	if !ctx.cr[6].lt {
	pc = 0x821CB348; continue 'dispatch;
	}
	// 821CB254: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821CB258: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821CB25C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821CB260: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821CB264: 41980008  blt cr6, 0x821cb26c
	if ctx.cr[6].lt {
	pc = 0x821CB26C; continue 'dispatch;
	}
	// 821CB268: 7FAB4A14  add r29, r11, r9
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x821CB26C; continue 'dispatch;
            }
            0x821CB26C => {
    //   block [0x821CB26C..0x821CB278)
	// 821CB26C: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821CB270: 40980008  bge cr6, 0x821cb278
	if !ctx.cr[6].lt {
	pc = 0x821CB278; continue 'dispatch;
	}
	// 821CB274: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	pc = 0x821CB278; continue 'dispatch;
            }
            0x821CB278 => {
    //   block [0x821CB278..0x821CB2F0)
	// 821CB278: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821CB27C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CB280: 48158131  bl 0x823233b0
	ctx.lr = 0x821CB284;
	sub_823233B0(ctx, base);
	// 821CB284: 838100BC  lwz r28, 0xbc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 821CB288: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821CB28C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB290: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821CB294: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 821CB298: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CB29C: 486E20A5  bl 0x828ad340
	ctx.lr = 0x821CB2A0;
	sub_828AD340(ctx, base);
	// 821CB2A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821CB2A4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821CB2A8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821CB2AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CB2B0: 483EEE81  bl 0x825ba130
	ctx.lr = 0x821CB2B4;
	sub_825BA130(ctx, base);
	// 821CB2B4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 821CB2B8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821CB2BC: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CB2C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CB2C4: 486E207D  bl 0x828ad340
	ctx.lr = 0x821CB2C8;
	sub_828AD340(ctx, base);
	// 821CB2C8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB2CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CB2D0: 839F0008  lwz r28, 8(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CB2D4: 7D4BE050  subf r10, r11, r28
	ctx.r[10].s64 = ctx.r[28].s64 - ctx.r[11].s64;
	// 821CB2D8: 7D4ADBD6  divw r10, r10, r27
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[27].s32;
	// 821CB2DC: 3B4A0001  addi r26, r10, 1
	ctx.r[26].s64 = ctx.r[10].s64 + 1;
	// 821CB2E0: 419A002C  beq cr6, 0x821cb30c
	if ctx.cr[6].eq {
	pc = 0x821CB30C; continue 'dispatch;
	}
	// 821CB2E4: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 821CB2E8: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821CB2EC: 419A0018  beq cr6, 0x821cb304
	if ctx.cr[6].eq {
	pc = 0x821CB304; continue 'dispatch;
	}
	pc = 0x821CB2F0; continue 'dispatch;
            }
            0x821CB2F0 => {
    //   block [0x821CB2F0..0x821CB304)
	// 821CB2F0: 387B0004  addi r3, r27, 4
	ctx.r[3].s64 = ctx.r[27].s64 + 4;
	// 821CB2F4: 4BFEC825  bl 0x821b7b18
	ctx.lr = 0x821CB2F8;
	sub_821B7B18(ctx, base);
	// 821CB2F8: 3B7B000C  addi r27, r27, 0xc
	ctx.r[27].s64 = ctx.r[27].s64 + 12;
	// 821CB2FC: 7F1BE040  cmplw cr6, r27, r28
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821CB300: 409AFFF0  bne cr6, 0x821cb2f0
	if !ctx.cr[6].eq {
	pc = 0x821CB2F0; continue 'dispatch;
	}
	pc = 0x821CB304; continue 'dispatch;
            }
            0x821CB304 => {
    //   block [0x821CB304..0x821CB30C)
	// 821CB304: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB308: 48050A31  bl 0x8221bd38
	ctx.lr = 0x821CB30C;
	sub_8221BD38(ctx, base);
	pc = 0x821CB30C; continue 'dispatch;
            }
            0x821CB30C => {
    //   block [0x821CB30C..0x821CB348)
	// 821CB30C: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821CB310: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 821CB314: 574A083C  slwi r10, r26, 1
	ctx.r[10].u32 = ctx.r[26].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821CB318: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 821CB31C: 7D5A5214  add r10, r26, r10
	ctx.r[10].u64 = ctx.r[26].u64 + ctx.r[10].u64;
	// 821CB320: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821CB324: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821CB328: 7D2BF214  add r9, r11, r30
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821CB32C: 7D0AF214  add r8, r10, r30
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 821CB330: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 821CB334: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821CB338: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 821CB33C: 4BFEC7DD  bl 0x821b7b18
	ctx.lr = 0x821CB340;
	sub_821B7B18(ctx, base);
	// 821CB340: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821CB344: 48ADE10C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x821CB348 => {
    //   block [0x821CB348..0x821CB39C)
	// 821CB348: 838100BC  lwz r28, 0xbc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 821CB34C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CB350: 7D7C2850  subf r11, r28, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[28].s64;
	// 821CB354: 7D4BDBD6  divw r10, r11, r27
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 821CB358: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 821CB35C: 40980040  bge cr6, 0x821cb39c
	if !ctx.cr[6].lt {
	pc = 0x821CB39C; continue 'dispatch;
	}
	// 821CB360: 38DC000C  addi r6, r28, 0xc
	ctx.r[6].s64 = ctx.r[28].s64 + 12;
	// 821CB364: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821CB368: 486E1FD9  bl 0x828ad340
	ctx.lr = 0x821CB36C;
	sub_828AD340(ctx, base);
	// 821CB36C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CB370: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821CB374: 7D7C2050  subf r11, r28, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[28].s64;
	// 821CB378: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CB37C: 7D4BDBD6  divw r10, r11, r27
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 821CB380: 20AA0001  subfic r5, r10, 1
	ctx.xer.ca = ctx.r[10].u32 <= 1 as u32;
	ctx.r[5].s64 = (1 as i64) - ctx.r[10].s64;
	// 821CB384: 483EEDAD  bl 0x825ba130
	ctx.lr = 0x821CB388;
	sub_825BA130(ctx, base);
	// 821CB388: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CB38C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 821CB390: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821CB394: 388BFFF4  addi r4, r11, -0xc
	ctx.r[4].s64 = ctx.r[11].s64 + -12;
	// 821CB398: 48000078  b 0x821cb410
	pc = 0x821CB410; continue 'dispatch;
            }
            0x821CB39C => {
    //   block [0x821CB39C..0x821CB3BC)
	// 821CB39C: 3BA5FFF4  addi r29, r5, -0xc
	ctx.r[29].s64 = ctx.r[5].s64 + -12;
	// 821CB3A0: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 821CB3A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821CB3A8: 486E1F99  bl 0x828ad340
	ctx.lr = 0x821CB3AC;
	sub_828AD340(ctx, base);
	// 821CB3AC: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 821CB3B0: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 821CB3B4: 419A0058  beq cr6, 0x821cb40c
	if ctx.cr[6].eq {
	pc = 0x821CB40C; continue 'dispatch;
	}
	// 821CB3B8: 3BFD0010  addi r31, r29, 0x10
	ctx.r[31].s64 = ctx.r[29].s64 + 16;
	pc = 0x821CB3BC; continue 'dispatch;
            }
            0x821CB3BC => {
    //   block [0x821CB3BC..0x821CB404)
	// 821CB3BC: 3BBDFFF4  addi r29, r29, -0xc
	ctx.r[29].s64 = ctx.r[29].s64 + -12;
	// 821CB3C0: 3BFFFFF4  addi r31, r31, -0xc
	ctx.r[31].s64 = ctx.r[31].s64 + -12;
	// 821CB3C4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CB3C8: 917FFFFC  stw r11, -4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), ctx.r[11].u32 ) };
	// 821CB3CC: 83DFFFF8  lwz r30, -8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821CB3D0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB3D4: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821CB3D8: 837FFFF4  lwz r27, -0xc(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) } as u64;
	// 821CB3DC: 419A0028  beq cr6, 0x821cb404
	if ctx.cr[6].eq {
	pc = 0x821CB404; continue 'dispatch;
	}
	// 821CB3E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CB3E4: 4BFEC735  bl 0x821b7b18
	ctx.lr = 0x821CB3E8;
	sub_821B7B18(ctx, base);
	// 821CB3E8: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 821CB3EC: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 821CB3F0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821CB3F4: 419A0010  beq cr6, 0x821cb404
	if ctx.cr[6].eq {
	pc = 0x821CB404; continue 'dispatch;
	}
	// 821CB3F8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CB3FC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821CB400: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x821CB404; continue 'dispatch;
            }
            0x821CB404 => {
    //   block [0x821CB404..0x821CB40C)
	// 821CB404: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821CB408: 409AFFB4  bne cr6, 0x821cb3bc
	if !ctx.cr[6].eq {
	pc = 0x821CB3BC; continue 'dispatch;
	}
	pc = 0x821CB40C; continue 'dispatch;
            }
            0x821CB40C => {
    //   block [0x821CB40C..0x821CB410)
	// 821CB40C: 389C000C  addi r4, r28, 0xc
	ctx.r[4].s64 = ctx.r[28].s64 + 12;
	pc = 0x821CB410; continue 'dispatch;
            }
            0x821CB410 => {
    //   block [0x821CB410..0x821CB42C)
	// 821CB410: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821CB414: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821CB418: 486BD009  bl 0x82888420
	ctx.lr = 0x821CB41C;
	sub_82888420(ctx, base);
	// 821CB41C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821CB420: 4BFEC6F9  bl 0x821b7b18
	ctx.lr = 0x821CB424;
	sub_821B7B18(ctx, base);
	// 821CB424: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821CB428: 48ADE028  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CB430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CB430 size=100
    let mut pc: u32 = 0x821CB430;
    'dispatch: loop {
        match pc {
            0x821CB430 => {
    //   block [0x821CB430..0x821CB478)
	// 821CB430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CB434: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821CB438: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821CB43C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CB440: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821CB444: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821CB448: 392B25E4  addi r9, r11, 0x25e4
	ctx.r[9].s64 = ctx.r[11].s64 + 9700;
	// 821CB44C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB450: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821CB454: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 821CB458: 419A0020  beq cr6, 0x821cb478
	if ctx.cr[6].eq {
	pc = 0x821CB478; continue 'dispatch;
	}
	// 821CB45C: 4859573D  bl 0x82760b98
	ctx.lr = 0x821CB460;
	sub_82760B98(ctx, base);
	// 821CB460: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CB464: 419A0014  beq cr6, 0x821cb478
	if ctx.cr[6].eq {
	pc = 0x821CB478; continue 'dispatch;
	}
	// 821CB468: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB46C: 4801CEDD  bl 0x821e8348
	ctx.lr = 0x821CB470;
	sub_821E8348(ctx, base);
	// 821CB470: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821CB474: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x821CB478; continue 'dispatch;
            }
            0x821CB478 => {
    //   block [0x821CB478..0x821CB494)
	// 821CB478: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CB47C: 4859591D  bl 0x82760d98
	ctx.lr = 0x821CB480;
	sub_82760D98(ctx, base);
	// 821CB480: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821CB484: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821CB488: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821CB48C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821CB490: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CB498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CB498 size=320
    let mut pc: u32 = 0x821CB498;
    'dispatch: loop {
        match pc {
            0x821CB498 => {
    //   block [0x821CB498..0x821CB5D8)
	// 821CB498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CB49C: 48ADDF6D  bl 0x82ca9408
	ctx.lr = 0x821CB4A0;
	sub_82CA93D0(ctx, base);
	// 821CB4A0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CB4A4: A1640052  lhz r11, 0x52(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(82 as u32) ) } as u64;
	// 821CB4A8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821CB4AC: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 821CB4B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821CB4B4: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 821CB4B8: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 821CB4BC: B1610050  sth r11, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u16 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CB5D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CB5D8 size=372
    let mut pc: u32 = 0x821CB5D8;
    'dispatch: loop {
        match pc {
            0x821CB5D8 => {
    //   block [0x821CB5D8..0x821CB600)
	// 821CB5D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CB5DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821CB5E0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CB5E4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821CB5E8: 419A0018  beq cr6, 0x821cb600
	if ctx.cr[6].eq {
	pc = 0x821CB600; continue 'dispatch;
	}
	// 821CB5EC: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 821CB5F0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821CB5F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CB5F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CB5FC: 409A0008  bne cr6, 0x821cb604
	if !ctx.cr[6].eq {
	pc = 0x821CB604; continue 'dispatch;
	}
	pc = 0x821CB600; continue 'dispatch;
            }
            0x821CB600 => {
    //   block [0x821CB600..0x821CB604)
	// 821CB600: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821CB604; continue 'dispatch;
            }
            0x821CB604 => {
    //   block [0x821CB604..0x821CB64C)
	// 821CB604: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CB608: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CB60C: 419A012C  beq cr6, 0x821cb738
	if ctx.cr[6].eq {
	pc = 0x821CB738; continue 'dispatch;
	}
	// 821CB610: 8144002C  lwz r10, 0x2c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 821CB614: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821CB618: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 821CB61C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821CB620: 419A00E8  beq cr6, 0x821cb708
	if ctx.cr[6].eq {
	pc = 0x821CB708; continue 'dispatch;
	}
	// 821CB624: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 821CB628: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CB62C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CB630: 419A001C  beq cr6, 0x821cb64c
	if ctx.cr[6].eq {
	pc = 0x821CB64C; continue 'dispatch;
	}
	// 821CB634: 896B0043  lbz r11, 0x43(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(67 as u32) ) } as u64;
	// 821CB638: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821CB63C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821CB640: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB644: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821CB648: 480000C4  b 0x821cb70c
	pc = 0x821CB70C; continue 'dispatch;
            }
            0x821CB64C => {
    //   block [0x821CB64C..0x821CB668)
	// 821CB64C: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 821CB650: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821CB654: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821CB658: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821CB65C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821CB660: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CB664: 40810054  ble 0x821cb6b8
	if !ctx.cr[0].gt {
	pc = 0x821CB6B8; continue 'dispatch;
	}
	pc = 0x821CB668; continue 'dispatch;
            }
            0x821CB668 => {
    //   block [0x821CB668..0x821CB688)
	// 821CB668: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821CB66C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821CB670: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821CB674: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CB678: 2F070043  cmpwi cr6, r7, 0x43
	ctx.cr[6].compare_i32(ctx.r[7].s32, 67, &mut ctx.xer);
	// 821CB67C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821CB680: 41980008  blt cr6, 0x821cb688
	if ctx.cr[6].lt {
	pc = 0x821CB688; continue 'dispatch;
	}
	// 821CB684: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x821CB688; continue 'dispatch;
            }
            0x821CB688 => {
    //   block [0x821CB688..0x821CB6A4)
	// 821CB688: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821CB68C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821CB690: 419A0014  beq cr6, 0x821cb6a4
	if ctx.cr[6].eq {
	pc = 0x821CB6A4; continue 'dispatch;
	}
	// 821CB694: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821CB698: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821CB69C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821CB6A0: 4800000C  b 0x821cb6ac
	pc = 0x821CB6AC; continue 'dispatch;
            }
            0x821CB6A4 => {
    //   block [0x821CB6A4..0x821CB6AC)
	// 821CB6A4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821CB6A8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821CB6AC; continue 'dispatch;
            }
            0x821CB6AC => {
    //   block [0x821CB6AC..0x821CB6B8)
	// 821CB6AC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CB6B0: 4199FFB8  bgt cr6, 0x821cb668
	if ctx.cr[6].gt {
	pc = 0x821CB668; continue 'dispatch;
	}
	// 821CB6B4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821CB6B8; continue 'dispatch;
            }
            0x821CB6B8 => {
    //   block [0x821CB6B8..0x821CB6D4)
	// 821CB6B8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821CB6BC: 419A003C  beq cr6, 0x821cb6f8
	if ctx.cr[6].eq {
	pc = 0x821CB6F8; continue 'dispatch;
	}
	// 821CB6C0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CB6C4: 2F0B0043  cmpwi cr6, r11, 0x43
	ctx.cr[6].compare_i32(ctx.r[11].s32, 67, &mut ctx.xer);
	// 821CB6C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CB6CC: 41990008  bgt cr6, 0x821cb6d4
	if ctx.cr[6].gt {
	pc = 0x821CB6D4; continue 'dispatch;
	}
	// 821CB6D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821CB6D4; continue 'dispatch;
            }
            0x821CB6D4 => {
    //   block [0x821CB6D4..0x821CB6F8)
	// 821CB6D4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CB6D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CB6DC: 409A001C  bne cr6, 0x821cb6f8
	if !ctx.cr[6].eq {
	pc = 0x821CB6F8; continue 'dispatch;
	}
	// 821CB6E0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821CB6E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821CB6E8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821CB6EC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821CB6F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB6F4: 48000018  b 0x821cb70c
	pc = 0x821CB70C; continue 'dispatch;
            }
            0x821CB6F8 => {
    //   block [0x821CB6F8..0x821CB708)
	// 821CB6F8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821CB6FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821CB700: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB704: 48000008  b 0x821cb70c
	pc = 0x821CB70C; continue 'dispatch;
            }
            0x821CB708 => {
    //   block [0x821CB708..0x821CB70C)
	// 821CB708: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821CB70C; continue 'dispatch;
            }
            0x821CB70C => {
    //   block [0x821CB70C..0x821CB738)
	// 821CB70C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821CB710: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CB714: 419A0024  beq cr6, 0x821cb738
	if ctx.cr[6].eq {
	pc = 0x821CB738; continue 'dispatch;
	}
	// 821CB718: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CB71C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821CB720: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CB724: 4E800421  bctrl
	ctx.lr = 0x821CB728;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CB728: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821CB72C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821CB730: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821CB734: 4E800020  blr
	return;
            }
            0x821CB738 => {
    //   block [0x821CB738..0x821CB74C)
	// 821CB738: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821CB73C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821CB740: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821CB744: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821CB748: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CB750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821CB750 size=576
    let mut pc: u32 = 0x821CB750;
    'dispatch: loop {
        match pc {
            0x821CB750 => {
    //   block [0x821CB750..0x821CB780)
	// 821CB750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CB754: 48ADDCB9  bl 0x82ca940c
	ctx.lr = 0x821CB758;
	sub_82CA93D0(ctx, base);
	// 821CB758: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CB75C: 3D608331  lis r11, -0x7ccf
	ctx.r[11].s64 = -2093940736;
	// 821CB760: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821CB764: 3D408331  lis r10, -0x7ccf
	ctx.r[10].s64 = -2093940736;
	// 821CB768: 812B711C  lwz r9, 0x711c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28956 as u32) ) } as u64;
	// 821CB76C: 2B090020  cmplwi cr6, r9, 0x20
	ctx.cr[6].compare_u32(ctx.r[9].u32, 32 as u32, &mut ctx.xer);
	// 821CB770: 409A0010  bne cr6, 0x821cb780
	if !ctx.cr[6].eq {
	pc = 0x821CB780; continue 'dispatch;
	}
	// 821CB774: 812A7120  lwz r9, 0x7120(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28960 as u32) ) } as u64;
	// 821CB778: 2B090060  cmplwi cr6, r9, 0x60
	ctx.cr[6].compare_u32(ctx.r[9].u32, 96 as u32, &mut ctx.xer);
	// 821CB77C: 419A002C  beq cr6, 0x821cb7a8
	if ctx.cr[6].eq {
	pc = 0x821CB7A8; continue 'dispatch;
	}
	pc = 0x821CB780; continue 'dispatch;
            }
            0x821CB780 => {
    //   block [0x821CB780..0x821CB7A8)
	// 821CB780: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 821CB784: 39000060  li r8, 0x60
	ctx.r[8].s64 = 96;
	// 821CB788: 912B711C  stw r9, 0x711c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28956 as u32), ctx.r[9].u32 ) };
	// 821CB78C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821CB790: 910A7120  stw r8, 0x7120(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28960 as u32), ctx.r[8].u32 ) };
	// 821CB794: 38C00060  li r6, 0x60
	ctx.r[6].s64 = 96;
	// 821CB798: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 821CB79C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821CB7A0: 806B0364  lwz r3, 0x364(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(868 as u32) ) } as u64;
	// 821CB7A4: 4BFD15C5  bl 0x8219cd68
	ctx.lr = 0x821CB7A8;
	sub_8219CD68(ctx, base);
	pc = 0x821CB7A8; continue 'dispatch;
            }
            0x821CB7A8 => {
    //   block [0x821CB7A8..0x821CB804)
	// 821CB7A8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821CB7AC: C02B9490  lfs f1, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821CB7B0: 4BFE61A9  bl 0x821b1958
	ctx.lr = 0x821CB7B4;
	sub_821B1958(ctx, base);
	// 821CB7B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CB7B8: 480AEC89  bl 0x8227a440
	ctx.lr = 0x821CB7BC;
	sub_8227A440(ctx, base);
	// 821CB7BC: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821CB7C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CB7C4: 3BABA990  addi r29, r11, -0x5670
	ctx.r[29].s64 = ctx.r[11].s64 + -22128;
	// 821CB7C8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821CB7CC: 480AD76D  bl 0x82278f38
	ctx.lr = 0x821CB7D0;
	sub_82278F38(ctx, base);
	// 821CB7D0: 39400007  li r10, 7
	ctx.r[10].s64 = 7;
	// 821CB7D4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB7D8: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 821CB7DC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821CB7E0: 83DF06FC  lwz r30, 0x6fc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1788 as u32) ) } as u64;
	// 821CB7E4: 915F06FC  stw r10, 0x6fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1788 as u32), ctx.r[10].u32 ) };
	// 821CB7E8: 81690014  lwz r11, 0x14(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 821CB7EC: 388B0D54  addi r4, r11, 0xd54
	ctx.r[4].s64 = ctx.r[11].s64 + 3412;
	// 821CB7F0: 48028C91  bl 0x821f4480
	ctx.lr = 0x821CB7F4;
	sub_821F4480(ctx, base);
	// 821CB7F4: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821CB7F8: 81010074  lwz r8, 0x74(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821CB7FC: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821CB800: 419A0058  beq cr6, 0x821cb858
	if ctx.cr[6].eq {
	pc = 0x821CB858; continue 'dispatch;
	}
	pc = 0x821CB804; continue 'dispatch;
            }
            0x821CB804 => {
    //   block [0x821CB804..0x821CB828)
	// 821CB804: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CB808: 81210064  lwz r9, 0x64(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821CB80C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CB810: 419A0018  beq cr6, 0x821cb828
	if ctx.cr[6].eq {
	pc = 0x821CB828; continue 'dispatch;
	}
	// 821CB814: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CB818: 7D0A5850  subf r8, r10, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821CB81C: 7D0B1670  srawi r11, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 821CB820: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CB824: 41980008  blt cr6, 0x821cb82c
	if ctx.cr[6].lt {
	pc = 0x821CB82C; continue 'dispatch;
	}
	pc = 0x821CB828; continue 'dispatch;
            }
            0x821CB828 => {
    //   block [0x821CB828..0x821CB82C)
	// 821CB828: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821CB82C; continue 'dispatch;
            }
            0x821CB82C => {
    //   block [0x821CB82C..0x821CB858)
	// 821CB82C: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821CB830: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821CB834: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CB838: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821CB83C: 4809C01D  bl 0x82267858
	ctx.lr = 0x821CB840;
	sub_82267858(ctx, base);
	// 821CB840: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821CB844: 48034535  bl 0x821ffd78
	ctx.lr = 0x821CB848;
	sub_821FFD78(ctx, base);
	// 821CB848: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821CB84C: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821CB850: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821CB854: 409AFFB0  bne cr6, 0x821cb804
	if !ctx.cr[6].eq {
	pc = 0x821CB804; continue 'dispatch;
	}
	pc = 0x821CB858; continue 'dispatch;
            }
            0x821CB858 => {
    //   block [0x821CB858..0x821CB880)
	// 821CB858: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB85C: 38A0002F  li r5, 0x2f
	ctx.r[5].s64 = 47;
	// 821CB860: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821CB864: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821CB868: 388B0D54  addi r4, r11, 0xd54
	ctx.r[4].s64 = ctx.r[11].s64 + 3412;
	// 821CB86C: 48028C15  bl 0x821f4480
	ctx.lr = 0x821CB870;
	sub_821F4480(ctx, base);
	// 821CB870: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821CB874: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821CB878: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821CB87C: 419A0054  beq cr6, 0x821cb8d0
	if ctx.cr[6].eq {
	pc = 0x821CB8D0; continue 'dispatch;
	}
	pc = 0x821CB880; continue 'dispatch;
            }
            0x821CB880 => {
    //   block [0x821CB880..0x821CB8A4)
	// 821CB880: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CB884: 81210064  lwz r9, 0x64(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821CB888: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CB88C: 419A0018  beq cr6, 0x821cb8a4
	if ctx.cr[6].eq {
	pc = 0x821CB8A4; continue 'dispatch;
	}
	// 821CB890: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CB894: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821CB898: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 821CB89C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821CB8A0: 41980008  blt cr6, 0x821cb8a8
	if ctx.cr[6].lt {
	pc = 0x821CB8A8; continue 'dispatch;
	}
	pc = 0x821CB8A4; continue 'dispatch;
            }
            0x821CB8A4 => {
    //   block [0x821CB8A4..0x821CB8A8)
	// 821CB8A4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821CB8A8; continue 'dispatch;
            }
            0x821CB8A8 => {
    //   block [0x821CB8A8..0x821CB8D0)
	// 821CB8A8: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821CB8AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CB8B0: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821CB8B4: 48098FB5  bl 0x82264868
	ctx.lr = 0x821CB8B8;
	sub_82264868(ctx, base);
	// 821CB8B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821CB8BC: 480344BD  bl 0x821ffd78
	ctx.lr = 0x821CB8C0;
	sub_821FFD78(ctx, base);
	// 821CB8C0: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821CB8C4: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821CB8C8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821CB8CC: 409AFFB4  bne cr6, 0x821cb880
	if !ctx.cr[6].eq {
	pc = 0x821CB880; continue 'dispatch;
	}
	pc = 0x821CB8D0; continue 'dispatch;
            }
            0x821CB8D0 => {
    //   block [0x821CB8D0..0x821CB95C)
	// 821CB8D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821CB8D4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821CB8D8: 388B2270  addi r4, r11, 0x2270
	ctx.r[4].s64 = ctx.r[11].s64 + 8816;
	// 821CB8DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821CB8E0: 480615F1  bl 0x8222ced0
	ctx.lr = 0x821CB8E4;
	sub_8222CED0(ctx, base);
	// 821CB8E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821CB8E8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821CB8EC: 480DFC1D  bl 0x822ab508
	ctx.lr = 0x821CB8F0;
	sub_822AB508(ctx, base);
	// 821CB8F0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821CB8F4: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 821CB8F8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821CB8FC: 480D6DBD  bl 0x822a26b8
	ctx.lr = 0x821CB900;
	sub_822A26B8(ctx, base);
	// 821CB900: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CB904: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821CB908: 48071699  bl 0x8223cfa0
	ctx.lr = 0x821CB90C;
	sub_8223CFA0(ctx, base);
	// 821CB90C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821CB910: 480D2189  bl 0x8229da98
	ctx.lr = 0x821CB914;
	sub_8229DA98(ctx, base);
	// 821CB914: 93DF06FC  stw r30, 0x6fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1788 as u32), ctx.r[30].u32 ) };
	// 821CB918: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821CB91C: 3BCBA9A8  addi r30, r11, -0x5658
	ctx.r[30].s64 = ctx.r[11].s64 + -22104;
	// 821CB920: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821CB924: 48015ED5  bl 0x821e17f8
	ctx.lr = 0x821CB928;
	sub_821E17F8(ctx, base);
	// 821CB928: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821CB92C: 4809F74D  bl 0x8226b078
	ctx.lr = 0x821CB930;
	sub_8226B078(ctx, base);
	// 821CB930: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 821CB934: 386AB158  addi r3, r10, -0x4ea8
	ctx.r[3].s64 = ctx.r[10].s64 + -20136;
	// 821CB938: 4BFE2419  bl 0x821add50
	ctx.lr = 0x821CB93C;
	sub_821ADD50(ctx, base);
	// 821CB93C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB940: 80690014  lwz r3, 0x14(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 821CB944: 480C3C0D  bl 0x8228f550
	ctx.lr = 0x821CB948;
	sub_8228F550(ctx, base);
	// 821CB948: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CB94C: 419A0010  beq cr6, 0x821cb95c
	if ctx.cr[6].eq {
	pc = 0x821CB95C; continue 'dispatch;
	}
	// 821CB950: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CB954: 38630090  addi r3, r3, 0x90
	ctx.r[3].s64 = ctx.r[3].s64 + 144;
	// 821CB958: 48008929  bl 0x821d4280
	ctx.lr = 0x821CB95C;
	sub_821D4280(ctx, base);
	pc = 0x821CB95C; continue 'dispatch;
            }
            0x821CB95C => {
    //   block [0x821CB95C..0x821CB990)
	// 821CB95C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821CB960: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821CB964: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821CB968: 48066D79  bl 0x822326e0
	ctx.lr = 0x821CB96C;
	sub_822326E0(ctx, base);
	// 821CB96C: 48076865  bl 0x822421d0
	ctx.lr = 0x821CB970;
	sub_822421D0(ctx, base);
	// 821CB970: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CB974: 4BFFC655  bl 0x821c7fc8
	ctx.lr = 0x821CB978;
	sub_821C7FC8(ctx, base);
	// 821CB978: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CB97C: 480ABA05  bl 0x82277380
	ctx.lr = 0x821CB980;
	sub_82277380(ctx, base);
	// 821CB980: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CB984: 480F890D  bl 0x822c4290
	ctx.lr = 0x821CB988;
	sub_822C4290(ctx, base);
	// 821CB988: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 821CB98C: 48ADDAD0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CB990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821CB990 size=2768
    let mut pc: u32 = 0x821CB990;
    'dispatch: loop {
        match pc {
            0x821CB990 => {
    //   block [0x821CB990..0x821CB9F4)
	// 821CB990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CB994: 48ADDA61  bl 0x82ca93f4
	ctx.lr = 0x821CB998;
	sub_82CA93D0(ctx, base);
	// 821CB998: DBA1FF98  stfd f29, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[29].u64 ) };
	// 821CB99C: DBC1FFA0  stfd f30, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[30].u64 ) };
	// 821CB9A0: DBE1FFA8  stfd f31, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 821CB9A4: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CB9A8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821CB9AC: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821CB9B0: 7F57D378  mr r23, r26
	ctx.r[23].u64 = ctx.r[26].u64;
	// 821CB9B4: 7F59D378  mr r25, r26
	ctx.r[25].u64 = ctx.r[26].u64;
	// 821CB9B8: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB9BC: 92E10068  stw r23, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[23].u32 ) };
	// 821CB9C0: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 821CB9C4: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 821CB9C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CB9CC: 419A00D8  beq cr6, 0x821cbaa4
	if ctx.cr[6].eq {
	pc = 0x821CBAA4; continue 'dispatch;
	}
	// 821CB9D0: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821CB9D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CB9D8: 419A001C  beq cr6, 0x821cb9f4
	if ctx.cr[6].eq {
	pc = 0x821CB9F4; continue 'dispatch;
	}
	// 821CB9DC: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 821CB9E0: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CB9E4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821CB9E8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821CB9EC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CB9F0: 480000B0  b 0x821cbaa0
	pc = 0x821CBAA0; continue 'dispatch;
            }
            0x821CB9F4 => {
    //   block [0x821CB9F4..0x821CBA10)
	// 821CB9F4: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CB9F8: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821CB9FC: 93410068  stw r26, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[26].u32 ) };
	// 821CBA00: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821CBA04: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 821CBA08: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CBA0C: 40810054  ble 0x821cba60
	if !ctx.cr[0].gt {
	pc = 0x821CBA60; continue 'dispatch;
	}
	pc = 0x821CBA10; continue 'dispatch;
            }
            0x821CBA10 => {
    //   block [0x821CBA10..0x821CBA30)
	// 821CBA10: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821CBA14: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821CBA18: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821CBA1C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBA20: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 821CBA24: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821CBA28: 41980008  blt cr6, 0x821cba30
	if ctx.cr[6].lt {
	pc = 0x821CBA30; continue 'dispatch;
	}
	// 821CBA2C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	pc = 0x821CBA30; continue 'dispatch;
            }
            0x821CBA30 => {
    //   block [0x821CBA30..0x821CBA4C)
	// 821CBA30: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821CBA34: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821CBA38: 419A0014  beq cr6, 0x821cba4c
	if ctx.cr[6].eq {
	pc = 0x821CBA4C; continue 'dispatch;
	}
	// 821CBA3C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821CBA40: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821CBA44: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821CBA48: 4800000C  b 0x821cba54
	pc = 0x821CBA54; continue 'dispatch;
            }
            0x821CBA4C => {
    //   block [0x821CBA4C..0x821CBA54)
	// 821CBA4C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821CBA50: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821CBA54; continue 'dispatch;
            }
            0x821CBA54 => {
    //   block [0x821CBA54..0x821CBA60)
	// 821CBA54: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CBA58: 4199FFB8  bgt cr6, 0x821cba10
	if ctx.cr[6].gt {
	pc = 0x821CBA10; continue 'dispatch;
	}
	// 821CBA5C: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	pc = 0x821CBA60; continue 'dispatch;
            }
            0x821CBA60 => {
    //   block [0x821CBA60..0x821CBA7C)
	// 821CBA60: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821CBA64: 419A0034  beq cr6, 0x821cba98
	if ctx.cr[6].eq {
	pc = 0x821CBA98; continue 'dispatch;
	}
	// 821CBA68: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBA6C: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 821CBA70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CBA74: 41990008  bgt cr6, 0x821cba7c
	if ctx.cr[6].gt {
	pc = 0x821CBA7C; continue 'dispatch;
	}
	// 821CBA78: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x821CBA7C; continue 'dispatch;
            }
            0x821CBA7C => {
    //   block [0x821CBA7C..0x821CBA98)
	// 821CBA7C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CBA80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CBA84: 409A0014  bne cr6, 0x821cba98
	if !ctx.cr[6].eq {
	pc = 0x821CBA98; continue 'dispatch;
	}
	// 821CBA88: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821CBA8C: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821CBA90: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821CBA94: 48000008  b 0x821cba9c
	pc = 0x821CBA9C; continue 'dispatch;
            }
            0x821CBA98 => {
    //   block [0x821CBA98..0x821CBA9C)
	// 821CBA98: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x821CBA9C; continue 'dispatch;
            }
            0x821CBA9C => {
    //   block [0x821CBA9C..0x821CBAA0)
	// 821CBA9C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x821CBAA0; continue 'dispatch;
            }
            0x821CBAA0 => {
    //   block [0x821CBAA0..0x821CBAA4)
	// 821CBAA0: 7D795B78  mr r25, r11
	ctx.r[25].u64 = ctx.r[11].u64;
	pc = 0x821CBAA4; continue 'dispatch;
            }
            0x821CBAA4 => {
    //   block [0x821CBAA4..0x821CBAF8)
	// 821CBAA4: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821CBAA8: 83CB9650  lwz r30, -0x69b0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 821CBAAC: 4803BD45  bl 0x822077f0
	ctx.lr = 0x821CBAB0;
	sub_822077F0(ctx, base);
	// 821CBAB0: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821CBAB4: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 821CBAB8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821CBABC: 809B0018  lwz r4, 0x18(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 821CBAC0: 3B0B9484  addi r24, r11, -0x6b7c
	ctx.r[24].s64 = ctx.r[11].s64 + -27516;
	// 821CBAC4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821CBAC8: C80A9660  lfd f0, -0x69a0(r10)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-27040 as u32) ) };
	// 821CBACC: C3AB9484  lfs f29, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821CBAD0: FC1F0024  fdiv f0, f31, f0
	ctx.f[0].f64 = ctx.f[31].f64 / ctx.f[0].f64;
	// 821CBAD4: FFC00018  frsp f30, f0
	ctx.f[30].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821CBAD8: 419A0178  beq cr6, 0x821cbc50
	if ctx.cr[6].eq {
	pc = 0x821CBC50; continue 'dispatch;
	}
	// 821CBADC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821CBAE0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 821CBAE4: 480E253D  bl 0x822ae020
	ctx.lr = 0x821CBAE8;
	sub_822AE020(ctx, base);
	// 821CBAE8: 807B0018  lwz r3, 0x18(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 821CBAEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CBAF0: 419A0040  beq cr6, 0x821cbb30
	if ctx.cr[6].eq {
	pc = 0x821CBB30; continue 'dispatch;
	}
	// 821CBAF4: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x821CBAF8; continue 'dispatch;
            }
            0x821CBAF8 => {
    //   block [0x821CBAF8..0x821CBB2C)
	// 821CBAF8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821CBAFC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CBB00: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821CBB04: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821CBB08: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821CBB0C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CBB10: 4082FFE8  bne 0x821cbaf8
	if !ctx.cr[0].eq {
	pc = 0x821CBAF8; continue 'dispatch;
	}
	// 821CBB14: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CBB18: 409A0014  bne cr6, 0x821cbb2c
	if !ctx.cr[6].eq {
	pc = 0x821CBB2C; continue 'dispatch;
	}
	// 821CBB1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBB20: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CBB24: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CBB28: 4E800421  bctrl
	ctx.lr = 0x821CBB2C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821CBB2C => {
    //   block [0x821CBB2C..0x821CBB30)
	// 821CBB2C: 935B0018  stw r26, 0x18(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(24 as u32), ctx.r[26].u32 ) };
	pc = 0x821CBB30; continue 'dispatch;
            }
            0x821CBB30 => {
    //   block [0x821CBB30..0x821CBB78)
	// 821CBB30: 935B0018  stw r26, 0x18(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(24 as u32), ctx.r[26].u32 ) };
	// 821CBB34: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 821CBB38: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CBB3C: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821CBB40: 552827FE  rlwinm r8, r9, 4, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0FFFFFFFu64;
	// 821CBB44: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821CBB48: 419A00F4  beq cr6, 0x821cbc3c
	if ctx.cr[6].eq {
	pc = 0x821CBC3C; continue 'dispatch;
	}
	// 821CBB4C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821CBB50: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CBB54: 419A0024  beq cr6, 0x821cbb78
	if ctx.cr[6].eq {
	pc = 0x821CBB78; continue 'dispatch;
	}
	// 821CBB58: 894A003C  lbz r10, 0x3c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 821CBB5C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CBB60: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821CBB64: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821CBB68: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CBB6C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821CBB70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CBB74: 480000CC  b 0x821cbc40
	pc = 0x821CBC40; continue 'dispatch;
            }
            0x821CBB78 => {
    //   block [0x821CBB78..0x821CBB94)
	// 821CBB78: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CBB7C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821CBB80: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 821CBB84: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821CBB88: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821CBB8C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CBB90: 40810054  ble 0x821cbbe4
	if !ctx.cr[0].gt {
	pc = 0x821CBBE4; continue 'dispatch;
	}
	pc = 0x821CBB94; continue 'dispatch;
            }
            0x821CBB94 => {
    //   block [0x821CBB94..0x821CBBB4)
	// 821CBB94: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821CBB98: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821CBB9C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821CBBA0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBBA4: 2F07003C  cmpwi cr6, r7, 0x3c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 60, &mut ctx.xer);
	// 821CBBA8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821CBBAC: 41980008  blt cr6, 0x821cbbb4
	if ctx.cr[6].lt {
	pc = 0x821CBBB4; continue 'dispatch;
	}
	// 821CBBB0: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	pc = 0x821CBBB4; continue 'dispatch;
            }
            0x821CBBB4 => {
    //   block [0x821CBBB4..0x821CBBD0)
	// 821CBBB4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821CBBB8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821CBBBC: 419A0014  beq cr6, 0x821cbbd0
	if ctx.cr[6].eq {
	pc = 0x821CBBD0; continue 'dispatch;
	}
	// 821CBBC0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821CBBC4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821CBBC8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821CBBCC: 4800000C  b 0x821cbbd8
	pc = 0x821CBBD8; continue 'dispatch;
            }
            0x821CBBD0 => {
    //   block [0x821CBBD0..0x821CBBD8)
	// 821CBBD0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821CBBD4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821CBBD8; continue 'dispatch;
            }
            0x821CBBD8 => {
    //   block [0x821CBBD8..0x821CBBE4)
	// 821CBBD8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CBBDC: 4199FFB8  bgt cr6, 0x821cbb94
	if ctx.cr[6].gt {
	pc = 0x821CBB94; continue 'dispatch;
	}
	// 821CBBE0: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x821CBBE4; continue 'dispatch;
            }
            0x821CBBE4 => {
    //   block [0x821CBBE4..0x821CBC00)
	// 821CBBE4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821CBBE8: 419A0040  beq cr6, 0x821cbc28
	if ctx.cr[6].eq {
	pc = 0x821CBC28; continue 'dispatch;
	}
	// 821CBBEC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBBF0: 2F0B003C  cmpwi cr6, r11, 0x3c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 60, &mut ctx.xer);
	// 821CBBF4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CBBF8: 41990008  bgt cr6, 0x821cbc00
	if ctx.cr[6].gt {
	pc = 0x821CBC00; continue 'dispatch;
	}
	// 821CBBFC: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x821CBC00; continue 'dispatch;
            }
            0x821CBC00 => {
    //   block [0x821CBC00..0x821CBC28)
	// 821CBC00: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CBC04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CBC08: 409A0020  bne cr6, 0x821cbc28
	if !ctx.cr[6].eq {
	pc = 0x821CBC28; continue 'dispatch;
	}
	// 821CBC0C: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821CBC10: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821CBC14: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821CBC18: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CBC1C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821CBC20: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CBC24: 4800001C  b 0x821cbc40
	pc = 0x821CBC40; continue 'dispatch;
            }
            0x821CBC28 => {
    //   block [0x821CBC28..0x821CBC3C)
	// 821CBC28: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821CBC2C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CBC30: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821CBC34: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CBC38: 48000008  b 0x821cbc40
	pc = 0x821CBC40; continue 'dispatch;
            }
            0x821CBC3C => {
    //   block [0x821CBC3C..0x821CBC40)
	// 821CBC3C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x821CBC40; continue 'dispatch;
            }
            0x821CBC40 => {
    //   block [0x821CBC40..0x821CBC50)
	// 821CBC40: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CBC44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CBC48: 419A0008  beq cr6, 0x821cbc50
	if ctx.cr[6].eq {
	pc = 0x821CBC50; continue 'dispatch;
	}
	// 821CBC4C: D3AA00FC  stfs f29, 0xfc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(252 as u32), tmp.u32 ) };
	pc = 0x821CBC50; continue 'dispatch;
            }
            0x821CBC50 => {
    //   block [0x821CBC50..0x821CBC8C)
	// 821CBC50: 817B0024  lwz r11, 0x24(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) } as u64;
	// 821CBC54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CBC58: 419A012C  beq cr6, 0x821cbd84
	if ctx.cr[6].eq {
	pc = 0x821CBD84; continue 'dispatch;
	}
	// 821CBC5C: 817B001C  lwz r11, 0x1c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 821CBC60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CBC64: 409A0120  bne cr6, 0x821cbd84
	if !ctx.cr[6].eq {
	pc = 0x821CBD84; continue 'dispatch;
	}
	// 821CBC68: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 821CBC6C: 480535ED  bl 0x8221f258
	ctx.lr = 0x821CBC70;
	sub_8221F258(ctx, base);
	// 821CBC70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CBC74: 419A0018  beq cr6, 0x821cbc8c
	if ctx.cr[6].eq {
	pc = 0x821CBC8C; continue 'dispatch;
	}
	// 821CBC78: C01822AC  lfs f0, 0x22ac(r24)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8876 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821CBC7C: EC20F824  fdivs f1, f0, f31
	ctx.f[1].f64 = ((ctx.f[0].f64 / ctx.f[31].f64) as f32) as f64;
	// 821CBC80: 480BFEC1  bl 0x8228bb40
	ctx.lr = 0x821CBC84;
	sub_8228BB40(ctx, base);
	// 821CBC84: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 821CBC88: 48000008  b 0x821cbc90
	pc = 0x821CBC90; continue 'dispatch;
            }
            0x821CBC8C => {
    //   block [0x821CBC8C..0x821CBC90)
	// 821CBC8C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	pc = 0x821CBC90; continue 'dispatch;
            }
            0x821CBC90 => {
    //   block [0x821CBC90..0x821CBCCC)
	// 821CBC90: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821CBC94: 80BB0024  lwz r5, 0x24(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) } as u64;
	// 821CBC98: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821CBC9C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821CBCA0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821CBCA4: 4800249D  bl 0x821ce140
	ctx.lr = 0x821CBCA8;
	sub_821CE140(ctx, base);
	// 821CBCA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821CBCAC: 817B001C  lwz r11, 0x1c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 821CBCB0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBCB4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821CBCB8: 419A007C  beq cr6, 0x821cbd34
	if ctx.cr[6].eq {
	pc = 0x821CBD34; continue 'dispatch;
	}
	// 821CBCBC: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821CBCC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CBCC4: 419A0040  beq cr6, 0x821cbd04
	if ctx.cr[6].eq {
	pc = 0x821CBD04; continue 'dispatch;
	}
	// 821CBCC8: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x821CBCCC; continue 'dispatch;
            }
            0x821CBCCC => {
    //   block [0x821CBCCC..0x821CBD00)
	// 821CBCCC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821CBCD0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CBCD4: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821CBCD8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821CBCDC: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821CBCE0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CBCE4: 4082FFE8  bne 0x821cbccc
	if !ctx.cr[0].eq {
	pc = 0x821CBCCC; continue 'dispatch;
	}
	// 821CBCE8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CBCEC: 409A0014  bne cr6, 0x821cbd00
	if !ctx.cr[6].eq {
	pc = 0x821CBD00; continue 'dispatch;
	}
	// 821CBCF0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBCF4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CBCF8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CBCFC: 4E800421  bctrl
	ctx.lr = 0x821CBD00;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821CBD00 => {
    //   block [0x821CBD00..0x821CBD04)
	// 821CBD00: 935B001C  stw r26, 0x1c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(28 as u32), ctx.r[26].u32 ) };
	pc = 0x821CBD04; continue 'dispatch;
            }
            0x821CBD04 => {
    //   block [0x821CBD04..0x821CBD18)
	// 821CBD04: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBD08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CBD0C: 917B001C  stw r11, 0x1c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 821CBD10: 419A0024  beq cr6, 0x821cbd34
	if ctx.cr[6].eq {
	pc = 0x821CBD34; continue 'dispatch;
	}
	// 821CBD14: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x821CBD18; continue 'dispatch;
            }
            0x821CBD18 => {
    //   block [0x821CBD18..0x821CBD34)
	// 821CBD18: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821CBD1C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CBD20: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821CBD24: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821CBD28: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821CBD2C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CBD30: 4082FFE8  bne 0x821cbd18
	if !ctx.cr[0].eq {
	pc = 0x821CBD18; continue 'dispatch;
	}
	pc = 0x821CBD34; continue 'dispatch;
            }
            0x821CBD34 => {
    //   block [0x821CBD34..0x821CBD48)
	// 821CBD34: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821CBD38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CBD3C: 419A0048  beq cr6, 0x821cbd84
	if ctx.cr[6].eq {
	pc = 0x821CBD84; continue 'dispatch;
	}
	// 821CBD40: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821CBD44: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x821CBD48; continue 'dispatch;
            }
            0x821CBD48 => {
    //   block [0x821CBD48..0x821CBD80)
	// 821CBD48: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821CBD4C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CBD50: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821CBD54: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821CBD58: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821CBD5C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CBD60: 4082FFE8  bne 0x821cbd48
	if !ctx.cr[0].eq {
	pc = 0x821CBD48; continue 'dispatch;
	}
	// 821CBD64: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821CBD68: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CBD6C: 409A0014  bne cr6, 0x821cbd80
	if !ctx.cr[6].eq {
	pc = 0x821CBD80; continue 'dispatch;
	}
	// 821CBD70: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBD74: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CBD78: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CBD7C: 4E800421  bctrl
	ctx.lr = 0x821CBD80;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821CBD80 => {
    //   block [0x821CBD80..0x821CBD84)
	// 821CBD80: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	pc = 0x821CBD84; continue 'dispatch;
            }
            0x821CBD84 => {
    //   block [0x821CBD84..0x821CBDAC)
	// 821CBD84: 807B0024  lwz r3, 0x24(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) } as u64;
	// 821CBD88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CBD8C: 419A0020  beq cr6, 0x821cbdac
	if ctx.cr[6].eq {
	pc = 0x821CBDAC; continue 'dispatch;
	}
	// 821CBD90: C01B005C  lfs f0, 0x5c(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821CBD94: EC3E002A  fadds f1, f30, f0
	ctx.f[1].f64 = ((ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64;
	// 821CBD98: D03B005C  stfs f1, 0x5c(r27)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 821CBD9C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBDA0: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821CBDA4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CBDA8: 4E800421  bctrl
	ctx.lr = 0x821CBDAC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821CBDAC => {
    //   block [0x821CBDAC..0x821CBE0C)
	// 821CBDAC: 817B003C  lwz r11, 0x3c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(60 as u32) ) } as u64;
	// 821CBDB0: 3B9B003C  addi r28, r27, 0x3c
	ctx.r[28].s64 = ctx.r[27].s64 + 60;
	// 821CBDB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CBDB8: 419A01F0  beq cr6, 0x821cbfa8
	if ctx.cr[6].eq {
	pc = 0x821CBFA8; continue 'dispatch;
	}
	// 821CBDBC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CBDC0: C01B0060  lfs f0, 0x60(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821CBDC4: EDA0F02A  fadds f13, f0, f30
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 821CBDC8: D1BB0060  stfs f13, 0x60(r27)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821CBDCC: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 821CBDD0: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821CBDD4: 5528A7FE  rlwinm r8, r9, 0x14, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000FFFu64;
	// 821CBDD8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821CBDDC: 419A00F4  beq cr6, 0x821cbed0
	if ctx.cr[6].eq {
	pc = 0x821CBED0; continue 'dispatch;
	}
	// 821CBDE0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821CBDE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CBDE8: 419A0024  beq cr6, 0x821cbe0c
	if ctx.cr[6].eq {
	pc = 0x821CBE0C; continue 'dispatch;
	}
	// 821CBDEC: 894A002C  lbz r10, 0x2c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 821CBDF0: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CBDF4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821CBDF8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821CBDFC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CBE00: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821CBE04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CBE08: 480000CC  b 0x821cbed4
	pc = 0x821CBED4; continue 'dispatch;
            }
            0x821CBE0C => {
    //   block [0x821CBE0C..0x821CBE28)
	// 821CBE0C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CBE10: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821CBE14: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 821CBE18: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821CBE1C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821CBE20: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CBE24: 40810054  ble 0x821cbe78
	if !ctx.cr[0].gt {
	pc = 0x821CBE78; continue 'dispatch;
	}
	pc = 0x821CBE28; continue 'dispatch;
            }
            0x821CBE28 => {
    //   block [0x821CBE28..0x821CBE48)
	// 821CBE28: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821CBE2C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821CBE30: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821CBE34: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBE38: 2F07002C  cmpwi cr6, r7, 0x2c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 44, &mut ctx.xer);
	// 821CBE3C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821CBE40: 41980008  blt cr6, 0x821cbe48
	if ctx.cr[6].lt {
	pc = 0x821CBE48; continue 'dispatch;
	}
	// 821CBE44: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	pc = 0x821CBE48; continue 'dispatch;
            }
            0x821CBE48 => {
    //   block [0x821CBE48..0x821CBE64)
	// 821CBE48: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821CBE4C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821CBE50: 419A0014  beq cr6, 0x821cbe64
	if ctx.cr[6].eq {
	pc = 0x821CBE64; continue 'dispatch;
	}
	// 821CBE54: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821CBE58: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821CBE5C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821CBE60: 4800000C  b 0x821cbe6c
	pc = 0x821CBE6C; continue 'dispatch;
            }
            0x821CBE64 => {
    //   block [0x821CBE64..0x821CBE6C)
	// 821CBE64: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821CBE68: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821CBE6C; continue 'dispatch;
            }
            0x821CBE6C => {
    //   block [0x821CBE6C..0x821CBE78)
	// 821CBE6C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CBE70: 4199FFB8  bgt cr6, 0x821cbe28
	if ctx.cr[6].gt {
	pc = 0x821CBE28; continue 'dispatch;
	}
	// 821CBE74: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x821CBE78; continue 'dispatch;
            }
            0x821CBE78 => {
    //   block [0x821CBE78..0x821CBE94)
	// 821CBE78: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821CBE7C: 419A0040  beq cr6, 0x821cbebc
	if ctx.cr[6].eq {
	pc = 0x821CBEBC; continue 'dispatch;
	}
	// 821CBE80: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBE84: 2F0B002C  cmpwi cr6, r11, 0x2c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 44, &mut ctx.xer);
	// 821CBE88: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CBE8C: 41990008  bgt cr6, 0x821cbe94
	if ctx.cr[6].gt {
	pc = 0x821CBE94; continue 'dispatch;
	}
	// 821CBE90: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x821CBE94; continue 'dispatch;
            }
            0x821CBE94 => {
    //   block [0x821CBE94..0x821CBEBC)
	// 821CBE94: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CBE98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CBE9C: 409A0020  bne cr6, 0x821cbebc
	if !ctx.cr[6].eq {
	pc = 0x821CBEBC; continue 'dispatch;
	}
	// 821CBEA0: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821CBEA4: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821CBEA8: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821CBEAC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CBEB0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821CBEB4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CBEB8: 4800001C  b 0x821cbed4
	pc = 0x821CBED4; continue 'dispatch;
            }
            0x821CBEBC => {
    //   block [0x821CBEBC..0x821CBED0)
	// 821CBEBC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821CBEC0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CBEC4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821CBEC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CBECC: 48000008  b 0x821cbed4
	pc = 0x821CBED4; continue 'dispatch;
            }
            0x821CBED0 => {
    //   block [0x821CBED0..0x821CBED4)
	// 821CBED0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x821CBED4; continue 'dispatch;
            }
            0x821CBED4 => {
    //   block [0x821CBED4..0x821CBEEC)
	// 821CBED4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CBED8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CBEDC: 419A0010  beq cr6, 0x821cbeec
	if ctx.cr[6].eq {
	pc = 0x821CBEEC; continue 'dispatch;
	}
	// 821CBEE0: 816A0064  lwz r11, 0x64(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(100 as u32) ) } as u64;
	// 821CBEE4: 6169000F  ori r9, r11, 0xf
	ctx.r[9].u64 = ctx.r[11].u64 | 15;
	// 821CBEE8: 912A0064  stw r9, 0x64(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	pc = 0x821CBEEC; continue 'dispatch;
            }
            0x821CBEEC => {
    //   block [0x821CBEEC..0x821CBF2C)
	// 821CBEEC: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBEF0: C0230028  lfs f1, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821CBEF4: 48107755  bl 0x822d3648
	ctx.lr = 0x821CBEF8;
	sub_822D3648(ctx, base);
	// 821CBEF8: C01B0060  lfs f0, 0x60(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821CBEFC: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 821CBF00: 40990090  ble cr6, 0x821cbf90
	if !ctx.cr[6].gt {
	pc = 0x821CBF90; continue 'dispatch;
	}
	// 821CBF04: 809B0020  lwz r4, 0x20(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 821CBF08: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821CBF0C: 419A005C  beq cr6, 0x821cbf68
	if ctx.cr[6].eq {
	pc = 0x821CBF68; continue 'dispatch;
	}
	// 821CBF10: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821CBF14: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 821CBF18: 480E2109  bl 0x822ae020
	ctx.lr = 0x821CBF1C;
	sub_822AE020(ctx, base);
	// 821CBF1C: 807B0020  lwz r3, 0x20(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 821CBF20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CBF24: 419A0040  beq cr6, 0x821cbf64
	if ctx.cr[6].eq {
	pc = 0x821CBF64; continue 'dispatch;
	}
	// 821CBF28: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x821CBF2C; continue 'dispatch;
            }
            0x821CBF2C => {
    //   block [0x821CBF2C..0x821CBF60)
	// 821CBF2C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821CBF30: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CBF34: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821CBF38: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821CBF3C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821CBF40: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CBF44: 4082FFE8  bne 0x821cbf2c
	if !ctx.cr[0].eq {
	pc = 0x821CBF2C; continue 'dispatch;
	}
	// 821CBF48: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CBF4C: 409A0014  bne cr6, 0x821cbf60
	if !ctx.cr[6].eq {
	pc = 0x821CBF60; continue 'dispatch;
	}
	// 821CBF50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBF54: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CBF58: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CBF5C: 4E800421  bctrl
	ctx.lr = 0x821CBF60;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821CBF60 => {
    //   block [0x821CBF60..0x821CBF64)
	// 821CBF60: 935B0020  stw r26, 0x20(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[26].u32 ) };
	pc = 0x821CBF64; continue 'dispatch;
            }
            0x821CBF64 => {
    //   block [0x821CBF64..0x821CBF68)
	// 821CBF64: 935B0020  stw r26, 0x20(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[26].u32 ) };
	pc = 0x821CBF68; continue 'dispatch;
            }
            0x821CBF68 => {
    //   block [0x821CBF68..0x821CBF90)
	// 821CBF68: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBF6C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBF70: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CBF74: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CBF78: 4E800421  bctrl
	ctx.lr = 0x821CBF7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CBF7C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821CBF80: 4BFEBB99  bl 0x821b7b18
	ctx.lr = 0x821CBF84;
	sub_821B7B18(ctx, base);
	// 821CBF84: 935C0000  stw r26, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 821CBF88: 93DB006C  stw r30, 0x6c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 821CBF8C: 4800001C  b 0x821cbfa8
	pc = 0x821CBFA8; continue 'dispatch;
            }
            0x821CBF90 => {
    //   block [0x821CBF90..0x821CBFA8)
	// 821CBF90: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBF94: FC200090  fmr f1, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[0].f64;
	// 821CBF98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBF9C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821CBFA0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CBFA4: 4E800421  bctrl
	ctx.lr = 0x821CBFA8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821CBFA8 => {
    //   block [0x821CBFA8..0x821CC010)
	// 821CBFA8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CBFAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CBFB0: 409A049C  bne cr6, 0x821cc44c
	if !ctx.cr[6].eq {
	pc = 0x821CC44C; continue 'dispatch;
	}
	// 821CBFB4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821CBFB8: 815B006C  lwz r10, 0x6c(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(108 as u32) ) } as u64;
	// 821CBFBC: 816BE3BC  lwz r11, -0x1c44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7236 as u32) ) } as u64;
	// 821CBFC0: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821CBFC4: 7F1E5000  cmpw cr6, r30, r10
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821CBFC8: 40990484  ble cr6, 0x821cc44c
	if !ctx.cr[6].gt {
	pc = 0x821CC44C; continue 'dispatch;
	}
	// 821CBFCC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CBFD0: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 821CBFD4: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821CBFD8: 55495FFE  rlwinm r9, r10, 0xb, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x001FFFFFu64;
	// 821CBFDC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821CBFE0: 419A00F4  beq cr6, 0x821cc0d4
	if ctx.cr[6].eq {
	pc = 0x821CC0D4; continue 'dispatch;
	}
	// 821CBFE4: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821CBFE8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CBFEC: 419A0024  beq cr6, 0x821cc010
	if ctx.cr[6].eq {
	pc = 0x821CC010; continue 'dispatch;
	}
	// 821CBFF0: 894A0015  lbz r10, 0x15(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 821CBFF4: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CBFF8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821CBFFC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821CC000: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CC004: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821CC008: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CC00C: 480000CC  b 0x821cc0d8
	pc = 0x821CC0D8; continue 'dispatch;
            }
            0x821CC010 => {
    //   block [0x821CC010..0x821CC02C)
	// 821CC010: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CC014: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821CC018: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 821CC01C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821CC020: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821CC024: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CC028: 40810054  ble 0x821cc07c
	if !ctx.cr[0].gt {
	pc = 0x821CC07C; continue 'dispatch;
	}
	pc = 0x821CC02C; continue 'dispatch;
            }
            0x821CC02C => {
    //   block [0x821CC02C..0x821CC04C)
	// 821CC02C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821CC030: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821CC034: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821CC038: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CC03C: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 821CC040: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821CC044: 41980008  blt cr6, 0x821cc04c
	if ctx.cr[6].lt {
	pc = 0x821CC04C; continue 'dispatch;
	}
	// 821CC048: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	pc = 0x821CC04C; continue 'dispatch;
            }
            0x821CC04C => {
    //   block [0x821CC04C..0x821CC068)
	// 821CC04C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821CC050: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821CC054: 419A0014  beq cr6, 0x821cc068
	if ctx.cr[6].eq {
	pc = 0x821CC068; continue 'dispatch;
	}
	// 821CC058: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821CC05C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821CC060: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821CC064: 4800000C  b 0x821cc070
	pc = 0x821CC070; continue 'dispatch;
            }
            0x821CC068 => {
    //   block [0x821CC068..0x821CC070)
	// 821CC068: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821CC06C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821CC070; continue 'dispatch;
            }
            0x821CC070 => {
    //   block [0x821CC070..0x821CC07C)
	// 821CC070: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CC074: 4199FFB8  bgt cr6, 0x821cc02c
	if ctx.cr[6].gt {
	pc = 0x821CC02C; continue 'dispatch;
	}
	// 821CC078: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x821CC07C; continue 'dispatch;
            }
            0x821CC07C => {
    //   block [0x821CC07C..0x821CC098)
	// 821CC07C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821CC080: 419A0040  beq cr6, 0x821cc0c0
	if ctx.cr[6].eq {
	pc = 0x821CC0C0; continue 'dispatch;
	}
	// 821CC084: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CC088: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 821CC08C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CC090: 41990008  bgt cr6, 0x821cc098
	if ctx.cr[6].gt {
	pc = 0x821CC098; continue 'dispatch;
	}
	// 821CC094: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x821CC098; continue 'dispatch;
            }
            0x821CC098 => {
    //   block [0x821CC098..0x821CC0C0)
	// 821CC098: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CC09C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CC0A0: 409A0020  bne cr6, 0x821cc0c0
	if !ctx.cr[6].eq {
	pc = 0x821CC0C0; continue 'dispatch;
	}
	// 821CC0A4: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821CC0A8: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821CC0AC: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821CC0B0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CC0B4: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821CC0B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CC0BC: 4800001C  b 0x821cc0d8
	pc = 0x821CC0D8; continue 'dispatch;
            }
            0x821CC0C0 => {
    //   block [0x821CC0C0..0x821CC0D4)
	// 821CC0C0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821CC0C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CC0C8: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821CC0CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CC0D0: 48000008  b 0x821cc0d8
	pc = 0x821CC0D8; continue 'dispatch;
            }
            0x821CC0D4 => {
    //   block [0x821CC0D4..0x821CC0D8)
	// 821CC0D4: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x821CC0D8; continue 'dispatch;
            }
            0x821CC0D8 => {
    //   block [0x821CC0D8..0x821CC10C)
	// 821CC0D8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CC0DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CC0E0: 419A0244  beq cr6, 0x821cc324
	if ctx.cr[6].eq {
	pc = 0x821CC324; continue 'dispatch;
	}
	// 821CC0E4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821CC0E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821CC0EC: 48029235  bl 0x821f5320
	ctx.lr = 0x821CC0F0;
	sub_821F5320(ctx, base);
	// 821CC0F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CC0F4: 419A0018  beq cr6, 0x821cc10c
	if ctx.cr[6].eq {
	pc = 0x821CC10C; continue 'dispatch;
	}
	// 821CC0F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CC0FC: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821CC100: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CC104: 4E800421  bctrl
	ctx.lr = 0x821CC108;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CC108: 48000008  b 0x821cc110
	pc = 0x821CC110; continue 'dispatch;
            }
            0x821CC10C => {
    //   block [0x821CC10C..0x821CC110)
	// 821CC10C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x821CC110; continue 'dispatch;
            }
            0x821CC110 => {
    //   block [0x821CC110..0x821CC178)
	// 821CC110: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821CC114: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CC118: 419A020C  beq cr6, 0x821cc324
	if ctx.cr[6].eq {
	pc = 0x821CC324; continue 'dispatch;
	}
	// 821CC11C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821CC120: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821CC124: 3BEB222C  addi r31, r11, 0x222c
	ctx.r[31].s64 = ctx.r[11].s64 + 8748;
	// 821CC128: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821CC12C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CC130: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 821CC134: 48060D9D  bl 0x8222ced0
	ctx.lr = 0x821CC138;
	sub_8222CED0(ctx, base);
	// 821CC138: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CC13C: 814B0038  lwz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 821CC140: 55495FFE  rlwinm r9, r10, 0xb, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x001FFFFFu64;
	// 821CC144: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821CC148: 419A00F4  beq cr6, 0x821cc23c
	if ctx.cr[6].eq {
	pc = 0x821CC23C; continue 'dispatch;
	}
	// 821CC14C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821CC150: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CC154: 419A0024  beq cr6, 0x821cc178
	if ctx.cr[6].eq {
	pc = 0x821CC178; continue 'dispatch;
	}
	// 821CC158: 892A00B5  lbz r9, 0xb5(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(181 as u32) ) } as u64;
	// 821CC15C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CC160: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 821CC164: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821CC168: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CC16C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821CC170: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CC174: 480000CC  b 0x821cc240
	pc = 0x821CC240; continue 'dispatch;
            }
            0x821CC178 => {
    //   block [0x821CC178..0x821CC194)
	// 821CC178: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CC17C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821CC180: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 821CC184: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821CC188: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821CC18C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CC190: 40810054  ble 0x821cc1e4
	if !ctx.cr[0].gt {
	pc = 0x821CC1E4; continue 'dispatch;
	}
	pc = 0x821CC194; continue 'dispatch;
            }
            0x821CC194 => {
    //   block [0x821CC194..0x821CC1B4)
	// 821CC194: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821CC198: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821CC19C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821CC1A0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CC1A4: 2F0700B5  cmpwi cr6, r7, 0xb5
	ctx.cr[6].compare_i32(ctx.r[7].s32, 181, &mut ctx.xer);
	// 821CC1A8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821CC1AC: 41980008  blt cr6, 0x821cc1b4
	if ctx.cr[6].lt {
	pc = 0x821CC1B4; continue 'dispatch;
	}
	// 821CC1B0: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	pc = 0x821CC1B4; continue 'dispatch;
            }
            0x821CC1B4 => {
    //   block [0x821CC1B4..0x821CC1D0)
	// 821CC1B4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821CC1B8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821CC1BC: 419A0014  beq cr6, 0x821cc1d0
	if ctx.cr[6].eq {
	pc = 0x821CC1D0; continue 'dispatch;
	}
	// 821CC1C0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821CC1C4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821CC1C8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821CC1CC: 4800000C  b 0x821cc1d8
	pc = 0x821CC1D8; continue 'dispatch;
            }
            0x821CC1D0 => {
    //   block [0x821CC1D0..0x821CC1D8)
	// 821CC1D0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821CC1D4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821CC1D8; continue 'dispatch;
            }
            0x821CC1D8 => {
    //   block [0x821CC1D8..0x821CC1E4)
	// 821CC1D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CC1DC: 4199FFB8  bgt cr6, 0x821cc194
	if ctx.cr[6].gt {
	pc = 0x821CC194; continue 'dispatch;
	}
	// 821CC1E0: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x821CC1E4; continue 'dispatch;
            }
            0x821CC1E4 => {
    //   block [0x821CC1E4..0x821CC200)
	// 821CC1E4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821CC1E8: 419A0040  beq cr6, 0x821cc228
	if ctx.cr[6].eq {
	pc = 0x821CC228; continue 'dispatch;
	}
	// 821CC1EC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CC1F0: 2F0B00B5  cmpwi cr6, r11, 0xb5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 181, &mut ctx.xer);
	// 821CC1F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CC1F8: 41990008  bgt cr6, 0x821cc200
	if ctx.cr[6].gt {
	pc = 0x821CC200; continue 'dispatch;
	}
	// 821CC1FC: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x821CC200; continue 'dispatch;
            }
            0x821CC200 => {
    //   block [0x821CC200..0x821CC228)
	// 821CC200: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CC204: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CC208: 409A0020  bne cr6, 0x821cc228
	if !ctx.cr[6].eq {
	pc = 0x821CC228; continue 'dispatch;
	}
	// 821CC20C: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821CC210: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821CC214: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821CC218: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CC21C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821CC220: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CC224: 4800001C  b 0x821cc240
	pc = 0x821CC240; continue 'dispatch;
            }
            0x821CC228 => {
    //   block [0x821CC228..0x821CC23C)
	// 821CC228: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821CC22C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CC230: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821CC234: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CC238: 48000008  b 0x821cc240
	pc = 0x821CC240; continue 'dispatch;
            }
            0x821CC23C => {
    //   block [0x821CC23C..0x821CC240)
	// 821CC23C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x821CC240; continue 'dispatch;
            }
            0x821CC240 => {
    //   block [0x821CC240..0x821CC290)
	// 821CC240: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CC244: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CC248: 419A0048  beq cr6, 0x821cc290
	if ctx.cr[6].eq {
	pc = 0x821CC290; continue 'dispatch;
	}
	// 821CC24C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CC250: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821CC254: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821CC258: 48060C79  bl 0x8222ced0
	ctx.lr = 0x821CC25C;
	sub_8222CED0(ctx, base);
	// 821CC25C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CC260: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821CC264: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821CC268: 48060C69  bl 0x8222ced0
	ctx.lr = 0x821CC26C;
	sub_8222CED0(ctx, base);
	// 821CC26C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821CC270: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 821CC274: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821CC278: 3AE00003  li r23, 3
	ctx.r[23].s64 = 3;
	// 821CC27C: 4825552D  bl 0x824217a8
	ctx.lr = 0x821CC280;
	sub_824217A8(ctx, base);
	// 821CC280: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821CC284: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CC288: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CC28C: 409A0008  bne cr6, 0x821cc294
	if !ctx.cr[6].eq {
	pc = 0x821CC294; continue 'dispatch;
	}
	pc = 0x821CC290; continue 'dispatch;
            }
            0x821CC290 => {
    //   block [0x821CC290..0x821CC294)
	// 821CC290: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x821CC294; continue 'dispatch;
            }
            0x821CC294 => {
    //   block [0x821CC294..0x821CC2B0)
	// 821CC294: 56EA07BC  rlwinm r10, r23, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[23].u32 as u64 & 0xFFFFFFFFu64;
	// 821CC298: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CC29C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821CC2A0: 419A0010  beq cr6, 0x821cc2b0
	if ctx.cr[6].eq {
	pc = 0x821CC2B0; continue 'dispatch;
	}
	// 821CC2A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821CC2A8: 56F707FA  rlwinm r23, r23, 0, 0x1f, 0x1d
	ctx.r[23].u64 = ctx.r[23].u32 as u64 & 0xFFFFFFFFu64;
	// 821CC2AC: 48048B2D  bl 0x82214dd8
	ctx.lr = 0x821CC2B0;
	sub_82214DD8(ctx, base);
	pc = 0x821CC2B0; continue 'dispatch;
            }
            0x821CC2B0 => {
    //   block [0x821CC2B0..0x821CC2C4)
	// 821CC2B0: 56EB07FE  clrlwi r11, r23, 0x1f
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0x00000001u64;
	// 821CC2B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CC2B8: 419A000C  beq cr6, 0x821cc2c4
	if ctx.cr[6].eq {
	pc = 0x821CC2C4; continue 'dispatch;
	}
	// 821CC2BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821CC2C0: 48048B19  bl 0x82214dd8
	ctx.lr = 0x821CC2C4;
	sub_82214DD8(ctx, base);
	pc = 0x821CC2C4; continue 'dispatch;
            }
            0x821CC2C4 => {
    //   block [0x821CC2C4..0x821CC2F0)
	// 821CC2C4: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 821CC2C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CC2CC: 419A0024  beq cr6, 0x821cc2f0
	if ctx.cr[6].eq {
	pc = 0x821CC2F0; continue 'dispatch;
	}
	// 821CC2D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821CC2D4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821CC2D8: 486D34B9  bl 0x8289f790
	ctx.lr = 0x821CC2DC;
	sub_8289F790(ctx, base);
	// 821CC2DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821CC2E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821CC2E4: 48098EBD  bl 0x822651a0
	ctx.lr = 0x821CC2E8;
	sub_822651A0(ctx, base);
	// 821CC2E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821CC2EC: 48048AED  bl 0x82214dd8
	ctx.lr = 0x821CC2F0;
	sub_82214DD8(ctx, base);
	pc = 0x821CC2F0; continue 'dispatch;
            }
            0x821CC2F0 => {
    //   block [0x821CC2F0..0x821CC324)
	// 821CC2F0: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 821CC2F4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821CC2F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821CC2FC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821CC300: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821CC304: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821CC308: 480B7A29  bl 0x82283d30
	ctx.lr = 0x821CC30C;
	sub_82283D30(ctx, base);
	// 821CC30C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821CC310: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821CC314: 480A6D45  bl 0x82273058
	ctx.lr = 0x821CC318;
	sub_82273058(ctx, base);
	// 821CC318: D3BB0060  stfs f29, 0x60(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821CC31C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821CC320: 48048AB9  bl 0x82214dd8
	ctx.lr = 0x821CC324;
	sub_82214DD8(ctx, base);
	pc = 0x821CC324; continue 'dispatch;
            }
            0x821CC324 => {
    //   block [0x821CC324..0x821CC354)
	// 821CC324: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CC328: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CC32C: 419A0120  beq cr6, 0x821cc44c
	if ctx.cr[6].eq {
	pc = 0x821CC44C; continue 'dispatch;
	}
	// 821CC330: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 821CC334: 48052F25  bl 0x8221f258
	ctx.lr = 0x821CC338;
	sub_8221F258(ctx, base);
	// 821CC338: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CC33C: 419A0018  beq cr6, 0x821cc354
	if ctx.cr[6].eq {
	pc = 0x821CC354; continue 'dispatch;
	}
	// 821CC340: C01822AC  lfs f0, 0x22ac(r24)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8876 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821CC344: EC20F824  fdivs f1, f0, f31
	ctx.f[1].f64 = ((ctx.f[0].f64 / ctx.f[31].f64) as f32) as f64;
	// 821CC348: 480BF7F9  bl 0x8228bb40
	ctx.lr = 0x821CC34C;
	sub_8228BB40(ctx, base);
	// 821CC34C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 821CC350: 48000008  b 0x821cc358
	pc = 0x821CC358; continue 'dispatch;
            }
            0x821CC354 => {
    //   block [0x821CC354..0x821CC358)
	// 821CC354: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	pc = 0x821CC358; continue 'dispatch;
            }
            0x821CC358 => {
    //   block [0x821CC358..0x821CC394)
	// 821CC358: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821CC35C: 80BC0000  lwz r5, 0(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CC360: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 821CC364: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821CC368: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821CC36C: 48001DD5  bl 0x821ce140
	ctx.lr = 0x821CC370;
	sub_821CE140(ctx, base);
	// 821CC370: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821CC374: 817B0020  lwz r11, 0x20(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 821CC378: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CC37C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821CC380: 419A007C  beq cr6, 0x821cc3fc
	if ctx.cr[6].eq {
	pc = 0x821CC3FC; continue 'dispatch;
	}
	// 821CC384: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821CC388: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CC38C: 419A0040  beq cr6, 0x821cc3cc
	if ctx.cr[6].eq {
	pc = 0x821CC3CC; continue 'dispatch;
	}
	// 821CC390: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x821CC394; continue 'dispatch;
            }
            0x821CC394 => {
    //   block [0x821CC394..0x821CC3C8)
	// 821CC394: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821CC398: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CC39C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821CC3A0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821CC3A4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821CC3A8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CC3AC: 4082FFE8  bne 0x821cc394
	if !ctx.cr[0].eq {
	pc = 0x821CC394; continue 'dispatch;
	}
	// 821CC3B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CC3B4: 409A0014  bne cr6, 0x821cc3c8
	if !ctx.cr[6].eq {
	pc = 0x821CC3C8; continue 'dispatch;
	}
	// 821CC3B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CC3BC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CC3C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CC3C4: 4E800421  bctrl
	ctx.lr = 0x821CC3C8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821CC3C8 => {
    //   block [0x821CC3C8..0x821CC3CC)
	// 821CC3C8: 935B0020  stw r26, 0x20(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[26].u32 ) };
	pc = 0x821CC3CC; continue 'dispatch;
            }
            0x821CC3CC => {
    //   block [0x821CC3CC..0x821CC3E0)
	// 821CC3CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CC3D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CC3D4: 917B0020  stw r11, 0x20(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 821CC3D8: 419A0024  beq cr6, 0x821cc3fc
	if ctx.cr[6].eq {
	pc = 0x821CC3FC; continue 'dispatch;
	}
	// 821CC3DC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x821CC3E0; continue 'dispatch;
            }
            0x821CC3E0 => {
    //   block [0x821CC3E0..0x821CC3FC)
	// 821CC3E0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821CC3E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CC3E8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821CC3EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821CC3F0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821CC3F4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CC3F8: 4082FFE8  bne 0x821cc3e0
	if !ctx.cr[0].eq {
	pc = 0x821CC3E0; continue 'dispatch;
	}
	pc = 0x821CC3FC; continue 'dispatch;
            }
            0x821CC3FC => {
    //   block [0x821CC3FC..0x821CC410)
	// 821CC3FC: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 821CC400: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CC404: 419A0044  beq cr6, 0x821cc448
	if ctx.cr[6].eq {
	pc = 0x821CC448; continue 'dispatch;
	}
	// 821CC408: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821CC40C: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x821CC410; continue 'dispatch;
            }
            0x821CC410 => {
    //   block [0x821CC410..0x821CC448)
	// 821CC410: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821CC414: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CC418: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821CC41C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821CC420: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821CC424: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CC428: 4082FFE8  bne 0x821cc410
	if !ctx.cr[0].eq {
	pc = 0x821CC410; continue 'dispatch;
	}
	// 821CC42C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821CC430: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CC434: 409A0014  bne cr6, 0x821cc448
	if !ctx.cr[6].eq {
	pc = 0x821CC448; continue 'dispatch;
	}
	// 821CC438: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CC43C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CC440: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CC444: 4E800421  bctrl
	ctx.lr = 0x821CC448;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821CC448 => {
    //   block [0x821CC448..0x821CC44C)
	// 821CC448: D3BB0060  stfs f29, 0x60(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(96 as u32), tmp.u32 ) };
	pc = 0x821CC44C; continue 'dispatch;
            }
            0x821CC44C => {
    //   block [0x821CC44C..0x821CC460)
	// 821CC44C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821CC450: CBA1FF98  lfd f29, -0x68(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 821CC454: CBC1FFA0  lfd f30, -0x60(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 821CC458: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 821CC45C: 48ADCFE8  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CC460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CC460 size=1828
    let mut pc: u32 = 0x821CC460;
    'dispatch: loop {
        match pc {
            0x821CC460 => {
    //   block [0x821CC460..0x821CC4C8)
	// 821CC460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CC464: 48ADCF99  bl 0x82ca93fc
	ctx.lr = 0x821CC468;
	sub_82CA93D0(ctx, base);
	// 821CC468: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 821CC46C: 48AE186D  bl 0x82cadcd8
	ctx.lr = 0x821CC470;
	sub_82CADCA0(ctx, base);
	// 821CC470: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CC474: 3F408349  lis r26, -0x7cb7
	ctx.r[26].s64 = -2092367872;
	// 821CC478: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821CC47C: 817A6AB8  lwz r11, 0x6ab8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821CC480: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CC484: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CC488: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 821CC48C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CC490: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CC494: 480662E5  bl 0x82232778
	ctx.lr = 0x821CC498;
	sub_82232778(ctx, base);
	// 821CC498: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821CC49C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821CC4A0: 419A06D4  beq cr6, 0x821ccb74
	if ctx.cr[6].eq {
	pc = 0x821CCB74; continue 'dispatch;
	}
	// 821CC4A4: 817E004C  lwz r11, 0x4c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 821CC4A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CC4AC: 4099001C  ble cr6, 0x821cc4c8
	if !ctx.cr[6].gt {
	pc = 0x821CC4C8; continue 'dispatch;
	}
	// 821CC4B0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CC4B4: 917E004C  stw r11, 0x4c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 821CC4B8: 41810010  bgt 0x821cc4c8
	if ctx.cr[0].gt {
	pc = 0x821CC4C8; continue 'dispatch;
	}
	// 821CC4BC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821CC4C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821CC4C4: 4830BB35  bl 0x824d7ff8
	ctx.lr = 0x821CC4C8;
	sub_824D7FF8(ctx, base);
	pc = 0x821CC4C8; continue 'dispatch;
            }
            0x821CC4C8 => {
    //   block [0x821CC4C8..0x821CC558)
	// 821CC4C8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CC4CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821CC4D0: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821CC4D4: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CC4D8: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821CC4DC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821CC4E0: 4E800421  bctrl
	ctx.lr = 0x821CC4E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CC4E4: 811E0404  lwz r8, 0x404(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1028 as u32) ) } as u64;
	// 821CC4E8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821CC4EC: 3BE003F0  li r31, 0x3f0
	ctx.r[31].s64 = 1008;
	// 821CC4F0: 3B6BB480  addi r27, r11, -0x4b80
	ctx.r[27].s64 = ctx.r[11].s64 + -19328;
	// 821CC4F4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821CC4F8: 40990060  ble cr6, 0x821cc558
	if !ctx.cr[6].gt {
	pc = 0x821CC558; continue 'dispatch;
	}
	// 821CC4FC: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
            }
            0x821CC558 => {
    //   block [0x821CC558..0x821CCB74)
	// 821CC558: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 821CC55C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CC560: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x821CCB74; continue 'dispatch;
            }
            0x821CCB74 => {
    //   block [0x821CCB74..0x821CCB84)
	// 821CCB74: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821CCB78: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 821CCB7C: 48AE11A9  bl 0x82cadd24
	ctx.lr = 0x821CCB80;
	sub_82CADCEC(ctx, base);
	// 821CCB80: 48ADC8CC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CCB88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821CCB88 size=8
    let mut pc: u32 = 0x821CCB88;
    'dispatch: loop {
        match pc {
            0x821CCB88 => {
    //   block [0x821CCB88..0x821CCB90)
	// 821CCB88: C023018C  lfs f1, 0x18c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(396 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821CCB8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CCB90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CCB90 size=120
    let mut pc: u32 = 0x821CCB90;
    'dispatch: loop {
        match pc {
            0x821CCB90 => {
    //   block [0x821CCB90..0x821CCBD0)
	// 821CCB90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CCB94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821CCB98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821CCB9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821CCBA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CCBA4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821CCBA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821CCBAC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CCBB0: 489A3AC1  bl 0x82b70670
	ctx.lr = 0x821CCBB4;
	sub_82B70670(ctx, base);
	// 821CCBB4: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CCBB8: 816A0040  lwz r11, 0x40(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821CCBBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CCBC0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821CCBC4: 814A003C  lwz r10, 0x3c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 821CCBC8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821CCBCC: 419A0020  beq cr6, 0x821ccbec
	if ctx.cr[6].eq {
	pc = 0x821CCBEC; continue 'dispatch;
	}
	pc = 0x821CCBD0; continue 'dispatch;
            }
            0x821CCBD0 => {
    //   block [0x821CCBD0..0x821CCBEC)
	// 821CCBD0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821CCBD4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CCBD8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821CCBDC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821CCBE0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821CCBE4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CCBE8: 4082FFE8  bne 0x821ccbd0
	if !ctx.cr[0].eq {
	pc = 0x821CCBD0; continue 'dispatch;
	}
	pc = 0x821CCBEC; continue 'dispatch;
            }
            0x821CCBEC => {
    //   block [0x821CCBEC..0x821CCC08)
	// 821CCBEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CCBF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821CCBF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821CCBF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821CCBFC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821CCC00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821CCC04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CCC20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CCC20 size=696
    let mut pc: u32 = 0x821CCC20;
    'dispatch: loop {
        match pc {
            0x821CCC20 => {
    //   block [0x821CCC20..0x821CCC54)
	// 821CCC20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CCC24: 48ADC7BD  bl 0x82ca93e0
	ctx.lr = 0x821CCC28;
	sub_82CA93D0(ctx, base);
	// 821CCC28: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CCC2C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 821CCC30: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821CCC34: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 821CCC38: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 821CCC3C: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 821CCC40: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 821CCC44: 3A600004  li r19, 4
	ctx.r[19].s64 = 4;
	// 821CCC48: 3A4B3A44  addi r18, r11, 0x3a44
	ctx.r[18].s64 = ctx.r[11].s64 + 14916;
	// 821CCC4C: 3AAA9700  addi r21, r10, -0x6900
	ctx.r[21].s64 = ctx.r[10].s64 + -26880;
	// 821CCC50: 3A893BB0  addi r20, r9, 0x3bb0
	ctx.r[20].s64 = ctx.r[9].s64 + 15280;
	pc = 0x821CCC54; continue 'dispatch;
            }
            0x821CCC54 => {
    //   block [0x821CCC54..0x821CCC7C)
	// 821CCC54: 39560001  addi r10, r22, 1
	ctx.r[10].s64 = ctx.r[22].s64 + 1;
	// 821CCC58: 8178000C  lwz r11, 0xc(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CCC5C: 3B200002  li r25, 2
	ctx.r[25].s64 = 2;
	// 821CCC60: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821CCC64: 7F4A5A14  add r26, r10, r11
	ctx.r[26].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821CCC68: 817AFFF4  lwz r11, -0xc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12 as u32) ) } as u64;
	// 821CCC6C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821CCC70: 419A000C  beq cr6, 0x821ccc7c
	if ctx.cr[6].eq {
	pc = 0x821CCC7C; continue 'dispatch;
	}
	// 821CCC74: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821CCC78: 409A0024  bne cr6, 0x821ccc9c
	if !ctx.cr[6].eq {
	pc = 0x821CCC9C; continue 'dispatch;
	}
	pc = 0x821CCC7C; continue 'dispatch;
            }
            0x821CCC7C => {
    //   block [0x821CCC7C..0x821CCC9C)
	// 821CCC7C: 817AFFFC  lwz r11, -4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821CCC80: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821CCC84: 419A012C  beq cr6, 0x821ccdb0
	if ctx.cr[6].eq {
	pc = 0x821CCDB0; continue 'dispatch;
	}
	// 821CCC88: 389AFFF8  addi r4, r26, -8
	ctx.r[4].s64 = ctx.r[26].s64 + -8;
	// 821CCC8C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821CCC90: 480D20C9  bl 0x8229ed58
	ctx.lr = 0x821CCC94;
	sub_8229ED58(ctx, base);
	// 821CCC94: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821CCC98: 409A0118  bne cr6, 0x821ccdb0
	if !ctx.cr[6].eq {
	pc = 0x821CCDB0; continue 'dispatch;
	}
	pc = 0x821CCC9C; continue 'dispatch;
            }
            0x821CCC9C => {
    //   block [0x821CCC9C..0x821CCCCC)
	// 821CCC9C: 817AFFF4  lwz r11, -0xc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12 as u32) ) } as u64;
	// 821CCCA0: 38DAFFF0  addi r6, r26, -0x10
	ctx.r[6].s64 = ctx.r[26].s64 + -16;
	// 821CCCA4: 38BAFFF8  addi r5, r26, -8
	ctx.r[5].s64 = ctx.r[26].s64 + -8;
	// 821CCCA8: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 821CCCAC: 419A002C  beq cr6, 0x821cccd8
	if ctx.cr[6].eq {
	pc = 0x821CCCD8; continue 'dispatch;
	}
	// 821CCCB0: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 821CCCB4: 419A0018  beq cr6, 0x821ccccc
	if ctx.cr[6].eq {
	pc = 0x821CCCCC; continue 'dispatch;
	}
	// 821CCCB8: 396B001F  addi r11, r11, 0x1f
	ctx.r[11].s64 = ctx.r[11].s64 + 31;
	// 821CCCBC: 81580010  lwz r10, 0x10(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CCCC0: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821CCCC4: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821CCCC8: 48000018  b 0x821ccce0
	pc = 0x821CCCE0; continue 'dispatch;
            }
            0x821CCCCC => {
    //   block [0x821CCCCC..0x821CCCD8)
	// 821CCCCC: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CCCD0: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CCCD4: 4800000C  b 0x821ccce0
	pc = 0x821CCCE0; continue 'dispatch;
            }
            0x821CCCD8 => {
    //   block [0x821CCCD8..0x821CCCE0)
	// 821CCCD8: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CCCDC: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x821CCCE0; continue 'dispatch;
            }
            0x821CCCE0 => {
    //   block [0x821CCCE0..0x821CCCF8)
	// 821CCCE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CCCE4: 419A0014  beq cr6, 0x821cccf8
	if ctx.cr[6].eq {
	pc = 0x821CCCF8; continue 'dispatch;
	}
	// 821CCCE8: 81780010  lwz r11, 0x10(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CCCEC: 808B00DC  lwz r4, 0xdc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(220 as u32) ) } as u64;
	// 821CCCF0: 4805B781  bl 0x82228470
	ctx.lr = 0x821CCCF4;
	sub_82228470(ctx, base);
	// 821CCCF4: 48000008  b 0x821cccfc
	pc = 0x821CCCFC; continue 'dispatch;
            }
            0x821CCCF8 => {
    //   block [0x821CCCF8..0x821CCCFC)
	// 821CCCF8: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	pc = 0x821CCCFC; continue 'dispatch;
            }
            0x821CCCFC => {
    //   block [0x821CCCFC..0x821CCD30)
	// 821CCCFC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CCD00: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CCD04: 409A005C  bne cr6, 0x821ccd60
	if !ctx.cr[6].eq {
	pc = 0x821CCD60; continue 'dispatch;
	}
	// 821CCD08: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CCD0C: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 821CCD10: 419A002C  beq cr6, 0x821ccd3c
	if ctx.cr[6].eq {
	pc = 0x821CCD3C; continue 'dispatch;
	}
	// 821CCD14: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 821CCD18: 419A0018  beq cr6, 0x821ccd30
	if ctx.cr[6].eq {
	pc = 0x821CCD30; continue 'dispatch;
	}
	// 821CCD1C: 396B001F  addi r11, r11, 0x1f
	ctx.r[11].s64 = ctx.r[11].s64 + 31;
	// 821CCD20: 81580010  lwz r10, 0x10(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CCD24: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821CCD28: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821CCD2C: 48000018  b 0x821ccd44
	pc = 0x821CCD44; continue 'dispatch;
            }
            0x821CCD30 => {
    //   block [0x821CCD30..0x821CCD3C)
	// 821CCD30: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CCD34: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CCD38: 4800000C  b 0x821ccd44
	pc = 0x821CCD44; continue 'dispatch;
            }
            0x821CCD3C => {
    //   block [0x821CCD3C..0x821CCD44)
	// 821CCD3C: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CCD40: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x821CCD44; continue 'dispatch;
            }
            0x821CCD44 => {
    //   block [0x821CCD44..0x821CCD5C)
	// 821CCD44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CCD48: 419A0014  beq cr6, 0x821ccd5c
	if ctx.cr[6].eq {
	pc = 0x821CCD5C; continue 'dispatch;
	}
	// 821CCD4C: 81780010  lwz r11, 0x10(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CCD50: 808B00DC  lwz r4, 0xdc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(220 as u32) ) } as u64;
	// 821CCD54: 4805B71D  bl 0x82228470
	ctx.lr = 0x821CCD58;
	sub_82228470(ctx, base);
	// 821CCD58: 48000008  b 0x821ccd60
	pc = 0x821CCD60; continue 'dispatch;
            }
            0x821CCD5C => {
    //   block [0x821CCD5C..0x821CCD60)
	// 821CCD5C: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	pc = 0x821CCD60; continue 'dispatch;
            }
            0x821CCD60 => {
    //   block [0x821CCD60..0x821CCD84)
	// 821CCD60: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CCD64: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CCD68: 419A001C  beq cr6, 0x821ccd84
	if ctx.cr[6].eq {
	pc = 0x821CCD84; continue 'dispatch;
	}
	// 821CCD6C: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 821CCD70: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821CCD74: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 821CCD78: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821CCD7C: 4886752D  bl 0x82a342a8
	ctx.lr = 0x821CCD80;
	sub_82A342A8(ctx, base);
	// 821CCD80: 48000138  b 0x821cceb8
	pc = 0x821CCEB8; continue 'dispatch;
            }
            0x821CCD84 => {
    //   block [0x821CCD84..0x821CCD9C)
	// 821CCD84: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CCD88: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 821CCD8C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821CCD90: 419A000C  beq cr6, 0x821ccd9c
	if ctx.cr[6].eq {
	pc = 0x821CCD9C; continue 'dispatch;
	}
	// 821CCD94: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821CCD98: 409A0008  bne cr6, 0x821ccda0
	if !ctx.cr[6].eq {
	pc = 0x821CCDA0; continue 'dispatch;
	}
	pc = 0x821CCD9C; continue 'dispatch;
            }
            0x821CCD9C => {
    //   block [0x821CCD9C..0x821CCDA0)
	// 821CCD9C: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	pc = 0x821CCDA0; continue 'dispatch;
            }
            0x821CCDA0 => {
    //   block [0x821CCDA0..0x821CCDB0)
	// 821CCDA0: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 821CCDA4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821CCDA8: 48864EE1  bl 0x82a31c88
	ctx.lr = 0x821CCDAC;
	sub_82A31C88(ctx, base);
	// 821CCDAC: 4800010C  b 0x821cceb8
	pc = 0x821CCEB8; continue 'dispatch;
            }
            0x821CCDB0 => {
    //   block [0x821CCDB0..0x821CCDDC)
	// 821CCDB0: 817AFFF8  lwz r11, -8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821CCDB4: 83CB000C  lwz r30, 0xc(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CCDB8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821CCDBC: 409A0020  bne cr6, 0x821ccddc
	if !ctx.cr[6].eq {
	pc = 0x821CCDDC; continue 'dispatch;
	}
	// 821CCDC0: 817AFFF4  lwz r11, -0xc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-12 as u32) ) } as u64;
	// 821CCDC4: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821CCDC8: 419A00F0  beq cr6, 0x821cceb8
	if ctx.cr[6].eq {
	pc = 0x821CCEB8; continue 'dispatch;
	}
	// 821CCDCC: 389AFFF0  addi r4, r26, -0x10
	ctx.r[4].s64 = ctx.r[26].s64 + -16;
	// 821CCDD0: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821CCDD4: 480D1F85  bl 0x8229ed58
	ctx.lr = 0x821CCDD8;
	sub_8229ED58(ctx, base);
	// 821CCDD8: 480000E0  b 0x821cceb8
	pc = 0x821CCEB8; continue 'dispatch;
            }
            0x821CCDDC => {
    //   block [0x821CCDDC..0x821CCDEC)
	// 821CCDDC: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 821CCDE0: 2F170001  cmpwi cr6, r23, 1
	ctx.cr[6].compare_i32(ctx.r[23].s32, 1, &mut ctx.xer);
	// 821CCDE4: 4099005C  ble cr6, 0x821cce40
	if !ctx.cr[6].gt {
	pc = 0x821CCE40; continue 'dispatch;
	}
	// 821CCDE8: 3BFAFFF0  addi r31, r26, -0x10
	ctx.r[31].s64 = ctx.r[26].s64 + -16;
	pc = 0x821CCDEC; continue 'dispatch;
            }
            0x821CCDEC => {
    //   block [0x821CCDEC..0x821CCE0C)
	// 821CCDEC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CCDF0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821CCDF4: 419A0018  beq cr6, 0x821cce0c
	if ctx.cr[6].eq {
	pc = 0x821CCE0C; continue 'dispatch;
	}
	// 821CCDF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CCDFC: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821CCE00: 480D1F59  bl 0x8229ed58
	ctx.lr = 0x821CCE04;
	sub_8229ED58(ctx, base);
	// 821CCE04: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821CCE08: 419A0038  beq cr6, 0x821cce40
	if ctx.cr[6].eq {
	pc = 0x821CCE40; continue 'dispatch;
	}
	pc = 0x821CCE0C; continue 'dispatch;
            }
            0x821CCE0C => {
    //   block [0x821CCE0C..0x821CCE2C)
	// 821CCE0C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CCE10: 215EFFFD  subfic r10, r30, -3
	ctx.xer.ca = ctx.r[30].u32 <= -3 as u32;
	ctx.r[10].s64 = (-3 as i64) - ctx.r[30].s64;
	// 821CCE14: 83AB000C  lwz r29, 0xc(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CCE18: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821CCE1C: 41980010  blt cr6, 0x821cce2c
	if ctx.cr[6].lt {
	pc = 0x821CCE2C; continue 'dispatch;
	}
	// 821CCE20: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 821CCE24: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821CCE28: 48865081  bl 0x82a31ea8
	ctx.lr = 0x821CCE2C;
	sub_82A31EA8(ctx, base);
	pc = 0x821CCE2C; continue 'dispatch;
            }
            0x821CCE2C => {
    //   block [0x821CCE2C..0x821CCE40)
	// 821CCE2C: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 821CCE30: 7FDDF214  add r30, r29, r30
	ctx.r[30].u64 = ctx.r[29].u64 + ctx.r[30].u64;
	// 821CCE34: 3BFFFFF8  addi r31, r31, -8
	ctx.r[31].s64 = ctx.r[31].s64 + -8;
	// 821CCE38: 7F19B800  cmpw cr6, r25, r23
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[23].s32, &mut ctx.xer);
	// 821CCE3C: 4198FFB0  blt cr6, 0x821ccdec
	if ctx.cr[6].lt {
	pc = 0x821CCDEC; continue 'dispatch;
	}
	pc = 0x821CCE40; continue 'dispatch;
            }
            0x821CCE40 => {
    //   block [0x821CCE40..0x821CCE70)
	// 821CCE40: 81780010  lwz r11, 0x10(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CCE44: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821CCE48: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821CCE4C: 388B0034  addi r4, r11, 0x34
	ctx.r[4].s64 = ctx.r[11].s64 + 52;
	// 821CCE50: 4BFE5721  bl 0x821b2570
	ctx.lr = 0x821CCE54;
	sub_821B2570(ctx, base);
	// 821CCE54: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821CCE58: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821CCE5C: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 821CCE60: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 821CCE64: 40990034  ble cr6, 0x821cce98
	if !ctx.cr[6].gt {
	pc = 0x821CCE98; continue 'dispatch;
	}
	// 821CCE68: 572B1838  slwi r11, r25, 3
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821CCE6C: 7FABD050  subf r29, r11, r26
	ctx.r[29].s64 = ctx.r[26].s64 - ctx.r[11].s64;
	pc = 0x821CCE70; continue 'dispatch;
            }
            0x821CCE70 => {
    //   block [0x821CCE70..0x821CCE98)
	// 821CCE70: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CCE74: 7C7BFA14  add r3, r27, r31
	ctx.r[3].u64 = ctx.r[27].u64 + ctx.r[31].u64;
	// 821CCE78: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 821CCE7C: 838B000C  lwz r28, 0xc(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CCE80: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821CCE84: 48ADC5FD  bl 0x82ca9480
	ctx.lr = 0x821CCE88;
	sub_82CA9480(ctx, base);
	// 821CCE88: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821CCE8C: 7FFCFA14  add r31, r28, r31
	ctx.r[31].u64 = ctx.r[28].u64 + ctx.r[31].u64;
	// 821CCE90: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 821CCE94: 4181FFDC  bgt 0x821cce70
	if ctx.cr[0].gt {
	pc = 0x821CCE70; continue 'dispatch;
	}
	pc = 0x821CCE98; continue 'dispatch;
            }
            0x821CCE98 => {
    //   block [0x821CCE98..0x821CCEB8)
	// 821CCE98: 572B1838  slwi r11, r25, 3
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821CCE9C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821CCEA0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821CCEA4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821CCEA8: 7FEBD050  subf r31, r11, r26
	ctx.r[31].s64 = ctx.r[26].s64 - ctx.r[11].s64;
	// 821CCEAC: 4805AEF5  bl 0x82227da0
	ctx.lr = 0x821CCEB0;
	sub_82227DA0(ctx, base);
	// 821CCEB0: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821CCEB4: 927F0004  stw r19, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[19].u32 ) };
	pc = 0x821CCEB8; continue 'dispatch;
            }
            0x821CCEB8 => {
    //   block [0x821CCEB8..0x821CCED8)
	// 821CCEB8: 7D59B850  subf r10, r25, r23
	ctx.r[10].s64 = ctx.r[23].s64 - ctx.r[25].s64;
	// 821CCEBC: 7D79B050  subf r11, r25, r22
	ctx.r[11].s64 = ctx.r[22].s64 - ctx.r[25].s64;
	// 821CCEC0: 3AEA0001  addi r23, r10, 1
	ctx.r[23].s64 = ctx.r[10].s64 + 1;
	// 821CCEC4: 3ACB0001  addi r22, r11, 1
	ctx.r[22].s64 = ctx.r[11].s64 + 1;
	// 821CCEC8: 2F170001  cmpwi cr6, r23, 1
	ctx.cr[6].compare_i32(ctx.r[23].s32, 1, &mut ctx.xer);
	// 821CCECC: 4199FD88  bgt cr6, 0x821ccc54
	if ctx.cr[6].gt {
	pc = 0x821CCC54; continue 'dispatch;
	}
	// 821CCED0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821CCED4: 48ADC55C  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CCED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CCED8 size=1076
    let mut pc: u32 = 0x821CCED8;
    'dispatch: loop {
        match pc {
            0x821CCED8 => {
    //   block [0x821CCED8..0x821CCF04)
	// 821CCED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CCEDC: 48ADC509  bl 0x82ca93e4
	ctx.lr = 0x821CCEE0;
	sub_82CA93D0(ctx, base);
	// 821CCEE0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CCEE4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821CCEE8: 7C932378  mr r19, r4
	ctx.r[19].u64 = ctx.r[4].u64;
	// 821CCEEC: 817B0020  lwz r11, 0x20(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 821CCEF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CCEF4: 419A0094  beq cr6, 0x821ccf88
	if ctx.cr[6].eq {
	pc = 0x821CCF88; continue 'dispatch;
	}
	// 821CCEF8: 817B001C  lwz r11, 0x1c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 821CCEFC: 3BDB0018  addi r30, r27, 0x18
	ctx.r[30].s64 = ctx.r[27].s64 + 24;
	// 821CCF00: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821CCF04; continue 'dispatch;
            }
            0x821CCF04 => {
    //   block [0x821CCF04..0x821CCF14)
	// 821CCF04: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CCF08: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821CCF0C: 419A0008  beq cr6, 0x821ccf14
	if ctx.cr[6].eq {
	pc = 0x821CCF14; continue 'dispatch;
	}
	// 821CCF10: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821CCF14; continue 'dispatch;
            }
            0x821CCF14 => {
    //   block [0x821CCF14..0x821CCF2C)
	// 821CCF14: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CCF18: 419A0068  beq cr6, 0x821ccf80
	if ctx.cr[6].eq {
	pc = 0x821CCF80; continue 'dispatch;
	}
	// 821CCF1C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CCF20: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CCF24: 409A0008  bne cr6, 0x821ccf2c
	if !ctx.cr[6].eq {
	pc = 0x821CCF2C; continue 'dispatch;
	}
	// 821CCF28: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821CCF2C; continue 'dispatch;
            }
            0x821CCF2C => {
    //   block [0x821CCF2C..0x821CCF4C)
	// 821CCF2C: 3BBF0008  addi r29, r31, 8
	ctx.r[29].s64 = ctx.r[31].s64 + 8;
	// 821CCF30: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821CCF34: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821CCF38: 4819D1A9  bl 0x8236a0e0
	ctx.lr = 0x821CCF3C;
	sub_8236A0E0(ctx, base);
	// 821CCF3C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CCF40: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CCF44: 409A0008  bne cr6, 0x821ccf4c
	if !ctx.cr[6].eq {
	pc = 0x821CCF4C; continue 'dispatch;
	}
	// 821CCF48: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821CCF4C; continue 'dispatch;
            }
            0x821CCF4C => {
    //   block [0x821CCF4C..0x821CCF78)
	// 821CCF4C: 817B0040  lwz r11, 0x40(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(64 as u32) ) } as u64;
	// 821CCF50: 387B003C  addi r3, r27, 0x3c
	ctx.r[3].s64 = ctx.r[27].s64 + 60;
	// 821CCF54: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821CCF58: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 821CCF5C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821CCF60: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821CCF64: 4897CE1D  bl 0x82b49d80
	ctx.lr = 0x821CCF68;
	sub_82B49D80(ctx, base);
	// 821CCF68: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CCF6C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821CCF70: 409A0008  bne cr6, 0x821ccf78
	if !ctx.cr[6].eq {
	pc = 0x821CCF78; continue 'dispatch;
	}
	// 821CCF74: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821CCF78; continue 'dispatch;
            }
            0x821CCF78 => {
    //   block [0x821CCF78..0x821CCF80)
	// 821CCF78: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CCF7C: 4BFFFF88  b 0x821ccf04
	pc = 0x821CCF04; continue 'dispatch;
            }
            0x821CCF80 => {
    //   block [0x821CCF80..0x821CCF88)
	// 821CCF80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821CCF84: 48847E0D  bl 0x82a14d90
	ctx.lr = 0x821CCF88;
	sub_82A14D90(ctx, base);
	pc = 0x821CCF88; continue 'dispatch;
            }
            0x821CCF88 => {
    //   block [0x821CCF88..0x821CCFA8)
	// 821CCF88: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821CCF8C: 48103D05  bl 0x822d0c90
	ctx.lr = 0x821CCF90;
	sub_822D0C90(ctx, base);
	// 821CCF90: 817B0044  lwz r11, 0x44(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(68 as u32) ) } as u64;
	// 821CCF94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CCF98: 419A0064  beq cr6, 0x821ccffc
	if ctx.cr[6].eq {
	pc = 0x821CCFFC; continue 'dispatch;
	}
	// 821CCF9C: 817B0040  lwz r11, 0x40(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(64 as u32) ) } as u64;
	// 821CCFA0: 3BDB003C  addi r30, r27, 0x3c
	ctx.r[30].s64 = ctx.r[27].s64 + 60;
	// 821CCFA4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821CCFA8; continue 'dispatch;
            }
            0x821CCFA8 => {
    //   block [0x821CCFA8..0x821CCFB8)
	// 821CCFA8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CCFAC: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821CCFB0: 419A0008  beq cr6, 0x821ccfb8
	if ctx.cr[6].eq {
	pc = 0x821CCFB8; continue 'dispatch;
	}
	// 821CCFB4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821CCFB8; continue 'dispatch;
            }
            0x821CCFB8 => {
    //   block [0x821CCFB8..0x821CCFD0)
	// 821CCFB8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CCFBC: 419A0038  beq cr6, 0x821ccff4
	if ctx.cr[6].eq {
	pc = 0x821CCFF4; continue 'dispatch;
	}
	// 821CCFC0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CCFC4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CCFC8: 409A0008  bne cr6, 0x821ccfd0
	if !ctx.cr[6].eq {
	pc = 0x821CCFD0; continue 'dispatch;
	}
	// 821CCFCC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821CCFD0; continue 'dispatch;
            }
            0x821CCFD0 => {
    //   block [0x821CCFD0..0x821CCFEC)
	// 821CCFD0: 389F0008  addi r4, r31, 8
	ctx.r[4].s64 = ctx.r[31].s64 + 8;
	// 821CCFD4: 387B0024  addi r3, r27, 0x24
	ctx.r[3].s64 = ctx.r[27].s64 + 36;
	// 821CCFD8: 4819D109  bl 0x8236a0e0
	ctx.lr = 0x821CCFDC;
	sub_8236A0E0(ctx, base);
	// 821CCFDC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CCFE0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CCFE4: 409A0008  bne cr6, 0x821ccfec
	if !ctx.cr[6].eq {
	pc = 0x821CCFEC; continue 'dispatch;
	}
	// 821CCFE8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821CCFEC; continue 'dispatch;
            }
            0x821CCFEC => {
    //   block [0x821CCFEC..0x821CCFF4)
	// 821CCFEC: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CCFF0: 4BFFFFB8  b 0x821ccfa8
	pc = 0x821CCFA8; continue 'dispatch;
            }
            0x821CCFF4 => {
    //   block [0x821CCFF4..0x821CCFFC)
	// 821CCFF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821CCFF8: 48847D99  bl 0x82a14d90
	ctx.lr = 0x821CCFFC;
	sub_82A14D90(ctx, base);
	pc = 0x821CCFFC; continue 'dispatch;
            }
            0x821CCFFC => {
    //   block [0x821CCFFC..0x821CD064)
	// 821CCFFC: 817B0038  lwz r11, 0x38(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(56 as u32) ) } as u64;
	// 821CD000: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 821CD004: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CD008: 419A005C  beq cr6, 0x821cd064
	if ctx.cr[6].eq {
	pc = 0x821CD064; continue 'dispatch;
	}
	// 821CD00C: 817B0034  lwz r11, 0x34(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(52 as u32) ) } as u64;
	// 821CD010: 3BFB0030  addi r31, r27, 0x30
	ctx.r[31].s64 = ctx.r[27].s64 + 48;
	// 821CD014: 3BDB0024  addi r30, r27, 0x24
	ctx.r[30].s64 = ctx.r[27].s64 + 36;
	// 821CD018: 92C10058  stw r22, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[22].u32 ) };
	// 821CD01C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 821CD020: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821CD024: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821CD028: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 821CD02C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821CD030: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CD034: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 821CD038: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821CD03C: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821CD040: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 821CD044: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821CD048: 4827F0A1  bl 0x8244c0e8
	ctx.lr = 0x821CD04C;
	sub_8244C0E8(ctx, base);
	// 821CD04C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CD050: 48847D41  bl 0x82a14d90
	ctx.lr = 0x821CD054;
	sub_82A14D90(ctx, base);
	// 821CD054: 3D008245  lis r8, -0x7dbb
	ctx.r[8].s64 = -2109407232;
	// 821CD058: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821CD05C: 3888B608  addi r4, r8, -0x49f8
	ctx.r[4].s64 = ctx.r[8].s64 + -18936;
	// 821CD060: 4827F109  bl 0x8244c168
	ctx.lr = 0x821CD064;
	sub_8244C168(ctx, base);
	pc = 0x821CD064; continue 'dispatch;
            }
            0x821CD064 => {
    //   block [0x821CD064..0x821CD094)
	// 821CD064: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821CD068: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821CD06C: 995B0050  stb r10, 0x50(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 821CD070: 3AFB0024  addi r23, r27, 0x24
	ctx.r[23].s64 = ctx.r[27].s64 + 36;
	// 821CD074: 813B0028  lwz r9, 0x28(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 821CD078: 3EA08349  lis r21, -0x7cb7
	ctx.r[21].s64 = -2092367872;
	// 821CD07C: 3B400018  li r26, 0x18
	ctx.r[26].s64 = 24;
	// 821CD080: 3E808349  lis r20, -0x7cb7
	ctx.r[20].s64 = -2092367872;
	// 821CD084: 816BE9EC  lwz r11, -0x1614(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5652 as u32) ) } as u64;
	// 821CD088: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821CD08C: 3B2B0024  addi r25, r11, 0x24
	ctx.r[25].s64 = ctx.r[11].s64 + 36;
	// 821CD090: 83090000  lwz r24, 0(r9)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821CD094; continue 'dispatch;
            }
            0x821CD094 => {
    //   block [0x821CD094..0x821CD0A4)
	// 821CD094: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CD098: 7F17B840  cmplw cr6, r23, r23
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[23].u32, &mut ctx.xer);
	// 821CD09C: 419A0008  beq cr6, 0x821cd0a4
	if ctx.cr[6].eq {
	pc = 0x821CD0A4; continue 'dispatch;
	}
	// 821CD0A0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821CD0A4; continue 'dispatch;
            }
            0x821CD0A4 => {
    //   block [0x821CD0A4..0x821CD0BC)
	// 821CD0A4: 7F185840  cmplw cr6, r24, r11
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CD0A8: 419A0258  beq cr6, 0x821cd300
	if ctx.cr[6].eq {
	pc = 0x821CD300; continue 'dispatch;
	}
	// 821CD0AC: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CD0B0: 7F185840  cmplw cr6, r24, r11
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CD0B4: 409A0008  bne cr6, 0x821cd0bc
	if !ctx.cr[6].eq {
	pc = 0x821CD0BC; continue 'dispatch;
	}
	// 821CD0B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821CD0BC; continue 'dispatch;
            }
            0x821CD0BC => {
    //   block [0x821CD0BC..0x821CD120)
	// 821CD0BC: 83980008  lwz r28, 8(r24)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CD0C0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821CD0C4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821CD0C8: 4BFE6F59  bl 0x821b4020
	ctx.lr = 0x821CD0CC;
	sub_821B4020(ctx, base);
	// 821CD0CC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821CD0D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CD0D4: 409A0214  bne cr6, 0x821cd2e8
	if !ctx.cr[6].eq {
	pc = 0x821CD2E8; continue 'dispatch;
	}
	// 821CD0D8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CD0DC: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	// 821CD0E0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821CD0E4: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821CD0E8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CD0EC: 4E800421  bctrl
	ctx.lr = 0x821CD0F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CD0F0: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821CD0F4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821CD0F8: 419A007C  beq cr6, 0x821cd174
	if ctx.cr[6].eq {
	pc = 0x821CD174; continue 'dispatch;
	}
	// 821CD0FC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CD100: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821CD104: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821CD108: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CD10C: 4E800421  bctrl
	ctx.lr = 0x821CD110;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CD110: 81390008  lwz r9, 8(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CD114: 83F90004  lwz r31, 4(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CD118: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821CD11C: 419A0058  beq cr6, 0x821cd174
	if ctx.cr[6].eq {
	pc = 0x821CD174; continue 'dispatch;
	}
            }
            0x821CD120 => {
    //   block [0x821CD120..0x821CD15C)
	// 821CD120: 897F0038  lbz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821CD124: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CD128: 409A0034  bne cr6, 0x821cd15c
	if !ctx.cr[6].eq {
	pc = 0x821CD15C; continue 'dispatch;
	}
	// 821CD12C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CD130: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CD134: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821CD138: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821CD13C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CD140: 4E800421  bctrl
	ctx.lr = 0x821CD144;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CD144: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821CD148: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821CD14C: 4BFE6ED5  bl 0x821b4020
	ctx.lr = 0x821CD150;
	sub_821B4020(ctx, base);
	// 821CD150: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821CD154: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821CD158: 409A0018  bne cr6, 0x821cd170
	if !ctx.cr[6].eq {
	pc = 0x821CD170; continue 'dispatch;
	}
            }
            0x821CD15C => {
    //   block [0x821CD15C..0x821CD170)
	// 821CD15C: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CD160: 3BFF0048  addi r31, r31, 0x48
	ctx.r[31].s64 = ctx.r[31].s64 + 72;
	// 821CD164: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CD168: 409AFFB8  bne cr6, 0x821cd120
	if !ctx.cr[6].eq {
	pc = 0x821CD120; continue 'dispatch;
	}
	// 821CD16C: 48000008  b 0x821cd174
	pc = 0x821CD174; continue 'dispatch;
            }
            0x821CD170 => {
    //   block [0x821CD170..0x821CD174)
	// 821CD170: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	pc = 0x821CD174; continue 'dispatch;
            }
            0x821CD174 => {
    //   block [0x821CD174..0x821CD1BC)
	// 821CD174: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 821CD178: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CD17C: 409A016C  bne cr6, 0x821cd2e8
	if !ctx.cr[6].eq {
	pc = 0x821CD2E8; continue 'dispatch;
	}
	// 821CD180: 811B0058  lwz r8, 0x58(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(88 as u32) ) } as u64;
	// 821CD184: 3BBB0054  addi r29, r27, 0x54
	ctx.r[29].s64 = ctx.r[27].s64 + 84;
	// 821CD188: 817B005C  lwz r11, 0x5c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(92 as u32) ) } as u64;
	// 821CD18C: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CD190: 419A0058  beq cr6, 0x821cd1e8
	if ctx.cr[6].eq {
	pc = 0x821CD1E8; continue 'dispatch;
	}
	// 821CD194: 7D2B5850  subf r9, r11, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[11].s64;
	// 821CD198: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821CD19C: 7D29D3D6  divw r9, r9, r26
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	// 821CD1A0: 7F0B5840  cmplw cr6, r11, r11
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CD1A4: 5527083C  slwi r7, r9, 1
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821CD1A8: 7CE93A14  add r7, r9, r7
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[7].u64;
	// 821CD1AC: 54E91838  slwi r9, r7, 3
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821CD1B0: 7CE94214  add r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 821CD1B4: 419A0030  beq cr6, 0x821cd1e4
	if ctx.cr[6].eq {
	pc = 0x821CD1E4; continue 'dispatch;
	}
	// 821CD1B8: 7D2B4050  subf r9, r11, r8
	ctx.r[9].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	pc = 0x821CD1BC; continue 'dispatch;
            }
            0x821CD1BC => {
    //   block [0x821CD1BC..0x821CD1E4)
	// 821CD1BC: E90A0000  ld r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 821CD1C0: 7CCA4A14  add r6, r10, r9
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821CD1C4: 7D0A492A  stdx r8, r10, r9
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[8].u64) };
	// 821CD1C8: E8AA0008  ld r5, 8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 821CD1CC: F8A60008  std r5, 8(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[5].u64 ) };
	// 821CD1D0: E88A0010  ld r4, 0x10(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	// 821CD1D4: 394A0018  addi r10, r10, 0x18
	ctx.r[10].s64 = ctx.r[10].s64 + 24;
	// 821CD1D8: F8860010  std r4, 0x10(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(16 as u32), ctx.r[4].u64 ) };
	// 821CD1DC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CD1E0: 409AFFDC  bne cr6, 0x821cd1bc
	if !ctx.cr[6].eq {
	pc = 0x821CD1BC; continue 'dispatch;
	}
	pc = 0x821CD1E4; continue 'dispatch;
            }
            0x821CD1E4 => {
    //   block [0x821CD1E4..0x821CD1E8)
	// 821CD1E4: 90FD0008  stw r7, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	pc = 0x821CD1E8; continue 'dispatch;
            }
            0x821CD1E8 => {
    //   block [0x821CD1E8..0x821CD218)
	// 821CD1E8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CD1EC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821CD1F0: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CD1F4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CD1F8: 4E800421  bctrl
	ctx.lr = 0x821CD1FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CD1FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821CD200: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 821CD204: 4809702D  bl 0x82264230
	ctx.lr = 0x821CD208;
	sub_82264230(ctx, base);
	// 821CD208: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CD20C: 419A000C  beq cr6, 0x821cd218
	if ctx.cr[6].eq {
	pc = 0x821CD218; continue 'dispatch;
	}
	// 821CD210: 80A30028  lwz r5, 0x28(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 821CD214: 48000058  b 0x821cd26c
	pc = 0x821CD26C; continue 'dispatch;
            }
            0x821CD218 => {
    //   block [0x821CD218..0x821CD22C)
	// 821CD218: 81556AB8  lwz r10, 0x6ab8(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821CD21C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CD220: 419A000C  beq cr6, 0x821cd22c
	if ctx.cr[6].eq {
	pc = 0x821CD22C; continue 'dispatch;
	}
	// 821CD224: 89746A5E  lbz r11, 0x6a5e(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[20].u32.wrapping_add(27230 as u32) ) } as u64;
	// 821CD228: 48000008  b 0x821cd230
	pc = 0x821CD230; continue 'dispatch;
            }
            0x821CD22C => {
    //   block [0x821CD22C..0x821CD230)
	// 821CD22C: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x821CD230; continue 'dispatch;
            }
            0x821CD230 => {
    //   block [0x821CD230..0x821CD268)
	// 821CD230: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CD234: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CD238: 419A0030  beq cr6, 0x821cd268
	if ctx.cr[6].eq {
	pc = 0x821CD268; continue 'dispatch;
	}
	// 821CD23C: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CD240: 814B011C  lwz r10, 0x11c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(284 as u32) ) } as u64;
	// 821CD244: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 821CD248: 409A0020  bne cr6, 0x821cd268
	if !ctx.cr[6].eq {
	pc = 0x821CD268; continue 'dispatch;
	}
	// 821CD24C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821CD250: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 821CD254: 48096FDD  bl 0x82264230
	ctx.lr = 0x821CD258;
	sub_82264230(ctx, base);
	// 821CD258: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CD25C: 419A000C  beq cr6, 0x821cd268
	if ctx.cr[6].eq {
	pc = 0x821CD268; continue 'dispatch;
	}
	// 821CD260: 80A30028  lwz r5, 0x28(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 821CD264: 48000008  b 0x821cd26c
	pc = 0x821CD26C; continue 'dispatch;
            }
            0x821CD268 => {
    //   block [0x821CD268..0x821CD26C)
	// 821CD268: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	pc = 0x821CD26C; continue 'dispatch;
            }
            0x821CD26C => {
    //   block [0x821CD26C..0x821CD298)
	// 821CD26C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821CD270: 807B0048  lwz r3, 0x48(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CD274: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821CD278: 480007F9  bl 0x821cda70
	ctx.lr = 0x821CD27C;
	sub_821CDA70(ctx, base);
	// 821CD27C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CD280: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CD284: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	// 821CD288: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821CD28C: 7D09D3D7  divw. r8, r9, r26
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821CD290: 41820058  beq 0x821cd2e8
	if ctx.cr[0].eq {
	pc = 0x821CD2E8; continue 'dispatch;
	}
	// 821CD294: 7EDFB378  mr r31, r22
	ctx.r[31].u64 = ctx.r[22].u64;
	pc = 0x821CD298; continue 'dispatch;
            }
            0x821CD298 => {
    //   block [0x821CD298..0x821CD2E8)
	// 821CD298: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CD29C: 7C8BFA14  add r4, r11, r31
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821CD2A0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821CD2A4: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CD2A8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821CD2AC: 4E800421  bctrl
	ctx.lr = 0x821CD2B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CD2B0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821CD2B4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821CD2B8: 4BFE6D69  bl 0x821b4020
	ctx.lr = 0x821CD2BC;
	sub_821B4020(ctx, base);
	// 821CD2BC: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821CD2C0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821CD2C4: 409A0024  bne cr6, 0x821cd2e8
	if !ctx.cr[6].eq {
	pc = 0x821CD2E8; continue 'dispatch;
	}
	// 821CD2C8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CD2CC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 821CD2D0: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CD2D4: 3BFF0018  addi r31, r31, 0x18
	ctx.r[31].s64 = ctx.r[31].s64 + 24;
	// 821CD2D8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821CD2DC: 7D09D3D6  divw r8, r9, r26
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	// 821CD2E0: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821CD2E4: 4198FFB4  blt cr6, 0x821cd298
	if ctx.cr[6].lt {
	pc = 0x821CD298; continue 'dispatch;
	}
            }
            0x821CD2E8 => {
    //   block [0x821CD2E8..0x821CD2F8)
	// 821CD2E8: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CD2EC: 7F185840  cmplw cr6, r24, r11
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CD2F0: 409A0008  bne cr6, 0x821cd2f8
	if !ctx.cr[6].eq {
	pc = 0x821CD2F8; continue 'dispatch;
	}
	// 821CD2F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821CD2F8; continue 'dispatch;
            }
            0x821CD2F8 => {
    //   block [0x821CD2F8..0x821CD300)
	// 821CD2F8: 83180000  lwz r24, 0(r24)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CD2FC: 4BFFFD98  b 0x821cd094
	pc = 0x821CD094; continue 'dispatch;
            }
            0x821CD300 => {
    //   block [0x821CD300..0x821CD30C)
	// 821CD300: 9ADB0050  stb r22, 0x50(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(80 as u32), ctx.r[22].u8 ) };
	// 821CD304: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821CD308: 48ADC12C  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CD310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CD310 size=828
    let mut pc: u32 = 0x821CD310;
    'dispatch: loop {
        match pc {
            0x821CD310 => {
    //   block [0x821CD310..0x821CD404)
	// 821CD310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CD314: 48ADC0DD  bl 0x82ca93f0
	ctx.lr = 0x821CD318;
	sub_82CA93D0(ctx, base);
	// 821CD318: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CD31C: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 821CD320: 3F008349  lis r24, -0x7cb7
	ctx.r[24].s64 = -2092367872;
	// 821CD324: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 821CD328: 81760004  lwz r11, 4(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CD32C: 80786E98  lwz r3, 0x6e98(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28312 as u32) ) } as u64;
	// 821CD330: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CD334: 83EB0014  lwz r31, 0x14(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821CD338: 419A030C  beq cr6, 0x821cd644
	if ctx.cr[6].eq {
	pc = 0x821CD644; continue 'dispatch;
	}
	// 821CD33C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821CD340: 4894F179  bl 0x82b1c4b8
	ctx.lr = 0x821CD344;
	sub_82B1C4B8(ctx, base);
	// 821CD344: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821CD348: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CD34C: 419A02F8  beq cr6, 0x821cd644
	if ctx.cr[6].eq {
	pc = 0x821CD644; continue 'dispatch;
	}
	// 821CD350: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821CD354: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 821CD358: 3B4BAC08  addi r26, r11, -0x53f8
	ctx.r[26].s64 = ctx.r[11].s64 + -21496;
	// 821CD35C: 386AAC10  addi r3, r10, -0x53f0
	ctx.r[3].s64 = ctx.r[10].s64 + -21488;
	// 821CD360: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821CD364: 4887F865  bl 0x82a4cbc8
	ctx.lr = 0x821CD368;
	sub_82A4CBC8(ctx, base);
	// 821CD368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CD36C: 4BFE9DBD  bl 0x821b7128
	ctx.lr = 0x821CD370;
	sub_821B7128(ctx, base);
	// 821CD370: 89390068  lbz r9, 0x68(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(104 as u32) ) } as u64;
	// 821CD374: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821CD378: 409A01B8  bne cr6, 0x821cd530
	if !ctx.cr[6].eq {
	pc = 0x821CD530; continue 'dispatch;
	}
	// 821CD37C: 81790014  lwz r11, 0x14(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(20 as u32) ) } as u64;
	// 821CD380: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821CD384: 419A01AC  beq cr6, 0x821cd530
	if ctx.cr[6].eq {
	pc = 0x821CD530; continue 'dispatch;
	}
	// 821CD388: 3EE08349  lis r23, -0x7cb7
	ctx.r[23].s64 = -2092367872;
	// 821CD38C: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 821CD390: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821CD394: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821CD398: 3BAA0364  addi r29, r10, 0x364
	ctx.r[29].s64 = ctx.r[10].s64 + 868;
	// 821CD39C: 897770D3  lbz r11, 0x70d3(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[23].u32.wrapping_add(28883 as u32) ) } as u64;
	// 821CD3A0: 83EA0364  lwz r31, 0x364(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(868 as u32) ) } as u64;
	// 821CD3A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CD3A8: 3D602AAA  lis r11, 0x2aaa
	ctx.r[11].s64 = 715784192;
	// 821CD3AC: 616BAAAA  ori r11, r11, 0xaaaa
	ctx.r[11].u64 = ctx.r[11].u64 | 43690;
	// 821CD3B0: 419A0080  beq cr6, 0x821cd430
	if ctx.cr[6].eq {
	pc = 0x821CD430; continue 'dispatch;
	}
	// 821CD3B4: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 821CD3B8: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 821CD3BC: 817F34CC  lwz r11, 0x34cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13516 as u32) ) } as u64;
	// 821CD3C0: 80CB006C  lwz r6, 0x6c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 821CD3C4: 60C50040  ori r5, r6, 0x40
	ctx.r[5].u64 = ctx.r[6].u64 | 64;
	// 821CD3C8: 90AB006C  stw r5, 0x6c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), ctx.r[5].u32 ) };
	// 821CD3CC: 809F0038  lwz r4, 0x38(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821CD3D0: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821CD3D4: 897F2ABC  lbz r11, 0x2abc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10940 as u32) ) } as u64;
	// 821CD3D8: 556A003C  rlwinm r10, r11, 0, 0, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821CD3DC: 913F31AC  stw r9, 0x31ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12716 as u32), ctx.r[9].u32 ) };
	// 821CD3E0: 7F032040  cmplw cr6, r3, r4
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821CD3E4: 995F2ABC  stb r10, 0x2abc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(10940 as u32), ctx.r[10].u8 ) };
	// 821CD3E8: 911F31A4  stw r8, 0x31a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12708 as u32), ctx.r[8].u32 ) };
	// 821CD3EC: 93DF31A8  stw r30, 0x31a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12712 as u32), ctx.r[30].u32 ) };
	// 821CD3F0: 90FF2AB4  stw r7, 0x2ab4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(10932 as u32), ctx.r[7].u32 ) };
	// 821CD3F4: 93DF2AB8  stw r30, 0x2ab8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(10936 as u32), ctx.r[30].u32 ) };
	// 821CD3F8: 4099000C  ble cr6, 0x821cd404
	if !ctx.cr[6].gt {
	pc = 0x821CD404; continue 'dispatch;
	}
	// 821CD3FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CD400: 4801BAC1  bl 0x821e8ec0
	ctx.lr = 0x821CD404;
	sub_821E8EC0(ctx, base);
	pc = 0x821CD404; continue 'dispatch;
            }
            0x821CD404 => {
    //   block [0x821CD404..0x821CD430)
	// 821CD404: 3D60C000  lis r11, -0x4000
	ctx.r[11].s64 = -1073741824;
	// 821CD408: 3D40C000  lis r10, -0x4000
	ctx.r[10].s64 = -1073741824;
	// 821CD40C: 61696000  ori r9, r11, 0x6000
	ctx.r[9].u64 = ctx.r[11].u64 | 24576;
	// 821CD410: 61486100  ori r8, r10, 0x6100
	ctx.r[8].u64 = ctx.r[10].u64 | 24832;
	// 821CD414: 95230004  stwu r9, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[9].u32) };
	ctx.r[3].u32 = ea;
	// 821CD418: 80FF31A4  lwz r7, 0x31a4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12708 as u32) ) } as u64;
	// 821CD41C: 94E30004  stwu r7, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[7].u32) };
	ctx.r[3].u32 = ea;
	// 821CD420: 95030004  stwu r8, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[8].u32) };
	ctx.r[3].u32 = ea;
	// 821CD424: 80DF31A8  lwz r6, 0x31a8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12712 as u32) ) } as u64;
	// 821CD428: 94C30004  stwu r6, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[6].u32) };
	ctx.r[3].u32 = ea;
	// 821CD42C: 48000050  b 0x821cd47c
	pc = 0x821CD47C; continue 'dispatch;
            }
            0x821CD430 => {
    //   block [0x821CD430..0x821CD468)
	// 821CD430: 891F2ABC  lbz r8, 0x2abc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10940 as u32) ) } as u64;
	// 821CD434: 80FF0038  lwz r7, 0x38(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821CD438: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821CD43C: 5506003C  rlwinm r6, r8, 0, 0, 0x1e
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 821CD440: 913F31AC  stw r9, 0x31ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12716 as u32), ctx.r[9].u32 ) };
	// 821CD444: 917F31A4  stw r11, 0x31a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12708 as u32), ctx.r[11].u32 ) };
	// 821CD448: 7F033840  cmplw cr6, r3, r7
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821CD44C: 98DF2ABC  stb r6, 0x2abc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(10940 as u32), ctx.r[6].u8 ) };
	// 821CD450: 93DF31A8  stw r30, 0x31a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12712 as u32), ctx.r[30].u32 ) };
	// 821CD454: 917F2AB4  stw r11, 0x2ab4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(10932 as u32), ctx.r[11].u32 ) };
	// 821CD458: 93DF2AB8  stw r30, 0x2ab8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(10936 as u32), ctx.r[30].u32 ) };
	// 821CD45C: 4099000C  ble cr6, 0x821cd468
	if !ctx.cr[6].gt {
	pc = 0x821CD468; continue 'dispatch;
	}
	// 821CD460: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CD464: 4801BA5D  bl 0x821e8ec0
	ctx.lr = 0x821CD468;
	sub_821E8EC0(ctx, base);
	pc = 0x821CD468; continue 'dispatch;
            }
            0x821CD468 => {
    //   block [0x821CD468..0x821CD47C)
	// 821CD468: 3D60C000  lis r11, -0x4000
	ctx.r[11].s64 = -1073741824;
	// 821CD46C: 616A6000  ori r10, r11, 0x6000
	ctx.r[10].u64 = ctx.r[11].u64 | 24576;
	// 821CD470: 95430004  stwu r10, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[10].u32) };
	ctx.r[3].u32 = ea;
	// 821CD474: 813F31A4  lwz r9, 0x31a4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12708 as u32) ) } as u64;
	// 821CD478: 95230004  stwu r9, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[9].u32) };
	ctx.r[3].u32 = ea;
	pc = 0x821CD47C; continue 'dispatch;
            }
            0x821CD47C => {
    //   block [0x821CD47C..0x821CD4B0)
	// 821CD47C: 907F0030  stw r3, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[3].u32 ) };
	// 821CD480: 38C00070  li r6, 0x70
	ctx.r[6].s64 = 112;
	// 821CD484: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 821CD488: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CD48C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821CD490: 4BFCF8D9  bl 0x8219cd68
	ctx.lr = 0x821CD494;
	sub_8219CD68(ctx, base);
	// 821CD494: 81790014  lwz r11, 0x14(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(20 as u32) ) } as u64;
	// 821CD498: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 821CD49C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CD4A0: 409901A0  ble cr6, 0x821cd640
	if !ctx.cr[6].gt {
	pc = 0x821CD640; continue 'dispatch;
	}
	// 821CD4A4: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821CD4A8: 3B800002  li r28, 2
	ctx.r[28].s64 = 2;
	// 821CD4AC: 3B6BA980  addi r27, r11, -0x5680
	ctx.r[27].s64 = ctx.r[11].s64 + -22144;
	pc = 0x821CD4B0; continue 'dispatch;
            }
            0x821CD4B0 => {
    //   block [0x821CD4B0..0x821CD4D0)
	// 821CD4B0: 897770D3  lbz r11, 0x70d3(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[23].u32.wrapping_add(28883 as u32) ) } as u64;
	// 821CD4B4: 7F84F030  slw r4, r28, r30
	if (ctx.r[30].u8 & 0x20) != 0 {
		ctx.r[4].u64 = 0;
	} else {
		ctx.r[4].u64 = ((ctx.r[28].u32) << ((ctx.r[30].u8 & 0x1F) as u32)) as u64;
	}
	// 821CD4B8: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CD4BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CD4C0: 419A0010  beq cr6, 0x821cd4d0
	if ctx.cr[6].eq {
	pc = 0x821CD4D0; continue 'dispatch;
	}
	// 821CD4C4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821CD4C8: 489D4879  bl 0x82ba1d40
	ctx.lr = 0x821CD4CC;
	sub_82BA1D40(ctx, base);
	// 821CD4CC: 48000008  b 0x821cd4d4
	pc = 0x821CD4D4; continue 'dispatch;
            }
            0x821CD4D0 => {
    //   block [0x821CD4D0..0x821CD4D4)
	// 821CD4D0: 48098121  bl 0x822655f0
	ctx.lr = 0x821CD4D4;
	sub_822655F0(ctx, base);
	pc = 0x821CD4D4; continue 'dispatch;
            }
            0x821CD4D4 => {
    //   block [0x821CD4D4..0x821CD510)
	// 821CD4D4: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CD4D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CD4DC: 419A0034  beq cr6, 0x821cd510
	if ctx.cr[6].eq {
	pc = 0x821CD510; continue 'dispatch;
	}
	// 821CD4E0: 81560004  lwz r10, 4(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CD4E4: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 821CD4E8: 81786E98  lwz r11, 0x6e98(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28312 as u32) ) } as u64;
	// 821CD4EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821CD4F0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821CD4F4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821CD4F8: 4BFB0161  bl 0x8217d658
	ctx.lr = 0x821CD4FC;
	sub_8217D658(ctx, base);
	// 821CD4FC: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 821CD500: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821CD504: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CD508: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821CD50C: 480B52AD  bl 0x822827b8
	ctx.lr = 0x821CD510;
	sub_822827B8(ctx, base);
	pc = 0x821CD510; continue 'dispatch;
            }
            0x821CD510 => {
    //   block [0x821CD510..0x821CD530)
	// 821CD510: 81790014  lwz r11, 0x14(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(20 as u32) ) } as u64;
	// 821CD514: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821CD518: 3BDE0002  addi r30, r30, 2
	ctx.r[30].s64 = ctx.r[30].s64 + 2;
	// 821CD51C: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821CD520: 4198FF90  blt cr6, 0x821cd4b0
	if ctx.cr[6].lt {
	pc = 0x821CD4B0; continue 'dispatch;
	}
	// 821CD524: 480C90BD  bl 0x822965e0
	ctx.lr = 0x821CD528;
	sub_822965E0(ctx, base);
	// 821CD528: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821CD52C: 48ADBF14  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821CD530 => {
    //   block [0x821CD530..0x821CD5A0)
	// 821CD530: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821CD534: 3B800002  li r28, 2
	ctx.r[28].s64 = 2;
	// 821CD538: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821CD53C: 894B70D3  lbz r10, 0x70d3(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28883 as u32) ) } as u64;
	// 821CD540: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821CD544: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CD548: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821CD54C: 3BAB0364  addi r29, r11, 0x364
	ctx.r[29].s64 = ctx.r[11].s64 + 868;
	// 821CD550: 83EB0364  lwz r31, 0x364(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(868 as u32) ) } as u64;
	// 821CD554: 419A0078  beq cr6, 0x821cd5cc
	if ctx.cr[6].eq {
	pc = 0x821CD5CC; continue 'dispatch;
	}
	// 821CD558: 817F34CC  lwz r11, 0x34cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13516 as u32) ) } as u64;
	// 821CD55C: 812B006C  lwz r9, 0x6c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 821CD560: 61280040  ori r8, r9, 0x40
	ctx.r[8].u64 = ctx.r[9].u64 | 64;
	// 821CD564: 910B006C  stw r8, 0x6c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), ctx.r[8].u32 ) };
	// 821CD568: 80FF0038  lwz r7, 0x38(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821CD56C: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821CD570: 7F033840  cmplw cr6, r3, r7
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821CD574: 88DF2ABC  lbz r6, 0x2abc(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10940 as u32) ) } as u64;
	// 821CD578: 915F31AC  stw r10, 0x31ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12716 as u32), ctx.r[10].u32 ) };
	// 821CD57C: 54C5003C  rlwinm r5, r6, 0, 0, 0x1e
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 821CD580: 939F31A4  stw r28, 0x31a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12708 as u32), ctx.r[28].u32 ) };
	// 821CD584: 93DF31A8  stw r30, 0x31a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12712 as u32), ctx.r[30].u32 ) };
	// 821CD588: 939F2AB4  stw r28, 0x2ab4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(10932 as u32), ctx.r[28].u32 ) };
	// 821CD58C: 93DF2AB8  stw r30, 0x2ab8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(10936 as u32), ctx.r[30].u32 ) };
	// 821CD590: 98BF2ABC  stb r5, 0x2abc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(10940 as u32), ctx.r[5].u8 ) };
	// 821CD594: 4099000C  ble cr6, 0x821cd5a0
	if !ctx.cr[6].gt {
	pc = 0x821CD5A0; continue 'dispatch;
	}
	// 821CD598: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CD59C: 4801B925  bl 0x821e8ec0
	ctx.lr = 0x821CD5A0;
	sub_821E8EC0(ctx, base);
	pc = 0x821CD5A0; continue 'dispatch;
            }
            0x821CD5A0 => {
    //   block [0x821CD5A0..0x821CD5CC)
	// 821CD5A0: 3D60C000  lis r11, -0x4000
	ctx.r[11].s64 = -1073741824;
	// 821CD5A4: 3D40C000  lis r10, -0x4000
	ctx.r[10].s64 = -1073741824;
	// 821CD5A8: 61696000  ori r9, r11, 0x6000
	ctx.r[9].u64 = ctx.r[11].u64 | 24576;
	// 821CD5AC: 61486100  ori r8, r10, 0x6100
	ctx.r[8].u64 = ctx.r[10].u64 | 24832;
	// 821CD5B0: 95230004  stwu r9, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[9].u32) };
	ctx.r[3].u32 = ea;
	// 821CD5B4: 80FF31A4  lwz r7, 0x31a4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12708 as u32) ) } as u64;
	// 821CD5B8: 94E30004  stwu r7, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[7].u32) };
	ctx.r[3].u32 = ea;
	// 821CD5BC: 95030004  stwu r8, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[8].u32) };
	ctx.r[3].u32 = ea;
	// 821CD5C0: 80DF31A8  lwz r6, 0x31a8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12712 as u32) ) } as u64;
	// 821CD5C4: 94C30004  stwu r6, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[6].u32) };
	ctx.r[3].u32 = ea;
	// 821CD5C8: 48000050  b 0x821cd618
	pc = 0x821CD618; continue 'dispatch;
            }
            0x821CD5CC => {
    //   block [0x821CD5CC..0x821CD604)
	// 821CD5CC: 893F2ABC  lbz r9, 0x2abc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10940 as u32) ) } as u64;
	// 821CD5D0: 811F0038  lwz r8, 0x38(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821CD5D4: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821CD5D8: 5527003C  rlwinm r7, r9, 0, 0, 0x1e
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821CD5DC: 915F31AC  stw r10, 0x31ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12716 as u32), ctx.r[10].u32 ) };
	// 821CD5E0: 939F31A4  stw r28, 0x31a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12708 as u32), ctx.r[28].u32 ) };
	// 821CD5E4: 7F034040  cmplw cr6, r3, r8
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821CD5E8: 98FF2ABC  stb r7, 0x2abc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(10940 as u32), ctx.r[7].u8 ) };
	// 821CD5EC: 93DF31A8  stw r30, 0x31a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12712 as u32), ctx.r[30].u32 ) };
	// 821CD5F0: 939F2AB4  stw r28, 0x2ab4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(10932 as u32), ctx.r[28].u32 ) };
	// 821CD5F4: 93DF2AB8  stw r30, 0x2ab8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(10936 as u32), ctx.r[30].u32 ) };
	// 821CD5F8: 4099000C  ble cr6, 0x821cd604
	if !ctx.cr[6].gt {
	pc = 0x821CD604; continue 'dispatch;
	}
	// 821CD5FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CD600: 4801B8C1  bl 0x821e8ec0
	ctx.lr = 0x821CD604;
	sub_821E8EC0(ctx, base);
	pc = 0x821CD604; continue 'dispatch;
            }
            0x821CD604 => {
    //   block [0x821CD604..0x821CD618)
	// 821CD604: 3D60C000  lis r11, -0x4000
	ctx.r[11].s64 = -1073741824;
	// 821CD608: 616A6000  ori r10, r11, 0x6000
	ctx.r[10].u64 = ctx.r[11].u64 | 24576;
	// 821CD60C: 95430004  stwu r10, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[10].u32) };
	ctx.r[3].u32 = ea;
	// 821CD610: 813F31A4  lwz r9, 0x31a4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12708 as u32) ) } as u64;
	// 821CD614: 95230004  stwu r9, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[9].u32) };
	ctx.r[3].u32 = ea;
	pc = 0x821CD618; continue 'dispatch;
            }
            0x821CD618 => {
    //   block [0x821CD618..0x821CD640)
	// 821CD618: 907F0030  stw r3, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[3].u32 ) };
	// 821CD61C: 38C00070  li r6, 0x70
	ctx.r[6].s64 = 112;
	// 821CD620: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 821CD624: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821CD628: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CD62C: 4BFCF73D  bl 0x8219cd68
	ctx.lr = 0x821CD630;
	sub_8219CD68(ctx, base);
	// 821CD630: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821CD634: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 821CD638: 388BA980  addi r4, r11, -0x5680
	ctx.r[4].s64 = ctx.r[11].s64 + -22144;
	// 821CD63C: 480EA835  bl 0x822b7e70
	ctx.lr = 0x821CD640;
	sub_822B7E70(ctx, base);
	pc = 0x821CD640; continue 'dispatch;
            }
            0x821CD640 => {
    //   block [0x821CD640..0x821CD644)
	// 821CD640: 480C8FA1  bl 0x822965e0
	ctx.lr = 0x821CD644;
	sub_822965E0(ctx, base);
	pc = 0x821CD644; continue 'dispatch;
            }
            0x821CD644 => {
    //   block [0x821CD644..0x821CD64C)
	// 821CD644: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821CD648: 48ADBDF8  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CD650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821CD650 size=384
    let mut pc: u32 = 0x821CD650;
    'dispatch: loop {
        match pc {
            0x821CD650 => {
    //   block [0x821CD650..0x821CD684)
	// 821CD650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CD654: 48ADBDB9  bl 0x82ca940c
	ctx.lr = 0x821CD658;
	sub_82CA93D0(ctx, base);
	// 821CD658: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CD65C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821CD660: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821CD664: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821CD668: 897F0014  lbz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821CD66C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CD670: 419A0014  beq cr6, 0x821cd684
	if ctx.cr[6].eq {
	pc = 0x821CD684; continue 'dispatch;
	}
	// 821CD674: 897F0015  lbz r11, 0x15(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 821CD678: 57CA063E  clrlwi r10, r30, 0x18
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 821CD67C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CD680: 419A0148  beq cr6, 0x821cd7c8
	if ctx.cr[6].eq {
	pc = 0x821CD7C8; continue 'dispatch;
	}
	pc = 0x821CD684; continue 'dispatch;
            }
            0x821CD684 => {
    //   block [0x821CD684..0x821CD718)
	// 821CD684: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 821CD688: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821CD68C: 813F001C  lwz r9, 0x1c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821CD690: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CD694: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 821CD698: 419A00E4  beq cr6, 0x821cd77c
	if ctx.cr[6].eq {
	pc = 0x821CD77C; continue 'dispatch;
	}
	// 821CD69C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CD6A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821CD6A4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821CD6A8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 821CD6AC: 419A006C  beq cr6, 0x821cd718
	if ctx.cr[6].eq {
	pc = 0x821CD718; continue 'dispatch;
	}
	// 821CD6B0: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821CD6B4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821CD6B8: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 821CD6BC: 419A00FC  beq cr6, 0x821cd7b8
	if ctx.cr[6].eq {
	pc = 0x821CD7B8; continue 'dispatch;
	}
	// 821CD6C0: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821CD6C4: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 821CD6C8: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 821CD6CC: 39210074  addi r9, r1, 0x74
	ctx.r[9].s64 = ctx.r[1].s64 + 116;
	// 821CD6D0: 7D451E70  srawi r5, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 821CD6D4: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 821CD6D8: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 821CD6DC: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 821CD6E0: 39050001  addi r8, r5, 1
	ctx.r[8].s64 = ctx.r[5].s64 + 1;
	// 821CD6E4: 91210084  stw r9, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[9].u32 ) };
	// 821CD6E8: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821CD6EC: 7D0B0E70  srawi r11, r8, 1
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 1) as i64;
	// 821CD6F0: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821CD6F4: E8610060  ld r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821CD6F8: 7D4B0194  addze r10, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[10].s64 = tmp.s64;
	// 821CD6FC: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 821CD700: 480FEF31  bl 0x822cc630
	ctx.lr = 0x821CD704;
	sub_822CC630(ctx, base);
	// 821CD704: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821CD708: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CD70C: 419A00AC  beq cr6, 0x821cd7b8
	if ctx.cr[6].eq {
	pc = 0x821CD7B8; continue 'dispatch;
	}
	// 821CD710: 4804E629  bl 0x8221bd38
	ctx.lr = 0x821CD714;
	sub_8221BD38(ctx, base);
	// 821CD714: 480000A4  b 0x821cd7b8
	pc = 0x821CD7B8; continue 'dispatch;
            }
            0x821CD718 => {
    //   block [0x821CD718..0x821CD77C)
	// 821CD718: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821CD71C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821CD720: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 821CD724: 419A0094  beq cr6, 0x821cd7b8
	if ctx.cr[6].eq {
	pc = 0x821CD7B8; continue 'dispatch;
	}
	// 821CD728: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821CD72C: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 821CD730: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 821CD734: 39210094  addi r9, r1, 0x94
	ctx.r[9].s64 = ctx.r[1].s64 + 148;
	// 821CD738: 7D451E70  srawi r5, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 821CD73C: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 821CD740: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 821CD744: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 821CD748: 39050001  addi r8, r5, 1
	ctx.r[8].s64 = ctx.r[5].s64 + 1;
	// 821CD74C: 912100A4  stw r9, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[9].u32 ) };
	// 821CD750: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821CD754: 7D070E70  srawi r7, r8, 1
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 1) as i64;
	// 821CD758: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821CD75C: 7D670194  addze r11, r7
	tmp.s64 = ctx.r[7].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[7].u32);
	ctx.r[11].s64 = tmp.s64;
	// 821CD760: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 821CD764: 488DA49D  bl 0x82aa7c00
	ctx.lr = 0x821CD768;
	sub_82AA7C00(ctx, base);
	// 821CD768: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 821CD76C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CD770: 419A0048  beq cr6, 0x821cd7b8
	if ctx.cr[6].eq {
	pc = 0x821CD7B8; continue 'dispatch;
	}
	// 821CD774: 4804E5C5  bl 0x8221bd38
	ctx.lr = 0x821CD778;
	sub_8221BD38(ctx, base);
	// 821CD778: 48000040  b 0x821cd7b8
	pc = 0x821CD7B8; continue 'dispatch;
            }
            0x821CD77C => {
    //   block [0x821CD77C..0x821CD7B4)
	// 821CD77C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CD780: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821CD784: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821CD788: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 821CD78C: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821CD790: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 821CD794: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821CD798: 7D051E70  srawi r5, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 821CD79C: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821CD7A0: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821CD7A4: 419A0010  beq cr6, 0x821cd7b4
	if ctx.cr[6].eq {
	pc = 0x821CD7B4; continue 'dispatch;
	}
	// 821CD7A8: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821CD7AC: 4BFC9225  bl 0x821969d0
	ctx.lr = 0x821CD7B0;
	sub_821969D0(ctx, base);
	// 821CD7B0: 48000008  b 0x821cd7b8
	pc = 0x821CD7B8; continue 'dispatch;
            }
            0x821CD7B4 => {
    //   block [0x821CD7B4..0x821CD7B8)
	// 821CD7B4: 4BFEA025  bl 0x821b77d8
	ctx.lr = 0x821CD7B8;
	sub_821B77D8(ctx, base);
	pc = 0x821CD7B8; continue 'dispatch;
            }
            0x821CD7B8 => {
    //   block [0x821CD7B8..0x821CD7C8)
	// 821CD7B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CD7BC: 9BDF0015  stb r30, 0x15(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(21 as u32), ctx.r[30].u8 ) };
	// 821CD7C0: 9BBF0016  stb r29, 0x16(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(22 as u32), ctx.r[29].u8 ) };
	// 821CD7C4: 997F0014  stb r11, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	pc = 0x821CD7C8; continue 'dispatch;
            }
            0x821CD7C8 => {
    //   block [0x821CD7C8..0x821CD7D0)
	// 821CD7C8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821CD7CC: 48ADBC90  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CD7D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821CD7D0 size=244
    let mut pc: u32 = 0x821CD7D0;
    'dispatch: loop {
        match pc {
            0x821CD7D0 => {
    //   block [0x821CD7D0..0x821CD830)
	// 821CD7D0: 3CC08336  lis r6, -0x7cca
	ctx.r[6].s64 = -2093613056;
	// 821CD7D4: 896605A0  lbz r11, 0x5a0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(1440 as u32) ) } as u64;
	// 821CD7D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CD7DC: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 821CD7E0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821CD7E4: 3CA08336  lis r5, -0x7cca
	ctx.r[5].s64 = -2093613056;
	// 821CD7E8: 396B9490  addi r11, r11, -0x6b70
	ctx.r[11].s64 = ctx.r[11].s64 + -27504;
	// 821CD7EC: 394505B0  addi r10, r5, 0x5b0
	ctx.r[10].s64 = ctx.r[5].s64 + 1456;
	// 821CD7F0: 3C808336  lis r4, -0x7cca
	ctx.r[4].s64 = -2093613056;
	// 821CD7F4: 392A0010  addi r9, r10, 0x10
	ctx.r[9].s64 = ctx.r[10].s64 + 16;
	// 821CD7F8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821CD7FC: C0CB296C  lfs f6, 0x296c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10604 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821CD800: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821CD804: C0AB2360  lfs f5, 0x2360(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9056 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821CD808: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821CD80C: 9104059C  stw r8, 0x59c(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(1436 as u32), ctx.r[8].u32 ) };
	// 821CD810: D0CA0004  stfs f6, 4(r10)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821CD814: D0AA0008  stfs f5, 8(r10)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821CD818: D16A000C  stfs f11, 0xc(r10)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821CD81C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821CD820: C1ABFFF4  lfs f13, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821CD824: C14B1FDC  lfs f10, 0x1fdc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8156 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821CD828: D1A505B0  stfs f13, 0x5b0(r5)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(1456 as u32), tmp.u32 ) };
	// 821CD82C: C0EA0C50  lfs f7, 0xc50(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3152 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	pc = 0x821CD830; continue 'dispatch;
            }
            0x821CD830 => {
    //   block [0x821CD830..0x821CD84C)
	// 821CD830: 7CEA07B4  extsw r10, r7
	ctx.r[10].s64 = ctx.r[7].s32 as i64;
	// 821CD834: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821CD838: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 821CD83C: C801FFF0  lfd f0, -0x10(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821CD840: FD80069C  fcfid f12, f0
	ctx.f[12].f64 = (ctx.f[0].s64 as f64);
	// 821CD844: FD206018  frsp f9, f12
	ctx.f[9].f64 = (ctx.f[12].f64 as f32) as f64;
	// 821CD848: ED8959F8  fmsubs f12, f9, f7, f11
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[7].f64 - ctx.f[11].f64) as f32) as f64);
	pc = 0x821CD84C; continue 'dispatch;
            }
            0x821CD84C => {
    //   block [0x821CD84C..0x821CD88C)
	// 821CD84C: 7D6A07B4  extsw r10, r11
	ctx.r[10].s64 = ctx.r[11].s32 as i64;
	// 821CD850: FC006210  fabs f0, f12
	ctx.f[0].u64 = ctx.f[12].u64 & !0x8000_0000_0000_0000u64;
	// 821CD854: F941FFF8  std r10, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[10].u64 ) };
	// 821CD858: C881FFF8  lfd f4, -8(r1)
	ctx.f[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 821CD85C: FC60269C  fcfid f3, f4
	ctx.f[3].f64 = (ctx.f[4].s64 as f64);
	// 821CD860: FC401818  frsp f2, f3
	ctx.f[2].f64 = (ctx.f[3].f64 as f32) as f64;
	// 821CD864: ED000332  fmuls f8, f0, f12
	ctx.f[8].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 821CD868: EC2259F8  fmsubs f1, f2, f7, f11
	ctx.f[1].f64 = (((ctx.f[2].f64 * ctx.f[7].f64 - ctx.f[11].f64) as f32) as f64);
	// 821CD86C: ED2832BA  fmadds f9, f8, f10, f6
	ctx.f[9].f64 = (((ctx.f[8].f64 * ctx.f[10].f64 + ctx.f[6].f64) as f32) as f64);
	// 821CD870: FF086800  fcmpu cr6, f8, f13
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[13].f64);
	// 821CD874: FC000A10  fabs f0, f1
	ctx.f[0].u64 = ctx.f[1].u64 & !0x8000_0000_0000_0000u64;
	// 821CD878: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 821CD87C: ED002ABA  fmadds f8, f0, f10, f5
	ctx.f[8].f64 = (((ctx.f[0].f64 * ctx.f[10].f64 + ctx.f[5].f64) as f32) as f64);
	// 821CD880: 409A000C  bne cr6, 0x821cd88c
	if !ctx.cr[6].eq {
	pc = 0x821CD88C; continue 'dispatch;
	}
	// 821CD884: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821CD888: 419A0018  beq cr6, 0x821cd8a0
	if ctx.cr[6].eq {
	pc = 0x821CD8A0; continue 'dispatch;
	}
	pc = 0x821CD88C; continue 'dispatch;
            }
            0x821CD88C => {
    //   block [0x821CD88C..0x821CD8A0)
	// 821CD88C: D1A90000  stfs f13, 0(r9)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821CD890: D1290004  stfs f9, 4(r9)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821CD894: D1090008  stfs f8, 8(r9)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821CD898: D169000C  stfs f11, 0xc(r9)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821CD89C: 39290010  addi r9, r9, 0x10
	ctx.r[9].s64 = ctx.r[9].s64 + 16;
	pc = 0x821CD8A0; continue 'dispatch;
            }
            0x821CD8A0 => {
    //   block [0x821CD8A0..0x821CD8C4)
	// 821CD8A0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821CD8A4: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 821CD8A8: 4198FFA4  blt cr6, 0x821cd84c
	if ctx.cr[6].lt {
	pc = 0x821CD84C; continue 'dispatch;
	}
	// 821CD8AC: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 821CD8B0: 2F070040  cmpwi cr6, r7, 0x40
	ctx.cr[6].compare_i32(ctx.r[7].s32, 64, &mut ctx.xer);
	// 821CD8B4: 4198FF7C  blt cr6, 0x821cd830
	if ctx.cr[6].lt {
	pc = 0x821CD830; continue 'dispatch;
	}
	// 821CD8B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CD8BC: 996605A0  stb r11, 0x5a0(r6)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[6].u32.wrapping_add(1440 as u32), ctx.r[11].u8 ) };
	// 821CD8C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CD8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821CD8C8 size=264
    let mut pc: u32 = 0x821CD8C8;
    'dispatch: loop {
        match pc {
            0x821CD8C8 => {
    //   block [0x821CD8C8..0x821CD918)
	// 821CD8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CD8CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821CD8D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821CD8D4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CD8D8: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 821CD8DC: 897F70E2  lbz r11, 0x70e2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(28898 as u32) ) } as u64;
	// 821CD8E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CD8E4: 409A00D8  bne cr6, 0x821cd9bc
	if !ctx.cr[6].eq {
	pc = 0x821CD9BC; continue 'dispatch;
	}
	// 821CD8E8: 38602310  li r3, 0x2310
	ctx.r[3].s64 = 8976;
	// 821CD8EC: 48ADCB9D  bl 0x82caa488
	ctx.lr = 0x821CD8F0;
	sub_82CAA488(ctx, base);
	// 821CD8F0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821CD8F4: 3943000F  addi r10, r3, 0xf
	ctx.r[10].s64 = ctx.r[3].s64 + 15;
	// 821CD8F8: 38EB0518  addi r7, r11, 0x518
	ctx.r[7].s64 = ctx.r[11].s64 + 1304;
	// 821CD8FC: 554B0036  rlwinm r11, r10, 0, 0, 0x1b
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821CD900: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821CD904: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 821CD908: 38CAB7A4  addi r6, r10, -0x485c
	ctx.r[6].s64 = ctx.r[10].s64 + -18524;
	// 821CD90C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821CD910: C00AB7A4  lfs f0, -0x485c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-18524 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821CD914: C186DCEC  lfs f12, -0x2314(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-8980 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x821CD918; continue 'dispatch;
            }
            0x821CD918 => {
    //   block [0x821CD918..0x821CD940)
	// 821CD918: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821CD91C: 419A0084  beq cr6, 0x821cd9a0
	if ctx.cr[6].eq {
	pc = 0x821CD9A0; continue 'dispatch;
	}
	// 821CD920: 91680000  stw r11, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821CD924: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821CD928: 41980078  blt cr6, 0x821cd9a0
	if ctx.cr[6].lt {
	pc = 0x821CD9A0; continue 'dispatch;
	}
	// 821CD92C: 7D2607B4  extsw r6, r9
	ctx.r[6].s64 = ctx.r[9].s32 as i64;
	// 821CD930: F8C10050  std r6, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u64 ) };
	// 821CD934: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821CD938: FD606E9C  fcfid f11, f13
	ctx.f[11].f64 = (ctx.f[13].s64 as f64);
	// 821CD93C: FDA05818  frsp f13, f11
	ctx.f[13].f64 = (ctx.f[11].f64 as f32) as f64;
	pc = 0x821CD940; continue 'dispatch;
            }
            0x821CD940 => {
    //   block [0x821CD940..0x821CD9A0)
	// 821CD940: 7D4607B4  extsw r6, r10
	ctx.r[6].s64 = ctx.r[10].s32 as i64;
	// 821CD944: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821CD948: F8C10058  std r6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u64 ) };
	// 821CD94C: C9610058  lfd f11, 0x58(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821CD950: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 821CD954: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821CD958: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 821CD95C: ED096824  fdivs f8, f9, f13
	ctx.f[8].f64 = ((ctx.f[9].f64 / ctx.f[13].f64) as f32) as f64;
	// 821CD960: ECEC4028  fsubs f7, f12, f8
	ctx.f[7].f64 = (((ctx.f[12].f64 - ctx.f[8].f64) as f32) as f64);
	// 821CD964: ECC80232  fmuls f6, f8, f8
	ctx.f[6].f64 = (((ctx.f[8].f64 * ctx.f[8].f64) as f32) as f64);
	// 821CD968: ECA701F2  fmuls f5, f7, f7
	ctx.f[5].f64 = (((ctx.f[7].f64 * ctx.f[7].f64) as f32) as f64);
	// 821CD96C: EC870232  fmuls f4, f7, f8
	ctx.f[4].f64 = (((ctx.f[7].f64 * ctx.f[8].f64) as f32) as f64);
	// 821CD970: EC660232  fmuls f3, f6, f8
	ctx.f[3].f64 = (((ctx.f[6].f64 * ctx.f[8].f64) as f32) as f64);
	// 821CD974: D06B000C  stfs f3, 0xc(r11)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821CD978: EC450232  fmuls f2, f5, f8
	ctx.f[2].f64 = (((ctx.f[5].f64 * ctx.f[8].f64) as f32) as f64);
	// 821CD97C: EC240232  fmuls f1, f4, f8
	ctx.f[1].f64 = (((ctx.f[4].f64 * ctx.f[8].f64) as f32) as f64);
	// 821CD980: ED6501F2  fmuls f11, f5, f7
	ctx.f[11].f64 = (((ctx.f[5].f64 * ctx.f[7].f64) as f32) as f64);
	// 821CD984: D16B0000  stfs f11, 0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821CD988: ED420032  fmuls f10, f2, f0
	ctx.f[10].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 821CD98C: D14B0004  stfs f10, 4(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821CD990: ED210032  fmuls f9, f1, f0
	ctx.f[9].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 821CD994: D12B0008  stfs f9, 8(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821CD998: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821CD99C: 4099FFA4  ble cr6, 0x821cd940
	if !ctx.cr[6].gt {
	pc = 0x821CD940; continue 'dispatch;
	}
	pc = 0x821CD9A0; continue 'dispatch;
            }
            0x821CD9A0 => {
    //   block [0x821CD9A0..0x821CD9BC)
	// 821CD9A0: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 821CD9A4: 39470080  addi r10, r7, 0x80
	ctx.r[10].s64 = ctx.r[7].s64 + 128;
	// 821CD9A8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821CD9AC: 7F085000  cmpw cr6, r8, r10
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821CD9B0: 4099FF68  ble cr6, 0x821cd918
	if !ctx.cr[6].gt {
	pc = 0x821CD918; continue 'dispatch;
	}
	// 821CD9B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CD9B8: 997F70E2  stb r11, 0x70e2(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28898 as u32), ctx.r[11].u8 ) };
	pc = 0x821CD9BC; continue 'dispatch;
            }
            0x821CD9BC => {
    //   block [0x821CD9BC..0x821CD9D0)
	// 821CD9BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821CD9C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821CD9C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821CD9C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821CD9CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CD9D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CD9D0 size=160
    let mut pc: u32 = 0x821CD9D0;
    'dispatch: loop {
        match pc {
            0x821CD9D0 => {
    //   block [0x821CD9D0..0x821CD9F0)
	// 821CD9D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CD9D4: 48ADBA35  bl 0x82ca9408
	ctx.lr = 0x821CD9D8;
	sub_82CA93D0(ctx, base);
	// 821CD9D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CD9DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821CD9E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821CD9E4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821CD9E8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CD9EC: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821CD9F0; continue 'dispatch;
            }
            0x821CD9F0 => {
    //   block [0x821CD9F0..0x821CDA0C)
	// 821CD9F0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CD9F4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CD9F8: 419A006C  beq cr6, 0x821cda64
	if ctx.cr[6].eq {
	pc = 0x821CDA64; continue 'dispatch;
	}
	// 821CD9FC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821CDA00: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CDA04: 409A0008  bne cr6, 0x821cda0c
	if !ctx.cr[6].eq {
	pc = 0x821CDA0C; continue 'dispatch;
	}
	// 821CDA08: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821CDA0C; continue 'dispatch;
            }
            0x821CDA0C => {
    //   block [0x821CDA0C..0x821CDA40)
	// 821CDA0C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDA10: 89640038  lbz r11, 0x38(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(56 as u32) ) } as u64;
	// 821CDA14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CDA18: 409A0028  bne cr6, 0x821cda40
	if !ctx.cr[6].eq {
	pc = 0x821CDA40; continue 'dispatch;
	}
	// 821CDA1C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CDA20: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821CDA24: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821CDA28: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CDA2C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CDA30: 4E800421  bctrl
	ctx.lr = 0x821CDA34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CDA34: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821CDA38: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821CDA3C: 409A001C  bne cr6, 0x821cda58
	if !ctx.cr[6].eq {
	pc = 0x821CDA58; continue 'dispatch;
	}
            }
            0x821CDA40 => {
    //   block [0x821CDA40..0x821CDA50)
	// 821CDA40: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDA44: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CDA48: 409A0008  bne cr6, 0x821cda50
	if !ctx.cr[6].eq {
	pc = 0x821CDA50; continue 'dispatch;
	}
	// 821CDA4C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821CDA50; continue 'dispatch;
            }
            0x821CDA50 => {
    //   block [0x821CDA50..0x821CDA58)
	// 821CDA50: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CDA54: 4BFFFF9C  b 0x821cd9f0
	pc = 0x821CD9F0; continue 'dispatch;
            }
            0x821CDA58 => {
    //   block [0x821CDA58..0x821CDA64)
	// 821CDA58: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821CDA5C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821CDA60: 48ADB9F8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x821CDA64 => {
    //   block [0x821CDA64..0x821CDA70)
	// 821CDA64: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821CDA68: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821CDA6C: 48ADB9EC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CDA70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821CDA70 size=1392
    let mut pc: u32 = 0x821CDA70;
    'dispatch: loop {
        match pc {
            0x821CDA70 => {
    //   block [0x821CDA70..0x821CDAA8)
	// 821CDA70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CDA74: 48ADB965  bl 0x82ca93d8
	ctx.lr = 0x821CDA78;
	sub_82CA93D0(ctx, base);
	// 821CDA78: 3981FF78  addi r12, r1, -0x88
	ctx.r[12].s64 = ctx.r[1].s64 + -136;
	// 821CDA7C: 48AE0255  bl 0x82cadcd0
	ctx.lr = 0x821CDA80;
	sub_82CADCA0(ctx, base);
	// 821CDA80: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CDA84: 7C701B78  mr r16, r3
	ctx.r[16].u64 = ctx.r[3].u64;
	// 821CDA88: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 821CDA8C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821CDA90: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 821CDA94: 7CD13378  mr r17, r6
	ctx.r[17].u64 = ctx.r[6].u64;
	// 821CDA98: 480517C1  bl 0x8221f258
	ctx.lr = 0x821CDA9C;
	sub_8221F258(ctx, base);
	// 821CDA9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CDAA0: 419A0008  beq cr6, 0x821cdaa8
	if ctx.cr[6].eq {
	pc = 0x821CDAA8; continue 'dispatch;
	}
	// 821CDAA4: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x821CDAA8; continue 'dispatch;
            }
            0x821CDAA8 => {
    //   block [0x821CDAA8..0x821CDAB4)
	// 821CDAA8: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CDAAC: 41820008  beq 0x821cdab4
	if ctx.cr[0].eq {
	pc = 0x821CDAB4; continue 'dispatch;
	}
	// 821CDAB0: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x821CDAB4; continue 'dispatch;
            }
            0x821CDAB4 => {
    //   block [0x821CDAB4..0x821CDAE8)
	// 821CDAB4: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDAB8: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 821CDABC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDAC0: 3B800048  li r28, 0x48
	ctx.r[28].s64 = 72;
	// 821CDAC4: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 821CDAC8: 7EBFAB78  mr r31, r21
	ctx.r[31].u64 = ctx.r[21].u64;
	// 821CDACC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821CDAD0: 92A10088  stw r21, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[21].u32 ) };
	// 821CDAD4: 7D09E3D7  divw. r8, r9, r28
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[28].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821CDAD8: 41820050  beq 0x821cdb28
	if ctx.cr[0].eq {
	pc = 0x821CDB28; continue 'dispatch;
	}
	// 821CDADC: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 821CDAE0: 7EBEAB78  mr r30, r21
	ctx.r[30].u64 = ctx.r[21].u64;
	// 821CDAE4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	pc = 0x821CDAE8; continue 'dispatch;
            }
            0x821CDAE8 => {
    //   block [0x821CDAE8..0x821CDB28)
	// 821CDAE8: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821CDAEC: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821CDAF0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821CDAF4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821CDAF8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821CDAFC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821CDB00: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821CDB04: 488C9865  bl 0x82a97368
	ctx.lr = 0x821CDB08;
	sub_82A97368(ctx, base);
	// 821CDB08: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDB0C: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDB10: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821CDB14: 3BDE0048  addi r30, r30, 0x48
	ctx.r[30].s64 = ctx.r[30].s64 + 72;
	// 821CDB18: 7D0B4850  subf r8, r11, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 821CDB1C: 7CE8E3D6  divw r7, r8, r28
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[28].s32;
	// 821CDB20: 7F1F3840  cmplw cr6, r31, r7
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821CDB24: 4198FFC4  blt cr6, 0x821cdae8
	if ctx.cr[6].lt {
	pc = 0x821CDAE8; continue 'dispatch;
	}
	pc = 0x821CDB28; continue 'dispatch;
            }
            0x821CDB28 => {
    //   block [0x821CDB28..0x821CDB60)
	// 821CDB28: 81500008  lwz r10, 8(r16)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDB2C: 3A400028  li r18, 0x28
	ctx.r[18].s64 = 40;
	// 821CDB30: 81700004  lwz r11, 4(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDB34: 7EB3AB78  mr r19, r21
	ctx.r[19].u64 = ctx.r[21].u64;
	// 821CDB38: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821CDB3C: 7D0993D7  divw. r8, r9, r18
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[18].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821CDB40: 4182044C  beq 0x821cdf8c
	if ctx.cr[0].eq {
	pc = 0x821CDF8C; continue 'dispatch;
	}
	// 821CDB44: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821CDB48: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821CDB4C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 821CDB50: 7EB4AB78  mr r20, r21
	ctx.r[20].u64 = ctx.r[21].u64;
	// 821CDB54: C38A9484  lfs f28, -0x6b7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821CDB58: CB490D38  lfd f26, 0xd38(r9)
	ctx.f[26].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(3384 as u32) ) };
	// 821CDB5C: CB680CB0  lfd f27, 0xcb0(r8)
	ctx.f[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(3248 as u32) ) };
	pc = 0x821CDB60; continue 'dispatch;
            }
            0x821CDB60 => {
    //   block [0x821CDB60..0x821CDB88)
	// 821CDB60: 7EEBA214  add r23, r11, r20
	ctx.r[23].u64 = ctx.r[11].u64 + ctx.r[20].u64;
	// 821CDB64: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 821CDB68: 3B370004  addi r25, r23, 4
	ctx.r[25].s64 = ctx.r[23].s64 + 4;
	// 821CDB6C: 7EBEAB78  mr r30, r21
	ctx.r[30].u64 = ctx.r[21].u64;
	// 821CDB70: 8177000C  lwz r11, 0xc(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CDB74: 81570008  lwz r10, 8(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDB78: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821CDB7C: 7D281E71  srawi. r8, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821CDB80: 41820050  beq 0x821cdbd0
	if ctx.cr[0].eq {
	pc = 0x821CDBD0; continue 'dispatch;
	}
	// 821CDB84: 7EBFAB78  mr r31, r21
	ctx.r[31].u64 = ctx.r[21].u64;
	pc = 0x821CDB88; continue 'dispatch;
            }
            0x821CDB88 => {
    //   block [0x821CDB88..0x821CDBCC)
	// 821CDB88: 81770008  lwz r11, 8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDB8C: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 821CDB90: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 821CDB94: 7C7F582E  lwzx r3, r31, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821CDB98: 4BFFFE39  bl 0x821cd9d0
	ctx.lr = 0x821CDB9C;
	sub_821CD9D0(ctx, base);
	// 821CDB9C: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821CDBA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CDBA4: 419A0028  beq cr6, 0x821cdbcc
	if ctx.cr[6].eq {
	pc = 0x821CDBCC; continue 'dispatch;
	}
	// 821CDBA8: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDBAC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 821CDBB0: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDBB4: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 821CDBB8: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821CDBBC: 7D281E70  srawi r8, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 821CDBC0: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821CDBC4: 4198FFC4  blt cr6, 0x821cdb88
	if ctx.cr[6].lt {
	pc = 0x821CDB88; continue 'dispatch;
	}
	// 821CDBC8: 48000008  b 0x821cdbd0
	pc = 0x821CDBD0; continue 'dispatch;
            }
            0x821CDBCC => {
    //   block [0x821CDBCC..0x821CDBD0)
	// 821CDBCC: 7EBDAB78  mr r29, r21
	ctx.r[29].u64 = ctx.r[21].u64;
	pc = 0x821CDBD0; continue 'dispatch;
            }
            0x821CDBD0 => {
    //   block [0x821CDBD0..0x821CDBFC)
	// 821CDBD0: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 821CDBD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CDBD8: 419A0394  beq cr6, 0x821cdf6c
	if ctx.cr[6].eq {
	pc = 0x821CDF6C; continue 'dispatch;
	}
	// 821CDBDC: 8177001C  lwz r11, 0x1c(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(28 as u32) ) } as u64;
	// 821CDBE0: 3B170014  addi r24, r23, 0x14
	ctx.r[24].s64 = ctx.r[23].s64 + 20;
	// 821CDBE4: 81570018  lwz r10, 0x18(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(24 as u32) ) } as u64;
	// 821CDBE8: 7EBEAB78  mr r30, r21
	ctx.r[30].u64 = ctx.r[21].u64;
	// 821CDBEC: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821CDBF0: 7D281E71  srawi. r8, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821CDBF4: 41820050  beq 0x821cdc44
	if ctx.cr[0].eq {
	pc = 0x821CDC44; continue 'dispatch;
	}
	// 821CDBF8: 7EBFAB78  mr r31, r21
	ctx.r[31].u64 = ctx.r[21].u64;
	pc = 0x821CDBFC; continue 'dispatch;
            }
            0x821CDBFC => {
    //   block [0x821CDBFC..0x821CDC40)
	// 821CDBFC: 81770018  lwz r11, 0x18(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(24 as u32) ) } as u64;
	// 821CDC00: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 821CDC04: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 821CDC08: 7C6BF82E  lwzx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 821CDC0C: 4BFFFDC5  bl 0x821cd9d0
	ctx.lr = 0x821CDC10;
	sub_821CD9D0(ctx, base);
	// 821CDC10: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821CDC14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CDC18: 419A0028  beq cr6, 0x821cdc40
	if ctx.cr[6].eq {
	pc = 0x821CDC40; continue 'dispatch;
	}
	// 821CDC1C: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDC20: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 821CDC24: 81580004  lwz r10, 4(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDC28: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 821CDC2C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821CDC30: 7D281E70  srawi r8, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 821CDC34: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821CDC38: 4198FFC4  blt cr6, 0x821cdbfc
	if ctx.cr[6].lt {
	pc = 0x821CDBFC; continue 'dispatch;
	}
	// 821CDC3C: 48000008  b 0x821cdc44
	pc = 0x821CDC44; continue 'dispatch;
            }
            0x821CDC40 => {
    //   block [0x821CDC40..0x821CDC44)
	// 821CDC40: 7EBDAB78  mr r29, r21
	ctx.r[29].u64 = ctx.r[21].u64;
	pc = 0x821CDC44; continue 'dispatch;
            }
            0x821CDC44 => {
    //   block [0x821CDC44..0x821CDC88)
	// 821CDC44: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 821CDC48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CDC4C: 419A0320  beq cr6, 0x821cdf6c
	if ctx.cr[6].eq {
	pc = 0x821CDF6C; continue 'dispatch;
	}
	// 821CDC50: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 821CDC54: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821CDC58: FFC0E090  fmr f30, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[28].f64;
	// 821CDC5C: D3C10050  stfs f30, 0x50(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821CDC60: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 821CDC64: FFA0E090  fmr f29, f28
	ctx.f[29].f64 = ctx.f[28].f64;
	// 821CDC68: D3A10054  stfs f29, 0x54(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821CDC6C: FFE0D890  fmr f31, f27
	ctx.f[31].f64 = ctx.f[27].f64;
	// 821CDC70: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CDC74: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 821CDC78: E9010060  ld r8, 0x60(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821CDC7C: F9010068  std r8, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[8].u64 ) };
	// 821CDC80: 83410068  lwz r26, 0x68(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 821CDC84: 8361006C  lwz r27, 0x6c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	pc = 0x821CDC88; continue 'dispatch;
            }
            0x821CDC88 => {
    //   block [0x821CDC88..0x821CDC9C)
	// 821CDC88: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 821CDC8C: 419A0010  beq cr6, 0x821cdc9c
	if ctx.cr[6].eq {
	pc = 0x821CDC9C; continue 'dispatch;
	}
	// 821CDC90: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 821CDC94: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CDC98: 419A0008  beq cr6, 0x821cdca0
	if ctx.cr[6].eq {
	pc = 0x821CDCA0; continue 'dispatch;
	}
	pc = 0x821CDC9C; continue 'dispatch;
            }
            0x821CDC9C => {
    //   block [0x821CDC9C..0x821CDCA0)
	// 821CDC9C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821CDCA0; continue 'dispatch;
            }
            0x821CDCA0 => {
    //   block [0x821CDCA0..0x821CDCB8)
	// 821CDCA0: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821CDCA4: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CDCA8: 419A014C  beq cr6, 0x821cddf4
	if ctx.cr[6].eq {
	pc = 0x821CDDF4; continue 'dispatch;
	}
	// 821CDCAC: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 821CDCB0: 409A0008  bne cr6, 0x821cdcb8
	if !ctx.cr[6].eq {
	pc = 0x821CDCB8; continue 'dispatch;
	}
	// 821CDCB4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821CDCB8; continue 'dispatch;
            }
            0x821CDCB8 => {
    //   block [0x821CDCB8..0x821CDCC8)
	// 821CDCB8: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDCBC: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CDCC0: 409A0008  bne cr6, 0x821cdcc8
	if !ctx.cr[6].eq {
	pc = 0x821CDCC8; continue 'dispatch;
	}
	// 821CDCC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821CDCC8; continue 'dispatch;
            }
            0x821CDCC8 => {
    //   block [0x821CDCC8..0x821CDD24)
	// 821CDCC8: 83DB0008  lwz r30, 8(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDCCC: FF1FD000  fcmpu cr6, f31, f26
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[26].f64);
	// 821CDCD0: 40990054  ble cr6, 0x821cdd24
	if !ctx.cr[6].gt {
	pc = 0x821CDD24; continue 'dispatch;
	}
	// 821CDCD4: C81E0040  lfd f0, 0x40(r30)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) };
	// 821CDCD8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821CDCDC: 40990048  ble cr6, 0x821cdd24
	if !ctx.cr[6].gt {
	pc = 0x821CDD24; continue 'dispatch;
	}
	// 821CDCE0: 89770025  lbz r11, 0x25(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[23].u32.wrapping_add(37 as u32) ) } as u64;
	// 821CDCE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CDCE8: 409A010C  bne cr6, 0x821cddf4
	if !ctx.cr[6].eq {
	pc = 0x821CDDF4; continue 'dispatch;
	}
	// 821CDCEC: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CDCF0: DBE100A0  stfd f31, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.f[31].u64 ) };
	// 821CDCF4: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821CDCF8: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 821CDCFC: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 821CDD00: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 821CDD04: F9410094  std r10, 0x94(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[10].u64 ) };
	// 821CDD08: 486B5C21  bl 0x82883928
	ctx.lr = 0x821CDD0C;
	sub_82883928(ctx, base);
	// 821CDD0C: D3810070  stfs f28, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821CDD10: D3810074  stfs f28, 0x74(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 821CDD14: E9210070  ld r9, 0x70(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 821CDD18: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 821CDD1C: C3A10054  lfs f29, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821CDD20: C3C10050  lfs f30, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	pc = 0x821CDD24; continue 'dispatch;
            }
            0x821CDD24 => {
    //   block [0x821CDD24..0x821CDD40)
	// 821CDD24: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDD28: 7EBCAB78  mr r28, r21
	ctx.r[28].u64 = ctx.r[21].u64;
	// 821CDD2C: 81580004  lwz r10, 4(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDD30: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821CDD34: 7D281E71  srawi. r8, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821CDD38: 418200A4  beq 0x821cdddc
	if ctx.cr[0].eq {
	pc = 0x821CDDDC; continue 'dispatch;
	}
	// 821CDD3C: 7EBDAB78  mr r29, r21
	ctx.r[29].u64 = ctx.r[21].u64;
	pc = 0x821CDD40; continue 'dispatch;
            }
            0x821CDD40 => {
    //   block [0x821CDD40..0x821CDDBC)
	// 821CDD40: 81770018  lwz r11, 0x18(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(24 as u32) ) } as u64;
	// 821CDD44: 895E0038  lbz r10, 0x38(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 821CDD48: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CDD4C: 7FEBE82E  lwzx r31, r11, r29
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 821CDD50: 409A006C  bne cr6, 0x821cddbc
	if !ctx.cr[6].eq {
	pc = 0x821CDDBC; continue 'dispatch;
	}
	// 821CDD54: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CDD58: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 821CDD5C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821CDD60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CDD64: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CDD68: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CDD6C: 4E800421  bctrl
	ctx.lr = 0x821CDD70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CDD70: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821CDD74: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821CDD78: 419A0044  beq cr6, 0x821cddbc
	if ctx.cr[6].eq {
	pc = 0x821CDDBC; continue 'dispatch;
	}
	// 821CDD7C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CDD80: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821CDD84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CDD88: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 821CDD8C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CDD90: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CDD94: 4E800421  bctrl
	ctx.lr = 0x821CDD98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CDD98: E9230000  ld r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821CDD9C: CBFE0040  lfd f31, 0x40(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) };
	// 821CDDA0: F9210068  std r9, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u64 ) };
	// 821CDDA4: C1A1006C  lfs f13, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821CDDA8: EFBD682A  fadds f29, f29, f13
	ctx.f[29].f64 = ((ctx.f[29].f64 + ctx.f[13].f64) as f32) as f64;
	// 821CDDAC: D3A10054  stfs f29, 0x54(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821CDDB0: C0010068  lfs f0, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821CDDB4: EFC0F02A  fadds f30, f0, f30
	ctx.f[30].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 821CDDB8: D3C10050  stfs f30, 0x50(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
            }
            0x821CDDBC => {
    //   block [0x821CDDBC..0x821CDDDC)
	// 821CDDBC: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDDC0: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 821CDDC4: 81580004  lwz r10, 4(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDDC8: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 821CDDCC: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821CDDD0: 7D281E70  srawi r8, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 821CDDD4: 7F1C4040  cmplw cr6, r28, r8
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821CDDD8: 4198FF68  blt cr6, 0x821cdd40
	if ctx.cr[6].lt {
	pc = 0x821CDD40; continue 'dispatch;
	}
	pc = 0x821CDDDC; continue 'dispatch;
            }
            0x821CDDDC => {
    //   block [0x821CDDDC..0x821CDDEC)
	// 821CDDDC: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDDE0: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CDDE4: 409A0008  bne cr6, 0x821cddec
	if !ctx.cr[6].eq {
	pc = 0x821CDDEC; continue 'dispatch;
	}
	// 821CDDE8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821CDDEC; continue 'dispatch;
            }
            0x821CDDEC => {
    //   block [0x821CDDEC..0x821CDDF4)
	// 821CDDEC: 837B0000  lwz r27, 0(r27)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CDDF0: 4BFFFE98  b 0x821cdc88
	pc = 0x821CDC88; continue 'dispatch;
            }
            0x821CDDF4 => {
    //   block [0x821CDDF4..0x821CDE48)
	// 821CDDF4: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CDDF8: DBE100C0  stfd f31, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.f[31].u64 ) };
	// 821CDDFC: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821CDE00: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 821CDE04: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 821CDE08: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 821CDE0C: F94100B4  std r10, 0xb4(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[10].u64 ) };
	// 821CDE10: 486B5B19  bl 0x82883928
	ctx.lr = 0x821CDE14;
	sub_82883928(ctx, base);
	// 821CDE14: 81390008  lwz r9, 8(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDE18: 81190004  lwz r8, 4(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDE1C: 7CE84850  subf r7, r8, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821CDE20: 54E60038  rlwinm r6, r7, 0, 0, 0x1c
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 821CDE24: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821CDE28: 419A0144  beq cr6, 0x821cdf6c
	if ctx.cr[6].eq {
	pc = 0x821CDF6C; continue 'dispatch;
	}
	// 821CDE2C: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDE30: 7EBBAB78  mr r27, r21
	ctx.r[27].u64 = ctx.r[21].u64;
	// 821CDE34: 81580004  lwz r10, 4(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDE38: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821CDE3C: 7D281E71  srawi. r8, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821CDE40: 4182012C  beq 0x821cdf6c
	if ctx.cr[0].eq {
	pc = 0x821CDF6C; continue 'dispatch;
	}
	// 821CDE44: 7EBCAB78  mr r28, r21
	ctx.r[28].u64 = ctx.r[21].u64;
	pc = 0x821CDE48; continue 'dispatch;
            }
            0x821CDE48 => {
    //   block [0x821CDE48..0x821CDE60)
	// 821CDE48: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821CDE4C: 3BC10080  addi r30, r1, 0x80
	ctx.r[30].s64 = ctx.r[1].s64 + 128;
	// 821CDE50: 81570018  lwz r10, 0x18(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(24 as u32) ) } as u64;
	// 821CDE54: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 821CDE58: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CDE5C: 7FAAE02E  lwzx r29, r10, r28
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	pc = 0x821CDE60; continue 'dispatch;
            }
            0x821CDE60 => {
    //   block [0x821CDE60..0x821CDE64)
	// 821CDE60: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	pc = 0x821CDE64; continue 'dispatch;
            }
            0x821CDE64 => {
    //   block [0x821CDE64..0x821CDE78)
	// 821CDE64: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821CDE68: 419A0010  beq cr6, 0x821cde78
	if ctx.cr[6].eq {
	pc = 0x821CDE78; continue 'dispatch;
	}
	// 821CDE6C: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 821CDE70: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CDE74: 419A0008  beq cr6, 0x821cde7c
	if ctx.cr[6].eq {
	pc = 0x821CDE7C; continue 'dispatch;
	}
	pc = 0x821CDE78; continue 'dispatch;
            }
            0x821CDE78 => {
    //   block [0x821CDE78..0x821CDE7C)
	// 821CDE78: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821CDE7C; continue 'dispatch;
            }
            0x821CDE7C => {
    //   block [0x821CDE7C..0x821CDE94)
	// 821CDE7C: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821CDE80: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CDE84: 419A00C8  beq cr6, 0x821cdf4c
	if ctx.cr[6].eq {
	pc = 0x821CDF4C; continue 'dispatch;
	}
	// 821CDE88: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821CDE8C: 409A0008  bne cr6, 0x821cde94
	if !ctx.cr[6].eq {
	pc = 0x821CDE94; continue 'dispatch;
	}
	// 821CDE90: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821CDE94; continue 'dispatch;
            }
            0x821CDE94 => {
    //   block [0x821CDE94..0x821CDEA4)
	// 821CDE94: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDE98: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CDE9C: 409A0008  bne cr6, 0x821cdea4
	if !ctx.cr[6].eq {
	pc = 0x821CDEA4; continue 'dispatch;
	}
	// 821CDEA0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821CDEA4; continue 'dispatch;
            }
            0x821CDEA4 => {
    //   block [0x821CDEA4..0x821CDEE4)
	// 821CDEA4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CDEA8: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 821CDEAC: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDEB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821CDEB4: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CDEB8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CDEBC: 4E800421  bctrl
	ctx.lr = 0x821CDEC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CDEC0: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821CDEC4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821CDEC8: 419A006C  beq cr6, 0x821cdf34
	if ctx.cr[6].eq {
	pc = 0x821CDF34; continue 'dispatch;
	}
	// 821CDECC: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821CDED0: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDED4: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821CDED8: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 821CDEDC: 409A0008  bne cr6, 0x821cdee4
	if !ctx.cr[6].eq {
	pc = 0x821CDEE4; continue 'dispatch;
	}
	// 821CDEE0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
            }
            0x821CDEE4 => {
    //   block [0x821CDEE4..0x821CDF20)
	// 821CDEE4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CDEE8: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821CDEEC: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821CDEF0: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 821CDEF4: 419A002C  beq cr6, 0x821cdf20
	if ctx.cr[6].eq {
	pc = 0x821CDF20; continue 'dispatch;
	}
	// 821CDEF8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDEFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CDF00: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821CDF04: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDF08: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CDF0C: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821CDF10: 4804DE29  bl 0x8221bd38
	ctx.lr = 0x821CDF14;
	sub_8221BD38(ctx, base);
	// 821CDF14: 80E10088  lwz r7, 0x88(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 821CDF18: 38C7FFFF  addi r6, r7, -1
	ctx.r[6].s64 = ctx.r[7].s64 + -1;
	// 821CDF1C: 90C10088  stw r6, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[6].u32 ) };
	pc = 0x821CDF20; continue 'dispatch;
            }
            0x821CDF20 => {
    //   block [0x821CDF20..0x821CDF34)
	// 821CDF20: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821CDF24: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821CDF28: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821CDF2C: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821CDF30: 4BFFFF34  b 0x821cde64
	pc = 0x821CDE64; continue 'dispatch;
            }
            0x821CDF34 => {
    //   block [0x821CDF34..0x821CDF44)
	// 821CDF34: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDF38: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CDF3C: 409A0008  bne cr6, 0x821cdf44
	if !ctx.cr[6].eq {
	pc = 0x821CDF44; continue 'dispatch;
	}
	// 821CDF40: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821CDF44; continue 'dispatch;
            }
            0x821CDF44 => {
    //   block [0x821CDF44..0x821CDF4C)
	// 821CDF44: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CDF48: 4BFFFF18  b 0x821cde60
	pc = 0x821CDE60; continue 'dispatch;
            }
            0x821CDF4C => {
    //   block [0x821CDF4C..0x821CDF6C)
	// 821CDF4C: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDF50: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 821CDF54: 81580004  lwz r10, 4(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDF58: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 821CDF5C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821CDF60: 7D281E70  srawi r8, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 821CDF64: 7F1B4040  cmplw cr6, r27, r8
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821CDF68: 4198FEE0  blt cr6, 0x821cde48
	if ctx.cr[6].lt {
	pc = 0x821CDE48; continue 'dispatch;
	}
	pc = 0x821CDF6C; continue 'dispatch;
            }
            0x821CDF6C => {
    //   block [0x821CDF6C..0x821CDF8C)
	// 821CDF6C: 81700004  lwz r11, 4(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDF70: 3A730001  addi r19, r19, 1
	ctx.r[19].s64 = ctx.r[19].s64 + 1;
	// 821CDF74: 81500008  lwz r10, 8(r16)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CDF78: 3A940028  addi r20, r20, 0x28
	ctx.r[20].s64 = ctx.r[20].s64 + 40;
	// 821CDF7C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821CDF80: 7D0993D6  divw r8, r9, r18
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[18].s32;
	// 821CDF84: 7F134040  cmplw cr6, r19, r8
	ctx.cr[6].compare_u32(ctx.r[19].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821CDF88: 4198FBD8  blt cr6, 0x821cdb60
	if ctx.cr[6].lt {
	pc = 0x821CDB60; continue 'dispatch;
	}
	pc = 0x821CDF8C; continue 'dispatch;
            }
            0x821CDF8C => {
    //   block [0x821CDF8C..0x821CDFB0)
	// 821CDF8C: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821CDF90: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CDF94: 914A0000  stw r10, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821CDF98: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821CDF9C: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821CDFA0: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821CDFA4: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821CDFA8: 92A10088  stw r21, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[21].u32 ) };
	// 821CDFAC: 419A0020  beq cr6, 0x821cdfcc
	if ctx.cr[6].eq {
	pc = 0x821CDFCC; continue 'dispatch;
	}
	pc = 0x821CDFB0; continue 'dispatch;
            }
            0x821CDFB0 => {
    //   block [0x821CDFB0..0x821CDFCC)
	// 821CDFB0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821CDFB4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CDFB8: 4804DD81  bl 0x8221bd38
	ctx.lr = 0x821CDFBC;
	sub_8221BD38(ctx, base);
	// 821CDFBC: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821CDFC0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821CDFC4: 7F1F1840  cmplw cr6, r31, r3
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821CDFC8: 409AFFE8  bne cr6, 0x821cdfb0
	if !ctx.cr[6].eq {
	pc = 0x821CDFB0; continue 'dispatch;
	}
	pc = 0x821CDFCC; continue 'dispatch;
            }
            0x821CDFCC => {
    //   block [0x821CDFCC..0x821CDFE0)
	// 821CDFCC: 4804DD6D  bl 0x8221bd38
	ctx.lr = 0x821CDFD0;
	sub_8221BD38(ctx, base);
	// 821CDFD0: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 821CDFD4: 3981FF78  addi r12, r1, -0x88
	ctx.r[12].s64 = ctx.r[1].s64 + -136;
	// 821CDFD8: 48ADFD45  bl 0x82cadd1c
	ctx.lr = 0x821CDFDC;
	sub_82CADCEC(ctx, base);
	// 821CDFDC: 48ADB44C  b 0x82ca9428
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CDFE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821CDFE0 size=212
    let mut pc: u32 = 0x821CDFE0;
    'dispatch: loop {
        match pc {
            0x821CDFE0 => {
    //   block [0x821CDFE0..0x821CE0B4)
	// 821CDFE0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821CDFE4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821CDFE8: 392B6A70  addi r9, r11, 0x6a70
	ctx.r[9].s64 = ctx.r[11].s64 + 27248;
	// 821CDFEC: 390A1BEC  addi r8, r10, 0x1bec
	ctx.r[8].s64 = ctx.r[10].s64 + 7148;
	// 821CDFF0: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821CDFF4: 80E40004  lwz r7, 4(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CDFF8: 90E30004  stw r7, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821CDFFC: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821CE000: 80C40008  lwz r6, 8(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CE004: 90C30008  stw r6, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 821CE008: 80A4000C  lwz r5, 0xc(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CE00C: 90A3000C  stw r5, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	// 821CE010: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CE014: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 821CE018: 81440014  lwz r10, 0x14(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 821CE01C: 91430014  stw r10, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 821CE020: 81240018  lwz r9, 0x18(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 821CE024: 91230018  stw r9, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 821CE028: 8104001C  lwz r8, 0x1c(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 821CE02C: 9103001C  stw r8, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[8].u32 ) };
	// 821CE030: C0040020  lfs f0, 0x20(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821CE034: D0030020  stfs f0, 0x20(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821CE038: C1A40024  lfs f13, 0x24(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821CE03C: D1A30024  stfs f13, 0x24(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821CE040: C1840028  lfs f12, 0x28(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821CE044: D1830028  stfs f12, 0x28(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 821CE048: C164002C  lfs f11, 0x2c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821CE04C: D163002C  stfs f11, 0x2c(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 821CE050: C1440030  lfs f10, 0x30(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821CE054: D1430030  stfs f10, 0x30(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 821CE058: C1240034  lfs f9, 0x34(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821CE05C: D1230034  stfs f9, 0x34(r3)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821CE060: C1040038  lfs f8, 0x38(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(56 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821CE064: D1030038  stfs f8, 0x38(r3)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 821CE068: C0E4003C  lfs f7, 0x3c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821CE06C: D0E3003C  stfs f7, 0x3c(r3)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 821CE070: C0C40040  lfs f6, 0x40(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(64 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821CE074: D0C30040  stfs f6, 0x40(r3)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 821CE078: C0A40044  lfs f5, 0x44(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(68 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821CE07C: D0A30044  stfs f5, 0x44(r3)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 821CE080: C0840048  lfs f4, 0x48(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 821CE084: D0830048  stfs f4, 0x48(r3)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 821CE088: C064004C  lfs f3, 0x4c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 821CE08C: D063004C  stfs f3, 0x4c(r3)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 821CE090: C0440050  lfs f2, 0x50(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(80 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821CE094: D0430050  stfs f2, 0x50(r3)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821CE098: 88E40054  lbz r7, 0x54(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 821CE09C: 98E30054  stb r7, 0x54(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[7].u8 ) };
	// 821CE0A0: 88C40055  lbz r6, 0x55(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(85 as u32) ) } as u64;
	// 821CE0A4: 98C30055  stb r6, 0x55(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(85 as u32), ctx.r[6].u8 ) };
	// 821CE0A8: 80A40058  lwz r5, 0x58(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(88 as u32) ) } as u64;
	// 821CE0AC: 90A30058  stw r5, 0x58(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[5].u32 ) };
	// 821CE0B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CE0B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CE0B8 size=132
    let mut pc: u32 = 0x821CE0B8;
    'dispatch: loop {
        match pc {
            0x821CE0B8 => {
    //   block [0x821CE0B8..0x821CE0E4)
	// 821CE0B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CE0BC: 48ADB34D  bl 0x82ca9408
	ctx.lr = 0x821CE0C0;
	sub_82CA93D0(ctx, base);
	// 821CE0C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CE0C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821CE0C8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821CE0CC: 897E0040  lbz r11, 0x40(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 821CE0D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CE0D4: 419A0010  beq cr6, 0x821ce0e4
	if ctx.cr[6].eq {
	pc = 0x821CE0E4; continue 'dispatch;
	}
	// 821CE0D8: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 821CE0DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CE0E0: 419A0050  beq cr6, 0x821ce130
	if ctx.cr[6].eq {
	pc = 0x821CE130; continue 'dispatch;
	}
	pc = 0x821CE0E4; continue 'dispatch;
            }
            0x821CE0E4 => {
    //   block [0x821CE0E4..0x821CE0F8)
	// 821CE0E4: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 821CE0E8: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 821CE0EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CE0F0: 419A0008  beq cr6, 0x821ce0f8
	if ctx.cr[6].eq {
	pc = 0x821CE0F8; continue 'dispatch;
	}
	// 821CE0F4: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	pc = 0x821CE0F8; continue 'dispatch;
            }
            0x821CE0F8 => {
    //   block [0x821CE0F8..0x821CE104)
	// 821CE0F8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821CE0FC: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821CE100: 41980028  blt cr6, 0x821ce128
	if ctx.cr[6].lt {
	pc = 0x821CE128; continue 'dispatch;
	}
	pc = 0x821CE104; continue 'dispatch;
            }
            0x821CE104 => {
    //   block [0x821CE104..0x821CE128)
	// 821CE104: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821CE108: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821CE10C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821CE110: 48020461  bl 0x821ee570
	ctx.lr = 0x821CE114;
	sub_821EE570(ctx, base);
	// 821CE114: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CE118: 409A001C  bne cr6, 0x821ce134
	if !ctx.cr[6].eq {
	pc = 0x821CE134; continue 'dispatch;
	}
	// 821CE11C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821CE120: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 821CE124: 4099FFE0  ble cr6, 0x821ce104
	if !ctx.cr[6].gt {
	pc = 0x821CE104; continue 'dispatch;
	}
	pc = 0x821CE128; continue 'dispatch;
            }
            0x821CE128 => {
    //   block [0x821CE128..0x821CE130)
	// 821CE128: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CE12C: 997E0040  stb r11, 0x40(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(64 as u32), ctx.r[11].u8 ) };
	pc = 0x821CE130; continue 'dispatch;
            }
            0x821CE130 => {
    //   block [0x821CE130..0x821CE134)
	// 821CE130: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x821CE134; continue 'dispatch;
            }
            0x821CE134 => {
    //   block [0x821CE134..0x821CE13C)
	// 821CE134: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821CE138: 48ADB320  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CE140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CE140 size=512
    let mut pc: u32 = 0x821CE140;
    'dispatch: loop {
        match pc {
            0x821CE140 => {
    //   block [0x821CE140..0x821CE170)
	// 821CE140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CE144: 48ADB2B5  bl 0x82ca93f8
	ctx.lr = 0x821CE148;
	sub_82CA93D0(ctx, base);
	// 821CE148: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CE14C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821CE150: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 821CE154: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 821CE158: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 821CE15C: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 821CE160: 817E025C  lwz r11, 0x25c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(604 as u32) ) } as u64;
	// 821CE164: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821CE168: 40990008  ble cr6, 0x821ce170
	if !ctx.cr[6].gt {
	pc = 0x821CE170; continue 'dispatch;
	}
	// 821CE16C: 93BE025C  stw r29, 0x25c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(604 as u32), ctx.r[29].u32 ) };
	pc = 0x821CE170; continue 'dispatch;
            }
            0x821CE170 => {
    //   block [0x821CE170..0x821CE1B0)
	// 821CE170: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CE174: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821CE178: 3BFE000C  addi r31, r30, 0xc
	ctx.r[31].s64 = ctx.r[30].s64 + 12;
	// 821CE17C: 7F9BE378  mr r27, r28
	ctx.r[27].u64 = ctx.r[28].u64;
	// 821CE180: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 821CE184: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CE188: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 821CE18C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821CE190: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821CE194: 4883F765  bl 0x82a0d8f8
	ctx.lr = 0x821CE198;
	sub_82A0D8F8(ctx, base);
	// 821CE198: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821CE19C: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CE1A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CE1A4: 419A000C  beq cr6, 0x821ce1b0
	if ctx.cr[6].eq {
	pc = 0x821CE1B0; continue 'dispatch;
	}
	// 821CE1A8: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821CE1AC: 419A0008  beq cr6, 0x821ce1b4
	if ctx.cr[6].eq {
	pc = 0x821CE1B4; continue 'dispatch;
	}
	pc = 0x821CE1B0; continue 'dispatch;
            }
            0x821CE1B0 => {
    //   block [0x821CE1B0..0x821CE1B4)
	// 821CE1B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821CE1B4; continue 'dispatch;
            }
            0x821CE1B4 => {
    //   block [0x821CE1B4..0x821CE1CC)
	// 821CE1B4: 8121005C  lwz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821CE1B8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821CE1BC: 419A005C  beq cr6, 0x821ce218
	if ctx.cr[6].eq {
	pc = 0x821CE218; continue 'dispatch;
	}
	// 821CE1C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CE1C4: 409A0008  bne cr6, 0x821ce1cc
	if !ctx.cr[6].eq {
	pc = 0x821CE1CC; continue 'dispatch;
	}
	// 821CE1C8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821CE1CC; continue 'dispatch;
            }
            0x821CE1CC => {
    //   block [0x821CE1CC..0x821CE1DC)
	// 821CE1CC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CE1D0: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CE1D4: 409A0008  bne cr6, 0x821ce1dc
	if !ctx.cr[6].eq {
	pc = 0x821CE1DC; continue 'dispatch;
	}
	// 821CE1D8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821CE1DC; continue 'dispatch;
            }
            0x821CE1DC => {
    //   block [0x821CE1DC..0x821CE1FC)
	// 821CE1DC: 81690010  lwz r11, 0x10(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CE1E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CE1E4: 419A0034  beq cr6, 0x821ce218
	if ctx.cr[6].eq {
	pc = 0x821CE218; continue 'dispatch;
	}
	// 821CE1E8: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 821CE1EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CE1F0: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 821CE1F4: 419A0024  beq cr6, 0x821ce218
	if ctx.cr[6].eq {
	pc = 0x821CE218; continue 'dispatch;
	}
	// 821CE1F8: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	pc = 0x821CE1FC; continue 'dispatch;
            }
            0x821CE1FC => {
    //   block [0x821CE1FC..0x821CE218)
	// 821CE1FC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821CE200: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CE204: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821CE208: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821CE20C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821CE210: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CE214: 4082FFE8  bne 0x821ce1fc
	if !ctx.cr[0].eq {
	pc = 0x821CE1FC; continue 'dispatch;
	}
	pc = 0x821CE218; continue 'dispatch;
            }
            0x821CE218 => {
    //   block [0x821CE218..0x821CE268)
	// 821CE218: 38600044  li r3, 0x44
	ctx.r[3].s64 = 68;
	// 821CE21C: 4805103D  bl 0x8221f258
	ctx.lr = 0x821CE220;
	sub_8221F258(ctx, base);
	// 821CE220: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821CE224: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821CE228: 419A0090  beq cr6, 0x821ce2b8
	if ctx.cr[6].eq {
	pc = 0x821CE2B8; continue 'dispatch;
	}
	// 821CE22C: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 821CE230: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 821CE234: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 821CE238: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821CE23C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821CE240: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821CE244: 4BFE995D  bl 0x821b7ba0
	ctx.lr = 0x821CE248;
	sub_821B7BA0(ctx, base);
	// 821CE248: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821CE24C: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 821CE250: 394B0FBC  addi r10, r11, 0xfbc
	ctx.r[10].s64 = ctx.r[11].s64 + 4028;
	// 821CE254: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821CE258: 48051001  bl 0x8221f258
	ctx.lr = 0x821CE25C;
	sub_8221F258(ctx, base);
	// 821CE25C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CE260: 419A0008  beq cr6, 0x821ce268
	if ctx.cr[6].eq {
	pc = 0x821CE268; continue 'dispatch;
	}
	// 821CE264: 93830000  stw r28, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x821CE268; continue 'dispatch;
            }
            0x821CE268 => {
    //   block [0x821CE268..0x821CE274)
	// 821CE268: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CE26C: 41820008  beq 0x821ce274
	if ctx.cr[0].eq {
	pc = 0x821CE274; continue 'dispatch;
	}
	// 821CE270: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x821CE274; continue 'dispatch;
            }
            0x821CE274 => {
    //   block [0x821CE274..0x821CE280)
	// 821CE274: 35630008  addic. r11, r3, 8
	ctx.xer.ca = (ctx.r[3].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CE278: 41820008  beq 0x821ce280
	if ctx.cr[0].eq {
	pc = 0x821CE280; continue 'dispatch;
	}
	// 821CE27C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x821CE280; continue 'dispatch;
            }
            0x821CE280 => {
    //   block [0x821CE280..0x821CE2B8)
	// 821CE280: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821CE284: 9B830015  stb r28, 0x15(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(21 as u32), ctx.r[28].u8 ) };
	// 821CE288: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821CE28C: 99430014  stb r10, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 821CE290: 907F003C  stw r3, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[3].u32 ) };
	// 821CE294: 99430015  stb r10, 0x15(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(21 as u32), ctx.r[10].u8 ) };
	// 821CE298: 815F003C  lwz r10, 0x3c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 821CE29C: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821CE2A0: 813F003C  lwz r9, 0x3c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 821CE2A4: 91290000  stw r9, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821CE2A8: 811F003C  lwz r8, 0x3c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 821CE2AC: 91080008  stw r8, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 821CE2B0: 939F0040  stw r28, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[28].u32 ) };
	// 821CE2B4: 48000008  b 0x821ce2bc
	pc = 0x821CE2BC; continue 'dispatch;
            }
            0x821CE2B8 => {
    //   block [0x821CE2B8..0x821CE2BC)
	// 821CE2B8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821CE2BC; continue 'dispatch;
            }
            0x821CE2BC => {
    //   block [0x821CE2BC..0x821CE2F8)
	// 821CE2BC: 815E0078  lwz r10, 0x78(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) } as u64;
	// 821CE2C0: 387E0060  addi r3, r30, 0x60
	ctx.r[3].s64 = ctx.r[30].s64 + 96;
	// 821CE2C4: 91780000  stw r11, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821CE2C8: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 821CE2CC: 392A0001  addi r9, r10, 1
	ctx.r[9].s64 = ctx.r[10].s64 + 1;
	// 821CE2D0: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 821CE2D4: 913E0078  stw r9, 0x78(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(120 as u32), ctx.r[9].u32 ) };
	// 821CE2D8: 914B0020  stw r10, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821CE2DC: 811E0064  lwz r8, 0x64(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 821CE2E0: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 821CE2E4: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821CE2E8: 480B9759  bl 0x82287a40
	ctx.lr = 0x821CE2EC;
	sub_82287A40(ctx, base);
	// 821CE2EC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 821CE2F0: 419A0044  beq cr6, 0x821ce334
	if ctx.cr[6].eq {
	pc = 0x821CE334; continue 'dispatch;
	}
	// 821CE2F4: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	pc = 0x821CE2F8; continue 'dispatch;
            }
            0x821CE2F8 => {
    //   block [0x821CE2F8..0x821CE334)
	// 821CE2F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821CE2FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CE300: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821CE304: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821CE308: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821CE30C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821CE310: 4082FFE8  bne 0x821ce2f8
	if !ctx.cr[0].eq {
	pc = 0x821CE2F8; continue 'dispatch;
	}
	// 821CE314: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821CE318: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CE31C: 409A0018  bne cr6, 0x821ce334
	if !ctx.cr[6].eq {
	pc = 0x821CE334; continue 'dispatch;
	}
	// 821CE320: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CE324: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821CE328: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CE32C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CE330: 4E800421  bctrl
	ctx.lr = 0x821CE334;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821CE334 => {
    //   block [0x821CE334..0x821CE340)
	// 821CE334: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821CE338: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821CE33C: 48ADB10C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CE340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821CE340 size=8
    let mut pc: u32 = 0x821CE340;
    'dispatch: loop {
        match pc {
            0x821CE340 => {
    //   block [0x821CE340..0x821CE348)
	// 821CE340: 80640008  lwz r3, 8(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CE344: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CE348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CE348 size=1848
    let mut pc: u32 = 0x821CE348;
    'dispatch: loop {
        match pc {
            0x821CE348 => {
    //   block [0x821CE348..0x821CEA80)
	// 821CE348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CE34C: 48ADB0A5  bl 0x82ca93f0
	ctx.lr = 0x821CE350;
	sub_82CA93D0(ctx, base);
	// 821CE350: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 821CE354: 48ADF985  bl 0x82cadcd8
	ctx.lr = 0x821CE358;
	sub_82CADCA0(ctx, base);
	// 821CE358: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CE35C: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 821CE360: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 821CE364: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 821CE368: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CEA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821CEA80 size=2820
    let mut pc: u32 = 0x821CEA80;
    'dispatch: loop {
        match pc {
            0x821CEA80 => {
    //   block [0x821CEA80..0x821CEAE8)
	// 821CEA80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CEA84: 48ADA94D  bl 0x82ca93d0
	ctx.lr = 0x821CEA88;
	sub_82CA93D0(ctx, base);
	// 821CEA88: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 821CEA8C: 48ADF231  bl 0x82cadcbc
	ctx.lr = 0x821CEA90;
	sub_82CADCA0(ctx, base);
	// 821CEA90: 9421FCB0  stwu r1, -0x350(r1)
	ea = ctx.r[1].u32.wrapping_add(-848 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CEA94: 7C6F1B78  mr r15, r3
	ctx.r[15].u64 = ctx.r[3].u64;
	// 821CEA98: FF600890  fmr f27, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[27].f64 = ctx.f[1].f64;
	// 821CEA9C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821CEAA0: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 821CEAA4: 7CAE2B78  mr r14, r5
	ctx.r[14].u64 = ctx.r[5].u64;
	// 821CEAA8: 91E10364  stw r15, 0x364(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(868 as u32), ctx.r[15].u32 ) };
	// 821CEAAC: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 821CEAB0: FFA01890  fmr f29, f3
	ctx.f[29].f64 = ctx.f[3].f64;
	// 821CEAB4: 91C10374  stw r14, 0x374(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(884 as u32), ctx.r[14].u32 ) };
	// 821CEAB8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 821CEABC: 816F001C  lwz r11, 0x1c(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(28 as u32) ) } as u64;
	// 821CEAC0: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 821CEAC4: 9341038C  stw r26, 0x38c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(908 as u32), ctx.r[26].u32 ) };
	// 821CEAC8: 7D3B4B78  mr r27, r9
	ctx.r[27].u64 = ctx.r[9].u64;
	// 821CEACC: FF802090  fmr f28, f4
	ctx.f[28].f64 = ctx.f[4].f64;
	// 821CEAD0: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 821CEAD4: FFC02890  fmr f30, f5
	ctx.f[30].f64 = ctx.f[5].f64;
	// 821CEAD8: FF003090  fmr f24, f6
	ctx.f[24].f64 = ctx.f[6].f64;
	// 821CEADC: FEE03890  fmr f23, f7
	ctx.f[23].f64 = ctx.f[7].f64;
	// 821CEAE0: 419A0008  beq cr6, 0x821ceae8
	if ctx.cr[6].eq {
	pc = 0x821CEAE8; continue 'dispatch;
	}
	// 821CEAE4: 48106135  bl 0x822d4c18
	ctx.lr = 0x821CEAE8;
	sub_822D4C18(ctx, base);
	pc = 0x821CEAE8; continue 'dispatch;
            }
            0x821CEAE8 => {
    //   block [0x821CEAE8..0x821CEB48)
	// 821CEAE8: 93CF001C  stw r30, 0x1c(r15)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[15].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 821CEAEC: 2F1E0004  cmpwi cr6, r30, 4
	ctx.cr[6].compare_i32(ctx.r[30].s32, 4, &mut ctx.xer);
	// 821CEAF0: 409A07F8  bne cr6, 0x821cf2e8
	if !ctx.cr[6].eq {
	pc = 0x821CF2E8; continue 'dispatch;
	}
	// 821CEAF4: 822E0028  lwz r17, 0x28(r14)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(40 as u32) ) } as u64;
	// 821CEAF8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821CEAFC: 816F0008  lwz r11, 8(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CEB00: 812F000C  lwz r9, 0xc(r15)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CEB04: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821CEB08: 906100A0  stw r3, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[3].u32 ) };
	// 821CEB0C: 39510008  addi r10, r17, 8
	ctx.r[10].s64 = ctx.r[17].s64 + 8;
	// 821CEB10: 93810104  stw r28, 0x104(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[28].u32 ) };
	// 821CEB14: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821CEB18: 81110010  lwz r8, 0x10(r17)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CEB1C: 80F1000C  lwz r7, 0xc(r17)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CEB20: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 821CEB24: 7CC74050  subf r6, r7, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 821CEB28: E8A100A0  ld r5, 0xa0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 821CEB2C: 90610108  stw r3, 0x108(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[3].u32 ) };
	// 821CEB30: 7CC42670  srawi r4, r6, 4
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[6].s32 >> 4) as i64;
	// 821CEB34: 9061010C  stw r3, 0x10c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), ctx.r[3].u32 ) };
	// 821CEB38: F8A10090  std r5, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[5].u64 ) };
	// 821CEB3C: 908100C8  stw r4, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[4].u32 ) };
	// 821CEB40: 419A0020  beq cr6, 0x821ceb60
	if ctx.cr[6].eq {
	pc = 0x821CEB60; continue 'dispatch;
	}
	// 821CEB44: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	pc = 0x821CEB48; continue 'dispatch;
            }
            0x821CEB48 => {
    //   block [0x821CEB48..0x821CEB60)
	// 821CEB48: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CEB4C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821CEB50: 986A00A0  stb r3, 0xa0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(160 as u32), ctx.r[3].u8 ) };
	// 821CEB54: 812F000C  lwz r9, 0xc(r15)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CEB58: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821CEB5C: 409AFFEC  bne cr6, 0x821ceb48
	if !ctx.cr[6].eq {
	pc = 0x821CEB48; continue 'dispatch;
	}
	pc = 0x821CEB60; continue 'dispatch;
            }
            0x821CEB60 => {
    //   block [0x821CEB60..0x821CEC18)
	// 821CEB60: 7C701B78  mr r16, r3
	ctx.r[16].u64 = ctx.r[3].u64;
	// 821CEB64: 836103DC  lwz r27, 0x3dc(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(988 as u32) ) } as u64;
	// 821CEB68: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 821CEB6C: 920100A8  stw r16, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[16].u32 ) };
	// 821CEB70: 409905F4  ble cr6, 0x821cf164
	if !ctx.cr[6].gt {
	pc = 0x821CF164; continue 'dispatch;
	}
	// 821CEB74: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 821CEB78: 906100A0  stw r3, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[3].u32 ) };
	// 821CEB7C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821CEB80: 388792D8  addi r4, r7, -0x6d28
	ctx.r[4].s64 = ctx.r[7].s64 + -27944;
	// 821CEB84: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 821CEB88: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 821CEB8C: C34792D8  lfs f26, -0x6d28(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27944 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 821CEB90: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 821CEB94: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 821CEB98: C3E401AC  lfs f31, 0x1ac(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(428 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821CEB9C: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 821CEBA0: C32401B8  lfs f25, 0x1b8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(440 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 821CEBA4: 3CA0820F  lis r5, -0x7df1
	ctx.r[5].s64 = -2112946176;
	// 821CEBA8: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 821CEBAC: 3A400010  li r18, 0x10
	ctx.r[18].s64 = 16;
	// 821CEBB0: 3B2B6F14  addi r25, r11, 0x6f14
	ctx.r[25].s64 = ctx.r[11].s64 + 28436;
	// 821CEBB4: 3B0A6EF0  addi r24, r10, 0x6ef0
	ctx.r[24].s64 = ctx.r[10].s64 + 28400;
	// 821CEBB8: 3AE96EFC  addi r23, r9, 0x6efc
	ctx.r[23].s64 = ctx.r[9].s64 + 28412;
	// 821CEBBC: 3AC86EE4  addi r22, r8, 0x6ee4
	ctx.r[22].s64 = ctx.r[8].s64 + 28388;
	// 821CEBC0: 3AA79060  addi r21, r7, -0x6fa0
	ctx.r[21].s64 = ctx.r[7].s64 + -28576;
	// 821CEBC4: 3A869160  addi r20, r6, -0x6ea0
	ctx.r[20].s64 = ctx.r[6].s64 + -28320;
	// 821CEBC8: 3B8544B0  addi r28, r5, 0x44b0
	ctx.r[28].s64 = ctx.r[5].s64 + 17584;
	// 821CEBCC: 3A641148  addi r19, r4, 0x1148
	ctx.r[19].s64 = ctx.r[4].s64 + 4424;
	// 821CEBD0: 816E0014  lwz r11, 0x14(r14)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(20 as u32) ) } as u64;
	// 821CEBD4: 392E0004  addi r9, r14, 4
	ctx.r[9].s64 = ctx.r[14].s64 + 4;
	// 821CEBD8: 80CE0020  lwz r6, 0x20(r14)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(32 as u32) ) } as u64;
	// 821CEBDC: 38EF0004  addi r7, r15, 4
	ctx.r[7].s64 = ctx.r[15].s64 + 4;
	// 821CEBE0: 7CB05A14  add r5, r16, r11
	ctx.r[5].u64 = ctx.r[16].u64 + ctx.r[11].u64;
	// 821CEBE4: 810E0008  lwz r8, 8(r14)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CEBE8: 814F0008  lwz r10, 8(r15)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CEBEC: 7CAB3038  and r11, r5, r6
	ctx.r[11].u64 = ctx.r[5].u64 & ctx.r[6].u64;
	// 821CEBF0: 80CF000C  lwz r6, 0xc(r15)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CEBF4: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821CEBF8: 7C8A3050  subf r4, r10, r6
	ctx.r[4].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821CEBFC: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821CEC00: 914100A4  stw r10, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[10].u32 ) };
	// 821CEC04: 7C8B1E71  srawi. r11, r4, 3
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[4].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CEC08: 55292834  slwi r9, r9, 5
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(5);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821CEC0C: 7FA94214  add r29, r9, r8
	ctx.r[29].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 821CEC10: 835D0020  lwz r26, 0x20(r29)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 821CEC14: 40810054  ble 0x821cec68
	if !ctx.cr[0].gt {
	pc = 0x821CEC68; continue 'dispatch;
	}
	pc = 0x821CEC18; continue 'dispatch;
            }
            0x821CEC18 => {
    //   block [0x821CEC18..0x821CEC38)
	// 821CEC18: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821CEC1C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821CEC20: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821CEC24: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CEC28: 7F07D000  cmpw cr6, r7, r26
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[26].s32, &mut ctx.xer);
	// 821CEC2C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821CEC30: 41980008  blt cr6, 0x821cec38
	if ctx.cr[6].lt {
	pc = 0x821CEC38; continue 'dispatch;
	}
	// 821CEC34: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x821CEC38; continue 'dispatch;
            }
            0x821CEC38 => {
    //   block [0x821CEC38..0x821CEC54)
	// 821CEC38: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821CEC3C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821CEC40: 419A0014  beq cr6, 0x821cec54
	if ctx.cr[6].eq {
	pc = 0x821CEC54; continue 'dispatch;
	}
	// 821CEC44: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821CEC48: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821CEC4C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821CEC50: 4800000C  b 0x821cec5c
	pc = 0x821CEC5C; continue 'dispatch;
            }
            0x821CEC54 => {
    //   block [0x821CEC54..0x821CEC5C)
	// 821CEC54: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821CEC58: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821CEC5C; continue 'dispatch;
            }
            0x821CEC5C => {
    //   block [0x821CEC5C..0x821CEC68)
	// 821CEC5C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CEC60: 4199FFB8  bgt cr6, 0x821cec18
	if ctx.cr[6].gt {
	pc = 0x821CEC18; continue 'dispatch;
	}
	// 821CEC64: 914100A4  stw r10, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[10].u32 ) };
	pc = 0x821CEC68; continue 'dispatch;
            }
            0x821CEC68 => {
    //   block [0x821CEC68..0x821CEC84)
	// 821CEC68: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821CEC6C: 419A0034  beq cr6, 0x821ceca0
	if ctx.cr[6].eq {
	pc = 0x821CECA0; continue 'dispatch;
	}
	// 821CEC70: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CEC74: 7F1A5800  cmpw cr6, r26, r11
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821CEC78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CEC7C: 41980008  blt cr6, 0x821cec84
	if ctx.cr[6].lt {
	pc = 0x821CEC84; continue 'dispatch;
	}
	// 821CEC80: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x821CEC84; continue 'dispatch;
            }
            0x821CEC84 => {
    //   block [0x821CEC84..0x821CECA0)
	// 821CEC84: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CEC88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CEC8C: 409A0014  bne cr6, 0x821ceca0
	if !ctx.cr[6].eq {
	pc = 0x821CECA0; continue 'dispatch;
	}
	// 821CEC90: E96100A0  ld r11, 0xa0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 821CEC94: F9610090  std r11, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u64 ) };
	// 821CEC98: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 821CEC9C: 48000008  b 0x821ceca4
	pc = 0x821CECA4; continue 'dispatch;
            }
            0x821CECA0 => {
    //   block [0x821CECA0..0x821CECA4)
	// 821CECA0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x821CECA4; continue 'dispatch;
            }
            0x821CECA4 => {
    //   block [0x821CECA4..0x821CECCC)
	// 821CECA4: 814F000C  lwz r10, 0xc(r15)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CECA8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821CECAC: 409A0108  bne cr6, 0x821cedb4
	if !ctx.cr[6].eq {
	pc = 0x821CEDB4; continue 'dispatch;
	}
	// 821CECB0: FF1EF800  fcmpu cr6, f30, f31
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 821CECB4: 40990018  ble cr6, 0x821ceccc
	if !ctx.cr[6].gt {
	pc = 0x821CECCC; continue 'dispatch;
	}
	// 821CECB8: FF1CF000  fcmpu cr6, f28, f30
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[30].f64);
	// 821CECBC: 41990010  bgt cr6, 0x821ceccc
	if ctx.cr[6].gt {
	pc = 0x821CECCC; continue 'dispatch;
	}
	// 821CECC0: EC1CF024  fdivs f0, f28, f30
	ctx.f[0].f64 = ((ctx.f[28].f64 / ctx.f[30].f64) as f32) as f64;
	// 821CECC4: EC190028  fsubs f0, f25, f0
	ctx.f[0].f64 = (((ctx.f[25].f64 - ctx.f[0].f64) as f32) as f64);
	// 821CECC8: 48000008  b 0x821cecd0
	pc = 0x821CECD0; continue 'dispatch;
            }
            0x821CECCC => {
    //   block [0x821CECCC..0x821CECD0)
	// 821CECCC: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x821CECD0; continue 'dispatch;
            }
            0x821CECD0 => {
    //   block [0x821CECD0..0x821CECE8)
	// 821CECD0: 816E0028  lwz r11, 0x28(r14)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(40 as u32) ) } as u64;
	// 821CECD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821CECD8: 894B0028  lbz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821CECDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CECE0: 419A0008  beq cr6, 0x821cece8
	if ctx.cr[6].eq {
	pc = 0x821CECE8; continue 'dispatch;
	}
	// 821CECE4: 3BE00800  li r31, 0x800
	ctx.r[31].s64 = 2048;
	pc = 0x821CECE8; continue 'dispatch;
            }
            0x821CECE8 => {
    //   block [0x821CECE8..0x821CED38)
	// 821CECE8: 386000B0  li r3, 0xb0
	ctx.r[3].s64 = 176;
	// 821CECEC: D0010140  stfs f0, 0x140(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 821CECF0: D3C10144  stfs f30, 0x144(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 821CECF4: D3610148  stfs f27, 0x148(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 821CECF8: D3E1014C  stfs f31, 0x14c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 821CECFC: D3E10150  stfs f31, 0x150(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 821CED00: D3E10154  stfs f31, 0x154(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 821CED04: D3E10158  stfs f31, 0x158(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(344 as u32), tmp.u32 ) };
	// 821CED08: D3410164  stfs f26, 0x164(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 821CED0C: 480505B5  bl 0x8221f2c0
	ctx.lr = 0x821CED10;
	sub_8221F2C0(ctx, base);
	// 821CED10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CED14: 409A0084  bne cr6, 0x821ced98
	if !ctx.cr[6].eq {
	pc = 0x821CED98; continue 'dispatch;
	}
	// 821CED18: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821CED1C: 816A6F6C  lwz r11, 0x6f6c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28524 as u32) ) } as u64;
	// 821CED20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CED24: 419A0014  beq cr6, 0x821ced38
	if ctx.cr[6].eq {
	pc = 0x821CED38; continue 'dispatch;
	}
	// 821CED28: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821CED2C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821CED30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821CED34: 4E800421  bctrl
	ctx.lr = 0x821CED38;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821CED38 => {
    //   block [0x821CED38..0x821CED40)
	// 821CED38: 48AF3671  bl 0x82cc23a8
	ctx.lr = 0x821CED3C;
	sub_82CC23A8(ctx, base);
	// 821CED3C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x821CED40; continue 'dispatch;
            }
            0x821CED40 => {
    //   block [0x821CED40..0x821CED7C)
	// 821CED40: 83EF0020  lwz r31, 0x20(r15)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(32 as u32) ) } as u64;
	// 821CED44: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 821CED48: 419A0034  beq cr6, 0x821ced7c
	if ctx.cr[6].eq {
	pc = 0x821CED7C; continue 'dispatch;
	}
	// 821CED4C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CED50: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821CED54: 409A0028  bne cr6, 0x821ced7c
	if !ctx.cr[6].eq {
	pc = 0x821CED7C; continue 'dispatch;
	}
	// 821CED58: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CED5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821CED60: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CED64: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CED68: 4E800421  bctrl
	ctx.lr = 0x821CED6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CED6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CED70: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821CED74: 480CCC9D  bl 0x8229ba10
	ctx.lr = 0x821CED78;
	sub_8229BA10(ctx, base);
	// 821CED78: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
            }
            0x821CED7C => {
    //   block [0x821CED7C..0x821CED98)
	// 821CED7C: 93410098  stw r26, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[26].u32 ) };
	// 821CED80: 38810098  addi r4, r1, 0x98
	ctx.r[4].s64 = ctx.r[1].s64 + 152;
	// 821CED84: 93C1009C  stw r30, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[30].u32 ) };
	// 821CED88: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 821CED8C: 486732D5  bl 0x82842060
	ctx.lr = 0x821CED90;
	sub_82842060(ctx, base);
	// 821CED90: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821CED94: 48000024  b 0x821cedb8
	pc = 0x821CEDB8; continue 'dispatch;
            }
            0x821CED98 => {
    //   block [0x821CED98..0x821CEDB4)
	// 821CED98: 816E0028  lwz r11, 0x28(r14)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(40 as u32) ) } as u64;
	// 821CED9C: 38C10140  addi r6, r1, 0x140
	ctx.r[6].s64 = ctx.r[1].s64 + 320;
	// 821CEDA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CEDA4: 38AB0004  addi r5, r11, 4
	ctx.r[5].s64 = ctx.r[11].s64 + 4;
	// 821CEDA8: 48287FB1  bl 0x82456d58
	ctx.lr = 0x821CEDAC;
	sub_82456D58(ctx, base);
	// 821CEDAC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821CEDB0: 4BFFFF90  b 0x821ced40
	pc = 0x821CED40; continue 'dispatch;
            }
            0x821CEDB4 => {
    //   block [0x821CEDB4..0x821CEDB8)
	// 821CEDB4: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x821CEDB8; continue 'dispatch;
            }
            0x821CEDB8 => {
    //   block [0x821CEDB8..0x821CF14C)
	// 821CEDB8: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CEDBC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CEDC0: 997E00A0  stb r11, 0xa0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(160 as u32), ctx.r[11].u8 ) };
	// 821CEDC4: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 821CEDC8: 419A0384  beq cr6, 0x821cf14c
	if ctx.cr[6].eq {
	pc = 0x821CF14C; continue 'dispatch;
	}
	// 821CEDCC: 39410250  addi r10, r1, 0x250
	ctx.r[10].s64 = ctx.r[1].s64 + 592;
	pc = 0x821CF14C; continue 'dispatch;
            }
            0x821CF14C => {
    //   block [0x821CF14C..0x821CF164)
	// 821CF14C: 8161038C  lwz r11, 0x38c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(908 as u32) ) } as u64;
	// 821CF150: 3A100001  addi r16, r16, 1
	ctx.r[16].s64 = ctx.r[16].s64 + 1;
	// 821CF154: 920100A8  stw r16, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[16].u32 ) };
	// 821CF158: 7F105800  cmpw cr6, r16, r11
	ctx.cr[6].compare_i32(ctx.r[16].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821CF15C: 4198FA74  blt cr6, 0x821cebd0
	if ctx.cr[6].lt {
	pc = 0x821CEBD0; continue 'dispatch;
	}
	// 821CF160: 83810104  lwz r28, 0x104(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	pc = 0x821CF164; continue 'dispatch;
            }
            0x821CF164 => {
    //   block [0x821CF164..0x821CF2E8)
	// 821CF164: 90610098  stw r3, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[3].u32 ) };
	// 821CF168: 816F0008  lwz r11, 8(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CF16C: 814F000C  lwz r10, 0xc(r15)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CF170: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821CF174: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 821CF178: E9210098  ld r9, 0x98(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 821CF17C: F9210090  std r9, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[9].u64 ) };
	// 821CF180: 419A00B4  beq cr6, 0x821cf234
	if ctx.cr[6].eq {
	pc = 0x821CF234; continue 'dispatch;
	}
	// 821CF184: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821CF188: 83C10094  lwz r30, 0x94(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 821CF18C: 3BAB6A70  addi r29, r11, 0x6a70
	ctx.r[29].s64 = ctx.r[11].s64 + 27248;
	// 821CF190: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CF194: 897F00A0  lbz r11, 0xa0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 821CF198: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CF19C: 409A0084  bne cr6, 0x821cf220
	if !ctx.cr[6].eq {
	pc = 0x821CF220; continue 'dispatch;
	}
	// 821CF1A0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CF1A4: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 821CF1A8: 419A0014  beq cr6, 0x821cf1bc
	if ctx.cr[6].eq {
	pc = 0x821CF1BC; continue 'dispatch;
	}
	// 821CF1AC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821CF1B0: 4BFA6769  bl 0x82175918
	ctx.lr = 0x821CF1B4;
	sub_82175918(ctx, base);
	// 821CF1B4: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821CF1B8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821CF1BC: 93BF0010  stw r29, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 821CF1C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CF1C4: 4804CB75  bl 0x8221bd38
	ctx.lr = 0x821CF1C8;
	sub_8221BD38(ctx, base);
	// 821CF1C8: 812F000C  lwz r9, 0xc(r15)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CF1CC: 397E0008  addi r11, r30, 8
	ctx.r[11].s64 = ctx.r[30].s64 + 8;
	// 821CF1D0: 390F0004  addi r8, r15, 4
	ctx.r[8].s64 = ctx.r[15].s64 + 4;
	// 821CF1D4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821CF1D8: 419A0028  beq cr6, 0x821cf200
	if ctx.cr[6].eq {
	pc = 0x821CF200; continue 'dispatch;
	}
	// 821CF1DC: 394BFFF8  addi r10, r11, -8
	ctx.r[10].s64 = ctx.r[11].s64 + -8;
	// 821CF1E0: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CF1E4: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821CF1E8: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CF1EC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821CF1F0: 90CA0004  stw r6, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 821CF1F4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821CF1F8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821CF1FC: 409AFFE4  bne cr6, 0x821cf1e0
	if !ctx.cr[6].eq {
	pc = 0x821CF1E0; continue 'dispatch;
	}
	// 821CF200: E9410090  ld r10, 0x90(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 821CF204: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821CF208: 81680008  lwz r11, 8(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CF20C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 821CF210: F9410090  std r10, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u64 ) };
	// 821CF214: 91280008  stw r9, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 821CF218: 83C10094  lwz r30, 0x94(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 821CF21C: 4800000C  b 0x821cf228
	pc = 0x821CF228; continue 'dispatch;
	// 821CF220: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 821CF224: 93C10094  stw r30, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[30].u32 ) };
	// 821CF228: 816F000C  lwz r11, 0xc(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CF22C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CF230: 409AFF60  bne cr6, 0x821cf190
	if !ctx.cr[6].eq {
	pc = 0x821CF190; continue 'dispatch;
	}
	// 821CF234: 81610108  lwz r11, 0x108(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(264 as u32) ) } as u64;
	// 821CF238: 7D5C5850  subf r10, r28, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 821CF23C: 7D5E1E71  srawi. r30, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[10].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821CF240: 40810040  ble 0x821cf280
	if !ctx.cr[0].gt {
	pc = 0x821CF280; continue 'dispatch;
	}
	// 821CF244: 3BAF0004  addi r29, r15, 4
	ctx.r[29].s64 = ctx.r[15].s64 + 4;
	// 821CF248: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 821CF24C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CF250: 38810098  addi r4, r1, 0x98
	ctx.r[4].s64 = ctx.r[1].s64 + 152;
	// 821CF254: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CF258: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821CF25C: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 821CF260: 9141009C  stw r10, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[10].u32 ) };
	// 821CF264: 48672DFD  bl 0x82842060
	ctx.lr = 0x821CF268;
	sub_82842060(ctx, base);
	// 821CF268: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821CF26C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821CF270: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 821CF274: 993D0011  stb r9, 0x11(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(17 as u32), ctx.r[9].u8 ) };
	// 821CF278: 4082FFD4  bne 0x821cf24c
	if !ctx.cr[0].eq {
	pc = 0x821CF24C; continue 'dispatch;
	}
	// 821CF27C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821CF280: 896F0015  lbz r11, 0x15(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[15].u32.wrapping_add(21 as u32) ) } as u64;
	// 821CF284: 3BEF0004  addi r31, r15, 4
	ctx.r[31].s64 = ctx.r[15].s64 + 4;
	// 821CF288: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CF28C: 419A003C  beq cr6, 0x821cf2c8
	if ctx.cr[6].eq {
	pc = 0x821CF2C8; continue 'dispatch;
	}
	// 821CF290: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CF294: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CF298: 906100A0  stw r3, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[3].u32 ) };
	// 821CF29C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821CF2A0: 90610098  stw r3, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[3].u32 ) };
	// 821CF2A4: 88DF0010  lbz r6, 0x10(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CF2A8: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 821CF2AC: 7D251E70  srawi r5, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 821CF2B0: 9141009C  stw r10, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[10].u32 ) };
	// 821CF2B4: E88100A0  ld r4, 0xa0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 821CF2B8: E8610098  ld r3, 0x98(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 821CF2BC: 48412FED  bl 0x825e22a8
	ctx.lr = 0x821CF2C0;
	sub_825E22A8(ctx, base);
	// 821CF2C0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821CF2C4: 991F0011  stb r8, 0x11(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(17 as u32), ctx.r[8].u8 ) };
	// 821CF2C8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821CF2CC: 419A02A8  beq cr6, 0x821cf574
	if ctx.cr[6].eq {
	pc = 0x821CF574; continue 'dispatch;
	}
	// 821CF2D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821CF2D4: 4804CA65  bl 0x8221bd38
	ctx.lr = 0x821CF2D8;
	sub_8221BD38(ctx, base);
	// 821CF2D8: 38210350  addi r1, r1, 0x350
	ctx.r[1].s64 = ctx.r[1].s64 + 848;
	// 821CF2DC: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 821CF2E0: 48ADEA29  bl 0x82cadd08
	ctx.lr = 0x821CF2E4;
	sub_82CADCEC(ctx, base);
	// 821CF2E4: 48ADA13C  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            0x821CF2E8 => {
    //   block [0x821CF2E8..0x821CF584)
	// 821CF2E8: 816F0018  lwz r11, 0x18(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(24 as u32) ) } as u64;
	// 821CF2EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821CF2F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CF2F4: 409A01AC  bne cr6, 0x821cf4a0
	if !ctx.cr[6].eq {
	pc = 0x821CF4A0; continue 'dispatch;
	}
	// 821CF2F8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821CF2FC: 2F1E0001  cmpwi cr6, r30, 1
	ctx.cr[6].compare_i32(ctx.r[30].s32, 1, &mut ctx.xer);
	// 821CF300: 409A0010  bne cr6, 0x821cf310
	if !ctx.cr[6].eq {
	pc = 0x821CF310; continue 'dispatch;
	}
	// 821CF304: 816E0030  lwz r11, 0x30(r14)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(48 as u32) ) } as u64;
	// 821CF308: 896B0034  lbz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821CF30C: 48000028  b 0x821cf334
	pc = 0x821CF334; continue 'dispatch;
	// 821CF310: 2F1E0002  cmpwi cr6, r30, 2
	ctx.cr[6].compare_i32(ctx.r[30].s32, 2, &mut ctx.xer);
	// 821CF314: 409A0010  bne cr6, 0x821cf324
	if !ctx.cr[6].eq {
	pc = 0x821CF324; continue 'dispatch;
	}
	// 821CF318: 816E0040  lwz r11, 0x40(r14)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(64 as u32) ) } as u64;
	// 821CF31C: 896B0034  lbz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821CF320: 48000014  b 0x821cf334
	pc = 0x821CF334; continue 'dispatch;
	// 821CF324: 2F1E0003  cmpwi cr6, r30, 3
	ctx.cr[6].compare_i32(ctx.r[30].s32, 3, &mut ctx.xer);
	// 821CF328: 409A000C  bne cr6, 0x821cf334
	if !ctx.cr[6].eq {
	pc = 0x821CF334; continue 'dispatch;
	}
	// 821CF32C: 816E002C  lwz r11, 0x2c(r14)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(44 as u32) ) } as u64;
	// 821CF330: 896B0028  lbz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821CF334: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CF338: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 821CF33C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CF340: 419A00AC  beq cr6, 0x821cf3ec
	if ctx.cr[6].eq {
	pc = 0x821CF3EC; continue 'dispatch;
	}
	// 821CF344: 4804FF15  bl 0x8221f258
	ctx.lr = 0x821CF348;
	sub_8221F258(ctx, base);
	// 821CF348: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CF34C: 419A0148  beq cr6, 0x821cf494
	if ctx.cr[6].eq {
	pc = 0x821CF494; continue 'dispatch;
	}
	// 821CF350: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821CF354: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 821CF358: 392B92D8  addi r9, r11, -0x6d28
	ctx.r[9].s64 = ctx.r[11].s64 + -27944;
	// 821CF35C: 390A6F08  addi r8, r10, 0x6f08
	ctx.r[8].s64 = ctx.r[10].s64 + 28424;
	// 821CF360: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821CF364: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821CF368: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821CF36C: 3CA0820F  lis r5, -0x7df1
	ctx.r[5].s64 = -2112946176;
	// 821CF370: 90E30004  stw r7, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821CF374: C00901AC  lfs f0, 0x1ac(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(428 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821CF378: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 821CF37C: 90C30010  stw r6, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 821CF380: C1A901B8  lfs f13, 0x1b8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(440 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821CF384: 93E30014  stw r31, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 821CF388: 38854748  addi r4, r5, 0x4748
	ctx.r[4].s64 = ctx.r[5].s64 + 18248;
	// 821CF38C: 93E30018  stw r31, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[31].u32 ) };
	// 821CF390: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	// 821CF394: 93E3001C  stw r31, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[31].u32 ) };
	// 821CF398: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821CF39C: 93E30020  stw r31, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[31].u32 ) };
	// 821CF3A0: 93E30024  stw r31, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[31].u32 ) };
	// 821CF3A4: D0030028  stfs f0, 0x28(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 821CF3A8: D003002C  stfs f0, 0x2c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 821CF3AC: D0030030  stfs f0, 0x30(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 821CF3B0: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821CF3B4: D0030038  stfs f0, 0x38(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 821CF3B8: D003003C  stfs f0, 0x3c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 821CF3BC: 9BE3005C  stb r31, 0x5c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[31].u8 ) };
	// 821CF3C0: D0030040  stfs f0, 0x40(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 821CF3C4: 9BE3005D  stb r31, 0x5d(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(93 as u32), ctx.r[31].u8 ) };
	// 821CF3C8: D0030044  stfs f0, 0x44(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 821CF3CC: D0030048  stfs f0, 0x48(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 821CF3D0: D003004C  stfs f0, 0x4c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 821CF3D4: D0030050  stfs f0, 0x50(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821CF3D8: D1A30054  stfs f13, 0x54(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821CF3DC: D1A30058  stfs f13, 0x58(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821CF3E0: 93E30060  stw r31, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 821CF3E4: 90830008  stw r4, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 821CF3E8: 480000B0  b 0x821cf498
	pc = 0x821CF498; continue 'dispatch;
	// 821CF3EC: 4804FE6D  bl 0x8221f258
	ctx.lr = 0x821CF3F0;
	sub_8221F258(ctx, base);
	// 821CF3F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CF3F4: 419A00A0  beq cr6, 0x821cf494
	if ctx.cr[6].eq {
	pc = 0x821CF494; continue 'dispatch;
	}
	// 821CF3F8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821CF3FC: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 821CF400: 392B92D8  addi r9, r11, -0x6d28
	ctx.r[9].s64 = ctx.r[11].s64 + -27944;
	// 821CF404: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 821CF408: 38EA6F08  addi r7, r10, 0x6f08
	ctx.r[7].s64 = ctx.r[10].s64 + 28424;
	// 821CF40C: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 821CF410: 38A81BEC  addi r5, r8, 0x1bec
	ctx.r[5].s64 = ctx.r[8].s64 + 7148;
	// 821CF414: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821CF418: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821CF41C: 90C30004  stw r6, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 821CF420: C00901AC  lfs f0, 0x1ac(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(428 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821CF424: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 821CF428: 90A30008  stw r5, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 821CF42C: C1A901B8  lfs f13, 0x1b8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(440 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821CF430: 90830010  stw r4, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[4].u32 ) };
	// 821CF434: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	// 821CF438: 93E30014  stw r31, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 821CF43C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821CF440: 93E30018  stw r31, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[31].u32 ) };
	// 821CF444: 93E3001C  stw r31, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[31].u32 ) };
	// 821CF448: 93E30020  stw r31, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[31].u32 ) };
	// 821CF44C: 93E30024  stw r31, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[31].u32 ) };
	// 821CF450: D0030028  stfs f0, 0x28(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 821CF454: D003002C  stfs f0, 0x2c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 821CF458: D0030030  stfs f0, 0x30(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 821CF45C: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821CF460: D0030038  stfs f0, 0x38(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 821CF464: D003003C  stfs f0, 0x3c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 821CF468: 9BE3005C  stb r31, 0x5c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[31].u8 ) };
	// 821CF46C: D0030040  stfs f0, 0x40(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 821CF470: 9BE3005D  stb r31, 0x5d(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(93 as u32), ctx.r[31].u8 ) };
	// 821CF474: D0030044  stfs f0, 0x44(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 821CF478: D0030048  stfs f0, 0x48(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 821CF47C: D003004C  stfs f0, 0x4c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 821CF480: D0030050  stfs f0, 0x50(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821CF484: D1A30054  stfs f13, 0x54(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821CF488: D1A30058  stfs f13, 0x58(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821CF48C: 93E30060  stw r31, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 821CF490: 48000008  b 0x821cf498
	pc = 0x821CF498; continue 'dispatch;
	// 821CF494: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821CF498: 916F0018  stw r11, 0x18(r15)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[15].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 821CF49C: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 821CF4A0: 816103E4  lwz r11, 0x3e4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(996 as u32) ) } as u64;
	// 821CF4A4: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 821CF4A8: 806F0018  lwz r3, 0x18(r15)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(24 as u32) ) } as u64;
	// 821CF4AC: FCC0B890  fmr f6, f23
	ctx.f[6].f64 = ctx.f[23].f64;
	// 821CF4B0: 88E103D7  lbz r7, 0x3d7(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(983 as u32) ) } as u64;
	// 821CF4B4: FCA0C090  fmr f5, f24
	ctx.f[5].f64 = ctx.f[24].f64;
	// 821CF4B8: 91410084  stw r10, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 821CF4BC: FC80F090  fmr f4, f30
	ctx.f[4].f64 = ctx.f[30].f64;
	// 821CF4C0: FC60E090  fmr f3, f28
	ctx.f[3].f64 = ctx.f[28].f64;
	// 821CF4C4: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 821CF4C8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CF4CC: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 821CF4D0: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 821CF4D4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821CF4D8: 98E1007F  stb r7, 0x7f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(127 as u32), ctx.r[7].u8 ) };
	// 821CF4DC: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 821CF4E0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821CF4E4: 7DC57378  mr r5, r14
	ctx.r[5].u64 = ctx.r[14].u64;
	// 821CF4E8: 90810090  stw r4, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[4].u32 ) };
	// 821CF4EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821CF4F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CF4F4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CF4F8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CF4FC: 4E800421  bctrl
	ctx.lr = 0x821CF500;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CF500: 57E9063E  clrlwi r9, r31, 0x18
	ctx.r[9].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 821CF504: 83C103DC  lwz r30, 0x3dc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(988 as u32) ) } as u64;
	// 821CF508: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821CF50C: 419A0028  beq cr6, 0x821cf534
	if ctx.cr[6].eq {
	pc = 0x821CF534; continue 'dispatch;
	}
	// 821CF510: 808F0020  lwz r4, 0x20(r15)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(32 as u32) ) } as u64;
	// 821CF514: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 821CF518: 419A001C  beq cr6, 0x821cf534
	if ctx.cr[6].eq {
	pc = 0x821CF534; continue 'dispatch;
	}
	// 821CF51C: 816F0000  lwz r11, 0(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CF520: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821CF524: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 821CF528: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CF52C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CF530: 4E800421  bctrl
	ctx.lr = 0x821CF534;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CF534: 83EF0018  lwz r31, 0x18(r15)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(24 as u32) ) } as u64;
	// 821CF538: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CF53C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821CF540: 419A0034  beq cr6, 0x821cf574
	if ctx.cr[6].eq {
	pc = 0x821CF574; continue 'dispatch;
	}
	// 821CF544: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821CF548: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821CF54C: 419A0028  beq cr6, 0x821cf574
	if ctx.cr[6].eq {
	pc = 0x821CF574; continue 'dispatch;
	}
	// 821CF550: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CF554: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CF558: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CF55C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821CF560: 4E800421  bctrl
	ctx.lr = 0x821CF564;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CF564: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821CF568: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821CF56C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CF570: 48092551  bl 0x82261ac0
	ctx.lr = 0x821CF574;
	sub_82261AC0(ctx, base);
	// 821CF574: 38210350  addi r1, r1, 0x350
	ctx.r[1].s64 = ctx.r[1].s64 + 848;
	// 821CF578: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 821CF57C: 48ADE78D  bl 0x82cadd08
	ctx.lr = 0x821CF580;
	sub_82CADCEC(ctx, base);
	// 821CF580: 48AD9EA0  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CF588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821CF588 size=92
    let mut pc: u32 = 0x821CF588;
    'dispatch: loop {
        match pc {
            0x821CF588 => {
    //   block [0x821CF588..0x821CF5B4)
	// 821CF588: 89630007  lbz r11, 7(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(7 as u32) ) } as u64;
	// 821CF58C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821CF590: 81240008  lwz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CF594: 7D4B5830  slw r11, r10, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[10].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 821CF598: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CF59C: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 821CF5A0: 7D0B4838  and r11, r8, r9
	ctx.r[11].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 821CF5A4: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821CF5A8: 7CEB4A14  add r7, r11, r9
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821CF5AC: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821CF5B0: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	pc = 0x821CF5B4; continue 'dispatch;
            }
            0x821CF5B4 => {
    //   block [0x821CF5B4..0x821CF5CC)
	// 821CF5B4: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CF5B8: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821CF5BC: 409A0010  bne cr6, 0x821cf5cc
	if !ctx.cr[6].eq {
	pc = 0x821CF5CC; continue 'dispatch;
	}
	// 821CF5C0: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CF5C4: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821CF5C8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	pc = 0x821CF5CC; continue 'dispatch;
            }
            0x821CF5CC => {
    //   block [0x821CF5CC..0x821CF5E4)
	// 821CF5CC: 80630010  lwz r3, 0x10(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CF5D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CF5D4: 409AFFE0  bne cr6, 0x821cf5b4
	if !ctx.cr[6].eq {
	pc = 0x821CF5B4; continue 'dispatch;
	}
	// 821CF5D8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 821CF5DC: 386B06F4  addi r3, r11, 0x6f4
	ctx.r[3].s64 = ctx.r[11].s64 + 1780;
	// 821CF5E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CF5E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821CF5E8 size=240
    let mut pc: u32 = 0x821CF5E8;
    'dispatch: loop {
        match pc {
            0x821CF5E8 => {
    //   block [0x821CF5E8..0x821CF634)
	// 821CF5E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CF5EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821CF5F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821CF5F4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CF5F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821CF5FC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CF600: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CF604: 419A00A0  beq cr6, 0x821cf6a4
	if ctx.cr[6].eq {
	pc = 0x821CF6A4; continue 'dispatch;
	}
	// 821CF608: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821CF60C: 419A0028  beq cr6, 0x821cf634
	if ctx.cr[6].eq {
	pc = 0x821CF634; continue 'dispatch;
	}
	// 821CF610: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821CF614: 409A0064  bne cr6, 0x821cf678
	if !ctx.cr[6].eq {
	pc = 0x821CF678; continue 'dispatch;
	}
	// 821CF618: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CF61C: 4BFFFF6D  bl 0x821cf588
	ctx.lr = 0x821CF620;
	sub_821CF588(ctx, base);
	// 821CF620: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821CF624: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821CF628: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821CF62C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821CF630: 4E800020  blr
	return;
            }
            0x821CF634 => {
    //   block [0x821CF634..0x821CF678)
	// 821CF634: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821CF638: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821CF63C: D9A10050  stfd f13, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[13].u64 ) };
	// 821CF640: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821CF644: 7C8B07B4  extsw r11, r4
	ctx.r[11].s64 = ctx.r[4].s32 as i64;
	// 821CF648: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821CF64C: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821CF650: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 821CF654: FD405818  frsp f10, f11
	ctx.f[10].f64 = (ctx.f[11].f64 as f32) as f64;
	// 821CF658: FF0A0000  fcmpu cr6, f10, f0
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[0].f64);
	// 821CF65C: 409A001C  bne cr6, 0x821cf678
	if !ctx.cr[6].eq {
	pc = 0x821CF678; continue 'dispatch;
	}
	// 821CF660: 48012279  bl 0x821e18d8
	ctx.lr = 0x821CF664;
	sub_821E18D8(ctx, base);
	// 821CF664: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821CF668: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821CF66C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821CF670: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821CF674: 4E800020  blr
	return;
            }
            0x821CF678 => {
    //   block [0x821CF678..0x821CF684)
	// 821CF678: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CF67C: 48A00CCD  bl 0x82bd0348
	ctx.lr = 0x821CF680;
	sub_82BD0348(ctx, base);
	// 821CF680: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x821CF684; continue 'dispatch;
            }
            0x821CF684 => {
    //   block [0x821CF684..0x821CF6A4)
	// 821CF684: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CF688: 38670008  addi r3, r7, 8
	ctx.r[3].s64 = ctx.r[7].s64 + 8;
	// 821CF68C: 48107F1D  bl 0x822d75a8
	ctx.lr = 0x821CF690;
	sub_822D75A8(ctx, base);
	// 821CF690: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821CF694: 409A002C  bne cr6, 0x821cf6c0
	if !ctx.cr[6].eq {
	pc = 0x821CF6C0; continue 'dispatch;
	}
	// 821CF698: 80E70010  lwz r7, 0x10(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CF69C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821CF6A0: 409AFFE4  bne cr6, 0x821cf684
	if !ctx.cr[6].eq {
	pc = 0x821CF684; continue 'dispatch;
	}
	pc = 0x821CF6A4; continue 'dispatch;
            }
            0x821CF6A4 => {
    //   block [0x821CF6A4..0x821CF6C0)
	// 821CF6A4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 821CF6A8: 386B06F4  addi r3, r11, 0x6f4
	ctx.r[3].s64 = ctx.r[11].s64 + 1780;
	// 821CF6AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821CF6B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821CF6B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821CF6B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821CF6BC: 4E800020  blr
	return;
            }
            0x821CF6C0 => {
    //   block [0x821CF6C0..0x821CF6D8)
	// 821CF6C0: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 821CF6C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821CF6C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821CF6CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821CF6D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821CF6D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CF6D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CF6D8 size=352
    let mut pc: u32 = 0x821CF6D8;
    'dispatch: loop {
        match pc {
            0x821CF6D8 => {
    //   block [0x821CF6D8..0x821CF708)
	// 821CF6D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CF6DC: 48AD9D19  bl 0x82ca93f4
	ctx.lr = 0x821CF6E0;
	sub_82CA93D0(ctx, base);
	// 821CF6E0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CF6E4: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 821CF6E8: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 821CF6EC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821CF6F0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821CF6F4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 821CF6F8: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 821CF6FC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 821CF700: 3B0A06F4  addi r24, r10, 0x6f4
	ctx.r[24].s64 = ctx.r[10].s64 + 1780;
	// 821CF704: 3B2B3B80  addi r25, r11, 0x3b80
	ctx.r[25].s64 = ctx.r[11].s64 + 15232;
	pc = 0x821CF708; continue 'dispatch;
            }
            0x821CF708 => {
    //   block [0x821CF708..0x821CF76C)
	// 821CF708: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CF70C: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 821CF710: 409A0074  bne cr6, 0x821cf784
	if !ctx.cr[6].eq {
	pc = 0x821CF784; continue 'dispatch;
	}
	// 821CF714: 83FD0000  lwz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CF718: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821CF71C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CF720: 4BFFFEC9  bl 0x821cf5e8
	ctx.lr = 0x821CF724;
	sub_821CF5E8(ctx, base);
	// 821CF724: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821CF728: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CF72C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CF730: 409A003C  bne cr6, 0x821cf76c
	if !ctx.cr[6].eq {
	pc = 0x821CF76C; continue 'dispatch;
	}
	// 821CF734: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CF738: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CF73C: 419A0030  beq cr6, 0x821cf76c
	if ctx.cr[6].eq {
	pc = 0x821CF76C; continue 'dispatch;
	}
	// 821CF740: 89630006  lbz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 821CF744: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821CF748: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CF74C: 409A0020  bne cr6, 0x821cf76c
	if !ctx.cr[6].eq {
	pc = 0x821CF76C; continue 'dispatch;
	}
	// 821CF750: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CF754: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821CF758: 80AB00A0  lwz r5, 0xa0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) } as u64;
	// 821CF75C: 48A046A5  bl 0x82bd3e00
	ctx.lr = 0x821CF760;
	sub_82BD3E00(ctx, base);
	// 821CF760: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821CF764: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821CF768: 409A007C  bne cr6, 0x821cf7e4
	if !ctx.cr[6].eq {
	pc = 0x821CF7E4; continue 'dispatch;
	}
	pc = 0x821CF76C; continue 'dispatch;
            }
            0x821CF76C => {
    //   block [0x821CF76C..0x821CF784)
	// 821CF76C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CF770: 91770000  stw r11, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821CF774: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CF778: 91570004  stw r10, 4(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821CF77C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821CF780: 48AD9CC4  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x821CF784 => {
    //   block [0x821CF784..0x821CF7A0)
	// 821CF784: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 821CF788: 419A0018  beq cr6, 0x821cf7a0
	if ctx.cr[6].eq {
	pc = 0x821CF7A0; continue 'dispatch;
	}
	// 821CF78C: 396B001F  addi r11, r11, 0x1f
	ctx.r[11].s64 = ctx.r[11].s64 + 31;
	// 821CF790: 815C0010  lwz r10, 0x10(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CF794: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821CF798: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821CF79C: 4800000C  b 0x821cf7a8
	pc = 0x821CF7A8; continue 'dispatch;
            }
            0x821CF7A0 => {
    //   block [0x821CF7A0..0x821CF7A8)
	// 821CF7A0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CF7A4: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x821CF7A8; continue 'dispatch;
            }
            0x821CF7A8 => {
    //   block [0x821CF7A8..0x821CF7C4)
	// 821CF7A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821CF7AC: 419A0018  beq cr6, 0x821cf7c4
	if ctx.cr[6].eq {
	pc = 0x821CF7C4; continue 'dispatch;
	}
	// 821CF7B0: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CF7B4: 808B00A0  lwz r4, 0xa0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) } as u64;
	// 821CF7B8: 4BFFFDD1  bl 0x821cf588
	ctx.lr = 0x821CF7BC;
	sub_821CF588(ctx, base);
	// 821CF7BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821CF7C0: 48000008  b 0x821cf7c8
	pc = 0x821CF7C8; continue 'dispatch;
            }
            0x821CF7C4 => {
    //   block [0x821CF7C4..0x821CF7C8)
	// 821CF7C4: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	pc = 0x821CF7C8; continue 'dispatch;
            }
            0x821CF7C8 => {
    //   block [0x821CF7C8..0x821CF7E4)
	// 821CF7C8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CF7CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CF7D0: 409A0014  bne cr6, 0x821cf7e4
	if !ctx.cr[6].eq {
	pc = 0x821CF7E4; continue 'dispatch;
	}
	// 821CF7D4: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821CF7D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821CF7DC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821CF7E0: 48A00811  bl 0x82bcfff0
	ctx.lr = 0x821CF7E4;
	sub_82BCFFF0(ctx, base);
	pc = 0x821CF7E4; continue 'dispatch;
            }
            0x821CF7E4 => {
    //   block [0x821CF7E4..0x821CF818)
	// 821CF7E4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CF7E8: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 821CF7EC: 419A002C  beq cr6, 0x821cf818
	if ctx.cr[6].eq {
	pc = 0x821CF818; continue 'dispatch;
	}
	// 821CF7F0: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 821CF7F4: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 821CF7F8: 2F1B0064  cmpwi cr6, r27, 0x64
	ctx.cr[6].compare_i32(ctx.r[27].s32, 100, &mut ctx.xer);
	// 821CF7FC: 4198FF0C  blt cr6, 0x821cf708
	if ctx.cr[6].lt {
	pc = 0x821CF708; continue 'dispatch;
	}
	// 821CF800: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 821CF804: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821CF808: 388B3B88  addi r4, r11, 0x3b88
	ctx.r[4].s64 = ctx.r[11].s64 + 15240;
	// 821CF80C: 48A00A05  bl 0x82bd0210
	ctx.lr = 0x821CF810;
	sub_82BD0210(ctx, base);
	// 821CF810: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821CF814: 48AD9C30  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x821CF818 => {
    //   block [0x821CF818..0x821CF838)
	// 821CF818: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 821CF81C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821CF820: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821CF824: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 821CF828: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821CF82C: 48A02F45  bl 0x82bd2770
	ctx.lr = 0x821CF830;
	sub_82BD2770(ctx, base);
	// 821CF830: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821CF834: 48AD9C10  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CF838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821CF838 size=384
    let mut pc: u32 = 0x821CF838;
    'dispatch: loop {
        match pc {
            0x821CF838 => {
    //   block [0x821CF838..0x821CF86C)
	// 821CF838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CF83C: 48AD9BB5  bl 0x82ca93f0
	ctx.lr = 0x821CF840;
	sub_82CA93D0(ctx, base);
	// 821CF840: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CF844: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821CF848: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 821CF84C: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 821CF850: 490592F9  bl 0x83228b48
	ctx.lr = 0x821CF854;
	sub_83228B48(ctx, base);
	// 821CF854: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821CF858: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821CF85C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CF860: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821CF864: 419A0008  beq cr6, 0x821cf86c
	if ctx.cr[6].eq {
	pc = 0x821CF86C; continue 'dispatch;
	}
	// 821CF868: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821CF86C; continue 'dispatch;
            }
            0x821CF86C => {
    //   block [0x821CF86C..0x821CF884)
	// 821CF86C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CF870: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CF874: 419A0010  beq cr6, 0x821cf884
	if ctx.cr[6].eq {
	pc = 0x821CF884; continue 'dispatch;
	}
	// 821CF878: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821CF87C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821CF880: 48AD9BC0  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x821CF884 => {
    //   block [0x821CF884..0x821CF8B0)
	// 821CF884: 817B0154  lwz r11, 0x154(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(340 as u32) ) } as u64;
	// 821CF888: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 821CF88C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821CF890: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 821CF894: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CF898: 40990110  ble cr6, 0x821cf9a8
	if !ctx.cr[6].gt {
	pc = 0x821CF9A8; continue 'dispatch;
	}
	// 821CF89C: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821CF8A0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821CF8A4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821CF8A8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821CF8AC: 3B4B1A90  addi r26, r11, 0x1a90
	ctx.r[26].s64 = ctx.r[11].s64 + 6800;
	pc = 0x821CF8B0; continue 'dispatch;
            }
            0x821CF8B0 => {
    //   block [0x821CF8B0..0x821CF920)
	// 821CF8B0: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CF8B4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821CF8B8: 7CFE5A14  add r7, r30, r11
	ctx.r[7].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 821CF8BC: 89670018  lbz r11, 0x18(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 821CF8C0: C027000C  lfs f1, 0xc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821CF8C4: 38AB0001  addi r5, r11, 1
	ctx.r[5].s64 = ctx.r[11].s64 + 1;
	// 821CF8C8: 4905F321  bl 0x8322ebe8
	ctx.lr = 0x821CF8CC;
	sub_8322EBE8(ctx, base);
	// 821CF8CC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821CF8D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CF8D4: 409A004C  bne cr6, 0x821cf920
	if !ctx.cr[6].eq {
	pc = 0x821CF920; continue 'dispatch;
	}
	// 821CF8D8: 81760004  lwz r11, 4(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CF8DC: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821CF8E0: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 821CF8E4: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 821CF8E8: 7CCBE214  add r6, r11, r28
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 821CF8EC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821CF8F0: 7CCA492E  stwx r6, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[6].u32) };
	// 821CF8F4: 2F1D0004  cmpwi cr6, r29, 4
	ctx.cr[6].compare_i32(ctx.r[29].s32, 4, &mut ctx.xer);
	// 821CF8F8: 7CEA412E  stwx r7, r10, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32), ctx.r[7].u32) };
	// 821CF8FC: 409A0024  bne cr6, 0x821cf920
	if !ctx.cr[6].eq {
	pc = 0x821CF920; continue 'dispatch;
	}
	// 821CF900: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CF904: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821CF908: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821CF90C: 7CBF5A14  add r5, r31, r11
	ctx.r[5].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 821CF910: 49053CE1  bl 0x832235f0
	ctx.lr = 0x821CF914;
	sub_832235F0(ctx, base);
	// 821CF914: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 821CF918: 3BFF0160  addi r31, r31, 0x160
	ctx.r[31].s64 = ctx.r[31].s64 + 352;
	// 821CF91C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x821CF920; continue 'dispatch;
            }
            0x821CF920 => {
    //   block [0x821CF920..0x821CF94C)
	// 821CF920: 817B0154  lwz r11, 0x154(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(340 as u32) ) } as u64;
	// 821CF924: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 821CF928: 3B9C0030  addi r28, r28, 0x30
	ctx.r[28].s64 = ctx.r[28].s64 + 48;
	// 821CF92C: 3BDE0024  addi r30, r30, 0x24
	ctx.r[30].s64 = ctx.r[30].s64 + 36;
	// 821CF930: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CF934: 4198FF7C  blt cr6, 0x821cf8b0
	if ctx.cr[6].lt {
	pc = 0x821CF8B0; continue 'dispatch;
	}
	// 821CF938: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821CF93C: 4099006C  ble cr6, 0x821cf9a8
	if !ctx.cr[6].gt {
	pc = 0x821CF9A8; continue 'dispatch;
	}
	// 821CF940: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821CF944: 1F980160  mulli r28, r24, 0x160
	ctx.r[28].s32 = ((ctx.r[24].s32 as i64 * 352 as i64) as i32);
	ctx.r[28].s64 = ctx.r[28].s32 as i64;
	// 821CF948: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x821CF94C; continue 'dispatch;
            }
            0x821CF94C => {
    //   block [0x821CF94C..0x821CF98C)
	// 821CF94C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821CF950: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CF954: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 821CF958: 7CDC5A14  add r6, r28, r11
	ctx.r[6].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 821CF95C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821CF960: 7CBF502E  lwzx r5, r31, r10
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821CF964: 7C9F482E  lwzx r4, r31, r9
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821CF968: 49053F89  bl 0x832238f0
	ctx.lr = 0x821CF96C;
	sub_832238F0(ctx, base);
	// 821CF96C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 821CF970: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 821CF974: 7F1EE800  cmpw cr6, r30, r29
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[29].s32, &mut ctx.xer);
	// 821CF978: 4198FFD4  blt cr6, 0x821cf94c
	if ctx.cr[6].lt {
	pc = 0x821CF94C; continue 'dispatch;
	}
	// 821CF97C: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 821CF980: 2F1D0004  cmpwi cr6, r29, 4
	ctx.cr[6].compare_i32(ctx.r[29].s32, 4, &mut ctx.xer);
	// 821CF984: 40980024  bge cr6, 0x821cf9a8
	if !ctx.cr[6].lt {
	pc = 0x821CF9A8; continue 'dispatch;
	}
	// 821CF988: 1FD80160  mulli r30, r24, 0x160
	ctx.r[30].s32 = ((ctx.r[24].s32 as i64 * 352 as i64) as i32);
	ctx.r[30].s64 = ctx.r[30].s32 as i64;
	pc = 0x821CF98C; continue 'dispatch;
            }
            0x821CF98C => {
    //   block [0x821CF98C..0x821CF9A8)
	// 821CF98C: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CF990: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CF994: 7C9E5A14  add r4, r30, r11
	ctx.r[4].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 821CF998: 490533A1  bl 0x83222d38
	ctx.lr = 0x821CF99C;
	sub_83222D38(ctx, base);
	// 821CF99C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821CF9A0: 2F1F0004  cmpwi cr6, r31, 4
	ctx.cr[6].compare_i32(ctx.r[31].s32, 4, &mut ctx.xer);
	// 821CF9A4: 4198FFE8  blt cr6, 0x821cf98c
	if ctx.cr[6].lt {
	pc = 0x821CF98C; continue 'dispatch;
	}
	pc = 0x821CF9A8; continue 'dispatch;
            }
            0x821CF9A8 => {
    //   block [0x821CF9A8..0x821CF9B8)
	// 821CF9A8: 570B103A  slwi r11, r24, 2
	ctx.r[11].u32 = ctx.r[24].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821CF9AC: 7C6BEA14  add r3, r11, r29
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821CF9B0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821CF9B4: 48AD9A8C  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CF9B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821CF9B8 size=452
    let mut pc: u32 = 0x821CF9B8;
    'dispatch: loop {
        match pc {
            0x821CF9B8 => {
    //   block [0x821CF9B8..0x821CF9EC)
	// 821CF9B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CF9BC: 48AD9A39  bl 0x82ca93f4
	ctx.lr = 0x821CF9C0;
	sub_82CA93D0(ctx, base);
	// 821CF9C0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CF9C4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821CF9C8: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 821CF9CC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 821CF9D0: 49059179  bl 0x83228b48
	ctx.lr = 0x821CF9D4;
	sub_83228B48(ctx, base);
	// 821CF9D4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821CF9D8: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821CF9DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CF9E0: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821CF9E4: 419A0008  beq cr6, 0x821cf9ec
	if ctx.cr[6].eq {
	pc = 0x821CF9EC; continue 'dispatch;
	}
	// 821CF9E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821CF9EC; continue 'dispatch;
            }
            0x821CF9EC => {
    //   block [0x821CF9EC..0x821CFA04)
	// 821CF9EC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CF9F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CF9F4: 419A0010  beq cr6, 0x821cfa04
	if ctx.cr[6].eq {
	pc = 0x821CFA04; continue 'dispatch;
	}
	// 821CF9F8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821CF9FC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821CFA00: 48AD9A44  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x821CFA04 => {
    //   block [0x821CFA04..0x821CFA28)
	// 821CFA04: 817B0154  lwz r11, 0x154(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(340 as u32) ) } as u64;
	// 821CFA08: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 821CFA0C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821CFA10: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821CFA14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CFA18: 40990154  ble cr6, 0x821cfb6c
	if !ctx.cr[6].gt {
	pc = 0x821CFB6C; continue 'dispatch;
	}
	// 821CFA1C: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821CFA20: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821CFA24: 3B0B1A80  addi r24, r11, 0x1a80
	ctx.r[24].s64 = ctx.r[11].s64 + 6784;
	pc = 0x821CFA28; continue 'dispatch;
            }
            0x821CFA28 => {
    //   block [0x821CFA28..0x821CFAB8)
	// 821CFA28: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CFA2C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821CFA30: 813C001C  lwz r9, 0x1c(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 821CFA34: 7D1D5A14  add r8, r29, r11
	ctx.r[8].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 821CFA38: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CFA3C: 7D0B4838  and r11, r8, r9
	ctx.r[11].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 821CFA40: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821CFA44: 7CEB4A14  add r7, r11, r9
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821CFA48: 54EB1838  slwi r11, r7, 3
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821CFA4C: 7CEB5214  add r7, r11, r10
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821CFA50: 89670014  lbz r11, 0x14(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 821CFA54: C027000C  lfs f1, 0xc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821CFA58: 38AB0001  addi r5, r11, 1
	ctx.r[5].s64 = ctx.r[11].s64 + 1;
	// 821CFA5C: 4905F18D  bl 0x8322ebe8
	ctx.lr = 0x821CFA60;
	sub_8322EBE8(ctx, base);
	// 821CFA60: 5466063E  clrlwi r6, r3, 0x18
	ctx.r[6].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821CFA64: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821CFA68: 409A0084  bne cr6, 0x821cfaec
	if !ctx.cr[6].eq {
	pc = 0x821CFAEC; continue 'dispatch;
	}
	// 821CFA6C: 81790010  lwz r11, 0x10(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16 as u32) ) } as u64;
	// 821CFA70: 57C9103A  slwi r9, r30, 2
	ctx.r[9].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821CFA74: 8119001C  lwz r8, 0x1c(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) } as u64;
	// 821CFA78: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821CFA7C: 7CABEA14  add r5, r11, r29
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821CFA80: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CFA84: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821CFA88: 7CA34038  and r3, r5, r8
	ctx.r[3].u64 = ctx.r[5].u64 & ctx.r[8].u64;
	// 821CFA8C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 821CFA90: 546B2834  slwi r11, r3, 5
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821CFA94: 2F1E0004  cmpwi cr6, r30, 4
	ctx.cr[6].compare_i32(ctx.r[30].s32, 4, &mut ctx.xer);
	// 821CFA98: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821CFA9C: 7CE9212E  stwx r7, r9, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[4].u32), ctx.r[7].u32) };
	// 821CFAA0: 7D69312E  stwx r11, r9, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[6].u32), ctx.r[11].u32) };
	// 821CFAA4: 409A0048  bne cr6, 0x821cfaec
	if !ctx.cr[6].eq {
	pc = 0x821CFAEC; continue 'dispatch;
	}
	// 821CFAA8: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CFAAC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821CFAB0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821CFAB4: 7CDA5A14  add r6, r26, r11
	ctx.r[6].u64 = ctx.r[26].u64 + ctx.r[11].u64;
	pc = 0x821CFAB8; continue 'dispatch;
            }
            0x821CFAB8 => {
    //   block [0x821CFAB8..0x821CFAEC)
	// 821CFAB8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821CFABC: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 821CFAC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821CFAC4: 7CBF582E  lwzx r5, r31, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821CFAC8: 7C9F502E  lwzx r4, r31, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821CFACC: 49052715  bl 0x832221e0
	ctx.lr = 0x821CFAD0;
	sub_832221E0(ctx, base);
	// 821CFAD0: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 821CFAD4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 821CFAD8: 2F1F0010  cmpwi cr6, r31, 0x10
	ctx.cr[6].compare_i32(ctx.r[31].s32, 16, &mut ctx.xer);
	// 821CFADC: 4198FFDC  blt cr6, 0x821cfab8
	if ctx.cr[6].lt {
	pc = 0x821CFAB8; continue 'dispatch;
	}
	// 821CFAE0: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 821CFAE4: 3B5A00D0  addi r26, r26, 0xd0
	ctx.r[26].s64 = ctx.r[26].s64 + 208;
	// 821CFAE8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x821CFAEC; continue 'dispatch;
            }
            0x821CFAEC => {
    //   block [0x821CFAEC..0x821CFB10)
	// 821CFAEC: 817B0154  lwz r11, 0x154(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(340 as u32) ) } as u64;
	// 821CFAF0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821CFAF4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821CFAF8: 4198FF30  blt cr6, 0x821cfa28
	if ctx.cr[6].lt {
	pc = 0x821CFA28; continue 'dispatch;
	}
	// 821CFAFC: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821CFB00: 4099006C  ble cr6, 0x821cfb6c
	if !ctx.cr[6].gt {
	pc = 0x821CFB6C; continue 'dispatch;
	}
	// 821CFB04: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821CFB08: 1F9700D0  mulli r28, r23, 0xd0
	ctx.r[28].s32 = ((ctx.r[23].s32 as i64 * 208 as i64) as i32);
	ctx.r[28].s64 = ctx.r[28].s32 as i64;
	// 821CFB0C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x821CFB10; continue 'dispatch;
            }
            0x821CFB10 => {
    //   block [0x821CFB10..0x821CFB50)
	// 821CFB10: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821CFB14: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CFB18: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 821CFB1C: 7CDC5A14  add r6, r28, r11
	ctx.r[6].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 821CFB20: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821CFB24: 7CBF502E  lwzx r5, r31, r10
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821CFB28: 7C9F482E  lwzx r4, r31, r9
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821CFB2C: 490526B5  bl 0x832221e0
	ctx.lr = 0x821CFB30;
	sub_832221E0(ctx, base);
	// 821CFB30: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821CFB34: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 821CFB38: 7F1DF000  cmpw cr6, r29, r30
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[30].s32, &mut ctx.xer);
	// 821CFB3C: 4198FFD4  blt cr6, 0x821cfb10
	if ctx.cr[6].lt {
	pc = 0x821CFB10; continue 'dispatch;
	}
	// 821CFB40: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 821CFB44: 2F1E0004  cmpwi cr6, r30, 4
	ctx.cr[6].compare_i32(ctx.r[30].s32, 4, &mut ctx.xer);
	// 821CFB48: 40980024  bge cr6, 0x821cfb6c
	if !ctx.cr[6].lt {
	pc = 0x821CFB6C; continue 'dispatch;
	}
	// 821CFB4C: 1FB700D0  mulli r29, r23, 0xd0
	ctx.r[29].s32 = ((ctx.r[23].s32 as i64 * 208 as i64) as i32);
	ctx.r[29].s64 = ctx.r[29].s32 as i64;
	pc = 0x821CFB50; continue 'dispatch;
            }
            0x821CFB50 => {
    //   block [0x821CFB50..0x821CFB6C)
	// 821CFB50: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CFB54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821CFB58: 7C9D5A14  add r4, r29, r11
	ctx.r[4].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 821CFB5C: 49052205  bl 0x83221d60
	ctx.lr = 0x821CFB60;
	sub_83221D60(ctx, base);
	// 821CFB60: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821CFB64: 2F1F0004  cmpwi cr6, r31, 4
	ctx.cr[6].compare_i32(ctx.r[31].s32, 4, &mut ctx.xer);
	// 821CFB68: 4198FFE8  blt cr6, 0x821cfb50
	if ctx.cr[6].lt {
	pc = 0x821CFB50; continue 'dispatch;
	}
	pc = 0x821CFB6C; continue 'dispatch;
            }
            0x821CFB6C => {
    //   block [0x821CFB6C..0x821CFB7C)
	// 821CFB6C: 56EB103A  slwi r11, r23, 2
	ctx.r[11].u32 = ctx.r[23].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821CFB70: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821CFB74: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821CFB78: 48AD98CC  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CFB80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CFB80 size=244
    let mut pc: u32 = 0x821CFB80;
    'dispatch: loop {
        match pc {
            0x821CFB80 => {
    //   block [0x821CFB80..0x821CFBB8)
	// 821CFB80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CFB84: 48AD987D  bl 0x82ca9400
	ctx.lr = 0x821CFB88;
	sub_82CA93D0(ctx, base);
	// 821CFB88: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CFB8C: F88100E8  std r4, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[4].u64 ) };
	// 821CFB90: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821CFB94: 834100EC  lwz r26, 0xec(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 821CFB98: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 821CFB9C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 821CFBA0: 83DA0004  lwz r30, 4(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CFBA4: 4804F6B5  bl 0x8221f258
	ctx.lr = 0x821CFBA8;
	sub_8221F258(ctx, base);
	// 821CFBA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821CFBAC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821CFBB0: 419A0008  beq cr6, 0x821cfbb8
	if ctx.cr[6].eq {
	pc = 0x821CFBB8; continue 'dispatch;
	}
	// 821CFBB4: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	pc = 0x821CFBB8; continue 'dispatch;
            }
            0x821CFBB8 => {
    //   block [0x821CFBB8..0x821CFBC8)
	// 821CFBB8: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 821CFBBC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821CFBC0: 419A0008  beq cr6, 0x821cfbc8
	if ctx.cr[6].eq {
	pc = 0x821CFBC8; continue 'dispatch;
	}
	// 821CFBC4: 93DD0000  stw r30, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x821CFBC8; continue 'dispatch;
            }
            0x821CFBC8 => {
    //   block [0x821CFBC8..0x821CFBF8)
	// 821CFBC8: 37DF0008  addic. r30, r31, 8
	ctx.xer.ca = (ctx.r[31].u32 > (!(8 as u32)));
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821CFBCC: 4182002C  beq 0x821cfbf8
	if ctx.cr[0].eq {
	pc = 0x821CFBF8; continue 'dispatch;
	}
	// 821CFBD0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821CFBD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821CFBD8: 48020669  bl 0x821f0240
	ctx.lr = 0x821CFBDC;
	sub_821F0240(ctx, base);
	// 821CFBDC: 389B0004  addi r4, r27, 4
	ctx.r[4].s64 = ctx.r[27].s64 + 4;
	// 821CFBE0: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 821CFBE4: 4802065D  bl 0x821f0240
	ctx.lr = 0x821CFBE8;
	sub_821F0240(ctx, base);
	// 821CFBE8: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CFBEC: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821CFBF0: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 821CFBF4: 915E000C  stw r10, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	pc = 0x821CFBF8; continue 'dispatch;
            }
            0x821CFBF8 => {
    //   block [0x821CFBF8..0x821CFC54)
	// 821CFBF8: 3D600FFF  lis r11, 0xfff
	ctx.r[11].s64 = 268369920;
	// 821CFBFC: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CFC00: 6169FFFF  ori r9, r11, 0xffff
	ctx.r[9].u64 = ctx.r[11].u64 | 65535;
	// 821CFC04: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 821CFC08: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 821CFC0C: 40980048  bge cr6, 0x821cfc54
	if !ctx.cr[6].lt {
	pc = 0x821CFC54; continue 'dispatch;
	}
	// 821CFC10: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821CFC14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821CFC18: 388B2D94  addi r4, r11, 0x2d94
	ctx.r[4].s64 = ctx.r[11].s64 + 11668;
	// 821CFC1C: 48122325  bl 0x822f1f40
	ctx.lr = 0x821CFC20;
	sub_822F1F40(ctx, base);
	// 821CFC20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821CFC24: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821CFC28: 48122189  bl 0x822f1db0
	ctx.lr = 0x821CFC2C;
	sub_822F1DB0(ctx, base);
	// 821CFC2C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821CFC30: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821CFC34: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 821CFC38: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 821CFC3C: 481221E5  bl 0x822f1e20
	ctx.lr = 0x821CFC40;
	sub_822F1E20(ctx, base);
	// 821CFC40: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 821CFC44: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821CFC48: 484ABB99  bl 0x8267b7e0
	ctx.lr = 0x821CFC4C;
	sub_8267B7E0(ctx, base);
	// 821CFC4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821CFC50: 4BFA1BC1  bl 0x82171810
	ctx.lr = 0x821CFC54;
	sub_82171810(ctx, base);
	pc = 0x821CFC54; continue 'dispatch;
            }
            0x821CFC54 => {
    //   block [0x821CFC54..0x821CFC74)
	// 821CFC54: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CFC58: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821CFC5C: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821CFC60: 93FA0004  stw r31, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821CFC64: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CFC68: 93EA0000  stw r31, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 821CFC6C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821CFC70: 48AD97E0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CFC78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CFC78 size=396
    let mut pc: u32 = 0x821CFC78;
    'dispatch: loop {
        match pc {
            0x821CFC78 => {
    //   block [0x821CFC78..0x821CFCA4)
	// 821CFC78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CFC7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821CFC80: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CFC84: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821CFC88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CFC8C: 419A0018  beq cr6, 0x821cfca4
	if ctx.cr[6].eq {
	pc = 0x821CFCA4; continue 'dispatch;
	}
	// 821CFC90: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 821CFC94: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821CFC98: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821CFC9C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821CFCA0: 409A0008  bne cr6, 0x821cfca8
	if !ctx.cr[6].eq {
	pc = 0x821CFCA8; continue 'dispatch;
	}
	pc = 0x821CFCA4; continue 'dispatch;
            }
            0x821CFCA4 => {
    //   block [0x821CFCA4..0x821CFCA8)
	// 821CFCA4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821CFCA8; continue 'dispatch;
            }
            0x821CFCA8 => {
    //   block [0x821CFCA8..0x821CFCF4)
	// 821CFCA8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821CFCAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CFCB0: 419A0140  beq cr6, 0x821cfdf0
	if ctx.cr[6].eq {
	pc = 0x821CFDF0; continue 'dispatch;
	}
	// 821CFCB4: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821CFCB8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821CFCBC: 55285FFE  rlwinm r8, r9, 0xb, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x001FFFFFu64;
	// 821CFCC0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821CFCC4: 419A00F8  beq cr6, 0x821cfdbc
	if ctx.cr[6].eq {
	pc = 0x821CFDBC; continue 'dispatch;
	}
	// 821CFCC8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821CFCCC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CFCD0: 419A0024  beq cr6, 0x821cfcf4
	if ctx.cr[6].eq {
	pc = 0x821CFCF4; continue 'dispatch;
	}
	// 821CFCD4: 892A0015  lbz r9, 0x15(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 821CFCD8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CFCDC: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 821CFCE0: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821CFCE4: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CFCE8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821CFCEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CFCF0: 480000D0  b 0x821cfdc0
	pc = 0x821CFDC0; continue 'dispatch;
            }
            0x821CFCF4 => {
    //   block [0x821CFCF4..0x821CFD14)
	// 821CFCF4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CFCF8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821CFCFC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821CFD00: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 821CFD04: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821CFD08: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821CFD0C: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CFD10: 40810054  ble 0x821cfd64
	if !ctx.cr[0].gt {
	pc = 0x821CFD64; continue 'dispatch;
	}
	pc = 0x821CFD14; continue 'dispatch;
            }
            0x821CFD14 => {
    //   block [0x821CFD14..0x821CFD34)
	// 821CFD14: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821CFD18: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821CFD1C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821CFD20: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CFD24: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 821CFD28: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821CFD2C: 41980008  blt cr6, 0x821cfd34
	if ctx.cr[6].lt {
	pc = 0x821CFD34; continue 'dispatch;
	}
	// 821CFD30: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x821CFD34; continue 'dispatch;
            }
            0x821CFD34 => {
    //   block [0x821CFD34..0x821CFD50)
	// 821CFD34: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821CFD38: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821CFD3C: 419A0014  beq cr6, 0x821cfd50
	if ctx.cr[6].eq {
	pc = 0x821CFD50; continue 'dispatch;
	}
	// 821CFD40: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821CFD44: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821CFD48: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821CFD4C: 4800000C  b 0x821cfd58
	pc = 0x821CFD58; continue 'dispatch;
            }
            0x821CFD50 => {
    //   block [0x821CFD50..0x821CFD58)
	// 821CFD50: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821CFD54: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821CFD58; continue 'dispatch;
            }
            0x821CFD58 => {
    //   block [0x821CFD58..0x821CFD64)
	// 821CFD58: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CFD5C: 4199FFB8  bgt cr6, 0x821cfd14
	if ctx.cr[6].gt {
	pc = 0x821CFD14; continue 'dispatch;
	}
	// 821CFD60: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821CFD64; continue 'dispatch;
            }
            0x821CFD64 => {
    //   block [0x821CFD64..0x821CFD80)
	// 821CFD64: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821CFD68: 419A0040  beq cr6, 0x821cfda8
	if ctx.cr[6].eq {
	pc = 0x821CFDA8; continue 'dispatch;
	}
	// 821CFD6C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CFD70: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 821CFD74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CFD78: 41990008  bgt cr6, 0x821cfd80
	if ctx.cr[6].gt {
	pc = 0x821CFD80; continue 'dispatch;
	}
	// 821CFD7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821CFD80; continue 'dispatch;
            }
            0x821CFD80 => {
    //   block [0x821CFD80..0x821CFDA8)
	// 821CFD80: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CFD84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CFD88: 409A0020  bne cr6, 0x821cfda8
	if !ctx.cr[6].eq {
	pc = 0x821CFDA8; continue 'dispatch;
	}
	// 821CFD8C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821CFD90: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821CFD94: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821CFD98: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CFD9C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821CFDA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CFDA4: 4800001C  b 0x821cfdc0
	pc = 0x821CFDC0; continue 'dispatch;
            }
            0x821CFDA8 => {
    //   block [0x821CFDA8..0x821CFDBC)
	// 821CFDA8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821CFDAC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CFDB0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821CFDB4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821CFDB8: 48000008  b 0x821cfdc0
	pc = 0x821CFDC0; continue 'dispatch;
            }
            0x821CFDBC => {
    //   block [0x821CFDBC..0x821CFDC0)
	// 821CFDBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821CFDC0; continue 'dispatch;
            }
            0x821CFDC0 => {
    //   block [0x821CFDC0..0x821CFDF0)
	// 821CFDC0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CFDC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CFDC8: 419A0028  beq cr6, 0x821cfdf0
	if ctx.cr[6].eq {
	pc = 0x821CFDF0; continue 'dispatch;
	}
	// 821CFDCC: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821CFDD0: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 821CFDD4: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 821CFDD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821CFDDC: 4E800421  bctrl
	ctx.lr = 0x821CFDE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821CFDE0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821CFDE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821CFDE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821CFDEC: 4E800020  blr
	return;
            }
            0x821CFDF0 => {
    //   block [0x821CFDF0..0x821CFE04)
	// 821CFDF0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821CFDF4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821CFDF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821CFDFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821CFE00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821CFE08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821CFE08 size=900
    let mut pc: u32 = 0x821CFE08;
    'dispatch: loop {
        match pc {
            0x821CFE08 => {
    //   block [0x821CFE08..0x821CFE64)
	// 821CFE08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821CFE0C: 48AD95F9  bl 0x82ca9404
	ctx.lr = 0x821CFE10;
	sub_82CA93D0(ctx, base);
	// 821CFE10: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821CFE14: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821CFE18: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821CFE1C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821CFE20: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 821CFE24: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 821CFE28: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CFE2C: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821CFE30: 554927FE  rlwinm r9, r10, 4, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0FFFFFFFu64;
	// 821CFE34: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821CFE38: 419A00E8  beq cr6, 0x821cff20
	if ctx.cr[6].eq {
	pc = 0x821CFF20; continue 'dispatch;
	}
	// 821CFE3C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821CFE40: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821CFE44: 419A0020  beq cr6, 0x821cfe64
	if ctx.cr[6].eq {
	pc = 0x821CFE64; continue 'dispatch;
	}
	// 821CFE48: 894A003C  lbz r10, 0x3c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 821CFE4C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CFE50: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821CFE54: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821CFE58: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821CFE5C: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CFE60: 480000C4  b 0x821cff24
	pc = 0x821CFF24; continue 'dispatch;
            }
            0x821CFE64 => {
    //   block [0x821CFE64..0x821CFE80)
	// 821CFE64: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821CFE68: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821CFE6C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821CFE70: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821CFE74: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821CFE78: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CFE7C: 40810054  ble 0x821cfed0
	if !ctx.cr[0].gt {
	pc = 0x821CFED0; continue 'dispatch;
	}
	pc = 0x821CFE80; continue 'dispatch;
            }
            0x821CFE80 => {
    //   block [0x821CFE80..0x821CFEA0)
	// 821CFE80: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821CFE84: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821CFE88: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821CFE8C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CFE90: 2F07003C  cmpwi cr6, r7, 0x3c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 60, &mut ctx.xer);
	// 821CFE94: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 821CFE98: 41980008  blt cr6, 0x821cfea0
	if ctx.cr[6].lt {
	pc = 0x821CFEA0; continue 'dispatch;
	}
	// 821CFE9C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x821CFEA0; continue 'dispatch;
            }
            0x821CFEA0 => {
    //   block [0x821CFEA0..0x821CFEBC)
	// 821CFEA0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821CFEA4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821CFEA8: 419A0014  beq cr6, 0x821cfebc
	if ctx.cr[6].eq {
	pc = 0x821CFEBC; continue 'dispatch;
	}
	// 821CFEAC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821CFEB0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821CFEB4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821CFEB8: 4800000C  b 0x821cfec4
	pc = 0x821CFEC4; continue 'dispatch;
            }
            0x821CFEBC => {
    //   block [0x821CFEBC..0x821CFEC4)
	// 821CFEBC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821CFEC0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821CFEC4; continue 'dispatch;
            }
            0x821CFEC4 => {
    //   block [0x821CFEC4..0x821CFED0)
	// 821CFEC4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821CFEC8: 4199FFB8  bgt cr6, 0x821cfe80
	if ctx.cr[6].gt {
	pc = 0x821CFE80; continue 'dispatch;
	}
	// 821CFECC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821CFED0; continue 'dispatch;
            }
            0x821CFED0 => {
    //   block [0x821CFED0..0x821CFEEC)
	// 821CFED0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821CFED4: 419A003C  beq cr6, 0x821cff10
	if ctx.cr[6].eq {
	pc = 0x821CFF10; continue 'dispatch;
	}
	// 821CFED8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821CFEDC: 2F0B003C  cmpwi cr6, r11, 0x3c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 60, &mut ctx.xer);
	// 821CFEE0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821CFEE4: 41990008  bgt cr6, 0x821cfeec
	if ctx.cr[6].gt {
	pc = 0x821CFEEC; continue 'dispatch;
	}
	// 821CFEE8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821CFEEC; continue 'dispatch;
            }
            0x821CFEEC => {
    //   block [0x821CFEEC..0x821CFF10)
	// 821CFEEC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CFEF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CFEF4: 409A001C  bne cr6, 0x821cff10
	if !ctx.cr[6].eq {
	pc = 0x821CFF10; continue 'dispatch;
	}
	// 821CFEF8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821CFEFC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821CFF00: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821CFF04: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CFF08: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821CFF0C: 48000018  b 0x821cff24
	pc = 0x821CFF24; continue 'dispatch;
            }
            0x821CFF10 => {
    //   block [0x821CFF10..0x821CFF20)
	// 821CFF10: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821CFF14: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821CFF18: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821CFF1C: 48000008  b 0x821cff24
	pc = 0x821CFF24; continue 'dispatch;
            }
            0x821CFF20 => {
    //   block [0x821CFF20..0x821CFF24)
	// 821CFF20: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821CFF24; continue 'dispatch;
            }
            0x821CFF24 => {
    //   block [0x821CFF24..0x821CFF60)
	// 821CFF24: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CFF28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CFF2C: 419A0254  beq cr6, 0x821d0180
	if ctx.cr[6].eq {
	pc = 0x821D0180; continue 'dispatch;
	}
	// 821CFF30: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 821CFF34: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821CFF38: 419A0028  beq cr6, 0x821cff60
	if ctx.cr[6].eq {
	pc = 0x821CFF60; continue 'dispatch;
	}
	// 821CFF3C: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 821CFF40: 419A0020  beq cr6, 0x821cff60
	if ctx.cr[6].eq {
	pc = 0x821CFF60; continue 'dispatch;
	}
	// 821CFF44: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821CFF48: 419A0018  beq cr6, 0x821cff60
	if ctx.cr[6].eq {
	pc = 0x821CFF60; continue 'dispatch;
	}
	// 821CFF4C: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 821CFF50: 419A0010  beq cr6, 0x821cff60
	if ctx.cr[6].eq {
	pc = 0x821CFF60; continue 'dispatch;
	}
	// 821CFF54: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821CFF58: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821CFF5C: 409A0008  bne cr6, 0x821cff64
	if !ctx.cr[6].eq {
	pc = 0x821CFF64; continue 'dispatch;
	}
	pc = 0x821CFF60; continue 'dispatch;
            }
            0x821CFF60 => {
    //   block [0x821CFF60..0x821CFF64)
	// 821CFF60: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821CFF64; continue 'dispatch;
            }
            0x821CFF64 => {
    //   block [0x821CFF64..0x821D0180)
	// 821CFF64: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821CFF68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821CFF6C: 419A0214  beq cr6, 0x821d0180
	if ctx.cr[6].eq {
	pc = 0x821D0180; continue 'dispatch;
	}
	// 821CFF70: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 821CFF74: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 821CFF78: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821CFF7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821CFF80: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821CFF84: 4809B045  bl 0x8226afc8
	ctx.lr = 0x821CFF88;
	sub_8226AFC8(ctx, base);
	// 821CFF88: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	pc = 0x821D0180; continue 'dispatch;
            }
            0x821D0180 => {
    //   block [0x821D0180..0x821D018C)
	// 821D0180: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821D0184: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821D0188: 48AD92CC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D0190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D0190 size=804
    let mut pc: u32 = 0x821D0190;
    'dispatch: loop {
        match pc {
            0x821D0190 => {
    //   block [0x821D0190..0x821D01E8)
	// 821D0190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D0194: 48AD9279  bl 0x82ca940c
	ctx.lr = 0x821D0198;
	sub_82CA93D0(ctx, base);
	// 821D0198: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D019C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821D01A0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821D01A4: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 821D01A8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D01AC: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821D01B0: 55499FFE  rlwinm r9, r10, 0x13, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00001FFFu64;
	// 821D01B4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821D01B8: 419A00F4  beq cr6, 0x821d02ac
	if ctx.cr[6].eq {
	pc = 0x821D02AC; continue 'dispatch;
	}
	// 821D01BC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D01C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D01C4: 419A0024  beq cr6, 0x821d01e8
	if ctx.cr[6].eq {
	pc = 0x821D01E8; continue 'dispatch;
	}
	// 821D01C8: 894A006D  lbz r10, 0x6d(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(109 as u32) ) } as u64;
	// 821D01CC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D01D0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821D01D4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D01D8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D01DC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821D01E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D01E4: 480000CC  b 0x821d02b0
	pc = 0x821D02B0; continue 'dispatch;
            }
            0x821D01E8 => {
    //   block [0x821D01E8..0x821D0204)
	// 821D01E8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D01EC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D01F0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821D01F4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821D01F8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D01FC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D0200: 40810054  ble 0x821d0254
	if !ctx.cr[0].gt {
	pc = 0x821D0254; continue 'dispatch;
	}
	pc = 0x821D0204; continue 'dispatch;
            }
            0x821D0204 => {
    //   block [0x821D0204..0x821D0224)
	// 821D0204: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821D0208: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D020C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821D0210: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D0214: 2F07006D  cmpwi cr6, r7, 0x6d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 109, &mut ctx.xer);
	// 821D0218: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D021C: 41980008  blt cr6, 0x821d0224
	if ctx.cr[6].lt {
	pc = 0x821D0224; continue 'dispatch;
	}
	// 821D0220: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x821D0224; continue 'dispatch;
            }
            0x821D0224 => {
    //   block [0x821D0224..0x821D0240)
	// 821D0224: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821D0228: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D022C: 419A0014  beq cr6, 0x821d0240
	if ctx.cr[6].eq {
	pc = 0x821D0240; continue 'dispatch;
	}
	// 821D0230: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821D0234: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D0238: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D023C: 4800000C  b 0x821d0248
	pc = 0x821D0248; continue 'dispatch;
            }
            0x821D0240 => {
    //   block [0x821D0240..0x821D0248)
	// 821D0240: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821D0244: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821D0248; continue 'dispatch;
            }
            0x821D0248 => {
    //   block [0x821D0248..0x821D0254)
	// 821D0248: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D024C: 4199FFB8  bgt cr6, 0x821d0204
	if ctx.cr[6].gt {
	pc = 0x821D0204; continue 'dispatch;
	}
	// 821D0250: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821D0254; continue 'dispatch;
            }
            0x821D0254 => {
    //   block [0x821D0254..0x821D0270)
	// 821D0254: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821D0258: 419A0040  beq cr6, 0x821d0298
	if ctx.cr[6].eq {
	pc = 0x821D0298; continue 'dispatch;
	}
	// 821D025C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D0260: 2F0B006D  cmpwi cr6, r11, 0x6d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 109, &mut ctx.xer);
	// 821D0264: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D0268: 41990008  bgt cr6, 0x821d0270
	if ctx.cr[6].gt {
	pc = 0x821D0270; continue 'dispatch;
	}
	// 821D026C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821D0270; continue 'dispatch;
            }
            0x821D0270 => {
    //   block [0x821D0270..0x821D0298)
	// 821D0270: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D0274: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D0278: 409A0020  bne cr6, 0x821d0298
	if !ctx.cr[6].eq {
	pc = 0x821D0298; continue 'dispatch;
	}
	// 821D027C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D0280: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821D0284: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D0288: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D028C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821D0290: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D0294: 4800001C  b 0x821d02b0
	pc = 0x821D02B0; continue 'dispatch;
            }
            0x821D0298 => {
    //   block [0x821D0298..0x821D02AC)
	// 821D0298: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821D029C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D02A0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821D02A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D02A8: 48000008  b 0x821d02b0
	pc = 0x821D02B0; continue 'dispatch;
            }
            0x821D02AC => {
    //   block [0x821D02AC..0x821D02B0)
	// 821D02AC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821D02B0; continue 'dispatch;
            }
            0x821D02B0 => {
    //   block [0x821D02B0..0x821D0334)
	// 821D02B0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D02B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D02B8: 419A01DC  beq cr6, 0x821d0494
	if ctx.cr[6].eq {
	pc = 0x821D0494; continue 'dispatch;
	}
	// 821D02BC: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D02C0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D02C4: 409A016C  bne cr6, 0x821d0430
	if !ctx.cr[6].eq {
	pc = 0x821D0430; continue 'dispatch;
	}
	// 821D02C8: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 821D02CC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821D02D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D02D4: 4BFFFB35  bl 0x821cfe08
	ctx.lr = 0x821D02D8;
	sub_821CFE08(ctx, base);
	// 821D02D8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D02DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D02E0: 419A0150  beq cr6, 0x821d0430
	if ctx.cr[6].eq {
	pc = 0x821D0430; continue 'dispatch;
	}
	// 821D02E4: 89410074  lbz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821D02E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D02EC: 419A0144  beq cr6, 0x821d0430
	if ctx.cr[6].eq {
	pc = 0x821D0430; continue 'dispatch;
	}
	// 821D02F0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D02F4: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 821D02F8: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D02FC: 552827FE  rlwinm r8, r9, 4, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0FFFFFFFu64;
	// 821D0300: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821D0304: 419A00F4  beq cr6, 0x821d03f8
	if ctx.cr[6].eq {
	pc = 0x821D03F8; continue 'dispatch;
	}
	// 821D0308: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D030C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D0310: 419A0024  beq cr6, 0x821d0334
	if ctx.cr[6].eq {
	pc = 0x821D0334; continue 'dispatch;
	}
	// 821D0314: 894A003C  lbz r10, 0x3c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 821D0318: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D031C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821D0320: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D0324: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D0328: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821D032C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D0330: 480000CC  b 0x821d03fc
	pc = 0x821D03FC; continue 'dispatch;
            }
            0x821D0334 => {
    //   block [0x821D0334..0x821D0350)
	// 821D0334: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D0338: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D033C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821D0340: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821D0344: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D0348: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D034C: 40810054  ble 0x821d03a0
	if !ctx.cr[0].gt {
	pc = 0x821D03A0; continue 'dispatch;
	}
	pc = 0x821D0350; continue 'dispatch;
            }
            0x821D0350 => {
    //   block [0x821D0350..0x821D0370)
	// 821D0350: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821D0354: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D0358: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821D035C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D0360: 2F07003C  cmpwi cr6, r7, 0x3c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 60, &mut ctx.xer);
	// 821D0364: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D0368: 41980008  blt cr6, 0x821d0370
	if ctx.cr[6].lt {
	pc = 0x821D0370; continue 'dispatch;
	}
	// 821D036C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x821D0370; continue 'dispatch;
            }
            0x821D0370 => {
    //   block [0x821D0370..0x821D038C)
	// 821D0370: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821D0374: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D0378: 419A0014  beq cr6, 0x821d038c
	if ctx.cr[6].eq {
	pc = 0x821D038C; continue 'dispatch;
	}
	// 821D037C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821D0380: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D0384: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D0388: 4800000C  b 0x821d0394
	pc = 0x821D0394; continue 'dispatch;
            }
            0x821D038C => {
    //   block [0x821D038C..0x821D0394)
	// 821D038C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821D0390: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821D0394; continue 'dispatch;
            }
            0x821D0394 => {
    //   block [0x821D0394..0x821D03A0)
	// 821D0394: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D0398: 4199FFB8  bgt cr6, 0x821d0350
	if ctx.cr[6].gt {
	pc = 0x821D0350; continue 'dispatch;
	}
	// 821D039C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821D03A0; continue 'dispatch;
            }
            0x821D03A0 => {
    //   block [0x821D03A0..0x821D03BC)
	// 821D03A0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821D03A4: 419A0040  beq cr6, 0x821d03e4
	if ctx.cr[6].eq {
	pc = 0x821D03E4; continue 'dispatch;
	}
	// 821D03A8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D03AC: 2F0B003C  cmpwi cr6, r11, 0x3c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 60, &mut ctx.xer);
	// 821D03B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D03B4: 41990008  bgt cr6, 0x821d03bc
	if ctx.cr[6].gt {
	pc = 0x821D03BC; continue 'dispatch;
	}
	// 821D03B8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821D03BC; continue 'dispatch;
            }
            0x821D03BC => {
    //   block [0x821D03BC..0x821D03E4)
	// 821D03BC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D03C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D03C4: 409A0020  bne cr6, 0x821d03e4
	if !ctx.cr[6].eq {
	pc = 0x821D03E4; continue 'dispatch;
	}
	// 821D03C8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D03CC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821D03D0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D03D4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D03D8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821D03DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D03E0: 4800001C  b 0x821d03fc
	pc = 0x821D03FC; continue 'dispatch;
            }
            0x821D03E4 => {
    //   block [0x821D03E4..0x821D03F8)
	// 821D03E4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821D03E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D03EC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821D03F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D03F4: 48000008  b 0x821d03fc
	pc = 0x821D03FC; continue 'dispatch;
            }
            0x821D03F8 => {
    //   block [0x821D03F8..0x821D03FC)
	// 821D03F8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821D03FC; continue 'dispatch;
            }
            0x821D03FC => {
    //   block [0x821D03FC..0x821D0430)
	// 821D03FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D0400: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D0404: 419A002C  beq cr6, 0x821d0430
	if ctx.cr[6].eq {
	pc = 0x821D0430; continue 'dispatch;
	}
	// 821D0408: 896A00BA  lbz r11, 0xba(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(186 as u32) ) } as u64;
	// 821D040C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D0410: 409A0020  bne cr6, 0x821d0430
	if !ctx.cr[6].eq {
	pc = 0x821D0430; continue 'dispatch;
	}
	// 821D0414: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 821D0418: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821D041C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 821D0420: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x821D0430; continue 'dispatch;
            }
            0x821D0430 => {
    //   block [0x821D0430..0x821D0494)
	// 821D0430: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D0434: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D0438: 419A005C  beq cr6, 0x821d0494
	if ctx.cr[6].eq {
	pc = 0x821D0494; continue 'dispatch;
	}
	// 821D043C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D0440: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D0444: 4BFDE9F5  bl 0x821aee38
	ctx.lr = 0x821D0448;
	sub_821AEE38(ctx, base);
	// 821D0448: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821D044C: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D0450: 480170B9  bl 0x821e7508
	ctx.lr = 0x821D0454;
	sub_821E7508(ctx, base);
	// 821D0454: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	pc = 0x821D0494; continue 'dispatch;
            }
            0x821D0494 => {
    //   block [0x821D0494..0x821D04B4)
	// 821D0494: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821D0498: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821D049C: 48AD8FC0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 821D04A0: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 821D04A4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821D04A8: 917D033C  stw r11, 0x33c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(828 as u32), ctx.r[11].u32 ) };
	// 821D04AC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821D04B0: 48AD8FAC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D04B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D04B8 size=1500
    let mut pc: u32 = 0x821D04B8;
    'dispatch: loop {
        match pc {
            0x821D04B8 => {
    //   block [0x821D04B8..0x821D0A94)
	// 821D04B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D04BC: 48AD8F49  bl 0x82ca9404
	ctx.lr = 0x821D04C0;
	sub_82CA93D0(ctx, base);
	// 821D04C0: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 821D04C4: 48ADD811  bl 0x82cadcd4
	ctx.lr = 0x821D04C8;
	sub_82CADCA0(ctx, base);
	// 821D04C8: 3980FF70  li r12, -0x90
	ctx.r[12].s64 = -144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D0A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D0A98 size=196
    let mut pc: u32 = 0x821D0A98;
    'dispatch: loop {
        match pc {
            0x821D0A98 => {
    //   block [0x821D0A98..0x821D0B30)
	// 821D0A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D0A9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D0AA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D0AA4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D0AA8: 8164002C  lwz r11, 0x2c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 821D0AAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D0AB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D0AB4: 419A007C  beq cr6, 0x821d0b30
	if ctx.cr[6].eq {
	pc = 0x821D0B30; continue 'dispatch;
	}
	// 821D0AB8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D0ABC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D0AC0: 419A0070  beq cr6, 0x821d0b30
	if ctx.cr[6].eq {
	pc = 0x821D0B30; continue 'dispatch;
	}
	// 821D0AC4: 8064002C  lwz r3, 0x2c(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 821D0AC8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821D0ACC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D0AD0: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D0AD4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D0AD8: 4E800421  bctrl
	ctx.lr = 0x821D0ADC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D0ADC: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 821D0AE0: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 821D0AE4: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 821D0AE8: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 821D0AEC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
            }
            0x821D0B30 => {
    //   block [0x821D0B30..0x821D0B5C)
	// 821D0B30: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821D0B34: 1020038C  vspltisw v1, 0
	for i in 0..4 {
		ctx.v[1].u32[i] = 0;
	}
	// 821D0B38: C02BB730  lfs f1, -0x48d0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18640 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821D0B3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D0B40: 4801A6B1  bl 0x821eb1f0
	ctx.lr = 0x821D0B44;
	sub_821EB1F0(ctx, base);
	// 821D0B44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D0B48: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821D0B4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D0B50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D0B54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D0B58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D0B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D0B60 size=64
    let mut pc: u32 = 0x821D0B60;
    'dispatch: loop {
        match pc {
            0x821D0B60 => {
    //   block [0x821D0B60..0x821D0BA0)
	// 821D0B60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D0B64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D0B68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D0B6C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D0B70: 80840038  lwz r4, 0x38(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(56 as u32) ) } as u64;
	// 821D0B74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D0B78: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D0B7C: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D0B80: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D0B84: 4E800421  bctrl
	ctx.lr = 0x821D0B88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D0B88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D0B8C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821D0B90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D0B94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D0B98: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D0B9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D0BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D0BA0 size=92
    let mut pc: u32 = 0x821D0BA0;
    'dispatch: loop {
        match pc {
            0x821D0BA0 => {
    //   block [0x821D0BA0..0x821D0BFC)
	// 821D0BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D0BA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D0BA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D0BAC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D0BB0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821D0BB4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821D0BB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D0BBC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D0BC0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 821D0BC4: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 821D0BC8: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D0BCC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821D0BD0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821D0BD4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821D0BD8: 48000029  bl 0x821d0c00
	ctx.lr = 0x821D0BDC;
	sub_821D0C00(ctx, base);
	// 821D0BDC: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D0BE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D0BE4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821D0BE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D0BEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D0BF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D0BF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D0BF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D0C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D0C00 size=596
    let mut pc: u32 = 0x821D0C00;
    'dispatch: loop {
        match pc {
            0x821D0C00 => {
    //   block [0x821D0C00..0x821D0CC4)
	// 821D0C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D0C04: 48AD87F9  bl 0x82ca93fc
	ctx.lr = 0x821D0C08;
	sub_82CA93D0(ctx, base);
	// 821D0C08: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D0C0C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 821D0C10: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821D0C14: 397A00C2  addi r11, r26, 0xc2
	ctx.r[11].s64 = ctx.r[26].s64 + 194;
	// 821D0C18: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 821D0C1C: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D0C20: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821D0C24: 7FEBDA14  add r31, r11, r27
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 821D0C28: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D0C2C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D0C30: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821D0C34: 7D071E70  srawi r7, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 821D0C38: 7F07E040  cmplw cr6, r7, r28
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821D0C3C: 40990164  ble cr6, 0x821d0da0
	if !ctx.cr[6].gt {
	pc = 0x821D0DA0; continue 'dispatch;
	}
	// 821D0C40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D0C44: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821D0C48: 488A32C9  bl 0x82a73f10
	ctx.lr = 0x821D0C4C;
	sub_82A73F10(ctx, base);
	// 821D0C4C: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 821D0C50: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821D0C54: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D0C58: 579E1838  slwi r30, r28, 3
	ctx.r[30].u32 = ctx.r[28].u32.wrapping_shl(3);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821D0C5C: 90A10068  stw r5, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[5].u32 ) };
	// 821D0C60: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821D0C64: 90A10058  stw r5, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u32 ) };
	// 821D0C68: 90A10060  stw r5, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u32 ) };
	// 821D0C6C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821D0C70: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821D0C74: 83210074  lwz r25, 0x74(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821D0C78: 7D7ECA14  add r11, r30, r25
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[25].u64;
	// 821D0C7C: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 821D0C80: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 821D0C84: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821D0C88: 9321006C  stw r25, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[25].u32 ) };
	// 821D0C8C: E9010068  ld r8, 0x68(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821D0C90: F9010068  std r8, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[8].u64 ) };
	// 821D0C94: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 821D0C98: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821D0C9C: F8810068  std r4, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[4].u64 ) };
	// 821D0CA0: 9121006C  stw r9, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 821D0CA4: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821D0CA8: 488ECD69  bl 0x82abda10
	ctx.lr = 0x821D0CAC;
	sub_82ABDA10(ctx, base);
	// 821D0CAC: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 821D0CB0: 40990034  ble cr6, 0x821d0ce4
	if !ctx.cr[6].gt {
	pc = 0x821D0CE4; continue 'dispatch;
	}
	// 821D0CB4: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 821D0CB8: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 821D0CBC: 7D1DC850  subf r8, r29, r25
	ctx.r[8].s64 = ctx.r[25].s64 - ctx.r[29].s64;
	// 821D0CC0: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	pc = 0x821D0CC4; continue 'dispatch;
            }
            0x821D0CC4 => {
    //   block [0x821D0CC4..0x821D0CE4)
	// 821D0CC4: C0090000  lfs f0, 0(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D0CC8: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821D0CCC: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 821D0CD0: 7CE8582E  lwzx r7, r8, r11
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821D0CD4: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821D0CD8: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 821D0CDC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821D0CE0: 4082FFE4  bne 0x821d0cc4
	if !ctx.cr[0].eq {
	pc = 0x821D0CC4; continue 'dispatch;
	}
	pc = 0x821D0CE4; continue 'dispatch;
            }
            0x821D0CE4 => {
    //   block [0x821D0CE4..0x821D0D24)
	// 821D0CE4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D0CE8: 395C0001  addi r10, r28, 1
	ctx.r[10].s64 = ctx.r[28].s64 + 1;
	// 821D0CEC: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D0CF0: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821D0CF4: 7D071E70  srawi r7, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 821D0CF8: 7F075040  cmplw cr6, r7, r10
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D0CFC: 40990028  ble cr6, 0x821d0d24
	if !ctx.cr[6].gt {
	pc = 0x821D0D24; continue 'dispatch;
	}
	// 821D0D00: 574A2036  slwi r10, r26, 4
	ctx.r[10].u32 = ctx.r[26].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D0D04: 7D7EEA14  add r11, r30, r29
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	// 821D0D08: 7D2ADA14  add r9, r10, r27
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 821D0D0C: 394BFFF8  addi r10, r11, -8
	ctx.r[10].s64 = ctx.r[11].s64 + -8;
	// 821D0D10: C00BFFF8  lfs f0, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D0D14: 81090C24  lwz r8, 0xc24(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3108 as u32) ) } as u64;
	// 821D0D18: 7DA8F42E  lfsx f13, r8, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821D0D1C: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821D0D20: D18BFFF8  stfs f12, -8(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	pc = 0x821D0D24; continue 'dispatch;
            }
            0x821D0D24 => {
    //   block [0x821D0D24..0x821D0D40)
	// 821D0D24: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821D0D28: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 821D0D2C: 392B9490  addi r9, r11, -0x6b70
	ctx.r[9].s64 = ctx.r[11].s64 + -27504;
	// 821D0D30: C009FFF4  lfs f0, -0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D0D34: 40990020  ble cr6, 0x821d0d54
	if !ctx.cr[6].gt {
	pc = 0x821D0D54; continue 'dispatch;
	}
	// 821D0D38: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 821D0D3C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821D0D40; continue 'dispatch;
            }
            0x821D0D40 => {
    //   block [0x821D0D40..0x821D0D54)
	// 821D0D40: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821D0D44: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D0D48: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 821D0D4C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D0D50: 4082FFF0  bne 0x821d0d40
	if !ctx.cr[0].eq {
	pc = 0x821D0D40; continue 'dispatch;
	}
	pc = 0x821D0D54; continue 'dispatch;
            }
            0x821D0D54 => {
    //   block [0x821D0D54..0x821D0D6C)
	// 821D0D54: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821D0D58: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 821D0D5C: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 821D0D60: 40990024  ble cr6, 0x821d0d84
	if !ctx.cr[6].gt {
	pc = 0x821D0D84; continue 'dispatch;
	}
	// 821D0D64: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821D0D68: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	pc = 0x821D0D6C; continue 'dispatch;
            }
            0x821D0D6C => {
    //   block [0x821D0D6C..0x821D0D84)
	// 821D0D6C: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821D0D70: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821D0D74: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821D0D78: D18B0000  stfs f12, 0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821D0D7C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821D0D80: 4082FFEC  bne 0x821d0d6c
	if !ctx.cr[0].eq {
	pc = 0x821D0D6C; continue 'dispatch;
	}
	pc = 0x821D0D84; continue 'dispatch;
            }
            0x821D0D84 => {
    //   block [0x821D0D84..0x821D0D94)
	// 821D0D84: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 821D0D88: 419A000C  beq cr6, 0x821d0d94
	if ctx.cr[6].eq {
	pc = 0x821D0D94; continue 'dispatch;
	}
	// 821D0D8C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 821D0D90: 4804AFA9  bl 0x8221bd38
	ctx.lr = 0x821D0D94;
	sub_8221BD38(ctx, base);
	pc = 0x821D0D94; continue 'dispatch;
            }
            0x821D0D94 => {
    //   block [0x821D0D94..0x821D0DA0)
	// 821D0D94: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821D0D98: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821D0D9C: 48AD86B0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821D0DA0 => {
    //   block [0x821D0DA0..0x821D0DCC)
	// 821D0DA0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D0DA4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821D0DA8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D0DAC: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 821D0DB0: 7D0A5850  subf r8, r10, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821D0DB4: 7D071E71  srawi. r7, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821D0DB8: 41820050  beq 0x821d0e08
	if ctx.cr[0].eq {
	pc = 0x821D0E08; continue 'dispatch;
	}
	// 821D0DBC: 574B2036  slwi r11, r26, 4
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D0DC0: 7CAA2B78  mr r10, r5
	ctx.r[10].u64 = ctx.r[5].u64;
	// 821D0DC4: 7CEBDA14  add r7, r11, r27
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 821D0DC8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x821D0DCC; continue 'dispatch;
            }
            0x821D0DCC => {
    //   block [0x821D0DCC..0x821D0E08)
	// 821D0DCC: 81070C24  lwz r8, 0xc24(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(3108 as u32) ) } as u64;
	// 821D0DD0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821D0DD4: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821D0DD8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D0DDC: C0080000  lfs f0, 0(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D0DE0: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821D0DE4: 81080004  lwz r8, 4(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D0DE8: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821D0DEC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821D0DF0: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D0DF4: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D0DF8: 7C643050  subf r3, r4, r6
	ctx.r[3].s64 = ctx.r[6].s64 - ctx.r[4].s64;
	// 821D0DFC: 7C681E70  srawi r8, r3, 3
	ctx.xer.ca = (ctx.r[3].s32 < 0) && ((ctx.r[3].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[3].s32 >> 3) as i64;
	// 821D0E00: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821D0E04: 4198FFC8  blt cr6, 0x821d0dcc
	if ctx.cr[6].lt {
	pc = 0x821D0DCC; continue 'dispatch;
	}
	pc = 0x821D0E08; continue 'dispatch;
            }
            0x821D0E08 => {
    //   block [0x821D0E08..0x821D0E28)
	// 821D0E08: 7F09E000  cmpw cr6, r9, r28
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[28].s32, &mut ctx.xer);
	// 821D0E0C: 40980030  bge cr6, 0x821d0e3c
	if !ctx.cr[6].lt {
	pc = 0x821D0E3C; continue 'dispatch;
	}
	// 821D0E10: 552B1838  slwi r11, r9, 3
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D0E14: 7D49E050  subf r10, r9, r28
	ctx.r[10].s64 = ctx.r[28].s64 - ctx.r[9].s64;
	// 821D0E18: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821D0E1C: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821D0E20: 39099490  addi r8, r9, -0x6b70
	ctx.r[8].s64 = ctx.r[9].s64 + -27504;
	// 821D0E24: C008FFF4  lfs f0, -0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x821D0E28; continue 'dispatch;
            }
            0x821D0E28 => {
    //   block [0x821D0E28..0x821D0E3C)
	// 821D0E28: 90AB0004  stw r5, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 821D0E2C: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821D0E30: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821D0E34: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821D0E38: 4082FFF0  bne 0x821d0e28
	if !ctx.cr[0].eq {
	pc = 0x821D0E28; continue 'dispatch;
	}
	pc = 0x821D0E3C; continue 'dispatch;
            }
            0x821D0E3C => {
    //   block [0x821D0E3C..0x821D0E54)
	// 821D0E3C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D0E40: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D0E44: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821D0E48: 7D231E70  srawi r3, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 821D0E4C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821D0E50: 48AD85FC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D0E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D0E58 size=1708
    let mut pc: u32 = 0x821D0E58;
    'dispatch: loop {
        match pc {
            0x821D0E58 => {
    //   block [0x821D0E58..0x821D0EB8)
	// 821D0E58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D0E5C: 48AD859D  bl 0x82ca93f8
	ctx.lr = 0x821D0E60;
	sub_82CA93D0(ctx, base);
	// 821D0E60: DBC1FFA8  stfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 821D0E64: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 821D0E68: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D0E6C: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 821D0E70: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821D0E74: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 821D0E78: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 821D0E7C: 4809B885  bl 0x8226c700
	ctx.lr = 0x821D0E80;
	sub_8226C700(ctx, base);
	// 821D0E80: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 821D0E84: 556A2FFE  rlwinm r10, r11, 5, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x07FFFFFFu64;
	// 821D0E88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D0E8C: 419A00E8  beq cr6, 0x821d0f74
	if ctx.cr[6].eq {
	pc = 0x821D0F74; continue 'dispatch;
	}
	// 821D0E90: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D0E94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D0E98: 419A0020  beq cr6, 0x821d0eb8
	if ctx.cr[6].eq {
	pc = 0x821D0EB8; continue 'dispatch;
	}
	// 821D0E9C: 894B005B  lbz r10, 0x5b(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(91 as u32) ) } as u64;
	// 821D0EA0: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D0EA4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821D0EA8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D0EAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D0EB0: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D0EB4: 480000C4  b 0x821d0f78
	pc = 0x821D0F78; continue 'dispatch;
            }
            0x821D0EB8 => {
    //   block [0x821D0EB8..0x821D0ED4)
	// 821D0EB8: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D0EBC: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D0EC0: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 821D0EC4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821D0EC8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D0ECC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D0ED0: 40810054  ble 0x821d0f24
	if !ctx.cr[0].gt {
	pc = 0x821D0F24; continue 'dispatch;
	}
	pc = 0x821D0ED4; continue 'dispatch;
            }
            0x821D0ED4 => {
    //   block [0x821D0ED4..0x821D0EF4)
	// 821D0ED4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821D0ED8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D0EDC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821D0EE0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D0EE4: 2F07005B  cmpwi cr6, r7, 0x5b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 91, &mut ctx.xer);
	// 821D0EE8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D0EEC: 41980008  blt cr6, 0x821d0ef4
	if ctx.cr[6].lt {
	pc = 0x821D0EF4; continue 'dispatch;
	}
	// 821D0EF0: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x821D0EF4; continue 'dispatch;
            }
            0x821D0EF4 => {
    //   block [0x821D0EF4..0x821D0F10)
	// 821D0EF4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821D0EF8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D0EFC: 419A0014  beq cr6, 0x821d0f10
	if ctx.cr[6].eq {
	pc = 0x821D0F10; continue 'dispatch;
	}
	// 821D0F00: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821D0F04: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D0F08: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D0F0C: 4800000C  b 0x821d0f18
	pc = 0x821D0F18; continue 'dispatch;
            }
            0x821D0F10 => {
    //   block [0x821D0F10..0x821D0F18)
	// 821D0F10: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821D0F14: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821D0F18; continue 'dispatch;
            }
            0x821D0F18 => {
    //   block [0x821D0F18..0x821D0F24)
	// 821D0F18: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D0F1C: 4199FFB8  bgt cr6, 0x821d0ed4
	if ctx.cr[6].gt {
	pc = 0x821D0ED4; continue 'dispatch;
	}
	// 821D0F20: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821D0F24; continue 'dispatch;
            }
            0x821D0F24 => {
    //   block [0x821D0F24..0x821D0F40)
	// 821D0F24: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821D0F28: 419A003C  beq cr6, 0x821d0f64
	if ctx.cr[6].eq {
	pc = 0x821D0F64; continue 'dispatch;
	}
	// 821D0F2C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D0F30: 2F0B005B  cmpwi cr6, r11, 0x5b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 91, &mut ctx.xer);
	// 821D0F34: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D0F38: 41990008  bgt cr6, 0x821d0f40
	if ctx.cr[6].gt {
	pc = 0x821D0F40; continue 'dispatch;
	}
	// 821D0F3C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x821D0F40; continue 'dispatch;
            }
            0x821D0F40 => {
    //   block [0x821D0F40..0x821D0F64)
	// 821D0F40: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D0F44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D0F48: 409A001C  bne cr6, 0x821d0f64
	if !ctx.cr[6].eq {
	pc = 0x821D0F64; continue 'dispatch;
	}
	// 821D0F4C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D0F50: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821D0F54: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D0F58: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D0F5C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D0F60: 48000018  b 0x821d0f78
	pc = 0x821D0F78; continue 'dispatch;
            }
            0x821D0F64 => {
    //   block [0x821D0F64..0x821D0F74)
	// 821D0F64: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821D0F68: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D0F6C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D0F70: 48000008  b 0x821d0f78
	pc = 0x821D0F78; continue 'dispatch;
            }
            0x821D0F74 => {
    //   block [0x821D0F74..0x821D0F78)
	// 821D0F74: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x821D0F78; continue 'dispatch;
            }
            0x821D0F78 => {
    //   block [0x821D0F78..0x821D0F90)
	// 821D0F78: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D0F7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D0F80: 419A0010  beq cr6, 0x821d0f90
	if ctx.cr[6].eq {
	pc = 0x821D0F90; continue 'dispatch;
	}
	// 821D0F84: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821D0F88: 8B5F006C  lbz r26, 0x6c(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 821D0F8C: 995F006C  stb r10, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[10].u8 ) };
	pc = 0x821D0F90; continue 'dispatch;
            }
            0x821D0F90 => {
    //   block [0x821D0F90..0x821D0FD8)
	// 821D0F90: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821D0F94: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 821D0F98: 4809B769  bl 0x8226c700
	ctx.lr = 0x821D0F9C;
	sub_8226C700(ctx, base);
	// 821D0F9C: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 821D0FA0: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 821D0FA4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D0FA8: 419A00F4  beq cr6, 0x821d109c
	if ctx.cr[6].eq {
	pc = 0x821D109C; continue 'dispatch;
	}
	// 821D0FAC: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D0FB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D0FB4: 419A0024  beq cr6, 0x821d0fd8
	if ctx.cr[6].eq {
	pc = 0x821D0FD8; continue 'dispatch;
	}
	// 821D0FB8: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 821D0FBC: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D0FC0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821D0FC4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D0FC8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D0FCC: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821D0FD0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D0FD4: 480000CC  b 0x821d10a0
	pc = 0x821D10A0; continue 'dispatch;
            }
            0x821D0FD8 => {
    //   block [0x821D0FD8..0x821D0FF4)
	// 821D0FD8: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D0FDC: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D0FE0: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 821D0FE4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821D0FE8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D0FEC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D0FF0: 40810054  ble 0x821d1044
	if !ctx.cr[0].gt {
	pc = 0x821D1044; continue 'dispatch;
	}
	pc = 0x821D0FF4; continue 'dispatch;
            }
            0x821D0FF4 => {
    //   block [0x821D0FF4..0x821D1014)
	// 821D0FF4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821D0FF8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D0FFC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821D1000: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D1004: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 821D1008: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D100C: 41980008  blt cr6, 0x821d1014
	if ctx.cr[6].lt {
	pc = 0x821D1014; continue 'dispatch;
	}
	// 821D1010: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x821D1014; continue 'dispatch;
            }
            0x821D1014 => {
    //   block [0x821D1014..0x821D1030)
	// 821D1014: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821D1018: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D101C: 419A0014  beq cr6, 0x821d1030
	if ctx.cr[6].eq {
	pc = 0x821D1030; continue 'dispatch;
	}
	// 821D1020: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821D1024: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D1028: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D102C: 4800000C  b 0x821d1038
	pc = 0x821D1038; continue 'dispatch;
            }
            0x821D1030 => {
    //   block [0x821D1030..0x821D1038)
	// 821D1030: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821D1034: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821D1038; continue 'dispatch;
            }
            0x821D1038 => {
    //   block [0x821D1038..0x821D1044)
	// 821D1038: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D103C: 4199FFB8  bgt cr6, 0x821d0ff4
	if ctx.cr[6].gt {
	pc = 0x821D0FF4; continue 'dispatch;
	}
	// 821D1040: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821D1044; continue 'dispatch;
            }
            0x821D1044 => {
    //   block [0x821D1044..0x821D1060)
	// 821D1044: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821D1048: 419A0040  beq cr6, 0x821d1088
	if ctx.cr[6].eq {
	pc = 0x821D1088; continue 'dispatch;
	}
	// 821D104C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D1050: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 821D1054: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D1058: 41990008  bgt cr6, 0x821d1060
	if ctx.cr[6].gt {
	pc = 0x821D1060; continue 'dispatch;
	}
	// 821D105C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x821D1060; continue 'dispatch;
            }
            0x821D1060 => {
    //   block [0x821D1060..0x821D1088)
	// 821D1060: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D1064: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D1068: 409A0020  bne cr6, 0x821d1088
	if !ctx.cr[6].eq {
	pc = 0x821D1088; continue 'dispatch;
	}
	// 821D106C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D1070: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821D1074: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D1078: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D107C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821D1080: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D1084: 4800001C  b 0x821d10a0
	pc = 0x821D10A0; continue 'dispatch;
            }
            0x821D1088 => {
    //   block [0x821D1088..0x821D109C)
	// 821D1088: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821D108C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D1090: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 821D1094: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D1098: 48000008  b 0x821d10a0
	pc = 0x821D10A0; continue 'dispatch;
            }
            0x821D109C => {
    //   block [0x821D109C..0x821D10A0)
	// 821D109C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x821D10A0; continue 'dispatch;
            }
            0x821D10A0 => {
    //   block [0x821D10A0..0x821D1100)
	// 821D10A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D10A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D10A8: 419A0444  beq cr6, 0x821d14ec
	if ctx.cr[6].eq {
	pc = 0x821D14EC; continue 'dispatch;
	}
	// 821D10AC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821D10B0: 815B0010  lwz r10, 0x10(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D10B4: 3BFB0010  addi r31, r27, 0x10
	ctx.r[31].s64 = ctx.r[27].s64 + 16;
	// 821D10B8: 3B8B9484  addi r28, r11, -0x6b7c
	ctx.r[28].s64 = ctx.r[11].s64 + -27516;
	// 821D10BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D10C0: C3EB9484  lfs f31, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821D10C4: 40990050  ble cr6, 0x821d1114
	if !ctx.cr[6].gt {
	pc = 0x821D1114; continue 'dispatch;
	}
	// 821D10C8: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 821D10CC: 4804E18D  bl 0x8221f258
	ctx.lr = 0x821D10D0;
	sub_8221F258(ctx, base);
	// 821D10D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D10D4: 419A002C  beq cr6, 0x821d1100
	if ctx.cr[6].eq {
	pc = 0x821D1100; continue 'dispatch;
	}
	// 821D10D8: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 821D10DC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821D10E0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821D10E4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821D10E8: 480B2B49  bl 0x82283c30
	ctx.lr = 0x821D10EC;
	sub_82283C30(ctx, base);
	// 821D10EC: 3BDB0008  addi r30, r27, 8
	ctx.r[30].s64 = ctx.r[27].s64 + 8;
	// 821D10F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D10F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D10F8: 480A1F61  bl 0x82273058
	ctx.lr = 0x821D10FC;
	sub_82273058(ctx, base);
	// 821D10FC: 480000AC  b 0x821d11a8
	pc = 0x821D11A8; continue 'dispatch;
            }
            0x821D1100 => {
    //   block [0x821D1100..0x821D1114)
	// 821D1100: 3BDB0008  addi r30, r27, 8
	ctx.r[30].s64 = ctx.r[27].s64 + 8;
	// 821D1104: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821D1108: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D110C: 480A1F4D  bl 0x82273058
	ctx.lr = 0x821D1110;
	sub_82273058(ctx, base);
	// 821D1110: 48000098  b 0x821d11a8
	pc = 0x821D11A8; continue 'dispatch;
            }
            0x821D1114 => {
    //   block [0x821D1114..0x821D1140)
	// 821D1114: 817B0018  lwz r11, 0x18(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D1118: 3BFB0018  addi r31, r27, 0x18
	ctx.r[31].s64 = ctx.r[27].s64 + 24;
	// 821D111C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D1120: 419A0020  beq cr6, 0x821d1140
	if ctx.cr[6].eq {
	pc = 0x821D1140; continue 'dispatch;
	}
	// 821D1124: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D1128: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D112C: 419A0014  beq cr6, 0x821d1140
	if ctx.cr[6].eq {
	pc = 0x821D1140; continue 'dispatch;
	}
	// 821D1130: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D1134: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821D1138: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D113C: 409A0008  bne cr6, 0x821d1144
	if !ctx.cr[6].eq {
	pc = 0x821D1144; continue 'dispatch;
	}
	pc = 0x821D1140; continue 'dispatch;
            }
            0x821D1140 => {
    //   block [0x821D1140..0x821D1144)
	// 821D1140: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x821D1144; continue 'dispatch;
            }
            0x821D1144 => {
    //   block [0x821D1144..0x821D1188)
	// 821D1144: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D1148: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821D114C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D1150: 419A0038  beq cr6, 0x821d1188
	if ctx.cr[6].eq {
	pc = 0x821D1188; continue 'dispatch;
	}
	// 821D1154: 4809B5AD  bl 0x8226c700
	ctx.lr = 0x821D1158;
	sub_8226C700(ctx, base);
	// 821D1158: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 821D115C: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D1160: 3BDB0008  addi r30, r27, 8
	ctx.r[30].s64 = ctx.r[27].s64 + 8;
	// 821D1164: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D1168: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D116C: 4BFF56F5  bl 0x821c6860
	ctx.lr = 0x821D1170;
	sub_821C6860(ctx, base);
	// 821D1170: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821D1174: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821D1178: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D117C: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 821D1180: 480C5991  bl 0x82296b10
	ctx.lr = 0x821D1184;
	sub_82296B10(ctx, base);
	// 821D1184: 48000024  b 0x821d11a8
	pc = 0x821D11A8; continue 'dispatch;
            }
            0x821D1188 => {
    //   block [0x821D1188..0x821D11A8)
	// 821D1188: 3BDB0008  addi r30, r27, 8
	ctx.r[30].s64 = ctx.r[27].s64 + 8;
	// 821D118C: 3BFB0014  addi r31, r27, 0x14
	ctx.r[31].s64 = ctx.r[27].s64 + 20;
	// 821D1190: 4809B571  bl 0x8226c700
	ctx.lr = 0x821D1194;
	sub_8226C700(ctx, base);
	// 821D1194: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D1198: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D119C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821D11A0: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 821D11A4: 480C5CCD  bl 0x82296e70
	ctx.lr = 0x821D11A8;
	sub_82296E70(ctx, base);
	pc = 0x821D11A8; continue 'dispatch;
            }
            0x821D11A8 => {
    //   block [0x821D11A8..0x821D11FC)
	// 821D11A8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D11AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D11B0: 409A0174  bne cr6, 0x821d1324
	if !ctx.cr[6].eq {
	pc = 0x821D1324; continue 'dispatch;
	}
	// 821D11B4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821D11B8: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 821D11BC: 4809B545  bl 0x8226c700
	ctx.lr = 0x821D11C0;
	sub_8226C700(ctx, base);
	// 821D11C0: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 821D11C4: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 821D11C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D11CC: 419A00F0  beq cr6, 0x821d12bc
	if ctx.cr[6].eq {
	pc = 0x821D12BC; continue 'dispatch;
	}
	// 821D11D0: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D11D4: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D11D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D11DC: 419A0020  beq cr6, 0x821d11fc
	if ctx.cr[6].eq {
	pc = 0x821D11FC; continue 'dispatch;
	}
	// 821D11E0: 896B0015  lbz r11, 0x15(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821D11E4: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821D11E8: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821D11EC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D11F0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821D11F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D11F8: 480000C8  b 0x821d12c0
	pc = 0x821D12C0; continue 'dispatch;
            }
            0x821D11FC => {
    //   block [0x821D11FC..0x821D1214)
	// 821D11FC: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D1200: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 821D1204: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821D1208: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D120C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D1210: 40810054  ble 0x821d1264
	if !ctx.cr[0].gt {
	pc = 0x821D1264; continue 'dispatch;
	}
	pc = 0x821D1214; continue 'dispatch;
            }
            0x821D1214 => {
    //   block [0x821D1214..0x821D1234)
	// 821D1214: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821D1218: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D121C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821D1220: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D1224: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 821D1228: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D122C: 41980008  blt cr6, 0x821d1234
	if ctx.cr[6].lt {
	pc = 0x821D1234; continue 'dispatch;
	}
	// 821D1230: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x821D1234; continue 'dispatch;
            }
            0x821D1234 => {
    //   block [0x821D1234..0x821D1250)
	// 821D1234: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821D1238: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D123C: 419A0014  beq cr6, 0x821d1250
	if ctx.cr[6].eq {
	pc = 0x821D1250; continue 'dispatch;
	}
	// 821D1240: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821D1244: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D1248: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D124C: 4800000C  b 0x821d1258
	pc = 0x821D1258; continue 'dispatch;
            }
            0x821D1250 => {
    //   block [0x821D1250..0x821D1258)
	// 821D1250: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821D1254: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821D1258; continue 'dispatch;
            }
            0x821D1258 => {
    //   block [0x821D1258..0x821D1264)
	// 821D1258: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D125C: 4199FFB8  bgt cr6, 0x821d1214
	if ctx.cr[6].gt {
	pc = 0x821D1214; continue 'dispatch;
	}
	// 821D1260: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821D1264; continue 'dispatch;
            }
            0x821D1264 => {
    //   block [0x821D1264..0x821D1280)
	// 821D1264: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821D1268: 419A0040  beq cr6, 0x821d12a8
	if ctx.cr[6].eq {
	pc = 0x821D12A8; continue 'dispatch;
	}
	// 821D126C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D1270: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 821D1274: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D1278: 41990008  bgt cr6, 0x821d1280
	if ctx.cr[6].gt {
	pc = 0x821D1280; continue 'dispatch;
	}
	// 821D127C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x821D1280; continue 'dispatch;
            }
            0x821D1280 => {
    //   block [0x821D1280..0x821D12A8)
	// 821D1280: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D1284: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D1288: 409A0020  bne cr6, 0x821d12a8
	if !ctx.cr[6].eq {
	pc = 0x821D12A8; continue 'dispatch;
	}
	// 821D128C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D1290: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821D1294: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D1298: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D129C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821D12A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D12A4: 4800001C  b 0x821d12c0
	pc = 0x821D12C0; continue 'dispatch;
            }
            0x821D12A8 => {
    //   block [0x821D12A8..0x821D12BC)
	// 821D12A8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821D12AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D12B0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821D12B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D12B8: 48000008  b 0x821d12c0
	pc = 0x821D12C0; continue 'dispatch;
            }
            0x821D12BC => {
    //   block [0x821D12BC..0x821D12C0)
	// 821D12BC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x821D12C0; continue 'dispatch;
            }
            0x821D12C0 => {
    //   block [0x821D12C0..0x821D1318)
	// 821D12C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D12C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D12C8: 419A005C  beq cr6, 0x821d1324
	if ctx.cr[6].eq {
	pc = 0x821D1324; continue 'dispatch;
	}
	// 821D12CC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821D12D0: 38BB0014  addi r5, r27, 0x14
	ctx.r[5].s64 = ctx.r[27].s64 + 20;
	// 821D12D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D12D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D12DC: 48250475  bl 0x82421750
	ctx.lr = 0x821D12E0;
	sub_82421750(ctx, base);
	// 821D12E0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D12E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D12E8: 419A003C  beq cr6, 0x821d1324
	if ctx.cr[6].eq {
	pc = 0x821D1324; continue 'dispatch;
	}
	// 821D12EC: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 821D12F0: 4804DF69  bl 0x8221f258
	ctx.lr = 0x821D12F4;
	sub_8221F258(ctx, base);
	// 821D12F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D12F8: 419A0020  beq cr6, 0x821d1318
	if ctx.cr[6].eq {
	pc = 0x821D1318; continue 'dispatch;
	}
	// 821D12FC: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 821D1300: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821D1304: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821D1308: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821D130C: 480B2925  bl 0x82283c30
	ctx.lr = 0x821D1310;
	sub_82283C30(ctx, base);
	// 821D1310: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D1314: 48000008  b 0x821d131c
	pc = 0x821D131C; continue 'dispatch;
            }
            0x821D1318 => {
    //   block [0x821D1318..0x821D131C)
	// 821D1318: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	pc = 0x821D131C; continue 'dispatch;
            }
            0x821D131C => {
    //   block [0x821D131C..0x821D1324)
	// 821D131C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D1320: 480A1D39  bl 0x82273058
	ctx.lr = 0x821D1324;
	sub_82273058(ctx, base);
	pc = 0x821D1324; continue 'dispatch;
            }
            0x821D1324 => {
    //   block [0x821D1324..0x821D1378)
	// 821D1324: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D1328: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D132C: 409A0058  bne cr6, 0x821d1384
	if !ctx.cr[6].eq {
	pc = 0x821D1384; continue 'dispatch;
	}
	// 821D1330: 38BB0014  addi r5, r27, 0x14
	ctx.r[5].s64 = ctx.r[27].s64 + 20;
	// 821D1334: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821D1338: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D133C: 480D0955  bl 0x822a1c90
	ctx.lr = 0x821D1340;
	sub_822A1C90(ctx, base);
	// 821D1340: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D1344: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D1348: 419A003C  beq cr6, 0x821d1384
	if ctx.cr[6].eq {
	pc = 0x821D1384; continue 'dispatch;
	}
	// 821D134C: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 821D1350: 4804DF09  bl 0x8221f258
	ctx.lr = 0x821D1354;
	sub_8221F258(ctx, base);
	// 821D1354: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D1358: 419A0020  beq cr6, 0x821d1378
	if ctx.cr[6].eq {
	pc = 0x821D1378; continue 'dispatch;
	}
	// 821D135C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 821D1360: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821D1364: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821D1368: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821D136C: 480B28C5  bl 0x82283c30
	ctx.lr = 0x821D1370;
	sub_82283C30(ctx, base);
	// 821D1370: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D1374: 48000008  b 0x821d137c
	pc = 0x821D137C; continue 'dispatch;
            }
            0x821D1378 => {
    //   block [0x821D1378..0x821D137C)
	// 821D1378: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	pc = 0x821D137C; continue 'dispatch;
            }
            0x821D137C => {
    //   block [0x821D137C..0x821D1384)
	// 821D137C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D1380: 480A1CD9  bl 0x82273058
	ctx.lr = 0x821D1384;
	sub_82273058(ctx, base);
	pc = 0x821D1384; continue 'dispatch;
            }
            0x821D1384 => {
    //   block [0x821D1384..0x821D13B4)
	// 821D1384: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D1388: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D138C: 419A0160  beq cr6, 0x821d14ec
	if ctx.cr[6].eq {
	pc = 0x821D14EC; continue 'dispatch;
	}
	// 821D1390: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821D1394: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D1398: 892BEC1B  lbz r9, -0x13e5(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-5093 as u32) ) } as u64;
	// 821D139C: C3EA0040  lfs f31, 0x40(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821D13A0: C3CA0044  lfs f30, 0x44(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821D13A4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821D13A8: 419A000C  beq cr6, 0x821d13b4
	if ctx.cr[6].eq {
	pc = 0x821D13B4; continue 'dispatch;
	}
	// 821D13AC: C3FCFE50  lfs f31, -0x1b0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-432 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821D13B0: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	pc = 0x821D13B4; continue 'dispatch;
            }
            0x821D13B4 => {
    //   block [0x821D13B4..0x821D13D4)
	// 821D13B4: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 821D13B8: 4804DEA1  bl 0x8221f258
	ctx.lr = 0x821D13BC;
	sub_8221F258(ctx, base);
	// 821D13BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D13C0: 419A0014  beq cr6, 0x821d13d4
	if ctx.cr[6].eq {
	pc = 0x821D13D4; continue 'dispatch;
	}
	// 821D13C4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821D13C8: 480BA779  bl 0x8228bb40
	ctx.lr = 0x821D13CC;
	sub_8228BB40(ctx, base);
	// 821D13CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D13D0: 48000008  b 0x821d13d8
	pc = 0x821D13D8; continue 'dispatch;
            }
            0x821D13D4 => {
    //   block [0x821D13D4..0x821D13D8)
	// 821D13D4: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	pc = 0x821D13D8; continue 'dispatch;
            }
            0x821D13D8 => {
    //   block [0x821D13D8..0x821D13F8)
	// 821D13D8: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 821D13DC: 4804DE7D  bl 0x8221f258
	ctx.lr = 0x821D13E0;
	sub_8221F258(ctx, base);
	// 821D13E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D13E4: 419A0014  beq cr6, 0x821d13f8
	if ctx.cr[6].eq {
	pc = 0x821D13F8; continue 'dispatch;
	}
	// 821D13E8: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821D13EC: 4805834D  bl 0x82229738
	ctx.lr = 0x821D13F0;
	sub_82229738(ctx, base);
	// 821D13F0: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 821D13F4: 48000008  b 0x821d13fc
	pc = 0x821D13FC; continue 'dispatch;
            }
            0x821D13F8 => {
    //   block [0x821D13F8..0x821D13FC)
	// 821D13F8: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	pc = 0x821D13FC; continue 'dispatch;
            }
            0x821D13FC => {
    //   block [0x821D13FC..0x821D1434)
	// 821D13FC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 821D1400: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D1404: 38C00080  li r6, 0x80
	ctx.r[6].s64 = 128;
	// 821D1408: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821D140C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821D1410: 4BFFCD31  bl 0x821ce140
	ctx.lr = 0x821D1414;
	sub_821CE140(ctx, base);
	// 821D1414: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D1418: 807B002C  lwz r3, 0x2c(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(44 as u32) ) } as u64;
	// 821D141C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D1420: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821D1424: 419A0078  beq cr6, 0x821d149c
	if ctx.cr[6].eq {
	pc = 0x821D149C; continue 'dispatch;
	}
	// 821D1428: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D142C: 419A0040  beq cr6, 0x821d146c
	if ctx.cr[6].eq {
	pc = 0x821D146C; continue 'dispatch;
	}
	// 821D1430: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x821D1434; continue 'dispatch;
            }
            0x821D1434 => {
    //   block [0x821D1434..0x821D1468)
	// 821D1434: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821D1438: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D143C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821D1440: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D1444: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821D1448: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D144C: 4082FFE8  bne 0x821d1434
	if !ctx.cr[0].eq {
	pc = 0x821D1434; continue 'dispatch;
	}
	// 821D1450: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D1454: 409A0014  bne cr6, 0x821d1468
	if !ctx.cr[6].eq {
	pc = 0x821D1468; continue 'dispatch;
	}
	// 821D1458: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D145C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D1460: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D1464: 4E800421  bctrl
	ctx.lr = 0x821D1468;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821D1468 => {
    //   block [0x821D1468..0x821D146C)
	// 821D1468: 933B002C  stw r25, 0x2c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(44 as u32), ctx.r[25].u32 ) };
	pc = 0x821D146C; continue 'dispatch;
            }
            0x821D146C => {
    //   block [0x821D146C..0x821D1480)
	// 821D146C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D1470: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D1474: 917B002C  stw r11, 0x2c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 821D1478: 419A0024  beq cr6, 0x821d149c
	if ctx.cr[6].eq {
	pc = 0x821D149C; continue 'dispatch;
	}
	// 821D147C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x821D1480; continue 'dispatch;
            }
            0x821D1480 => {
    //   block [0x821D1480..0x821D149C)
	// 821D1480: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821D1484: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D1488: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821D148C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821D1490: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821D1494: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D1498: 4082FFE8  bne 0x821d1480
	if !ctx.cr[0].eq {
	pc = 0x821D1480; continue 'dispatch;
	}
	pc = 0x821D149C; continue 'dispatch;
            }
            0x821D149C => {
    //   block [0x821D149C..0x821D14B0)
	// 821D149C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821D14A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D14A4: 419A0048  beq cr6, 0x821d14ec
	if ctx.cr[6].eq {
	pc = 0x821D14EC; continue 'dispatch;
	}
	// 821D14A8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821D14AC: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x821D14B0; continue 'dispatch;
            }
            0x821D14B0 => {
    //   block [0x821D14B0..0x821D14E8)
	// 821D14B0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821D14B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D14B8: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821D14BC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821D14C0: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821D14C4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D14C8: 4082FFE8  bne 0x821d14b0
	if !ctx.cr[0].eq {
	pc = 0x821D14B0; continue 'dispatch;
	}
	// 821D14CC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821D14D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D14D4: 409A0014  bne cr6, 0x821d14e8
	if !ctx.cr[6].eq {
	pc = 0x821D14E8; continue 'dispatch;
	}
	// 821D14D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D14DC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D14E0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D14E4: 4E800421  bctrl
	ctx.lr = 0x821D14E8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821D14E8 => {
    //   block [0x821D14E8..0x821D14EC)
	// 821D14E8: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	pc = 0x821D14EC; continue 'dispatch;
            }
            0x821D14EC => {
    //   block [0x821D14EC..0x821D1504)
	// 821D14EC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821D14F0: 480A03B9  bl 0x822718a8
	ctx.lr = 0x821D14F4;
	sub_822718A8(ctx, base);
	// 821D14F4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821D14F8: CBC1FFA8  lfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 821D14FC: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 821D1500: 48AD7F48  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D1508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821D1508 size=164
    let mut pc: u32 = 0x821D1508;
    'dispatch: loop {
        match pc {
            0x821D1508 => {
    //   block [0x821D1508..0x821D1520)
	// 821D1508: 3D607F10  lis r11, 0x7f10
	ctx.r[11].s64 = 2131755008;
	// 821D150C: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D1510: 41980010  blt cr6, 0x821d1520
	if ctx.cr[6].lt {
	pc = 0x821D1520; continue 'dispatch;
	}
	// 821D1514: 3D608700  lis r11, -0x7900
	ctx.r[11].s64 = -2030043136;
	// 821D1518: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D151C: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	pc = 0x821D1520; continue 'dispatch;
            }
            0x821D1520 => {
    //   block [0x821D1520..0x821D1544)
	// 821D1520: 3944007F  addi r10, r4, 0x7f
	ctx.r[10].s64 = ctx.r[4].s64 + 127;
	// 821D1524: 546B0030  rlwinm r11, r3, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0xFFFFFFFFu64;
	// 821D1528: 554A0030  rlwinm r10, r10, 0, 0, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821D152C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D1530: 7D4A3E70  srawi r10, r10, 7
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 7) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 7) as i64;
	// 821D1534: 7D4A0194  addze r10, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[10].s64 = tmp.s64;
	// 821D1538: 5549E8FF  rlwinm. r9, r10, 0x1d, 3, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821D153C: 554A077E  clrlwi r10, r10, 0x1d
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 821D1540: 4182004C  beq 0x821d158c
	if ctx.cr[0].eq {
	pc = 0x821D158C; continue 'dispatch;
	}
	pc = 0x821D1544; continue 'dispatch;
            }
            0x821D1544 => {
    //   block [0x821D1544..0x821D158C)
	// 821D1544: 7C0058AC  dcbf 0, r11
	// 821D1548: 39000080  li r8, 0x80
	ctx.r[8].s64 = 128;
	// 821D154C: 7C0858AC  dcbf r8, r11
	// 821D1550: 39000100  li r8, 0x100
	ctx.r[8].s64 = 256;
	// 821D1554: 7C0858AC  dcbf r8, r11
	// 821D1558: 39000180  li r8, 0x180
	ctx.r[8].s64 = 384;
	// 821D155C: 7C0858AC  dcbf r8, r11
	// 821D1560: 39000200  li r8, 0x200
	ctx.r[8].s64 = 512;
	// 821D1564: 7C0858AC  dcbf r8, r11
	// 821D1568: 39000280  li r8, 0x280
	ctx.r[8].s64 = 640;
	// 821D156C: 7C0858AC  dcbf r8, r11
	// 821D1570: 39000300  li r8, 0x300
	ctx.r[8].s64 = 768;
	// 821D1574: 7C0858AC  dcbf r8, r11
	// 821D1578: 39000380  li r8, 0x380
	ctx.r[8].s64 = 896;
	// 821D157C: 7C0858AC  dcbf r8, r11
	// 821D1580: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821D1584: 396B0400  addi r11, r11, 0x400
	ctx.r[11].s64 = ctx.r[11].s64 + 1024;
	// 821D1588: 4082FFBC  bne 0x821d1544
	if !ctx.cr[0].eq {
	pc = 0x821D1544; continue 'dispatch;
	}
	pc = 0x821D158C; continue 'dispatch;
            }
            0x821D158C => {
    //   block [0x821D158C..0x821D1594)
	// 821D158C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D1590: 419A0014  beq cr6, 0x821d15a4
	if ctx.cr[6].eq {
	pc = 0x821D15A4; continue 'dispatch;
	}
	pc = 0x821D1594; continue 'dispatch;
            }
            0x821D1594 => {
    //   block [0x821D1594..0x821D15A4)
	// 821D1594: 7C0058AC  dcbf 0, r11
	// 821D1598: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821D159C: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 821D15A0: 4082FFF4  bne 0x821d1594
	if !ctx.cr[0].eq {
	pc = 0x821D1594; continue 'dispatch;
	}
	pc = 0x821D15A4; continue 'dispatch;
            }
            0x821D15A4 => {
    //   block [0x821D15A4..0x821D15AC)
	// 821D15A4: 7C0004AC  sync
	// 821D15A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D15B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D15B0 size=276
    let mut pc: u32 = 0x821D15B0;
    'dispatch: loop {
        match pc {
            0x821D15B0 => {
    //   block [0x821D15B0..0x821D15F8)
	// 821D15B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D15B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D15B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821D15BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D15C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D15C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D15C8: 3FC04000  lis r30, 0x4000
	ctx.r[30].s64 = 1073741824;
	// 821D15CC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D15D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D15D4: 419A0024  beq cr6, 0x821d15f8
	if ctx.cr[6].eq {
	pc = 0x821D15F8; continue 'dispatch;
	}
	// 821D15D8: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D15DC: 552A653E  srwi r10, r9, 0x14
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shr(20);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D15E0: 552900FE  clrlwi r9, r9, 3
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x1FFFFFFFu64;
	// 821D15E4: 394A0200  addi r10, r10, 0x200
	ctx.r[10].s64 = ctx.r[10].s64 + 512;
	// 821D15E8: 554A04E6  rlwinm r10, r10, 0, 0x13, 0x13
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821D15EC: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821D15F0: 7D5E5050  subf r10, r30, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[30].s64;
	// 821D15F4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x821D15F8; continue 'dispatch;
            }
            0x821D15F8 => {
    //   block [0x821D15F8..0x821D1624)
	// 821D15F8: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 821D15FC: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D1600: 38800420  li r4, 0x420
	ctx.r[4].s64 = 1056;
	// 821D1604: 480350E5  bl 0x822066e8
	ctx.lr = 0x821D1608;
	sub_822066E8(ctx, base);
	// 821D1608: 7C671B79  or. r7, r3, r3
	ctx.r[7].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821D160C: 40820018  bne 0x821d1624
	if !ctx.cr[0].eq {
	pc = 0x821D1624; continue 'dispatch;
	}
	// 821D1610: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D1614: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821D1618: 80EB4158  lwz r7, 0x4158(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16728 as u32) ) } as u64;
	// 821D161C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821D1620: 48000078  b 0x821d1698
	pc = 0x821D1698; continue 'dispatch;
            }
            0x821D1624 => {
    //   block [0x821D1624..0x821D1670)
	// 821D1624: 39670004  addi r11, r7, 4
	ctx.r[11].s64 = ctx.r[7].s64 + 4;
	// 821D1628: 5569653E  srwi r9, r11, 0x14
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(20);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821D162C: 556A00FE  clrlwi r10, r11, 3
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 821D1630: 39690200  addi r11, r9, 0x200
	ctx.r[11].s64 = ctx.r[9].s64 + 512;
	// 821D1634: 556B04E6  rlwinm r11, r11, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821D1638: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821D163C: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 821D1640: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821D1644: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D1648: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D164C: 419A0024  beq cr6, 0x821d1670
	if ctx.cr[6].eq {
	pc = 0x821D1670; continue 'dispatch;
	}
	// 821D1650: 54EA653E  srwi r10, r7, 0x14
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shr(20);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D1654: 54E900FE  clrlwi r9, r7, 3
	ctx.r[9].u64 = ctx.r[7].u32 as u64 & 0x1FFFFFFFu64;
	// 821D1658: 394A0200  addi r10, r10, 0x200
	ctx.r[10].s64 = ctx.r[10].s64 + 512;
	// 821D165C: 554A04E6  rlwinm r10, r10, 0, 0x13, 0x13
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821D1660: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821D1664: 7D5E5050  subf r10, r30, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[30].s64;
	// 821D1668: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821D166C: 48000008  b 0x821d1674
	pc = 0x821D1674; continue 'dispatch;
            }
            0x821D1670 => {
    //   block [0x821D1670..0x821D1674)
	// 821D1670: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	pc = 0x821D1674; continue 'dispatch;
            }
            0x821D1674 => {
    //   block [0x821D1674..0x821D1698)
	// 821D1674: 54EB653E  srwi r11, r7, 0x14
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shr(20);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D1678: 54EA00FE  clrlwi r10, r7, 3
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0x1FFFFFFFu64;
	// 821D167C: 396B0200  addi r11, r11, 0x200
	ctx.r[11].s64 = ctx.r[11].s64 + 512;
	// 821D1680: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821D1684: 556B04E6  rlwinm r11, r11, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821D1688: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821D168C: 7C7E5850  subf r3, r30, r11
	ctx.r[3].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 821D1690: 38831080  addi r4, r3, 0x1080
	ctx.r[4].s64 = ctx.r[3].s64 + 4224;
	// 821D1694: 4BFFFE75  bl 0x821d1508
	ctx.lr = 0x821D1698;
	sub_821D1508(ctx, base);
	pc = 0x821D1698; continue 'dispatch;
            }
            0x821D1698 => {
    //   block [0x821D1698..0x821D16C4)
	// 821D1698: 38670004  addi r3, r7, 4
	ctx.r[3].s64 = ctx.r[7].s64 + 4;
	// 821D169C: 90FF0004  stw r7, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821D16A0: 3967107C  addi r11, r7, 0x107c
	ctx.r[11].s64 = ctx.r[7].s64 + 4220;
	// 821D16A4: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 821D16A8: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 821D16AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D16B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D16B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D16B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821D16BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D16C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D16C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D16C8 size=176
    let mut pc: u32 = 0x821D16C8;
    'dispatch: loop {
        match pc {
            0x821D16C8 => {
    //   block [0x821D16C8..0x821D174C)
	// 821D16C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D16CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D16D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821D16D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D16D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D16DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D16E0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821D16E4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D16E8: 556A07BC  rlwinm r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821D16EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D16F0: 409A0070  bne cr6, 0x821d1760
	if !ctx.cr[6].eq {
	pc = 0x821D1760; continue 'dispatch;
	}
	// 821D16F4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821D16F8: 3880001C  li r4, 0x1c
	ctx.r[4].s64 = 28;
	// 821D16FC: 806B6F1C  lwz r3, 0x6f1c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28444 as u32) ) } as u64;
	// 821D1700: 48A19AE1  bl 0x82beb1e0
	ctx.lr = 0x821D1704;
	sub_82BEB1E0(ctx, base);
	// 821D1704: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D1708: 419A0044  beq cr6, 0x821d174c
	if ctx.cr[6].eq {
	pc = 0x821D174C; continue 'dispatch;
	}
	// 821D170C: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821D1710: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821D1714: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821D1718: 3D00820F  lis r8, -0x7df1
	ctx.r[8].s64 = -2112946176;
	// 821D171C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821D1720: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D1724: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 821D1728: 38E86E98  addi r7, r8, 0x6e98
	ctx.r[7].s64 = ctx.r[8].s64 + 28312;
	// 821D172C: 81496F18  lwz r10, 0x6f18(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28440 as u32) ) } as u64;
	// 821D1730: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 821D1734: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 821D1738: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	// 821D173C: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821D1740: 91696F18  stw r11, 0x6f18(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28440 as u32), ctx.r[11].u32 ) };
	// 821D1744: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 821D1748: 48000008  b 0x821d1750
	pc = 0x821D1750; continue 'dispatch;
            }
            0x821D174C => {
    //   block [0x821D174C..0x821D1750)
	// 821D174C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x821D1750; continue 'dispatch;
            }
            0x821D1750 => {
    //   block [0x821D1750..0x821D1760)
	// 821D1750: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D1754: C03F0274  lfs f1, 0x274(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821D1758: 386B00A8  addi r3, r11, 0xa8
	ctx.r[3].s64 = ctx.r[11].s64 + 168;
	// 821D175C: 4805AB55  bl 0x8222c2b0
	ctx.lr = 0x821D1760;
	sub_8222C2B0(ctx, base);
	pc = 0x821D1760; continue 'dispatch;
            }
            0x821D1760 => {
    //   block [0x821D1760..0x821D1778)
	// 821D1760: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D1764: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D1768: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D176C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821D1770: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D1774: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D1778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D1778 size=24
    let mut pc: u32 = 0x821D1778;
    'dispatch: loop {
        match pc {
            0x821D1778 => {
    //   block [0x821D1778..0x821D1790)
	// 821D1778: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D177C: 48000014  b 0x821d1790
	sub_821D1790(ctx, base);
	return;
	// 821D1780: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821D1784: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D1788: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821D178C: 4BFF8E5C  b 0x821ca5e8
	sub_821CA5E8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D1790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D1790 size=836
    let mut pc: u32 = 0x821D1790;
    'dispatch: loop {
        match pc {
            0x821D1790 => {
    //   block [0x821D1790..0x821D1AD4)
	// 821D1790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D1794: 48AD7C71  bl 0x82ca9404
	ctx.lr = 0x821D1798;
	sub_82CA93D0(ctx, base);
	// 821D1798: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D179C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D17A0: 38600099  li r3, 0x99
	ctx.r[3].s64 = 153;
	// 821D17A4: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 821D17A8: 4805AA69  bl 0x8222c210
	ctx.lr = 0x821D17AC;
	sub_8222C210(ctx, base);
	// 821D17AC: 3860009A  li r3, 0x9a
	ctx.r[3].s64 = 154;
	// 821D17B0: 48037361  bl 0x82208b10
	ctx.lr = 0x821D17B4;
	sub_82208B10(ctx, base);
	// 821D17B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D17B8: 4BFE8B81  bl 0x821ba338
	ctx.lr = 0x821D17BC;
	sub_821BA338(ctx, base);
	// 821D17BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D17C0: 4BFE8CD9  bl 0x821ba498
	ctx.lr = 0x821D17C4;
	sub_821BA498(ctx, base);
	// 821D17C4: 39600690  li r11, 0x690
	ctx.r[11].s64 = 1680;
	// 821D17C8: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 821D17CC: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821D17D0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D1AD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D1AD8 size=28
    let mut pc: u32 = 0x821D1AD8;
    'dispatch: loop {
        match pc {
            0x821D1AD8 => {
    //   block [0x821D1AD8..0x821D1AF4)
	// 821D1AD8: 80630038  lwz r3, 0x38(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 821D1ADC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D1AE0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 821D1AE4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D1AE8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D1AEC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D1AF0: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D1AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D1AF8 size=420
    let mut pc: u32 = 0x821D1AF8;
    'dispatch: loop {
        match pc {
            0x821D1AF8 => {
    //   block [0x821D1AF8..0x821D1B20)
	// 821D1AF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D1AFC: 48AD790D  bl 0x82ca9408
	ctx.lr = 0x821D1B00;
	sub_82CA93D0(ctx, base);
	// 821D1B00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D1B04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D1B08: 897F2ABD  lbz r11, 0x2abd(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10941 as u32) ) } as u64;
	// 821D1B0C: 556B06B5  rlwinm. r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D1B10: 41820010  beq 0x821d1b20
	if ctx.cr[0].eq {
	pc = 0x821D1B20; continue 'dispatch;
	}
	// 821D1B14: 489D0A35  bl 0x82ba2548
	ctx.lr = 0x821D1B18;
	sub_82BA2548(ctx, base);
	// 821D1B18: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821D1B1C: 48000178  b 0x821d1c94
	pc = 0x821D1C94; continue 'dispatch;
            }
            0x821D1B20 => {
    //   block [0x821D1B20..0x821D1B34)
	// 821D1B20: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821D1B24: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821D1B28: 409A000C  bne cr6, 0x821d1b34
	if !ctx.cr[6].eq {
	pc = 0x821D1B34; continue 'dispatch;
	}
	// 821D1B2C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821D1B30: 4800000C  b 0x821d1b3c
	pc = 0x821D1B3C; continue 'dispatch;
            }
            0x821D1B34 => {
    //   block [0x821D1B34..0x821D1B3C)
	// 821D1B34: 3964000E  addi r11, r4, 0xe
	ctx.r[11].s64 = ctx.r[4].s64 + 14;
	// 821D1B38: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	pc = 0x821D1B3C; continue 'dispatch;
            }
            0x821D1B3C => {
    //   block [0x821D1B3C..0x821D1B64)
	// 821D1B3C: 83DF34CC  lwz r30, 0x34cc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13516 as u32) ) } as u64;
	// 821D1B40: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821D1B44: 419A0020  beq cr6, 0x821d1b64
	if ctx.cr[6].eq {
	pc = 0x821D1B64; continue 'dispatch;
	}
	// 821D1B48: 815E00AC  lwz r10, 0xac(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(172 as u32) ) } as u64;
	// 821D1B4C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D1B50: 419A0014  beq cr6, 0x821d1b64
	if ctx.cr[6].eq {
	pc = 0x821D1B64; continue 'dispatch;
	}
	// 821D1B54: 815F3A40  lwz r10, 0x3a40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(14912 as u32) ) } as u64;
	// 821D1B58: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D1B5C: 41990008  bgt cr6, 0x821d1b64
	if ctx.cr[6].gt {
	pc = 0x821D1B64; continue 'dispatch;
	}
	// 821D1B60: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x821D1B64; continue 'dispatch;
            }
            0x821D1B64 => {
    //   block [0x821D1B64..0x821D1B8C)
	// 821D1B64: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821D1B68: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821D1B6C: 40820020  bne 0x821d1b8c
	if !ctx.cr[0].eq {
	pc = 0x821D1B8C; continue 'dispatch;
	}
	// 821D1B70: 38C00020  li r6, 0x20
	ctx.r[6].s64 = 32;
	// 821D1B74: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821D1B78: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821D1B7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D1B80: 48034939  bl 0x822064b8
	ctx.lr = 0x821D1B84;
	sub_822064B8(ctx, base);
	// 821D1B84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821D1B88: 48000094  b 0x821d1c1c
	pc = 0x821D1C1C; continue 'dispatch;
            }
            0x821D1B8C => {
    //   block [0x821D1B8C..0x821D1BAC)
	// 821D1B8C: 817E0098  lwz r11, 0x98(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(152 as u32) ) } as u64;
	// 821D1B90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D1B94: 419A0030  beq cr6, 0x821d1bc4
	if ctx.cr[6].eq {
	pc = 0x821D1BC4; continue 'dispatch;
	}
	// 821D1B98: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821D1B9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D1BA0: 419A000C  beq cr6, 0x821d1bac
	if ctx.cr[6].eq {
	pc = 0x821D1BAC; continue 'dispatch;
	}
	// 821D1BA4: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 821D1BA8: 4800007C  b 0x821d1c24
	pc = 0x821D1C24; continue 'dispatch;
            }
            0x821D1BAC => {
    //   block [0x821D1BAC..0x821D1BC4)
	// 821D1BAC: 817E0098  lwz r11, 0x98(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(152 as u32) ) } as u64;
	// 821D1BB0: 917F3A50  stw r11, 0x3a50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(14928 as u32), ctx.r[11].u32 ) };
	// 821D1BB4: 817E009C  lwz r11, 0x9c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(156 as u32) ) } as u64;
	// 821D1BB8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821D1BBC: 83DE0098  lwz r30, 0x98(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(152 as u32) ) } as u64;
	// 821D1BC0: 4800005C  b 0x821d1c1c
	pc = 0x821D1C1C; continue 'dispatch;
            }
            0x821D1BC4 => {
    //   block [0x821D1BC4..0x821D1BDC)
	// 821D1BC4: 490E7D81  bl 0x832b9944
	ctx.lr = 0x821D1BC8;
	// extern call 0x832B9944  crate::xboxkrnl::KeGetCurrentProcessType
	crate::xboxkrnl::KeGetCurrentProcessType(ctx, base);
	// 821D1BC8: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 821D1BCC: 409A0010  bne cr6, 0x821d1bdc
	if !ctx.cr[6].eq {
	pc = 0x821D1BDC; continue 'dispatch;
	}
	// 821D1BD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821D1BD4: 816B09AC  lwz r11, 0x9ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2476 as u32) ) } as u64;
	// 821D1BD8: 4800000C  b 0x821d1be4
	pc = 0x821D1BE4; continue 'dispatch;
            }
            0x821D1BDC => {
    //   block [0x821D1BDC..0x821D1BE4)
	// 821D1BDC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821D1BE0: 816B09B0  lwz r11, 0x9b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2480 as u32) ) } as u64;
	pc = 0x821D1BE4; continue 'dispatch;
            }
            0x821D1BE4 => {
    //   block [0x821D1BE4..0x821D1C1C)
	// 821D1BE4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D1BE8: 3BAB3A7C  addi r29, r11, 0x3a7c
	ctx.r[29].s64 = ctx.r[11].s64 + 14972;
	// 821D1BEC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D1BF0: 490E7D75  bl 0x832b9964
	ctx.lr = 0x821D1BF4;
	// extern call 0x832B9964  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 821D1BF4: 807E00A4  lwz r3, 0xa4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(164 as u32) ) } as u64;
	// 821D1BF8: 817E00AC  lwz r11, 0xac(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(172 as u32) ) } as u64;
	// 821D1BFC: 38C00020  li r6, 0x20
	ctx.r[6].s64 = 32;
	// 821D1C00: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821D1C04: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821D1C08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821D1C0C: 4E800421  bctrl
	ctx.lr = 0x821D1C10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D1C10: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821D1C14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D1C18: 490E7D3D  bl 0x832b9954
	ctx.lr = 0x821D1C1C;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
            }
            0x821D1C1C => {
    //   block [0x821D1C1C..0x821D1C24)
	// 821D1C1C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821D1C20: 409A0010  bne cr6, 0x821d1c30
	if !ctx.cr[6].eq {
	pc = 0x821D1C30; continue 'dispatch;
	}
	pc = 0x821D1C24; continue 'dispatch;
            }
            0x821D1C24 => {
    //   block [0x821D1C24..0x821D1C30)
	// 821D1C24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D1C28: 489D0921  bl 0x82ba2548
	ctx.lr = 0x821D1C2C;
	sub_82BA2548(ctx, base);
	// 821D1C2C: 48000038  b 0x821d1c64
	pc = 0x821D1C64; continue 'dispatch;
            }
            0x821D1C30 => {
    //   block [0x821D1C30..0x821D1C64)
	// 821D1C30: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D1C34: 397EFFFC  addi r11, r30, -4
	ctx.r[11].s64 = ctx.r[30].s64 + -4;
	// 821D1C38: 93DF3A50  stw r30, 0x3a50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(14928 as u32), ctx.r[30].u32 ) };
	// 821D1C3C: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D1C40: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 821D1C44: 939F3A44  stw r28, 0x3a44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(14916 as u32), ctx.r[28].u32 ) };
	// 821D1C48: 394AFFF2  addi r10, r10, -0xe
	ctx.r[10].s64 = ctx.r[10].s64 + -14;
	// 821D1C4C: 939F3A54  stw r28, 0x3a54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(14932 as u32), ctx.r[28].u32 ) };
	// 821D1C50: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D1C54: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D1C58: 394BFF60  addi r10, r11, -0xa0
	ctx.r[10].s64 = ctx.r[11].s64 + -160;
	// 821D1C5C: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 821D1C60: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	pc = 0x821D1C64; continue 'dispatch;
            }
            0x821D1C64 => {
    //   block [0x821D1C64..0x821D1C90)
	// 821D1C64: 817F5DAC  lwz r11, 0x5dac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(23980 as u32) ) } as u64;
	// 821D1C68: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D1C6C: 40820024  bne 0x821d1c90
	if !ctx.cr[0].eq {
	pc = 0x821D1C90; continue 'dispatch;
	}
	// 821D1C70: 809F3A5C  lwz r4, 0x3a5c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(14940 as u32) ) } as u64;
	// 821D1C74: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821D1C78: 419A0018  beq cr6, 0x821d1c90
	if ctx.cr[6].eq {
	pc = 0x821D1C90; continue 'dispatch;
	}
	// 821D1C7C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821D1C80: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 821D1C84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D1C88: 480709E1  bl 0x82242668
	ctx.lr = 0x821D1C8C;
	sub_82242668(ctx, base);
	// 821D1C8C: 939F3A5C  stw r28, 0x3a5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(14940 as u32), ctx.r[28].u32 ) };
	pc = 0x821D1C90; continue 'dispatch;
            }
            0x821D1C90 => {
    //   block [0x821D1C90..0x821D1C94)
	// 821D1C90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x821D1C94; continue 'dispatch;
            }
            0x821D1C94 => {
    //   block [0x821D1C94..0x821D1C9C)
	// 821D1C94: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821D1C98: 48AD77C0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D1CA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D1CA0 size=820
    let mut pc: u32 = 0x821D1CA0;
    'dispatch: loop {
        match pc {
            0x821D1CA0 => {
    //   block [0x821D1CA0..0x821D1D14)
	// 821D1CA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D1CA4: 48AD7759  bl 0x82ca93fc
	ctx.lr = 0x821D1CA8;
	sub_82CA93D0(ctx, base);
	// 821D1CA8: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 821D1CAC: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D1CB0: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 821D1CB4: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 821D1CB8: 3CC08349  lis r6, -0x7cb7
	ctx.r[6].s64 = -2092367872;
	// 821D1CBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821D1CC0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821D1CC4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821D1CC8: 91686E88  stw r11, 0x6e88(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(28296 as u32), ctx.r[11].u32 ) };
	// 821D1CCC: 91476E8C  stw r10, 0x6e8c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(28300 as u32), ctx.r[10].u32 ) };
	// 821D1CD0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821D1CD4: 91266E90  stw r9, 0x6e90(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(28304 as u32), ctx.r[9].u32 ) };
	// 821D1CD8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821D1CDC: 3BEB4D60  addi r31, r11, 0x4d60
	ctx.r[31].s64 = ctx.r[11].s64 + 19808;
	// 821D1CE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821D1CE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D1CE8: 48003941  bl 0x821d5628
	ctx.lr = 0x821D1CEC;
	sub_821D5628(ctx, base);
	// 821D1CEC: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 821D1CF0: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D1CF4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821D1CF8: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D1CFC: 7CAB5050  subf r5, r11, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D1D00: C81B6E18  lfd f0, 0x6e18(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(28184 as u32) ) };
	// 821D1D04: 7CA41671  srawi. r4, r5, 2
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[5].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821D1D08: FFE00018  frsp f31, f0
	ctx.f[31].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821D1D0C: 41820048  beq 0x821d1d54
	if ctx.cr[0].eq {
	pc = 0x821D1D54; continue 'dispatch;
	}
	// 821D1D10: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x821D1D14; continue 'dispatch;
            }
            0x821D1D14 => {
    //   block [0x821D1D14..0x821D1D54)
	// 821D1D14: 7C7C582E  lwzx r3, r28, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821D1D18: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821D1D1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821D1D20: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D1D24: 814B0064  lwz r10, 0x64(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 821D1D28: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D1D2C: 4E800421  bctrl
	ctx.lr = 0x821D1D30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D1D30: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D1D34: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D1D38: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821D1D3C: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 821D1D40: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D1D44: 7D281670  srawi r8, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 821D1D48: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821D1D4C: 4198FFC8  blt cr6, 0x821d1d14
	if ctx.cr[6].lt {
	pc = 0x821D1D14; continue 'dispatch;
	}
	// 821D1D50: C81B6E18  lfd f0, 0x6e18(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(28184 as u32) ) };
            }
            0x821D1D54 => {
    //   block [0x821D1D54..0x821D1D74)
	// 821D1D54: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D1D58: FFE00018  frsp f31, f0
	ctx.f[31].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821D1D5C: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821D1D60: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821D1D64: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D1D68: 7D491671  srawi. r9, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821D1D6C: 41820044  beq 0x821d1db0
	if ctx.cr[0].eq {
	pc = 0x821D1DB0; continue 'dispatch;
	}
	// 821D1D70: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x821D1D74; continue 'dispatch;
            }
            0x821D1D74 => {
    //   block [0x821D1D74..0x821D1DB0)
	// 821D1D74: 7C7C582E  lwzx r3, r28, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821D1D78: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821D1D7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821D1D80: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D1D84: 814B0064  lwz r10, 0x64(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 821D1D88: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D1D8C: 4E800421  bctrl
	ctx.lr = 0x821D1D90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D1D90: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D1D94: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821D1D98: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821D1D9C: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 821D1DA0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D1DA4: 7D281670  srawi r8, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 821D1DA8: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821D1DAC: 4198FFC8  blt cr6, 0x821d1d74
	if ctx.cr[6].lt {
	pc = 0x821D1D74; continue 'dispatch;
	}
            }
            0x821D1DB0 => {
    //   block [0x821D1DB0..0x821D1FD4)
	// 821D1DB0: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821D1DB4: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 821D1DB8: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 821D1DBC: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D1DC0: 394B0010  addi r10, r11, 0x10
	ctx.r[10].s64 = ctx.r[11].s64 + 16;
	// 821D1DC4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D1DC8: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 821D1DCC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821D1DD0: 3CA0820A  lis r5, -0x7df6
	ctx.r[5].s64 = -2113273856;
	// 821D1DD4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D1FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D1FD8 size=568
    let mut pc: u32 = 0x821D1FD8;
    'dispatch: loop {
        match pc {
            0x821D1FD8 => {
    //   block [0x821D1FD8..0x821D2210)
	// 821D1FD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D1FDC: 48AD7431  bl 0x82ca940c
	ctx.lr = 0x821D1FE0;
	sub_82CA93D0(ctx, base);
	// 821D1FE0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 821D1FE4: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D2210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D2210 size=84
    let mut pc: u32 = 0x821D2210;
    'dispatch: loop {
        match pc {
            0x821D2210 => {
    //   block [0x821D2210..0x821D2264)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D2268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D2268 size=312
    let mut pc: u32 = 0x821D2268;
    'dispatch: loop {
        match pc {
            0x821D2268 => {
    //   block [0x821D2268..0x821D23A0)
	// 821D2268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D226C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D2270: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D2274: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D23A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D23A0 size=432
    let mut pc: u32 = 0x821D23A0;
    'dispatch: loop {
        match pc {
            0x821D23A0 => {
    //   block [0x821D23A0..0x821D2550)
	// 821D23A0: 3961FF60  addi r11, r1, -0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + -160;
	// 821D23A4: 3941FFB0  addi r10, r1, -0x50
	ctx.r[10].s64 = ctx.r[1].s64 + -80;
	// 821D23A8: 3921FFD0  addi r9, r1, -0x30
	ctx.r[9].s64 = ctx.r[1].s64 + -48;
	// 821D23AC: 3901FFF0  addi r8, r1, -0x10
	ctx.r[8].s64 = ctx.r[1].s64 + -16;
	// 821D23B0: 38E1FF00  addi r7, r1, -0x100
	ctx.r[7].s64 = ctx.r[1].s64 + -256;
	// 821D23B4: 38C1FF80  addi r6, r1, -0x80
	ctx.r[6].s64 = ctx.r[1].s64 + -128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D2550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D2550 size=376
    let mut pc: u32 = 0x821D2550;
    'dispatch: loop {
        match pc {
            0x821D2550 => {
    //   block [0x821D2550..0x821D2578)
	// 821D2550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D2554: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D2558: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821D255C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D2560: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D2564: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D2568: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821D256C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2570: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D2574: 409A000C  bne cr6, 0x821d2580
	if !ctx.cr[6].eq {
	pc = 0x821D2580; continue 'dispatch;
	}
	pc = 0x821D2578; continue 'dispatch;
            }
            0x821D2578 => {
    //   block [0x821D2578..0x821D2580)
	// 821D2578: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821D257C: 48000134  b 0x821d26b0
	pc = 0x821D26B0; continue 'dispatch;
            }
            0x821D2580 => {
    //   block [0x821D2580..0x821D25B0)
	// 821D2580: 817E0028  lwz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D2584: 556A2FFE  rlwinm r10, r11, 5, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x07FFFFFFu64;
	// 821D2588: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D258C: 419A0078  beq cr6, 0x821d2604
	if ctx.cr[6].eq {
	pc = 0x821D2604; continue 'dispatch;
	}
	// 821D2590: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D2594: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D2598: 409A0064  bne cr6, 0x821d25fc
	if !ctx.cr[6].eq {
	pc = 0x821D25FC; continue 'dispatch;
	}
	// 821D259C: 817E004C  lwz r11, 0x4c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D25A0: 815E0048  lwz r10, 0x48(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D25A4: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821D25A8: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D25AC: 40810050  ble 0x821d25fc
	if !ctx.cr[0].gt {
	pc = 0x821D25FC; continue 'dispatch;
	}
	pc = 0x821D25B0; continue 'dispatch;
            }
            0x821D25B0 => {
    //   block [0x821D25B0..0x821D25D0)
	// 821D25B0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821D25B4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D25B8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821D25BC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D25C0: 2F07003B  cmpwi cr6, r7, 0x3b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 59, &mut ctx.xer);
	// 821D25C4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D25C8: 41980008  blt cr6, 0x821d25d0
	if ctx.cr[6].lt {
	pc = 0x821D25D0; continue 'dispatch;
	}
	// 821D25CC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x821D25D0; continue 'dispatch;
            }
            0x821D25D0 => {
    //   block [0x821D25D0..0x821D25EC)
	// 821D25D0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821D25D4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D25D8: 419A0014  beq cr6, 0x821d25ec
	if ctx.cr[6].eq {
	pc = 0x821D25EC; continue 'dispatch;
	}
	// 821D25DC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821D25E0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D25E4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D25E8: 4800000C  b 0x821d25f4
	pc = 0x821D25F4; continue 'dispatch;
            }
            0x821D25EC => {
    //   block [0x821D25EC..0x821D25F4)
	// 821D25EC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821D25F0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821D25F4; continue 'dispatch;
            }
            0x821D25F4 => {
    //   block [0x821D25F4..0x821D25FC)
	// 821D25F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D25F8: 4199FFB8  bgt cr6, 0x821d25b0
	if ctx.cr[6].gt {
	pc = 0x821D25B0; continue 'dispatch;
	}
	pc = 0x821D25FC; continue 'dispatch;
            }
            0x821D25FC => {
    //   block [0x821D25FC..0x821D2604)
	// 821D25FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D2600: 48000008  b 0x821d2608
	pc = 0x821D2608; continue 'dispatch;
            }
            0x821D2604 => {
    //   block [0x821D2604..0x821D2608)
	// 821D2604: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821D2608; continue 'dispatch;
            }
            0x821D2608 => {
    //   block [0x821D2608..0x821D26B0)
	// 821D2608: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D260C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D2610: 419AFF68  beq cr6, 0x821d2578
	if ctx.cr[6].eq {
	pc = 0x821D2578; continue 'dispatch;
	}
	// 821D2614: 809E007C  lwz r4, 0x7c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 821D2618: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D261C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2620: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821D2624: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D2628: 4E800421  bctrl
	ctx.lr = 0x821D262C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D262C: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 821D2630: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 821D2634: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 821D2638: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
            }
            0x821D26B0 => {
    //   block [0x821D26B0..0x821D26C8)
	// 821D26B0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821D26B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D26B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D26BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821D26C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D26C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D26C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D26C8 size=332
    let mut pc: u32 = 0x821D26C8;
    'dispatch: loop {
        match pc {
            0x821D26C8 => {
    //   block [0x821D26C8..0x821D26FC)
	// 821D26C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D26CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D26D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821D26D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D26D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D26DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D26E0: 3BDF0078  addi r30, r31, 0x78
	ctx.r[30].s64 = ctx.r[31].s64 + 120;
	// 821D26E4: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 821D26E8: 815F0078  lwz r10, 0x78(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 821D26EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D26F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821D26F4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821D26F8: 419A0020  beq cr6, 0x821d2718
	if ctx.cr[6].eq {
	pc = 0x821D2718; continue 'dispatch;
	}
	pc = 0x821D26FC; continue 'dispatch;
            }
            0x821D26FC => {
    //   block [0x821D26FC..0x821D2718)
	// 821D26FC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821D2700: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D2704: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821D2708: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821D270C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821D2710: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D2714: 4082FFE8  bne 0x821d26fc
	if !ctx.cr[0].eq {
	pc = 0x821D26FC; continue 'dispatch;
	}
	pc = 0x821D2718; continue 'dispatch;
            }
            0x821D2718 => {
    //   block [0x821D2718..0x821D2788)
	// 821D2718: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D271C: 48098EE5  bl 0x8226b600
	ctx.lr = 0x821D2720;
	sub_8226B600(ctx, base);
	// 821D2720: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2724: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D2728: 419A00CC  beq cr6, 0x821d27f4
	if ctx.cr[6].eq {
	pc = 0x821D27F4; continue 'dispatch;
	}
	// 821D272C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2730: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D2734: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D2738: 4E800421  bctrl
	ctx.lr = 0x821D273C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D273C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D2740: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821D2744: 419A00B0  beq cr6, 0x821d27f4
	if ctx.cr[6].eq {
	pc = 0x821D27F4; continue 'dispatch;
	}
	// 821D2748: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D274C: 480B3A5D  bl 0x822861a8
	ctx.lr = 0x821D2750;
	sub_822861A8(ctx, base);
	// 821D2750: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2754: 389F0070  addi r4, r31, 0x70
	ctx.r[4].s64 = ctx.r[31].s64 + 112;
	// 821D2758: 815F0070  lwz r10, 0x70(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 821D275C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821D2760: 419A0084  beq cr6, 0x821d27e4
	if ctx.cr[6].eq {
	pc = 0x821D27E4; continue 'dispatch;
	}
	// 821D2764: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 821D2768: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D276C: 419A0058  beq cr6, 0x821d27c4
	if ctx.cr[6].eq {
	pc = 0x821D27C4; continue 'dispatch;
	}
	// 821D2770: 815F0058  lwz r10, 0x58(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 821D2774: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821D2778: 419A0010  beq cr6, 0x821d2788
	if ctx.cr[6].eq {
	pc = 0x821D2788; continue 'dispatch;
	}
	// 821D277C: 813F0054  lwz r9, 0x54(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D2780: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821D2784: 40980040  bge cr6, 0x821d27c4
	if !ctx.cr[6].lt {
	pc = 0x821D27C4; continue 'dispatch;
	}
            }
            0x821D2788 => {
    //   block [0x821D2788..0x821D27C4)
	// 821D2788: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D278C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 821D2790: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821D2794: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D2798: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821D279C: 4E800421  bctrl
	ctx.lr = 0x821D27A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D27A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D27A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D27A8: 4BFA8BF1  bl 0x8217b398
	ctx.lr = 0x821D27AC;
	sub_8217B398(ctx, base);
	// 821D27AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821D27B0: 4BFE5369  bl 0x821b7b18
	ctx.lr = 0x821D27B4;
	sub_821B7B18(ctx, base);
	// 821D27B4: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D27B8: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 821D27BC: 911F0054  stw r8, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 821D27C0: 4800000C  b 0x821d27cc
	pc = 0x821D27CC; continue 'dispatch;
            }
            0x821D27C4 => {
    //   block [0x821D27C4..0x821D27CC)
	// 821D27C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D27C8: 4BFA8BD1  bl 0x8217b398
	ctx.lr = 0x821D27CC;
	sub_8217B398(ctx, base);
	pc = 0x821D27CC; continue 'dispatch;
            }
            0x821D27CC => {
    //   block [0x821D27CC..0x821D27E4)
	// 821D27CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D27D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D27D4: 814B0050  lwz r10, 0x50(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D27D8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D27DC: 4E800421  bctrl
	ctx.lr = 0x821D27E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D27E0: 48000014  b 0x821d27f4
	pc = 0x821D27F4; continue 'dispatch;
            }
            0x821D27E4 => {
    //   block [0x821D27E4..0x821D27F4)
	// 821D27E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D27E8: 4BFE5331  bl 0x821b7b18
	ctx.lr = 0x821D27EC;
	sub_821B7B18(ctx, base);
	// 821D27EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821D27F0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x821D27F4; continue 'dispatch;
            }
            0x821D27F4 => {
    //   block [0x821D27F4..0x821D2814)
	// 821D27F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D27F8: 4BFE5321  bl 0x821b7b18
	ctx.lr = 0x821D27FC;
	sub_821B7B18(ctx, base);
	// 821D27FC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821D2800: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D2804: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D2808: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821D280C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D2810: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D2818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D2818 size=292
    let mut pc: u32 = 0x821D2818;
    'dispatch: loop {
        match pc {
            0x821D2818 => {
    //   block [0x821D2818..0x821D284C)
	// 821D2818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D281C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D2820: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D2824: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821D2828: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 821D282C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821D2830: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 821D2834: 81250018  lwz r9, 0x18(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D2838: 80C5001C  lwz r6, 0x1c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D283C: 7D493050  subf r10, r9, r6
	ctx.r[10].s64 = ctx.r[6].s64 - ctx.r[9].s64;
	// 821D2840: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821D2844: 7D6A5BD7  divw. r11, r10, r11
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[11].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D2848: 4081005C  ble 0x821d28a4
	if !ctx.cr[0].gt {
	pc = 0x821D28A4; continue 'dispatch;
	}
	pc = 0x821D284C; continue 'dispatch;
            }
            0x821D284C => {
    //   block [0x821D284C..0x821D2874)
	// 821D284C: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821D2850: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D2854: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821D2858: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D285C: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821D2860: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2864: 2F070001  cmpwi cr6, r7, 1
	ctx.cr[6].compare_i32(ctx.r[7].s32, 1, &mut ctx.xer);
	// 821D2868: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D286C: 41980008  blt cr6, 0x821d2874
	if ctx.cr[6].lt {
	pc = 0x821D2874; continue 'dispatch;
	}
	// 821D2870: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x821D2874; continue 'dispatch;
            }
            0x821D2874 => {
    //   block [0x821D2874..0x821D2890)
	// 821D2874: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821D2878: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D287C: 419A0014  beq cr6, 0x821d2890
	if ctx.cr[6].eq {
	pc = 0x821D2890; continue 'dispatch;
	}
	// 821D2880: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821D2884: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 821D2888: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D288C: 4800000C  b 0x821d2898
	pc = 0x821D2898; continue 'dispatch;
            }
            0x821D2890 => {
    //   block [0x821D2890..0x821D2898)
	// 821D2890: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821D2894: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x821D2898; continue 'dispatch;
            }
            0x821D2898 => {
    //   block [0x821D2898..0x821D28A4)
	// 821D2898: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D289C: 4199FFB0  bgt cr6, 0x821d284c
	if ctx.cr[6].gt {
	pc = 0x821D284C; continue 'dispatch;
	}
	// 821D28A0: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	pc = 0x821D28A4; continue 'dispatch;
            }
            0x821D28A4 => {
    //   block [0x821D28A4..0x821D28C0)
	// 821D28A4: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821D28A8: 419A0034  beq cr6, 0x821d28dc
	if ctx.cr[6].eq {
	pc = 0x821D28DC; continue 'dispatch;
	}
	// 821D28AC: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D28B0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821D28B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D28B8: 41990008  bgt cr6, 0x821d28c0
	if ctx.cr[6].gt {
	pc = 0x821D28C0; continue 'dispatch;
	}
	// 821D28BC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x821D28C0; continue 'dispatch;
            }
            0x821D28C0 => {
    //   block [0x821D28C0..0x821D28DC)
	// 821D28C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D28C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D28C8: 409A0014  bne cr6, 0x821d28dc
	if !ctx.cr[6].eq {
	pc = 0x821D28DC; continue 'dispatch;
	}
	// 821D28CC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D28D0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821D28D4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D28D8: 48000008  b 0x821d28e0
	pc = 0x821D28E0; continue 'dispatch;
            }
            0x821D28DC => {
    //   block [0x821D28DC..0x821D28E0)
	// 821D28DC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x821D28E0; continue 'dispatch;
            }
            0x821D28E0 => {
    //   block [0x821D28E0..0x821D28F8)
	// 821D28E0: 8145001C  lwz r10, 0x1c(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D28E4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D28E8: 419A0010  beq cr6, 0x821d28f8
	if ctx.cr[6].eq {
	pc = 0x821D28F8; continue 'dispatch;
	}
	// 821D28EC: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D28F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D28F4: 48000008  b 0x821d28fc
	pc = 0x821D28FC; continue 'dispatch;
            }
            0x821D28F8 => {
    //   block [0x821D28F8..0x821D28FC)
	// 821D28F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x821D28FC; continue 'dispatch;
            }
            0x821D28FC => {
    //   block [0x821D28FC..0x821D2928)
	// 821D28FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D2900: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D2904: 419A0024  beq cr6, 0x821d2928
	if ctx.cr[6].eq {
	pc = 0x821D2928; continue 'dispatch;
	}
	// 821D2908: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D290C: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D2910: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D2914: 4E800421  bctrl
	ctx.lr = 0x821D2918;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D2918: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821D291C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D2920: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D2924: 4E800020  blr
	return;
            }
            0x821D2928 => {
    //   block [0x821D2928..0x821D293C)
	// 821D2928: 88650049  lbz r3, 0x49(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(73 as u32) ) } as u64;
	// 821D292C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821D2930: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D2934: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D2938: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D2940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D2940 size=756
    let mut pc: u32 = 0x821D2940;
    'dispatch: loop {
        match pc {
            0x821D2940 => {
    //   block [0x821D2940..0x821D29C0)
	// 821D2940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D2944: 48AD6AC5  bl 0x82ca9408
	ctx.lr = 0x821D2948;
	sub_82CA93D0(ctx, base);
	// 821D2948: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D294C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821D2950: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821D2954: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821D2958: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D295C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D2960: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821D2964: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D2968: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D296C: 4805FE0D  bl 0x82232778
	ctx.lr = 0x821D2970;
	sub_82232778(ctx, base);
	// 821D2970: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D2974: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D2978: 419A02B0  beq cr6, 0x821d2c28
	if ctx.cr[6].eq {
	pc = 0x821D2C28; continue 'dispatch;
	}
	// 821D297C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D2980: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821D2984: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 821D2988: 894B0024  lbz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821D298C: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 821D2990: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821D2994: 419A00E8  beq cr6, 0x821d2a7c
	if ctx.cr[6].eq {
	pc = 0x821D2A7C; continue 'dispatch;
	}
	// 821D2998: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D299C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D29A0: 419A0020  beq cr6, 0x821d29c0
	if ctx.cr[6].eq {
	pc = 0x821D29C0; continue 'dispatch;
	}
	// 821D29A4: 894A0018  lbz r10, 0x18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D29A8: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D29AC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821D29B0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D29B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D29B8: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D29BC: 480000C4  b 0x821d2a80
	pc = 0x821D2A80; continue 'dispatch;
            }
            0x821D29C0 => {
    //   block [0x821D29C0..0x821D29DC)
	// 821D29C0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D29C4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D29C8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821D29CC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821D29D0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D29D4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D29D8: 40810054  ble 0x821d2a2c
	if !ctx.cr[0].gt {
	pc = 0x821D2A2C; continue 'dispatch;
	}
	pc = 0x821D29DC; continue 'dispatch;
            }
            0x821D29DC => {
    //   block [0x821D29DC..0x821D29FC)
	// 821D29DC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821D29E0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D29E4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821D29E8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D29EC: 2F070018  cmpwi cr6, r7, 0x18
	ctx.cr[6].compare_i32(ctx.r[7].s32, 24, &mut ctx.xer);
	// 821D29F0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D29F4: 41980008  blt cr6, 0x821d29fc
	if ctx.cr[6].lt {
	pc = 0x821D29FC; continue 'dispatch;
	}
	// 821D29F8: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x821D29FC; continue 'dispatch;
            }
            0x821D29FC => {
    //   block [0x821D29FC..0x821D2A18)
	// 821D29FC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821D2A00: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D2A04: 419A0014  beq cr6, 0x821d2a18
	if ctx.cr[6].eq {
	pc = 0x821D2A18; continue 'dispatch;
	}
	// 821D2A08: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821D2A0C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D2A10: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D2A14: 4800000C  b 0x821d2a20
	pc = 0x821D2A20; continue 'dispatch;
            }
            0x821D2A18 => {
    //   block [0x821D2A18..0x821D2A20)
	// 821D2A18: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821D2A1C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821D2A20; continue 'dispatch;
            }
            0x821D2A20 => {
    //   block [0x821D2A20..0x821D2A2C)
	// 821D2A20: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D2A24: 4199FFB8  bgt cr6, 0x821d29dc
	if ctx.cr[6].gt {
	pc = 0x821D29DC; continue 'dispatch;
	}
	// 821D2A28: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821D2A2C; continue 'dispatch;
            }
            0x821D2A2C => {
    //   block [0x821D2A2C..0x821D2A48)
	// 821D2A2C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821D2A30: 419A003C  beq cr6, 0x821d2a6c
	if ctx.cr[6].eq {
	pc = 0x821D2A6C; continue 'dispatch;
	}
	// 821D2A34: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2A38: 2F0B0018  cmpwi cr6, r11, 0x18
	ctx.cr[6].compare_i32(ctx.r[11].s32, 24, &mut ctx.xer);
	// 821D2A3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D2A40: 41990008  bgt cr6, 0x821d2a48
	if ctx.cr[6].gt {
	pc = 0x821D2A48; continue 'dispatch;
	}
	// 821D2A44: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821D2A48; continue 'dispatch;
            }
            0x821D2A48 => {
    //   block [0x821D2A48..0x821D2A6C)
	// 821D2A48: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D2A4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D2A50: 409A001C  bne cr6, 0x821d2a6c
	if !ctx.cr[6].eq {
	pc = 0x821D2A6C; continue 'dispatch;
	}
	// 821D2A54: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D2A58: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821D2A5C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D2A60: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D2A64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D2A68: 48000018  b 0x821d2a80
	pc = 0x821D2A80; continue 'dispatch;
            }
            0x821D2A6C => {
    //   block [0x821D2A6C..0x821D2A7C)
	// 821D2A6C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821D2A70: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D2A74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D2A78: 48000008  b 0x821d2a80
	pc = 0x821D2A80; continue 'dispatch;
            }
            0x821D2A7C => {
    //   block [0x821D2A7C..0x821D2A80)
	// 821D2A7C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821D2A80; continue 'dispatch;
            }
            0x821D2A80 => {
    //   block [0x821D2A80..0x821D2AE0)
	// 821D2A80: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D2A84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D2A88: 419A0194  beq cr6, 0x821d2c1c
	if ctx.cr[6].eq {
	pc = 0x821D2C1C; continue 'dispatch;
	}
	// 821D2A8C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821D2A90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D2A94: 3BCBB780  addi r30, r11, -0x4880
	ctx.r[30].s64 = ctx.r[11].s64 + -18560;
	// 821D2A98: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821D2A9C: 4809ED35  bl 0x822717d0
	ctx.lr = 0x821D2AA0;
	sub_822717D0(ctx, base);
	// 821D2AA0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D2AA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D2AA8: 419A0174  beq cr6, 0x821d2c1c
	if ctx.cr[6].eq {
	pc = 0x821D2C1C; continue 'dispatch;
	}
	// 821D2AAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D2AB0: 481DDF89  bl 0x823b0a38
	ctx.lr = 0x821D2AB4;
	sub_823B0A38(ctx, base);
	// 821D2AB4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D2AB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D2ABC: 48328A2D  bl 0x824fb4e8
	ctx.lr = 0x821D2AC0;
	sub_824FB4E8(ctx, base);
	// 821D2AC0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D2AC4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821D2AC8: 419A0018  beq cr6, 0x821d2ae0
	if ctx.cr[6].eq {
	pc = 0x821D2AE0; continue 'dispatch;
	}
	// 821D2ACC: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 821D2AD0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821D2AD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D2AD8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D2ADC: 409A0008  bne cr6, 0x821d2ae4
	if !ctx.cr[6].eq {
	pc = 0x821D2AE4; continue 'dispatch;
	}
	pc = 0x821D2AE0; continue 'dispatch;
            }
            0x821D2AE0 => {
    //   block [0x821D2AE0..0x821D2AE4)
	// 821D2AE0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821D2AE4; continue 'dispatch;
            }
            0x821D2AE4 => {
    //   block [0x821D2AE4..0x821D2B34)
	// 821D2AE4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D2AE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D2AEC: 419A0130  beq cr6, 0x821d2c1c
	if ctx.cr[6].eq {
	pc = 0x821D2C1C; continue 'dispatch;
	}
	// 821D2AF0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D2AF4: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 821D2AF8: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D2AFC: 55283FFE  rlwinm r8, r9, 7, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x01FFFFFFu64;
	// 821D2B00: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821D2B04: 419A00F4  beq cr6, 0x821d2bf8
	if ctx.cr[6].eq {
	pc = 0x821D2BF8; continue 'dispatch;
	}
	// 821D2B08: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D2B0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D2B10: 419A0024  beq cr6, 0x821d2b34
	if ctx.cr[6].eq {
	pc = 0x821D2B34; continue 'dispatch;
	}
	// 821D2B14: 892A0039  lbz r9, 0x39(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(57 as u32) ) } as u64;
	// 821D2B18: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D2B1C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 821D2B20: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821D2B24: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D2B28: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821D2B2C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D2B30: 480000CC  b 0x821d2bfc
	pc = 0x821D2BFC; continue 'dispatch;
            }
            0x821D2B34 => {
    //   block [0x821D2B34..0x821D2B50)
	// 821D2B34: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D2B38: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D2B3C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821D2B40: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821D2B44: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D2B48: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D2B4C: 40810054  ble 0x821d2ba0
	if !ctx.cr[0].gt {
	pc = 0x821D2BA0; continue 'dispatch;
	}
	pc = 0x821D2B50; continue 'dispatch;
            }
            0x821D2B50 => {
    //   block [0x821D2B50..0x821D2B70)
	// 821D2B50: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821D2B54: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D2B58: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821D2B5C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2B60: 2F070039  cmpwi cr6, r7, 0x39
	ctx.cr[6].compare_i32(ctx.r[7].s32, 57, &mut ctx.xer);
	// 821D2B64: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D2B68: 41980008  blt cr6, 0x821d2b70
	if ctx.cr[6].lt {
	pc = 0x821D2B70; continue 'dispatch;
	}
	// 821D2B6C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x821D2B70; continue 'dispatch;
            }
            0x821D2B70 => {
    //   block [0x821D2B70..0x821D2B8C)
	// 821D2B70: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821D2B74: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D2B78: 419A0014  beq cr6, 0x821d2b8c
	if ctx.cr[6].eq {
	pc = 0x821D2B8C; continue 'dispatch;
	}
	// 821D2B7C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821D2B80: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D2B84: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D2B88: 4800000C  b 0x821d2b94
	pc = 0x821D2B94; continue 'dispatch;
            }
            0x821D2B8C => {
    //   block [0x821D2B8C..0x821D2B94)
	// 821D2B8C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821D2B90: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821D2B94; continue 'dispatch;
            }
            0x821D2B94 => {
    //   block [0x821D2B94..0x821D2BA0)
	// 821D2B94: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D2B98: 4199FFB8  bgt cr6, 0x821d2b50
	if ctx.cr[6].gt {
	pc = 0x821D2B50; continue 'dispatch;
	}
	// 821D2B9C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821D2BA0; continue 'dispatch;
            }
            0x821D2BA0 => {
    //   block [0x821D2BA0..0x821D2BBC)
	// 821D2BA0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821D2BA4: 419A0040  beq cr6, 0x821d2be4
	if ctx.cr[6].eq {
	pc = 0x821D2BE4; continue 'dispatch;
	}
	// 821D2BA8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2BAC: 2F0B0039  cmpwi cr6, r11, 0x39
	ctx.cr[6].compare_i32(ctx.r[11].s32, 57, &mut ctx.xer);
	// 821D2BB0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D2BB4: 41990008  bgt cr6, 0x821d2bbc
	if ctx.cr[6].gt {
	pc = 0x821D2BBC; continue 'dispatch;
	}
	// 821D2BB8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821D2BBC; continue 'dispatch;
            }
            0x821D2BBC => {
    //   block [0x821D2BBC..0x821D2BE4)
	// 821D2BBC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D2BC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D2BC4: 409A0020  bne cr6, 0x821d2be4
	if !ctx.cr[6].eq {
	pc = 0x821D2BE4; continue 'dispatch;
	}
	// 821D2BC8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D2BCC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821D2BD0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D2BD4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D2BD8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821D2BDC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D2BE0: 4800001C  b 0x821d2bfc
	pc = 0x821D2BFC; continue 'dispatch;
            }
            0x821D2BE4 => {
    //   block [0x821D2BE4..0x821D2BF8)
	// 821D2BE4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821D2BE8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D2BEC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821D2BF0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D2BF4: 48000008  b 0x821d2bfc
	pc = 0x821D2BFC; continue 'dispatch;
            }
            0x821D2BF8 => {
    //   block [0x821D2BF8..0x821D2BFC)
	// 821D2BF8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821D2BFC; continue 'dispatch;
            }
            0x821D2BFC => {
    //   block [0x821D2BFC..0x821D2C1C)
	// 821D2BFC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D2C00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D2C04: 419A0018  beq cr6, 0x821d2c1c
	if ctx.cr[6].eq {
	pc = 0x821D2C1C; continue 'dispatch;
	}
	// 821D2C08: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 821D2C0C: 483128A5  bl 0x824e54b0
	ctx.lr = 0x821D2C10;
	sub_824E54B0(ctx, base);
	// 821D2C10: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D2C14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D2C18: 419A0010  beq cr6, 0x821d2c28
	if ctx.cr[6].eq {
	pc = 0x821D2C28; continue 'dispatch;
	}
	pc = 0x821D2C1C; continue 'dispatch;
            }
            0x821D2C1C => {
    //   block [0x821D2C1C..0x821D2C28)
	// 821D2C1C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821D2C20: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821D2C24: 48AD6834  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x821D2C28 => {
    //   block [0x821D2C28..0x821D2C34)
	// 821D2C28: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821D2C2C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821D2C30: 48AD6828  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D2C38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D2C38 size=460
    let mut pc: u32 = 0x821D2C38;
    'dispatch: loop {
        match pc {
            0x821D2C38 => {
    //   block [0x821D2C38..0x821D2E04)
	// 821D2C38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D2C3C: 48AD67BD  bl 0x82ca93f8
	ctx.lr = 0x821D2C40;
	sub_82CA93D0(ctx, base);
	// 821D2C40: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D2E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D2E08 size=168
    let mut pc: u32 = 0x821D2E08;
    'dispatch: loop {
        match pc {
            0x821D2E08 => {
    //   block [0x821D2E08..0x821D2E3C)
	// 821D2E08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D2E0C: 48AD65F9  bl 0x82ca9404
	ctx.lr = 0x821D2E10;
	sub_82CA93D0(ctx, base);
	// 821D2E10: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D2E14: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821D2E18: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821D2E1C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821D2E20: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 821D2E24: 817E0028  lwz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D2E28: 83FE0020  lwz r31, 0x20(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 821D2E2C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D2E30: 7D4BFA14  add r10, r11, r31
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821D2E34: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D2E38: 419A0070  beq cr6, 0x821d2ea8
	if ctx.cr[6].eq {
	pc = 0x821D2EA8; continue 'dispatch;
	}
	pc = 0x821D2E3C; continue 'dispatch;
            }
            0x821D2E3C => {
    //   block [0x821D2E3C..0x821D2E8C)
	// 821D2E3C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2E40: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 821D2E44: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2E48: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D2E4C: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D2E50: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D2E54: 4E800421  bctrl
	ctx.lr = 0x821D2E58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D2E58: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D2E5C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821D2E60: 419A002C  beq cr6, 0x821d2e8c
	if ctx.cr[6].eq {
	pc = 0x821D2E8C; continue 'dispatch;
	}
	// 821D2E64: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2E68: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D2E6C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2E70: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D2E74: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D2E78: 4E800421  bctrl
	ctx.lr = 0x821D2E7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D2E7C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D2E80: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821D2E84: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821D2E88: 4800EB59  bl 0x821e19e0
	ctx.lr = 0x821D2E8C;
	sub_821E19E0(ctx, base);
            }
            0x821D2E8C => {
    //   block [0x821D2E8C..0x821D2EA8)
	// 821D2E8C: 817E0028  lwz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D2E90: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 821D2E94: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 821D2E98: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D2E9C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821D2EA0: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D2EA4: 409AFF98  bne cr6, 0x821d2e3c
	if !ctx.cr[6].eq {
	pc = 0x821D2E3C; continue 'dispatch;
	}
	pc = 0x821D2EA8; continue 'dispatch;
            }
            0x821D2EA8 => {
    //   block [0x821D2EA8..0x821D2EB0)
	// 821D2EA8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821D2EAC: 48AD65A8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D2EB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D2EB0 size=24
    let mut pc: u32 = 0x821D2EB0;
    'dispatch: loop {
        match pc {
            0x821D2EB0 => {
    //   block [0x821D2EB0..0x821D2EC8)
	// 821D2EB0: A164001C  lhz r11, 0x1c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D2EB4: 7D6A2838  and r10, r11, r5
	ctx.r[10].u64 = ctx.r[11].u64 & ctx.r[5].u64;
	// 821D2EB8: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 821D2EBC: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 821D2EC0: 69030001  xori r3, r8, 1
	ctx.r[3].u64 = ctx.r[8].u64 ^ 1;
	// 821D2EC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D2EC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D2EC8 size=624
    let mut pc: u32 = 0x821D2EC8;
    'dispatch: loop {
        match pc {
            0x821D2EC8 => {
    //   block [0x821D2EC8..0x821D2F20)
	// 821D2EC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D2ECC: 48AD6535  bl 0x82ca9400
	ctx.lr = 0x821D2ED0;
	sub_82CA93D0(ctx, base);
	// 821D2ED0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D2ED4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821D2ED8: A17D0014  lhz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 821D2EDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D2EE0: 419A00F0  beq cr6, 0x821d2fd0
	if ctx.cr[6].eq {
	pc = 0x821D2FD0; continue 'dispatch;
	}
	// 821D2EE4: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D2EE8: 3D6082BC  lis r11, -0x7d44
	ctx.r[11].s64 = -2101608448;
	// 821D2EEC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821D2EF0: 388B9118  addi r4, r11, -0x6ee8
	ctx.r[4].s64 = ctx.r[11].s64 + -28392;
	// 821D2EF4: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D2EF8: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D2EFC: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821D2F00: 7D1E1E70  srawi r30, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 821D2F04: 480A8A65  bl 0x8227b968
	ctx.lr = 0x821D2F08;
	sub_8227B968(ctx, base);
	// 821D2F08: 80DD0010  lwz r6, 0x10(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D2F0C: 3BFD0010  addi r31, r29, 0x10
	ctx.r[31].s64 = ctx.r[29].s64 + 16;
	// 821D2F10: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821D2F14: 409A000C  bne cr6, 0x821d2f20
	if !ctx.cr[6].eq {
	pc = 0x821D2F20; continue 'dispatch;
	}
	// 821D2F18: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821D2F1C: 38CB0CA0  addi r6, r11, 0xca0
	ctx.r[6].s64 = ctx.r[11].s64 + 3232;
	pc = 0x821D2F20; continue 'dispatch;
            }
            0x821D2F20 => {
    //   block [0x821D2F20..0x821D2F24)
	// 821D2F20: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x821D2F24; continue 'dispatch;
            }
            0x821D2F24 => {
    //   block [0x821D2F24..0x821D2FAC)
	// 821D2F24: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2F28: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821D2F2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D2F30: 409AFFF4  bne cr6, 0x821d2f24
	if !ctx.cr[6].eq {
	pc = 0x821D2F24; continue 'dispatch;
	}
	// 821D2F34: 7D665850  subf r11, r6, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	// 821D2F38: 90C10050  stw r6, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u32 ) };
	// 821D2F3C: 3D4082BD  lis r10, -0x7d43
	ctx.r[10].s64 = -2101542912;
	// 821D2F40: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D2F44: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 821D2F48: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821D2F4C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821D2F50: 388AE1F8  addi r4, r10, -0x1e08
	ctx.r[4].s64 = ctx.r[10].s64 + -7688;
	// 821D2F54: 489F992D  bl 0x82bcc880
	ctx.lr = 0x821D2F58;
	sub_82BCC880(ctx, base);
	// 821D2F58: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821D2F5C: 3CC082BD  lis r6, -0x7d43
	ctx.r[6].s64 = -2101542912;
	// 821D2F60: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 821D2F64: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821D2F68: 3886C870  addi r4, r6, -0x3790
	ctx.r[4].s64 = ctx.r[6].s64 + -14224;
	// 821D2F6C: 839D0004  lwz r28, 4(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D2F70: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821D2F74: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D2F78: 813C0020  lwz r9, 0x20(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 821D2F7C: 394BFFF8  addi r10, r11, -8
	ctx.r[10].s64 = ctx.r[11].s64 + -8;
	// 821D2F80: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 821D2F84: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821D2F88: 7CC95050  subf r6, r9, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821D2F8C: 7CE95850  subf r7, r9, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821D2F90: 480ED5E1  bl 0x822c0570
	ctx.lr = 0x821D2F94;
	sub_822C0570(ctx, base);
	// 821D2F94: 815C0014  lwz r10, 0x14(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 821D2F98: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D2F9C: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D2FA0: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821D2FA4: 41980008  blt cr6, 0x821d2fac
	if ctx.cr[6].lt {
	pc = 0x821D2FAC; continue 'dispatch;
	}
	// 821D2FA8: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x821D2FAC; continue 'dispatch;
            }
            0x821D2FAC => {
    //   block [0x821D2FAC..0x821D2FD0)
	// 821D2FAC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821D2FB0: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D2FB4: 489F8D55  bl 0x82bcbd08
	ctx.lr = 0x821D2FB8;
	sub_82BCBD08(ctx, base);
	// 821D2FB8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2FBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D2FC0: 419A0010  beq cr6, 0x821d2fd0
	if ctx.cr[6].eq {
	pc = 0x821D2FD0; continue 'dispatch;
	}
	// 821D2FC4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821D2FC8: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 821D2FCC: B15F0004  sth r10, 4(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u16 ) };
	pc = 0x821D2FD0; continue 'dispatch;
            }
            0x821D2FD0 => {
    //   block [0x821D2FD0..0x821D305C)
	// 821D2FD0: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D2FD4: 489E55CD  bl 0x82bb85a0
	ctx.lr = 0x821D2FD8;
	sub_82BB85A0(ctx, base);
	// 821D2FD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D2FDC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2FE0: 814B0074  lwz r10, 0x74(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 821D2FE4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D2FE8: 4E800421  bctrl
	ctx.lr = 0x821D2FEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D2FEC: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D2FF0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821D2FF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D2FF8: 81090020  lwz r8, 0x20(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 821D2FFC: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821D3000: 4E800421  bctrl
	ctx.lr = 0x821D3004;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D3004: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D3008: 3CE08210  lis r7, -0x7df0
	ctx.r[7].s64 = -2112880640;
	// 821D300C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D3010: 38C7CF28  addi r6, r7, -0x30d8
	ctx.r[6].s64 = ctx.r[7].s64 + -12504;
	// 821D3014: 38BB00C0  addi r5, r27, 0xc0
	ctx.r[5].s64 = ctx.r[27].s64 + 192;
	// 821D3018: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D301C: 480F229D  bl 0x822c52b8
	ctx.lr = 0x821D3020;
	sub_822C52B8(ctx, base);
	// 821D3020: 3CC08210  lis r6, -0x7df0
	ctx.r[6].s64 = -2112880640;
	// 821D3024: 38BB0090  addi r5, r27, 0x90
	ctx.r[5].s64 = ctx.r[27].s64 + 144;
	// 821D3028: 38C6DF9C  addi r6, r6, -0x2064
	ctx.r[6].s64 = ctx.r[6].s64 + -8292;
	// 821D302C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D3030: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D3034: 4BFFFDD5  bl 0x821d2e08
	ctx.lr = 0x821D3038;
	sub_821D2E08(ctx, base);
	// 821D3038: 80BB0058  lwz r5, 0x58(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(88 as u32) ) } as u64;
	// 821D303C: 3B9B0030  addi r28, r27, 0x30
	ctx.r[28].s64 = ctx.r[27].s64 + 48;
	// 821D3040: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D3044: 83DB0050  lwz r30, 0x50(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D3048: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821D304C: 7F1E2040  cmplw cr6, r30, r4
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821D3050: 419A0098  beq cr6, 0x821d30e8
	if ctx.cr[6].eq {
	pc = 0x821D30E8; continue 'dispatch;
	}
	// 821D3054: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 821D3058: 3B4BDFB8  addi r26, r11, -0x2048
	ctx.r[26].s64 = ctx.r[11].s64 + -8264;
            }
            0x821D305C => {
    //   block [0x821D305C..0x821D30CC)
	// 821D305C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3060: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 821D3064: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3068: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D306C: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D3070: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D3074: 4E800421  bctrl
	ctx.lr = 0x821D3078;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D3078: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D307C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821D3080: 419A004C  beq cr6, 0x821d30cc
	if ctx.cr[6].eq {
	pc = 0x821D30CC; continue 'dispatch;
	}
	// 821D3084: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3088: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D308C: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3090: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D3094: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D3098: 4E800421  bctrl
	ctx.lr = 0x821D309C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D309C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D30A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D30A4: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 821D30A8: 4800E939  bl 0x821e19e0
	ctx.lr = 0x821D30AC;
	sub_821E19E0(ctx, base);
	// 821D30AC: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D30B0: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D30B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821D30B8: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 821D30BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D30C0: 81090050  lwz r8, 0x50(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D30C4: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821D30C8: 4E800421  bctrl
	ctx.lr = 0x821D30CC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821D30CC => {
    //   block [0x821D30CC..0x821D30E8)
	// 821D30CC: 815C0028  lwz r10, 0x28(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D30D0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 821D30D4: 817C0020  lwz r11, 0x20(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 821D30D8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D30DC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D30E0: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821D30E4: 409AFF78  bne cr6, 0x821d305c
	if !ctx.cr[6].eq {
	pc = 0x821D305C; continue 'dispatch;
	}
	pc = 0x821D30E8; continue 'dispatch;
            }
            0x821D30E8 => {
    //   block [0x821D30E8..0x821D3138)
	// 821D30E8: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 821D30EC: 38BB0060  addi r5, r27, 0x60
	ctx.r[5].s64 = ctx.r[27].s64 + 96;
	// 821D30F0: 38CBDFAC  addi r6, r11, -0x2054
	ctx.r[6].s64 = ctx.r[11].s64 + -8276;
	// 821D30F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D30F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D30FC: 4BFFFD0D  bl 0x821d2e08
	ctx.lr = 0x821D3100;
	sub_821D2E08(ctx, base);
	// 821D3100: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 821D3104: 38BB00F0  addi r5, r27, 0xf0
	ctx.r[5].s64 = ctx.r[27].s64 + 240;
	// 821D3108: 38CACF18  addi r6, r10, -0x30e8
	ctx.r[6].s64 = ctx.r[10].s64 + -12520;
	// 821D310C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D3110: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D3114: 480F21A5  bl 0x822c52b8
	ctx.lr = 0x821D3118;
	sub_822C52B8(ctx, base);
	// 821D3118: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821D311C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821D3120: 38C9103C  addi r6, r9, 0x103c
	ctx.r[6].s64 = ctx.r[9].s64 + 4156;
	// 821D3124: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D3128: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D312C: 4BFFFCDD  bl 0x821d2e08
	ctx.lr = 0x821D3130;
	sub_821D2E08(ctx, base);
	// 821D3130: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821D3134: 48AD631C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D3138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D3138 size=132
    let mut pc: u32 = 0x821D3138;
    'dispatch: loop {
        match pc {
            0x821D3138 => {
    //   block [0x821D3138..0x821D3194)
	// 821D3138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D313C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D3140: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D3144: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D3148: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D314C: F8A10080  std r5, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[5].u64 ) };
	// 821D3150: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821D3154: F8C10088  std r6, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[6].u64 ) };
	// 821D3158: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D315C: 81210084  lwz r9, 0x84(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821D3160: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D3164: 909F0000  stw r4, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 821D3168: F8BF0008  std r5, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[5].u64 ) };
	// 821D316C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821D3170: F8DF0010  std r6, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[6].u64 ) };
	// 821D3174: 419A0030  beq cr6, 0x821d31a4
	if ctx.cr[6].eq {
	pc = 0x821D31A4; continue 'dispatch;
	}
	// 821D3178: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D317C: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D3180: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D3184: 419A0010  beq cr6, 0x821d3194
	if ctx.cr[6].eq {
	pc = 0x821D3194; continue 'dispatch;
	}
	// 821D3188: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D318C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D3190: 7D2B1670  srawi r11, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 2) as i64;
	pc = 0x821D3194; continue 'dispatch;
            }
            0x821D3194 => {
    //   block [0x821D3194..0x821D31A4)
	// 821D3194: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D3198: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D319C: 4199000C  bgt cr6, 0x821d31a8
	if ctx.cr[6].gt {
	pc = 0x821D31A8; continue 'dispatch;
	}
	// 821D31A0: 4802C5A1  bl 0x821ff740
	ctx.lr = 0x821D31A4;
	sub_821FF740(ctx, base);
	pc = 0x821D31A4; continue 'dispatch;
            }
            0x821D31A4 => {
    //   block [0x821D31A4..0x821D31A8)
	// 821D31A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x821D31A8; continue 'dispatch;
            }
            0x821D31A8 => {
    //   block [0x821D31A8..0x821D31BC)
	// 821D31A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821D31AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D31B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D31B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D31B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D31C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D31C0 size=152
    let mut pc: u32 = 0x821D31C0;
    'dispatch: loop {
        match pc {
            0x821D31C0 => {
    //   block [0x821D31C0..0x821D31F8)
	// 821D31C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D31C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D31C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D31CC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D31D0: 8144001C  lwz r10, 0x1c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D31D4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821D31D8: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D31DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D31E0: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 821D31E4: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 821D31E8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D31EC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821D31F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821D31F4: 419A0024  beq cr6, 0x821d3218
	if ctx.cr[6].eq {
	pc = 0x821D3218; continue 'dispatch;
	}
	pc = 0x821D31F8; continue 'dispatch;
            }
            0x821D31F8 => {
    //   block [0x821D31F8..0x821D3218)
	// 821D31F8: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D31FC: 7D282838  and r8, r9, r5
	ctx.r[8].u64 = ctx.r[9].u64 & ctx.r[5].u64;
	// 821D3200: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821D3204: 409A0040  bne cr6, 0x821d3244
	if !ctx.cr[6].eq {
	pc = 0x821D3244; continue 'dispatch;
	}
	// 821D3208: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 821D320C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D3210: 409AFFE8  bne cr6, 0x821d31f8
	if !ctx.cr[6].eq {
	pc = 0x821D31F8; continue 'dispatch;
	}
	// 821D3214: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x821D3218; continue 'dispatch;
            }
            0x821D3218 => {
    //   block [0x821D3218..0x821D3224)
	// 821D3218: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821D321C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821D3220: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	pc = 0x821D3224; continue 'dispatch;
            }
            0x821D3224 => {
    //   block [0x821D3224..0x821D3244)
	// 821D3224: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D3228: 4BFFFF11  bl 0x821d3138
	ctx.lr = 0x821D322C;
	sub_821D3138(ctx, base);
	// 821D322C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D3230: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D3234: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D3238: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D323C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D3240: 4E800020  blr
	return;
            }
            0x821D3244 => {
    //   block [0x821D3244..0x821D3258)
	// 821D3244: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 821D3248: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821D324C: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821D3250: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D3254: 4BFFFFD0  b 0x821d3224
	pc = 0x821D3224; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D3258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D3258 size=104
    let mut pc: u32 = 0x821D3258;
    'dispatch: loop {
        match pc {
            0x821D3258 => {
    //   block [0x821D3258..0x821D32C0)
	// 821D3258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D325C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D3260: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D3264: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D3268: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821D326C: 1020038C  vspltisw v1, 0
	for i in 0..4 {
		ctx.v[1].u32[i] = 0;
	}
	// 821D3270: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821D3274: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D3278: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821D327C: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D3280: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D32C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D32C0 size=688
    let mut pc: u32 = 0x821D32C0;
    'dispatch: loop {
        match pc {
            0x821D32C0 => {
    //   block [0x821D32C0..0x821D331C)
	// 821D32C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D32C4: 48AD6145  bl 0x82ca9408
	ctx.lr = 0x821D32C8;
	sub_82CA93D0(ctx, base);
	// 821D32C8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D32CC: 8164000C  lwz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D32D0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821D32D4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821D32D8: 3BE40008  addi r31, r4, 8
	ctx.r[31].s64 = ctx.r[4].s64 + 8;
	// 821D32DC: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 821D32E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D32E4: 419A0038  beq cr6, 0x821d331c
	if ctx.cr[6].eq {
	pc = 0x821D331C; continue 'dispatch;
	}
	// 821D32E8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D32EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D32F0: 419A0080  beq cr6, 0x821d3370
	if ctx.cr[6].eq {
	pc = 0x821D3370; continue 'dispatch;
	}
	// 821D32F4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D32F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D32FC: 419A0020  beq cr6, 0x821d331c
	if ctx.cr[6].eq {
	pc = 0x821D331C; continue 'dispatch;
	}
	// 821D3300: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D3304: 4BFA0B35  bl 0x82173e38
	ctx.lr = 0x821D3308;
	sub_82173E38(ctx, base);
	// 821D3308: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 821D330C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821D3310: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D3314: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D3318: 409A0008  bne cr6, 0x821d3320
	if !ctx.cr[6].eq {
	pc = 0x821D3320; continue 'dispatch;
	}
	pc = 0x821D331C; continue 'dispatch;
            }
            0x821D331C => {
    //   block [0x821D331C..0x821D3320)
	// 821D331C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821D3320; continue 'dispatch;
            }
            0x821D3320 => {
    //   block [0x821D3320..0x821D3370)
	// 821D3320: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D3324: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D3328: 419A01CC  beq cr6, 0x821d34f4
	if ctx.cr[6].eq {
	pc = 0x821D34F4; continue 'dispatch;
	}
	// 821D332C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D3330: 4BFA0B09  bl 0x82173e38
	ctx.lr = 0x821D3334;
	sub_82173E38(ctx, base);
	// 821D3334: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 821D3338: 556A4FFE  rlwinm r10, r11, 9, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x007FFFFFu64;
	// 821D333C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D3340: 419A0100  beq cr6, 0x821d3440
	if ctx.cr[6].eq {
	pc = 0x821D3440; continue 'dispatch;
	}
	// 821D3344: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D3348: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D334C: 419A0030  beq cr6, 0x821d337c
	if ctx.cr[6].eq {
	pc = 0x821D337C; continue 'dispatch;
	}
	// 821D3350: 894B0057  lbz r10, 0x57(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(87 as u32) ) } as u64;
	// 821D3354: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D3358: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821D335C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D3360: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D3364: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821D3368: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D336C: 480000D8  b 0x821d3444
	pc = 0x821D3444; continue 'dispatch;
            }
            0x821D3370 => {
    //   block [0x821D3370..0x821D337C)
	// 821D3370: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D3374: 4BFC0AC5  bl 0x82193e38
	ctx.lr = 0x821D3378;
	sub_82193E38(ctx, base);
	// 821D3378: 4BFFFFA4  b 0x821d331c
	pc = 0x821D331C; continue 'dispatch;
            }
            0x821D337C => {
    //   block [0x821D337C..0x821D3398)
	// 821D337C: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D3380: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D3384: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 821D3388: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821D338C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821D3390: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D3394: 40810054  ble 0x821d33e8
	if !ctx.cr[0].gt {
	pc = 0x821D33E8; continue 'dispatch;
	}
	pc = 0x821D3398; continue 'dispatch;
            }
            0x821D3398 => {
    //   block [0x821D3398..0x821D33B8)
	// 821D3398: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821D339C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D33A0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821D33A4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D33A8: 2F070057  cmpwi cr6, r7, 0x57
	ctx.cr[6].compare_i32(ctx.r[7].s32, 87, &mut ctx.xer);
	// 821D33AC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D33B0: 41980008  blt cr6, 0x821d33b8
	if ctx.cr[6].lt {
	pc = 0x821D33B8; continue 'dispatch;
	}
	// 821D33B4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x821D33B8; continue 'dispatch;
            }
            0x821D33B8 => {
    //   block [0x821D33B8..0x821D33D4)
	// 821D33B8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821D33BC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D33C0: 419A0014  beq cr6, 0x821d33d4
	if ctx.cr[6].eq {
	pc = 0x821D33D4; continue 'dispatch;
	}
	// 821D33C4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821D33C8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D33CC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D33D0: 4800000C  b 0x821d33dc
	pc = 0x821D33DC; continue 'dispatch;
            }
            0x821D33D4 => {
    //   block [0x821D33D4..0x821D33DC)
	// 821D33D4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821D33D8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821D33DC; continue 'dispatch;
            }
            0x821D33DC => {
    //   block [0x821D33DC..0x821D33E8)
	// 821D33DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D33E0: 4199FFB8  bgt cr6, 0x821d3398
	if ctx.cr[6].gt {
	pc = 0x821D3398; continue 'dispatch;
	}
	// 821D33E4: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x821D33E8; continue 'dispatch;
            }
            0x821D33E8 => {
    //   block [0x821D33E8..0x821D3404)
	// 821D33E8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821D33EC: 419A0040  beq cr6, 0x821d342c
	if ctx.cr[6].eq {
	pc = 0x821D342C; continue 'dispatch;
	}
	// 821D33F0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D33F4: 2F0B0057  cmpwi cr6, r11, 0x57
	ctx.cr[6].compare_i32(ctx.r[11].s32, 87, &mut ctx.xer);
	// 821D33F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D33FC: 41990008  bgt cr6, 0x821d3404
	if ctx.cr[6].gt {
	pc = 0x821D3404; continue 'dispatch;
	}
	// 821D3400: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821D3404; continue 'dispatch;
            }
            0x821D3404 => {
    //   block [0x821D3404..0x821D342C)
	// 821D3404: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D3408: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D340C: 409A0020  bne cr6, 0x821d342c
	if !ctx.cr[6].eq {
	pc = 0x821D342C; continue 'dispatch;
	}
	// 821D3410: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821D3414: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821D3418: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821D341C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D3420: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821D3424: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D3428: 4800001C  b 0x821d3444
	pc = 0x821D3444; continue 'dispatch;
            }
            0x821D342C => {
    //   block [0x821D342C..0x821D3440)
	// 821D342C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821D3430: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D3434: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821D3438: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D343C: 48000008  b 0x821d3444
	pc = 0x821D3444; continue 'dispatch;
            }
            0x821D3440 => {
    //   block [0x821D3440..0x821D3444)
	// 821D3440: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821D3444; continue 'dispatch;
            }
            0x821D3444 => {
    //   block [0x821D3444..0x821D34F4)
	// 821D3444: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D3448: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D344C: 419A00A8  beq cr6, 0x821d34f4
	if ctx.cr[6].eq {
	pc = 0x821D34F4; continue 'dispatch;
	}
	// 821D3450: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D3454: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821D3458: 83EB007C  lwz r31, 0x7c(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821D345C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D3460: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3464: 812A0044  lwz r9, 0x44(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 821D3468: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821D346C: 4E800421  bctrl
	ctx.lr = 0x821D3470;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D3470: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 821D3474: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821D3478: E8880000  ld r4, 0(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 821D347C: E8A80008  ld r5, 8(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	// 821D3480: 4BFFFDD9  bl 0x821d3258
	ctx.lr = 0x821D3484;
	sub_821D3258(ctx, base);
	// 821D3484: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3488: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D348C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821D3490: 80C70040  lwz r6, 0x40(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(64 as u32) ) } as u64;
	// 821D3494: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 821D3498: 4E800421  bctrl
	ctx.lr = 0x821D349C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821D34F4 => {
    //   block [0x821D34F4..0x821D3570)
	// 821D34F4: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 821D34F8: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 821D34FC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821D3500: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821D3504: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821D3508: 392B9140  addi r9, r11, -0x6ec0
	ctx.r[9].s64 = ctx.r[11].s64 + -28352;
	// 821D350C: C0079490  lfs f0, -0x6b70(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D3510: 390A9150  addi r8, r10, -0x6eb0
	ctx.r[8].s64 = ctx.r[10].s64 + -28336;
	// 821D3514: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821D3518: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D3570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D3570 size=1548
    let mut pc: u32 = 0x821D3570;
    'dispatch: loop {
        match pc {
            0x821D3570 => {
    //   block [0x821D3570..0x821D35EC)
	// 821D3570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D3574: 48AD5E75  bl 0x82ca93e8
	ctx.lr = 0x821D3578;
	sub_82CA93D0(ctx, base);
	// 821D3578: 9421FDB0  stwu r1, -0x250(r1)
	ea = ctx.r[1].u32.wrapping_add(-592 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D357C: 39670070  addi r11, r7, 0x70
	ctx.r[11].s64 = ctx.r[7].s64 + 112;
	// 821D3580: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 821D3584: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D3588: 7D6B182E  lwzx r11, r11, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 821D358C: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 821D3590: 396B0368  addi r11, r11, 0x368
	ctx.r[11].s64 = ctx.r[11].s64 + 872;
	// 821D3594: 836B001C  lwz r27, 0x1c(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D3598: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 821D359C: 419A05D8  beq cr6, 0x821d3b74
	if ctx.cr[6].eq {
	pc = 0x821D3B74; continue 'dispatch;
	}
	// 821D35A0: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D35A4: 1D2701A0  mulli r9, r7, 0x1a0
	ctx.r[9].s32 = ((ctx.r[7].s32 as i64 * 416 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 821D35A8: 83050018  lwz r24, 0x18(r5)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D35AC: 390A0009  addi r8, r10, 9
	ctx.r[8].s64 = ctx.r[10].s64 + 9;
	// 821D35B0: 7D491A14  add r10, r9, r3
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[3].u64;
	// 821D35B4: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821D35B8: 394A0044  addi r10, r10, 0x44
	ctx.r[10].s64 = ctx.r[10].s64 + 68;
	// 821D35BC: 7FC95A14  add r30, r9, r11
	ctx.r[30].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821D35C0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 821D35C4: 7FDAF378  mr r26, r30
	ctx.r[26].u64 = ctx.r[30].u64;
	// 821D35C8: 419A02E4  beq cr6, 0x821d38ac
	if ctx.cr[6].eq {
	pc = 0x821D38AC; continue 'dispatch;
	}
	// 821D35CC: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 821D35D0: 3AE50034  addi r23, r5, 0x34
	ctx.r[23].s64 = ctx.r[5].s64 + 52;
	// 821D35D4: 7F2B5050  subf r25, r11, r10
	ctx.r[25].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D35D8: A1410050  lhz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D35DC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 821D35E0: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 821D35E4: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 821D35E8: 3BAB5CE4  addi r29, r11, 0x5ce4
	ctx.r[29].s64 = ctx.r[11].s64 + 23780;
	pc = 0x821D35EC; continue 'dispatch;
            }
            0x821D35EC => {
    //   block [0x821D35EC..0x821D3614)
	// 821D35EC: 7CB93A14  add r5, r25, r7
	ctx.r[5].u64 = ctx.r[25].u64 + ctx.r[7].u64;
	// 821D35F0: 7D79382E  lwzx r11, r25, r7
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 821D35F4: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 821D35F8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821D35FC: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 821D3600: 80650004  lwz r3, 4(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D3604: 83E50008  lwz r31, 8(r5)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D3608: 419A0040  beq cr6, 0x821d3648
	if ctx.cr[6].eq {
	pc = 0x821D3648; continue 'dispatch;
	}
	// 821D360C: 80BA0000  lwz r5, 0(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3610: 54A4A73E  rlwinm r4, r5, 0x14, 0x1c, 0x1f
	ctx.r[4].u64 = ctx.r[5].u32 as u64 & 0x00000FFFu64;
	pc = 0x821D3614; continue 'dispatch;
            }
            0x821D3614 => {
    //   block [0x821D3614..0x821D3630)
	// 821D3614: 8AA80009  lbz r21, 9(r8)
	ctx.r[21].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(9 as u32) ) } as u64;
	// 821D3618: 7F152040  cmplw cr6, r21, r4
	ctx.cr[6].compare_u32(ctx.r[21].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821D361C: 409A0014  bne cr6, 0x821d3630
	if !ctx.cr[6].eq {
	pc = 0x821D3630; continue 'dispatch;
	}
	// 821D3620: 8AA8000A  lbz r21, 0xa(r8)
	ctx.r[21].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(10 as u32) ) } as u64;
	// 821D3624: 54B4873E  rlwinm r20, r5, 0x10, 0x1c, 0x1f
	ctx.r[20].u64 = ctx.r[5].u32 as u64 & 0x0000FFFFu64;
	// 821D3628: 7F15A040  cmplw cr6, r21, r20
	ctx.cr[6].compare_u32(ctx.r[21].u32, ctx.r[20].u32, &mut ctx.xer);
	// 821D362C: 419A0014  beq cr6, 0x821d3640
	if ctx.cr[6].eq {
	pc = 0x821D3640; continue 'dispatch;
	}
	pc = 0x821D3630; continue 'dispatch;
            }
            0x821D3630 => {
    //   block [0x821D3630..0x821D3640)
	// 821D3630: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821D3634: 3908000C  addi r8, r8, 0xc
	ctx.r[8].s64 = ctx.r[8].s64 + 12;
	// 821D3638: 7F09C040  cmplw cr6, r9, r24
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[24].u32, &mut ctx.xer);
	// 821D363C: 4198FFD8  blt cr6, 0x821d3614
	if ctx.cr[6].lt {
	pc = 0x821D3614; continue 'dispatch;
	}
	pc = 0x821D3640; continue 'dispatch;
            }
            0x821D3640 => {
    //   block [0x821D3640..0x821D3648)
	// 821D3640: 7F09C040  cmplw cr6, r9, r24
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[24].u32, &mut ctx.xer);
	// 821D3644: 41980038  blt cr6, 0x821d367c
	if ctx.cr[6].lt {
	pc = 0x821D367C; continue 'dispatch;
	}
	pc = 0x821D3648; continue 'dispatch;
            }
            0x821D3648 => {
    //   block [0x821D3648..0x821D367C)
	// 821D3648: 3D80BFC6  lis r12, -0x403a
	ctx.r[12].s64 = -1077542912;
	// 821D364C: 89060000  lbz r8, 0(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3650: 3920005F  li r9, 0x5f
	ctx.r[9].s64 = 95;
	// 821D3654: 618CCFFF  ori r12, r12, 0xcfff
	ctx.r[12].u64 = ctx.r[12].u64 | 53247;
	// 821D3658: 512BA096  rlwimi r11, r9, 0x14, 2, 0xb
	ctx.r[11].u64 = (((ctx.r[9].u32).rotate_left(20) as u64) & 0x000000003FF00000) | (ctx.r[11].u64 & 0xFFFFFFFFC00FFFFF);
	// 821D365C: 554A073E  clrlwi r10, r10, 0x1c
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 821D3660: 7C656038  and r5, r3, r12
	ctx.r[5].u64 = ctx.r[3].u64 & ctx.r[12].u64;
	// 821D3664: 57E40000  rlwinm r4, r31, 0, 0, 0
	ctx.r[4].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 821D3668: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 821D366C: 614A9250  ori r10, r10, 0x9250
	ctx.r[10].u64 = ctx.r[10].u64 | 37456;
	// 821D3670: 64AB0006  oris r11, r5, 6
	ctx.r[11].u64 = ctx.r[5].u64 | 393216;
	// 821D3674: 7C884378  or r8, r4, r8
	ctx.r[8].u64 = ctx.r[4].u64 | ctx.r[8].u64;
	// 821D3678: 48000124  b 0x821d379c
	pc = 0x821D379C; continue 'dispatch;
            }
            0x821D367C => {
    //   block [0x821D367C..0x821D36E0)
	// 821D367C: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D3680: 554A073E  clrlwi r10, r10, 0x1c
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 821D3684: 5524877E  rlwinm r4, r9, 0x10, 0x1d, 0x1f
	ctx.r[4].u64 = ctx.r[9].u32 as u64 & 0x0000FFFFu64;
	// 821D3688: 5525B6B8  rlwinm r5, r9, 0x16, 0x1a, 0x1c
	ctx.r[5].u64 = ctx.r[9].u32 as u64 & 0x000003FFu64;
	// 821D368C: 55356F7E  rlwinm r21, r9, 0xd, 0x1d, 0x1f
	ctx.r[21].u64 = ctx.r[9].u32 as u64 & 0x0007FFFFu64;
	// 821D3690: 7CA52378  or r5, r5, r4
	ctx.r[5].u64 = ctx.r[5].u64 | ctx.r[4].u64;
	// 821D3694: 5524042A  rlwinm r4, r9, 0, 0x10, 0x15
	ctx.r[4].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821D3698: 54A51838  slwi r5, r5, 3
	ctx.r[5].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821D369C: 55340632  rlwinm r20, r9, 0, 0x18, 0x19
	ctx.r[20].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821D36A0: 7CA5AB78  or r5, r5, r21
	ctx.r[5].u64 = ctx.r[5].u64 | ctx.r[21].u64;
	// 821D36A4: 2B140040  cmplwi cr6, r20, 0x40
	ctx.cr[6].compare_u32(ctx.r[20].u32, 64 as u32, &mut ctx.xer);
	// 821D36A8: 54A5083C  slwi r5, r5, 1
	ctx.r[5].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821D36AC: 7CA52378  or r5, r5, r4
	ctx.r[5].u64 = ctx.r[5].u64 | ctx.r[4].u64;
	// 821D36B0: 54A51838  slwi r5, r5, 3
	ctx.r[5].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821D36B4: 7CAA5378  or r10, r5, r10
	ctx.r[10].u64 = ctx.r[5].u64 | ctx.r[10].u64;
	// 821D36B8: 554A043E  clrlwi r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 821D36BC: 409A0084  bne cr6, 0x821d3740
	if !ctx.cr[6].eq {
	pc = 0x821D3740; continue 'dispatch;
	}
	// 821D36C0: 55440424  rlwinm r4, r10, 0, 0x10, 0x12
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821D36C4: 5545043E  clrlwi r5, r10, 0x10
	ctx.r[5].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 821D36C8: 2B046000  cmplwi cr6, r4, 0x6000
	ctx.cr[6].compare_u32(ctx.r[4].u32, 24576 as u32, &mut ctx.xer);
	// 821D36CC: 41990014  bgt cr6, 0x821d36e0
	if ctx.cr[6].gt {
	pc = 0x821D36E0; continue 'dispatch;
	}
	// 821D36D0: 54AA0424  rlwinm r10, r5, 0, 0x10, 0x12
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 821D36D4: 54A504FE  clrlwi r5, r5, 0x13
	ctx.r[5].u64 = ctx.r[5].u32 as u64 & 0x00001FFFu64;
	// 821D36D8: 694A2000  xori r10, r10, 0x2000
	ctx.r[10].u64 = ctx.r[10].u64 ^ 8192;
	// 821D36DC: 7D4A2B78  or r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	pc = 0x821D36E0; continue 'dispatch;
            }
            0x821D36E0 => {
    //   block [0x821D36E0..0x821D3700)
	// 821D36E0: 554404EA  rlwinm r4, r10, 0, 0x13, 0x15
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821D36E4: 5545043E  clrlwi r5, r10, 0x10
	ctx.r[5].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 821D36E8: 2B040C00  cmplwi cr6, r4, 0xc00
	ctx.cr[6].compare_u32(ctx.r[4].u32, 3072 as u32, &mut ctx.xer);
	// 821D36EC: 41990014  bgt cr6, 0x821d3700
	if ctx.cr[6].gt {
	pc = 0x821D3700; continue 'dispatch;
	}
	// 821D36F0: 54AA04EA  rlwinm r10, r5, 0, 0x13, 0x15
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 821D36F4: 70A5E3FF  andi. r5, r5, 0xe3ff
	ctx.r[5].u64 = ctx.r[5].u64 & 58367;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 821D36F8: 694A0400  xori r10, r10, 0x400
	ctx.r[10].u64 = ctx.r[10].u64 ^ 1024;
	// 821D36FC: 7D4A2B78  or r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	pc = 0x821D3700; continue 'dispatch;
            }
            0x821D3700 => {
    //   block [0x821D3700..0x821D3720)
	// 821D3700: 554405B0  rlwinm r4, r10, 0, 0x16, 0x18
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821D3704: 5545043E  clrlwi r5, r10, 0x10
	ctx.r[5].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 821D3708: 2B040180  cmplwi cr6, r4, 0x180
	ctx.cr[6].compare_u32(ctx.r[4].u32, 384 as u32, &mut ctx.xer);
	// 821D370C: 41990014  bgt cr6, 0x821d3720
	if ctx.cr[6].gt {
	pc = 0x821D3720; continue 'dispatch;
	}
	// 821D3710: 54AA05B0  rlwinm r10, r5, 0, 0x16, 0x18
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 821D3714: 70A5FC7F  andi. r5, r5, 0xfc7f
	ctx.r[5].u64 = ctx.r[5].u64 & 64639;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 821D3718: 694A0080  xori r10, r10, 0x80
	ctx.r[10].u64 = ctx.r[10].u64 ^ 128;
	// 821D371C: 7D4A2B78  or r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	pc = 0x821D3720; continue 'dispatch;
            }
            0x821D3720 => {
    //   block [0x821D3720..0x821D3740)
	// 821D3720: 55440676  rlwinm r4, r10, 0, 0x19, 0x1b
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821D3724: 5545043E  clrlwi r5, r10, 0x10
	ctx.r[5].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 821D3728: 2B040030  cmplwi cr6, r4, 0x30
	ctx.cr[6].compare_u32(ctx.r[4].u32, 48 as u32, &mut ctx.xer);
	// 821D372C: 41990014  bgt cr6, 0x821d3740
	if ctx.cr[6].gt {
	pc = 0x821D3740; continue 'dispatch;
	}
	// 821D3730: 54AA0676  rlwinm r10, r5, 0, 0x19, 0x1b
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 821D3734: 70A5FF8F  andi. r5, r5, 0xff8f
	ctx.r[5].u64 = ctx.r[5].u64 & 65423;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 821D3738: 694A0010  xori r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u64 ^ 16;
	// 821D373C: 7D4A2B78  or r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	pc = 0x821D3740; continue 'dispatch;
            }
            0x821D3740 => {
    //   block [0x821D3740..0x821D379C)
	// 821D3740: A0A80000  lhz r5, 0(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3744: 3C800156  lis r4, 0x156
	ctx.r[4].s64 = 22413312;
	// 821D3748: A1080002  lhz r8, 2(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(2 as u32) ) } as u64;
	// 821D374C: 553563A6  rlwinm r21, r9, 0xc, 0xe, 0x13
	ctx.r[21].u64 = ctx.r[9].u32 as u64 & 0x000FFFFFu64;
	// 821D3750: 2285005F  subfic r20, r5, 0x5f
	ctx.xer.ca = ctx.r[5].u32 <= 95 as u32;
	ctx.r[20].s64 = (95 as i64) - ctx.r[5].s64;
	// 821D3754: 60840056  ori r4, r4, 0x56
	ctx.r[4].u64 = ctx.r[4].u64 | 86;
	// 821D3758: 552905AE  rlwinm r9, r9, 0, 0x16, 0x17
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821D375C: 7C9421D6  mullw r4, r20, r4
	ctx.r[4].s32 = ((ctx.r[20].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 821D3760: 7CA530AE  lbzx r5, r5, r6
	ctx.r[5].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 821D3764: 7C942378  mr r20, r4
	ctx.r[20].u64 = ctx.r[4].u64;
	// 821D3768: 3D80BFC0  lis r12, -0x4040
	ctx.r[12].s64 = -1077936128;
	// 821D376C: 50945A18  rlwimi r20, r4, 0xb, 8, 0xc
	ctx.r[20].u64 = (((ctx.r[4].u32).rotate_left(11) as u64) & 0x0000000000F80000) | (ctx.r[20].u64 & 0xFFFFFFFFFF07FFFF);
	// 821D3770: 5508306E  rlwinm r8, r8, 6, 1, 0x17
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x03FFFFFFu64;
	// 821D3774: 7EA94B78  or r9, r21, r9
	ctx.r[9].u64 = ctx.r[21].u64 | ctx.r[9].u64;
	// 821D3778: 618CCFFF  ori r12, r12, 0xcfff
	ctx.r[12].u64 = ctx.r[12].u64 | 53247;
	// 821D377C: 528B0956  rlwimi r11, r20, 1, 5, 0xb
	ctx.r[11].u64 = (((ctx.r[20].u32).rotate_left(1) as u64) & 0x0000000007F00000) | (ctx.r[11].u64 & 0xFFFFFFFFF80FFFFF);
	// 821D3780: 7D082B78  or r8, r8, r5
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[5].u64;
	// 821D3784: 55242036  slwi r4, r9, 4
	ctx.r[4].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821D3788: 7C636038  and r3, r3, r12
	ctx.r[3].u64 = ctx.r[3].u64 & ctx.r[12].u64;
	// 821D378C: 57E50000  rlwinm r5, r31, 0, 0, 0
	ctx.r[5].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 821D3790: 55690142  rlwinm r9, r11, 0, 5, 1
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821D3794: 7C8B1B78  or r11, r4, r3
	ctx.r[11].u64 = ctx.r[4].u64 | ctx.r[3].u64;
	// 821D3798: 7D082B78  or r8, r8, r5
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[5].u64;
	pc = 0x821D379C; continue 'dispatch;
            }
            0x821D379C => {
    //   block [0x821D379C..0x821D38AC)
	// 821D379C: 55650F3C  rlwinm r5, r11, 1, 0x1c, 0x1e
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 821D37A0: 91270000  stw r9, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821D37A4: 554A043E  clrlwi r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 821D37A8: 91070008  stw r8, 8(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 821D37AC: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 821D37B0: 614A000E  ori r10, r10, 0xe
	ctx.r[10].u64 = ctx.r[10].u64 | 14;
	// 821D37B4: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 821D37B8: 7D25EA2E  lhzx r9, r5, r29
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 821D37BC: 5548043E  clrlwi r8, r10, 0x10
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 821D37C0: 5545043E  clrlwi r5, r10, 0x10
	ctx.r[5].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 821D37C4: 7D294038  and r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821D37C8: 5548043E  clrlwi r8, r10, 0x10
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 821D37CC: 5524043E  clrlwi r4, r9, 0x10
	ctx.r[4].u64 = ctx.r[9].u32 as u64 & 0x0000FFFFu64;
	// 821D37D0: 5529ECFE  rlwinm r9, r9, 0x1d, 0x13, 0x1f
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x00000007u64;
	// 821D37D4: 5543043E  clrlwi r3, r10, 0x10
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 821D37D8: 7D292378  or r9, r9, r4
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[4].u64;
	// 821D37DC: 5529E8FE  srwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shr(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821D37E0: 7D292378  or r9, r9, r4
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[4].u64;
	// 821D37E4: 5529E8FE  srwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shr(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821D37E8: 7D292378  or r9, r9, r4
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[4].u64;
	// 821D37EC: 5529E8FE  srwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shr(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821D37F0: 7D292378  or r9, r9, r4
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[4].u64;
	// 821D37F4: 512BFF7E  rlwimi r11, r9, 0x1f, 0x1d, 0x1f
	ctx.r[11].u64 = (((ctx.r[9].u32).rotate_left(31) as u64) & 0x0000000000000007) | (ctx.r[11].u64 & 0xFFFFFFFFFFFFFFF8);
	// 821D37F8: 5569F73C  rlwinm r9, r11, 0x1e, 0x1c, 0x1e
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 821D37FC: 7D29EA2E  lhzx r9, r9, r29
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 821D3800: 7D292838  and r9, r9, r5
	ctx.r[9].u64 = ctx.r[9].u64 & ctx.r[5].u64;
	// 821D3804: 5525043E  clrlwi r5, r9, 0x10
	ctx.r[5].u64 = ctx.r[9].u32 as u64 & 0x0000FFFFu64;
	// 821D3808: 5524ECFE  rlwinm r4, r9, 0x1d, 0x13, 0x1f
	ctx.r[4].u64 = ctx.r[9].u32 as u64 & 0x00000007u64;
	// 821D380C: 552913BA  rlwinm r9, r9, 2, 0xe, 0x1d
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x3FFFFFFFu64;
	// 821D3810: 7C842B78  or r4, r4, r5
	ctx.r[4].u64 = ctx.r[4].u64 | ctx.r[5].u64;
	// 821D3814: 5484E8FE  srwi r4, r4, 3
	ctx.r[4].u32 = ctx.r[4].u32.wrapping_shr(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821D3818: 7C842B78  or r4, r4, r5
	ctx.r[4].u64 = ctx.r[4].u64 | ctx.r[5].u64;
	// 821D381C: 5484E8FE  srwi r4, r4, 3
	ctx.r[4].u32 = ctx.r[4].u32.wrapping_shr(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821D3820: 7C852B78  or r5, r4, r5
	ctx.r[5].u64 = ctx.r[4].u64 | ctx.r[5].u64;
	// 821D3824: 54A5F87E  srwi r5, r5, 1
	ctx.r[5].u32 = ctx.r[5].u32.wrapping_shr(1);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821D3828: 7CA94B78  or r9, r5, r9
	ctx.r[9].u64 = ctx.r[5].u64 | ctx.r[9].u64;
	// 821D382C: 51690772  rlwimi r9, r11, 0, 0x1d, 0x19
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(0) as u64) & 0xFFFFFFFFFFFFFFC7) | (ctx.r[9].u64 & 0x0000000000000038);
	// 821D3830: 552BDF3C  rlwinm r11, r9, 0x1b, 0x1c, 0x1e
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 821D3834: 7D6BEA2E  lhzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 821D3838: 7D6B4038  and r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[8].u64;
	// 821D383C: 5568043E  clrlwi r8, r11, 0x10
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 821D3840: 5565ECFE  rlwinm r5, r11, 0x1d, 0x13, 0x1f
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 821D3844: 556B1B78  rlwinm r11, r11, 3, 0xd, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 821D3848: 7CA54378  or r5, r5, r8
	ctx.r[5].u64 = ctx.r[5].u64 | ctx.r[8].u64;
	// 821D384C: 7D6B4378  or r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[8].u64;
	// 821D3850: 54A5E8FE  srwi r5, r5, 3
	ctx.r[5].u32 = ctx.r[5].u32.wrapping_shr(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821D3854: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D3858: 7CA84378  or r8, r5, r8
	ctx.r[8].u64 = ctx.r[5].u64 | ctx.r[8].u64;
	// 821D385C: 5508F87E  srwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D3860: 7D0B5B78  or r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 | ctx.r[11].u64;
	// 821D3864: 512B06AC  rlwimi r11, r9, 0, 0x1a, 0x16
	ctx.r[11].u64 = (((ctx.r[9].u32).rotate_left(0) as u64) & 0xFFFFFFFFFFFFFE3F) | (ctx.r[11].u64 & 0x00000000000001C0);
	// 821D3868: 5569C73C  rlwinm r9, r11, 0x18, 0x1c, 0x1e
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D386C: 7D29EA2E  lhzx r9, r9, r29
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 821D3870: 7D291838  and r9, r9, r3
	ctx.r[9].u64 = ctx.r[9].u64 & ctx.r[3].u64;
	// 821D3874: 5528043E  clrlwi r8, r9, 0x10
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000FFFFu64;
	// 821D3878: 55251B78  rlwinm r5, r9, 3, 0xd, 0x1c
	ctx.r[5].u64 = ctx.r[9].u32 as u64 & 0x1FFFFFFFu64;
	// 821D387C: 5529ECFE  rlwinm r9, r9, 0x1d, 0x13, 0x1f
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x00000007u64;
	// 821D3880: 7CA54378  or r5, r5, r8
	ctx.r[5].u64 = ctx.r[5].u64 | ctx.r[8].u64;
	// 821D3884: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821D3888: 54A51838  slwi r5, r5, 3
	ctx.r[5].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821D388C: 5529F87E  srwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821D3890: 7CA84378  or r8, r5, r8
	ctx.r[8].u64 = ctx.r[5].u64 | ctx.r[8].u64;
	// 821D3894: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D3898: 7D094B78  or r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 821D389C: 516905E6  rlwimi r9, r11, 0, 0x17, 0x13
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(0) as u64) & 0xFFFFFFFFFFFFF1FF) | (ctx.r[9].u64 & 0x0000000000000E00);
	// 821D38A0: 91270004  stw r9, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821D38A4: 38E7000C  addi r7, r7, 0xc
	ctx.r[7].s64 = ctx.r[7].s64 + 12;
	// 821D38A8: 4082FD44  bne 0x821d35ec
	if !ctx.cr[0].eq {
	pc = 0x821D35EC; continue 'dispatch;
	}
	pc = 0x821D38AC; continue 'dispatch;
            }
            0x821D38AC => {
    //   block [0x821D38AC..0x821D38C8)
	// 821D38AC: 576B103A  slwi r11, r27, 2
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D38B0: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	// 821D38B4: 7F4BF214  add r26, r11, r30
	ctx.r[26].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821D38B8: 7F1ED040  cmplw cr6, r30, r26
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[26].u32, &mut ctx.xer);
	// 821D38BC: 4098027C  bge cr6, 0x821d3b38
	if !ctx.cr[6].lt {
	pc = 0x821D3B38; continue 'dispatch;
	}
	// 821D38C0: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 821D38C4: 3B2BB720  addi r25, r11, -0x48e0
	ctx.r[25].s64 = ctx.r[11].s64 + -18656;
	pc = 0x821D38C8; continue 'dispatch;
            }
            0x821D38C8 => {
    //   block [0x821D38C8..0x821D38D0)
	// 821D38C8: 7F1BD040  cmplw cr6, r27, r26
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[26].u32, &mut ctx.xer);
	// 821D38CC: 4098026C  bge cr6, 0x821d3b38
	if !ctx.cr[6].lt {
	pc = 0x821D3B38; continue 'dispatch;
	}
	pc = 0x821D38D0; continue 'dispatch;
            }
            0x821D38D0 => {
    //   block [0x821D38D0..0x821D38E8)
	// 821D38D0: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D38D4: 556B0297  rlwinm. r11, r11, 0, 0xa, 0xb
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D38D8: 40820010  bne 0x821d38e8
	if !ctx.cr[0].eq {
	pc = 0x821D38E8; continue 'dispatch;
	}
	// 821D38DC: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 821D38E0: 7F1BD040  cmplw cr6, r27, r26
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[26].u32, &mut ctx.xer);
	// 821D38E4: 4198FFEC  blt cr6, 0x821d38d0
	if ctx.cr[6].lt {
	pc = 0x821D38D0; continue 'dispatch;
	}
	pc = 0x821D38E8; continue 'dispatch;
            }
            0x821D38E8 => {
    //   block [0x821D38E8..0x821D3900)
	// 821D38E8: 7F1BD040  cmplw cr6, r27, r26
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[26].u32, &mut ctx.xer);
	// 821D38EC: 4098024C  bge cr6, 0x821d3b38
	if !ctx.cr[6].lt {
	pc = 0x821D3B38; continue 'dispatch;
	}
	// 821D38F0: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 821D38F4: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 821D38F8: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 821D38FC: 4098023C  bge cr6, 0x821d3b38
	if !ctx.cr[6].lt {
	pc = 0x821D3B38; continue 'dispatch;
	}
	pc = 0x821D3900; continue 'dispatch;
            }
            0x821D3900 => {
    //   block [0x821D3900..0x821D3918)
	// 821D3900: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3904: 55290297  rlwinm. r9, r9, 0, 0xa, 0xb
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821D3908: 40820010  bne 0x821d3918
	if !ctx.cr[0].eq {
	pc = 0x821D3918; continue 'dispatch;
	}
	// 821D390C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821D3910: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 821D3914: 4198FFEC  blt cr6, 0x821d3900
	if ctx.cr[6].lt {
	pc = 0x821D3900; continue 'dispatch;
	}
	pc = 0x821D3918; continue 'dispatch;
            }
            0x821D3918 => {
    //   block [0x821D3918..0x821D3990)
	// 821D3918: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 821D391C: 4098021C  bge cr6, 0x821d3b38
	if !ctx.cr[6].lt {
	pc = 0x821D3B38; continue 'dispatch;
	}
	// 821D3920: 7D1E5050  subf r8, r30, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[30].s64;
	// 821D3924: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3928: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821D392C: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 821D3930: 7D4A1670  srawi r10, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 821D3934: 7D081670  srawi r8, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 821D3938: 38AA0001  addi r5, r10, 1
	ctx.r[5].s64 = ctx.r[10].s64 + 1;
	// 821D393C: 1D08000C  mulli r8, r8, 0xc
	ctx.r[8].s32 = ((ctx.r[8].s32 as i64 * 12 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 821D3940: 3945FFFF  addi r10, r5, -1
	ctx.r[10].s64 = ctx.r[5].s64 + -1;
	// 821D3944: 54E70296  rlwinm r7, r7, 0, 0xa, 0xb
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 821D3948: 3CC00030  lis r6, 0x30
	ctx.r[6].s64 = 3145728;
	// 821D394C: 7C684A14  add r3, r8, r9
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821D3950: 3B6B0004  addi r27, r11, 4
	ctx.r[27].s64 = ctx.r[11].s64 + 4;
	// 821D3954: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 821D3958: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 821D395C: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 821D3960: 7F073040  cmplw cr6, r7, r6
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821D3964: 409A002C  bne cr6, 0x821d3990
	if !ctx.cr[6].eq {
	pc = 0x821D3990; continue 'dispatch;
	}
	// 821D3968: 7D1E5850  subf r8, r30, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 821D396C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 821D3970: 7D081670  srawi r8, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 821D3974: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 821D3978: 1D08000C  mulli r8, r8, 0xc
	ctx.r[8].s32 = ((ctx.r[8].s32 as i64 * 12 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 821D397C: 7D68582E  lwzx r11, r8, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821D3980: 5568767A  rlwinm r8, r11, 0xe, 0x19, 0x1d
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x0003FFFFu64;
	// 821D3984: 556B3FBE  rlwinm r11, r11, 7, 0x1e, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x01FFFFFFu64;
	// 821D3988: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 821D398C: 7D1D5B78  or r29, r8, r11
	ctx.r[29].u64 = ctx.r[8].u64 | ctx.r[11].u64;
	pc = 0x821D3990; continue 'dispatch;
            }
            0x821D3990 => {
    //   block [0x821D3990..0x821D39A0)
	// 821D3990: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821D3994: 419A00EC  beq cr6, 0x821d3a80
	if ctx.cr[6].eq {
	pc = 0x821D3A80; continue 'dispatch;
	}
	// 821D3998: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 821D399C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x821D39A0; continue 'dispatch;
            }
            0x821D39A0 => {
    //   block [0x821D39A0..0x821D39B0)
	// 821D39A0: 7F1F2040  cmplw cr6, r31, r4
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821D39A4: 409800CC  bge cr6, 0x821d3a70
	if !ctx.cr[6].lt {
	pc = 0x821D3A70; continue 'dispatch;
	}
	// 821D39A8: 394B000C  addi r10, r11, 0xc
	ctx.r[10].s64 = ctx.r[11].s64 + 12;
	// 821D39AC: 7F9F2050  subf r28, r31, r4
	ctx.r[28].s64 = ctx.r[4].s64 - ctx.r[31].s64;
	pc = 0x821D39B0; continue 'dispatch;
            }
            0x821D39B0 => {
    //   block [0x821D39B0..0x821D39F0)
	// 821D39B0: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D39B4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D39B8: 5506767A  rlwinm r6, r8, 0xe, 0x19, 0x1d
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x0003FFFFu64;
	// 821D39BC: 55083FBE  rlwinm r8, r8, 7, 0x1e, 0x1f
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x01FFFFFFu64;
	// 821D39C0: 54F8767A  rlwinm r24, r7, 0xe, 0x19, 0x1d
	ctx.r[24].u64 = ctx.r[7].u32 as u64 & 0x0003FFFFu64;
	// 821D39C4: 54F73FBE  rlwinm r23, r7, 7, 0x1e, 0x1f
	ctx.r[23].u64 = ctx.r[7].u32 as u64 & 0x01FFFFFFu64;
	// 821D39C8: 7CC74378  or r7, r6, r8
	ctx.r[7].u64 = ctx.r[6].u64 | ctx.r[8].u64;
	// 821D39CC: 7F06BB78  or r6, r24, r23
	ctx.r[6].u64 = ctx.r[24].u64 | ctx.r[23].u64;
	// 821D39D0: 7D073051  subf. r8, r7, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[7].s64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821D39D4: 4182001C  beq 0x821d39f0
	if ctx.cr[0].eq {
	pc = 0x821D39F0; continue 'dispatch;
	}
	// 821D39D8: 7F1D3800  cmpw cr6, r29, r7
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[7].s32, &mut ctx.xer);
	// 821D39DC: 419A0058  beq cr6, 0x821d3a34
	if ctx.cr[6].eq {
	pc = 0x821D3A34; continue 'dispatch;
	}
	// 821D39E0: 7F1D3000  cmpw cr6, r29, r6
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[6].s32, &mut ctx.xer);
	// 821D39E4: 409A0048  bne cr6, 0x821d3a2c
	if !ctx.cr[6].eq {
	pc = 0x821D3A2C; continue 'dispatch;
	}
	// 821D39E8: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 821D39EC: 48000040  b 0x821d3a2c
	pc = 0x821D3A2C; continue 'dispatch;
            }
            0x821D39F0 => {
    //   block [0x821D39F0..0x821D3A2C)
	// 821D39F0: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D39F4: 80EA0008  lwz r7, 8(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D39F8: 5508083C  slwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D39FC: 54E7083C  slwi r7, r7, 1
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821D3A00: 7D084E70  srawi r8, r8, 9
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 9) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[8].s32 >> 9) as i64;
	// 821D3A04: 7CE74E70  srawi r7, r7, 9
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 9) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[7].s32 >> 9) as i64;
	// 821D3A08: 7D074051  subf. r8, r7, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821D3A0C: 40820020  bne 0x821d3a2c
	if !ctx.cr[0].eq {
	pc = 0x821D3A2C; continue 'dispatch;
	}
	// 821D3A10: A10B0004  lhz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D3A14: A0EA0004  lhz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D3A18: 550806BE  clrlwi r8, r8, 0x1a
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x0000003Fu64;
	// 821D3A1C: 54E706BE  clrlwi r7, r7, 0x1a
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x0000003Fu64;
	// 821D3A20: 7D08C8AE  lbzx r8, r8, r25
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 821D3A24: 7CE7C8AE  lbzx r7, r7, r25
	ctx.r[7].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 821D3A28: 7D074050  subf r8, r7, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	pc = 0x821D3A2C; continue 'dispatch;
            }
            0x821D3A2C => {
    //   block [0x821D3A2C..0x821D3A34)
	// 821D3A2C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821D3A30: 40990034  ble cr6, 0x821d3a64
	if !ctx.cr[6].gt {
	pc = 0x821D3A64; continue 'dispatch;
	}
	pc = 0x821D3A34; continue 'dispatch;
            }
            0x821D3A34 => {
    //   block [0x821D3A34..0x821D3A64)
	// 821D3A34: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3A38: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3A3C: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D3A40: 830B0008  lwz r24, 8(r11)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D3A44: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821D3A48: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D3A4C: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821D3A50: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D3A54: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 821D3A58: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821D3A5C: 90CA0004  stw r6, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 821D3A60: 930A0008  stw r24, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	pc = 0x821D3A64; continue 'dispatch;
            }
            0x821D3A64 => {
    //   block [0x821D3A64..0x821D3A70)
	// 821D3A64: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 821D3A68: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 821D3A6C: 4082FF44  bne 0x821d39b0
	if !ctx.cr[0].eq {
	pc = 0x821D39B0; continue 'dispatch;
	}
	pc = 0x821D3A70; continue 'dispatch;
            }
            0x821D3A70 => {
    //   block [0x821D3A70..0x821D3A80)
	// 821D3A70: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821D3A74: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 821D3A78: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821D3A7C: 4082FF24  bne 0x821d39a0
	if !ctx.cr[0].eq {
	pc = 0x821D39A0; continue 'dispatch;
	}
	pc = 0x821D3A80; continue 'dispatch;
            }
            0x821D3A80 => {
    //   block [0x821D3A80..0x821D3A94)
	// 821D3A80: 1D65000C  mulli r11, r5, 0xc
	ctx.r[11].s32 = ((ctx.r[5].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821D3A84: 7CCB1A14  add r6, r11, r3
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 821D3A88: 3963000C  addi r11, r3, 0xc
	ctx.r[11].s64 = ctx.r[3].s64 + 12;
	// 821D3A8C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 821D3A90: 4800009C  b 0x821d3b2c
	pc = 0x821D3B2C; continue 'dispatch;
            }
            0x821D3A94 => {
    //   block [0x821D3A94..0x821D3B0C)
	// 821D3A94: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3A98: 81070000  lwz r8, 0(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3A9C: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 821D3AA0: 7D054378  mr r5, r8
	ctx.r[5].u64 = ctx.r[8].u64;
	// 821D3AA4: 5149CB1A  rlwimi r9, r10, 0x19, 0xc, 0xd
	ctx.r[9].u64 = (((ctx.r[10].u32).rotate_left(25) as u64) & 0x00000000000C0000) | (ctx.r[9].u64 & 0xFFFFFFFFFFF3FFFF);
	// 821D3AA8: 5105CB1A  rlwimi r5, r8, 0x19, 0xc, 0xd
	ctx.r[5].u64 = (((ctx.r[8].u32).rotate_left(25) as u64) & 0x00000000000C0000) | (ctx.r[5].u64 & 0xFFFFFFFFFFF3FFFF);
	// 821D3AAC: 552A01DA  rlwinm r10, r9, 0, 7, 0xd
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821D3AB0: 54A901DA  rlwinm r9, r5, 0, 7, 0xd
	ctx.r[9].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 821D3AB4: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D3AB8: 409A006C  bne cr6, 0x821d3b24
	if !ctx.cr[6].eq {
	pc = 0x821D3B24; continue 'dispatch;
	}
	// 821D3ABC: 81470008  lwz r10, 8(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D3AC0: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D3AC4: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D3AC8: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821D3ACC: 7D4A4E70  srawi r10, r10, 9
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 9) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 9) as i64;
	// 821D3AD0: 7D294E70  srawi r9, r9, 9
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 9) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 9) as i64;
	// 821D3AD4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821D3AD8: 4199004C  bgt cr6, 0x821d3b24
	if ctx.cr[6].gt {
	pc = 0x821D3B24; continue 'dispatch;
	}
	// 821D3ADC: A0AB0004  lhz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D3AE0: 54A506BE  clrlwi r5, r5, 0x1a
	ctx.r[5].u64 = ctx.r[5].u32 as u64 & 0x0000003Fu64;
	// 821D3AE4: 7CA5C8AE  lbzx r5, r5, r25
	ctx.r[5].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 821D3AE8: 7D4A2850  subf r10, r10, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 821D3AEC: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821D3AF0: 2B0A0008  cmplwi cr6, r10, 8
	ctx.cr[6].compare_u32(ctx.r[10].u32, 8 as u32, &mut ctx.xer);
	// 821D3AF4: 41990030  bgt cr6, 0x821d3b24
	if ctx.cr[6].gt {
	pc = 0x821D3B24; continue 'dispatch;
	}
	// 821D3AF8: 55092F7E  rlwinm r9, r8, 5, 0x1d, 0x1f
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x07FFFFFFu64;
	// 821D3AFC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821D3B00: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D3B04: 40990008  ble cr6, 0x821d3b0c
	if !ctx.cr[6].gt {
	pc = 0x821D3B0C; continue 'dispatch;
	}
	// 821D3B08: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	pc = 0x821D3B0C; continue 'dispatch;
            }
            0x821D3B0C => {
    //   block [0x821D3B0C..0x821D3B24)
	// 821D3B0C: 5148D888  rlwimi r8, r10, 0x1b, 2, 4
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(27) as u64) & 0x0000000038000000) | (ctx.r[8].u64 & 0xFFFFFFFFC7FFFFFF);
	// 821D3B10: 91070000  stw r8, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821D3B14: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D3B18: 654A4000  oris r10, r10, 0x4000
	ctx.r[10].u64 = ctx.r[10].u64 | 1073741824;
	// 821D3B1C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821D3B20: 48000008  b 0x821d3b28
	pc = 0x821D3B28; continue 'dispatch;
            }
            0x821D3B24 => {
    //   block [0x821D3B24..0x821D3B28)
	// 821D3B24: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	pc = 0x821D3B28; continue 'dispatch;
            }
            0x821D3B28 => {
    //   block [0x821D3B28..0x821D3B2C)
	// 821D3B28: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	pc = 0x821D3B2C; continue 'dispatch;
            }
            0x821D3B2C => {
    //   block [0x821D3B2C..0x821D3B38)
	// 821D3B2C: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821D3B30: 4198FF64  blt cr6, 0x821d3a94
	if ctx.cr[6].lt {
	pc = 0x821D3A94; continue 'dispatch;
	}
	// 821D3B34: 4BFFFD94  b 0x821d38c8
	pc = 0x821D38C8; continue 'dispatch;
            }
            0x821D3B38 => {
    //   block [0x821D3B38..0x821D3B40)
	// 821D3B38: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 821D3B3C: 48000030  b 0x821d3b6c
	pc = 0x821D3B6C; continue 'dispatch;
            }
            0x821D3B40 => {
    //   block [0x821D3B40..0x821D3B64)
	// 821D3B40: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D3B44: 556B053E  clrlwi r11, r11, 0x14
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000FFFu64;
	// 821D3B48: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821D3B4C: 7C6BB214  add r3, r11, r22
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[22].u64;
	// 821D3B50: 7F03F840  cmplw cr6, r3, r31
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821D3B54: 419A0010  beq cr6, 0x821d3b64
	if ctx.cr[6].eq {
	pc = 0x821D3B64; continue 'dispatch;
	}
	// 821D3B58: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 821D3B5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D3B60: 48AD5921  bl 0x82ca9480
	ctx.lr = 0x821D3B64;
	sub_82CA9480(ctx, base);
	pc = 0x821D3B64; continue 'dispatch;
            }
            0x821D3B64 => {
    //   block [0x821D3B64..0x821D3B6C)
	// 821D3B64: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 821D3B68: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	pc = 0x821D3B6C; continue 'dispatch;
            }
            0x821D3B6C => {
    //   block [0x821D3B6C..0x821D3B74)
	// 821D3B6C: 7F1ED040  cmplw cr6, r30, r26
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[26].u32, &mut ctx.xer);
	// 821D3B70: 4198FFD0  blt cr6, 0x821d3b40
	if ctx.cr[6].lt {
	pc = 0x821D3B40; continue 'dispatch;
	}
	pc = 0x821D3B74; continue 'dispatch;
            }
            0x821D3B74 => {
    //   block [0x821D3B74..0x821D3B7C)
	// 821D3B74: 38210250  addi r1, r1, 0x250
	ctx.r[1].s64 = ctx.r[1].s64 + 592;
	// 821D3B78: 48AD58C0  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D3B80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D3B80 size=1792
    let mut pc: u32 = 0x821D3B80;
    'dispatch: loop {
        match pc {
            0x821D3B80 => {
    //   block [0x821D3B80..0x821D4280)
	// 821D3B80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D3B84: 48AD5879  bl 0x82ca93fc
	ctx.lr = 0x821D3B88;
	sub_82CA93D0(ctx, base);
	// 821D3B88: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D3B8C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821D3B90: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 821D3B94: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821D3B98: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821D3B9C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D3BA0: C0099A80  lfs f0, -0x6580(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D3BA4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821D3BA8: 3BCB0010  addi r30, r11, 0x10
	ctx.r[30].s64 = ctx.r[11].s64 + 16;
	// 821D3BAC: 3B5E0410  addi r26, r30, 0x410
	ctx.r[26].s64 = ctx.r[30].s64 + 1040;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D4280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D4280 size=936
    let mut pc: u32 = 0x821D4280;
    'dispatch: loop {
        match pc {
            0x821D4280 => {
    //   block [0x821D4280..0x821D4628)
	// 821D4280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D4284: 48AD517D  bl 0x82ca9400
	ctx.lr = 0x821D4288;
	sub_82CA93D0(ctx, base);
	// 821D4288: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D428C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821D4290: 39400070  li r10, 0x70
	ctx.r[10].s64 = 112;
	// 821D4294: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 821D4298: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821D429C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821D42A0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D42A4: C0089A80  lfs f0, -0x6580(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D42A8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821D42AC: 3BCB0010  addi r30, r11, 0x10
	ctx.r[30].s64 = ctx.r[11].s64 + 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D4628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D4628 size=1192
    let mut pc: u32 = 0x821D4628;
    'dispatch: loop {
        match pc {
            0x821D4628 => {
    //   block [0x821D4628..0x821D4680)
	// 821D4628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D462C: 48AD4DC5  bl 0x82ca93f0
	ctx.lr = 0x821D4630;
	sub_82CA93D0(ctx, base);
	// 821D4630: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D4634: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821D4638: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821D463C: 3ACB8D14  addi r22, r11, -0x72ec
	ctx.r[22].s64 = ctx.r[11].s64 + -29420;
	// 821D4640: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821D4644: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D4648: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 821D464C: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 821D4650: 4802C121  bl 0x82200770
	ctx.lr = 0x821D4654;
	sub_82200770(ctx, base);
	// 821D4654: 3EE08349  lis r23, -0x7cb7
	ctx.r[23].s64 = -2092367872;
	// 821D4658: 81776AB8  lwz r11, 0x6ab8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821D465C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D4660: 814B0078  lwz r10, 0x78(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 821D4664: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D4668: 480AD979  bl 0x82281fe0
	ctx.lr = 0x821D466C;
	sub_82281FE0(ctx, base);
	// 821D466C: 89010054  lbz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D4670: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821D4674: 419A000C  beq cr6, 0x821d4680
	if ctx.cr[6].eq {
	pc = 0x821D4680; continue 'dispatch;
	}
	// 821D4678: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D467C: 490E52D9  bl 0x832b9954
	ctx.lr = 0x821D4680;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x821D4680; continue 'dispatch;
            }
            0x821D4680 => {
    //   block [0x821D4680..0x821D46AC)
	// 821D4680: 81776AB8  lwz r11, 0x6ab8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821D4684: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D4688: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 821D468C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D4690: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D4694: 550A003E  slwi r10, r8, 0
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D4698: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D469C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D46A0: 409A000C  bne cr6, 0x821d46ac
	if !ctx.cr[6].eq {
	pc = 0x821D46AC; continue 'dispatch;
	}
	// 821D46A4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 821D46A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821D46AC; continue 'dispatch;
            }
            0x821D46AC => {
    //   block [0x821D46AC..0x821D46FC)
	// 821D46AC: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D46B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D46B4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D46B8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D46BC: 4E800421  bctrl
	ctx.lr = 0x821D46C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D46C0: 81390000  lwz r9, 0(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D46C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D46C8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 821D46CC: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D46D0: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821D46D4: 4E800421  bctrl
	ctx.lr = 0x821D46D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D46D8: 7CFF1850  subf r7, r31, r3
	ctx.r[7].s64 = ctx.r[3].s64 - ctx.r[31].s64;
	// 821D46DC: 7CE60034  cntlzw r6, r7
	ctx.r[6].u64 = if ctx.r[7].u32 == 0 { 32 } else { ctx.r[7].u32.leading_zeros() as u64 };
	// 821D46E0: 54C5DFFE  rlwinm r5, r6, 0x1b, 0x1f, 0x1f
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0x0000001Fu64;
	// 821D46E4: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821D46E8: 419A03E0  beq cr6, 0x821d4ac8
	if ctx.cr[6].eq {
	pc = 0x821D4AC8; continue 'dispatch;
	}
	// 821D46EC: 8359002C  lwz r26, 0x2c(r25)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(44 as u32) ) } as u64;
	// 821D46F0: 81790030  lwz r11, 0x30(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(48 as u32) ) } as u64;
	// 821D46F4: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D46F8: 419A0134  beq cr6, 0x821d482c
	if ctx.cr[6].eq {
	pc = 0x821D482C; continue 'dispatch;
	}
            }
            0x821D46FC => {
    //   block [0x821D46FC..0x821D4740)
	// 821D46FC: 81776AB8  lwz r11, 0x6ab8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821D4700: 3B9A0004  addi r28, r26, 4
	ctx.r[28].s64 = ctx.r[26].s64 + 4;
	// 821D4704: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D4708: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D470C: 806A009C  lwz r3, 0x9c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) } as u64;
	// 821D4710: 4808FB21  bl 0x82264230
	ctx.lr = 0x821D4714;
	sub_82264230(ctx, base);
	// 821D4714: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D4718: 419A0104  beq cr6, 0x821d481c
	if ctx.cr[6].eq {
	pc = 0x821D481C; continue 'dispatch;
	}
	// 821D471C: 480CA75D  bl 0x8229ee78
	ctx.lr = 0x821D4720;
	sub_8229EE78(ctx, base);
	// 821D4720: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821D4724: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 821D4728: 419A0018  beq cr6, 0x821d4740
	if ctx.cr[6].eq {
	pc = 0x821D4740; continue 'dispatch;
	}
	// 821D472C: 897B0090  lbz r11, 0x90(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(144 as u32) ) } as u64;
	// 821D4730: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821D4734: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D4738: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D473C: 409A0008  bne cr6, 0x821d4744
	if !ctx.cr[6].eq {
	pc = 0x821D4744; continue 'dispatch;
	}
	pc = 0x821D4740; continue 'dispatch;
            }
            0x821D4740 => {
    //   block [0x821D4740..0x821D4744)
	// 821D4740: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x821D4744; continue 'dispatch;
            }
            0x821D4744 => {
    //   block [0x821D4744..0x821D4760)
	// 821D4744: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D4748: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D474C: 419A00D0  beq cr6, 0x821d481c
	if ctx.cr[6].eq {
	pc = 0x821D481C; continue 'dispatch;
	}
	// 821D4750: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D4754: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 821D4758: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821D475C: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821D4760; continue 'dispatch;
            }
            0x821D4760 => {
    //   block [0x821D4760..0x821D4764)
	// 821D4760: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	pc = 0x821D4764; continue 'dispatch;
            }
            0x821D4764 => {
    //   block [0x821D4764..0x821D4778)
	// 821D4764: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D4768: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821D476C: 419A000C  beq cr6, 0x821d4778
	if ctx.cr[6].eq {
	pc = 0x821D4778; continue 'dispatch;
	}
	// 821D4770: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821D4774: 419A0008  beq cr6, 0x821d477c
	if ctx.cr[6].eq {
	pc = 0x821D477C; continue 'dispatch;
	}
	pc = 0x821D4778; continue 'dispatch;
            }
            0x821D4778 => {
    //   block [0x821D4778..0x821D477C)
	// 821D4778: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821D477C; continue 'dispatch;
            }
            0x821D477C => {
    //   block [0x821D477C..0x821D4790)
	// 821D477C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D4780: 419A009C  beq cr6, 0x821d481c
	if ctx.cr[6].eq {
	pc = 0x821D481C; continue 'dispatch;
	}
	// 821D4784: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821D4788: 409A0008  bne cr6, 0x821d4790
	if !ctx.cr[6].eq {
	pc = 0x821D4790; continue 'dispatch;
	}
	// 821D478C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821D4790; continue 'dispatch;
            }
            0x821D4790 => {
    //   block [0x821D4790..0x821D47A0)
	// 821D4790: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D4794: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D4798: 409A0008  bne cr6, 0x821d47a0
	if !ctx.cr[6].eq {
	pc = 0x821D47A0; continue 'dispatch;
	}
	// 821D479C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821D47A0; continue 'dispatch;
            }
            0x821D47A0 => {
    //   block [0x821D47A0..0x821D4804)
	// 821D47A0: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D47A4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821D47A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D47AC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D47B0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D47B4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D47B8: 4E800421  bctrl
	ctx.lr = 0x821D47BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D47BC: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D47C0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821D47C4: 419A0040  beq cr6, 0x821d4804
	if ctx.cr[6].eq {
	pc = 0x821D4804; continue 'dispatch;
	}
	// 821D47C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D47CC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821D47D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D47D4: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D47D8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D47DC: 4E800421  bctrl
	ctx.lr = 0x821D47E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D47E0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821D47E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821D47E8: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D47EC: 4867381D  bl 0x82848008
	ctx.lr = 0x821D47F0;
	sub_82848008(ctx, base);
	// 821D47F0: E9230000  ld r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821D47F4: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 821D47F8: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D47FC: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D4800: 4BFFFF64  b 0x821d4764
	pc = 0x821D4764; continue 'dispatch;
            }
            0x821D4804 => {
    //   block [0x821D4804..0x821D4814)
	// 821D4804: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D4808: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D480C: 409A0008  bne cr6, 0x821d4814
	if !ctx.cr[6].eq {
	pc = 0x821D4814; continue 'dispatch;
	}
	// 821D4810: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821D4814; continue 'dispatch;
            }
            0x821D4814 => {
    //   block [0x821D4814..0x821D481C)
	// 821D4814: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D4818: 4BFFFF48  b 0x821d4760
	pc = 0x821D4760; continue 'dispatch;
            }
            0x821D481C => {
    //   block [0x821D481C..0x821D482C)
	// 821D481C: 81790030  lwz r11, 0x30(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(48 as u32) ) } as u64;
	// 821D4820: 3B5A0010  addi r26, r26, 0x10
	ctx.r[26].s64 = ctx.r[26].s64 + 16;
	// 821D4824: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D4828: 409AFED4  bne cr6, 0x821d46fc
	if !ctx.cr[6].eq {
	pc = 0x821D46FC; continue 'dispatch;
	}
	pc = 0x821D482C; continue 'dispatch;
            }
            0x821D482C => {
    //   block [0x821D482C..0x821D4844)
	// 821D482C: 83B90018  lwz r29, 0x18(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D4830: 8179001C  lwz r11, 0x1c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D4834: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 821D4838: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D483C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 821D4840: 419A0134  beq cr6, 0x821d4974
	if ctx.cr[6].eq {
	pc = 0x821D4974; continue 'dispatch;
	}
	pc = 0x821D4844; continue 'dispatch;
            }
            0x821D4844 => {
    //   block [0x821D4844..0x821D4864)
	// 821D4844: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D4848: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 821D484C: 552A003E  slwi r10, r9, 0
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D4850: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D4854: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D4858: 409A000C  bne cr6, 0x821d4864
	if !ctx.cr[6].eq {
	pc = 0x821D4864; continue 'dispatch;
	}
	// 821D485C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 821D4860: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821D4864; continue 'dispatch;
            }
            0x821D4864 => {
    //   block [0x821D4864..0x821D48A4)
	// 821D4864: 83EB0008  lwz r31, 8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D4868: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 821D486C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D4870: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D4874: 419A0030  beq cr6, 0x821d48a4
	if ctx.cr[6].eq {
	pc = 0x821D48A4; continue 'dispatch;
	}
	// 821D4878: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D487C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D4880: 419A0040  beq cr6, 0x821d48c0
	if ctx.cr[6].eq {
	pc = 0x821D48C0; continue 'dispatch;
	}
	// 821D4884: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D4888: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D488C: 419A0018  beq cr6, 0x821d48a4
	if ctx.cr[6].eq {
	pc = 0x821D48A4; continue 'dispatch;
	}
	// 821D4890: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 821D4894: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821D4898: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D489C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D48A0: 409A0008  bne cr6, 0x821d48a8
	if !ctx.cr[6].eq {
	pc = 0x821D48A8; continue 'dispatch;
	}
	pc = 0x821D48A4; continue 'dispatch;
            }
            0x821D48A4 => {
    //   block [0x821D48A4..0x821D48A8)
	// 821D48A4: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x821D48A8; continue 'dispatch;
            }
            0x821D48A8 => {
    //   block [0x821D48A8..0x821D48C0)
	// 821D48A8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D48AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D48B0: 419A0018  beq cr6, 0x821d48c8
	if ctx.cr[6].eq {
	pc = 0x821D48C8; continue 'dispatch;
	}
	// 821D48B4: 3BBD0010  addi r29, r29, 0x10
	ctx.r[29].s64 = ctx.r[29].s64 + 16;
	// 821D48B8: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 821D48BC: 480000AC  b 0x821d4968
	pc = 0x821D4968; continue 'dispatch;
            }
            0x821D48C0 => {
    //   block [0x821D48C0..0x821D48C8)
	// 821D48C0: 4BFBF579  bl 0x82193e38
	ctx.lr = 0x821D48C4;
	sub_82193E38(ctx, base);
	// 821D48C4: 4BFFFFE0  b 0x821d48a4
	pc = 0x821D48A4; continue 'dispatch;
            }
            0x821D48C8 => {
    //   block [0x821D48C8..0x821D48E8)
	// 821D48C8: 897F0010  lbz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D48CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D48D0: 419A0018  beq cr6, 0x821d48e8
	if ctx.cr[6].eq {
	pc = 0x821D48E8; continue 'dispatch;
	}
	// 821D48D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D48D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D48DC: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821D48E0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D48E4: 4E800421  bctrl
	ctx.lr = 0x821D48E8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821D48E8 => {
    //   block [0x821D48E8..0x821D4900)
	// 821D48E8: 83D9001C  lwz r30, 0x1c(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D48EC: 3BFD0010  addi r31, r29, 0x10
	ctx.r[31].s64 = ctx.r[29].s64 + 16;
	// 821D48F0: 3B990014  addi r28, r25, 0x14
	ctx.r[28].s64 = ctx.r[25].s64 + 20;
	// 821D48F4: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821D48F8: 419A0020  beq cr6, 0x821d4918
	if ctx.cr[6].eq {
	pc = 0x821D4918; continue 'dispatch;
	}
	// 821D48FC: 7FBFE850  subf r29, r31, r29
	ctx.r[29].s64 = ctx.r[29].s64 - ctx.r[31].s64;
	pc = 0x821D4900; continue 'dispatch;
            }
            0x821D4900 => {
    //   block [0x821D4900..0x821D4918)
	// 821D4900: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D4904: 7C7DFA14  add r3, r29, r31
	ctx.r[3].u64 = ctx.r[29].u64 + ctx.r[31].u64;
	// 821D4908: 482062A1  bl 0x823daba8
	ctx.lr = 0x821D490C;
	sub_823DABA8(ctx, base);
	// 821D490C: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 821D4910: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821D4914: 409AFFEC  bne cr6, 0x821d4900
	if !ctx.cr[6].eq {
	pc = 0x821D4900; continue 'dispatch;
	}
	pc = 0x821D4918; continue 'dispatch;
            }
            0x821D4918 => {
    //   block [0x821D4918..0x821D492C)
	// 821D4918: 83BC0008  lwz r29, 8(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D491C: 3BDDFFF0  addi r30, r29, -0x10
	ctx.r[30].s64 = ctx.r[29].s64 + -16;
	// 821D4920: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 821D4924: 419A002C  beq cr6, 0x821d4950
	if ctx.cr[6].eq {
	pc = 0x821D4950; continue 'dispatch;
	}
	// 821D4928: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	pc = 0x821D492C; continue 'dispatch;
            }
            0x821D492C => {
    //   block [0x821D492C..0x821D4950)
	// 821D492C: 387FFFFC  addi r3, r31, -4
	ctx.r[3].s64 = ctx.r[31].s64 + -4;
	// 821D4930: 485CC4E9  bl 0x827a0e18
	ctx.lr = 0x821D4934;
	sub_827A0E18(ctx, base);
	// 821D4934: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D4938: 48047401  bl 0x8221bd38
	ctx.lr = 0x821D493C;
	sub_8221BD38(ctx, base);
	// 821D493C: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 821D4940: 931F0000  stw r24, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 821D4944: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 821D4948: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 821D494C: 409AFFE0  bne cr6, 0x821d492c
	if !ctx.cr[6].eq {
	pc = 0x821D492C; continue 'dispatch;
	}
	pc = 0x821D4950; continue 'dispatch;
            }
            0x821D4950 => {
    //   block [0x821D4950..0x821D4968)
	// 821D4950: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D4954: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D4958: 392BFFF0  addi r9, r11, -0x10
	ctx.r[9].s64 = ctx.r[11].s64 + -16;
	// 821D495C: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821D4960: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D4964: 913C0008  stw r9, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x821D4968; continue 'dispatch;
            }
            0x821D4968 => {
    //   block [0x821D4968..0x821D4974)
	// 821D4968: 8179001C  lwz r11, 0x1c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D496C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D4970: 409AFED4  bne cr6, 0x821d4844
	if !ctx.cr[6].eq {
	pc = 0x821D4844; continue 'dispatch;
	}
	pc = 0x821D4974; continue 'dispatch;
            }
            0x821D4974 => {
    //   block [0x821D4974..0x821D4984)
	// 821D4974: 83F90018  lwz r31, 0x18(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D4978: 8179001C  lwz r11, 0x1c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D497C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D4980: 419A0048  beq cr6, 0x821d49c8
	if ctx.cr[6].eq {
	pc = 0x821D49C8; continue 'dispatch;
	}
	pc = 0x821D4984; continue 'dispatch;
            }
            0x821D4984 => {
    //   block [0x821D4984..0x821D49A4)
	// 821D4984: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D4988: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 821D498C: 552A003E  slwi r10, r9, 0
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D4990: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D4994: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D4998: 409A000C  bne cr6, 0x821d49a4
	if !ctx.cr[6].eq {
	pc = 0x821D49A4; continue 'dispatch;
	}
	// 821D499C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 821D49A0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821D49A4; continue 'dispatch;
            }
            0x821D49A4 => {
    //   block [0x821D49A4..0x821D49C8)
	// 821D49A4: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D49A8: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 821D49AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D49B0: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 821D49B4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D49B8: 4E800421  bctrl
	ctx.lr = 0x821D49BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D49BC: 8139001C  lwz r9, 0x1c(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D49C0: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821D49C4: 409AFFC0  bne cr6, 0x821d4984
	if !ctx.cr[6].eq {
	pc = 0x821D4984; continue 'dispatch;
	}
            }
            0x821D49C8 => {
    //   block [0x821D49C8..0x821D4A14)
	// 821D49C8: 81776AB8  lwz r11, 0x6ab8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821D49CC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D49D0: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821D49D4: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D49D8: 480A1591  bl 0x82275f68
	ctx.lr = 0x821D49DC;
	sub_82275F68(ctx, base);
	// 821D49DC: 81776AB8  lwz r11, 0x6ab8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821D49E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821D49E4: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D49E8: 8088008C  lwz r4, 0x8c(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D49EC: 4BFD7BED  bl 0x821ac5d8
	ctx.lr = 0x821D49F0;
	sub_821AC5D8(ctx, base);
	// 821D49F0: 88E30004  lbz r7, 4(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D49F4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D49F8: 409A001C  bne cr6, 0x821d4a14
	if !ctx.cr[6].eq {
	pc = 0x821D4A14; continue 'dispatch;
	}
	// 821D49FC: 81776AB8  lwz r11, 0x6ab8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821D4A00: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D4A04: 894B0104  lbz r10, 0x104(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) } as u64;
	// 821D4A08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D4A0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D4A10: 419A0008  beq cr6, 0x821d4a18
	if ctx.cr[6].eq {
	pc = 0x821D4A18; continue 'dispatch;
	}
	pc = 0x821D4A14; continue 'dispatch;
            }
            0x821D4A14 => {
    //   block [0x821D4A14..0x821D4A18)
	// 821D4A14: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x821D4A18; continue 'dispatch;
            }
            0x821D4A18 => {
    //   block [0x821D4A18..0x821D4A78)
	// 821D4A18: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 821D4A1C: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D4A20: 480403B9  bl 0x82214dd8
	ctx.lr = 0x821D4A24;
	sub_82214DD8(ctx, base);
	// 821D4A24: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821D4A28: 480403B1  bl 0x82214dd8
	ctx.lr = 0x821D4A2C;
	sub_82214DD8(ctx, base);
	// 821D4A2C: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 821D4A30: 480403A9  bl 0x82214dd8
	ctx.lr = 0x821D4A34;
	sub_82214DD8(ctx, base);
	// 821D4A34: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821D4A38: 480403A1  bl 0x82214dd8
	ctx.lr = 0x821D4A3C;
	sub_82214DD8(ctx, base);
	// 821D4A3C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821D4A40: 419A004C  beq cr6, 0x821d4a8c
	if ctx.cr[6].eq {
	pc = 0x821D4A8C; continue 'dispatch;
	}
	// 821D4A44: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 821D4A48: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821D4A4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D4A50: 4802BD21  bl 0x82200770
	ctx.lr = 0x821D4A54;
	sub_82200770(ctx, base);
	// 821D4A54: 81776AB8  lwz r11, 0x6ab8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821D4A58: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D4A5C: 894B0104  lbz r10, 0x104(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) } as u64;
	// 821D4A60: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D4A64: 409A0014  bne cr6, 0x821d4a78
	if !ctx.cr[6].eq {
	pc = 0x821D4A78; continue 'dispatch;
	}
	// 821D4A68: 806B009C  lwz r3, 0x9c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) } as u64;
	// 821D4A6C: 48023D5D  bl 0x821f87c8
	ctx.lr = 0x821D4A70;
	sub_821F87C8(ctx, base);
	// 821D4A70: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D4A74: 4BFE47E5  bl 0x821b9258
	ctx.lr = 0x821D4A78;
	sub_821B9258(ctx, base);
	pc = 0x821D4A78; continue 'dispatch;
            }
            0x821D4A78 => {
    //   block [0x821D4A78..0x821D4A8C)
	// 821D4A78: 89410054  lbz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D4A7C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D4A80: 419A000C  beq cr6, 0x821d4a8c
	if ctx.cr[6].eq {
	pc = 0x821D4A8C; continue 'dispatch;
	}
	// 821D4A84: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D4A88: 490E4ECD  bl 0x832b9954
	ctx.lr = 0x821D4A8C;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x821D4A8C; continue 'dispatch;
            }
            0x821D4A8C => {
    //   block [0x821D4A8C..0x821D4AB8)
	// 821D4A8C: 81776AB8  lwz r11, 0x6ab8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821D4A90: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D4A94: 812A008C  lwz r9, 0x8c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D4A98: 888900F5  lbz r4, 0xf5(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(245 as u32) ) } as u64;
	// 821D4A9C: 890900F3  lbz r8, 0xf3(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(243 as u32) ) } as u64;
	// 821D4AA0: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 821D4AA4: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821D4AA8: 419A0010  beq cr6, 0x821d4ab8
	if ctx.cr[6].eq {
	pc = 0x821D4AB8; continue 'dispatch;
	}
	// 821D4AAC: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D4AB0: 806B008C  lwz r3, 0x8c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D4AB4: 48158205  bl 0x8232ccb8
	ctx.lr = 0x821D4AB8;
	sub_8232CCB8(ctx, base);
	pc = 0x821D4AB8; continue 'dispatch;
            }
            0x821D4AB8 => {
    //   block [0x821D4AB8..0x821D4AC8)
	// 821D4AB8: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 821D4ABC: 816A9650  lwz r11, -0x69b0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 821D4AC0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821D4AC4: 916A9650  stw r11, -0x69b0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-27056 as u32), ctx.r[11].u32 ) };
	pc = 0x821D4AC8; continue 'dispatch;
            }
            0x821D4AC8 => {
    //   block [0x821D4AC8..0x821D4AD0)
	// 821D4AC8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821D4ACC: 48AD4974  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D4AD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D4AD0 size=396
    let mut pc: u32 = 0x821D4AD0;
    'dispatch: loop {
        match pc {
            0x821D4AD0 => {
    //   block [0x821D4AD0..0x821D4B1C)
	// 821D4AD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D4AD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D4AD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D4ADC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821D4AE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D4AE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D4AE8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821D4AEC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821D4AF0: 3940000C  li r10, 0xc
	ctx.r[10].s64 = 12;
	// 821D4AF4: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 821D4AF8: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D4AFC: 989F000E  stb r4, 0xe(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(14 as u32), ctx.r[4].u8 ) };
	// 821D4B00: C3EB9484  lfs f31, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821D4B04: 80A6001C  lwz r5, 0x1c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D4B08: 81260018  lwz r9, 0x18(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D4B0C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821D4B10: 7D092850  subf r8, r9, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[9].s64;
	// 821D4B14: 7D6853D7  divw. r11, r8, r10
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[10].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D4B18: 4081005C  ble 0x821d4b74
	if !ctx.cr[0].gt {
	pc = 0x821D4B74; continue 'dispatch;
	}
	pc = 0x821D4B1C; continue 'dispatch;
            }
            0x821D4B1C => {
    //   block [0x821D4B1C..0x821D4B44)
	// 821D4B1C: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821D4B20: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D4B24: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821D4B28: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D4B2C: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821D4B30: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D4B34: 2F070001  cmpwi cr6, r7, 1
	ctx.cr[6].compare_i32(ctx.r[7].s32, 1, &mut ctx.xer);
	// 821D4B38: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D4B3C: 41980008  blt cr6, 0x821d4b44
	if ctx.cr[6].lt {
	pc = 0x821D4B44; continue 'dispatch;
	}
	// 821D4B40: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	pc = 0x821D4B44; continue 'dispatch;
            }
            0x821D4B44 => {
    //   block [0x821D4B44..0x821D4B60)
	// 821D4B44: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821D4B48: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D4B4C: 419A0014  beq cr6, 0x821d4b60
	if ctx.cr[6].eq {
	pc = 0x821D4B60; continue 'dispatch;
	}
	// 821D4B50: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821D4B54: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 821D4B58: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D4B5C: 4800000C  b 0x821d4b68
	pc = 0x821D4B68; continue 'dispatch;
            }
            0x821D4B60 => {
    //   block [0x821D4B60..0x821D4B68)
	// 821D4B60: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821D4B64: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x821D4B68; continue 'dispatch;
            }
            0x821D4B68 => {
    //   block [0x821D4B68..0x821D4B74)
	// 821D4B68: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D4B6C: 4199FFB0  bgt cr6, 0x821d4b1c
	if ctx.cr[6].gt {
	pc = 0x821D4B1C; continue 'dispatch;
	}
	// 821D4B70: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	pc = 0x821D4B74; continue 'dispatch;
            }
            0x821D4B74 => {
    //   block [0x821D4B74..0x821D4B90)
	// 821D4B74: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821D4B78: 419A0034  beq cr6, 0x821d4bac
	if ctx.cr[6].eq {
	pc = 0x821D4BAC; continue 'dispatch;
	}
	// 821D4B7C: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D4B80: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821D4B84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D4B88: 41990008  bgt cr6, 0x821d4b90
	if ctx.cr[6].gt {
	pc = 0x821D4B90; continue 'dispatch;
	}
	// 821D4B8C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	pc = 0x821D4B90; continue 'dispatch;
            }
            0x821D4B90 => {
    //   block [0x821D4B90..0x821D4BAC)
	// 821D4B90: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D4B94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D4B98: 409A0014  bne cr6, 0x821d4bac
	if !ctx.cr[6].eq {
	pc = 0x821D4BAC; continue 'dispatch;
	}
	// 821D4B9C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D4BA0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821D4BA4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D4BA8: 48000008  b 0x821d4bb0
	pc = 0x821D4BB0; continue 'dispatch;
            }
            0x821D4BAC => {
    //   block [0x821D4BAC..0x821D4BB0)
	// 821D4BAC: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	pc = 0x821D4BB0; continue 'dispatch;
            }
            0x821D4BB0 => {
    //   block [0x821D4BB0..0x821D4BC8)
	// 821D4BB0: 8146001C  lwz r10, 0x1c(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D4BB4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D4BB8: 419A0010  beq cr6, 0x821d4bc8
	if ctx.cr[6].eq {
	pc = 0x821D4BC8; continue 'dispatch;
	}
	// 821D4BBC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D4BC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D4BC4: 4800000C  b 0x821d4bd0
	pc = 0x821D4BD0; continue 'dispatch;
            }
            0x821D4BC8 => {
    //   block [0x821D4BC8..0x821D4BD0)
	// 821D4BC8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D4BCC: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	pc = 0x821D4BD0; continue 'dispatch;
            }
            0x821D4BD0 => {
    //   block [0x821D4BD0..0x821D4BE0)
	// 821D4BD0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D4BD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D4BD8: 419A0008  beq cr6, 0x821d4be0
	if ctx.cr[6].eq {
	pc = 0x821D4BE0; continue 'dispatch;
	}
	// 821D4BDC: C3EA0008  lfs f31, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x821D4BE0; continue 'dispatch;
            }
            0x821D4BE0 => {
    //   block [0x821D4BE0..0x821D4C30)
	// 821D4BE0: 897F000C  lbz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D4BE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D4BE8: 419A0058  beq cr6, 0x821d4c40
	if ctx.cr[6].eq {
	pc = 0x821D4C40; continue 'dispatch;
	}
	// 821D4BEC: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821D4BF0: 894B8FED  lbz r10, -0x7013(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28691 as u32) ) } as u64;
	// 821D4BF4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D4BF8: 419A0038  beq cr6, 0x821d4c30
	if ctx.cr[6].eq {
	pc = 0x821D4C30; continue 'dispatch;
	}
	// 821D4BFC: 897F0054  lbz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D4C00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D4C04: 409A002C  bne cr6, 0x821d4c30
	if !ctx.cr[6].eq {
	pc = 0x821D4C30; continue 'dispatch;
	}
	// 821D4C08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D4C0C: 48097AF5  bl 0x8226c700
	ctx.lr = 0x821D4C10;
	sub_8226C700(ctx, base);
	// 821D4C10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D4C14: 419A002C  beq cr6, 0x821d4c40
	if ctx.cr[6].eq {
	pc = 0x821D4C40; continue 'dispatch;
	}
	// 821D4C18: 8063007C  lwz r3, 0x7c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(124 as u32) ) } as u64;
	// 821D4C1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D4C20: 814B007C  lwz r10, 0x7c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821D4C24: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D4C28: 4E800421  bctrl
	ctx.lr = 0x821D4C2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D4C2C: 48000014  b 0x821d4c40
	pc = 0x821D4C40; continue 'dispatch;
            }
            0x821D4C30 => {
    //   block [0x821D4C30..0x821D4C40)
	// 821D4C30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D4C34: C03F0008  lfs f1, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821D4C38: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 821D4C3C: 480674A5  bl 0x8223c0e0
	ctx.lr = 0x821D4C40;
	sub_8223C0E0(ctx, base);
	pc = 0x821D4C40; continue 'dispatch;
            }
            0x821D4C40 => {
    //   block [0x821D4C40..0x821D4C5C)
	// 821D4C40: D3FF0008  stfs f31, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821D4C44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D4C48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D4C4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D4C50: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821D4C54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D4C58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D4C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D4C60 size=132
    let mut pc: u32 = 0x821D4C60;
    'dispatch: loop {
        match pc {
            0x821D4C60 => {
    //   block [0x821D4C60..0x821D4CE4)
	// 821D4C60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D4C64: 48AD47A9  bl 0x82ca940c
	ctx.lr = 0x821D4C68;
	sub_82CA93D0(ctx, base);
	// 821D4C68: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D4C6C: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 821D4C70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D4C74: 48053485  bl 0x822280f8
	ctx.lr = 0x821D4C78;
	sub_822280F8(ctx, base);
	// 821D4C78: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821D4C7C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821D4C80: 83C30004  lwz r30, 4(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D4C84: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821D4C88: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D4C8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D4C90: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 821D4C94: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D4C98: 4812D2C1  bl 0x82301f58
	ctx.lr = 0x821D4C9C;
	sub_82301F58(ctx, base);
	// 821D4C9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D4CA0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D4CA4: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 821D4CA8: 4E800421  bctrl
	ctx.lr = 0x821D4CAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D4CAC: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D4CB0: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D4CB4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D4CB8: 7D260034  cntlzw r6, r9
	ctx.r[6].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821D4CBC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821D4CC0: 54C5DFFE  rlwinm r5, r6, 0x1b, 0x1f, 0x1f
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0x0000001Fu64;
	// 821D4CC4: 68A40001  xori r4, r5, 1
	ctx.r[4].u64 = ctx.r[5].u64 ^ 1;
	// 821D4CC8: 90E80004  stw r7, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821D4CCC: 90880000  stw r4, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 821D4CD0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D4CD4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821D4CD8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821D4CDC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821D4CE0: 48AD477C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D4CE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D4CE8 size=164
    let mut pc: u32 = 0x821D4CE8;
    'dispatch: loop {
        match pc {
            0x821D4CE8 => {
    //   block [0x821D4CE8..0x821D4D8C)
	// 821D4CE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D4CEC: 48AD471D  bl 0x82ca9408
	ctx.lr = 0x821D4CF0;
	sub_82CA93D0(ctx, base);
	// 821D4CF0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D4CF4: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 821D4CF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D4CFC: 480533FD  bl 0x822280f8
	ctx.lr = 0x821D4D00;
	sub_822280F8(ctx, base);
	// 821D4D00: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821D4D04: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821D4D08: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821D4D0C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821D4D10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D4D14: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 821D4D18: 83CA0004  lwz r30, 4(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D4D1C: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D4D20: 480533D9  bl 0x822280f8
	ctx.lr = 0x821D4D24;
	sub_822280F8(ctx, base);
	// 821D4D24: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D4D28: 48052839  bl 0x82227560
	ctx.lr = 0x821D4D2C;
	sub_82227560(ctx, base);
	// 821D4D2C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 821D4D30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D4D34: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821D4D38: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D4D3C: 4815194D  bl 0x82326688
	ctx.lr = 0x821D4D40;
	sub_82326688(ctx, base);
	// 821D4D40: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821D4D44: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821D4D48: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D4D4C: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 821D4D50: 4E800421  bctrl
	ctx.lr = 0x821D4D54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D4D54: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D4D58: 80FF0008  lwz r7, 8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D4D5C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821D4D60: 7D050034  cntlzw r5, r8
	ctx.r[5].u64 = if ctx.r[8].u32 == 0 { 32 } else { ctx.r[8].u32.leading_zeros() as u64 };
	// 821D4D64: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821D4D68: 54A4DFFE  rlwinm r4, r5, 0x1b, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[5].u32 as u64 & 0x0000001Fu64;
	// 821D4D6C: 688B0001  xori r11, r4, 1
	ctx.r[11].u64 = ctx.r[4].u64 ^ 1;
	// 821D4D70: 90C70004  stw r6, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 821D4D74: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821D4D78: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D4D7C: 394B0008  addi r10, r11, 8
	ctx.r[10].s64 = ctx.r[11].s64 + 8;
	// 821D4D80: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821D4D84: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821D4D88: 48AD46D0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D4D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D4D90 size=112
    let mut pc: u32 = 0x821D4D90;
    'dispatch: loop {
        match pc {
            0x821D4D90 => {
    //   block [0x821D4D90..0x821D4DE8)
	// 821D4D90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D4D94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D4D98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D4D9C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D4DA0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821D4DA4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 821D4DA8: 4882B921  bl 0x82a006c8
	ctx.lr = 0x821D4DAC;
	sub_82A006C8(ctx, base);
	// 821D4DAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D4DB0: 419A0038  beq cr6, 0x821d4de8
	if ctx.cr[6].eq {
	pc = 0x821D4DE8; continue 'dispatch;
	}
	// 821D4DB4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821D4DB8: 80830000  lwz r4, 0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D4DBC: 816B6DA0  lwz r11, 0x6da0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28064 as u32) ) } as u64;
	// 821D4DC0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D4DC4: 806A000C  lwz r3, 0xc(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D4DC8: 4882C349  bl 0x82a01110
	ctx.lr = 0x821D4DCC;
	sub_82A01110(ctx, base);
	// 821D4DCC: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821D4DD0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821D4DD4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821D4DD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D4DDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D4DE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D4DE4: 4E800020  blr
	return;
            }
            0x821D4DE8 => {
    //   block [0x821D4DE8..0x821D4E00)
	// 821D4DE8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821D4DEC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821D4DF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D4DF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D4DF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D4DFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D4E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D4E00 size=192
    let mut pc: u32 = 0x821D4E00;
    'dispatch: loop {
        match pc {
            0x821D4E00 => {
    //   block [0x821D4E00..0x821D4E54)
	// 821D4E00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D4E04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D4E08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821D4E0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D4E10: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D4E14: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821D4E18: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821D4E1C: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D4E20: 556A056A  rlwinm r10, r11, 0, 0x15, 0x15
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821D4E24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D4E28: 419A004C  beq cr6, 0x821d4e74
	if ctx.cr[6].eq {
	pc = 0x821D4E74; continue 'dispatch;
	}
	// 821D4E2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D4E30: 4BFEDF49  bl 0x821c2d78
	ctx.lr = 0x821D4E34;
	sub_821C2D78(ctx, base);
	// 821D4E34: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821D4E38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D4E3C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821D4E40: 4800A2C9  bl 0x821df108
	ctx.lr = 0x821D4E44;
	sub_821DF108(ctx, base);
	// 821D4E44: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821D4E48: 395F013C  addi r10, r31, 0x13c
	ctx.r[10].s64 = ctx.r[31].s64 + 316;
	// 821D4E4C: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 821D4E50: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x821D4E54; continue 'dispatch;
            }
            0x821D4E54 => {
    //   block [0x821D4E54..0x821D4E74)
	// 821D4E54: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D4E58: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821D4E5C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821D4E60: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821D4E64: 4200FFF0  bdnz 0x821d4e54
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821D4E54; continue 'dispatch;
	}
	// 821D4E68: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D4E6C: 556A05A8  rlwinm r10, r11, 0, 0x16, 0x14
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821D4E70: 915F0048  stw r10, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[10].u32 ) };
	pc = 0x821D4E74; continue 'dispatch;
            }
            0x821D4E74 => {
    //   block [0x821D4E74..0x821D4EC0)
	// 821D4E74: C01F013C  lfs f0, 0x13c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D4E78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D4E7C: C1BF0140  lfs f13, 0x140(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821D4E80: C19F0144  lfs f12, 0x144(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821D4E84: C17F0148  lfs f11, 0x148(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821D4E88: C15F014C  lfs f10, 0x14c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821D4E8C: C13F0150  lfs f9, 0x150(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821D4E90: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821D4E94: D1BE0004  stfs f13, 4(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821D4E98: D19E0008  stfs f12, 8(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821D4E9C: D17E000C  stfs f11, 0xc(r30)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821D4EA0: D15E0010  stfs f10, 0x10(r30)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821D4EA4: D13E0014  stfs f9, 0x14(r30)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821D4EA8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821D4EAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D4EB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D4EB4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821D4EB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D4EBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D4EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D4EC0 size=44
    let mut pc: u32 = 0x821D4EC0;
    'dispatch: loop {
        match pc {
            0x821D4EC0 => {
    //   block [0x821D4EC0..0x821D4EEC)
	// 821D4EC0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D4EF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D4EF0 size=40
    let mut pc: u32 = 0x821D4EF0;
    'dispatch: loop {
        match pc {
            0x821D4EF0 => {
    //   block [0x821D4EF0..0x821D4F0C)
	// 821D4EF0: 89630025  lbz r11, 0x25(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(37 as u32) ) } as u64;
	// 821D4EF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D4EF8: 409A0014  bne cr6, 0x821d4f0c
	if !ctx.cr[6].eq {
	pc = 0x821D4F0C; continue 'dispatch;
	}
	// 821D4EFC: 81630050  lwz r11, 0x50(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D4F00: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D4F04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821D4F08: 419A0008  beq cr6, 0x821d4f10
	if ctx.cr[6].eq {
	pc = 0x821D4F10; continue 'dispatch;
	}
	pc = 0x821D4F0C; continue 'dispatch;
            }
            0x821D4F0C => {
    //   block [0x821D4F0C..0x821D4F10)
	// 821D4F0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x821D4F10; continue 'dispatch;
            }
            0x821D4F10 => {
    //   block [0x821D4F10..0x821D4F18)
	// 821D4F10: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D4F14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D4F18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821D4F18 size=56
    let mut pc: u32 = 0x821D4F18;
    'dispatch: loop {
        match pc {
            0x821D4F18 => {
    //   block [0x821D4F18..0x821D4F34)
	// 821D4F18: 89630025  lbz r11, 0x25(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(37 as u32) ) } as u64;
	// 821D4F1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D4F20: 409A0014  bne cr6, 0x821d4f34
	if !ctx.cr[6].eq {
	pc = 0x821D4F34; continue 'dispatch;
	}
	// 821D4F24: 81630050  lwz r11, 0x50(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D4F28: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D4F2C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821D4F30: 419A0008  beq cr6, 0x821d4f38
	if ctx.cr[6].eq {
	pc = 0x821D4F38; continue 'dispatch;
	}
	pc = 0x821D4F34; continue 'dispatch;
            }
            0x821D4F34 => {
    //   block [0x821D4F34..0x821D4F38)
	// 821D4F34: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x821D4F38; continue 'dispatch;
            }
            0x821D4F38 => {
    //   block [0x821D4F38..0x821D4F50)
	// 821D4F38: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D4F3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D4F40: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821D4F44: 419A000C  beq cr6, 0x821d4f50
	if ctx.cr[6].eq {
		sub_821D4F50(ctx, base);
		return;
	}
	// 821D4F48: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821D4F4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D4F50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821D4F50 size=12
    let mut pc: u32 = 0x821D4F50;
    'dispatch: loop {
        match pc {
            0x821D4F50 => {
    //   block [0x821D4F50..0x821D4F5C)
	// 821D4F50: 394B9484  addi r10, r11, -0x6b7c
	ctx.r[10].s64 = ctx.r[11].s64 + -27516;
	// 821D4F54: C02A2984  lfs f1, 0x2984(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10628 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821D4F58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D4F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D4F60 size=260
    let mut pc: u32 = 0x821D4F60;
    'dispatch: loop {
        match pc {
            0x821D4F60 => {
    //   block [0x821D4F60..0x821D4FA4)
	// 821D4F60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D4F64: 48AD44A5  bl 0x82ca9408
	ctx.lr = 0x821D4F68;
	sub_82CA93D0(ctx, base);
	// 821D4F68: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D4F6C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821D4F70: 54850430  rlwinm r5, r4, 0, 0x10, 0x18
	ctx.r[5].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	// 821D4F74: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 821D4F78: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 821D4F7C: 549D067E  clrlwi r29, r4, 0x19
	ctx.r[29].u64 = ctx.r[4].u32 as u64 & 0x0000007Fu64;
	// 821D4F80: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821D4F84: 419A00B4  beq cr6, 0x821d5038
	if ctx.cr[6].eq {
	pc = 0x821D5038; continue 'dispatch;
	}
	// 821D4F88: 38830D54  addi r4, r3, 0xd54
	ctx.r[4].s64 = ctx.r[3].s64 + 3412;
	// 821D4F8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D4F90: 4BFFE231  bl 0x821d31c0
	ctx.lr = 0x821D4F94;
	sub_821D31C0(ctx, base);
	// 821D4F94: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821D4F98: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821D4F9C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D4FA0: 419A0098  beq cr6, 0x821d5038
	if ctx.cr[6].eq {
	pc = 0x821D5038; continue 'dispatch;
	}
	pc = 0x821D4FA4; continue 'dispatch;
            }
            0x821D4FA4 => {
    //   block [0x821D4FA4..0x821D4FC8)
	// 821D4FA4: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D4FA8: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D4FAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D4FB0: 419A0018  beq cr6, 0x821d4fc8
	if ctx.cr[6].eq {
	pc = 0x821D4FC8; continue 'dispatch;
	}
	// 821D4FB4: 810A0010  lwz r8, 0x10(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D4FB8: 7CEB4050  subf r7, r11, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 821D4FBC: 7CE81670  srawi r8, r7, 2
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[7].s32 >> 2) as i64;
	// 821D4FC0: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821D4FC4: 41980008  blt cr6, 0x821d4fcc
	if ctx.cr[6].lt {
	pc = 0x821D4FCC; continue 'dispatch;
	}
	pc = 0x821D4FC8; continue 'dispatch;
            }
            0x821D4FC8 => {
    //   block [0x821D4FC8..0x821D4FCC)
	// 821D4FC8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821D4FCC; continue 'dispatch;
            }
            0x821D4FCC => {
    //   block [0x821D4FCC..0x821D5004)
	// 821D4FCC: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D4FD0: 7D68582E  lwzx r11, r8, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821D4FD4: 80EB001C  lwz r7, 0x1c(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D4FD8: 7CE6F838  and r6, r7, r31
	ctx.r[6].u64 = ctx.r[7].u64 & ctx.r[31].u64;
	// 821D4FDC: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821D4FE0: 419A0040  beq cr6, 0x821d5020
	if ctx.cr[6].eq {
	pc = 0x821D5020; continue 'dispatch;
	}
	// 821D4FE4: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D4FE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D4FEC: 419A0018  beq cr6, 0x821d5004
	if ctx.cr[6].eq {
	pc = 0x821D5004; continue 'dispatch;
	}
	// 821D4FF0: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D4FF4: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D4FF8: 7CEA1670  srawi r10, r7, 2
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[7].s32 >> 2) as i64;
	// 821D4FFC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D5000: 41980008  blt cr6, 0x821d5008
	if ctx.cr[6].lt {
	pc = 0x821D5008; continue 'dispatch;
	}
	pc = 0x821D5004; continue 'dispatch;
            }
            0x821D5004 => {
    //   block [0x821D5004..0x821D5008)
	// 821D5004: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821D5008; continue 'dispatch;
            }
            0x821D5008 => {
    //   block [0x821D5008..0x821D5020)
	// 821D5008: 7C68582E  lwzx r3, r8, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821D500C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821D5010: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D5014: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D5018: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D501C: 4E800421  bctrl
	ctx.lr = 0x821D5020;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821D5020 => {
    //   block [0x821D5020..0x821D5038)
	// 821D5020: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D5024: 4802A71D  bl 0x821ff740
	ctx.lr = 0x821D5028;
	sub_821FF740(ctx, base);
	// 821D5028: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821D502C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821D5030: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D5034: 409AFF70  bne cr6, 0x821d4fa4
	if !ctx.cr[6].eq {
	pc = 0x821D4FA4; continue 'dispatch;
	}
	pc = 0x821D5038; continue 'dispatch;
            }
            0x821D5038 => {
    //   block [0x821D5038..0x821D505C)
	// 821D5038: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821D503C: 419A0020  beq cr6, 0x821d505c
	if ctx.cr[6].eq {
	pc = 0x821D505C; continue 'dispatch;
	}
	// 821D5040: 3D608219  lis r11, -0x7de7
	ctx.r[11].s64 = -2112290816;
	// 821D5044: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 821D5048: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 821D504C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821D5050: 388B2028  addi r4, r11, 0x2028
	ctx.r[4].s64 = ctx.r[11].s64 + 8232;
	// 821D5054: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D5058: 480C25A1  bl 0x822975f8
	ctx.lr = 0x821D505C;
	sub_822975F8(ctx, base);
	pc = 0x821D505C; continue 'dispatch;
            }
            0x821D505C => {
    //   block [0x821D505C..0x821D5064)
	// 821D505C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821D5060: 48AD43F8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D5068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D5068 size=220
    let mut pc: u32 = 0x821D5068;
    'dispatch: loop {
        match pc {
            0x821D5068 => {
    //   block [0x821D5068..0x821D5144)
	// 821D5068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D506C: 48AD43A1  bl 0x82ca940c
	ctx.lr = 0x821D5070;
	sub_82CA93D0(ctx, base);
	// 821D5070: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 821D5074: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D5078: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821D507C: 39400670  li r10, 0x670
	ctx.r[10].s64 = 1648;
	// 821D5080: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 821D5084: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821D5088: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821D508C: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821D5090: C3E89484  lfs f31, -0x6b7c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D5148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D5148 size=152
    let mut pc: u32 = 0x821D5148;
    'dispatch: loop {
        match pc {
            0x821D5148 => {
    //   block [0x821D5148..0x821D5160)
	// 821D5148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D514C: 48AD42C1  bl 0x82ca940c
	ctx.lr = 0x821D5150;
	sub_82CA93D0(ctx, base);
	// 821D5150: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D5154: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821D5158: 3BA00010  li r29, 0x10
	ctx.r[29].s64 = 16;
	// 821D515C: 3BFE0060  addi r31, r30, 0x60
	ctx.r[31].s64 = ctx.r[30].s64 + 96;
	pc = 0x821D5160; continue 'dispatch;
            }
            0x821D5160 => {
    //   block [0x821D5160..0x821D51A8)
	// 821D5160: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D5164: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821D5168: 419A0058  beq cr6, 0x821d51c0
	if ctx.cr[6].eq {
	pc = 0x821D51C0; continue 'dispatch;
	}
	// 821D516C: A1640072  lhz r11, 0x72(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(114 as u32) ) } as u64;
	// 821D5170: 815F0080  lwz r10, 0x80(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 821D5174: 813E1C40  lwz r9, 0x1c40(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(7232 as u32) ) } as u64;
	// 821D5178: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D517C: 7D07FE70  srawi r7, r8, 0x1f
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 31) as i64;
	// 821D5180: 7D063A78  xor r6, r8, r7
	ctx.r[6].u64 = ctx.r[8].u64 ^ ctx.r[7].u64;
	// 821D5184: 7CA73050  subf r5, r7, r6
	ctx.r[5].s64 = ctx.r[6].s64 - ctx.r[7].s64;
	// 821D5188: 7F054840  cmplw cr6, r5, r9
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821D518C: 4099001C  ble cr6, 0x821d51a8
	if !ctx.cr[6].gt {
	pc = 0x821D51A8; continue 'dispatch;
	}
	// 821D5190: 389FFFE0  addi r4, r31, -0x20
	ctx.r[4].s64 = ctx.r[31].s64 + -32;
	// 821D5194: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D5198: 488E3F91  bl 0x82ab9128
	ctx.lr = 0x821D519C;
	sub_82AB9128(ctx, base);
	// 821D519C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D51A0: A1640072  lhz r11, 0x72(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(114 as u32) ) } as u64;
	// 821D51A4: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	pc = 0x821D51A8; continue 'dispatch;
            }
            0x821D51A8 => {
    //   block [0x821D51A8..0x821D51C0)
	// 821D51A8: A164006C  lhz r11, 0x6c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(108 as u32) ) } as u64;
	// 821D51AC: 556A04A4  rlwinm r10, r11, 0, 0x12, 0x12
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821D51B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D51B4: 419A000C  beq cr6, 0x821d51c0
	if ctx.cr[6].eq {
	pc = 0x821D51C0; continue 'dispatch;
	}
	// 821D51B8: 387FFFE0  addi r3, r31, -0x20
	ctx.r[3].s64 = ctx.r[31].s64 + -32;
	// 821D51BC: 488E2DCD  bl 0x82ab7f88
	ctx.lr = 0x821D51C0;
	sub_82AB7F88(ctx, base);
	pc = 0x821D51C0; continue 'dispatch;
            }
            0x821D51C0 => {
    //   block [0x821D51C0..0x821D51E0)
	// 821D51C0: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821D51C4: 3BFF01C0  addi r31, r31, 0x1c0
	ctx.r[31].s64 = ctx.r[31].s64 + 448;
	// 821D51C8: 4082FF98  bne 0x821d5160
	if !ctx.cr[0].eq {
	pc = 0x821D5160; continue 'dispatch;
	}
	// 821D51CC: 817E1C44  lwz r11, 0x1c44(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(7236 as u32) ) } as u64;
	// 821D51D0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821D51D4: 917E1C44  stw r11, 0x1c44(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(7236 as u32), ctx.r[11].u32 ) };
	// 821D51D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D51DC: 48AD4280  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D51E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D51E0 size=112
    let mut pc: u32 = 0x821D51E0;
    'dispatch: loop {
        match pc {
            0x821D51E0 => {
    //   block [0x821D51E0..0x821D5220)
	// 821D51E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D51E4: 48AD4229  bl 0x82ca940c
	ctx.lr = 0x821D51E8;
	sub_82CA93D0(ctx, base);
	// 821D51E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D51EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D51F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821D51F4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821D51F8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821D51FC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821D5200: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821D5204: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821D5208: 419A0018  beq cr6, 0x821d5220
	if ctx.cr[6].eq {
	pc = 0x821D5220; continue 'dispatch;
	}
	// 821D520C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D5210: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D5214: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D5218: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D521C: 4E800421  bctrl
	ctx.lr = 0x821D5220;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821D5220 => {
    //   block [0x821D5220..0x821D523C)
	// 821D5220: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D5224: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D5228: 419A0014  beq cr6, 0x821d523c
	if ctx.cr[6].eq {
	pc = 0x821D523C; continue 'dispatch;
	}
	// 821D522C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D5230: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D5234: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D5238: 4E800421  bctrl
	ctx.lr = 0x821D523C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821D523C => {
    //   block [0x821D523C..0x821D5250)
	// 821D523C: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 821D5240: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D5244: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 821D5248: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D524C: 48AD4210  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D5250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D5250 size=152
    let mut pc: u32 = 0x821D5250;
    'dispatch: loop {
        match pc {
            0x821D5250 => {
    //   block [0x821D5250..0x821D52CC)
	// 821D5250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D5254: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D5258: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821D525C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D5260: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D5264: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D5268: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821D526C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821D5270: 392B26C4  addi r9, r11, 0x26c4
	ctx.r[9].s64 = ctx.r[11].s64 + 9924;
	// 821D5274: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821D5278: 390A11B0  addi r8, r10, 0x11b0
	ctx.r[8].s64 = ctx.r[10].s64 + 4528;
	// 821D527C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821D5280: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 821D5284: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 821D5288: 911F0004  stw r8, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821D528C: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 821D5290: 93FF0008  stw r31, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 821D5294: 48049FC5  bl 0x8221f258
	ctx.lr = 0x821D5298;
	sub_8221F258(ctx, base);
	// 821D5298: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821D529C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D52A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D52A4: 419A0028  beq cr6, 0x821d52cc
	if ctx.cr[6].eq {
	pc = 0x821D52CC; continue 'dispatch;
	}
	// 821D52A8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821D52AC: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 821D52B0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 821D52B4: 93CB0008  stw r30, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 821D52B8: 93CB000C  stw r30, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 821D52BC: 994B0010  stb r10, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u8 ) };
	// 821D52C0: 9BCB0011  stb r30, 0x11(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(17 as u32), ctx.r[30].u8 ) };
	// 821D52C4: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 821D52C8: 48000008  b 0x821d52d0
	pc = 0x821D52D0; continue 'dispatch;
            }
            0x821D52CC => {
    //   block [0x821D52CC..0x821D52D0)
	// 821D52CC: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	pc = 0x821D52D0; continue 'dispatch;
            }
            0x821D52D0 => {
    //   block [0x821D52D0..0x821D52E8)
	// 821D52D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D52D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D52D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D52DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821D52E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D52E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D52E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D52E8 size=204
    let mut pc: u32 = 0x821D52E8;
    'dispatch: loop {
        match pc {
            0x821D52E8 => {
    //   block [0x821D52E8..0x821D53B4)
	// 821D52E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D52EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D52F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821D52F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D52F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D52FC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821D5300: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D5304: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 821D5308: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 821D530C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D5310: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821D5314: 4808FE8D  bl 0x822651a0
	ctx.lr = 0x821D5318;
	sub_822651A0(ctx, base);
	// 821D5318: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D531C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821D5320: 813E000C  lwz r9, 0xc(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D5324: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 821D5328: 811E0010  lwz r8, 0x10(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D532C: 911F0010  stw r8, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 821D5330: 80FE0014  lwz r7, 0x14(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821D5334: 90FF0014  stw r7, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 821D5338: 80DE0018  lwz r6, 0x18(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D533C: 90DF0018  stw r6, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[6].u32 ) };
	// 821D5340: 80BE001C  lwz r5, 0x1c(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D5344: 90BF001C  stw r5, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[5].u32 ) };
	// 821D5348: 809E0020  lwz r4, 0x20(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 821D534C: 909F0020  stw r4, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 821D5350: C01E0024  lfs f0, 0x24(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D5354: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821D5358: C1BE0028  lfs f13, 0x28(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821D535C: D1BF0028  stfs f13, 0x28(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 821D5360: 807E002C  lwz r3, 0x2c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 821D5364: 907F002C  stw r3, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[3].u32 ) };
	// 821D5368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D536C: C19E0030  lfs f12, 0x30(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821D5370: D19F0030  stfs f12, 0x30(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 821D5374: C17E0034  lfs f11, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821D5378: D17F0034  stfs f11, 0x34(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821D537C: 817E0038  lwz r11, 0x38(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 821D5380: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 821D5384: 815E003C  lwz r10, 0x3c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 821D5388: 915F003C  stw r10, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[10].u32 ) };
	// 821D538C: 893E0040  lbz r9, 0x40(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 821D5390: 993F0040  stb r9, 0x40(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[9].u8 ) };
	// 821D5394: 891E0041  lbz r8, 0x41(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(65 as u32) ) } as u64;
	// 821D5398: 991F0041  stb r8, 0x41(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(65 as u32), ctx.r[8].u8 ) };
	// 821D539C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D53A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D53A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D53A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821D53AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D53B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D53B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D53B8 size=256
    let mut pc: u32 = 0x821D53B8;
    'dispatch: loop {
        match pc {
            0x821D53B8 => {
    //   block [0x821D53B8..0x821D53F0)
	// 821D53B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D53BC: 48AD4045  bl 0x82ca9400
	ctx.lr = 0x821D53C0;
	sub_82CA93D0(ctx, base);
	// 821D53C0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D53C4: F88100E8  std r4, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[4].u64 ) };
	// 821D53C8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821D53CC: 834100EC  lwz r26, 0xec(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 821D53D0: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 821D53D4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821D53D8: 83DA0004  lwz r30, 4(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D53DC: 48049E7D  bl 0x8221f258
	ctx.lr = 0x821D53E0;
	sub_8221F258(ctx, base);
	// 821D53E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D53E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821D53E8: 419A0008  beq cr6, 0x821d53f0
	if ctx.cr[6].eq {
	pc = 0x821D53F0; continue 'dispatch;
	}
	// 821D53EC: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	pc = 0x821D53F0; continue 'dispatch;
            }
            0x821D53F0 => {
    //   block [0x821D53F0..0x821D5400)
	// 821D53F0: 3B9F0004  addi r28, r31, 4
	ctx.r[28].s64 = ctx.r[31].s64 + 4;
	// 821D53F4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821D53F8: 419A0008  beq cr6, 0x821d5400
	if ctx.cr[6].eq {
	pc = 0x821D5400; continue 'dispatch;
	}
	// 821D53FC: 93DC0000  stw r30, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x821D5400; continue 'dispatch;
            }
            0x821D5400 => {
    //   block [0x821D5400..0x821D5430)
	// 821D5400: 37DF0008  addic. r30, r31, 8
	ctx.xer.ca = (ctx.r[31].u32 > (!(8 as u32)));
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821D5404: 41820038  beq 0x821d543c
	if ctx.cr[0].eq {
	pc = 0x821D543C; continue 'dispatch;
	}
	// 821D5408: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D540C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821D5410: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D5414: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D5418: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 821D541C: 419A0014  beq cr6, 0x821d5430
	if ctx.cr[6].eq {
	pc = 0x821D5430; continue 'dispatch;
	}
	// 821D5420: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D5424: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D5428: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D542C: 4E800421  bctrl
	ctx.lr = 0x821D5430;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821D5430 => {
    //   block [0x821D5430..0x821D543C)
	// 821D5430: 389D0008  addi r4, r29, 8
	ctx.r[4].s64 = ctx.r[29].s64 + 8;
	// 821D5434: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 821D5438: 4801AE09  bl 0x821f0240
	ctx.lr = 0x821D543C;
	sub_821F0240(ctx, base);
	pc = 0x821D543C; continue 'dispatch;
            }
            0x821D543C => {
    //   block [0x821D543C..0x821D5498)
	// 821D543C: 3D601555  lis r11, 0x1555
	ctx.r[11].s64 = 357892096;
	// 821D5440: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D5444: 61695555  ori r9, r11, 0x5555
	ctx.r[9].u64 = ctx.r[11].u64 | 21845;
	// 821D5448: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 821D544C: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 821D5450: 40980048  bge cr6, 0x821d5498
	if !ctx.cr[6].lt {
	pc = 0x821D5498; continue 'dispatch;
	}
	// 821D5454: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821D5458: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D545C: 388B2D94  addi r4, r11, 0x2d94
	ctx.r[4].s64 = ctx.r[11].s64 + 11668;
	// 821D5460: 4811CAE1  bl 0x822f1f40
	ctx.lr = 0x821D5464;
	sub_822F1F40(ctx, base);
	// 821D5464: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821D5468: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821D546C: 4811C945  bl 0x822f1db0
	ctx.lr = 0x821D5470;
	sub_822F1DB0(ctx, base);
	// 821D5470: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821D5474: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821D5478: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 821D547C: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 821D5480: 4811C9A1  bl 0x822f1e20
	ctx.lr = 0x821D5484;
	sub_822F1E20(ctx, base);
	// 821D5484: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 821D5488: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821D548C: 484A6355  bl 0x8267b7e0
	ctx.lr = 0x821D5490;
	sub_8267B7E0(ctx, base);
	// 821D5490: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D5494: 4BF9C37D  bl 0x82171810
	ctx.lr = 0x821D5498;
	sub_82171810(ctx, base);
	pc = 0x821D5498; continue 'dispatch;
            }
            0x821D5498 => {
    //   block [0x821D5498..0x821D54B8)
	// 821D5498: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D549C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821D54A0: 917B0008  stw r11, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821D54A4: 93FA0004  stw r31, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 821D54A8: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D54AC: 93EA0000  stw r31, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 821D54B0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821D54B4: 48AD3F9C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D54B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D54B8 size=104
    let mut pc: u32 = 0x821D54B8;
    'dispatch: loop {
        match pc {
            0x821D54B8 => {
    //   block [0x821D54B8..0x821D54E0)
	// 821D54B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D54BC: 48AD3F49  bl 0x82ca9404
	ctx.lr = 0x821D54C0;
	sub_82CA93D0(ctx, base);
	// 821D54C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D54C4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821D54C8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 821D54CC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 821D54D0: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 821D54D4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 821D54D8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821D54DC: 419A0034  beq cr6, 0x821d5510
	if ctx.cr[6].eq {
	pc = 0x821D5510; continue 'dispatch;
	}
	pc = 0x821D54E0; continue 'dispatch;
            }
            0x821D54E0 => {
    //   block [0x821D54E0..0x821D5504)
	// 821D54E0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821D54E4: 419A0020  beq cr6, 0x821d5504
	if ctx.cr[6].eq {
	pc = 0x821D5504; continue 'dispatch;
	}
	// 821D54E8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821D54EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D54F0: 4BFC1881  bl 0x82196d70
	ctx.lr = 0x821D54F4;
	sub_82196D70(ctx, base);
	// 821D54F4: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D54F8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821D54FC: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D5500: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	pc = 0x821D5504; continue 'dispatch;
            }
            0x821D5504 => {
    //   block [0x821D5504..0x821D5510)
	// 821D5504: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821D5508: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 821D550C: 4082FFD4  bne 0x821d54e0
	if !ctx.cr[0].eq {
	pc = 0x821D54E0; continue 'dispatch;
	}
	pc = 0x821D5510; continue 'dispatch;
            }
            0x821D5510 => {
    //   block [0x821D5510..0x821D5520)
	// 821D5510: 57AB2036  slwi r11, r29, 4
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D5514: 7C6BDA14  add r3, r11, r27
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 821D5518: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821D551C: 48AD3F38  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D5520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D5520 size=60
    let mut pc: u32 = 0x821D5520;
    'dispatch: loop {
        match pc {
            0x821D5520 => {
    //   block [0x821D5520..0x821D5554)
	// 821D5520: 81630058  lwz r11, 0x58(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) } as u64;
	// 821D5524: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821D5528: 419A002C  beq cr6, 0x821d5554
	if ctx.cr[6].eq {
	pc = 0x821D5554; continue 'dispatch;
	}
	// 821D552C: 8163004C  lwz r11, 0x4c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D5530: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D5534: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821D5538: 7D283671  srawi. r8, r9, 6
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 6) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 6) as i64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821D553C: 41820018  beq 0x821d5554
	if ctx.cr[0].eq {
	pc = 0x821D5554; continue 'dispatch;
	}
	// 821D5540: 81630054  lwz r11, 0x54(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D5544: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821D5548: 7D6A2038  and r10, r11, r4
	ctx.r[10].u64 = ctx.r[11].u64 & ctx.r[4].u64;
	// 821D554C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D5550: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	pc = 0x821D5554; continue 'dispatch;
            }
            0x821D5554 => {
    //   block [0x821D5554..0x821D555C)
	// 821D5554: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821D5558: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D5560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D5560 size=64
    let mut pc: u32 = 0x821D5560;
    'dispatch: loop {
        match pc {
            0x821D5560 => {
    //   block [0x821D5560..0x821D55A0)
	// 821D5560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D5564: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D5568: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D556C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D5570: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D5574: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821D5578: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D557C: 994B000C  stb r10, 0xc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u8 ) };
	// 821D5580: 80840010  lwz r4, 0x10(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D5584: 4800001D  bl 0x821d55a0
	ctx.lr = 0x821D5588;
	sub_821D55A0(ctx, base);
	// 821D5588: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D558C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821D5590: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D5594: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D5598: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D559C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D55A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D55A0 size=132
    let mut pc: u32 = 0x821D55A0;
    'dispatch: loop {
        match pc {
            0x821D55A0 => {
    //   block [0x821D55A0..0x821D55D8)
	// 821D55A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D55A4: 48AD3E65  bl 0x82ca9408
	ctx.lr = 0x821D55A8;
	sub_82CA93D0(ctx, base);
	// 821D55A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D55AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821D55B0: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 821D55B4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821D55B8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821D55BC: 48049C9D  bl 0x8221f258
	ctx.lr = 0x821D55C0;
	sub_8221F258(ctx, base);
	// 821D55C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D55C4: 419A0014  beq cr6, 0x821d55d8
	if ctx.cr[6].eq {
	pc = 0x821D55D8; continue 'dispatch;
	}
	// 821D55C8: 4BFFFC89  bl 0x821d5250
	ctx.lr = 0x821D55CC;
	sub_821D5250(ctx, base);
	// 821D55CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D55D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821D55D4: 409A001C  bne cr6, 0x821d55f0
	if !ctx.cr[6].eq {
	pc = 0x821D55F0; continue 'dispatch;
	}
	pc = 0x821D55D8; continue 'dispatch;
            }
            0x821D55D8 => {
    //   block [0x821D55D8..0x821D55F0)
	// 821D55D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821D55DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D55E0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821D55E4: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821D55E8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821D55EC: 48AD3E6C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x821D55F0 => {
    //   block [0x821D55F0..0x821D5624)
	// 821D55F0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821D55F4: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D55F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D55FC: 4800094D  bl 0x821d5f48
	ctx.lr = 0x821D5600;
	sub_821D5F48(ctx, base);
	// 821D5600: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D5604: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 821D5608: 997D000C  stb r11, 0xc(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 821D560C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D5610: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D5614: 4BFFFBCD  bl 0x821d51e0
	ctx.lr = 0x821D5618;
	sub_821D51E0(ctx, base);
	// 821D5618: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D561C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821D5620: 48AD3E38  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D5628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D5628 size=440
    let mut pc: u32 = 0x821D5628;
    'dispatch: loop {
        match pc {
            0x821D5628 => {
    //   block [0x821D5628..0x821D567C)
	// 821D5628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D562C: 48AD3DC9  bl 0x82ca93f4
	ctx.lr = 0x821D5630;
	sub_82CA93D0(ctx, base);
	// 821D5630: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D5634: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 821D5638: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D563C: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 821D5640: 3B1F0004  addi r24, r31, 4
	ctx.r[24].s64 = ctx.r[31].s64 + 4;
	// 821D5644: 817A0014  lwz r11, 0x14(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 821D5648: 92FF0000  stw r23, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 821D564C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D5650: 3B2B0D54  addi r25, r11, 0xd54
	ctx.r[25].s64 = ctx.r[11].s64 + 3412;
	// 821D5654: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D5658: 7F032840  cmplw cr6, r3, r5
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821D565C: 419A0024  beq cr6, 0x821d5680
	if ctx.cr[6].eq {
	pc = 0x821D5680; continue 'dispatch;
	}
	// 821D5660: 7D652850  subf r11, r5, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[5].s64;
	// 821D5664: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D5668: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821D566C: 7FC61A14  add r30, r6, r3
	ctx.r[30].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 821D5670: 4081000C  ble 0x821d567c
	if !ctx.cr[0].gt {
	pc = 0x821D567C; continue 'dispatch;
	}
	// 821D5674: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 821D5678: 48AD49B1  bl 0x82caa028
	ctx.lr = 0x821D567C;
	sub_82CAA028(ctx, base);
	pc = 0x821D567C; continue 'dispatch;
            }
            0x821D567C => {
    //   block [0x821D567C..0x821D5680)
	// 821D567C: 93D80008  stw r30, 8(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	pc = 0x821D5680; continue 'dispatch;
            }
            0x821D5680 => {
    //   block [0x821D5680..0x821D56B0)
	// 821D5680: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D5684: 3B7F0014  addi r27, r31, 0x14
	ctx.r[27].s64 = ctx.r[31].s64 + 20;
	// 821D5688: 80BF001C  lwz r5, 0x1c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D568C: 7F032840  cmplw cr6, r3, r5
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821D5690: 419A0024  beq cr6, 0x821d56b4
	if ctx.cr[6].eq {
	pc = 0x821D56B4; continue 'dispatch;
	}
	// 821D5694: 7D652850  subf r11, r5, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[5].s64;
	// 821D5698: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D569C: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821D56A0: 7FC61A14  add r30, r6, r3
	ctx.r[30].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 821D56A4: 4081000C  ble 0x821d56b0
	if !ctx.cr[0].gt {
	pc = 0x821D56B0; continue 'dispatch;
	}
	// 821D56A8: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 821D56AC: 48AD497D  bl 0x82caa028
	ctx.lr = 0x821D56B0;
	sub_82CAA028(ctx, base);
	pc = 0x821D56B0; continue 'dispatch;
            }
            0x821D56B0 => {
    //   block [0x821D56B0..0x821D56B4)
	// 821D56B0: 93DB0008  stw r30, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	pc = 0x821D56B4; continue 'dispatch;
            }
            0x821D56B4 => {
    //   block [0x821D56B4..0x821D56E4)
	// 821D56B4: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D56B8: 3B9F0024  addi r28, r31, 0x24
	ctx.r[28].s64 = ctx.r[31].s64 + 36;
	// 821D56BC: 80BF002C  lwz r5, 0x2c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821D56C0: 7F032840  cmplw cr6, r3, r5
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821D56C4: 419A0024  beq cr6, 0x821d56e8
	if ctx.cr[6].eq {
	pc = 0x821D56E8; continue 'dispatch;
	}
	// 821D56C8: 7D652850  subf r11, r5, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[5].s64;
	// 821D56CC: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D56D0: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821D56D4: 7FC61A14  add r30, r6, r3
	ctx.r[30].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 821D56D8: 4081000C  ble 0x821d56e4
	if !ctx.cr[0].gt {
	pc = 0x821D56E4; continue 'dispatch;
	}
	// 821D56DC: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 821D56E0: 48AD4949  bl 0x82caa028
	ctx.lr = 0x821D56E4;
	sub_82CAA028(ctx, base);
	pc = 0x821D56E4; continue 'dispatch;
            }
            0x821D56E4 => {
    //   block [0x821D56E4..0x821D56E8)
	// 821D56E4: 93DC0008  stw r30, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	pc = 0x821D56E8; continue 'dispatch;
            }
            0x821D56E8 => {
    //   block [0x821D56E8..0x821D5718)
	// 821D56E8: 807F0040  lwz r3, 0x40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 821D56EC: 3BDF003C  addi r30, r31, 0x3c
	ctx.r[30].s64 = ctx.r[31].s64 + 60;
	// 821D56F0: 80BF0044  lwz r5, 0x44(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 821D56F4: 7F032840  cmplw cr6, r3, r5
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821D56F8: 419A0024  beq cr6, 0x821d571c
	if ctx.cr[6].eq {
	pc = 0x821D571C; continue 'dispatch;
	}
	// 821D56FC: 7D652850  subf r11, r5, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[5].s64;
	// 821D5700: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D5704: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821D5708: 7FA61A14  add r29, r6, r3
	ctx.r[29].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 821D570C: 4081000C  ble 0x821d5718
	if !ctx.cr[0].gt {
	pc = 0x821D5718; continue 'dispatch;
	}
	// 821D5710: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 821D5714: 48AD4915  bl 0x82caa028
	ctx.lr = 0x821D5718;
	sub_82CAA028(ctx, base);
	pc = 0x821D5718; continue 'dispatch;
            }
            0x821D5718 => {
    //   block [0x821D5718..0x821D571C)
	// 821D5718: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	pc = 0x821D571C; continue 'dispatch;
            }
            0x821D571C => {
    //   block [0x821D571C..0x821D5768)
	// 821D571C: 92FF0034  stw r23, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[23].u32 ) };
	// 821D5720: 38A0000B  li r5, 0xb
	ctx.r[5].s64 = 11;
	// 821D5724: 92FF0038  stw r23, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[23].u32 ) };
	// 821D5728: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821D572C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D5730: 4801ED51  bl 0x821f4480
	ctx.lr = 0x821D5734;
	sub_821F4480(ctx, base);
	// 821D5734: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821D5738: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821D573C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D5740: 419A003C  beq cr6, 0x821d577c
	if ctx.cr[6].eq {
	pc = 0x821D577C; continue 'dispatch;
	}
	// 821D5744: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D5748: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D574C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D5750: 419A0018  beq cr6, 0x821d5768
	if ctx.cr[6].eq {
	pc = 0x821D5768; continue 'dispatch;
	}
	// 821D5754: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D5758: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D575C: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 821D5760: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D5764: 41980008  blt cr6, 0x821d576c
	if ctx.cr[6].lt {
	pc = 0x821D576C; continue 'dispatch;
	}
	pc = 0x821D5768; continue 'dispatch;
            }
            0x821D5768 => {
    //   block [0x821D5768..0x821D576C)
	// 821D5768: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821D576C; continue 'dispatch;
            }
            0x821D576C => {
    //   block [0x821D576C..0x821D577C)
	// 821D576C: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D5770: 7D2A582E  lwzx r9, r10, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821D5774: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821D5778: 48000010  b 0x821d5788
	pc = 0x821D5788; continue 'dispatch;
            }
            0x821D577C => {
    //   block [0x821D577C..0x821D5788)
	// 821D577C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821D5780: 816B6E94  lwz r11, 0x6e94(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28308 as u32) ) } as u64;
	// 821D5784: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x821D5788; continue 'dispatch;
            }
            0x821D5788 => {
    //   block [0x821D5788..0x821D57E0)
	// 821D5788: 38E0000A  li r7, 0xa
	ctx.r[7].s64 = 10;
	// 821D578C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 821D5790: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 821D5794: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821D5798: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821D579C: 4BFE792D  bl 0x821bd0c8
	ctx.lr = 0x821D57A0;
	sub_821BD0C8(ctx, base);
	// 821D57A0: 38E00009  li r7, 9
	ctx.r[7].s64 = 9;
	// 821D57A4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 821D57A8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821D57AC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821D57B0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821D57B4: 480065DD  bl 0x821dbd90
	ctx.lr = 0x821D57B8;
	sub_821DBD90(ctx, base);
	// 821D57B8: 907F0034  stw r3, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[3].u32 ) };
	// 821D57BC: 38E00008  li r7, 8
	ctx.r[7].s64 = 8;
	// 821D57C0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 821D57C4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821D57C8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821D57CC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821D57D0: 4802A3F1  bl 0x821ffbc0
	ctx.lr = 0x821D57D4;
	sub_821FFBC0(ctx, base);
	// 821D57D4: 907F0038  stw r3, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[3].u32 ) };
	// 821D57D8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821D57DC: 48AD3C68  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D57E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D57E0 size=1828
    let mut pc: u32 = 0x821D57E0;
    'dispatch: loop {
        match pc {
            0x821D57E0 => {
    //   block [0x821D57E0..0x821D5F04)
	// 821D57E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D57E4: 48AD3C15  bl 0x82ca93f8
	ctx.lr = 0x821D57E8;
	sub_82CA93D0(ctx, base);
	// 821D57E8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D57EC: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 821D57F0: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 821D57F4: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821D57F8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821D57FC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D5800: C0099A80  lfs f0, -0x6580(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D5804: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821D5808: 3B6B0010  addi r27, r11, 0x10
	ctx.r[27].s64 = ctx.r[11].s64 + 16;
	// 821D580C: 3B1B0430  addi r24, r27, 0x430
	ctx.r[24].s64 = ctx.r[27].s64 + 1072;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


