pub fn sub_82ED3A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ED3A50 size=2032
    let mut pc: u32 = 0x82ED3A50;
    'dispatch: loop {
        match pc {
            0x82ED3A50 => {
    //   block [0x82ED3A50..0x82ED3AEC)
	// 82ED3A50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED3A54: 4BDD597D  bl 0x82ca93d0
	ctx.lr = 0x82ED3A58;
	sub_82CA93D0(ctx, base);
	// 82ED3A58: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 82ED3A5C: 4BDDA279  bl 0x82cadcd4
	ctx.lr = 0x82ED3A60;
	sub_82CADCA0(ctx, base);
	// 82ED3A60: 9421FDD0  stwu r1, -0x230(r1)
	ea = ctx.r[1].u32.wrapping_add(-560 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED3A64: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 82ED3A68: 98C1025F  stb r6, 0x25f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(607 as u32), ctx.r[6].u8 ) };
	// 82ED3A6C: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82ED3A70: 90E10264  stw r7, 0x264(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(612 as u32), ctx.r[7].u32 ) };
	// 82ED3A74: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED3A78: 9101026C  stw r8, 0x26c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(620 as u32), ctx.r[8].u32 ) };
	// 82ED3A7C: 99210277  stb r9, 0x277(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(631 as u32), ctx.r[9].u8 ) };
	// 82ED3A80: 7D5A5378  mr r26, r10
	ctx.r[26].u64 = ctx.r[10].u64;
	// 82ED3A84: 3A380004  addi r17, r24, 4
	ctx.r[17].s64 = ctx.r[24].s64 + 4;
	// 82ED3A88: C0180000  lfs f0, 0(r24)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED3A8C: 3A790004  addi r19, r25, 4
	ctx.r[19].s64 = ctx.r[25].s64 + 4;
	// 82ED3A90: C1B90000  lfs f13, 0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED3A94: 3A180008  addi r16, r24, 8
	ctx.r[16].s64 = ctx.r[24].s64 + 8;
	// 82ED3A98: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82ED3A9C: C0190004  lfs f0, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED3AA0: C1980004  lfs f12, 4(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED3AA4: 3A590008  addi r18, r25, 8
	ctx.r[18].s64 = ctx.r[25].s64 + 8;
	// 82ED3AA8: ED8C002A  fadds f12, f12, f0
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82ED3AAC: C0180008  lfs f0, 8(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED3AB0: C1790008  lfs f11, 8(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED3AB4: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 82ED3AB8: ED6B002A  fadds f11, f11, f0
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82ED3ABC: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED3AC0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ED3AC4: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 82ED3AC8: 39CB09A8  addi r14, r11, 0x9a8
	ctx.r[14].s64 = ctx.r[11].s64 + 2472;
	// 82ED3ACC: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 82ED3AD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ED3AD4: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED3AD8: EFCC0032  fmuls f30, f12, f0
	ctx.f[30].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED3ADC: 91C1005C  stw r14, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[14].u32 ) };
	// 82ED3AE0: EFAB0032  fmuls f29, f11, f0
	ctx.f[29].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED3AE4: 419A0530  beq cr6, 0x82ed4014
	if ctx.cr[6].eq {
	pc = 0x82ED4014; continue 'dispatch;
	}
	// 82ED3AE8: 39E00003  li r15, 3
	ctx.r[15].s64 = 3;
	pc = 0x82ED3AEC; continue 'dispatch;
            }
            0x82ED3AEC => {
    //   block [0x82ED3AEC..0x82ED3C18)
	// 82ED3AEC: 82F50014  lwz r23, 0x14(r21)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED3AF0: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82ED3AF4: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED3AF8: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED3AFC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED3B00: 4E800421  bctrl
	ctx.lr = 0x82ED3B04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED3B04: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED3B08: 41820500  beq 0x82ed4008
	if ctx.cr[0].eq {
	pc = 0x82ED4008; continue 'dispatch;
	}
	// 82ED3B0C: 81570004  lwz r10, 4(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED3B10: 391A001C  addi r8, r26, 0x1c
	ctx.r[8].s64 = ctx.r[26].s64 + 28;
	// 82ED3B14: 8177002C  lwz r11, 0x2c(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED3B18: 3923FFFF  addi r9, r3, -1
	ctx.r[9].s64 = ctx.r[3].s64 + -1;
	// 82ED3B1C: C0190000  lfs f0, 0(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED3B20: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82ED3B24: 814A007C  lwz r10, 0x7c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(124 as u32) ) } as u64;
	// 82ED3B28: 7CE85A2E  lhzx r7, r8, r11
	ctx.r[7].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ED3B2C: 7D2951D6  mullw r9, r9, r10
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82ED3B30: 7D4751D6  mullw r10, r7, r10
	ctx.r[10].s32 = ((ctx.r[7].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82ED3B34: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82ED3B38: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82ED3B3C: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED3B40: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ED3B44: 409804C4  bge cr6, 0x82ed4008
	if !ctx.cr[6].lt {
	pc = 0x82ED4008; continue 'dispatch;
	}
	// 82ED3B48: 81570004  lwz r10, 4(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED3B4C: 38FA001E  addi r7, r26, 0x1e
	ctx.r[7].s64 = ctx.r[26].s64 + 30;
	// 82ED3B50: 557F003E  slwi r31, r11, 0
	ctx.r[31].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82ED3B54: C0130000  lfs f0, 0(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED3B58: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82ED3B5C: 83CA007C  lwz r30, 0x7c(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(124 as u32) ) } as u64;
	// 82ED3B60: 7D475A2E  lhzx r10, r7, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ED3B64: 7D4AF1D6  mullw r10, r10, r30
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[30].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82ED3B68: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82ED3B6C: C1AA0008  lfs f13, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED3B70: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ED3B74: 40980494  bge cr6, 0x82ed4008
	if !ctx.cr[6].lt {
	pc = 0x82ED4008; continue 'dispatch;
	}
	// 82ED3B78: 38DA0020  addi r6, r26, 0x20
	ctx.r[6].s64 = ctx.r[26].s64 + 32;
	// 82ED3B7C: C0120000  lfs f0, 0(r18)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED3B80: D00100A0  stfs f0, 0xa0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82ED3B84: 7D465A2E  lhzx r10, r6, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ED3B88: 7D4AF1D6  mullw r10, r10, r30
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[30].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82ED3B8C: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82ED3B90: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED3B94: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ED3B98: 40980470  bge cr6, 0x82ed4008
	if !ctx.cr[6].lt {
	pc = 0x82ED4008; continue 'dispatch;
	}
	// 82ED3B9C: 7D484A2E  lhzx r10, r8, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82ED3BA0: C0180000  lfs f0, 0(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED3BA4: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82ED3BA8: 7D4AF1D6  mullw r10, r10, r30
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[30].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82ED3BAC: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82ED3BB0: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED3BB4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ED3BB8: 40990450  ble cr6, 0x82ed4008
	if !ctx.cr[6].gt {
	pc = 0x82ED4008; continue 'dispatch;
	}
	// 82ED3BBC: 7D474A2E  lhzx r10, r7, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82ED3BC0: C0110000  lfs f0, 0(r17)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED3BC4: D001009C  stfs f0, 0x9c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82ED3BC8: 7D4AF1D6  mullw r10, r10, r30
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[30].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82ED3BCC: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82ED3BD0: C1AA0008  lfs f13, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED3BD4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ED3BD8: 40990430  ble cr6, 0x82ed4008
	if !ctx.cr[6].gt {
	pc = 0x82ED4008; continue 'dispatch;
	}
	// 82ED3BDC: 7D464A2E  lhzx r10, r6, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82ED3BE0: C0100000  lfs f0, 0(r16)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED3BE4: D00100A4  stfs f0, 0xa4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82ED3BE8: 7D4AF1D6  mullw r10, r10, r30
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[30].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82ED3BEC: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82ED3BF0: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED3BF4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ED3BF8: 40990410  ble cr6, 0x82ed4008
	if !ctx.cr[6].gt {
	pc = 0x82ED4008; continue 'dispatch;
	}
	// 82ED3BFC: 7D09D214  add r8, r9, r26
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[26].u64;
	// 82ED3C00: 3B83FFFF  addi r28, r3, -1
	ctx.r[28].s64 = ctx.r[3].s64 + -1;
	// 82ED3C04: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ED3C08: 3BA10090  addi r29, r1, 0x90
	ctx.r[29].s64 = ctx.r[1].s64 + 144;
	// 82ED3C0C: 3880001C  li r4, 0x1c
	ctx.r[4].s64 = 28;
	// 82ED3C10: 3868001C  addi r3, r8, 0x1c
	ctx.r[3].s64 = ctx.r[8].s64 + 28;
	// 82ED3C14: 7F695850  subf r27, r9, r11
	ctx.r[27].s64 = ctx.r[11].s64 - ctx.r[9].s64;
            }
            0x82ED3C18 => {
    //   block [0x82ED3C18..0x82ED3C48)
	// 82ED3C18: 7D7B1A2E  lhzx r11, r27, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82ED3C1C: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED3C20: 7D6BF1D6  mullw r11, r11, r30
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[30].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82ED3C24: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ED3C28: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82ED3C2C: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED3C30: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED3C34: 40980014  bge cr6, 0x82ed3c48
	if !ctx.cr[6].lt {
	pc = 0x82ED3C48; continue 'dispatch;
	}
	// 82ED3C38: 39610068  addi r11, r1, 0x68
	ctx.r[11].s64 = ctx.r[1].s64 + 104;
	// 82ED3C3C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82ED3C40: 7D2A592E  stwx r9, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u32) };
	// 82ED3C44: 48000070  b 0x82ed3cb4
	pc = 0x82ED3CB4; continue 'dispatch;
            }
            0x82ED3C48 => {
    //   block [0x82ED3C48..0x82ED3C64)
	// 82ED3C48: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 82ED3C4C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82ED3C50: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 82ED3C54: 40990058  ble cr6, 0x82ed3cac
	if !ctx.cr[6].gt {
	pc = 0x82ED3CAC; continue 'dispatch;
	}
	// 82ED3C58: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED3C5C: 80F7002C  lwz r7, 0x2c(r23)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED3C60: 80CB007C  lwz r6, 0x7c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	pc = 0x82ED3C64; continue 'dispatch;
            }
            0x82ED3C64 => {
    //   block [0x82ED3C64..0x82ED3C9C)
	// 82ED3C64: 7D682A14  add r11, r8, r5
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[5].u64;
	// 82ED3C68: 556BF87E  srwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED3C6C: 7D2B31D6  mullw r9, r11, r6
	ctx.r[9].s32 = ((ctx.r[11].s32 as i64 * ctx.r[6].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82ED3C70: 7D292214  add r9, r9, r4
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[4].u64;
	// 82ED3C74: 7D293A14  add r9, r9, r7
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[7].u64;
	// 82ED3C78: 7D29D22E  lhzx r9, r9, r26
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82ED3C7C: 7D2931D6  mullw r9, r9, r6
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * ctx.r[6].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82ED3C80: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82ED3C84: 7D293A14  add r9, r9, r7
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[7].u64;
	// 82ED3C88: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED3C8C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ED3C90: 4099000C  ble cr6, 0x82ed3c9c
	if !ctx.cr[6].gt {
	pc = 0x82ED3C9C; continue 'dispatch;
	}
	// 82ED3C94: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82ED3C98: 48000008  b 0x82ed3ca0
	pc = 0x82ED3CA0; continue 'dispatch;
            }
            0x82ED3C9C => {
    //   block [0x82ED3C9C..0x82ED3CA0)
	// 82ED3C9C: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	pc = 0x82ED3CA0; continue 'dispatch;
            }
            0x82ED3CA0 => {
    //   block [0x82ED3CA0..0x82ED3CAC)
	// 82ED3CA0: 7D654050  subf r11, r5, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[5].s64;
	// 82ED3CA4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ED3CA8: 4199FFBC  bgt cr6, 0x82ed3c64
	if ctx.cr[6].gt {
	pc = 0x82ED3C64; continue 'dispatch;
	}
	pc = 0x82ED3CAC; continue 'dispatch;
            }
            0x82ED3CAC => {
    //   block [0x82ED3CAC..0x82ED3CB4)
	// 82ED3CAC: 39610068  addi r11, r1, 0x68
	ctx.r[11].s64 = ctx.r[1].s64 + 104;
	// 82ED3CB0: 7D0A592E  stwx r8, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[8].u32) };
	pc = 0x82ED3CB4; continue 'dispatch;
            }
            0x82ED3CB4 => {
    //   block [0x82ED3CB4..0x82ED3CE0)
	// 82ED3CB4: A1630000  lhz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED3CB8: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED3CBC: 7D6BF1D6  mullw r11, r11, r30
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[30].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82ED3CC0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ED3CC4: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82ED3CC8: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED3CCC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED3CD0: 40990010  ble cr6, 0x82ed3ce0
	if !ctx.cr[6].gt {
	pc = 0x82ED3CE0; continue 'dispatch;
	}
	// 82ED3CD4: 39610078  addi r11, r1, 0x78
	ctx.r[11].s64 = ctx.r[1].s64 + 120;
	// 82ED3CD8: 7F8A592E  stwx r28, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[28].u32) };
	// 82ED3CDC: 48000070  b 0x82ed3d4c
	pc = 0x82ED3D4C; continue 'dispatch;
            }
            0x82ED3CE0 => {
    //   block [0x82ED3CE0..0x82ED3CFC)
	// 82ED3CE0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82ED3CE4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82ED3CE8: 2B060001  cmplwi cr6, r6, 1
	ctx.cr[6].compare_u32(ctx.r[6].u32, 1 as u32, &mut ctx.xer);
	// 82ED3CEC: 40990058  ble cr6, 0x82ed3d44
	if !ctx.cr[6].gt {
	pc = 0x82ED3D44; continue 'dispatch;
	}
	// 82ED3CF0: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED3CF4: 8117002C  lwz r8, 0x2c(r23)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED3CF8: 80EB007C  lwz r7, 0x7c(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	pc = 0x82ED3CFC; continue 'dispatch;
            }
            0x82ED3CFC => {
    //   block [0x82ED3CFC..0x82ED3D34)
	// 82ED3CFC: 7D662A14  add r11, r6, r5
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[5].u64;
	// 82ED3D00: 556BF87E  srwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED3D04: 7D2759D6  mullw r9, r7, r11
	ctx.r[9].s32 = ((ctx.r[7].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82ED3D08: 7D292214  add r9, r9, r4
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[4].u64;
	// 82ED3D0C: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82ED3D10: 7D29D22E  lhzx r9, r9, r26
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82ED3D14: 7D2939D6  mullw r9, r9, r7
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * ctx.r[7].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82ED3D18: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82ED3D1C: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82ED3D20: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED3D24: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ED3D28: 4198000C  blt cr6, 0x82ed3d34
	if ctx.cr[6].lt {
	pc = 0x82ED3D34; continue 'dispatch;
	}
	// 82ED3D2C: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82ED3D30: 48000008  b 0x82ed3d38
	pc = 0x82ED3D38; continue 'dispatch;
            }
            0x82ED3D34 => {
    //   block [0x82ED3D34..0x82ED3D38)
	// 82ED3D34: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	pc = 0x82ED3D38; continue 'dispatch;
            }
            0x82ED3D38 => {
    //   block [0x82ED3D38..0x82ED3D44)
	// 82ED3D38: 7D653050  subf r11, r5, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[5].s64;
	// 82ED3D3C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ED3D40: 4199FFBC  bgt cr6, 0x82ed3cfc
	if ctx.cr[6].gt {
	pc = 0x82ED3CFC; continue 'dispatch;
	}
	pc = 0x82ED3D44; continue 'dispatch;
            }
            0x82ED3D44 => {
    //   block [0x82ED3D44..0x82ED3D4C)
	// 82ED3D44: 39610078  addi r11, r1, 0x78
	ctx.r[11].s64 = ctx.r[1].s64 + 120;
	// 82ED3D48: 7CAA592E  stwx r5, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[5].u32) };
	pc = 0x82ED3D4C; continue 'dispatch;
            }
            0x82ED3D4C => {
    //   block [0x82ED3D4C..0x82ED3D98)
	// 82ED3D4C: 38840002  addi r4, r4, 2
	ctx.r[4].s64 = ctx.r[4].s64 + 2;
	// 82ED3D50: 38630002  addi r3, r3, 2
	ctx.r[3].s64 = ctx.r[3].s64 + 2;
	// 82ED3D54: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82ED3D58: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82ED3D5C: 2B040022  cmplwi cr6, r4, 0x22
	ctx.cr[6].compare_u32(ctx.r[4].u32, 34 as u32, &mut ctx.xer);
	// 82ED3D60: 4198FEB8  blt cr6, 0x82ed3c18
	if ctx.cr[6].lt {
	pc = 0x82ED3C18; continue 'dispatch;
	}
	// 82ED3D64: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82ED3D68: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82ED3D6C: 8121007C  lwz r9, 0x7c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82ED3D70: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82ED3D74: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82ED3D78: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82ED3D7C: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	// 82ED3D80: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ED3D84: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ED3D88: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82ED3D8C: 4098000C  bge cr6, 0x82ed3d98
	if !ctx.cr[6].lt {
	pc = 0x82ED3D98; continue 'dispatch;
	}
	// 82ED3D90: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ED3D94: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	pc = 0x82ED3D98; continue 'dispatch;
            }
            0x82ED3D98 => {
    //   block [0x82ED3D98..0x82ED3DB8)
	// 82ED3D98: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82ED3D9C: 81210080  lwz r9, 0x80(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82ED3DA0: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82ED3DA4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ED3DA8: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82ED3DAC: 4098000C  bge cr6, 0x82ed3db8
	if !ctx.cr[6].lt {
	pc = 0x82ED3DB8; continue 'dispatch;
	}
	// 82ED3DB0: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82ED3DB4: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	pc = 0x82ED3DB8; continue 'dispatch;
            }
            0x82ED3DB8 => {
    //   block [0x82ED3DB8..0x82ED3E00)
	// 82ED3DB8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82ED3DBC: 419A024C  beq cr6, 0x82ed4008
	if ctx.cr[6].eq {
	pc = 0x82ED4008; continue 'dispatch;
	}
	// 82ED3DC0: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 82ED3DC4: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ED3DC8: 7D097B96  divwu r8, r9, r15
	ctx.r[8].u32 = ctx.r[9].u32 / ctx.r[15].u32;
	// 82ED3DCC: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 82ED3DD0: 1D080003  mulli r8, r8, 3
	ctx.r[8].s32 = ((ctx.r[8].s32 as i64 * 3 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82ED3DD4: 7C8A382E  lwzx r4, r10, r7
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82ED3DD8: 38CB000E  addi r6, r11, 0xe
	ctx.r[6].s64 = ctx.r[11].s64 + 14;
	// 82ED3DDC: 7CA84850  subf r5, r8, r9
	ctx.r[5].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82ED3DE0: 81210264  lwz r9, 0x264(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(612 as u32) ) } as u64;
	// 82ED3DE4: 568A103A  slwi r10, r20, 2
	ctx.r[10].u32 = ctx.r[20].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ED3DE8: 56CB1838  slwi r11, r22, 3
	ctx.r[11].u32 = ctx.r[22].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED3DEC: 7EDBB378  mr r27, r22
	ctx.r[27].u64 = ctx.r[22].u64;
	// 82ED3DF0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82ED3DF4: 54C3083C  slwi r3, r6, 1
	ctx.r[3].u32 = ctx.r[6].u32.wrapping_shl(1);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82ED3DF8: 7FEA4A14  add r31, r10, r9
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82ED3DFC: 7FCB7214  add r30, r11, r14
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[14].u64;
	pc = 0x82ED3E00; continue 'dispatch;
            }
            0x82ED3E00 => {
    //   block [0x82ED3E00..0x82ED3E58)
	// 82ED3E00: 81570004  lwz r10, 4(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED3E04: 2C050000  cmpwi r5, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED3E08: 8177002C  lwz r11, 0x2c(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED3E0C: 814A007C  lwz r10, 0x7c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(124 as u32) ) } as u64;
	// 82ED3E10: 7D2451D6  mullw r9, r4, r10
	ctx.r[9].s32 = ((ctx.r[4].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82ED3E14: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82ED3E18: 7D291A14  add r9, r9, r3
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[3].u64;
	// 82ED3E1C: 7D29D22E  lhzx r9, r9, r26
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82ED3E20: 7D4951D6  mullw r10, r9, r10
	ctx.r[10].s32 = ((ctx.r[9].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82ED3E24: 7CCA5A14  add r6, r10, r11
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82ED3E28: C0060004  lfs f0, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED3E2C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82ED3E30: C0060008  lfs f0, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED3E34: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82ED3E38: C006000C  lfs f0, 0xc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED3E3C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82ED3E40: 4182002C  beq 0x82ed3e6c
	if ctx.cr[0].eq {
	pc = 0x82ED3E6C; continue 'dispatch;
	}
	// 82ED3E44: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82ED3E48: 409A0010  bne cr6, 0x82ed3e58
	if !ctx.cr[6].eq {
	pc = 0x82ED3E58; continue 'dispatch;
	}
	// 82ED3E4C: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 82ED3E50: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 82ED3E54: 48000020  b 0x82ed3e74
	pc = 0x82ED3E74; continue 'dispatch;
            }
            0x82ED3E58 => {
    //   block [0x82ED3E58..0x82ED3E6C)
	// 82ED3E58: 2F050002  cmpwi cr6, r5, 2
	ctx.cr[6].compare_i32(ctx.r[5].s32, 2, &mut ctx.xer);
	// 82ED3E5C: 409A0010  bne cr6, 0x82ed3e6c
	if !ctx.cr[6].eq {
	pc = 0x82ED3E6C; continue 'dispatch;
	}
	// 82ED3E60: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 82ED3E64: 7E0B8378  mr r11, r16
	ctx.r[11].u64 = ctx.r[16].u64;
	// 82ED3E68: 4800000C  b 0x82ed3e74
	pc = 0x82ED3E74; continue 'dispatch;
            }
            0x82ED3E6C => {
    //   block [0x82ED3E6C..0x82ED3E74)
	// 82ED3E6C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82ED3E70: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x82ED3E74; continue 'dispatch;
            }
            0x82ED3E74 => {
    //   block [0x82ED3E74..0x82ED3EA0)
	// 82ED3E74: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED3E78: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED3E7C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED3E80: 4099016C  ble cr6, 0x82ed3fec
	if !ctx.cr[6].gt {
	pc = 0x82ED3FEC; continue 'dispatch;
	}
	// 82ED3E84: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82ED3E88: 419A002C  beq cr6, 0x82ed3eb4
	if ctx.cr[6].eq {
	pc = 0x82ED3EB4; continue 'dispatch;
	}
	// 82ED3E8C: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82ED3E90: 409A0010  bne cr6, 0x82ed3ea0
	if !ctx.cr[6].eq {
	pc = 0x82ED3EA0; continue 'dispatch;
	}
	// 82ED3E94: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 82ED3E98: 7E6B9B78  mr r11, r19
	ctx.r[11].u64 = ctx.r[19].u64;
	// 82ED3E9C: 48000020  b 0x82ed3ebc
	pc = 0x82ED3EBC; continue 'dispatch;
            }
            0x82ED3EA0 => {
    //   block [0x82ED3EA0..0x82ED3EB4)
	// 82ED3EA0: 2F050002  cmpwi cr6, r5, 2
	ctx.cr[6].compare_i32(ctx.r[5].s32, 2, &mut ctx.xer);
	// 82ED3EA4: 409A0010  bne cr6, 0x82ed3eb4
	if !ctx.cr[6].eq {
	pc = 0x82ED3EB4; continue 'dispatch;
	}
	// 82ED3EA8: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 82ED3EAC: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 82ED3EB0: 4800000C  b 0x82ed3ebc
	pc = 0x82ED3EBC; continue 'dispatch;
            }
            0x82ED3EB4 => {
    //   block [0x82ED3EB4..0x82ED3EBC)
	// 82ED3EB4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82ED3EB8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82ED3EBC; continue 'dispatch;
            }
            0x82ED3EBC => {
    //   block [0x82ED3EBC..0x82ED3EF4)
	// 82ED3EBC: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED3EC0: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED3EC4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED3EC8: 40980124  bge cr6, 0x82ed3fec
	if !ctx.cr[6].lt {
	pc = 0x82ED3FEC; continue 'dispatch;
	}
	// 82ED3ECC: 39650001  addi r11, r5, 1
	ctx.r[11].s64 = ctx.r[5].s64 + 1;
	// 82ED3ED0: 7D4B7B96  divwu r10, r11, r15
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[15].u32;
	// 82ED3ED4: 1D4A0003  mulli r10, r10, 3
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 3 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82ED3ED8: 7D2A5851  subf. r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82ED3EDC: 4182002C  beq 0x82ed3f08
	if ctx.cr[0].eq {
	pc = 0x82ED3F08; continue 'dispatch;
	}
	// 82ED3EE0: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 82ED3EE4: 409A0010  bne cr6, 0x82ed3ef4
	if !ctx.cr[6].eq {
	pc = 0x82ED3EF4; continue 'dispatch;
	}
	// 82ED3EE8: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 82ED3EEC: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 82ED3EF0: 48000020  b 0x82ed3f10
	pc = 0x82ED3F10; continue 'dispatch;
            }
            0x82ED3EF4 => {
    //   block [0x82ED3EF4..0x82ED3F08)
	// 82ED3EF4: 2F090002  cmpwi cr6, r9, 2
	ctx.cr[6].compare_i32(ctx.r[9].s32, 2, &mut ctx.xer);
	// 82ED3EF8: 409A0010  bne cr6, 0x82ed3f08
	if !ctx.cr[6].eq {
	pc = 0x82ED3F08; continue 'dispatch;
	}
	// 82ED3EFC: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 82ED3F00: 7E0B8378  mr r11, r16
	ctx.r[11].u64 = ctx.r[16].u64;
	// 82ED3F04: 4800000C  b 0x82ed3f10
	pc = 0x82ED3F10; continue 'dispatch;
            }
            0x82ED3F08 => {
    //   block [0x82ED3F08..0x82ED3F10)
	// 82ED3F08: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82ED3F0C: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x82ED3F10; continue 'dispatch;
            }
            0x82ED3F10 => {
    //   block [0x82ED3F10..0x82ED3F3C)
	// 82ED3F10: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED3F14: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED3F18: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED3F1C: 409900D0  ble cr6, 0x82ed3fec
	if !ctx.cr[6].gt {
	pc = 0x82ED3FEC; continue 'dispatch;
	}
	// 82ED3F20: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82ED3F24: 419A002C  beq cr6, 0x82ed3f50
	if ctx.cr[6].eq {
	pc = 0x82ED3F50; continue 'dispatch;
	}
	// 82ED3F28: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 82ED3F2C: 409A0010  bne cr6, 0x82ed3f3c
	if !ctx.cr[6].eq {
	pc = 0x82ED3F3C; continue 'dispatch;
	}
	// 82ED3F30: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 82ED3F34: 7E6B9B78  mr r11, r19
	ctx.r[11].u64 = ctx.r[19].u64;
	// 82ED3F38: 48000020  b 0x82ed3f58
	pc = 0x82ED3F58; continue 'dispatch;
            }
            0x82ED3F3C => {
    //   block [0x82ED3F3C..0x82ED3F50)
	// 82ED3F3C: 2F090002  cmpwi cr6, r9, 2
	ctx.cr[6].compare_i32(ctx.r[9].s32, 2, &mut ctx.xer);
	// 82ED3F40: 409A0010  bne cr6, 0x82ed3f50
	if !ctx.cr[6].eq {
	pc = 0x82ED3F50; continue 'dispatch;
	}
	// 82ED3F44: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 82ED3F48: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 82ED3F4C: 4800000C  b 0x82ed3f58
	pc = 0x82ED3F58; continue 'dispatch;
            }
            0x82ED3F50 => {
    //   block [0x82ED3F50..0x82ED3F58)
	// 82ED3F50: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82ED3F54: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82ED3F58; continue 'dispatch;
            }
            0x82ED3F58 => {
    //   block [0x82ED3F58..0x82ED3F8C)
	// 82ED3F58: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED3F5C: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED3F60: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED3F64: 40980088  bge cr6, 0x82ed3fec
	if !ctx.cr[6].lt {
	pc = 0x82ED3FEC; continue 'dispatch;
	}
	// 82ED3F68: 81260000  lwz r9, 0(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED3F6C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82ED3F70: 552B0001  rlwinm. r11, r9, 0, 0, 0
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED3F74: 41820058  beq 0x82ed3fcc
	if ctx.cr[0].eq {
	pc = 0x82ED3FCC; continue 'dispatch;
	}
	// 82ED3F78: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ED3F7C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82ED3F80: 419A0034  beq cr6, 0x82ed3fb4
	if ctx.cr[6].eq {
	pc = 0x82ED3FB4; continue 'dispatch;
	}
	// 82ED3F84: 5528007E  clrlwi r8, r9, 1
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x7FFFFFFFu64;
	// 82ED3F88: 7DCB7378  mr r11, r14
	ctx.r[11].u64 = ctx.r[14].u64;
	pc = 0x82ED3F8C; continue 'dispatch;
            }
            0x82ED3F8C => {
    //   block [0x82ED3F8C..0x82ED3FAC)
	// 82ED3F8C: 81CB0000  lwz r14, 0(r11)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED3F90: 7F0E4040  cmplw cr6, r14, r8
	ctx.cr[6].compare_u32(ctx.r[14].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82ED3F94: 419A0018  beq cr6, 0x82ed3fac
	if ctx.cr[6].eq {
	pc = 0x82ED3FAC; continue 'dispatch;
	}
	// 82ED3F98: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ED3F9C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82ED3FA0: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82ED3FA4: 4198FFE8  blt cr6, 0x82ed3f8c
	if ctx.cr[6].lt {
	pc = 0x82ED3F8C; continue 'dispatch;
	}
	// 82ED3FA8: 48000008  b 0x82ed3fb0
	pc = 0x82ED3FB0; continue 'dispatch;
            }
            0x82ED3FAC => {
    //   block [0x82ED3FAC..0x82ED3FB0)
	// 82ED3FAC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	pc = 0x82ED3FB0; continue 'dispatch;
            }
            0x82ED3FB0 => {
    //   block [0x82ED3FB0..0x82ED3FB4)
	// 82ED3FB0: 81C1005C  lwz r14, 0x5c(r1)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	pc = 0x82ED3FB4; continue 'dispatch;
            }
            0x82ED3FB4 => {
    //   block [0x82ED3FB4..0x82ED3FCC)
	// 82ED3FB4: 2B161000  cmplwi cr6, r22, 0x1000
	ctx.cr[6].compare_u32(ctx.r[22].u32, 4096 as u32, &mut ctx.xer);
	// 82ED3FB8: 40980014  bge cr6, 0x82ed3fcc
	if !ctx.cr[6].lt {
	pc = 0x82ED3FCC; continue 'dispatch;
	}
	// 82ED3FBC: 552B007E  clrlwi r11, r9, 1
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x7FFFFFFFu64;
	// 82ED3FC0: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 82ED3FC4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ED3FC8: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	pc = 0x82ED3FCC; continue 'dispatch;
            }
            0x82ED3FCC => {
    //   block [0x82ED3FCC..0x82ED3FEC)
	// 82ED3FCC: 54EB063F  clrlwi. r11, r7, 0x18
	ctx.r[11].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED3FD0: 4082001C  bne 0x82ed3fec
	if !ctx.cr[0].eq {
	pc = 0x82ED3FEC; continue 'dispatch;
	}
	// 82ED3FD4: 8161026C  lwz r11, 0x26c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(620 as u32) ) } as u64;
	// 82ED3FD8: 3A940001  addi r20, r20, 1
	ctx.r[20].s64 = ctx.r[20].s64 + 1;
	// 82ED3FDC: 90DF0000  stw r6, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82ED3FE0: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82ED3FE4: 7F145840  cmplw cr6, r20, r11
	ctx.cr[6].compare_u32(ctx.r[20].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED3FE8: 4098002C  bge cr6, 0x82ed4014
	if !ctx.cr[6].lt {
	pc = 0x82ED4014; continue 'dispatch;
	}
	pc = 0x82ED3FEC; continue 'dispatch;
            }
            0x82ED3FEC => {
    //   block [0x82ED3FEC..0x82ED4008)
	// 82ED3FEC: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82ED3FF0: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82ED3FF4: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82ED3FF8: 4198FE08  blt cr6, 0x82ed3e00
	if ctx.cr[6].lt {
	pc = 0x82ED3E00; continue 'dispatch;
	}
	// 82ED3FFC: 8161026C  lwz r11, 0x26c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(620 as u32) ) } as u64;
	// 82ED4000: 7F145840  cmplw cr6, r20, r11
	ctx.cr[6].compare_u32(ctx.r[20].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED4004: 40980010  bge cr6, 0x82ed4014
	if !ctx.cr[6].lt {
	pc = 0x82ED4014; continue 'dispatch;
	}
	pc = 0x82ED4008; continue 'dispatch;
            }
            0x82ED4008 => {
    //   block [0x82ED4008..0x82ED4014)
	// 82ED4008: 82B50040  lwz r21, 0x40(r21)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(64 as u32) ) } as u64;
	// 82ED400C: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 82ED4010: 409AFADC  bne cr6, 0x82ed3aec
	if !ctx.cr[6].eq {
	pc = 0x82ED3AEC; continue 'dispatch;
	}
	pc = 0x82ED4014; continue 'dispatch;
            }
            0x82ED4014 => {
    //   block [0x82ED4014..0x82ED4044)
	// 82ED4014: 89610277  lbz r11, 0x277(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(631 as u32) ) } as u64;
	// 82ED4018: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ED401C: 409A01D8  bne cr6, 0x82ed41f4
	if !ctx.cr[6].eq {
	pc = 0x82ED41F4; continue 'dispatch;
	}
	// 82ED4020: 83210284  lwz r25, 0x284(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(644 as u32) ) } as u64;
	// 82ED4024: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82ED4028: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82ED402C: 409A005C  bne cr6, 0x82ed4088
	if !ctx.cr[6].eq {
	pc = 0x82ED4088; continue 'dispatch;
	}
	// 82ED4030: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 82ED4034: 419A017C  beq cr6, 0x82ed41b0
	if ctx.cr[6].eq {
	pc = 0x82ED41B0; continue 'dispatch;
	}
	// 82ED4038: 81010264  lwz r8, 0x264(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(612 as u32) ) } as u64;
	// 82ED403C: 7E89A378  mr r9, r20
	ctx.r[9].u64 = ctx.r[20].u64;
	// 82ED4040: 396E0004  addi r11, r14, 4
	ctx.r[11].s64 = ctx.r[14].s64 + 4;
	pc = 0x82ED4044; continue 'dispatch;
            }
            0x82ED4044 => {
    //   block [0x82ED4044..0x82ED4088)
	// 82ED4044: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED4048: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82ED404C: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82ED4050: 914BFFFC  stw r10, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[10].u32 ) };
	// 82ED4054: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED4058: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED405C: C1AA0008  lfs f13, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED4060: EDBE6828  fsubs f13, f30, f13
	ctx.f[13].f64 = (((ctx.f[30].f64 - ctx.f[13].f64) as f32) as f64);
	// 82ED4064: C18A000C  lfs f12, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED4068: ED9D6028  fsubs f12, f29, f12
	ctx.f[12].f64 = (((ctx.f[29].f64 - ctx.f[12].f64) as f32) as f64);
	// 82ED406C: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED4070: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82ED4074: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82ED4078: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82ED407C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82ED4080: 4082FFC4  bne 0x82ed4044
	if !ctx.cr[0].eq {
	pc = 0x82ED4044; continue 'dispatch;
	}
	// 82ED4084: 4800012C  b 0x82ed41b0
	pc = 0x82ED41B0; continue 'dispatch;
            }
            0x82ED4088 => {
    //   block [0x82ED4088..0x82ED40C4)
	// 82ED4088: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 82ED408C: 419A0124  beq cr6, 0x82ed41b0
	if ctx.cr[6].eq {
	pc = 0x82ED41B0; continue 'dispatch;
	}
	// 82ED4090: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82ED4094: 83610264  lwz r27, 0x264(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(612 as u32) ) } as u64;
	// 82ED4098: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82ED409C: 3BEB9128  addi r31, r11, -0x6ed8
	ctx.r[31].s64 = ctx.r[11].s64 + -28376;
	// 82ED40A0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82ED40A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ED40A8: 3BAB9128  addi r29, r11, -0x6ed8
	ctx.r[29].s64 = ctx.r[11].s64 + -28376;
	// 82ED40AC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED40B0: C3690BEC  lfs f27, 0xbec(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3052 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82ED40B4: 7E9AA378  mr r26, r20
	ctx.r[26].u64 = ctx.r[20].u64;
	// 82ED40B8: 3BCE0004  addi r30, r14, 4
	ctx.r[30].s64 = ctx.r[14].s64 + 4;
	// 82ED40BC: C38A0C18  lfs f28, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82ED40C0: 3B8B9F1C  addi r28, r11, -0x60e4
	ctx.r[28].s64 = ctx.r[11].s64 + -24804;
	pc = 0x82ED40C4; continue 'dispatch;
            }
            0x82ED40C4 => {
    //   block [0x82ED40C4..0x82ED4110)
	// 82ED40C4: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED40C8: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82ED40CC: D381005C  stfs f28, 0x5c(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82ED40D0: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82ED40D4: 392100C0  addi r9, r1, 0xc0
	ctx.r[9].s64 = ctx.r[1].s64 + 192;
	// 82ED40D8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ED40DC: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82ED40E0: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82ED40E4: 917EFFFC  stw r11, -4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-4 as u32), ctx.r[11].u32 ) };
	// 82ED40E8: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED40EC: 93E100B0  stw r31, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[31].u32 ) };
	// 82ED40F0: 90E10064  stw r7, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[7].u32 ) };
	// 82ED40F4: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED40F8: D00100B4  stfs f0, 0xb4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82ED40FC: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED4100: D00100B8  stfs f0, 0xb8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82ED4104: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED4108: D00100BC  stfs f0, 0xbc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82ED410C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82ED4110; continue 'dispatch;
            }
            0x82ED4110 => {
    //   block [0x82ED4110..0x82ED4150)
	// 82ED4110: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82ED4114: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82ED4118: 4200FFF8  bdnz 0x82ed4110
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82ED4110; continue 'dispatch;
	}
	// 82ED411C: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82ED4120: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82ED4124: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82ED4128: 9AE10108  stb r23, 0x108(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[23].u8 ) };
	// 82ED412C: 4B2DA57D  bl 0x821ae6a8
	ctx.lr = 0x82ED4130;
	sub_821AE6A8(ctx, base);
	// 82ED4130: D3E10114  stfs f31, 0x114(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82ED4134: 39610120  addi r11, r1, 0x120
	ctx.r[11].s64 = ctx.r[1].s64 + 288;
	// 82ED4138: D3C10118  stfs f30, 0x118(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 82ED413C: 93E10110  stw r31, 0x110(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[31].u32 ) };
	// 82ED4140: D3A1011C  stfs f29, 0x11c(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 82ED4144: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 82ED4148: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82ED414C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82ED4150; continue 'dispatch;
            }
            0x82ED4150 => {
    //   block [0x82ED4150..0x82ED4190)
	// 82ED4150: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ED4154: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ED4158: 4200FFF8  bdnz 0x82ed4150
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82ED4150; continue 'dispatch;
	}
	// 82ED415C: 80C1028C  lwz r6, 0x28c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(652 as u32) ) } as u64;
	// 82ED4160: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82ED4164: 9AE10168  stb r23, 0x168(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(360 as u32), ctx.r[23].u8 ) };
	// 82ED4168: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82ED416C: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 82ED4170: 7F2903A6  mtctr r25
	ctx.ctr.u64 = ctx.r[25].u64;
	// 82ED4174: 4E800421  bctrl
	ctx.lr = 0x82ED4178;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED4178: 93A10110  stw r29, 0x110(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[29].u32 ) };
	// 82ED417C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED4180: 41820010  beq 0x82ed4190
	if ctx.cr[0].eq {
	pc = 0x82ED4190; continue 'dispatch;
	}
	// 82ED4184: C001005C  lfs f0, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED4188: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82ED418C: 4800000C  b 0x82ed4198
	pc = 0x82ED4198; continue 'dispatch;
            }
            0x82ED4190 => {
    //   block [0x82ED4190..0x82ED4198)
	// 82ED4190: D37E0000  stfs f27, 0(r30)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82ED4194: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	pc = 0x82ED4198; continue 'dispatch;
            }
            0x82ED4198 => {
    //   block [0x82ED4198..0x82ED41B0)
	// 82ED4198: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82ED419C: 93A100B0  stw r29, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[29].u32 ) };
	// 82ED41A0: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 82ED41A4: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82ED41A8: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82ED41AC: 4082FF18  bne 0x82ed40c4
	if !ctx.cr[0].eq {
	pc = 0x82ED40C4; continue 'dispatch;
	}
	pc = 0x82ED41B0; continue 'dispatch;
            }
            0x82ED41B0 => {
    //   block [0x82ED41B0..0x82ED41DC)
	// 82ED41B0: 3D6082ED  lis r11, -0x7d13
	ctx.r[11].s64 = -2098397184;
	// 82ED41B4: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 82ED41B8: 38CB36B8  addi r6, r11, 0x36b8
	ctx.r[6].s64 = ctx.r[11].s64 + 14008;
	// 82ED41BC: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82ED41C0: 7DC37378  mr r3, r14
	ctx.r[3].u64 = ctx.r[14].u64;
	// 82ED41C4: 4BDD79F5  bl 0x82cabbb8
	ctx.lr = 0x82ED41C8;
	sub_82CABBB8(ctx, base);
	// 82ED41C8: 7E98A051  subf. r20, r24, r20
	ctx.r[20].s64 = ctx.r[20].s64 - ctx.r[24].s64;
	ctx.cr[0].compare_i32(ctx.r[20].s32, 0, &mut ctx.xer);
	// 82ED41CC: 41820028  beq 0x82ed41f4
	if ctx.cr[0].eq {
	pc = 0x82ED41F4; continue 'dispatch;
	}
	// 82ED41D0: 81210264  lwz r9, 0x264(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(612 as u32) ) } as u64;
	// 82ED41D4: 7DCA7378  mr r10, r14
	ctx.r[10].u64 = ctx.r[14].u64;
	// 82ED41D8: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	pc = 0x82ED41DC; continue 'dispatch;
            }
            0x82ED41DC => {
    //   block [0x82ED41DC..0x82ED41F4)
	// 82ED41DC: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED41E0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED41E4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82ED41E8: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82ED41EC: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82ED41F0: 4082FFEC  bne 0x82ed41dc
	if !ctx.cr[0].eq {
	pc = 0x82ED41DC; continue 'dispatch;
	}
	pc = 0x82ED41F4; continue 'dispatch;
            }
            0x82ED41F4 => {
    //   block [0x82ED41F4..0x82ED4210)
	// 82ED41F4: 8961025F  lbz r11, 0x25f(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(607 as u32) ) } as u64;
	// 82ED41F8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED41FC: 40820030  bne 0x82ed422c
	if !ctx.cr[0].eq {
	pc = 0x82ED422C; continue 'dispatch;
	}
	// 82ED4200: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 82ED4204: 419A0028  beq cr6, 0x82ed422c
	if ctx.cr[6].eq {
	pc = 0x82ED422C; continue 'dispatch;
	}
	// 82ED4208: 81610264  lwz r11, 0x264(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(612 as u32) ) } as u64;
	// 82ED420C: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
	pc = 0x82ED4210; continue 'dispatch;
            }
            0x82ED4210 => {
    //   block [0x82ED4210..0x82ED422C)
	// 82ED4210: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED4214: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ED4218: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED421C: 5529007E  clrlwi r9, r9, 1
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x7FFFFFFFu64;
	// 82ED4220: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ED4224: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ED4228: 4082FFE8  bne 0x82ed4210
	if !ctx.cr[0].eq {
	pc = 0x82ED4210; continue 'dispatch;
	}
	pc = 0x82ED422C; continue 'dispatch;
            }
            0x82ED422C => {
    //   block [0x82ED422C..0x82ED4240)
	// 82ED422C: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82ED4230: 38210230  addi r1, r1, 0x230
	ctx.r[1].s64 = ctx.r[1].s64 + 560;
	// 82ED4234: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 82ED4238: 4BDD9AE9  bl 0x82cadd20
	ctx.lr = 0x82ED423C;
	sub_82CADCEC(ctx, base);
	// 82ED423C: 4BDD51E4  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED4240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED4240 size=848
    let mut pc: u32 = 0x82ED4240;
    'dispatch: loop {
        match pc {
            0x82ED4240 => {
    //   block [0x82ED4240..0x82ED4294)
	// 82ED4240: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED4244: 4BDD51A9  bl 0x82ca93ec
	ctx.lr = 0x82ED4248;
	sub_82CA93D0(ctx, base);
	// 82ED4248: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED424C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82ED4250: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82ED4254: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 82ED4258: 7CD63378  mr r22, r6
	ctx.r[22].u64 = ctx.r[6].u64;
	// 82ED425C: 80990004  lwz r4, 4(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED4260: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED4264: 41820324  beq 0x82ed4588
	if ctx.cr[0].eq {
	pc = 0x82ED4588; continue 'dispatch;
	}
	// 82ED4268: 80790008  lwz r3, 8(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED426C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED4270: 40820024  bne 0x82ed4294
	if !ctx.cr[0].eq {
	pc = 0x82ED4294; continue 'dispatch;
	}
	// 82ED4274: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82ED4278: 4BFFF6F9  bl 0x82ed3970
	ctx.lr = 0x82ED427C;
	sub_82ED3970(ctx, base);
	// 82ED427C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED4280: 41820308  beq 0x82ed4588
	if ctx.cr[0].eq {
	pc = 0x82ED4588; continue 'dispatch;
	}
	// 82ED4284: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED4288: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED428C: 90790008  stw r3, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82ED4290: 418202F8  beq 0x82ed4588
	if ctx.cr[0].eq {
	pc = 0x82ED4588; continue 'dispatch;
	}
	pc = 0x82ED4294; continue 'dispatch;
            }
            0x82ED4294 => {
    //   block [0x82ED4294..0x82ED42D8)
	// 82ED4294: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED4298: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED429C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED42A0: 4E800421  bctrl
	ctx.lr = 0x82ED42A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED42A4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ED42A8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED42AC: 3B4BF1A8  addi r26, r11, -0xe58
	ctx.r[26].s64 = ctx.r[11].s64 + -3672;
	// 82ED42B0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ED42B4: 3F608336  lis r27, -0x7cca
	ctx.r[27].s64 = -2093613056;
	// 82ED42B8: 3B0BF9A8  addi r24, r11, -0x658
	ctx.r[24].s64 = ctx.r[11].s64 + -1624;
	// 82ED42BC: 40820144  bne 0x82ed4400
	if !ctx.cr[0].eq {
	pc = 0x82ED4400; continue 'dispatch;
	}
	// 82ED42C0: 80990004  lwz r4, 4(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED42C4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82ED42C8: 80F90008  lwz r7, 8(r25)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED42CC: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED42D0: 41820130  beq 0x82ed4400
	if ctx.cr[0].eq {
	pc = 0x82ED4400; continue 'dispatch;
	}
	// 82ED42D4: 83FB89B4  lwz r31, -0x764c(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-30284 as u32) ) } as u64;
            }
            0x82ED42D8 => {
    //   block [0x82ED42D8..0x82ED4314)
	// 82ED42D8: 7F04E840  cmplw cr6, r4, r29
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82ED42DC: 419A0124  beq cr6, 0x82ed4400
	if ctx.cr[6].eq {
	pc = 0x82ED4400; continue 'dispatch;
	}
	// 82ED42E0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82ED42E4: 419A00E4  beq cr6, 0x82ed43c8
	if ctx.cr[6].eq {
	pc = 0x82ED43C8; continue 'dispatch;
	}
	// 82ED42E8: 8164001C  lwz r11, 0x1c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED42EC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED42F0: 418200D8  beq 0x82ed43c8
	if ctx.cr[0].eq {
	pc = 0x82ED43C8; continue 'dispatch;
	}
	// 82ED42F4: 81470028  lwz r10, 0x28(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ED42F8: 386BFFFF  addi r3, r11, -1
	ctx.r[3].s64 = ctx.r[11].s64 + -1;
	// 82ED42FC: 81670030  lwz r11, 0x30(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ED4300: 8107002C  lwz r8, 0x2c(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED4304: 83CA0004  lwz r30, 4(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED4308: 546A2036  slwi r10, r3, 4
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ED430C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ED4310: 480000A4  b 0x82ed43b4
	pc = 0x82ED43B4; continue 'dispatch;
            }
            0x82ED4314 => {
    //   block [0x82ED4314..0x82ED4338)
	// 82ED4314: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED4318: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82ED431C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ED4320: 55292834  slwi r9, r9, 5
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(5);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82ED4324: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82ED4328: 7D29402E  lwzx r9, r9, r8
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82ED432C: 5529007E  clrlwi r9, r9, 1
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x7FFFFFFFu64;
	// 82ED4330: 419A0030  beq cr6, 0x82ed4360
	if ctx.cr[6].eq {
	pc = 0x82ED4360; continue 'dispatch;
	}
	// 82ED4334: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	pc = 0x82ED4338; continue 'dispatch;
            }
            0x82ED4338 => {
    //   block [0x82ED4338..0x82ED4350)
	// 82ED4338: 54B5063F  clrlwi. r21, r5, 0x18
	ctx.r[21].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[21].s32, 0, &mut ctx.xer);
	// 82ED433C: 41820024  beq 0x82ed4360
	if ctx.cr[0].eq {
	pc = 0x82ED4360; continue 'dispatch;
	}
	// 82ED4340: 82A60000  lwz r21, 0(r6)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED4344: 7F154840  cmplw cr6, r21, r9
	ctx.cr[6].compare_u32(ctx.r[21].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82ED4348: 409A0008  bne cr6, 0x82ed4350
	if !ctx.cr[6].eq {
	pc = 0x82ED4350; continue 'dispatch;
	}
	// 82ED434C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	pc = 0x82ED4350; continue 'dispatch;
            }
            0x82ED4350 => {
    //   block [0x82ED4350..0x82ED4360)
	// 82ED4350: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ED4354: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82ED4358: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82ED435C: 4198FFDC  blt cr6, 0x82ed4338
	if ctx.cr[6].lt {
	pc = 0x82ED4338; continue 'dispatch;
	}
	pc = 0x82ED4360; continue 'dispatch;
            }
            0x82ED4360 => {
    //   block [0x82ED4360..0x82ED43A8)
	// 82ED4360: 54AA063F  clrlwi. r10, r5, 0x18
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ED4364: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 82ED4368: 41820040  beq 0x82ed43a8
	if ctx.cr[0].eq {
	pc = 0x82ED43A8; continue 'dispatch;
	}
	// 82ED436C: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED4370: 38DA1000  addi r6, r26, 0x1000
	ctx.r[6].s64 = ctx.r[26].s64 + 4096;
	// 82ED4374: 57E5103A  slwi r5, r31, 2
	ctx.r[5].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82ED4378: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ED437C: 7D6A312E  stwx r11, r10, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32), ctx.r[11].u32) };
	// 82ED4380: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED4384: 7D25C12E  stwx r9, r5, r24
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[24].u32), ctx.r[9].u32) };
	// 82ED4388: 5546103A  slwi r6, r10, 2
	ctx.r[6].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82ED438C: 395F0001  addi r10, r31, 1
	ctx.r[10].s64 = ctx.r[31].s64 + 1;
	// 82ED4390: 7CE6D12E  stwx r7, r6, r26
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[26].u32), ctx.r[7].u32) };
	// 82ED4394: 915B89B4  stw r10, -0x764c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(-30284 as u32), ctx.r[10].u32 ) };
	// 82ED4398: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED439C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ED43A0: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ED43A4: 83FB89B4  lwz r31, -0x764c(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-30284 as u32) ) } as u64;
	pc = 0x82ED43A8; continue 'dispatch;
            }
            0x82ED43A8 => {
    //   block [0x82ED43A8..0x82ED43B4)
	// 82ED43A8: 7F03F040  cmplw cr6, r3, r30
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82ED43AC: 4098001C  bge cr6, 0x82ed43c8
	if !ctx.cr[6].lt {
	pc = 0x82ED43C8; continue 'dispatch;
	}
	// 82ED43B0: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	pc = 0x82ED43B4; continue 'dispatch;
            }
            0x82ED43B4 => {
    //   block [0x82ED43B4..0x82ED43C8)
	// 82ED43B4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED43B8: 554A2834  slwi r10, r10, 5
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ED43BC: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82ED43C0: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82ED43C4: 419AFF50  beq cr6, 0x82ed4314
	if ctx.cr[6].eq {
	pc = 0x82ED4314; continue 'dispatch;
	}
	pc = 0x82ED43C8; continue 'dispatch;
            }
            0x82ED43C8 => {
    //   block [0x82ED43C8..0x82ED43D4)
	// 82ED43C8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82ED43CC: 409A0008  bne cr6, 0x82ed43d4
	if !ctx.cr[6].eq {
	pc = 0x82ED43D4; continue 'dispatch;
	}
	// 82ED43D0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	pc = 0x82ED43D4; continue 'dispatch;
            }
            0x82ED43D4 => {
    //   block [0x82ED43D4..0x82ED4400)
	// 82ED43D4: 80840018  lwz r4, 0x18(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ED43D8: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED43DC: 41820024  beq 0x82ed4400
	if ctx.cr[0].eq {
	pc = 0x82ED4400; continue 'dispatch;
	}
	// 82ED43E0: 7F04E840  cmplw cr6, r4, r29
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82ED43E4: 419A001C  beq cr6, 0x82ed4400
	if ctx.cr[6].eq {
	pc = 0x82ED4400; continue 'dispatch;
	}
	// 82ED43E8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82ED43EC: 4BFFF585  bl 0x82ed3970
	ctx.lr = 0x82ED43F0;
	sub_82ED3970(ctx, base);
	// 82ED43F0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED43F4: 4182FEE4  beq 0x82ed42d8
	if ctx.cr[0].eq {
	pc = 0x82ED42D8; continue 'dispatch;
	}
	// 82ED43F8: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED43FC: 4BFFFEDC  b 0x82ed42d8
	pc = 0x82ED42D8; continue 'dispatch;
            }
            0x82ED4400 => {
    //   block [0x82ED4400..0x82ED443C)
	// 82ED4400: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ED4404: 917B89B4  stw r11, -0x764c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(-30284 as u32), ctx.r[11].u32 ) };
	// 82ED4408: 80790008  lwz r3, 8(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED440C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED4410: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED4414: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED4418: 4E800421  bctrl
	ctx.lr = 0x82ED441C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED441C: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82ED4420: 409A015C  bne cr6, 0x82ed457c
	if !ctx.cr[6].eq {
	pc = 0x82ED457C; continue 'dispatch;
	}
	// 82ED4424: 80990004  lwz r4, 4(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED4428: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ED442C: 81190008  lwz r8, 8(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED4430: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED4434: 41820148  beq 0x82ed457c
	if ctx.cr[0].eq {
	pc = 0x82ED457C; continue 'dispatch;
	}
	// 82ED4438: 80BB89B4  lwz r5, -0x764c(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-30284 as u32) ) } as u64;
            }
            0x82ED443C => {
    //   block [0x82ED443C..0x82ED4480)
	// 82ED443C: 7F04F040  cmplw cr6, r4, r30
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82ED4440: 419A013C  beq cr6, 0x82ed457c
	if ctx.cr[6].eq {
	pc = 0x82ED457C; continue 'dispatch;
	}
	// 82ED4444: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82ED4448: 419A00FC  beq cr6, 0x82ed4544
	if ctx.cr[6].eq {
	pc = 0x82ED4544; continue 'dispatch;
	}
	// 82ED444C: 81440018  lwz r10, 0x18(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ED4450: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED4454: 418200F0  beq 0x82ed4544
	if ctx.cr[0].eq {
	pc = 0x82ED4544; continue 'dispatch;
	}
	// 82ED4458: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED445C: 386AFFFF  addi r3, r10, -1
	ctx.r[3].s64 = ctx.r[10].s64 + -1;
	// 82ED4460: 81280028  lwz r9, 0x28(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ED4464: 80E80030  lwz r7, 0x30(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ED4468: 80CB0080  lwz r6, 0x80(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82ED446C: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED4470: 812B007C  lwz r9, 0x7c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82ED4474: 7D6619D6  mullw r11, r6, r3
	ctx.r[11].s32 = ((ctx.r[6].s32 as i64 * ctx.r[3].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82ED4478: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82ED447C: 480000B0  b 0x82ed452c
	pc = 0x82ED452C; continue 'dispatch;
            }
            0x82ED4480 => {
    //   block [0x82ED4480..0x82ED44A4)
	// 82ED4480: 83AB0008  lwz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED4484: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82ED4488: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82ED448C: 7D3D49D6  mullw r9, r29, r9
	ctx.r[9].s32 = ((ctx.r[29].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82ED4490: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82ED4494: 5549007E  clrlwi r9, r10, 1
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x7FFFFFFFu64;
	// 82ED4498: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82ED449C: 419A0030  beq cr6, 0x82ed44cc
	if ctx.cr[6].eq {
	pc = 0x82ED44CC; continue 'dispatch;
	}
	// 82ED44A0: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	pc = 0x82ED44A4; continue 'dispatch;
            }
            0x82ED44A4 => {
    //   block [0x82ED44A4..0x82ED44BC)
	// 82ED44A4: 54DD063F  clrlwi. r29, r6, 0x18
	ctx.r[29].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82ED44A8: 41820024  beq 0x82ed44cc
	if ctx.cr[0].eq {
	pc = 0x82ED44CC; continue 'dispatch;
	}
	// 82ED44AC: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED44B0: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82ED44B4: 409A0008  bne cr6, 0x82ed44bc
	if !ctx.cr[6].eq {
	pc = 0x82ED44BC; continue 'dispatch;
	}
	// 82ED44B8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	pc = 0x82ED44BC; continue 'dispatch;
            }
            0x82ED44BC => {
    //   block [0x82ED44BC..0x82ED44CC)
	// 82ED44BC: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 82ED44C0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82ED44C4: 7F072840  cmplw cr6, r7, r5
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82ED44C8: 4198FFDC  blt cr6, 0x82ed44a4
	if ctx.cr[6].lt {
	pc = 0x82ED44A4; continue 'dispatch;
	}
	pc = 0x82ED44CC; continue 'dispatch;
            }
            0x82ED44CC => {
    //   block [0x82ED44CC..0x82ED4514)
	// 82ED44CC: 54CA063F  clrlwi. r10, r6, 0x18
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ED44D0: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 82ED44D4: 41820040  beq 0x82ed4514
	if ctx.cr[0].eq {
	pc = 0x82ED4514; continue 'dispatch;
	}
	// 82ED44D8: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED44DC: 38FA1000  addi r7, r26, 0x1000
	ctx.r[7].s64 = ctx.r[26].s64 + 4096;
	// 82ED44E0: 54A6103A  slwi r6, r5, 2
	ctx.r[6].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82ED44E4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ED44E8: 7D6A392E  stwx r11, r10, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[7].u32), ctx.r[11].u32) };
	// 82ED44EC: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED44F0: 7D26C12E  stwx r9, r6, r24
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[24].u32), ctx.r[9].u32) };
	// 82ED44F4: 5547103A  slwi r7, r10, 2
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82ED44F8: 39450001  addi r10, r5, 1
	ctx.r[10].s64 = ctx.r[5].s64 + 1;
	// 82ED44FC: 7D07D12E  stwx r8, r7, r26
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[26].u32), ctx.r[8].u32) };
	// 82ED4500: 915B89B4  stw r10, -0x764c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(-30284 as u32), ctx.r[10].u32 ) };
	// 82ED4504: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED4508: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ED450C: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ED4510: 80BB89B4  lwz r5, -0x764c(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-30284 as u32) ) } as u64;
	pc = 0x82ED4514; continue 'dispatch;
            }
            0x82ED4514 => {
    //   block [0x82ED4514..0x82ED452C)
	// 82ED4514: 7F03F840  cmplw cr6, r3, r31
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82ED4518: 4098002C  bge cr6, 0x82ed4544
	if !ctx.cr[6].lt {
	pc = 0x82ED4544; continue 'dispatch;
	}
	// 82ED451C: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED4520: 80E90080  lwz r7, 0x80(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(128 as u32) ) } as u64;
	// 82ED4524: 8129007C  lwz r9, 0x7c(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 82ED4528: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	pc = 0x82ED452C; continue 'dispatch;
            }
            0x82ED452C => {
    //   block [0x82ED452C..0x82ED4544)
	// 82ED452C: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED4530: 8148002C  lwz r10, 0x2c(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED4534: 7CE749D6  mullw r7, r7, r9
	ctx.r[7].s32 = ((ctx.r[7].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[7].s64 = ctx.r[7].s32 as i64;
	// 82ED4538: 7CE75214  add r7, r7, r10
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 82ED453C: 7F072040  cmplw cr6, r7, r4
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82ED4540: 419AFF40  beq cr6, 0x82ed4480
	if ctx.cr[6].eq {
	pc = 0x82ED4480; continue 'dispatch;
	}
	pc = 0x82ED4544; continue 'dispatch;
            }
            0x82ED4544 => {
    //   block [0x82ED4544..0x82ED4550)
	// 82ED4544: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82ED4548: 409A0008  bne cr6, 0x82ed4550
	if !ctx.cr[6].eq {
	pc = 0x82ED4550; continue 'dispatch;
	}
	// 82ED454C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	pc = 0x82ED4550; continue 'dispatch;
            }
            0x82ED4550 => {
    //   block [0x82ED4550..0x82ED457C)
	// 82ED4550: 80840014  lwz r4, 0x14(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED4554: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED4558: 41820024  beq 0x82ed457c
	if ctx.cr[0].eq {
	pc = 0x82ED457C; continue 'dispatch;
	}
	// 82ED455C: 7F04F040  cmplw cr6, r4, r30
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82ED4560: 419A001C  beq cr6, 0x82ed457c
	if ctx.cr[6].eq {
	pc = 0x82ED457C; continue 'dispatch;
	}
	// 82ED4564: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82ED4568: 4BFFF409  bl 0x82ed3970
	ctx.lr = 0x82ED456C;
	sub_82ED3970(ctx, base);
	// 82ED456C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED4570: 4182FECC  beq 0x82ed443c
	if ctx.cr[0].eq {
	pc = 0x82ED443C; continue 'dispatch;
	}
	// 82ED4574: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED4578: 4BFFFEC4  b 0x82ed443c
	pc = 0x82ED443C; continue 'dispatch;
            }
            0x82ED457C => {
    //   block [0x82ED457C..0x82ED4588)
	// 82ED457C: 397A1000  addi r11, r26, 0x1000
	ctx.r[11].s64 = ctx.r[26].s64 + 4096;
	// 82ED4580: 91770000  stw r11, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ED4584: 93560000  stw r26, 0(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	pc = 0x82ED4588; continue 'dispatch;
            }
            0x82ED4588 => {
    //   block [0x82ED4588..0x82ED4590)
	// 82ED4588: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82ED458C: 4BDD4EB0  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED4590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED4590 size=512
    let mut pc: u32 = 0x82ED4590;
    'dispatch: loop {
        match pc {
            0x82ED4590 => {
    //   block [0x82ED4590..0x82ED45D4)
	// 82ED4590: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED4594: 4BDD4E5D  bl 0x82ca93f0
	ctx.lr = 0x82ED4598;
	sub_82CA93D0(ctx, base);
	// 82ED4598: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED459C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82ED45A0: 80980004  lwz r4, 4(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED45A4: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED45A8: 418201DC  beq 0x82ed4784
	if ctx.cr[0].eq {
	pc = 0x82ED4784; continue 'dispatch;
	}
	// 82ED45AC: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED45B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED45B4: 409A0020  bne cr6, 0x82ed45d4
	if !ctx.cr[6].eq {
	pc = 0x82ED45D4; continue 'dispatch;
	}
	// 82ED45B8: 4BFFF3B9  bl 0x82ed3970
	ctx.lr = 0x82ED45BC;
	sub_82ED3970(ctx, base);
	// 82ED45BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED45C0: 418201C4  beq 0x82ed4784
	if ctx.cr[0].eq {
	pc = 0x82ED4784; continue 'dispatch;
	}
	// 82ED45C4: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED45C8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED45CC: 91780008  stw r11, 8(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82ED45D0: 418201B4  beq 0x82ed4784
	if ctx.cr[0].eq {
	pc = 0x82ED4784; continue 'dispatch;
	}
	pc = 0x82ED45D4; continue 'dispatch;
            }
            0x82ED45D4 => {
    //   block [0x82ED45D4..0x82ED462C)
	// 82ED45D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ED45D8: 3F608336  lis r27, -0x7cca
	ctx.r[27].s64 = -2093613056;
	// 82ED45DC: 917B89B4  stw r11, -0x764c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(-30284 as u32), ctx.r[11].u32 ) };
	// 82ED45E0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82ED45E4: 80780008  lwz r3, 8(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED45E8: 3B8B89B0  addi r28, r11, -0x7650
	ctx.r[28].s64 = ctx.r[11].s64 + -30288;
	// 82ED45EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ED45F0: 917CFFFC  stw r11, -4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(-4 as u32), ctx.r[11].u32 ) };
	// 82ED45F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED45F8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED45FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED4600: 4E800421  bctrl
	ctx.lr = 0x82ED4604;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED4604: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ED4608: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82ED460C: 3B2BF1A8  addi r25, r11, -0xe58
	ctx.r[25].s64 = ctx.r[11].s64 + -3672;
	// 82ED4610: 409A0148  bne cr6, 0x82ed4758
	if !ctx.cr[6].eq {
	pc = 0x82ED4758; continue 'dispatch;
	}
	// 82ED4614: 83B80004  lwz r29, 4(r24)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED4618: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 82ED461C: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED4620: 41820138  beq 0x82ed4758
	if ctx.cr[0].eq {
	pc = 0x82ED4758; continue 'dispatch;
	}
	// 82ED4624: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ED4628: 3AEBF9A8  addi r23, r11, -0x658
	ctx.r[23].s64 = ctx.r[11].s64 + -1624;
            }
            0x82ED462C => {
    //   block [0x82ED462C..0x82ED4674)
	// 82ED462C: 7F1DB040  cmplw cr6, r29, r22
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[22].u32, &mut ctx.xer);
	// 82ED4630: 419A0128  beq cr6, 0x82ed4758
	if ctx.cr[6].eq {
	pc = 0x82ED4758; continue 'dispatch;
	}
	// 82ED4634: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ED4638: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82ED463C: 4BFFF335  bl 0x82ed3970
	ctx.lr = 0x82ED4640;
	sub_82ED3970(ctx, base);
	// 82ED4640: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED4644: 418200FC  beq 0x82ed4740
	if ctx.cr[0].eq {
	pc = 0x82ED4740; continue 'dispatch;
	}
	// 82ED4648: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ED464C: 83C30014  lwz r30, 0x14(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED4650: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED4654: 418200EC  beq 0x82ed4740
	if ctx.cr[0].eq {
	pc = 0x82ED4740; continue 'dispatch;
	}
	// 82ED4658: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED465C: 3B4BFFFF  addi r26, r11, -1
	ctx.r[26].s64 = ctx.r[11].s64 + -1;
	// 82ED4660: 811E0030  lwz r8, 0x30(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ED4664: 812A0080  lwz r9, 0x80(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 82ED4668: 7D29D1D6  mullw r9, r9, r26
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * ctx.r[26].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82ED466C: 7FE94214  add r31, r9, r8
	ctx.r[31].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82ED4670: 480000B4  b 0x82ed4724
	pc = 0x82ED4724; continue 'dispatch;
            }
            0x82ED4674 => {
    //   block [0x82ED4674..0x82ED469C)
	// 82ED4674: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED4678: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82ED467C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82ED4680: 7D4851D6  mullw r10, r8, r10
	ctx.r[10].s32 = ((ctx.r[8].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82ED4684: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ED4688: 5568007E  clrlwi r8, r11, 1
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 82ED468C: 817B89B4  lwz r11, -0x764c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-30284 as u32) ) } as u64;
	// 82ED4690: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED4694: 419A0030  beq cr6, 0x82ed46c4
	if ctx.cr[6].eq {
	pc = 0x82ED46C4; continue 'dispatch;
	}
	// 82ED4698: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	pc = 0x82ED469C; continue 'dispatch;
            }
            0x82ED469C => {
    //   block [0x82ED469C..0x82ED46B4)
	// 82ED469C: 54E6063F  clrlwi. r6, r7, 0x18
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82ED46A0: 41820024  beq 0x82ed46c4
	if ctx.cr[0].eq {
	pc = 0x82ED46C4; continue 'dispatch;
	}
	// 82ED46A4: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED46A8: 7F064040  cmplw cr6, r6, r8
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82ED46AC: 409A0008  bne cr6, 0x82ed46b4
	if !ctx.cr[6].eq {
	pc = 0x82ED46B4; continue 'dispatch;
	}
	// 82ED46B0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x82ED46B4; continue 'dispatch;
            }
            0x82ED46B4 => {
    //   block [0x82ED46B4..0x82ED46C4)
	// 82ED46B4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ED46B8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82ED46BC: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED46C0: 4198FFDC  blt cr6, 0x82ed469c
	if ctx.cr[6].lt {
	pc = 0x82ED469C; continue 'dispatch;
	}
	pc = 0x82ED46C4; continue 'dispatch;
            }
            0x82ED46C4 => {
    //   block [0x82ED46C4..0x82ED46F8)
	// 82ED46C4: 54EA063F  clrlwi. r10, r7, 0x18
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ED46C8: 41820030  beq 0x82ed46f8
	if ctx.cr[0].eq {
	pc = 0x82ED46F8; continue 'dispatch;
	}
	// 82ED46CC: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82ED46D0: 815CFFFC  lwz r10, -4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82ED46D4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ED46D8: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82ED46DC: 38F91000  addi r7, r25, 0x1000
	ctx.r[7].s64 = ctx.r[25].s64 + 4096;
	// 82ED46E0: 7D06B92E  stwx r8, r6, r23
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[23].u32), ctx.r[8].u32) };
	// 82ED46E4: 917B89B4  stw r11, -0x764c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(-30284 as u32), ctx.r[11].u32 ) };
	// 82ED46E8: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	// 82ED46EC: 7FC9C92E  stwx r30, r9, r25
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[25].u32), ctx.r[30].u32) };
	// 82ED46F0: 7FE9392E  stwx r31, r9, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32), ctx.r[31].u32) };
	// 82ED46F4: 917CFFFC  stw r11, -4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(-4 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED46F8; continue 'dispatch;
            }
            0x82ED46F8 => {
    //   block [0x82ED46F8..0x82ED4724)
	// 82ED46F8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED46FC: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82ED4700: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED4704: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED4708: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED470C: 4E800421  bctrl
	ctx.lr = 0x82ED4710;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED4710: 7F1A1840  cmplw cr6, r26, r3
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82ED4714: 4098002C  bge cr6, 0x82ed4740
	if !ctx.cr[6].lt {
	pc = 0x82ED4740; continue 'dispatch;
	}
	// 82ED4718: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED471C: 812A0080  lwz r9, 0x80(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 82ED4720: 7FE9FA14  add r31, r9, r31
	ctx.r[31].u64 = ctx.r[9].u64 + ctx.r[31].u64;
            }
            0x82ED4724 => {
    //   block [0x82ED4724..0x82ED4740)
	// 82ED4724: 814A007C  lwz r10, 0x7c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(124 as u32) ) } as u64;
	// 82ED4728: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED472C: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED4730: 7D2951D6  mullw r9, r9, r10
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82ED4734: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82ED4738: 7F09E840  cmplw cr6, r9, r29
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82ED473C: 419AFF38  beq cr6, 0x82ed4674
	if ctx.cr[6].eq {
	pc = 0x82ED4674; continue 'dispatch;
	}
	pc = 0x82ED4740; continue 'dispatch;
            }
            0x82ED4740 => {
    //   block [0x82ED4740..0x82ED474C)
	// 82ED4740: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 82ED4744: 409A0008  bne cr6, 0x82ed474c
	if !ctx.cr[6].eq {
	pc = 0x82ED474C; continue 'dispatch;
	}
	// 82ED4748: 7FB6EB78  mr r22, r29
	ctx.r[22].u64 = ctx.r[29].u64;
	pc = 0x82ED474C; continue 'dispatch;
            }
            0x82ED474C => {
    //   block [0x82ED474C..0x82ED4758)
	// 82ED474C: 83BD0014  lwz r29, 0x14(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED4750: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED4754: 4082FED8  bne 0x82ed462c
	if !ctx.cr[0].eq {
	pc = 0x82ED462C; continue 'dispatch;
	}
	pc = 0x82ED4758; continue 'dispatch;
            }
            0x82ED4758 => {
    //   block [0x82ED4758..0x82ED4784)
	// 82ED4758: 817CFFFC  lwz r11, -4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82ED475C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED4760: 419A0024  beq cr6, 0x82ed4784
	if ctx.cr[6].eq {
	pc = 0x82ED4784; continue 'dispatch;
	}
	// 82ED4764: 81791000  lwz r11, 0x1000(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4096 as u32) ) } as u64;
	// 82ED4768: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ED476C: 91780000  stw r11, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ED4770: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED4774: 80780000  lwz r3, 0(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED4778: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ED477C: 9178000C  stw r11, 0xc(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82ED4780: 48000008  b 0x82ed4788
	pc = 0x82ED4788; continue 'dispatch;
            }
            0x82ED4784 => {
    //   block [0x82ED4784..0x82ED4788)
	// 82ED4784: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82ED4788; continue 'dispatch;
            }
            0x82ED4788 => {
    //   block [0x82ED4788..0x82ED4790)
	// 82ED4788: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82ED478C: 4BDD4CB4  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED4790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED4790 size=180
    let mut pc: u32 = 0x82ED4790;
    'dispatch: loop {
        match pc {
            0x82ED4790 => {
    //   block [0x82ED4790..0x82ED47DC)
	// 82ED4790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED4794: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED4798: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED479C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED47A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED47A4: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED47A8: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED47AC: 41820080  beq 0x82ed482c
	if ctx.cr[0].eq {
	pc = 0x82ED482C; continue 'dispatch;
	}
	// 82ED47B0: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED47B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED47B8: 40820024  bne 0x82ed47dc
	if !ctx.cr[0].eq {
	pc = 0x82ED47DC; continue 'dispatch;
	}
	// 82ED47BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED47C0: 4BFFF1B1  bl 0x82ed3970
	ctx.lr = 0x82ED47C4;
	sub_82ED3970(ctx, base);
	// 82ED47C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED47C8: 41820064  beq 0x82ed482c
	if ctx.cr[0].eq {
	pc = 0x82ED482C; continue 'dispatch;
	}
	// 82ED47CC: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED47D0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED47D4: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82ED47D8: 41820054  beq 0x82ed482c
	if ctx.cr[0].eq {
	pc = 0x82ED482C; continue 'dispatch;
	}
	pc = 0x82ED47DC; continue 'dispatch;
            }
            0x82ED47DC => {
    //   block [0x82ED47DC..0x82ED482C)
	// 82ED47DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED47E0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED47E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED47E8: 4E800421  bctrl
	ctx.lr = 0x82ED47EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED47EC: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82ED47F0: 409A003C  bne cr6, 0x82ed482c
	if !ctx.cr[6].eq {
	pc = 0x82ED482C; continue 'dispatch;
	}
	// 82ED47F4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED47F8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED47FC: 556A0001  rlwinm. r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ED4800: 4082002C  bne 0x82ed482c
	if !ctx.cr[0].eq {
	pc = 0x82ED482C; continue 'dispatch;
	}
	// 82ED4804: 3D200000  lis r9, 0
	ctx.r[9].s64 = 0;
	// 82ED4808: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED480C: 612984FC  ori r9, r9, 0x84fc
	ctx.r[9].u64 = ctx.r[9].u64 | 34044;
	// 82ED4810: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82ED4814: 806A001C  lwz r3, 0x1c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED4818: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED481C: 41820010  beq 0x82ed482c
	if ctx.cr[0].eq {
	pc = 0x82ED482C; continue 'dispatch;
	}
	// 82ED4820: 5564847E  rlwinm r4, r11, 0x10, 0x11, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82ED4824: 4BFC7E8D  bl 0x82e9c6b0
	ctx.lr = 0x82ED4828;
	sub_82E9C6B0(ctx, base);
	// 82ED4828: 48000008  b 0x82ed4830
	pc = 0x82ED4830; continue 'dispatch;
            }
            0x82ED482C => {
    //   block [0x82ED482C..0x82ED4830)
	// 82ED482C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82ED4830; continue 'dispatch;
            }
            0x82ED4830 => {
    //   block [0x82ED4830..0x82ED4844)
	// 82ED4830: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ED4834: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED4838: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED483C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED4840: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED4848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED4848 size=200
    let mut pc: u32 = 0x82ED4848;
    'dispatch: loop {
        match pc {
            0x82ED4848 => {
    //   block [0x82ED4848..0x82ED4870)
	// 82ED4848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED484C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED4850: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ED4854: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED4858: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED485C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED4860: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ED4864: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED4868: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED486C: 4082000C  bne 0x82ed4878
	if !ctx.cr[0].eq {
	pc = 0x82ED4878; continue 'dispatch;
	}
	pc = 0x82ED4870; continue 'dispatch;
            }
            0x82ED4870 => {
    //   block [0x82ED4870..0x82ED4878)
	// 82ED4870: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ED4874: 48000084  b 0x82ed48f8
	pc = 0x82ED48F8; continue 'dispatch;
            }
            0x82ED4878 => {
    //   block [0x82ED4878..0x82ED48A4)
	// 82ED4878: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED487C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED4880: 40820024  bne 0x82ed48a4
	if !ctx.cr[0].eq {
	pc = 0x82ED48A4; continue 'dispatch;
	}
	// 82ED4884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED4888: 4BFFF0E9  bl 0x82ed3970
	ctx.lr = 0x82ED488C;
	sub_82ED3970(ctx, base);
	// 82ED488C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED4890: 4182FFE0  beq 0x82ed4870
	if ctx.cr[0].eq {
	pc = 0x82ED4870; continue 'dispatch;
	}
	// 82ED4894: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED4898: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED489C: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82ED48A0: 4182FFD0  beq 0x82ed4870
	if ctx.cr[0].eq {
	pc = 0x82ED4870; continue 'dispatch;
	}
	pc = 0x82ED48A4; continue 'dispatch;
            }
            0x82ED48A4 => {
    //   block [0x82ED48A4..0x82ED48F4)
	// 82ED48A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED48A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED48AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED48B0: 4E800421  bctrl
	ctx.lr = 0x82ED48B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED48B4: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82ED48B8: 409AFFB8  bne cr6, 0x82ed4870
	if !ctx.cr[6].eq {
	pc = 0x82ED4870; continue 'dispatch;
	}
	// 82ED48BC: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED48C0: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED48C4: 556B0001  rlwinm. r11, r11, 0, 0, 0
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED48C8: 4082002C  bne 0x82ed48f4
	if !ctx.cr[0].eq {
	pc = 0x82ED48F4; continue 'dispatch;
	}
	// 82ED48CC: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ED48D0: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED48D4: 616B84FC  ori r11, r11, 0x84fc
	ctx.r[11].u64 = ctx.r[11].u64 | 34044;
	// 82ED48D8: 7D64582E  lwzx r11, r4, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ED48DC: 806B001C  lwz r3, 0x1c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED48E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED48E4: 41820010  beq 0x82ed48f4
	if ctx.cr[0].eq {
	pc = 0x82ED48F4; continue 'dispatch;
	}
	// 82ED48E8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82ED48EC: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED48F0: 4BFC7DE1  bl 0x82e9c6d0
	ctx.lr = 0x82ED48F4;
	sub_82E9C6D0(ctx, base);
            }
            0x82ED48F4 => {
    //   block [0x82ED48F4..0x82ED48F8)
	// 82ED48F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82ED48F8; continue 'dispatch;
            }
            0x82ED48F8 => {
    //   block [0x82ED48F8..0x82ED4910)
	// 82ED48F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ED48FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED4900: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED4904: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ED4908: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED490C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED4910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED4910 size=204
    let mut pc: u32 = 0x82ED4910;
    'dispatch: loop {
        match pc {
            0x82ED4910 => {
    //   block [0x82ED4910..0x82ED4934)
	// 82ED4910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED4914: 4BDD4AF5  bl 0x82ca9408
	ctx.lr = 0x82ED4918;
	sub_82CA93D0(ctx, base);
	// 82ED4918: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED491C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED4920: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ED4924: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82ED4928: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED492C: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED4930: 4082000C  bne 0x82ed493c
	if !ctx.cr[0].eq {
	pc = 0x82ED493C; continue 'dispatch;
	}
	pc = 0x82ED4934; continue 'dispatch;
            }
            0x82ED4934 => {
    //   block [0x82ED4934..0x82ED493C)
	// 82ED4934: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ED4938: 4800009C  b 0x82ed49d4
	pc = 0x82ED49D4; continue 'dispatch;
            }
            0x82ED493C => {
    //   block [0x82ED493C..0x82ED4968)
	// 82ED493C: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED4940: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED4944: 40820024  bne 0x82ed4968
	if !ctx.cr[0].eq {
	pc = 0x82ED4968; continue 'dispatch;
	}
	// 82ED4948: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED494C: 4BFFF025  bl 0x82ed3970
	ctx.lr = 0x82ED4950;
	sub_82ED3970(ctx, base);
	// 82ED4950: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED4954: 4182FFE0  beq 0x82ed4934
	if ctx.cr[0].eq {
	pc = 0x82ED4934; continue 'dispatch;
	}
	// 82ED4958: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED495C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED4960: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82ED4964: 4182FFD0  beq 0x82ed4934
	if ctx.cr[0].eq {
	pc = 0x82ED4934; continue 'dispatch;
	}
	pc = 0x82ED4968; continue 'dispatch;
            }
            0x82ED4968 => {
    //   block [0x82ED4968..0x82ED49D0)
	// 82ED4968: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED496C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED4970: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED4974: 4E800421  bctrl
	ctx.lr = 0x82ED4978;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED4978: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82ED497C: 409AFFB8  bne cr6, 0x82ed4934
	if !ctx.cr[6].eq {
	pc = 0x82ED4934; continue 'dispatch;
	}
	// 82ED4980: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED4984: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82ED4988: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED498C: 556B0001  rlwinm. r11, r11, 0, 0, 0
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED4990: 40820040  bne 0x82ed49d0
	if !ctx.cr[0].eq {
	pc = 0x82ED49D0; continue 'dispatch;
	}
	// 82ED4994: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ED4998: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED499C: 616B84FC  ori r11, r11, 0x84fc
	ctx.r[11].u64 = ctx.r[11].u64 | 34044;
	// 82ED49A0: 7D64582E  lwzx r11, r4, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ED49A4: 806B001C  lwz r3, 0x1c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED49A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED49AC: 41820024  beq 0x82ed49d0
	if ctx.cr[0].eq {
	pc = 0x82ED49D0; continue 'dispatch;
	}
	// 82ED49B0: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 82ED49B4: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED49B8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82ED49BC: 4BFC7E4D  bl 0x82e9c808
	ctx.lr = 0x82ED49C0;
	sub_82E9C808(ctx, base);
	// 82ED49C0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82ED49C4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ED49C8: 409A0008  bne cr6, 0x82ed49d0
	if !ctx.cr[6].eq {
	pc = 0x82ED49D0; continue 'dispatch;
	}
	// 82ED49CC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
            }
            0x82ED49D0 => {
    //   block [0x82ED49D0..0x82ED49D4)
	// 82ED49D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x82ED49D4; continue 'dispatch;
            }
            0x82ED49D4 => {
    //   block [0x82ED49D4..0x82ED49DC)
	// 82ED49D4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ED49D8: 4BDD4A80  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED49E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED49E0 size=360
    let mut pc: u32 = 0x82ED49E0;
    'dispatch: loop {
        match pc {
            0x82ED49E0 => {
    //   block [0x82ED49E0..0x82ED4A1C)
	// 82ED49E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED49E4: 4BDD4A11  bl 0x82ca93f4
	ctx.lr = 0x82ED49E8;
	sub_82CA93D0(ctx, base);
	// 82ED49E8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED49EC: 3F808336  lis r28, -0x7cca
	ctx.r[28].s64 = -2093613056;
	// 82ED49F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ED49F4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82ED49F8: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 82ED49FC: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 82ED4A00: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82ED4A04: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ED4A08: 917C89B4  stw r11, -0x764c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(-30284 as u32), ctx.r[11].u32 ) };
	// 82ED4A0C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82ED4A10: 419A0114  beq cr6, 0x82ed4b24
	if ctx.cr[6].eq {
	pc = 0x82ED4B24; continue 'dispatch;
	}
	// 82ED4A14: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82ED4A18: 3B2AF9A8  addi r25, r10, -0x658
	ctx.r[25].s64 = ctx.r[10].s64 + -1624;
	pc = 0x82ED4A1C; continue 'dispatch;
            }
            0x82ED4A1C => {
    //   block [0x82ED4A1C..0x82ED4A64)
	// 82ED4A1C: 7F1DD040  cmplw cr6, r29, r26
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82ED4A20: 419A0104  beq cr6, 0x82ed4b24
	if ctx.cr[6].eq {
	pc = 0x82ED4B24; continue 'dispatch;
	}
	// 82ED4A24: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ED4A28: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82ED4A2C: 4BFFEF45  bl 0x82ed3970
	ctx.lr = 0x82ED4A30;
	sub_82ED3970(ctx, base);
	// 82ED4A30: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED4A34: 418200FC  beq 0x82ed4b30
	if ctx.cr[0].eq {
	pc = 0x82ED4B30; continue 'dispatch;
	}
	// 82ED4A38: 83E30014  lwz r31, 0x14(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED4A3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED4A40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED4A44: 83DF0030  lwz r30, 0x30(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ED4A48: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED4A4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED4A50: 4E800421  bctrl
	ctx.lr = 0x82ED4A54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED4A54: 817C89B4  lwz r11, -0x764c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-30284 as u32) ) } as u64;
	// 82ED4A58: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ED4A5C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED4A60: 418200AC  beq 0x82ed4b0c
	if ctx.cr[0].eq {
	pc = 0x82ED4B0C; continue 'dispatch;
	}
            }
            0x82ED4A64 => {
    //   block [0x82ED4A64..0x82ED4AA8)
	// 82ED4A64: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED4A68: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED4A6C: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED4A70: 8129007C  lwz r9, 0x7c(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 82ED4A74: 7D0849D6  mullw r8, r8, r9
	ctx.r[8].s32 = ((ctx.r[8].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82ED4A78: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82ED4A7C: 7F08E840  cmplw cr6, r8, r29
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82ED4A80: 409A0074  bne cr6, 0x82ed4af4
	if !ctx.cr[6].eq {
	pc = 0x82ED4AF4; continue 'dispatch;
	}
	// 82ED4A84: 80FE0004  lwz r7, 4(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED4A88: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82ED4A8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED4A90: 7D2749D6  mullw r9, r7, r9
	ctx.r[9].s32 = ((ctx.r[7].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82ED4A94: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82ED4A98: 5547007E  clrlwi r7, r10, 1
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0x7FFFFFFFu64;
	// 82ED4A9C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ED4AA0: 419A002C  beq cr6, 0x82ed4acc
	if ctx.cr[6].eq {
	pc = 0x82ED4ACC; continue 'dispatch;
	}
	// 82ED4AA4: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	pc = 0x82ED4AA8; continue 'dispatch;
            }
            0x82ED4AA8 => {
    //   block [0x82ED4AA8..0x82ED4AC8)
	// 82ED4AA8: 80A90000  lwz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED4AAC: 7F053840  cmplw cr6, r5, r7
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82ED4AB0: 419A0018  beq cr6, 0x82ed4ac8
	if ctx.cr[6].eq {
	pc = 0x82ED4AC8; continue 'dispatch;
	}
	// 82ED4AB4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ED4AB8: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82ED4ABC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED4AC0: 4198FFE8  blt cr6, 0x82ed4aa8
	if ctx.cr[6].lt {
	pc = 0x82ED4AA8; continue 'dispatch;
	}
	// 82ED4AC4: 48000008  b 0x82ed4acc
	pc = 0x82ED4ACC; continue 'dispatch;
            }
            0x82ED4AC8 => {
    //   block [0x82ED4AC8..0x82ED4ACC)
	// 82ED4AC8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	pc = 0x82ED4ACC; continue 'dispatch;
            }
            0x82ED4ACC => {
    //   block [0x82ED4ACC..0x82ED4AE4)
	// 82ED4ACC: 550A063F  clrlwi. r10, r8, 0x18
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ED4AD0: 41820024  beq 0x82ed4af4
	if ctx.cr[0].eq {
	pc = 0x82ED4AF4; continue 'dispatch;
	}
	// 82ED4AD4: 56EA063F  clrlwi. r10, r23, 0x18
	ctx.r[10].u64 = ctx.r[23].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ED4AD8: 4082000C  bne 0x82ed4ae4
	if !ctx.cr[0].eq {
	pc = 0x82ED4AE4; continue 'dispatch;
	}
	// 82ED4ADC: 7F0BC040  cmplw cr6, r11, r24
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[24].u32, &mut ctx.xer);
	// 82ED4AE0: 419A0058  beq cr6, 0x82ed4b38
	if ctx.cr[6].eq {
	pc = 0x82ED4B38; continue 'dispatch;
	}
	pc = 0x82ED4AE4; continue 'dispatch;
            }
            0x82ED4AE4 => {
    //   block [0x82ED4AE4..0x82ED4AF4)
	// 82ED4AE4: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ED4AE8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ED4AEC: 7CEAC92E  stwx r7, r10, r25
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[25].u32), ctx.r[7].u32) };
	// 82ED4AF0: 917C89B4  stw r11, -0x764c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(-30284 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED4AF4; continue 'dispatch;
            }
            0x82ED4AF4 => {
    //   block [0x82ED4AF4..0x82ED4B0C)
	// 82ED4AF4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED4AF8: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82ED4AFC: 7F061840  cmplw cr6, r6, r3
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82ED4B00: 814A0080  lwz r10, 0x80(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 82ED4B04: 7FCAF214  add r30, r10, r30
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82ED4B08: 4198FF5C  blt cr6, 0x82ed4a64
	if ctx.cr[6].lt {
	pc = 0x82ED4A64; continue 'dispatch;
	}
	pc = 0x82ED4B0C; continue 'dispatch;
            }
            0x82ED4B0C => {
    //   block [0x82ED4B0C..0x82ED4B18)
	// 82ED4B0C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82ED4B10: 409A0008  bne cr6, 0x82ed4b18
	if !ctx.cr[6].eq {
	pc = 0x82ED4B18; continue 'dispatch;
	}
	// 82ED4B14: 7FBAEB78  mr r26, r29
	ctx.r[26].u64 = ctx.r[29].u64;
	pc = 0x82ED4B18; continue 'dispatch;
            }
            0x82ED4B18 => {
    //   block [0x82ED4B18..0x82ED4B24)
	// 82ED4B18: 83BD0014  lwz r29, 0x14(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED4B1C: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED4B20: 4082FEFC  bne 0x82ed4a1c
	if !ctx.cr[0].eq {
	pc = 0x82ED4A1C; continue 'dispatch;
	}
	pc = 0x82ED4B24; continue 'dispatch;
            }
            0x82ED4B24 => {
    //   block [0x82ED4B24..0x82ED4B28)
	// 82ED4B24: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	pc = 0x82ED4B28; continue 'dispatch;
            }
            0x82ED4B28 => {
    //   block [0x82ED4B28..0x82ED4B30)
	// 82ED4B28: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82ED4B2C: 4BDD4918  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82ED4B30 => {
    //   block [0x82ED4B30..0x82ED4B38)
	// 82ED4B30: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82ED4B34: 4BFFFFF4  b 0x82ed4b28
	pc = 0x82ED4B28; continue 'dispatch;
            }
            0x82ED4B38 => {
    //   block [0x82ED4B38..0x82ED4B48)
	// 82ED4B38: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ED4B3C: 93DB0000  stw r30, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82ED4B40: 93FB000C  stw r31, 0xc(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82ED4B44: 4BFFFFE4  b 0x82ed4b28
	pc = 0x82ED4B28; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED4B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED4B48 size=356
    let mut pc: u32 = 0x82ED4B48;
    'dispatch: loop {
        match pc {
            0x82ED4B48 => {
    //   block [0x82ED4B48..0x82ED4B84)
	// 82ED4B48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED4B4C: 4BDD48A5  bl 0x82ca93f0
	ctx.lr = 0x82ED4B50;
	sub_82CA93D0(ctx, base);
	// 82ED4B50: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED4B54: 3F608336  lis r27, -0x7cca
	ctx.r[27].s64 = -2093613056;
	// 82ED4B58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ED4B5C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82ED4B60: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 82ED4B64: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 82ED4B68: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82ED4B6C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82ED4B70: 917B89B4  stw r11, -0x764c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(-30284 as u32), ctx.r[11].u32 ) };
	// 82ED4B74: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82ED4B78: 419A0108  beq cr6, 0x82ed4c80
	if ctx.cr[6].eq {
	pc = 0x82ED4C80; continue 'dispatch;
	}
	// 82ED4B7C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82ED4B80: 3B0AF9A8  addi r24, r10, -0x658
	ctx.r[24].s64 = ctx.r[10].s64 + -1624;
	pc = 0x82ED4B84; continue 'dispatch;
            }
            0x82ED4B84 => {
    //   block [0x82ED4B84..0x82ED4BD4)
	// 82ED4B84: 7F1CC840  cmplw cr6, r28, r25
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82ED4B88: 419A00F8  beq cr6, 0x82ed4c80
	if ctx.cr[6].eq {
	pc = 0x82ED4C80; continue 'dispatch;
	}
	// 82ED4B8C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82ED4B90: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82ED4B94: 4BFFEDDD  bl 0x82ed3970
	ctx.lr = 0x82ED4B98;
	sub_82ED3970(ctx, base);
	// 82ED4B98: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED4B9C: 418200F0  beq 0x82ed4c8c
	if ctx.cr[0].eq {
	pc = 0x82ED4C8C; continue 'dispatch;
	}
	// 82ED4BA0: 83E30014  lwz r31, 0x14(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED4BA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED4BA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED4BAC: 83BF0030  lwz r29, 0x30(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ED4BB0: 83DF002C  lwz r30, 0x2c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED4BB4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED4BB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED4BBC: 4E800421  bctrl
	ctx.lr = 0x82ED4BC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED4BC0: 817B89B4  lwz r11, -0x764c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-30284 as u32) ) } as u64;
	// 82ED4BC4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82ED4BC8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED4BCC: 4182009C  beq 0x82ed4c68
	if ctx.cr[0].eq {
	pc = 0x82ED4C68; continue 'dispatch;
	}
	// 82ED4BD0: 38DD0004  addi r6, r29, 4
	ctx.r[6].s64 = ctx.r[29].s64 + 4;
            }
            0x82ED4BD4 => {
    //   block [0x82ED4BD4..0x82ED4C0C)
	// 82ED4BD4: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED4BD8: 554A2834  slwi r10, r10, 5
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ED4BDC: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82ED4BE0: 7F0AE040  cmplw cr6, r10, r28
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82ED4BE4: 409A0074  bne cr6, 0x82ed4c58
	if !ctx.cr[6].eq {
	pc = 0x82ED4C58; continue 'dispatch;
	}
	// 82ED4BE8: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED4BEC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82ED4BF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED4BF4: 55492834  slwi r9, r10, 5
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82ED4BF8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ED4BFC: 7D29F02E  lwzx r9, r9, r30
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82ED4C00: 5527007E  clrlwi r7, r9, 1
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x7FFFFFFFu64;
	// 82ED4C04: 419A002C  beq cr6, 0x82ed4c30
	if ctx.cr[6].eq {
	pc = 0x82ED4C30; continue 'dispatch;
	}
	// 82ED4C08: 7F09C378  mr r9, r24
	ctx.r[9].u64 = ctx.r[24].u64;
	pc = 0x82ED4C0C; continue 'dispatch;
            }
            0x82ED4C0C => {
    //   block [0x82ED4C0C..0x82ED4C2C)
	// 82ED4C0C: 80890000  lwz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED4C10: 7F043840  cmplw cr6, r4, r7
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82ED4C14: 419A0018  beq cr6, 0x82ed4c2c
	if ctx.cr[6].eq {
	pc = 0x82ED4C2C; continue 'dispatch;
	}
	// 82ED4C18: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ED4C1C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82ED4C20: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED4C24: 4198FFE8  blt cr6, 0x82ed4c0c
	if ctx.cr[6].lt {
	pc = 0x82ED4C0C; continue 'dispatch;
	}
	// 82ED4C28: 48000008  b 0x82ed4c30
	pc = 0x82ED4C30; continue 'dispatch;
            }
            0x82ED4C2C => {
    //   block [0x82ED4C2C..0x82ED4C30)
	// 82ED4C2C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	pc = 0x82ED4C30; continue 'dispatch;
            }
            0x82ED4C30 => {
    //   block [0x82ED4C30..0x82ED4C48)
	// 82ED4C30: 550A063F  clrlwi. r10, r8, 0x18
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ED4C34: 41820024  beq 0x82ed4c58
	if ctx.cr[0].eq {
	pc = 0x82ED4C58; continue 'dispatch;
	}
	// 82ED4C38: 56CA063F  clrlwi. r10, r22, 0x18
	ctx.r[10].u64 = ctx.r[22].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ED4C3C: 4082000C  bne 0x82ed4c48
	if !ctx.cr[0].eq {
	pc = 0x82ED4C48; continue 'dispatch;
	}
	// 82ED4C40: 7F0BB840  cmplw cr6, r11, r23
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[23].u32, &mut ctx.xer);
	// 82ED4C44: 419A0050  beq cr6, 0x82ed4c94
	if ctx.cr[6].eq {
	pc = 0x82ED4C94; continue 'dispatch;
	}
	pc = 0x82ED4C48; continue 'dispatch;
            }
            0x82ED4C48 => {
    //   block [0x82ED4C48..0x82ED4C58)
	// 82ED4C48: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ED4C4C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ED4C50: 7CEAC12E  stwx r7, r10, r24
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[24].u32), ctx.r[7].u32) };
	// 82ED4C54: 917B89B4  stw r11, -0x764c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(-30284 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED4C58; continue 'dispatch;
            }
            0x82ED4C58 => {
    //   block [0x82ED4C58..0x82ED4C68)
	// 82ED4C58: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82ED4C5C: 38C60010  addi r6, r6, 0x10
	ctx.r[6].s64 = ctx.r[6].s64 + 16;
	// 82ED4C60: 7F051840  cmplw cr6, r5, r3
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82ED4C64: 4198FF70  blt cr6, 0x82ed4bd4
	if ctx.cr[6].lt {
	pc = 0x82ED4BD4; continue 'dispatch;
	}
	pc = 0x82ED4C68; continue 'dispatch;
            }
            0x82ED4C68 => {
    //   block [0x82ED4C68..0x82ED4C74)
	// 82ED4C68: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82ED4C6C: 409A0008  bne cr6, 0x82ed4c74
	if !ctx.cr[6].eq {
	pc = 0x82ED4C74; continue 'dispatch;
	}
	// 82ED4C70: 7F99E378  mr r25, r28
	ctx.r[25].u64 = ctx.r[28].u64;
	pc = 0x82ED4C74; continue 'dispatch;
            }
            0x82ED4C74 => {
    //   block [0x82ED4C74..0x82ED4C80)
	// 82ED4C74: 839C0018  lwz r28, 0x18(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ED4C78: 281C0000  cmplwi r28, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED4C7C: 4082FF08  bne 0x82ed4b84
	if !ctx.cr[0].eq {
	pc = 0x82ED4B84; continue 'dispatch;
	}
	pc = 0x82ED4C80; continue 'dispatch;
            }
            0x82ED4C80 => {
    //   block [0x82ED4C80..0x82ED4C84)
	// 82ED4C80: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	pc = 0x82ED4C84; continue 'dispatch;
            }
            0x82ED4C84 => {
    //   block [0x82ED4C84..0x82ED4C8C)
	// 82ED4C84: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82ED4C88: 4BDD47B8  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x82ED4C8C => {
    //   block [0x82ED4C8C..0x82ED4C94)
	// 82ED4C8C: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82ED4C90: 4BFFFFF4  b 0x82ed4c84
	pc = 0x82ED4C84; continue 'dispatch;
            }
            0x82ED4C94 => {
    //   block [0x82ED4C94..0x82ED4CAC)
	// 82ED4C94: 54AB2036  slwi r11, r5, 4
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED4C98: 93FA000C  stw r31, 0xc(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82ED4C9C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ED4CA0: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82ED4CA4: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ED4CA8: 4BFFFFDC  b 0x82ed4c84
	pc = 0x82ED4C84; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED4CB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED4CB0 size=432
    let mut pc: u32 = 0x82ED4CB0;
    'dispatch: loop {
        match pc {
            0x82ED4CB0 => {
    //   block [0x82ED4CB0..0x82ED4CE8)
	// 82ED4CB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED4CB4: 4BDD4739  bl 0x82ca93ec
	ctx.lr = 0x82ED4CB8;
	sub_82CA93D0(ctx, base);
	// 82ED4CB8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED4CBC: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82ED4CC0: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 82ED4CC4: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 82ED4CC8: 7CF63B78  mr r22, r7
	ctx.r[22].u64 = ctx.r[7].u64;
	// 82ED4CCC: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82ED4CD0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ED4CD4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82ED4CD8: 3F608336  lis r27, -0x7cca
	ctx.r[27].s64 = -2093613056;
	// 82ED4CDC: 419A0158  beq cr6, 0x82ed4e34
	if ctx.cr[6].eq {
	pc = 0x82ED4E34; continue 'dispatch;
	}
	// 82ED4CE0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ED4CE4: 3B0BF9A8  addi r24, r11, -0x658
	ctx.r[24].s64 = ctx.r[11].s64 + -1624;
	pc = 0x82ED4CE8; continue 'dispatch;
            }
            0x82ED4CE8 => {
    //   block [0x82ED4CE8..0x82ED4D30)
	// 82ED4CE8: 7F1DC840  cmplw cr6, r29, r25
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82ED4CEC: 419A0148  beq cr6, 0x82ed4e34
	if ctx.cr[6].eq {
	pc = 0x82ED4E34; continue 'dispatch;
	}
	// 82ED4CF0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ED4CF4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82ED4CF8: 4BFFEC79  bl 0x82ed3970
	ctx.lr = 0x82ED4CFC;
	sub_82ED3970(ctx, base);
	// 82ED4CFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED4D00: 4182011C  beq 0x82ed4e1c
	if ctx.cr[0].eq {
	pc = 0x82ED4E1C; continue 'dispatch;
	}
	// 82ED4D04: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ED4D08: 83C30014  lwz r30, 0x14(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED4D0C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED4D10: 4182010C  beq 0x82ed4e1c
	if ctx.cr[0].eq {
	pc = 0x82ED4E1C; continue 'dispatch;
	}
	// 82ED4D14: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED4D18: 3B8BFFFF  addi r28, r11, -1
	ctx.r[28].s64 = ctx.r[11].s64 + -1;
	// 82ED4D1C: 811E0030  lwz r8, 0x30(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ED4D20: 812A0080  lwz r9, 0x80(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 82ED4D24: 7D29E1D6  mullw r9, r9, r28
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * ctx.r[28].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82ED4D28: 7FE94214  add r31, r9, r8
	ctx.r[31].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82ED4D2C: 480000D4  b 0x82ed4e00
	pc = 0x82ED4E00; continue 'dispatch;
            }
            0x82ED4D30 => {
    //   block [0x82ED4D30..0x82ED4D5C)
	// 82ED4D30: 80FF0008  lwz r7, 8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED4D34: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82ED4D38: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82ED4D3C: 7D4751D6  mullw r10, r7, r10
	ctx.r[10].s32 = ((ctx.r[7].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82ED4D40: 7CEA5A14  add r7, r10, r11
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82ED4D44: 817B89B4  lwz r11, -0x764c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-30284 as u32) ) } as u64;
	// 82ED4D48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED4D4C: 81470000  lwz r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED4D50: 5546007E  clrlwi r6, r10, 1
	ctx.r[6].u64 = ctx.r[10].u32 as u64 & 0x7FFFFFFFu64;
	// 82ED4D54: 419A0030  beq cr6, 0x82ed4d84
	if ctx.cr[6].eq {
	pc = 0x82ED4D84; continue 'dispatch;
	}
	// 82ED4D58: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	pc = 0x82ED4D5C; continue 'dispatch;
            }
            0x82ED4D5C => {
    //   block [0x82ED4D5C..0x82ED4D74)
	// 82ED4D5C: 5505063F  clrlwi. r5, r8, 0x18
	ctx.r[5].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82ED4D60: 41820024  beq 0x82ed4d84
	if ctx.cr[0].eq {
	pc = 0x82ED4D84; continue 'dispatch;
	}
	// 82ED4D64: 80AA0000  lwz r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED4D68: 7F053040  cmplw cr6, r5, r6
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82ED4D6C: 409A0008  bne cr6, 0x82ed4d74
	if !ctx.cr[6].eq {
	pc = 0x82ED4D74; continue 'dispatch;
	}
	// 82ED4D70: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	pc = 0x82ED4D74; continue 'dispatch;
            }
            0x82ED4D74 => {
    //   block [0x82ED4D74..0x82ED4D84)
	// 82ED4D74: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ED4D78: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82ED4D7C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED4D80: 4198FFDC  blt cr6, 0x82ed4d5c
	if ctx.cr[6].lt {
	pc = 0x82ED4D5C; continue 'dispatch;
	}
	pc = 0x82ED4D84; continue 'dispatch;
            }
            0x82ED4D84 => {
    //   block [0x82ED4D84..0x82ED4DA4)
	// 82ED4D84: 550A063F  clrlwi. r10, r8, 0x18
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ED4D88: 4182004C  beq 0x82ed4dd4
	if ctx.cr[0].eq {
	pc = 0x82ED4DD4; continue 'dispatch;
	}
	// 82ED4D8C: 56A9063F  clrlwi. r9, r21, 0x18
	ctx.r[9].u64 = ctx.r[21].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82ED4D90: 40820024  bne 0x82ed4db4
	if !ctx.cr[0].eq {
	pc = 0x82ED4DB4; continue 'dispatch;
	}
	// 82ED4D94: 56CA063F  clrlwi. r10, r22, 0x18
	ctx.r[10].u64 = ctx.r[22].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ED4D98: 4182000C  beq 0x82ed4da4
	if ctx.cr[0].eq {
	pc = 0x82ED4DA4; continue 'dispatch;
	}
	// 82ED4D9C: 7F0BB840  cmplw cr6, r11, r23
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[23].u32, &mut ctx.xer);
	// 82ED4DA0: 419A00A4  beq cr6, 0x82ed4e44
	if ctx.cr[6].eq {
	pc = 0x82ED4E44; continue 'dispatch;
	}
	pc = 0x82ED4DA4; continue 'dispatch;
            }
            0x82ED4DA4 => {
    //   block [0x82ED4DA4..0x82ED4DB4)
	// 82ED4DA4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82ED4DA8: 409A000C  bne cr6, 0x82ed4db4
	if !ctx.cr[6].eq {
	pc = 0x82ED4DB4; continue 'dispatch;
	}
	// 82ED4DAC: 7F173840  cmplw cr6, r23, r7
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82ED4DB0: 419A0094  beq cr6, 0x82ed4e44
	if ctx.cr[6].eq {
	pc = 0x82ED4E44; continue 'dispatch;
	}
	pc = 0x82ED4DB4; continue 'dispatch;
            }
            0x82ED4DB4 => {
    //   block [0x82ED4DB4..0x82ED4DC4)
	// 82ED4DB4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82ED4DB8: 409A000C  bne cr6, 0x82ed4dc4
	if !ctx.cr[6].eq {
	pc = 0x82ED4DC4; continue 'dispatch;
	}
	// 82ED4DBC: 56CA063F  clrlwi. r10, r22, 0x18
	ctx.r[10].u64 = ctx.r[22].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ED4DC0: 41820014  beq 0x82ed4dd4
	if ctx.cr[0].eq {
	pc = 0x82ED4DD4; continue 'dispatch;
	}
	pc = 0x82ED4DC4; continue 'dispatch;
            }
            0x82ED4DC4 => {
    //   block [0x82ED4DC4..0x82ED4DD4)
	// 82ED4DC4: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ED4DC8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ED4DCC: 7CCAC12E  stwx r6, r10, r24
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[24].u32), ctx.r[6].u32) };
	// 82ED4DD0: 917B89B4  stw r11, -0x764c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(-30284 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED4DD4; continue 'dispatch;
            }
            0x82ED4DD4 => {
    //   block [0x82ED4DD4..0x82ED4E00)
	// 82ED4DD4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED4DD8: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82ED4DDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED4DE0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED4DE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED4DE8: 4E800421  bctrl
	ctx.lr = 0x82ED4DEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED4DEC: 7F1C1840  cmplw cr6, r28, r3
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82ED4DF0: 4098002C  bge cr6, 0x82ed4e1c
	if !ctx.cr[6].lt {
	pc = 0x82ED4E1C; continue 'dispatch;
	}
	// 82ED4DF4: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED4DF8: 812A0080  lwz r9, 0x80(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 82ED4DFC: 7FE9FA14  add r31, r9, r31
	ctx.r[31].u64 = ctx.r[9].u64 + ctx.r[31].u64;
            }
            0x82ED4E00 => {
    //   block [0x82ED4E00..0x82ED4E1C)
	// 82ED4E00: 814A007C  lwz r10, 0x7c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(124 as u32) ) } as u64;
	// 82ED4E04: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED4E08: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED4E0C: 7D2951D6  mullw r9, r9, r10
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82ED4E10: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82ED4E14: 7F09E840  cmplw cr6, r9, r29
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82ED4E18: 419AFF18  beq cr6, 0x82ed4d30
	if ctx.cr[6].eq {
	pc = 0x82ED4D30; continue 'dispatch;
	}
	pc = 0x82ED4E1C; continue 'dispatch;
            }
            0x82ED4E1C => {
    //   block [0x82ED4E1C..0x82ED4E28)
	// 82ED4E1C: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82ED4E20: 409A0008  bne cr6, 0x82ed4e28
	if !ctx.cr[6].eq {
	pc = 0x82ED4E28; continue 'dispatch;
	}
	// 82ED4E24: 7FB9EB78  mr r25, r29
	ctx.r[25].u64 = ctx.r[29].u64;
	pc = 0x82ED4E28; continue 'dispatch;
            }
            0x82ED4E28 => {
    //   block [0x82ED4E28..0x82ED4E34)
	// 82ED4E28: 83BD0014  lwz r29, 0x14(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED4E2C: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED4E30: 4082FEB8  bne 0x82ed4ce8
	if !ctx.cr[0].eq {
	pc = 0x82ED4CE8; continue 'dispatch;
	}
	pc = 0x82ED4E34; continue 'dispatch;
            }
            0x82ED4E34 => {
    //   block [0x82ED4E34..0x82ED4E44)
	// 82ED4E34: 56AB063F  clrlwi. r11, r21, 0x18
	ctx.r[11].u64 = ctx.r[21].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED4E38: 4182001C  beq 0x82ed4e54
	if ctx.cr[0].eq {
	pc = 0x82ED4E54; continue 'dispatch;
	}
	// 82ED4E3C: 807B89B4  lwz r3, -0x764c(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-30284 as u32) ) } as u64;
	// 82ED4E40: 48000018  b 0x82ed4e58
	pc = 0x82ED4E58; continue 'dispatch;
            }
            0x82ED4E44 => {
    //   block [0x82ED4E44..0x82ED4E54)
	// 82ED4E44: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ED4E48: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82ED4E4C: 93DA000C  stw r30, 0xc(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82ED4E50: 48000008  b 0x82ed4e58
	pc = 0x82ED4E58; continue 'dispatch;
            }
            0x82ED4E54 => {
    //   block [0x82ED4E54..0x82ED4E58)
	// 82ED4E54: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82ED4E58; continue 'dispatch;
            }
            0x82ED4E58 => {
    //   block [0x82ED4E58..0x82ED4E60)
	// 82ED4E58: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82ED4E5C: 4BDD45E0  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED4E60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED4E60 size=412
    let mut pc: u32 = 0x82ED4E60;
    'dispatch: loop {
        match pc {
            0x82ED4E60 => {
    //   block [0x82ED4E60..0x82ED4E98)
	// 82ED4E60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED4E64: 4BDD4585  bl 0x82ca93e8
	ctx.lr = 0x82ED4E68;
	sub_82CA93D0(ctx, base);
	// 82ED4E68: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED4E6C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82ED4E70: 7CB42B78  mr r20, r5
	ctx.r[20].u64 = ctx.r[5].u64;
	// 82ED4E74: 7CD63378  mr r22, r6
	ctx.r[22].u64 = ctx.r[6].u64;
	// 82ED4E78: 7CF53B78  mr r21, r7
	ctx.r[21].u64 = ctx.r[7].u64;
	// 82ED4E7C: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82ED4E80: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ED4E84: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82ED4E88: 3F408336  lis r26, -0x7cca
	ctx.r[26].s64 = -2093613056;
	// 82ED4E8C: 419A0144  beq cr6, 0x82ed4fd0
	if ctx.cr[6].eq {
	pc = 0x82ED4FD0; continue 'dispatch;
	}
	// 82ED4E90: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82ED4E94: 3AEBF9A8  addi r23, r11, -0x658
	ctx.r[23].s64 = ctx.r[11].s64 + -1624;
	pc = 0x82ED4E98; continue 'dispatch;
            }
            0x82ED4E98 => {
    //   block [0x82ED4E98..0x82ED4EDC)
	// 82ED4E98: 7F1DC040  cmplw cr6, r29, r24
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[24].u32, &mut ctx.xer);
	// 82ED4E9C: 419A0134  beq cr6, 0x82ed4fd0
	if ctx.cr[6].eq {
	pc = 0x82ED4FD0; continue 'dispatch;
	}
	// 82ED4EA0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ED4EA4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82ED4EA8: 4BFFEAC9  bl 0x82ed3970
	ctx.lr = 0x82ED4EAC;
	sub_82ED3970(ctx, base);
	// 82ED4EAC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED4EB0: 41820108  beq 0x82ed4fb8
	if ctx.cr[0].eq {
	pc = 0x82ED4FB8; continue 'dispatch;
	}
	// 82ED4EB4: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED4EB8: 83830014  lwz r28, 0x14(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED4EBC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED4EC0: 418200F8  beq 0x82ed4fb8
	if ctx.cr[0].eq {
	pc = 0x82ED4FB8; continue 'dispatch;
	}
	// 82ED4EC4: 3B6BFFFF  addi r27, r11, -1
	ctx.r[27].s64 = ctx.r[11].s64 + -1;
	// 82ED4EC8: 817C0030  lwz r11, 0x30(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ED4ECC: 83DC002C  lwz r30, 0x2c(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED4ED0: 576A2036  slwi r10, r27, 4
	ctx.r[10].u32 = ctx.r[27].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ED4ED4: 7FEB5214  add r31, r11, r10
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ED4ED8: 480000CC  b 0x82ed4fa4
	pc = 0x82ED4FA4; continue 'dispatch;
            }
            0x82ED4EDC => {
    //   block [0x82ED4EDC..0x82ED4F08)
	// 82ED4EDC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED4EE0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82ED4EE4: 815A89B4  lwz r10, -0x764c(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-30284 as u32) ) } as u64;
	// 82ED4EE8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82ED4EEC: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED4EF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82ED4EF4: 7CEBF214  add r7, r11, r30
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82ED4EF8: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED4EFC: 5566007E  clrlwi r6, r11, 1
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 82ED4F00: 419A0030  beq cr6, 0x82ed4f30
	if ctx.cr[6].eq {
	pc = 0x82ED4F30; continue 'dispatch;
	}
	// 82ED4F04: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x82ED4F08; continue 'dispatch;
            }
            0x82ED4F08 => {
    //   block [0x82ED4F08..0x82ED4F20)
	// 82ED4F08: 5505063F  clrlwi. r5, r8, 0x18
	ctx.r[5].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82ED4F0C: 41820024  beq 0x82ed4f30
	if ctx.cr[0].eq {
	pc = 0x82ED4F30; continue 'dispatch;
	}
	// 82ED4F10: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED4F14: 7F053040  cmplw cr6, r5, r6
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82ED4F18: 409A0008  bne cr6, 0x82ed4f20
	if !ctx.cr[6].eq {
	pc = 0x82ED4F20; continue 'dispatch;
	}
	// 82ED4F1C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	pc = 0x82ED4F20; continue 'dispatch;
            }
            0x82ED4F20 => {
    //   block [0x82ED4F20..0x82ED4F30)
	// 82ED4F20: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ED4F24: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ED4F28: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ED4F2C: 4198FFDC  blt cr6, 0x82ed4f08
	if ctx.cr[6].lt {
	pc = 0x82ED4F08; continue 'dispatch;
	}
	pc = 0x82ED4F30; continue 'dispatch;
            }
            0x82ED4F30 => {
    //   block [0x82ED4F30..0x82ED4F50)
	// 82ED4F30: 550B063F  clrlwi. r11, r8, 0x18
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED4F34: 4182004C  beq 0x82ed4f80
	if ctx.cr[0].eq {
	pc = 0x82ED4F80; continue 'dispatch;
	}
	// 82ED4F38: 5689063F  clrlwi. r9, r20, 0x18
	ctx.r[9].u64 = ctx.r[20].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82ED4F3C: 40820024  bne 0x82ed4f60
	if !ctx.cr[0].eq {
	pc = 0x82ED4F60; continue 'dispatch;
	}
	// 82ED4F40: 56AB063F  clrlwi. r11, r21, 0x18
	ctx.r[11].u64 = ctx.r[21].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED4F44: 4182000C  beq 0x82ed4f50
	if ctx.cr[0].eq {
	pc = 0x82ED4F50; continue 'dispatch;
	}
	// 82ED4F48: 7F0AB040  cmplw cr6, r10, r22
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[22].u32, &mut ctx.xer);
	// 82ED4F4C: 419A0094  beq cr6, 0x82ed4fe0
	if ctx.cr[6].eq {
	pc = 0x82ED4FE0; continue 'dispatch;
	}
	pc = 0x82ED4F50; continue 'dispatch;
            }
            0x82ED4F50 => {
    //   block [0x82ED4F50..0x82ED4F60)
	// 82ED4F50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED4F54: 409A000C  bne cr6, 0x82ed4f60
	if !ctx.cr[6].eq {
	pc = 0x82ED4F60; continue 'dispatch;
	}
	// 82ED4F58: 7F163840  cmplw cr6, r22, r7
	ctx.cr[6].compare_u32(ctx.r[22].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82ED4F5C: 419A0084  beq cr6, 0x82ed4fe0
	if ctx.cr[6].eq {
	pc = 0x82ED4FE0; continue 'dispatch;
	}
	pc = 0x82ED4F60; continue 'dispatch;
            }
            0x82ED4F60 => {
    //   block [0x82ED4F60..0x82ED4F70)
	// 82ED4F60: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82ED4F64: 409A000C  bne cr6, 0x82ed4f70
	if !ctx.cr[6].eq {
	pc = 0x82ED4F70; continue 'dispatch;
	}
	// 82ED4F68: 56AB063F  clrlwi. r11, r21, 0x18
	ctx.r[11].u64 = ctx.r[21].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED4F6C: 41820014  beq 0x82ed4f80
	if ctx.cr[0].eq {
	pc = 0x82ED4F80; continue 'dispatch;
	}
	pc = 0x82ED4F70; continue 'dispatch;
            }
            0x82ED4F70 => {
    //   block [0x82ED4F70..0x82ED4F80)
	// 82ED4F70: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82ED4F74: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	// 82ED4F78: 7CC9B92E  stwx r6, r9, r23
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[23].u32), ctx.r[6].u32) };
	// 82ED4F7C: 917A89B4  stw r11, -0x764c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(-30284 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED4F80; continue 'dispatch;
            }
            0x82ED4F80 => {
    //   block [0x82ED4F80..0x82ED4FA4)
	// 82ED4F80: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED4F84: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82ED4F88: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ED4F8C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED4F90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED4F94: 4E800421  bctrl
	ctx.lr = 0x82ED4F98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED4F98: 7F1B1840  cmplw cr6, r27, r3
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82ED4F9C: 4098001C  bge cr6, 0x82ed4fb8
	if !ctx.cr[6].lt {
	pc = 0x82ED4FB8; continue 'dispatch;
	}
	// 82ED4FA0: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
            }
            0x82ED4FA4 => {
    //   block [0x82ED4FA4..0x82ED4FB8)
	// 82ED4FA4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED4FA8: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED4FAC: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82ED4FB0: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82ED4FB4: 419AFF28  beq cr6, 0x82ed4edc
	if ctx.cr[6].eq {
	pc = 0x82ED4EDC; continue 'dispatch;
	}
	pc = 0x82ED4FB8; continue 'dispatch;
            }
            0x82ED4FB8 => {
    //   block [0x82ED4FB8..0x82ED4FC4)
	// 82ED4FB8: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82ED4FBC: 409A0008  bne cr6, 0x82ed4fc4
	if !ctx.cr[6].eq {
	pc = 0x82ED4FC4; continue 'dispatch;
	}
	// 82ED4FC0: 7FB8EB78  mr r24, r29
	ctx.r[24].u64 = ctx.r[29].u64;
	pc = 0x82ED4FC4; continue 'dispatch;
            }
            0x82ED4FC4 => {
    //   block [0x82ED4FC4..0x82ED4FD0)
	// 82ED4FC4: 83BD0018  lwz r29, 0x18(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ED4FC8: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED4FCC: 4082FECC  bne 0x82ed4e98
	if !ctx.cr[0].eq {
	pc = 0x82ED4E98; continue 'dispatch;
	}
	pc = 0x82ED4FD0; continue 'dispatch;
            }
            0x82ED4FD0 => {
    //   block [0x82ED4FD0..0x82ED4FE0)
	// 82ED4FD0: 568B063F  clrlwi. r11, r20, 0x18
	ctx.r[11].u64 = ctx.r[20].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED4FD4: 4182001C  beq 0x82ed4ff0
	if ctx.cr[0].eq {
	pc = 0x82ED4FF0; continue 'dispatch;
	}
	// 82ED4FD8: 807A89B4  lwz r3, -0x764c(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-30284 as u32) ) } as u64;
	// 82ED4FDC: 48000018  b 0x82ed4ff4
	pc = 0x82ED4FF4; continue 'dispatch;
            }
            0x82ED4FE0 => {
    //   block [0x82ED4FE0..0x82ED4FF0)
	// 82ED4FE0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ED4FE4: 93F90000  stw r31, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82ED4FE8: 9399000C  stw r28, 0xc(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82ED4FEC: 48000008  b 0x82ed4ff4
	pc = 0x82ED4FF4; continue 'dispatch;
            }
            0x82ED4FF0 => {
    //   block [0x82ED4FF0..0x82ED4FF4)
	// 82ED4FF0: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82ED4FF4; continue 'dispatch;
            }
            0x82ED4FF4 => {
    //   block [0x82ED4FF4..0x82ED4FFC)
	// 82ED4FF4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82ED4FF8: 4BDD4440  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED5000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED5000 size=192
    let mut pc: u32 = 0x82ED5000;
    'dispatch: loop {
        match pc {
            0x82ED5000 => {
    //   block [0x82ED5000..0x82ED5020)
	// 82ED5000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED5004: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED5008: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED500C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED5010: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED5014: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED5018: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED501C: 4082000C  bne 0x82ed5028
	if !ctx.cr[0].eq {
	pc = 0x82ED5028; continue 'dispatch;
	}
	pc = 0x82ED5020; continue 'dispatch;
            }
            0x82ED5020 => {
    //   block [0x82ED5020..0x82ED5028)
	// 82ED5020: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82ED5024: 48000088  b 0x82ed50ac
	pc = 0x82ED50AC; continue 'dispatch;
            }
            0x82ED5028 => {
    //   block [0x82ED5028..0x82ED5054)
	// 82ED5028: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED502C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED5030: 40820024  bne 0x82ed5054
	if !ctx.cr[0].eq {
	pc = 0x82ED5054; continue 'dispatch;
	}
	// 82ED5034: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED5038: 4BFFE939  bl 0x82ed3970
	ctx.lr = 0x82ED503C;
	sub_82ED3970(ctx, base);
	// 82ED503C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED5040: 4182FFE0  beq 0x82ed5020
	if ctx.cr[0].eq {
	pc = 0x82ED5020; continue 'dispatch;
	}
	// 82ED5044: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED5048: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED504C: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82ED5050: 4182FFD0  beq 0x82ed5020
	if ctx.cr[0].eq {
	pc = 0x82ED5020; continue 'dispatch;
	}
	pc = 0x82ED5054; continue 'dispatch;
            }
            0x82ED5054 => {
    //   block [0x82ED5054..0x82ED5090)
	// 82ED5054: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED5058: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED505C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED5060: 4E800421  bctrl
	ctx.lr = 0x82ED5064;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED5064: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82ED5068: 409A0028  bne cr6, 0x82ed5090
	if !ctx.cr[6].eq {
	pc = 0x82ED5090; continue 'dispatch;
	}
	// 82ED506C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED5070: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED5074: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED5078: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED507C: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED5080: 8129007C  lwz r9, 0x7c(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 82ED5084: 7D4951D6  mullw r10, r9, r10
	ctx.r[10].s32 = ((ctx.r[9].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82ED5088: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ED508C: 4800001C  b 0x82ed50a8
	pc = 0x82ED50A8; continue 'dispatch;
            }
            0x82ED5090 => {
    //   block [0x82ED5090..0x82ED50A8)
	// 82ED5090: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED5094: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED5098: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED509C: 814A002C  lwz r10, 0x2c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED50A0: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED50A4: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	pc = 0x82ED50A8; continue 'dispatch;
            }
            0x82ED50A8 => {
    //   block [0x82ED50A8..0x82ED50AC)
	// 82ED50A8: 5563007E  clrlwi r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	pc = 0x82ED50AC; continue 'dispatch;
            }
            0x82ED50AC => {
    //   block [0x82ED50AC..0x82ED50C0)
	// 82ED50AC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ED50B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED50B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED50B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED50BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED50C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED50C0 size=192
    let mut pc: u32 = 0x82ED50C0;
    'dispatch: loop {
        match pc {
            0x82ED50C0 => {
    //   block [0x82ED50C0..0x82ED50E0)
	// 82ED50C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED50C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED50C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED50CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED50D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED50D4: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED50D8: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED50DC: 4082000C  bne 0x82ed50e8
	if !ctx.cr[0].eq {
	pc = 0x82ED50E8; continue 'dispatch;
	}
	pc = 0x82ED50E0; continue 'dispatch;
            }
            0x82ED50E0 => {
    //   block [0x82ED50E0..0x82ED50E8)
	// 82ED50E0: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82ED50E4: 48000088  b 0x82ed516c
	pc = 0x82ED516C; continue 'dispatch;
            }
            0x82ED50E8 => {
    //   block [0x82ED50E8..0x82ED5114)
	// 82ED50E8: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED50EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED50F0: 40820024  bne 0x82ed5114
	if !ctx.cr[0].eq {
	pc = 0x82ED5114; continue 'dispatch;
	}
	// 82ED50F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED50F8: 4BFFE879  bl 0x82ed3970
	ctx.lr = 0x82ED50FC;
	sub_82ED3970(ctx, base);
	// 82ED50FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED5100: 4182FFE0  beq 0x82ed50e0
	if ctx.cr[0].eq {
	pc = 0x82ED50E0; continue 'dispatch;
	}
	// 82ED5104: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED5108: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED510C: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82ED5110: 4182FFD0  beq 0x82ed50e0
	if ctx.cr[0].eq {
	pc = 0x82ED50E0; continue 'dispatch;
	}
	pc = 0x82ED5114; continue 'dispatch;
            }
            0x82ED5114 => {
    //   block [0x82ED5114..0x82ED5150)
	// 82ED5114: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED5118: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED511C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED5120: 4E800421  bctrl
	ctx.lr = 0x82ED5124;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED5124: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82ED5128: 409A0028  bne cr6, 0x82ed5150
	if !ctx.cr[6].eq {
	pc = 0x82ED5150; continue 'dispatch;
	}
	// 82ED512C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED5130: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED5134: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED5138: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED513C: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED5140: 8129007C  lwz r9, 0x7c(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 82ED5144: 7D4951D6  mullw r10, r9, r10
	ctx.r[10].s32 = ((ctx.r[9].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82ED5148: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ED514C: 4800001C  b 0x82ed5168
	pc = 0x82ED5168; continue 'dispatch;
            }
            0x82ED5150 => {
    //   block [0x82ED5150..0x82ED5168)
	// 82ED5150: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED5154: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED5158: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED515C: 814A002C  lwz r10, 0x2c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED5160: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED5164: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	pc = 0x82ED5168; continue 'dispatch;
            }
            0x82ED5168 => {
    //   block [0x82ED5168..0x82ED516C)
	// 82ED5168: 5563007E  clrlwi r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	pc = 0x82ED516C; continue 'dispatch;
            }
            0x82ED516C => {
    //   block [0x82ED516C..0x82ED5180)
	// 82ED516C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ED5170: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED5174: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED5178: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED517C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED5180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED5180 size=104
    let mut pc: u32 = 0x82ED5180;
    'dispatch: loop {
        match pc {
            0x82ED5180 => {
    //   block [0x82ED5180..0x82ED519C)
	// 82ED5180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED5184: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED5188: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED518C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82ED5190: 80890004  lwz r4, 4(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED5194: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED5198: 4082000C  bne 0x82ed51a4
	if !ctx.cr[0].eq {
	pc = 0x82ED51A4; continue 'dispatch;
	}
	pc = 0x82ED519C; continue 'dispatch;
            }
            0x82ED519C => {
    //   block [0x82ED519C..0x82ED51A4)
	// 82ED519C: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82ED51A0: 48000038  b 0x82ed51d8
	pc = 0x82ED51D8; continue 'dispatch;
            }
            0x82ED51A4 => {
    //   block [0x82ED51A4..0x82ED51D0)
	// 82ED51A4: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED51A8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED51AC: 40820024  bne 0x82ed51d0
	if !ctx.cr[0].eq {
	pc = 0x82ED51D0; continue 'dispatch;
	}
	// 82ED51B0: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 82ED51B4: 4BFFE7BD  bl 0x82ed3970
	ctx.lr = 0x82ED51B8;
	sub_82ED3970(ctx, base);
	// 82ED51B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED51BC: 4182FFE0  beq 0x82ed519c
	if ctx.cr[0].eq {
	pc = 0x82ED519C; continue 'dispatch;
	}
	// 82ED51C0: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED51C4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED51C8: 91690008  stw r11, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82ED51CC: 4182FFD0  beq 0x82ed519c
	if ctx.cr[0].eq {
	pc = 0x82ED519C; continue 'dispatch;
	}
	pc = 0x82ED51D0; continue 'dispatch;
            }
            0x82ED51D0 => {
    //   block [0x82ED51D0..0x82ED51D8)
	// 82ED51D0: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED51D4: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82ED51D8; continue 'dispatch;
            }
            0x82ED51D8 => {
    //   block [0x82ED51D8..0x82ED51E8)
	// 82ED51D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ED51DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED51E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED51E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED51E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED51E8 size=104
    let mut pc: u32 = 0x82ED51E8;
    'dispatch: loop {
        match pc {
            0x82ED51E8 => {
    //   block [0x82ED51E8..0x82ED5204)
	// 82ED51E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED51EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED51F0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED51F4: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82ED51F8: 80890004  lwz r4, 4(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED51FC: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED5200: 4082000C  bne 0x82ed520c
	if !ctx.cr[0].eq {
	pc = 0x82ED520C; continue 'dispatch;
	}
	pc = 0x82ED5204; continue 'dispatch;
            }
            0x82ED5204 => {
    //   block [0x82ED5204..0x82ED520C)
	// 82ED5204: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82ED5208: 48000038  b 0x82ed5240
	pc = 0x82ED5240; continue 'dispatch;
            }
            0x82ED520C => {
    //   block [0x82ED520C..0x82ED5238)
	// 82ED520C: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED5210: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED5214: 40820024  bne 0x82ed5238
	if !ctx.cr[0].eq {
	pc = 0x82ED5238; continue 'dispatch;
	}
	// 82ED5218: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 82ED521C: 4BFFE755  bl 0x82ed3970
	ctx.lr = 0x82ED5220;
	sub_82ED3970(ctx, base);
	// 82ED5220: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED5224: 4182FFE0  beq 0x82ed5204
	if ctx.cr[0].eq {
	pc = 0x82ED5204; continue 'dispatch;
	}
	// 82ED5228: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED522C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED5230: 91690008  stw r11, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82ED5234: 4182FFD0  beq 0x82ed5204
	if ctx.cr[0].eq {
	pc = 0x82ED5204; continue 'dispatch;
	}
	pc = 0x82ED5238; continue 'dispatch;
            }
            0x82ED5238 => {
    //   block [0x82ED5238..0x82ED5240)
	// 82ED5238: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED523C: 806B001C  lwz r3, 0x1c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	pc = 0x82ED5240; continue 'dispatch;
            }
            0x82ED5240 => {
    //   block [0x82ED5240..0x82ED5250)
	// 82ED5240: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ED5244: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED5248: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED524C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED5250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED5250 size=200
    let mut pc: u32 = 0x82ED5250;
    'dispatch: loop {
        match pc {
            0x82ED5250 => {
    //   block [0x82ED5250..0x82ED5270)
	// 82ED5250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED5254: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED5258: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED525C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED5260: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED5264: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED5268: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED526C: 4082000C  bne 0x82ed5278
	if !ctx.cr[0].eq {
	pc = 0x82ED5278; continue 'dispatch;
	}
	pc = 0x82ED5270; continue 'dispatch;
            }
            0x82ED5270 => {
    //   block [0x82ED5270..0x82ED5278)
	// 82ED5270: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ED5274: 48000090  b 0x82ed5304
	pc = 0x82ED5304; continue 'dispatch;
            }
            0x82ED5278 => {
    //   block [0x82ED5278..0x82ED52A4)
	// 82ED5278: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED527C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED5280: 40820024  bne 0x82ed52a4
	if !ctx.cr[0].eq {
	pc = 0x82ED52A4; continue 'dispatch;
	}
	// 82ED5284: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED5288: 4BFFE6E9  bl 0x82ed3970
	ctx.lr = 0x82ED528C;
	sub_82ED3970(ctx, base);
	// 82ED528C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED5290: 4182FFE0  beq 0x82ed5270
	if ctx.cr[0].eq {
	pc = 0x82ED5270; continue 'dispatch;
	}
	// 82ED5294: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED5298: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED529C: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82ED52A0: 4182FFD0  beq 0x82ed5270
	if ctx.cr[0].eq {
	pc = 0x82ED5270; continue 'dispatch;
	}
	pc = 0x82ED52A4; continue 'dispatch;
            }
            0x82ED52A4 => {
    //   block [0x82ED52A4..0x82ED52E4)
	// 82ED52A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED52A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED52AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED52B0: 4E800421  bctrl
	ctx.lr = 0x82ED52B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED52B4: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82ED52B8: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED52BC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ED52C0: 409A0024  bne cr6, 0x82ed52e4
	if !ctx.cr[6].eq {
	pc = 0x82ED52E4; continue 'dispatch;
	}
	// 82ED52C4: 552B003E  slwi r11, r9, 0
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED52C8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED52CC: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED52D0: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED52D4: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED52D8: 8167007C  lwz r11, 0x7c(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(124 as u32) ) } as u64;
	// 82ED52DC: 7D6B41D6  mullw r11, r11, r8
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82ED52E0: 48000018  b 0x82ed52f8
	pc = 0x82ED52F8; continue 'dispatch;
            }
            0x82ED52E4 => {
    //   block [0x82ED52E4..0x82ED52F8)
	// 82ED52E4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED52E8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED52EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED52F0: 814A002C  lwz r10, 0x2c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED52F4: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	pc = 0x82ED52F8; continue 'dispatch;
            }
            0x82ED52F8 => {
    //   block [0x82ED52F8..0x82ED5304)
	// 82ED52F8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ED52FC: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82ED5300: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED5304; continue 'dispatch;
            }
            0x82ED5304 => {
    //   block [0x82ED5304..0x82ED5318)
	// 82ED5304: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ED5308: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED530C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED5310: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED5314: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED5318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED5318 size=176
    let mut pc: u32 = 0x82ED5318;
    'dispatch: loop {
        match pc {
            0x82ED5318 => {
    //   block [0x82ED5318..0x82ED5340)
	// 82ED5318: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED531C: 4BDD40ED  bl 0x82ca9408
	ctx.lr = 0x82ED5320;
	sub_82CA93D0(ctx, base);
	// 82ED5320: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED5324: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED5328: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ED532C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82ED5330: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82ED5334: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED5338: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED533C: 4082000C  bne 0x82ed5348
	if !ctx.cr[0].eq {
	pc = 0x82ED5348; continue 'dispatch;
	}
	pc = 0x82ED5340; continue 'dispatch;
            }
            0x82ED5340 => {
    //   block [0x82ED5340..0x82ED5348)
	// 82ED5340: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82ED5344: 4800007C  b 0x82ed53c0
	pc = 0x82ED53C0; continue 'dispatch;
            }
            0x82ED5348 => {
    //   block [0x82ED5348..0x82ED5374)
	// 82ED5348: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED534C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED5350: 409A0024  bne cr6, 0x82ed5374
	if !ctx.cr[6].eq {
	pc = 0x82ED5374; continue 'dispatch;
	}
	// 82ED5354: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED5358: 4BFFE619  bl 0x82ed3970
	ctx.lr = 0x82ED535C;
	sub_82ED3970(ctx, base);
	// 82ED535C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED5360: 4182FFE0  beq 0x82ed5340
	if ctx.cr[0].eq {
	pc = 0x82ED5340; continue 'dispatch;
	}
	// 82ED5364: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED5368: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED536C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82ED5370: 4182FFD0  beq 0x82ed5340
	if ctx.cr[0].eq {
	pc = 0x82ED5340; continue 'dispatch;
	}
	pc = 0x82ED5374; continue 'dispatch;
            }
            0x82ED5374 => {
    //   block [0x82ED5374..0x82ED53BC)
	// 82ED5374: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ED5378: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82ED537C: 916A89B4  stw r11, -0x764c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-30284 as u32), ctx.r[11].u32 ) };
	// 82ED5380: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED5384: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED5388: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED538C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED5390: 4E800421  bctrl
	ctx.lr = 0x82ED5394;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED5394: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82ED5398: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED539C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82ED53A0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82ED53A4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ED53A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED53AC: 409A0010  bne cr6, 0x82ed53bc
	if !ctx.cr[6].eq {
	pc = 0x82ED53BC; continue 'dispatch;
	}
	// 82ED53B0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ED53B4: 4BFFF8FD  bl 0x82ed4cb0
	ctx.lr = 0x82ED53B8;
	sub_82ED4CB0(ctx, base);
	// 82ED53B8: 48000008  b 0x82ed53c0
	pc = 0x82ED53C0; continue 'dispatch;
            }
            0x82ED53BC => {
    //   block [0x82ED53BC..0x82ED53C0)
	// 82ED53BC: 4BFFFAA5  bl 0x82ed4e60
	ctx.lr = 0x82ED53C0;
	sub_82ED4E60(ctx, base);
	pc = 0x82ED53C0; continue 'dispatch;
            }
            0x82ED53C0 => {
    //   block [0x82ED53C0..0x82ED53C8)
	// 82ED53C0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ED53C4: 4BDD4094  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED53C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED53C8 size=148
    let mut pc: u32 = 0x82ED53C8;
    'dispatch: loop {
        match pc {
            0x82ED53C8 => {
    //   block [0x82ED53C8..0x82ED53EC)
	// 82ED53C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED53CC: 4BDD4041  bl 0x82ca940c
	ctx.lr = 0x82ED53D0;
	sub_82CA93D0(ctx, base);
	// 82ED53D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED53D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED53D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ED53DC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82ED53E0: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED53E4: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED53E8: 4082000C  bne 0x82ed53f4
	if !ctx.cr[0].eq {
	pc = 0x82ED53F4; continue 'dispatch;
	}
	pc = 0x82ED53EC; continue 'dispatch;
            }
            0x82ED53EC => {
    //   block [0x82ED53EC..0x82ED53F4)
	// 82ED53EC: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82ED53F0: 48000064  b 0x82ed5454
	pc = 0x82ED5454; continue 'dispatch;
            }
            0x82ED53F4 => {
    //   block [0x82ED53F4..0x82ED5420)
	// 82ED53F4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED53F8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED53FC: 40820024  bne 0x82ed5420
	if !ctx.cr[0].eq {
	pc = 0x82ED5420; continue 'dispatch;
	}
	// 82ED5400: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED5404: 4BFFE56D  bl 0x82ed3970
	ctx.lr = 0x82ED5408;
	sub_82ED3970(ctx, base);
	// 82ED5408: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED540C: 4182FFE0  beq 0x82ed53ec
	if ctx.cr[0].eq {
	pc = 0x82ED53EC; continue 'dispatch;
	}
	// 82ED5410: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED5414: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED5418: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82ED541C: 4182FFD0  beq 0x82ed53ec
	if ctx.cr[0].eq {
	pc = 0x82ED53EC; continue 'dispatch;
	}
	pc = 0x82ED5420; continue 'dispatch;
            }
            0x82ED5420 => {
    //   block [0x82ED5420..0x82ED5450)
	// 82ED5420: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED5424: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED5428: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED542C: 4E800421  bctrl
	ctx.lr = 0x82ED5430;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED5430: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82ED5434: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED5438: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82ED543C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ED5440: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED5444: 409A000C  bne cr6, 0x82ed5450
	if !ctx.cr[6].eq {
	pc = 0x82ED5450; continue 'dispatch;
	}
	// 82ED5448: 4BFFF599  bl 0x82ed49e0
	ctx.lr = 0x82ED544C;
	sub_82ED49E0(ctx, base);
	// 82ED544C: 48000008  b 0x82ed5454
	pc = 0x82ED5454; continue 'dispatch;
            }
            0x82ED5450 => {
    //   block [0x82ED5450..0x82ED5454)
	// 82ED5450: 4BFFF6F9  bl 0x82ed4b48
	ctx.lr = 0x82ED5454;
	sub_82ED4B48(ctx, base);
	pc = 0x82ED5454; continue 'dispatch;
            }
            0x82ED5454 => {
    //   block [0x82ED5454..0x82ED545C)
	// 82ED5454: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ED5458: 4BDD4004  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED5460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED5460 size=204
    let mut pc: u32 = 0x82ED5460;
    'dispatch: loop {
        match pc {
            0x82ED5460 => {
    //   block [0x82ED5460..0x82ED54B4)
	// 82ED5460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED5464: 4BDD3F95  bl 0x82ca93f8
	ctx.lr = 0x82ED5468;
	sub_82CA93D0(ctx, base);
	// 82ED5468: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED546C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82ED5470: 7D585378  mr r24, r10
	ctx.r[24].u64 = ctx.r[10].u64;
	// 82ED5474: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED5478: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ED547C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ED5480: 814B89A8  lwz r10, -0x7658(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30296 as u32) ) } as u64;
	// 82ED5484: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82ED5488: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82ED548C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ED5490: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED5494: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82ED5498: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 82ED549C: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 82ED54A0: 914B89A8  stw r10, -0x7658(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-30296 as u32), ctx.r[10].u32 ) };
	// 82ED54A4: 4BFB6835  bl 0x82e8bcd8
	ctx.lr = 0x82ED54A8;
	sub_82E8BCD8(ctx, base);
	// 82ED54A8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED54AC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ED54B0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x82ED54B4; continue 'dispatch;
            }
            0x82ED54B4 => {
    //   block [0x82ED54B4..0x82ED54D0)
	// 82ED54B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED54B8: 419A0018  beq cr6, 0x82ed54d0
	if ctx.cr[6].eq {
	pc = 0x82ED54D0; continue 'dispatch;
	}
	// 82ED54BC: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED54C0: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82ED54C4: 8108001C  lwz r8, 0x1c(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED54C8: 2B080002  cmplwi cr6, r8, 2
	ctx.cr[6].compare_u32(ctx.r[8].u32, 2 as u32, &mut ctx.xer);
	// 82ED54CC: 419A0020  beq cr6, 0x82ed54ec
	if ctx.cr[6].eq {
	pc = 0x82ED54EC; continue 'dispatch;
	}
	pc = 0x82ED54D0; continue 'dispatch;
            }
            0x82ED54D0 => {
    //   block [0x82ED54D0..0x82ED54E4)
	// 82ED54D0: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 82ED54D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ED54D8: 2B090030  cmplwi cr6, r9, 0x30
	ctx.cr[6].compare_u32(ctx.r[9].u32, 48 as u32, &mut ctx.xer);
	// 82ED54DC: 4198FFD8  blt cr6, 0x82ed54b4
	if ctx.cr[6].lt {
	pc = 0x82ED54B4; continue 'dispatch;
	}
	// 82ED54E0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82ED54E4; continue 'dispatch;
            }
            0x82ED54E4 => {
    //   block [0x82ED54E4..0x82ED54EC)
	// 82ED54E4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82ED54E8: 4BDD3F60  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x82ED54EC => {
    //   block [0x82ED54EC..0x82ED552C)
	// 82ED54EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED54F0: 1D4A000C  mulli r10, r10, 0xc
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 12 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82ED54F4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ED54F8: 93010054  stw r24, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 82ED54FC: 81410104  lwz r10, 0x104(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82ED5500: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 82ED5504: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82ED5508: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82ED550C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82ED5510: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82ED5514: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ED5518: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82ED551C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED5520: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ED5524: 4BFFE52D  bl 0x82ed3a50
	ctx.lr = 0x82ED5528;
	sub_82ED3A50(ctx, base);
	// 82ED5528: 4BFFFFBC  b 0x82ed54e4
	pc = 0x82ED54E4; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED5530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ED5530 size=868
    let mut pc: u32 = 0x82ED5530;
    'dispatch: loop {
        match pc {
            0x82ED5530 => {
    //   block [0x82ED5530..0x82ED5574)
	// 82ED5530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED5534: 4BDD3E9D  bl 0x82ca93d0
	ctx.lr = 0x82ED5538;
	sub_82CA93D0(ctx, base);
	// 82ED5538: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED553C: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82ED5540: 990101CF  stb r8, 0x1cf(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(463 as u32), ctx.r[8].u8 ) };
	// 82ED5544: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 82ED5548: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 82ED554C: 7CAF2B78  mr r15, r5
	ctx.r[15].u64 = ctx.r[5].u64;
	// 82ED5550: 7CD13378  mr r17, r6
	ctx.r[17].u64 = ctx.r[6].u64;
	// 82ED5554: 7CF53B78  mr r21, r7
	ctx.r[21].u64 = ctx.r[7].u64;
	// 82ED5558: 7D3D4B78  mr r29, r9
	ctx.r[29].u64 = ctx.r[9].u64;
	// 82ED555C: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82ED5560: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82ED5564: 3E008336  lis r16, -0x7cca
	ctx.r[16].s64 = -2093613056;
	// 82ED5568: 409A000C  bne cr6, 0x82ed5574
	if !ctx.cr[6].eq {
	pc = 0x82ED5574; continue 'dispatch;
	}
	// 82ED556C: 83B089B8  lwz r29, -0x7648(r16)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(-30280 as u32) ) } as u64;
	// 82ED5570: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82ED5574; continue 'dispatch;
            }
            0x82ED5574 => {
    //   block [0x82ED5574..0x82ED5584)
	// 82ED5574: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ED5578: 4082000C  bne 0x82ed5584
	if !ctx.cr[0].eq {
	pc = 0x82ED5584; continue 'dispatch;
	}
	// 82ED557C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED5580: 41820008  beq 0x82ed5588
	if ctx.cr[0].eq {
	pc = 0x82ED5588; continue 'dispatch;
	}
	pc = 0x82ED5584; continue 'dispatch;
            }
            0x82ED5584 => {
    //   block [0x82ED5584..0x82ED5588)
	// 82ED5584: 92FD0004  stw r23, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[23].u32 ) };
	pc = 0x82ED5588; continue 'dispatch;
            }
            0x82ED5588 => {
    //   block [0x82ED5588..0x82ED55A0)
	// 82ED5588: 816101E4  lwz r11, 0x1e4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(484 as u32) ) } as u64;
	// 82ED558C: 3A40FFFF  li r18, -1
	ctx.r[18].s64 = -1;
	// 82ED5590: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED5594: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82ED5598: 409A0008  bne cr6, 0x82ed55a0
	if !ctx.cr[6].eq {
	pc = 0x82ED55A0; continue 'dispatch;
	}
	// 82ED559C: 92410060  stw r18, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[18].u32 ) };
	pc = 0x82ED55A0; continue 'dispatch;
            }
            0x82ED55A0 => {
    //   block [0x82ED55A0..0x82ED55D8)
	// 82ED55A0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED55A4: 3A7D0010  addi r19, r29, 0x10
	ctx.r[19].s64 = ctx.r[29].s64 + 16;
	// 82ED55A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED55AC: 409A0170  bne cr6, 0x82ed571c
	if !ctx.cr[6].eq {
	pc = 0x82ED571C; continue 'dispatch;
	}
	// 82ED55B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED55B4: 80F40014  lwz r7, 0x14(r20)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED55B8: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED55BC: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED55C0: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82ED55C4: C1880000  lfs f12, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED55C8: C1AB84AC  lfs f13, -0x7b54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31572 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED55CC: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82ED55D0: 409A002C  bne cr6, 0x82ed55fc
	if !ctx.cr[6].eq {
	pc = 0x82ED55FC; continue 'dispatch;
	}
	// 82ED55D4: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	pc = 0x82ED55D8; continue 'dispatch;
            }
            0x82ED55D8 => {
    //   block [0x82ED55D8..0x82ED55EC)
	// 82ED55D8: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED55DC: C1AA0038  lfs f13, 0x38(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED55E0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ED55E4: 40990008  ble cr6, 0x82ed55ec
	if !ctx.cr[6].gt {
	pc = 0x82ED55EC; continue 'dispatch;
	}
	// 82ED55E8: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82ED55EC; continue 'dispatch;
            }
            0x82ED55EC => {
    //   block [0x82ED55EC..0x82ED55FC)
	// 82ED55EC: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82ED55F0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED55F4: 4082FFE4  bne 0x82ed55d8
	if !ctx.cr[0].eq {
	pc = 0x82ED55D8; continue 'dispatch;
	}
	// 82ED55F8: 4800003C  b 0x82ed5634
	pc = 0x82ED5634; continue 'dispatch;
            }
            0x82ED55FC => {
    //   block [0x82ED55FC..0x82ED5614)
	// 82ED55FC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82ED5600: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82ED5604: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED5608: 4182000C  beq 0x82ed5614
	if ctx.cr[0].eq {
	pc = 0x82ED5614; continue 'dispatch;
	}
	// 82ED560C: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED5610: 4800000C  b 0x82ed561c
	pc = 0x82ED561C; continue 'dispatch;
            }
            0x82ED5614 => {
    //   block [0x82ED5614..0x82ED561C)
	// 82ED5614: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED5618: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82ED561C; continue 'dispatch;
            }
            0x82ED561C => {
    //   block [0x82ED561C..0x82ED5634)
	// 82ED561C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED5620: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 82ED5624: C00B0A54  lfs f0, 0xa54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED5628: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED562C: 419A0008  beq cr6, 0x82ed5634
	if ctx.cr[6].eq {
	pc = 0x82ED5634; continue 'dispatch;
	}
	// 82ED5630: C0150024  lfs f0, 0x24(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82ED5634; continue 'dispatch;
            }
            0x82ED5634 => {
    //   block [0x82ED5634..0x82ED567C)
	// 82ED5634: C1B60004  lfs f13, 4(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED5638: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 82ED563C: C1960008  lfs f12, 8(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED5640: ED4D0028  fsubs f10, f13, f0
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED5644: D1410080  stfs f10, 0x80(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82ED5648: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82ED564C: C176000C  lfs f11, 0xc(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED5650: ED4C0028  fsubs f10, f12, f0
	ctx.f[10].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED5654: D1410084  stfs f10, 0x84(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82ED5658: ED4B0028  fsubs f10, f11, f0
	ctx.f[10].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED565C: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82ED5660: EDAC002A  fadds f13, f12, f0
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82ED5664: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82ED5668: D1410088  stfs f10, 0x88(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82ED566C: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82ED5670: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82ED5674: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82ED5678: 3948001C  addi r10, r8, 0x1c
	ctx.r[10].s64 = ctx.r[8].s64 + 28;
	pc = 0x82ED567C; continue 'dispatch;
            }
            0x82ED567C => {
    //   block [0x82ED567C..0x82ED5690)
	// 82ED567C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82ED5680: 419A0010  beq cr6, 0x82ed5690
	if ctx.cr[6].eq {
	pc = 0x82ED5690; continue 'dispatch;
	}
	// 82ED5684: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED5688: 2B080002  cmplwi cr6, r8, 2
	ctx.cr[6].compare_u32(ctx.r[8].u32, 2 as u32, &mut ctx.xer);
	// 82ED568C: 419A0018  beq cr6, 0x82ed56a4
	if ctx.cr[6].eq {
	pc = 0x82ED56A4; continue 'dispatch;
	}
	pc = 0x82ED5690; continue 'dispatch;
            }
            0x82ED5690 => {
    //   block [0x82ED5690..0x82ED56A4)
	// 82ED5690: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ED5694: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82ED5698: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82ED569C: 4198FFE0  blt cr6, 0x82ed567c
	if ctx.cr[6].lt {
	pc = 0x82ED567C; continue 'dispatch;
	}
	// 82ED56A0: 48000008  b 0x82ed56a8
	pc = 0x82ED56A8; continue 'dispatch;
            }
            0x82ED56A4 => {
    //   block [0x82ED56A4..0x82ED56A8)
	// 82ED56A4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	pc = 0x82ED56A8; continue 'dispatch;
            }
            0x82ED56A8 => {
    //   block [0x82ED56A8..0x82ED5700)
	// 82ED56A8: 552B063F  clrlwi. r11, r9, 0x18
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED56AC: 4182005C  beq 0x82ed5708
	if ctx.cr[0].eq {
	pc = 0x82ED5708; continue 'dispatch;
	}
	// 82ED56B0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED56B4: 92FD000C  stw r23, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[23].u32 ) };
	// 82ED56B8: 92FD0008  stw r23, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[23].u32 ) };
	// 82ED56BC: 2B0B0014  cmplwi cr6, r11, 0x14
	ctx.cr[6].compare_u32(ctx.r[11].u32, 20 as u32, &mut ctx.xer);
	// 82ED56C0: 41980048  blt cr6, 0x82ed5708
	if ctx.cr[6].lt {
	pc = 0x82ED5708; continue 'dispatch;
	}
	// 82ED56C4: 812101F4  lwz r9, 0x1f4(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(500 as u32) ) } as u64;
	// 82ED56C8: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 82ED56CC: 7E679B78  mr r7, r19
	ctx.r[7].u64 = ctx.r[19].u64;
	// 82ED56D0: 814101EC  lwz r10, 0x1ec(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(492 as u32) ) } as u64;
	// 82ED56D4: 5568F0BE  srwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82ED56D8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82ED56DC: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82ED56E0: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82ED56E4: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82ED56E8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82ED56EC: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82ED56F0: 4BFFFD71  bl 0x82ed5460
	ctx.lr = 0x82ED56F4;
	sub_82ED5460(ctx, base);
	// 82ED56F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED56F8: 907D000C  stw r3, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82ED56FC: 40820018  bne 0x82ed5714
	if !ctx.cr[0].eq {
	pc = 0x82ED5714; continue 'dispatch;
	}
	pc = 0x82ED5700; continue 'dispatch;
            }
            0x82ED5700 => {
    //   block [0x82ED5700..0x82ED5704)
	// 82ED5700: 92510000  stw r18, 0(r17)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[17].u32.wrapping_add(0 as u32), ctx.r[18].u32 ) };
	pc = 0x82ED5704; continue 'dispatch;
            }
            0x82ED5704 => {
    //   block [0x82ED5704..0x82ED5708)
	// 82ED5704: 92FD0004  stw r23, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[23].u32 ) };
	pc = 0x82ED5708; continue 'dispatch;
            }
            0x82ED5708 => {
    //   block [0x82ED5708..0x82ED570C)
	// 82ED5708: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82ED570C; continue 'dispatch;
            }
            0x82ED570C => {
    //   block [0x82ED570C..0x82ED5714)
	// 82ED570C: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 82ED5710: 4BDD3D10  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            0x82ED5714 => {
    //   block [0x82ED5714..0x82ED571C)
	// 82ED5714: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ED5718: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED571C; continue 'dispatch;
            }
            0x82ED571C => {
    //   block [0x82ED571C..0x82ED574C)
	// 82ED571C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED5720: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82ED5724: 409AFFE4  bne cr6, 0x82ed5708
	if !ctx.cr[6].eq {
	pc = 0x82ED5708; continue 'dispatch;
	}
	// 82ED5728: 379D0008  addic. r28, r29, 8
	ctx.xer.ca = (ctx.r[29].u32 > (!(8 as u32)));
	ctx.r[28].s64 = ctx.r[29].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82ED572C: 7EF8BB78  mr r24, r23
	ctx.r[24].u64 = ctx.r[23].u64;
	// 82ED5730: 4182FFD8  beq 0x82ed5708
	if ctx.cr[0].eq {
	pc = 0x82ED5708; continue 'dispatch;
	}
	// 82ED5734: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED5738: 3B4B9F1C  addi r26, r11, -0x60e4
	ctx.r[26].s64 = ctx.r[11].s64 + -24804;
	// 82ED573C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82ED5740: 3B2B9128  addi r25, r11, -0x6ed8
	ctx.r[25].s64 = ctx.r[11].s64 + -28376;
	// 82ED5744: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82ED5748: 3B6B9128  addi r27, r11, -0x6ed8
	ctx.r[27].s64 = ctx.r[11].s64 + -28376;
	pc = 0x82ED574C; continue 'dispatch;
            }
            0x82ED574C => {
    //   block [0x82ED574C..0x82ED57AC)
	// 82ED574C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED5750: 2F0F0000  cmpwi cr6, r15, 0
	ctx.cr[6].compare_i32(ctx.r[15].s32, 0, &mut ctx.xer);
	// 82ED5754: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED5758: 7FEB982E  lwzx r31, r11, r19
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[19].u32)) } as u64;
	// 82ED575C: 419A0120  beq cr6, 0x82ed587c
	if ctx.cr[6].eq {
	pc = 0x82ED587C; continue 'dispatch;
	}
	// 82ED5760: 2F0F0001  cmpwi cr6, r15, 1
	ctx.cr[6].compare_i32(ctx.r[15].s32, 1, &mut ctx.xer);
	// 82ED5764: 409AFFE8  bne cr6, 0x82ed574c
	if !ctx.cr[6].eq {
	pc = 0x82ED574C; continue 'dispatch;
	}
	// 82ED5768: 817089B8  lwz r11, -0x7648(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(-30280 as u32) ) } as u64;
	// 82ED576C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED5770: 419A003C  beq cr6, 0x82ed57ac
	if ctx.cr[6].eq {
	pc = 0x82ED57AC; continue 'dispatch;
	}
	// 82ED5774: 3D400000  lis r10, 0
	ctx.r[10].s64 = 0;
	// 82ED5778: 8174001C  lwz r11, 0x1c(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED577C: 614A84EC  ori r10, r10, 0x84ec
	ctx.r[10].u64 = ctx.r[10].u64 | 34028;
	// 82ED5780: 7FCB502E  lwzx r30, r11, r10
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82ED5784: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82ED5788: 419A0024  beq cr6, 0x82ed57ac
	if ctx.cr[6].eq {
	pc = 0x82ED57AC; continue 'dispatch;
	}
	// 82ED578C: 81750004  lwz r11, 4(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED5790: 81CB0014  lwz r14, 0x14(r11)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED5794: 4B38B225  bl 0x822609b8
	ctx.lr = 0x82ED5798;
	sub_822609B8(ctx, base);
	// 82ED5798: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ED579C: 7DC57378  mr r5, r14
	ctx.r[5].u64 = ctx.r[14].u64;
	// 82ED57A0: 4BF9A931  bl 0x82e700d0
	ctx.lr = 0x82ED57A4;
	sub_82E700D0(ctx, base);
	// 82ED57A4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED57A8: 418200E4  beq 0x82ed588c
	if ctx.cr[0].eq {
	pc = 0x82ED588C; continue 'dispatch;
	}
	pc = 0x82ED57AC; continue 'dispatch;
            }
            0x82ED57AC => {
    //   block [0x82ED57AC..0x82ED57D8)
	// 82ED57AC: C01F0004  lfs f0, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED57B0: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
	// 82ED57B4: C1BF0008  lfs f13, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED57B8: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 82ED57BC: C19F000C  lfs f12, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED57C0: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82ED57C4: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82ED57C8: 93610090  stw r27, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[27].u32 ) };
	// 82ED57CC: D1A10098  stfs f13, 0x98(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82ED57D0: D181009C  stfs f12, 0x9c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82ED57D4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82ED57D8; continue 'dispatch;
            }
            0x82ED57D8 => {
    //   block [0x82ED57D8..0x82ED5830)
	// 82ED57D8: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ED57DC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ED57E0: 4200FFF8  bdnz 0x82ed57d8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82ED57D8; continue 'dispatch;
	}
	// 82ED57E4: 9AE100E8  stb r23, 0xe8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[23].u8 ) };
	// 82ED57E8: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82ED57EC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED57F0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82ED57F4: 93410068  stw r26, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[26].u32 ) };
	// 82ED57F8: 556B007E  clrlwi r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 82ED57FC: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82ED5800: 4B2D8EA9  bl 0x821ae6a8
	ctx.lr = 0x82ED5804;
	sub_821AE6A8(ctx, base);
	// 82ED5804: 896101CF  lbz r11, 0x1cf(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(463 as u32) ) } as u64;
	// 82ED5808: 80750228  lwz r3, 0x228(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(552 as u32) ) } as u64;
	// 82ED580C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED5810: 81750004  lwz r11, 4(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED5814: 80CB0014  lwz r6, 0x14(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED5818: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED581C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED5820: 41820010  beq 0x82ed5830
	if ctx.cr[0].eq {
	pc = 0x82ED5830; continue 'dispatch;
	}
	// 82ED5824: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82ED5828: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82ED582C: 4800000C  b 0x82ed5838
	pc = 0x82ED5838; continue 'dispatch;
            }
            0x82ED5830 => {
    //   block [0x82ED5830..0x82ED5838)
	// 82ED5830: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 82ED5834: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	pc = 0x82ED5838; continue 'dispatch;
            }
            0x82ED5838 => {
    //   block [0x82ED5838..0x82ED587C)
	// 82ED5838: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED583C: 4E800421  bctrl
	ctx.lr = 0x82ED5840;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED5840: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED5844: 40820038  bne 0x82ed587c
	if !ctx.cr[0].eq {
	pc = 0x82ED587C; continue 'dispatch;
	}
	// 82ED5848: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED584C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ED5850: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ED5854: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED5858: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ED585C: 4098FEA4  bge cr6, 0x82ed5700
	if !ctx.cr[6].lt {
	pc = 0x82ED5700; continue 'dispatch;
	}
	// 82ED5860: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82ED5864: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 82ED5868: 7F185840  cmplw cr6, r24, r11
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED586C: 40980020  bge cr6, 0x82ed588c
	if !ctx.cr[6].lt {
	pc = 0x82ED588C; continue 'dispatch;
	}
	// 82ED5870: 93210068  stw r25, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[25].u32 ) };
	// 82ED5874: 93210090  stw r25, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[25].u32 ) };
	// 82ED5878: 4BFFFED4  b 0x82ed574c
	pc = 0x82ED574C; continue 'dispatch;
            }
            0x82ED587C => {
    //   block [0x82ED587C..0x82ED588C)
	// 82ED587C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED5880: 556B007E  clrlwi r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 82ED5884: 91710000  stw r11, 0(r17)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[17].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ED5888: 4BFFFE7C  b 0x82ed5704
	pc = 0x82ED5704; continue 'dispatch;
            }
            0x82ED588C => {
    //   block [0x82ED588C..0x82ED5894)
	// 82ED588C: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED5890: 4BFFFE7C  b 0x82ed570c
	pc = 0x82ED570C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED5898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED5898 size=196
    let mut pc: u32 = 0x82ED5898;
    'dispatch: loop {
        match pc {
            0x82ED5898 => {
    //   block [0x82ED5898..0x82ED58B4)
	// 82ED5898: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED589C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED58A0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED58A4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82ED58A8: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED58AC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED58B0: 4082000C  bne 0x82ed58bc
	if !ctx.cr[0].eq {
	pc = 0x82ED58BC; continue 'dispatch;
	}
	pc = 0x82ED58B4; continue 'dispatch;
            }
            0x82ED58B4 => {
    //   block [0x82ED58B4..0x82ED58BC)
	// 82ED58B4: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82ED58B8: 48000094  b 0x82ed594c
	pc = 0x82ED594C; continue 'dispatch;
            }
            0x82ED58BC => {
    //   block [0x82ED58BC..0x82ED5900)
	// 82ED58BC: 810B0014  lwz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED58C0: 550B0001  rlwinm. r11, r8, 0, 0, 0
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED58C4: 4082FFF0  bne 0x82ed58b4
	if !ctx.cr[0].eq {
	pc = 0x82ED58B4; continue 'dispatch;
	}
	// 82ED58C8: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED58CC: 4182FFE8  beq 0x82ed58b4
	if ctx.cr[0].eq {
	pc = 0x82ED58B4; continue 'dispatch;
	}
	// 82ED58D0: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 82ED58D4: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82ED58D8: 4BFFE099  bl 0x82ed3970
	ctx.lr = 0x82ED58DC;
	sub_82ED3970(ctx, base);
	// 82ED58DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED58E0: 40820068  bne 0x82ed5948
	if !ctx.cr[0].eq {
	pc = 0x82ED5948; continue 'dispatch;
	}
	// 82ED58E4: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82ED58E8: 4BFFF901  bl 0x82ed51e8
	ctx.lr = 0x82ED58EC;
	sub_82ED51E8(ctx, base);
	// 82ED58EC: 3563FFFF  addic. r11, r3, -1
	ctx.xer.ca = (ctx.r[3].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED58F0: 40820030  bne 0x82ed5920
	if !ctx.cr[0].eq {
	pc = 0x82ED5920; continue 'dispatch;
	}
	// 82ED58F4: 80880014  lwz r4, 0x14(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED58F8: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED58FC: 4182FFB8  beq 0x82ed58b4
	if ctx.cr[0].eq {
	pc = 0x82ED58B4; continue 'dispatch;
	}
	pc = 0x82ED5900; continue 'dispatch;
            }
            0x82ED5900 => {
    //   block [0x82ED5900..0x82ED5918)
	// 82ED5900: 7F044040  cmplw cr6, r4, r8
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82ED5904: 419AFFB0  beq cr6, 0x82ed58b4
	if ctx.cr[6].eq {
	pc = 0x82ED58B4; continue 'dispatch;
	}
	// 82ED5908: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82ED590C: 4BFFE065  bl 0x82ed3970
	ctx.lr = 0x82ED5910;
	sub_82ED3970(ctx, base);
	// 82ED5910: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED5914: 4182FFEC  beq 0x82ed5900
	if ctx.cr[0].eq {
	pc = 0x82ED5900; continue 'dispatch;
	}
	pc = 0x82ED5918; continue 'dispatch;
            }
            0x82ED5918 => {
    //   block [0x82ED5918..0x82ED5920)
	// 82ED5918: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82ED591C: 48000030  b 0x82ed594c
	pc = 0x82ED594C; continue 'dispatch;
            }
            0x82ED5920 => {
    //   block [0x82ED5920..0x82ED592C)
	// 82ED5920: 80880018  lwz r4, 0x18(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ED5924: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED5928: 4182FF8C  beq 0x82ed58b4
	if ctx.cr[0].eq {
	pc = 0x82ED58B4; continue 'dispatch;
	}
	pc = 0x82ED592C; continue 'dispatch;
            }
            0x82ED592C => {
    //   block [0x82ED592C..0x82ED5948)
	// 82ED592C: 7F044040  cmplw cr6, r4, r8
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82ED5930: 419AFF84  beq cr6, 0x82ed58b4
	if ctx.cr[6].eq {
	pc = 0x82ED58B4; continue 'dispatch;
	}
	// 82ED5934: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82ED5938: 4BFFE039  bl 0x82ed3970
	ctx.lr = 0x82ED593C;
	sub_82ED3970(ctx, base);
	// 82ED593C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED5940: 4182FFEC  beq 0x82ed592c
	if ctx.cr[0].eq {
	pc = 0x82ED592C; continue 'dispatch;
	}
	// 82ED5944: 4BFFFFD4  b 0x82ed5918
	pc = 0x82ED5918; continue 'dispatch;
            }
            0x82ED5948 => {
    //   block [0x82ED5948..0x82ED594C)
	// 82ED5948: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	pc = 0x82ED594C; continue 'dispatch;
            }
            0x82ED594C => {
    //   block [0x82ED594C..0x82ED595C)
	// 82ED594C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ED5950: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED5954: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED5958: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED5960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED5960 size=84
    let mut pc: u32 = 0x82ED5960;
    'dispatch: loop {
        match pc {
            0x82ED5960 => {
    //   block [0x82ED5960..0x82ED59B4)
	// 82ED5960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED5964: 4BDD3AA9  bl 0x82ca940c
	ctx.lr = 0x82ED5968;
	sub_82CA93D0(ctx, base);
	// 82ED5968: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED596C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED5970: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82ED5974: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82ED5978: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ED597C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ED5980: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED5984: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82ED5988: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82ED598C: 4BFFF98D  bl 0x82ed5318
	ctx.lr = 0x82ED5990;
	sub_82ED5318(ctx, base);
	// 82ED5990: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82ED5994: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82ED5998: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82ED599C: 7D635850  subf r11, r3, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82ED59A0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82ED59A4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82ED59A8: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82ED59AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ED59B0: 4BDD3AAC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED59B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED59B8 size=84
    let mut pc: u32 = 0x82ED59B8;
    'dispatch: loop {
        match pc {
            0x82ED59B8 => {
    //   block [0x82ED59B8..0x82ED59EC)
	// 82ED59B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED59BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED59C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED59C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED59C8: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82ED59CC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82ED59D0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ED59D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED59D8: 4BFFF941  bl 0x82ed5318
	ctx.lr = 0x82ED59DC;
	sub_82ED5318(ctx, base);
	// 82ED59DC: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82ED59E0: 409A000C  bne cr6, 0x82ed59ec
	if !ctx.cr[6].eq {
	pc = 0x82ED59EC; continue 'dispatch;
	}
	// 82ED59E4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ED59E8: 48000010  b 0x82ed59f8
	pc = 0x82ED59F8; continue 'dispatch;
            }
            0x82ED59EC => {
    //   block [0x82ED59EC..0x82ED59F8)
	// 82ED59EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ED59F0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ED59F4: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED59F8; continue 'dispatch;
            }
            0x82ED59F8 => {
    //   block [0x82ED59F8..0x82ED5A0C)
	// 82ED59F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ED59FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED5A00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED5A04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED5A08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED5A10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED5A10 size=16
    let mut pc: u32 = 0x82ED5A10;
    'dispatch: loop {
        match pc {
            0x82ED5A10 => {
    //   block [0x82ED5A10..0x82ED5A20)
	// 82ED5A10: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82ED5A14: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82ED5A18: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ED5A1C: 4BFFF8FC  b 0x82ed5318
	sub_82ED5318(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED5A20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED5A20 size=12
    let mut pc: u32 = 0x82ED5A20;
    'dispatch: loop {
        match pc {
            0x82ED5A20 => {
    //   block [0x82ED5A20..0x82ED5A2C)
	// 82ED5A20: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82ED5A24: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ED5A28: 4BFFF9A0  b 0x82ed53c8
	sub_82ED53C8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED5A30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED5A30 size=20
    let mut pc: u32 = 0x82ED5A30;
    'dispatch: loop {
        match pc {
            0x82ED5A30 => {
    //   block [0x82ED5A30..0x82ED5A44)
	// 82ED5A30: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED5A34: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED5A38: 4198000C  blt cr6, 0x82ed5a44
	if ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x82ED5A44);
		return;
	}
	// 82ED5A3C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ED5A40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED5A68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED5A68 size=76
    let mut pc: u32 = 0x82ED5A68;
    'dispatch: loop {
        match pc {
            0x82ED5A68 => {
    //   block [0x82ED5A68..0x82ED5AA0)
	// 82ED5A68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED5A6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED5A70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED5A74: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED5A78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED5A7C: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82ED5A80: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED5A84: 4182001C  beq 0x82ed5aa0
	if ctx.cr[0].eq {
	pc = 0x82ED5AA0; continue 'dispatch;
	}
	// 82ED5A88: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ED5A8C: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ED5A90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED5A94: 4E800421  bctrl
	ctx.lr = 0x82ED5A98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED5A98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ED5A9C: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
            }
            0x82ED5AA0 => {
    //   block [0x82ED5AA0..0x82ED5AB4)
	// 82ED5AA0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ED5AA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED5AA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED5AAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED5AB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED5AB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ED5AB8 size=764
    let mut pc: u32 = 0x82ED5AB8;
    'dispatch: loop {
        match pc {
            0x82ED5AB8 => {
    //   block [0x82ED5AB8..0x82ED5B14)
	// 82ED5AB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED5ABC: 4BDD3941  bl 0x82ca93fc
	ctx.lr = 0x82ED5AC0;
	sub_82CA93D0(ctx, base);
	// 82ED5AC0: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 82ED5AC4: 4BDD8215  bl 0x82cadcd8
	ctx.lr = 0x82ED5AC8;
	sub_82CADCA0(ctx, base);
	// 82ED5AC8: 9421FD30  stwu r1, -0x2d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-720 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED5ACC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82ED5AD0: 817C0294  lwz r11, 0x294(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(660 as u32) ) } as u64;
	// 82ED5AD4: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82ED5AD8: 409A02C0  bne cr6, 0x82ed5d98
	if !ctx.cr[6].eq {
	pc = 0x82ED5D98; continue 'dispatch;
	}
	// 82ED5ADC: 817C002C  lwz r11, 0x2c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED5AE0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82ED5AE4: 7F7ADB78  mr r26, r27
	ctx.r[26].u64 = ctx.r[27].u64;
	// 82ED5AE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED5AEC: 4099029C  ble cr6, 0x82ed5d88
	if !ctx.cr[6].gt {
	pc = 0x82ED5D88; continue 'dispatch;
	}
	// 82ED5AF0: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82ED5AF4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82ED5AF8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ED5AFC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED5B00: 3F208334  lis r25, -0x7ccc
	ctx.r[25].s64 = -2093744128;
	// 82ED5B04: C3880C4C  lfs f28, 0xc4c(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3148 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82ED5B08: C3A90B60  lfs f29, 0xb60(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2912 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82ED5B0C: C3CA0C14  lfs f30, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82ED5B10: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82ED5B14; continue 'dispatch;
            }
            0x82ED5B14 => {
    //   block [0x82ED5B14..0x82ED5B6C)
	// 82ED5B14: 815C0024  lwz r10, 0x24(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 82ED5B18: 574B2834  slwi r11, r26, 5
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED5B1C: 7FEB5214  add r31, r11, r10
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ED5B20: 897F001C  lbz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED5B24: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED5B28: 41820250  beq 0x82ed5d78
	if ctx.cr[0].eq {
	pc = 0x82ED5D78; continue 'dispatch;
	}
	// 82ED5B2C: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82ED5B30: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82ED5B34: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82ED5B38: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82ED5B3C: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED5B40: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82ED5B44: 409A0028  bne cr6, 0x82ed5b6c
	if !ctx.cr[6].eq {
	pc = 0x82ED5B6C; continue 'dispatch;
	}
	// 82ED5B48: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82ED5B4C: 616B84D8  ori r11, r11, 0x84d8
	ctx.r[11].u64 = ctx.r[11].u64 | 34008;
	// 82ED5B50: 7D7C582E  lwzx r11, r28, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82ED5B54: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED5B58: 419A0220  beq cr6, 0x82ed5d78
	if ctx.cr[6].eq {
	pc = 0x82ED5D78; continue 'dispatch;
	}
	// 82ED5B5C: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82ED5B60: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82ED5B64: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82ED5B68: 48000020  b 0x82ed5b88
	pc = 0x82ED5B88; continue 'dispatch;
            }
            0x82ED5B6C => {
    //   block [0x82ED5B6C..0x82ED5B88)
	// 82ED5B6C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ED5B70: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED5B74: 41820238  beq 0x82ed5dac
	if ctx.cr[0].eq {
	pc = 0x82ED5DAC; continue 'dispatch;
	}
	// 82ED5B78: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82ED5B7C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ED5B80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED5B84: 4E800421  bctrl
	ctx.lr = 0x82ED5B88;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED5B88 => {
    //   block [0x82ED5B88..0x82ED5BC4)
	// 82ED5B88: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED5B8C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED5B90: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82ED5B94: 419A003C  beq cr6, 0x82ed5bd0
	if ctx.cr[6].eq {
	pc = 0x82ED5BD0; continue 'dispatch;
	}
	// 82ED5B98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ED5B9C: 419A0034  beq cr6, 0x82ed5bd0
	if ctx.cr[6].eq {
	pc = 0x82ED5BD0; continue 'dispatch;
	}
	// 82ED5BA0: 4BFFDCB1  bl 0x82ed3850
	ctx.lr = 0x82ED5BA4;
	sub_82ED3850(ctx, base);
	// 82ED5BA4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED5BA8: 41820028  beq 0x82ed5bd0
	if ctx.cr[0].eq {
	pc = 0x82ED5BD0; continue 'dispatch;
	}
	// 82ED5BAC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED5BB0: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED5BB4: 41820010  beq 0x82ed5bc4
	if ctx.cr[0].eq {
	pc = 0x82ED5BC4; continue 'dispatch;
	}
	// 82ED5BB8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ED5BBC: 4BFFD375  bl 0x82ed2f30
	ctx.lr = 0x82ED5BC0;
	sub_82ED2F30(ctx, base);
	// 82ED5BC0: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	pc = 0x82ED5BC4; continue 'dispatch;
            }
            0x82ED5BC4 => {
    //   block [0x82ED5BC4..0x82ED5BD0)
	// 82ED5BC4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED5BC8: 937F0004  stw r27, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82ED5BCC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED5BD0; continue 'dispatch;
            }
            0x82ED5BD0 => {
    //   block [0x82ED5BD0..0x82ED5C00)
	// 82ED5BD0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED5BD4: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 82ED5BD8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED5BDC: 41820024  beq 0x82ed5c00
	if ctx.cr[0].eq {
	pc = 0x82ED5C00; continue 'dispatch;
	}
	// 82ED5BE0: 4BFFDCC9  bl 0x82ed38a8
	ctx.lr = 0x82ED5BE4;
	sub_82ED38A8(ctx, base);
	// 82ED5BE4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED5BE8: 41820018  beq 0x82ed5c00
	if ctx.cr[0].eq {
	pc = 0x82ED5C00; continue 'dispatch;
	}
	// 82ED5BEC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ED5BF0: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED5BF4: 4BFFD33D  bl 0x82ed2f30
	ctx.lr = 0x82ED5BF8;
	sub_82ED2F30(ctx, base);
	// 82ED5BF8: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82ED5BFC: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	pc = 0x82ED5C00; continue 'dispatch;
            }
            0x82ED5C00 => {
    //   block [0x82ED5C00..0x82ED5C4C)
	// 82ED5C00: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 82ED5C04: C1610058  lfs f11, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED5C08: C181005C  lfs f12, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED5C0C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED5C10: C1410060  lfs f10, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82ED5C14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED5C18: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED5C1C: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED5C20: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED5C24: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82ED5C28: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED5C2C: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82ED5C30: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED5C34: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82ED5C38: EDAC033A  fmadds f13, f12, f12, f0
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82ED5C3C: 409A0010  bne cr6, 0x82ed5c4c
	if !ctx.cr[6].eq {
	pc = 0x82ED5C4C; continue 'dispatch;
	}
	// 82ED5C40: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED5C44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED5C48: 419A0058  beq cr6, 0x82ed5ca0
	if ctx.cr[6].eq {
	pc = 0x82ED5CA0; continue 'dispatch;
	}
	pc = 0x82ED5C4C; continue 'dispatch;
            }
            0x82ED5C4C => {
    //   block [0x82ED5C4C..0x82ED5C60)
	// 82ED5C4C: 81790718  lwz r11, 0x718(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82ED5C50: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED5C54: 4182000C  beq 0x82ed5c60
	if ctx.cr[0].eq {
	pc = 0x82ED5C60; continue 'dispatch;
	}
	// 82ED5C58: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED5C5C: 48000008  b 0x82ed5c64
	pc = 0x82ED5C64; continue 'dispatch;
            }
            0x82ED5C60 => {
    //   block [0x82ED5C60..0x82ED5C64)
	// 82ED5C60: FD80F090  fmr f12, f30
	ctx.f[12].f64 = ctx.f[30].f64;
	pc = 0x82ED5C64; continue 'dispatch;
            }
            0x82ED5C64 => {
    //   block [0x82ED5C64..0x82ED5C78)
	// 82ED5C64: 81790718  lwz r11, 0x718(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82ED5C68: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED5C6C: 4182000C  beq 0x82ed5c78
	if ctx.cr[0].eq {
	pc = 0x82ED5C78; continue 'dispatch;
	}
	// 82ED5C70: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED5C74: 48000008  b 0x82ed5c7c
	pc = 0x82ED5C7C; continue 'dispatch;
            }
            0x82ED5C78 => {
    //   block [0x82ED5C78..0x82ED5C7C)
	// 82ED5C78: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	pc = 0x82ED5C7C; continue 'dispatch;
            }
            0x82ED5C7C => {
    //   block [0x82ED5C7C..0x82ED5CA0)
	// 82ED5C7C: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82ED5C80: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82ED5C84: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ED5C88: 40980018  bge cr6, 0x82ed5ca0
	if !ctx.cr[6].lt {
	pc = 0x82ED5CA0; continue 'dispatch;
	}
	// 82ED5C8C: 897C0010  lbz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED5C90: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED5C94: 4082000C  bne 0x82ed5ca0
	if !ctx.cr[0].eq {
	pc = 0x82ED5CA0; continue 'dispatch;
	}
	// 82ED5C98: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED5C9C: 418200DC  beq 0x82ed5d78
	if ctx.cr[0].eq {
	pc = 0x82ED5D78; continue 'dispatch;
	}
	pc = 0x82ED5CA0; continue 'dispatch;
            }
            0x82ED5CA0 => {
    //   block [0x82ED5CA0..0x82ED5CD8)
	// 82ED5CA0: D17E0000  stfs f11, 0(r30)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82ED5CA4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ED5CA8: C001005C  lfs f0, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED5CAC: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82ED5CB0: C0010060  lfs f0, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED5CB4: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82ED5CB8: C0010064  lfs f0, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED5CBC: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82ED5CC0: 4BFFC1E1  bl 0x82ed1ea0
	ctx.lr = 0x82ED5CC4;
	sub_82ED1EA0(ctx, base);
	// 82ED5CC4: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82ED5CC8: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 82ED5CCC: 2B080080  cmplwi cr6, r8, 0x80
	ctx.cr[6].compare_u32(ctx.r[8].u32, 128 as u32, &mut ctx.xer);
	// 82ED5CD0: 40990008  ble cr6, 0x82ed5cd8
	if !ctx.cr[6].gt {
	pc = 0x82ED5CD8; continue 'dispatch;
	}
	// 82ED5CD4: 39000080  li r8, 0x80
	ctx.r[8].s64 = 128;
	pc = 0x82ED5CD8; continue 'dispatch;
            }
            0x82ED5CD8 => {
    //   block [0x82ED5CD8..0x82ED5D20)
	// 82ED5CD8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ED5CDC: C03F0014  lfs f1, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ED5CE0: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82ED5CE4: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 82ED5CE8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ED5CEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ED5CF0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ED5CF4: 4BFFC3A5  bl 0x82ed2098
	ctx.lr = 0x82ED5CF8;
	sub_82ED2098(ctx, base);
	// 82ED5CF8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED5CFC: 4182007C  beq 0x82ed5d78
	if ctx.cr[0].eq {
	pc = 0x82ED5D78; continue 'dispatch;
	}
	// 82ED5D00: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ED5D04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED5D08: 419A0070  beq cr6, 0x82ed5d78
	if ctx.cr[6].eq {
	pc = 0x82ED5D78; continue 'dispatch;
	}
	// 82ED5D0C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED5D10: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED5D14: 4182000C  beq 0x82ed5d20
	if ctx.cr[0].eq {
	pc = 0x82ED5D20; continue 'dispatch;
	}
	// 82ED5D18: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ED5D1C: 4BFFD215  bl 0x82ed2f30
	ctx.lr = 0x82ED5D20;
	sub_82ED2F30(ctx, base);
	pc = 0x82ED5D20; continue 'dispatch;
            }
            0x82ED5D20 => {
    //   block [0x82ED5D20..0x82ED5D40)
	// 82ED5D20: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ED5D24: 937F0004  stw r27, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82ED5D28: 4BFFC279  bl 0x82ed1fa0
	ctx.lr = 0x82ED5D2C;
	sub_82ED1FA0(ctx, base);
	// 82ED5D2C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ED5D30: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 82ED5D34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED5D38: 419A0038  beq cr6, 0x82ed5d70
	if ctx.cr[6].eq {
	pc = 0x82ED5D70; continue 'dispatch;
	}
	// 82ED5D3C: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	pc = 0x82ED5D40; continue 'dispatch;
            }
            0x82ED5D40 => {
    //   block [0x82ED5D40..0x82ED5D70)
	// 82ED5D40: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82ED5D44: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED5D48: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82ED5D4C: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 82ED5D50: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ED5D54: 4BFFCFF5  bl 0x82ed2d48
	ctx.lr = 0x82ED5D58;
	sub_82ED2D48(ctx, base);
	// 82ED5D58: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82ED5D5C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ED5D60: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82ED5D64: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82ED5D68: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED5D6C: 4198FFD4  blt cr6, 0x82ed5d40
	if ctx.cr[6].lt {
	pc = 0x82ED5D40; continue 'dispatch;
	}
	pc = 0x82ED5D70; continue 'dispatch;
            }
            0x82ED5D70 => {
    //   block [0x82ED5D70..0x82ED5D78)
	// 82ED5D70: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82ED5D74: 4BFFC24D  bl 0x82ed1fc0
	ctx.lr = 0x82ED5D78;
	sub_82ED1FC0(ctx, base);
	pc = 0x82ED5D78; continue 'dispatch;
            }
            0x82ED5D78 => {
    //   block [0x82ED5D78..0x82ED5D88)
	// 82ED5D78: 817C002C  lwz r11, 0x2c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED5D7C: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82ED5D80: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED5D84: 4198FD90  blt cr6, 0x82ed5b14
	if ctx.cr[6].lt {
	pc = 0x82ED5B14; continue 'dispatch;
	}
	pc = 0x82ED5D88; continue 'dispatch;
            }
            0x82ED5D88 => {
    //   block [0x82ED5D88..0x82ED5D98)
	// 82ED5D88: 897C0010  lbz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED5D8C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED5D90: 41820008  beq 0x82ed5d98
	if ctx.cr[0].eq {
	pc = 0x82ED5D98; continue 'dispatch;
	}
	// 82ED5D94: 9B7C0010  stb r27, 0x10(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(16 as u32), ctx.r[27].u8 ) };
	pc = 0x82ED5D98; continue 'dispatch;
            }
            0x82ED5D98 => {
    //   block [0x82ED5D98..0x82ED5D9C)
	// 82ED5D98: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82ED5D9C; continue 'dispatch;
            }
            0x82ED5D9C => {
    //   block [0x82ED5D9C..0x82ED5DAC)
	// 82ED5D9C: 382102D0  addi r1, r1, 0x2d0
	ctx.r[1].s64 = ctx.r[1].s64 + 720;
	// 82ED5DA0: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 82ED5DA4: 4BDD7F81  bl 0x82cadd24
	ctx.lr = 0x82ED5DA8;
	sub_82CADCEC(ctx, base);
	// 82ED5DA8: 4BDD36A4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82ED5DAC => {
    //   block [0x82ED5DAC..0x82ED5DB4)
	// 82ED5DAC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ED5DB0: 4BFFFFEC  b 0x82ed5d9c
	pc = 0x82ED5D9C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED5DB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ED5DB8 size=308
    let mut pc: u32 = 0x82ED5DB8;
    'dispatch: loop {
        match pc {
            0x82ED5DB8 => {
    //   block [0x82ED5DB8..0x82ED5DEC)
	// 82ED5DB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED5DBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED5DC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ED5DC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED5DC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED5DCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED5DD0: 3D6007FF  lis r11, 0x7ff
	ctx.r[11].s64 = 134152192;
	// 82ED5DD4: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 82ED5DD8: 83DF002C  lwz r30, 0x2c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED5DDC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED5DE0: 57C32834  slwi r3, r30, 5
	ctx.r[3].u32 = ctx.r[30].u32.wrapping_shl(5);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82ED5DE4: 40990008  ble cr6, 0x82ed5dec
	if !ctx.cr[6].gt {
	pc = 0x82ED5DEC; continue 'dispatch;
	}
	// 82ED5DE8: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82ED5DEC; continue 'dispatch;
            }
            0x82ED5DEC => {
    //   block [0x82ED5DEC..0x82ED5E10)
	// 82ED5DEC: 4B740B3D  bl 0x82616928
	ctx.lr = 0x82ED5DF0;
	sub_82616928(ctx, base);
	// 82ED5DF0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED5DF4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ED5DF8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED5DFC: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED5E00: 41820030  beq 0x82ed5e30
	if ctx.cr[0].eq {
	pc = 0x82ED5E30; continue 'dispatch;
	}
	// 82ED5E04: 353EFFFF  addic. r9, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82ED5E08: 41800020  blt 0x82ed5e28
	if ctx.cr[0].lt {
	pc = 0x82ED5E28; continue 'dispatch;
	}
	// 82ED5E0C: 39630010  addi r11, r3, 0x10
	ctx.r[11].s64 = ctx.r[3].s64 + 16;
	pc = 0x82ED5E10; continue 'dispatch;
            }
            0x82ED5E10 => {
    //   block [0x82ED5E10..0x82ED5E28)
	// 82ED5E10: D00BFFF8  stfs f0, -8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82ED5E14: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82ED5E18: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82ED5E1C: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82ED5E20: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 82ED5E24: 4080FFEC  bge 0x82ed5e10
	if !ctx.cr[0].lt {
	pc = 0x82ED5E10; continue 'dispatch;
	}
	pc = 0x82ED5E28; continue 'dispatch;
            }
            0x82ED5E28 => {
    //   block [0x82ED5E28..0x82ED5E30)
	// 82ED5E28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ED5E2C: 48000008  b 0x82ed5e34
	pc = 0x82ED5E34; continue 'dispatch;
            }
            0x82ED5E30 => {
    //   block [0x82ED5E30..0x82ED5E34)
	// 82ED5E30: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x82ED5E34; continue 'dispatch;
            }
            0x82ED5E34 => {
    //   block [0x82ED5E34..0x82ED5E54)
	// 82ED5E34: 811F002C  lwz r8, 0x2c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED5E38: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 82ED5E3C: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82ED5E40: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82ED5E44: 40990080  ble cr6, 0x82ed5ec4
	if !ctx.cr[6].gt {
	pc = 0x82ED5EC4; continue 'dispatch;
	}
	// 82ED5E48: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82ED5E4C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82ED5E50: C1A80BEC  lfs f13, 0xbec(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3052 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82ED5E54; continue 'dispatch;
            }
            0x82ED5E54 => {
    //   block [0x82ED5E54..0x82ED5EC4)
	// 82ED5E54: 811F0024  lwz r8, 0x24(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82ED5E58: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ED5E5C: 7D4B412E  stwx r10, r11, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), ctx.r[10].u32) };
	// 82ED5E60: 811F0024  lwz r8, 0x24(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82ED5E64: 7D0B4214  add r8, r11, r8
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82ED5E68: 91480004  stw r10, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82ED5E6C: 811F0024  lwz r8, 0x24(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82ED5E70: 7D0B4214  add r8, r11, r8
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82ED5E74: D0080008  stfs f0, 8(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82ED5E78: 811F0024  lwz r8, 0x24(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82ED5E7C: 7D0B4214  add r8, r11, r8
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82ED5E80: D008000C  stfs f0, 0xc(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82ED5E84: 811F0024  lwz r8, 0x24(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82ED5E88: 7D0B4214  add r8, r11, r8
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82ED5E8C: D0080010  stfs f0, 0x10(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82ED5E90: 811F0024  lwz r8, 0x24(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82ED5E94: 7D0B4214  add r8, r11, r8
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82ED5E98: D1A80014  stfs f13, 0x14(r8)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82ED5E9C: 811F0024  lwz r8, 0x24(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82ED5EA0: 7D0B4214  add r8, r11, r8
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82ED5EA4: 91480018  stw r10, 0x18(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82ED5EA8: 811F0024  lwz r8, 0x24(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82ED5EAC: 7D0B4214  add r8, r11, r8
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82ED5EB0: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 82ED5EB4: 9948001C  stb r10, 0x1c(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(28 as u32), ctx.r[10].u8 ) };
	// 82ED5EB8: 811F002C  lwz r8, 0x2c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED5EBC: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82ED5EC0: 4198FF94  blt cr6, 0x82ed5e54
	if ctx.cr[6].lt {
	pc = 0x82ED5E54; continue 'dispatch;
	}
	pc = 0x82ED5EC4; continue 'dispatch;
            }
            0x82ED5EC4 => {
    //   block [0x82ED5EC4..0x82ED5EEC)
	// 82ED5EC4: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82ED5EC8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ED5ECC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ED5ED0: 994B001C  stb r10, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[10].u8 ) };
	// 82ED5ED4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ED5ED8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED5EDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED5EE0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ED5EE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED5EE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED5EF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED5EF0 size=80
    let mut pc: u32 = 0x82ED5EF0;
    'dispatch: loop {
        match pc {
            0x82ED5EF0 => {
    //   block [0x82ED5EF0..0x82ED5F28)
	// 82ED5EF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED5EF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED5EF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED5EFC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED5F00: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED5F04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED5F08: 396BBA90  addi r11, r11, -0x4570
	ctx.r[11].s64 = ctx.r[11].s64 + -17776;
	// 82ED5F0C: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ED5F10: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ED5F14: 41820014  beq 0x82ed5f28
	if ctx.cr[0].eq {
	pc = 0x82ED5F28; continue 'dispatch;
	}
	// 82ED5F18: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ED5F1C: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ED5F20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED5F24: 4E800421  bctrl
	ctx.lr = 0x82ED5F28;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED5F28 => {
    //   block [0x82ED5F28..0x82ED5F40)
	// 82ED5F28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED5F2C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ED5F30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED5F34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED5F38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED5F3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED5F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED5F40 size=20
    let mut pc: u32 = 0x82ED5F40;
    'dispatch: loop {
        match pc {
            0x82ED5F40 => {
    //   block [0x82ED5F40..0x82ED5F54)
	// 82ED5F40: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED5F44: 394B0008  addi r10, r11, 8
	ctx.r[10].s64 = ctx.r[11].s64 + 8;
	// 82ED5F48: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82ED5F4C: 9143002C  stw r10, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 82ED5F50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED5F58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED5F58 size=24
    let mut pc: u32 = 0x82ED5F58;
    'dispatch: loop {
        match pc {
            0x82ED5F58 => {
    //   block [0x82ED5F58..0x82ED5F70)
	// 82ED5F58: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED5F5C: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82ED5F60: 396B0009  addi r11, r11, 9
	ctx.r[11].s64 = ctx.r[11].s64 + 9;
	// 82ED5F64: 91430028  stw r10, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82ED5F68: 9163002C  stw r11, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82ED5F6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED5F70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82ED5F70 size=816
    let mut pc: u32 = 0x82ED5F70;
    'dispatch: loop {
        match pc {
            0x82ED5F70 => {
    //   block [0x82ED5F70..0x82ED5FCC)
	// 82ED5F70: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82ED5F74: 5485063F  clrlwi. r5, r4, 0x18
	ctx.r[5].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82ED5F78: 41820054  beq 0x82ed5fcc
	if ctx.cr[0].eq {
	pc = 0x82ED5FCC; continue 'dispatch;
	}
	// 82ED5F7C: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ED5F80: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED5F84: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82ED5F88: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82ED5F8C: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82ED5F90: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82ED5F94: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82ED5F98: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82ED5F9C: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82ED5FA0: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82ED5FA4: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ED5FA8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED5FAC: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82ED5FB0: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82ED5FB4: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82ED5FB8: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82ED5FBC: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82ED5FC0: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82ED5FC4: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82ED5FC8: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED5FCC; continue 'dispatch;
            }
            0x82ED5FCC => {
    //   block [0x82ED5FCC..0x82ED6014)
	// 82ED5FCC: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ED5FD0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ED5FD4: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED5FD8: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82ED5FDC: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED5FE0: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED5FE4: 814A007C  lwz r10, 0x7c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(124 as u32) ) } as u64;
	// 82ED5FE8: 90C30034  stw r6, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[6].u32 ) };
	// 82ED5FEC: 7D4A41D6  mullw r10, r10, r8
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82ED5FF0: 90C30020  stw r6, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[6].u32 ) };
	// 82ED5FF4: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82ED5FF8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82ED5FFC: 91430030  stw r10, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 82ED6000: 419A0114  beq cr6, 0x82ed6114
	if ctx.cr[6].eq {
	pc = 0x82ED6114; continue 'dispatch;
	}
	// 82ED6004: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED6008: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	// 82ED600C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED6010: 40990104  ble cr6, 0x82ed6114
	if !ctx.cr[6].gt {
	pc = 0x82ED6114; continue 'dispatch;
	}
	pc = 0x82ED6014; continue 'dispatch;
            }
            0x82ED6014 => {
    //   block [0x82ED6014..0x82ED6114)
	// 82ED6014: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED6018: 8143002C  lwz r10, 0x2c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED601C: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82ED6020: 7D6B49D6  mullw r11, r11, r9
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82ED6024: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ED6028: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ED602C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED6030: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82ED6034: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82ED6038: 5148843E  rlwimi r8, r10, 0x10, 0x10, 0x1f
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF0000);
	// 82ED603C: 5147801E  rlwimi r7, r10, 0x10, 0, 0xf
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[7].u64 & 0xFFFFFFFF0000FFFF);
	// 82ED6040: 550AC43E  rlwinm r10, r8, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82ED6044: 54E8401E  rlwinm r8, r7, 8, 0, 0xf
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x00FFFFFFu64;
	// 82ED6048: 7D4A4378  or r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 82ED604C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ED6050: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED6054: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82ED6058: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82ED605C: 5148843E  rlwimi r8, r10, 0x10, 0x10, 0x1f
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF0000);
	// 82ED6060: 5147801E  rlwimi r7, r10, 0x10, 0, 0xf
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[7].u64 & 0xFFFFFFFF0000FFFF);
	// 82ED6064: 550AC43E  rlwinm r10, r8, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82ED6068: 54E8401E  rlwinm r8, r7, 8, 0, 0xf
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x00FFFFFFu64;
	// 82ED606C: 7D4A4378  or r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 82ED6070: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82ED6074: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED6078: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82ED607C: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82ED6080: 5148843E  rlwimi r8, r10, 0x10, 0x10, 0x1f
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF0000);
	// 82ED6084: 5147801E  rlwimi r7, r10, 0x10, 0, 0xf
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[7].u64 & 0xFFFFFFFF0000FFFF);
	// 82ED6088: 550AC43E  rlwinm r10, r8, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82ED608C: 54E8401E  rlwinm r8, r7, 8, 0, 0xf
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x00FFFFFFu64;
	// 82ED6090: 7D4A4378  or r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 82ED6094: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82ED6098: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED609C: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82ED60A0: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82ED60A4: 5148843E  rlwimi r8, r10, 0x10, 0x10, 0x1f
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF0000);
	// 82ED60A8: 5147801E  rlwimi r7, r10, 0x10, 0, 0xf
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[7].u64 & 0xFFFFFFFF0000FFFF);
	// 82ED60AC: 550AC43E  rlwinm r10, r8, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82ED60B0: 54E8401E  rlwinm r8, r7, 8, 0, 0xf
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x00FFFFFFu64;
	// 82ED60B4: 7D4A4378  or r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 82ED60B8: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82ED60BC: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED60C0: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82ED60C4: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82ED60C8: 5148843E  rlwimi r8, r10, 0x10, 0x10, 0x1f
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF0000);
	// 82ED60CC: 5147801E  rlwimi r7, r10, 0x10, 0, 0xf
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[7].u64 & 0xFFFFFFFF0000FFFF);
	// 82ED60D0: 550AC43E  rlwinm r10, r8, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82ED60D4: 54E8401E  rlwinm r8, r7, 8, 0, 0xf
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x00FFFFFFu64;
	// 82ED60D8: 7D4A4378  or r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 82ED60DC: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82ED60E0: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ED60E4: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82ED60E8: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82ED60EC: 5148843E  rlwimi r8, r10, 0x10, 0x10, 0x1f
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF0000);
	// 82ED60F0: 5147801E  rlwimi r7, r10, 0x10, 0, 0xf
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[7].u64 & 0xFFFFFFFF0000FFFF);
	// 82ED60F4: 550AC43E  rlwinm r10, r8, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82ED60F8: 54E8401E  rlwinm r8, r7, 8, 0, 0xf
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x00FFFFFFu64;
	// 82ED60FC: 7D4A4378  or r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 82ED6100: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82ED6104: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ED6108: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED610C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED6110: 4198FF04  blt cr6, 0x82ed6014
	if ctx.cr[6].lt {
	pc = 0x82ED6014; continue 'dispatch;
	}
	pc = 0x82ED6114; continue 'dispatch;
            }
            0x82ED6114 => {
    //   block [0x82ED6114..0x82ED6174)
	// 82ED6114: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED6118: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ED611C: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED6120: D0030038  stfs f0, 0x38(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82ED6124: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED6128: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED612C: 419A0058  beq cr6, 0x82ed6184
	if ctx.cr[6].eq {
	pc = 0x82ED6184; continue 'dispatch;
	}
	// 82ED6130: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED6134: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED6138: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82ED613C: 419A0044  beq cr6, 0x82ed6180
	if ctx.cr[6].eq {
	pc = 0x82ED6180; continue 'dispatch;
	}
	// 82ED6140: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED6144: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82ED6148: D0030038  stfs f0, 0x38(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82ED614C: 419A0028  beq cr6, 0x82ed6174
	if ctx.cr[6].eq {
	pc = 0x82ED6174; continue 'dispatch;
	}
	// 82ED6150: 81630038  lwz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 82ED6154: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82ED6158: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82ED615C: 516A843E  rlwimi r10, r11, 0x10, 0x10, 0x1f
	ctx.r[10].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF0000);
	// 82ED6160: 5169801E  rlwimi r9, r11, 0x10, 0, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[9].u64 & 0xFFFFFFFF0000FFFF);
	// 82ED6164: 554BC43E  rlwinm r11, r10, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82ED6168: 552A401E  rlwinm r10, r9, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00FFFFFFu64;
	// 82ED616C: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82ED6170: 91630038  stw r11, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED6174; continue 'dispatch;
            }
            0x82ED6174 => {
    //   block [0x82ED6174..0x82ED6180)
	// 82ED6174: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED6178: 90CB0014  stw r6, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[6].u32 ) };
	// 82ED617C: 48000008  b 0x82ed6184
	pc = 0x82ED6184; continue 'dispatch;
            }
            0x82ED6180 => {
    //   block [0x82ED6180..0x82ED6184)
	// 82ED6180: D0030038  stfs f0, 0x38(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	pc = 0x82ED6184; continue 'dispatch;
            }
            0x82ED6184 => {
    //   block [0x82ED6184..0x82ED61A0)
	// 82ED6184: 80E30028  lwz r7, 0x28(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ED6188: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	// 82ED618C: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED6190: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED6194: 40990058  ble cr6, 0x82ed61ec
	if !ctx.cr[6].gt {
	pc = 0x82ED61EC; continue 'dispatch;
	}
	// 82ED6198: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED619C: 8103002C  lwz r8, 0x2c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	pc = 0x82ED61A0; continue 'dispatch;
            }
            0x82ED61A0 => {
    //   block [0x82ED61A0..0x82ED61CC)
	// 82ED61A0: 8169007C  lwz r11, 0x7c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 82ED61A4: 3C808000  lis r4, -0x8000
	ctx.r[4].s64 = -2147483648;
	// 82ED61A8: 7D6B51D6  mullw r11, r11, r10
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82ED61AC: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82ED61B0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED61B4: 7F1F2040  cmplw cr6, r31, r4
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82ED61B8: 41980020  blt cr6, 0x82ed61d8
	if ctx.cr[6].lt {
	pc = 0x82ED61D8; continue 'dispatch;
	}
	// 82ED61BC: 80830034  lwz r4, 0x34(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ED61C0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82ED61C4: 409A0008  bne cr6, 0x82ed61cc
	if !ctx.cr[6].eq {
	pc = 0x82ED61CC; continue 'dispatch;
	}
	// 82ED61C8: 91630034  stw r11, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED61CC; continue 'dispatch;
            }
            0x82ED61CC => {
    //   block [0x82ED61CC..0x82ED61D8)
	// 82ED61CC: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ED61D0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82ED61D4: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED61D8; continue 'dispatch;
            }
            0x82ED61D8 => {
    //   block [0x82ED61D8..0x82ED61EC)
	// 82ED61D8: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ED61DC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ED61E0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED61E4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED61E8: 4198FFB8  blt cr6, 0x82ed61a0
	if ctx.cr[6].lt {
	pc = 0x82ED61A0; continue 'dispatch;
	}
	pc = 0x82ED61EC; continue 'dispatch;
            }
            0x82ED61EC => {
    //   block [0x82ED61EC..0x82ED6204)
	// 82ED61EC: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82ED61F0: 419A00A8  beq cr6, 0x82ed6298
	if ctx.cr[6].eq {
	pc = 0x82ED6298; continue 'dispatch;
	}
	// 82ED61F4: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED61F8: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	// 82ED61FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED6200: 40990098  ble cr6, 0x82ed6298
	if !ctx.cr[6].gt {
	pc = 0x82ED6298; continue 'dispatch;
	}
	pc = 0x82ED6204; continue 'dispatch;
            }
            0x82ED6204 => {
    //   block [0x82ED6204..0x82ED6298)
	// 82ED6204: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED6208: 81430030  lwz r10, 0x30(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ED620C: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82ED6210: 7D6B49D6  mullw r11, r11, r9
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82ED6214: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ED6218: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ED621C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED6220: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82ED6224: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82ED6228: 5148843E  rlwimi r8, r10, 0x10, 0x10, 0x1f
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF0000);
	// 82ED622C: 5147801E  rlwimi r7, r10, 0x10, 0, 0xf
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[7].u64 & 0xFFFFFFFF0000FFFF);
	// 82ED6230: 550AC43E  rlwinm r10, r8, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82ED6234: 54E8401E  rlwinm r8, r7, 8, 0, 0xf
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x00FFFFFFu64;
	// 82ED6238: 7D4A4378  or r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 82ED623C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ED6240: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED6244: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82ED6248: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82ED624C: 5148843E  rlwimi r8, r10, 0x10, 0x10, 0x1f
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF0000);
	// 82ED6250: 5147801E  rlwimi r7, r10, 0x10, 0, 0xf
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[7].u64 & 0xFFFFFFFF0000FFFF);
	// 82ED6254: 550AC43E  rlwinm r10, r8, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82ED6258: 54E8401E  rlwinm r8, r7, 8, 0, 0xf
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x00FFFFFFu64;
	// 82ED625C: 7D4A4378  or r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 82ED6260: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82ED6264: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED6268: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 82ED626C: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82ED6270: 5148843E  rlwimi r8, r10, 0x10, 0x10, 0x1f
	ctx.r[8].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[8].u64 & 0xFFFFFFFFFFFF0000);
	// 82ED6274: 5147801E  rlwimi r7, r10, 0x10, 0, 0xf
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[7].u64 & 0xFFFFFFFF0000FFFF);
	// 82ED6278: 550AC43E  rlwinm r10, r8, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82ED627C: 54E8401E  rlwinm r8, r7, 8, 0, 0xf
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x00FFFFFFu64;
	// 82ED6280: 7D4A4378  or r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 82ED6284: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82ED6288: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ED628C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED6290: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED6294: 4198FF70  blt cr6, 0x82ed6204
	if ctx.cr[6].lt {
	pc = 0x82ED6204; continue 'dispatch;
	}
	pc = 0x82ED6298; continue 'dispatch;
            }
            0x82ED6298 => {
    //   block [0x82ED6298..0x82ED62A0)
	// 82ED6298: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82ED629C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED62A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED62A0 size=792
    let mut pc: u32 = 0x82ED62A0;
    'dispatch: loop {
        match pc {
            0x82ED62A0 => {
    //   block [0x82ED62A0..0x82ED62F8)
	// 82ED62A0: 5486063F  clrlwi. r6, r4, 0x18
	ctx.r[6].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82ED62A4: 41820054  beq 0x82ed62f8
	if ctx.cr[0].eq {
	pc = 0x82ED62F8; continue 'dispatch;
	}
	// 82ED62A8: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ED62AC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED62B0: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82ED62B4: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82ED62B8: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82ED62BC: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82ED62C0: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82ED62C4: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82ED62C8: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82ED62CC: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82ED62D0: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ED62D4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED62D8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82ED62DC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82ED62E0: 5169843E  rlwimi r9, r11, 0x10, 0x10, 0x1f
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF0000);
	// 82ED62E4: 5168801E  rlwimi r8, r11, 0x10, 0, 0xf
	ctx.r[8].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[8].u64 & 0xFFFFFFFF0000FFFF);
	// 82ED62E8: 552BC43E  rlwinm r11, r9, 0x18, 0x10, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82ED62EC: 5509401E  rlwinm r9, r8, 8, 0, 0xf
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x00FFFFFFu64;
	// 82ED62F0: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82ED62F4: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED62F8; continue 'dispatch;
            }
            0x82ED62F8 => {
    //   block [0x82ED62F8..0x82ED635C)
	// 82ED62F8: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ED62FC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82ED6300: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED6304: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82ED6308: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED630C: 55292834  slwi r9, r9, 5
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(5);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82ED6310: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82ED6314: 39290009  addi r9, r9, 9
	ctx.r[9].s64 = ctx.r[9].s64 + 9;
	// 82ED6318: 91230030  stw r9, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[9].u32 ) };
	// 82ED631C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED6320: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED6324: 5508083C  slwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82ED6328: 90E30034  stw r7, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[7].u32 ) };
	// 82ED632C: 90E30020  stw r7, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[7].u32 ) };
	// 82ED6330: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82ED6334: 55292036  slwi r9, r9, 4
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82ED6338: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82ED633C: 394A0009  addi r10, r10, 9
	ctx.r[10].s64 = ctx.r[10].s64 + 9;
	// 82ED6340: 91430038  stw r10, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 82ED6344: 419A0160  beq cr6, 0x82ed64a4
	if ctx.cr[6].eq {
	pc = 0x82ED64A4; continue 'dispatch;
	}
	// 82ED6348: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED634C: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 82ED6350: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED6354: 40990150  ble cr6, 0x82ed64a4
	if !ctx.cr[6].gt {
	pc = 0x82ED64A4; continue 'dispatch;
	}
	// 82ED6358: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	pc = 0x82ED635C; continue 'dispatch;
            }
            0x82ED635C => {
    //   block [0x82ED635C..0x82ED64A4)
	// 82ED635C: 8103002C  lwz r8, 0x2c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED6360: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ED6364: 7D4B402E  lwzx r10, r11, r8
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82ED6368: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	// 82ED636C: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 82ED6370: 5145843E  rlwimi r5, r10, 0x10, 0x10, 0x1f
	ctx.r[5].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[5].u64 & 0xFFFFFFFFFFFF0000);
	// 82ED6374: 5144801E  rlwimi r4, r10, 0x10, 0, 0xf
	ctx.r[4].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[4].u64 & 0xFFFFFFFF0000FFFF);
	// 82ED6378: 54AAC43E  rlwinm r10, r5, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82ED637C: 5485401E  rlwinm r5, r4, 8, 0, 0xf
	ctx.r[5].u64 = ctx.r[4].u32 as u64 & 0x00FFFFFFu64;
	// 82ED6380: 7D4A2B78  or r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 82ED6384: 7D4B412E  stwx r10, r11, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), ctx.r[10].u32) };
	// 82ED6388: 8143002C  lwz r10, 0x2c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED638C: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ED6390: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED6394: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	// 82ED6398: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 82ED639C: 5145843E  rlwimi r5, r10, 0x10, 0x10, 0x1f
	ctx.r[5].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[5].u64 & 0xFFFFFFFFFFFF0000);
	// 82ED63A0: 5144801E  rlwimi r4, r10, 0x10, 0, 0xf
	ctx.r[4].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[4].u64 & 0xFFFFFFFF0000FFFF);
	// 82ED63A4: 54AAC43E  rlwinm r10, r5, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82ED63A8: 5485401E  rlwinm r5, r4, 8, 0, 0xf
	ctx.r[5].u64 = ctx.r[4].u32 as u64 & 0x00FFFFFFu64;
	// 82ED63AC: 7D4A2B78  or r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 82ED63B0: 91480004  stw r10, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82ED63B4: 8143002C  lwz r10, 0x2c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED63B8: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ED63BC: 81480008  lwz r10, 8(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED63C0: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	// 82ED63C4: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 82ED63C8: 5145843E  rlwimi r5, r10, 0x10, 0x10, 0x1f
	ctx.r[5].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[5].u64 & 0xFFFFFFFFFFFF0000);
	// 82ED63CC: 5144801E  rlwimi r4, r10, 0x10, 0, 0xf
	ctx.r[4].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[4].u64 & 0xFFFFFFFF0000FFFF);
	// 82ED63D0: 54AAC43E  rlwinm r10, r5, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82ED63D4: 5485401E  rlwinm r5, r4, 8, 0, 0xf
	ctx.r[5].u64 = ctx.r[4].u32 as u64 & 0x00FFFFFFu64;
	// 82ED63D8: 7D4A2B78  or r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 82ED63DC: 91480008  stw r10, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82ED63E0: 8143002C  lwz r10, 0x2c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED63E4: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ED63E8: 8148000C  lwz r10, 0xc(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED63EC: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	// 82ED63F0: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 82ED63F4: 5145843E  rlwimi r5, r10, 0x10, 0x10, 0x1f
	ctx.r[5].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[5].u64 & 0xFFFFFFFFFFFF0000);
	// 82ED63F8: 5144801E  rlwimi r4, r10, 0x10, 0, 0xf
	ctx.r[4].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[4].u64 & 0xFFFFFFFF0000FFFF);
	// 82ED63FC: 54AAC43E  rlwinm r10, r5, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82ED6400: 5485401E  rlwinm r5, r4, 8, 0, 0xf
	ctx.r[5].u64 = ctx.r[4].u32 as u64 & 0x00FFFFFFu64;
	// 82ED6404: 7D4A2B78  or r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 82ED6408: 9148000C  stw r10, 0xc(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82ED640C: 8143002C  lwz r10, 0x2c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED6410: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ED6414: 81480010  lwz r10, 0x10(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED6418: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	// 82ED641C: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 82ED6420: 5145843E  rlwimi r5, r10, 0x10, 0x10, 0x1f
	ctx.r[5].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[5].u64 & 0xFFFFFFFFFFFF0000);
	// 82ED6424: 5144801E  rlwimi r4, r10, 0x10, 0, 0xf
	ctx.r[4].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[4].u64 & 0xFFFFFFFF0000FFFF);
	// 82ED6428: 54AAC43E  rlwinm r10, r5, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82ED642C: 5485401E  rlwinm r5, r4, 8, 0, 0xf
	ctx.r[5].u64 = ctx.r[4].u32 as u64 & 0x00FFFFFFu64;
	// 82ED6430: 7D4A2B78  or r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 82ED6434: 91480010  stw r10, 0x10(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82ED6438: 8143002C  lwz r10, 0x2c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED643C: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ED6440: 81480014  lwz r10, 0x14(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED6444: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	// 82ED6448: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 82ED644C: 5145843E  rlwimi r5, r10, 0x10, 0x10, 0x1f
	ctx.r[5].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[5].u64 & 0xFFFFFFFFFFFF0000);
	// 82ED6450: 5144801E  rlwimi r4, r10, 0x10, 0, 0xf
	ctx.r[4].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[4].u64 & 0xFFFFFFFF0000FFFF);
	// 82ED6454: 54AAC43E  rlwinm r10, r5, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82ED6458: 5485401E  rlwinm r5, r4, 8, 0, 0xf
	ctx.r[5].u64 = ctx.r[4].u32 as u64 & 0x00FFFFFFu64;
	// 82ED645C: 7D4A2B78  or r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 82ED6460: 91480014  stw r10, 0x14(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82ED6464: 8143002C  lwz r10, 0x2c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED6468: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ED646C: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 82ED6470: 8148001C  lwz r10, 0x1c(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED6474: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	// 82ED6478: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 82ED647C: 5145801E  rlwimi r5, r10, 0x10, 0, 0xf
	ctx.r[5].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[5].u64 & 0xFFFFFFFF0000FFFF);
	// 82ED6480: 5144843E  rlwimi r4, r10, 0x10, 0x10, 0x1f
	ctx.r[4].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[4].u64 & 0xFFFFFFFFFFFF0000);
	// 82ED6484: 54AA401E  rlwinm r10, r5, 8, 0, 0xf
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x00FFFFFFu64;
	// 82ED6488: 5485C43E  rlwinm r5, r4, 0x18, 0x10, 0x1f
	ctx.r[5].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82ED648C: 7D4A2B78  or r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[5].u64;
	// 82ED6490: 9148001C  stw r10, 0x1c(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82ED6494: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ED6498: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED649C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ED64A0: 4198FEBC  blt cr6, 0x82ed635c
	if ctx.cr[6].lt {
	pc = 0x82ED635C; continue 'dispatch;
	}
	pc = 0x82ED64A4; continue 'dispatch;
            }
            0x82ED64A4 => {
    //   block [0x82ED64A4..0x82ED64BC)
	// 82ED64A4: 81030028  lwz r8, 0x28(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ED64A8: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 82ED64AC: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED64B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED64B4: 4099004C  ble cr6, 0x82ed6500
	if !ctx.cr[6].gt {
	pc = 0x82ED6500; continue 'dispatch;
	}
	// 82ED64B8: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	pc = 0x82ED64BC; continue 'dispatch;
            }
            0x82ED64BC => {
    //   block [0x82ED64BC..0x82ED64DC)
	// 82ED64BC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED64C0: 3CA08000  lis r5, -0x8000
	ctx.r[5].s64 = -2147483648;
	// 82ED64C4: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82ED64C8: 41980020  blt cr6, 0x82ed64e8
	if ctx.cr[6].lt {
	pc = 0x82ED64E8; continue 'dispatch;
	}
	// 82ED64CC: 81230034  lwz r9, 0x34(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 82ED64D0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82ED64D4: 409A0008  bne cr6, 0x82ed64dc
	if !ctx.cr[6].eq {
	pc = 0x82ED64DC; continue 'dispatch;
	}
	// 82ED64D8: 91630034  stw r11, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED64DC; continue 'dispatch;
            }
            0x82ED64DC => {
    //   block [0x82ED64DC..0x82ED64E8)
	// 82ED64DC: 81230020  lwz r9, 0x20(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ED64E0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ED64E4: 91230020  stw r9, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	pc = 0x82ED64E8; continue 'dispatch;
            }
            0x82ED64E8 => {
    //   block [0x82ED64E8..0x82ED6500)
	// 82ED64E8: 81230028  lwz r9, 0x28(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ED64EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ED64F0: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 82ED64F4: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED64F8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82ED64FC: 4198FFC0  blt cr6, 0x82ed64bc
	if ctx.cr[6].lt {
	pc = 0x82ED64BC; continue 'dispatch;
	}
	pc = 0x82ED6500; continue 'dispatch;
            }
            0x82ED6500 => {
    //   block [0x82ED6500..0x82ED651C)
	// 82ED6500: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82ED6504: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82ED6508: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED650C: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 82ED6510: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED6514: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 82ED6518: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	pc = 0x82ED651C; continue 'dispatch;
            }
            0x82ED651C => {
    //   block [0x82ED651C..0x82ED65B8)
	// 82ED651C: 81030030  lwz r8, 0x30(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ED6520: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82ED6524: 7D4B402E  lwzx r10, r11, r8
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82ED6528: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82ED652C: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82ED6530: 5147843E  rlwimi r7, r10, 0x10, 0x10, 0x1f
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF0000);
	// 82ED6534: 5146801E  rlwimi r6, r10, 0x10, 0, 0xf
	ctx.r[6].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[6].u64 & 0xFFFFFFFF0000FFFF);
	// 82ED6538: 54EAC43E  rlwinm r10, r7, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82ED653C: 54C7401E  rlwinm r7, r6, 8, 0, 0xf
	ctx.r[7].u64 = ctx.r[6].u32 as u64 & 0x00FFFFFFu64;
	// 82ED6540: 7D4A3B78  or r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[7].u64;
	// 82ED6544: 7D4B412E  stwx r10, r11, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), ctx.r[10].u32) };
	// 82ED6548: 81430030  lwz r10, 0x30(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ED654C: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ED6550: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED6554: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82ED6558: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82ED655C: 5147843E  rlwimi r7, r10, 0x10, 0x10, 0x1f
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF0000);
	// 82ED6560: 5146801E  rlwimi r6, r10, 0x10, 0, 0xf
	ctx.r[6].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[6].u64 & 0xFFFFFFFF0000FFFF);
	// 82ED6564: 54EAC43E  rlwinm r10, r7, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82ED6568: 54C7401E  rlwinm r7, r6, 8, 0, 0xf
	ctx.r[7].u64 = ctx.r[6].u32 as u64 & 0x00FFFFFFu64;
	// 82ED656C: 7D4A3B78  or r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[7].u64;
	// 82ED6570: 91480004  stw r10, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82ED6574: 81430030  lwz r10, 0x30(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ED6578: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ED657C: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82ED6580: 81480008  lwz r10, 8(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED6584: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82ED6588: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82ED658C: 5147843E  rlwimi r7, r10, 0x10, 0x10, 0x1f
	ctx.r[7].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x000000000000FFFF) | (ctx.r[7].u64 & 0xFFFFFFFFFFFF0000);
	// 82ED6590: 5146801E  rlwimi r6, r10, 0x10, 0, 0xf
	ctx.r[6].u64 = (((ctx.r[10].u32).rotate_left(16) as u64) & 0x00000000FFFF0000) | (ctx.r[6].u64 & 0xFFFFFFFF0000FFFF);
	// 82ED6594: 54EAC43E  rlwinm r10, r7, 0x18, 0x10, 0x1f
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82ED6598: 54C7401E  rlwinm r7, r6, 8, 0, 0xf
	ctx.r[7].u64 = ctx.r[6].u32 as u64 & 0x00FFFFFFu64;
	// 82ED659C: 7D4A3B78  or r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[7].u64;
	// 82ED65A0: 91480008  stw r10, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82ED65A4: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ED65A8: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED65AC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ED65B0: 4198FF6C  blt cr6, 0x82ed651c
	if ctx.cr[6].lt {
	pc = 0x82ED651C; continue 'dispatch;
	}
	// 82ED65B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED65B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED65B8 size=120
    let mut pc: u32 = 0x82ED65B8;
    'dispatch: loop {
        match pc {
            0x82ED65B8 => {
    //   block [0x82ED65B8..0x82ED65E0)
	// 82ED65B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED65BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED65C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ED65C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED65C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED65CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED65D0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ED65D4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED65D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED65DC: 40990038  ble cr6, 0x82ed6614
	if !ctx.cr[6].gt {
	pc = 0x82ED6614; continue 'dispatch;
	}
	pc = 0x82ED65E0; continue 'dispatch;
            }
            0x82ED65E0 => {
    //   block [0x82ED65E0..0x82ED6614)
	// 82ED65E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED65E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ED65E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED65EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED65F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED65F4: 4E800421  bctrl
	ctx.lr = 0x82ED65F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED65F8: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED65FC: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 82ED6600: 419A0018  beq cr6, 0x82ed6618
	if ctx.cr[6].eq {
	pc = 0x82ED6618; continue 'dispatch;
	}
	// 82ED6604: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED6608: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82ED660C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED6610: 4198FFD0  blt cr6, 0x82ed65e0
	if ctx.cr[6].lt {
	pc = 0x82ED65E0; continue 'dispatch;
	}
            }
            0x82ED6614 => {
    //   block [0x82ED6614..0x82ED6618)
	// 82ED6614: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82ED6618; continue 'dispatch;
            }
            0x82ED6618 => {
    //   block [0x82ED6618..0x82ED6630)
	// 82ED6618: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ED661C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED6620: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED6624: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ED6628: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED662C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED6630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED6630 size=120
    let mut pc: u32 = 0x82ED6630;
    'dispatch: loop {
        match pc {
            0x82ED6630 => {
    //   block [0x82ED6630..0x82ED6654)
	// 82ED6630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED6634: 4BDD2DD9  bl 0x82ca940c
	ctx.lr = 0x82ED6638;
	sub_82CA93D0(ctx, base);
	// 82ED6638: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED663C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82ED6640: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ED6644: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82ED6648: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED664C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED6650: 40990044  ble cr6, 0x82ed6694
	if !ctx.cr[6].gt {
	pc = 0x82ED6694; continue 'dispatch;
	}
	pc = 0x82ED6654; continue 'dispatch;
            }
            0x82ED6654 => {
    //   block [0x82ED6654..0x82ED6684)
	// 82ED6654: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED6658: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ED665C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED6660: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED6664: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED6668: 4E800421  bctrl
	ctx.lr = 0x82ED666C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED666C: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED6670: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82ED6674: 409A0010  bne cr6, 0x82ed6684
	if !ctx.cr[6].eq {
	pc = 0x82ED6684; continue 'dispatch;
	}
	// 82ED6678: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED667C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82ED6680: 409A0020  bne cr6, 0x82ed66a0
	if !ctx.cr[6].eq {
	pc = 0x82ED66A0; continue 'dispatch;
	}
            }
            0x82ED6684 => {
    //   block [0x82ED6684..0x82ED6694)
	// 82ED6684: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED6688: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82ED668C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED6690: 4198FFC4  blt cr6, 0x82ed6654
	if ctx.cr[6].lt {
	pc = 0x82ED6654; continue 'dispatch;
	}
	pc = 0x82ED6694; continue 'dispatch;
            }
            0x82ED6694 => {
    //   block [0x82ED6694..0x82ED6698)
	// 82ED6694: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82ED6698; continue 'dispatch;
            }
            0x82ED6698 => {
    //   block [0x82ED6698..0x82ED66A0)
	// 82ED6698: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ED669C: 4BDD2DC0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82ED66A0 => {
    //   block [0x82ED66A0..0x82ED66A8)
	// 82ED66A0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82ED66A4: 4BFFFFF4  b 0x82ed6698
	pc = 0x82ED6698; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED66A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED66A8 size=136
    let mut pc: u32 = 0x82ED66A8;
    'dispatch: loop {
        match pc {
            0x82ED66A8 => {
    //   block [0x82ED66A8..0x82ED66CC)
	// 82ED66A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED66AC: 4BDD2D61  bl 0x82ca940c
	ctx.lr = 0x82ED66B0;
	sub_82CA93D0(ctx, base);
	// 82ED66B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED66B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED66B8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ED66BC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ED66C0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED66C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED66C8: 40990060  ble cr6, 0x82ed6728
	if !ctx.cr[6].gt {
	pc = 0x82ED6728; continue 'dispatch;
	}
	pc = 0x82ED66CC; continue 'dispatch;
            }
            0x82ED66CC => {
    //   block [0x82ED66CC..0x82ED6718)
	// 82ED66CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED66D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ED66D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED66D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED66DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED66E0: 4E800421  bctrl
	ctx.lr = 0x82ED66E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED66E4: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED66E8: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82ED66EC: 409A002C  bne cr6, 0x82ed6718
	if !ctx.cr[6].eq {
	pc = 0x82ED6718; continue 'dispatch;
	}
	// 82ED66F0: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82ED66F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED66F8: 419A0020  beq cr6, 0x82ed6718
	if ctx.cr[6].eq {
	pc = 0x82ED6718; continue 'dispatch;
	}
	// 82ED66FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED6700: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 82ED6704: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ED6708: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED670C: 91430010  stw r10, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82ED6710: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED6714: 4E800421  bctrl
	ctx.lr = 0x82ED6718;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED6718 => {
    //   block [0x82ED6718..0x82ED6728)
	// 82ED6718: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED671C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82ED6720: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED6724: 4198FFA8  blt cr6, 0x82ed66cc
	if ctx.cr[6].lt {
	pc = 0x82ED66CC; continue 'dispatch;
	}
	pc = 0x82ED6728; continue 'dispatch;
            }
            0x82ED6728 => {
    //   block [0x82ED6728..0x82ED6730)
	// 82ED6728: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ED672C: 4BDD2D30  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED6730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED6730 size=136
    let mut pc: u32 = 0x82ED6730;
    'dispatch: loop {
        match pc {
            0x82ED6730 => {
    //   block [0x82ED6730..0x82ED6754)
	// 82ED6730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED6734: 4BDD2CD9  bl 0x82ca940c
	ctx.lr = 0x82ED6738;
	sub_82CA93D0(ctx, base);
	// 82ED6738: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED673C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED6740: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82ED6744: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ED6748: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED674C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED6750: 4099005C  ble cr6, 0x82ed67ac
	if !ctx.cr[6].gt {
	pc = 0x82ED67AC; continue 'dispatch;
	}
	pc = 0x82ED6754; continue 'dispatch;
            }
            0x82ED6754 => {
    //   block [0x82ED6754..0x82ED679C)
	// 82ED6754: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED6758: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ED675C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED6760: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED6764: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED6768: 4E800421  bctrl
	ctx.lr = 0x82ED676C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED676C: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED6770: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED6774: 41820028  beq 0x82ed679c
	if ctx.cr[0].eq {
	pc = 0x82ED679C; continue 'dispatch;
	}
	// 82ED6778: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED677C: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82ED6780: 409A001C  bne cr6, 0x82ed679c
	if !ctx.cr[6].eq {
	pc = 0x82ED679C; continue 'dispatch;
	}
	// 82ED6784: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED6788: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED678C: 409A0024  bne cr6, 0x82ed67b0
	if !ctx.cr[6].eq {
	pc = 0x82ED67B0; continue 'dispatch;
	}
	// 82ED6790: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED6794: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 82ED6798: 419A0018  beq cr6, 0x82ed67b0
	if ctx.cr[6].eq {
	pc = 0x82ED67B0; continue 'dispatch;
	}
            }
            0x82ED679C => {
    //   block [0x82ED679C..0x82ED67AC)
	// 82ED679C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED67A0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82ED67A4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED67A8: 4198FFAC  blt cr6, 0x82ed6754
	if ctx.cr[6].lt {
	pc = 0x82ED6754; continue 'dispatch;
	}
	pc = 0x82ED67AC; continue 'dispatch;
            }
            0x82ED67AC => {
    //   block [0x82ED67AC..0x82ED67B0)
	// 82ED67AC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82ED67B0; continue 'dispatch;
            }
            0x82ED67B0 => {
    //   block [0x82ED67B0..0x82ED67B8)
	// 82ED67B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ED67B4: 4BDD2CA8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED67B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED67B8 size=184
    let mut pc: u32 = 0x82ED67B8;
    'dispatch: loop {
        match pc {
            0x82ED67B8 => {
    //   block [0x82ED67B8..0x82ED67EC)
	// 82ED67B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED67BC: 4BDD2C4D  bl 0x82ca9408
	ctx.lr = 0x82ED67C0;
	sub_82CA93D0(ctx, base);
	// 82ED67C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED67C4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82ED67C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED67CC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ED67D0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82ED67D4: 419A0018  beq cr6, 0x82ed67ec
	if ctx.cr[6].eq {
	pc = 0x82ED67EC; continue 'dispatch;
	}
	// 82ED67D8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED67DC: 7C6BE1D6  mullw r3, r11, r28
	ctx.r[3].s32 = ((ctx.r[11].s32 as i64 * ctx.r[28].s32 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82ED67E0: 4B740149  bl 0x82616928
	ctx.lr = 0x82ED67E4;
	sub_82616928(ctx, base);
	// 82ED67E4: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82ED67E8: 48000008  b 0x82ed67f0
	pc = 0x82ED67F0; continue 'dispatch;
            }
            0x82ED67EC => {
    //   block [0x82ED67EC..0x82ED67F0)
	// 82ED67EC: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	pc = 0x82ED67F0; continue 'dispatch;
            }
            0x82ED67F0 => {
    //   block [0x82ED67F0..0x82ED6800)
	// 82ED67F0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED67F4: 83BF0004  lwz r29, 4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED67F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED67FC: 40990068  ble cr6, 0x82ed6864
	if !ctx.cr[6].gt {
	pc = 0x82ED6864; continue 'dispatch;
	}
	pc = 0x82ED6800; continue 'dispatch;
            }
            0x82ED6800 => {
    //   block [0x82ED6800..0x82ED6854)
	// 82ED6800: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED6804: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ED6808: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED680C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED6810: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED6814: 4E800421  bctrl
	ctx.lr = 0x82ED6818;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED6818: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82ED681C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ED6820: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED6824: 93AB0014  stw r29, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 82ED6828: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED682C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED6830: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED6834: 4E800421  bctrl
	ctx.lr = 0x82ED6838;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED6838: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED683C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED6840: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED6844: 4E800421  bctrl
	ctx.lr = 0x82ED6848;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED6848: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82ED684C: 419A0008  beq cr6, 0x82ed6854
	if ctx.cr[6].eq {
	pc = 0x82ED6854; continue 'dispatch;
	}
	// 82ED6850: 7FBDE214  add r29, r29, r28
	ctx.r[29].u64 = ctx.r[29].u64 + ctx.r[28].u64;
            }
            0x82ED6854 => {
    //   block [0x82ED6854..0x82ED6864)
	// 82ED6854: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED6858: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82ED685C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED6860: 4198FFA0  blt cr6, 0x82ed6800
	if ctx.cr[6].lt {
	pc = 0x82ED6800; continue 'dispatch;
	}
	pc = 0x82ED6864; continue 'dispatch;
            }
            0x82ED6864 => {
    //   block [0x82ED6864..0x82ED6870)
	// 82ED6864: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED6868: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ED686C: 4BDD2BEC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED6870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED6870 size=88
    let mut pc: u32 = 0x82ED6870;
    'dispatch: loop {
        match pc {
            0x82ED6870 => {
    //   block [0x82ED6870..0x82ED68AC)
	// 82ED6870: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED6874: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED6878: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED687C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED6880: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED6884: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED6888: 396BBAA8  addi r11, r11, -0x4558
	ctx.r[11].s64 = ctx.r[11].s64 + -17752;
	// 82ED688C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED6890: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED6894: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ED6898: 41820014  beq 0x82ed68ac
	if ctx.cr[0].eq {
	pc = 0x82ED68AC; continue 'dispatch;
	}
	// 82ED689C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ED68A0: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ED68A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED68A8: 4E800421  bctrl
	ctx.lr = 0x82ED68AC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED68AC => {
    //   block [0x82ED68AC..0x82ED68C8)
	// 82ED68AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ED68B0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82ED68B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ED68B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED68BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED68C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED68C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED68C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED68C8 size=12
    let mut pc: u32 = 0x82ED68C8;
    'dispatch: loop {
        match pc {
            0x82ED68C8 => {
    //   block [0x82ED68C8..0x82ED68D4)
	// 82ED68C8: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ED68CC: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED68D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED68D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED68D8 size=12
    let mut pc: u32 = 0x82ED68D8;
    'dispatch: loop {
        match pc {
            0x82ED68D8 => {
    //   block [0x82ED68D8..0x82ED68E4)
	// 82ED68D8: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ED68DC: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED68E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED68E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED68E8 size=140
    let mut pc: u32 = 0x82ED68E8;
    'dispatch: loop {
        match pc {
            0x82ED68E8 => {
    //   block [0x82ED68E8..0x82ED6948)
	// 82ED68E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED68EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED68F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ED68F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED68F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED68FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED6900: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82ED6904: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ED6908: 394ABAC8  addi r10, r10, -0x4538
	ctx.r[10].s64 = ctx.r[10].s64 + -17720;
	// 82ED690C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED6910: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED6914: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ED6918: 41820038  beq 0x82ed6950
	if ctx.cr[0].eq {
	pc = 0x82ED6950; continue 'dispatch;
	}
	// 82ED691C: 814BFFFC  lwz r10, -4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82ED6920: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82ED6924: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ED6928: 419A0020  beq cr6, 0x82ed6948
	if ctx.cr[6].eq {
	pc = 0x82ED6948; continue 'dispatch;
	}
	// 82ED692C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED6930: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82ED6934: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82ED6938: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED693C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED6940: 4E800421  bctrl
	ctx.lr = 0x82ED6944;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED6944: 48000008  b 0x82ed694c
	pc = 0x82ED694C; continue 'dispatch;
            }
            0x82ED6948 => {
    //   block [0x82ED6948..0x82ED694C)
	// 82ED6948: 4B96EE69  bl 0x828457b0
	ctx.lr = 0x82ED694C;
	sub_828457B0(ctx, base);
	pc = 0x82ED694C; continue 'dispatch;
            }
            0x82ED694C => {
    //   block [0x82ED694C..0x82ED6950)
	// 82ED694C: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	pc = 0x82ED6950; continue 'dispatch;
            }
            0x82ED6950 => {
    //   block [0x82ED6950..0x82ED6974)
	// 82ED6950: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED6954: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82ED6958: 4BFFFF19  bl 0x82ed6870
	ctx.lr = 0x82ED695C;
	sub_82ED6870(ctx, base);
	// 82ED695C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ED6960: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED6964: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED6968: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ED696C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED6970: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED6978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED6978 size=16
    let mut pc: u32 = 0x82ED6978;
    'dispatch: loop {
        match pc {
            0x82ED6978 => {
    //   block [0x82ED6978..0x82ED6988)
	// 82ED6978: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED697C: 1D64003C  mulli r11, r4, 0x3c
	ctx.r[11].s32 = ((ctx.r[4].s32 as i64 * 60 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82ED6980: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ED6984: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED6988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED6988 size=140
    let mut pc: u32 = 0x82ED6988;
    'dispatch: loop {
        match pc {
            0x82ED6988 => {
    //   block [0x82ED6988..0x82ED69E8)
	// 82ED6988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED698C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED6990: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ED6994: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED6998: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED699C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED69A0: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82ED69A4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ED69A8: 394ABAE8  addi r10, r10, -0x4518
	ctx.r[10].s64 = ctx.r[10].s64 + -17688;
	// 82ED69AC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED69B0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED69B4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82ED69B8: 41820038  beq 0x82ed69f0
	if ctx.cr[0].eq {
	pc = 0x82ED69F0; continue 'dispatch;
	}
	// 82ED69BC: 814BFFFC  lwz r10, -4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82ED69C0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82ED69C4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ED69C8: 419A0020  beq cr6, 0x82ed69e8
	if ctx.cr[6].eq {
	pc = 0x82ED69E8; continue 'dispatch;
	}
	// 82ED69CC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED69D0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82ED69D4: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82ED69D8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED69DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED69E0: 4E800421  bctrl
	ctx.lr = 0x82ED69E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED69E4: 48000008  b 0x82ed69ec
	pc = 0x82ED69EC; continue 'dispatch;
            }
            0x82ED69E8 => {
    //   block [0x82ED69E8..0x82ED69EC)
	// 82ED69E8: 4B96EDC9  bl 0x828457b0
	ctx.lr = 0x82ED69EC;
	sub_828457B0(ctx, base);
	pc = 0x82ED69EC; continue 'dispatch;
            }
            0x82ED69EC => {
    //   block [0x82ED69EC..0x82ED69F0)
	// 82ED69EC: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	pc = 0x82ED69F0; continue 'dispatch;
            }
            0x82ED69F0 => {
    //   block [0x82ED69F0..0x82ED6A14)
	// 82ED69F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED69F4: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82ED69F8: 4BFFFE79  bl 0x82ed6870
	ctx.lr = 0x82ED69FC;
	sub_82ED6870(ctx, base);
	// 82ED69FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ED6A00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED6A04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED6A08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ED6A0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED6A10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED6A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED6A18 size=16
    let mut pc: u32 = 0x82ED6A18;
    'dispatch: loop {
        match pc {
            0x82ED6A18 => {
    //   block [0x82ED6A18..0x82ED6A28)
	// 82ED6A18: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED6A1C: 548B3032  slwi r11, r4, 6
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED6A20: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ED6A24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED6A28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED6A28 size=88
    let mut pc: u32 = 0x82ED6A28;
    'dispatch: loop {
        match pc {
            0x82ED6A28 => {
    //   block [0x82ED6A28..0x82ED6A64)
	// 82ED6A28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED6A2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED6A30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ED6A34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED6A38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED6A3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED6A40: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ED6A44: 4BFFFE2D  bl 0x82ed6870
	ctx.lr = 0x82ED6A48;
	sub_82ED6870(ctx, base);
	// 82ED6A48: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED6A4C: 41820018  beq 0x82ed6a64
	if ctx.cr[0].eq {
	pc = 0x82ED6A64; continue 'dispatch;
	}
	// 82ED6A50: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ED6A54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED6A58: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ED6A5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED6A60: 4E800421  bctrl
	ctx.lr = 0x82ED6A64;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED6A64 => {
    //   block [0x82ED6A64..0x82ED6A80)
	// 82ED6A64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED6A68: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ED6A6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED6A70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED6A74: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ED6A78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED6A7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED6A80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED6A80 size=300
    let mut pc: u32 = 0x82ED6A80;
    'dispatch: loop {
        match pc {
            0x82ED6A80 => {
    //   block [0x82ED6A80..0x82ED6ACC)
	// 82ED6A80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED6A84: 4BDD2981  bl 0x82ca9404
	ctx.lr = 0x82ED6A88;
	sub_82CA93D0(ctx, base);
	// 82ED6A88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED6A8C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED6A90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED6A94: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ED6A98: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82ED6A9C: 396BBAC8  addi r11, r11, -0x4538
	ctx.r[11].s64 = ctx.r[11].s64 + -17720;
	// 82ED6AA0: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82ED6AA4: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82ED6AA8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82ED6AAC: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82ED6AB0: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82ED6AB4: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82ED6AB8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ED6ABC: 409A0010  bne cr6, 0x82ed6acc
	if !ctx.cr[6].eq {
	pc = 0x82ED6ACC; continue 'dispatch;
	}
	// 82ED6AC0: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82ED6AC4: 4B4136F5  bl 0x822ea1b8
	ctx.lr = 0x82ED6AC8;
	sub_822EA1B8(ctx, base);
	// 82ED6AC8: 48000034  b 0x82ed6afc
	pc = 0x82ED6AFC; continue 'dispatch;
            }
            0x82ED6ACC => {
    //   block [0x82ED6ACC..0x82ED6AE8)
	// 82ED6ACC: 3D600444  lis r11, 0x444
	ctx.r[11].s64 = 71565312;
	// 82ED6AD0: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82ED6AD4: 616B4444  ori r11, r11, 0x4444
	ctx.r[11].u64 = ctx.r[11].u64 | 17476;
	// 82ED6AD8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED6ADC: 1D7E003C  mulli r11, r30, 0x3c
	ctx.r[11].s32 = ((ctx.r[30].s32 as i64 * 60 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82ED6AE0: 40990008  ble cr6, 0x82ed6ae8
	if !ctx.cr[6].gt {
	pc = 0x82ED6AE8; continue 'dispatch;
	}
	// 82ED6AE4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x82ED6AE8; continue 'dispatch;
            }
            0x82ED6AE8 => {
    //   block [0x82ED6AE8..0x82ED6AF8)
	// 82ED6AE8: 3940FFFB  li r10, -5
	ctx.r[10].s64 = -5;
	// 82ED6AEC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ED6AF0: 41990008  bgt cr6, 0x82ed6af8
	if ctx.cr[6].gt {
	pc = 0x82ED6AF8; continue 'dispatch;
	}
	// 82ED6AF4: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	pc = 0x82ED6AF8; continue 'dispatch;
            }
            0x82ED6AF8 => {
    //   block [0x82ED6AF8..0x82ED6AFC)
	// 82ED6AF8: 4B73FE31  bl 0x82616928
	ctx.lr = 0x82ED6AFC;
	sub_82616928(ctx, base);
	pc = 0x82ED6AFC; continue 'dispatch;
            }
            0x82ED6AFC => {
    //   block [0x82ED6AFC..0x82ED6B20)
	// 82ED6AFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ED6B00: 419A004C  beq cr6, 0x82ed6b4c
	if ctx.cr[6].eq {
	pc = 0x82ED6B4C; continue 'dispatch;
	}
	// 82ED6B04: 39030004  addi r8, r3, 4
	ctx.r[8].s64 = ctx.r[3].s64 + 4;
	// 82ED6B08: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82ED6B0C: 355EFFFF  addic. r10, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ED6B10: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 82ED6B14: 41800030  blt 0x82ed6b44
	if ctx.cr[0].lt {
	pc = 0x82ED6B44; continue 'dispatch;
	}
	// 82ED6B18: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82ED6B1C: 3929BAB0  addi r9, r9, -0x4550
	ctx.r[9].s64 = ctx.r[9].s64 + -17744;
	pc = 0x82ED6B20; continue 'dispatch;
            }
            0x82ED6B20 => {
    //   block [0x82ED6B20..0x82ED6B44)
	// 82ED6B20: 93AB000C  stw r29, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82ED6B24: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ED6B28: 93AB0010  stw r29, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 82ED6B2C: 93AB001C  stw r29, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 82ED6B30: 93AB0020  stw r29, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u32 ) };
	// 82ED6B34: 9BAB0008  stb r29, 8(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[29].u8 ) };
	// 82ED6B38: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ED6B3C: 396B003C  addi r11, r11, 0x3c
	ctx.r[11].s64 = ctx.r[11].s64 + 60;
	// 82ED6B40: 4080FFE0  bge 0x82ed6b20
	if !ctx.cr[0].lt {
	pc = 0x82ED6B20; continue 'dispatch;
	}
	pc = 0x82ED6B44; continue 'dispatch;
            }
            0x82ED6B44 => {
    //   block [0x82ED6B44..0x82ED6B4C)
	// 82ED6B44: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 82ED6B48: 48000008  b 0x82ed6b50
	pc = 0x82ED6B50; continue 'dispatch;
            }
            0x82ED6B4C => {
    //   block [0x82ED6B4C..0x82ED6B50)
	// 82ED6B4C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82ED6B50; continue 'dispatch;
            }
            0x82ED6B50 => {
    //   block [0x82ED6B50..0x82ED6B68)
	// 82ED6B50: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED6B54: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82ED6B58: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82ED6B5C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82ED6B60: 40990034  ble cr6, 0x82ed6b94
	if !ctx.cr[6].gt {
	pc = 0x82ED6B94; continue 'dispatch;
	}
	// 82ED6B64: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82ED6B68; continue 'dispatch;
            }
            0x82ED6B68 => {
    //   block [0x82ED6B68..0x82ED6B94)
	// 82ED6B68: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED6B6C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ED6B70: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82ED6B74: 93890018  stw r28, 0x18(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[28].u32 ) };
	// 82ED6B78: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED6B7C: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82ED6B80: 396B003C  addi r11, r11, 0x3c
	ctx.r[11].s64 = ctx.r[11].s64 + 60;
	// 82ED6B84: 93690004  stw r27, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82ED6B88: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED6B8C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82ED6B90: 4198FFD8  blt cr6, 0x82ed6b68
	if ctx.cr[6].lt {
	pc = 0x82ED6B68; continue 'dispatch;
	}
	pc = 0x82ED6B94; continue 'dispatch;
            }
            0x82ED6B94 => {
    //   block [0x82ED6B94..0x82ED6BAC)
	// 82ED6B94: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82ED6B98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED6B9C: 4BFFFC1D  bl 0x82ed67b8
	ctx.lr = 0x82ED6BA0;
	sub_82ED67B8(ctx, base);
	// 82ED6BA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED6BA4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ED6BA8: 4BDD28AC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED6BB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED6BB0 size=88
    let mut pc: u32 = 0x82ED6BB0;
    'dispatch: loop {
        match pc {
            0x82ED6BB0 => {
    //   block [0x82ED6BB0..0x82ED6BEC)
	// 82ED6BB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED6BB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED6BB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ED6BBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED6BC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED6BC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED6BC8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ED6BCC: 4BFFFD1D  bl 0x82ed68e8
	ctx.lr = 0x82ED6BD0;
	sub_82ED68E8(ctx, base);
	// 82ED6BD0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED6BD4: 41820018  beq 0x82ed6bec
	if ctx.cr[0].eq {
	pc = 0x82ED6BEC; continue 'dispatch;
	}
	// 82ED6BD8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ED6BDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED6BE0: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ED6BE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED6BE8: 4E800421  bctrl
	ctx.lr = 0x82ED6BEC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED6BEC => {
    //   block [0x82ED6BEC..0x82ED6C08)
	// 82ED6BEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED6BF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ED6BF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED6BF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED6BFC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ED6C00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED6C04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED6C08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED6C08 size=184
    let mut pc: u32 = 0x82ED6C08;
    'dispatch: loop {
        match pc {
            0x82ED6C08 => {
    //   block [0x82ED6C08..0x82ED6C48)
	// 82ED6C08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED6C0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED6C10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ED6C14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED6C18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED6C1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED6C20: 548B07BD  rlwinm. r11, r4, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED6C24: 41820058  beq 0x82ed6c7c
	if ctx.cr[0].eq {
	pc = 0x82ED6C7C; continue 'dispatch;
	}
	// 82ED6C28: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82ED6C2C: 3BDFFFFC  addi r30, r31, -4
	ctx.r[30].s64 = ctx.r[31].s64 + -4;
	// 82ED6C30: 1D4B003C  mulli r10, r11, 0x3c
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 60 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82ED6C34: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED6C38: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82ED6C3C: 4180001C  blt 0x82ed6c58
	if ctx.cr[0].lt {
	pc = 0x82ED6C58; continue 'dispatch;
	}
	// 82ED6C40: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82ED6C44: 3929BA90  addi r9, r9, -0x4570
	ctx.r[9].s64 = ctx.r[9].s64 + -17776;
	pc = 0x82ED6C48; continue 'dispatch;
            }
            0x82ED6C48 => {
    //   block [0x82ED6C48..0x82ED6C58)
	// 82ED6C48: 394AFFC4  addi r10, r10, -0x3c
	ctx.r[10].s64 = ctx.r[10].s64 + -60;
	// 82ED6C4C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED6C50: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ED6C54: 4080FFF4  bge 0x82ed6c48
	if !ctx.cr[0].lt {
	pc = 0x82ED6C48; continue 'dispatch;
	}
	pc = 0x82ED6C58; continue 'dispatch;
            }
            0x82ED6C58 => {
    //   block [0x82ED6C58..0x82ED6C74)
	// 82ED6C58: 548B07FF  clrlwi. r11, r4, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED6C5C: 41820018  beq 0x82ed6c74
	if ctx.cr[0].eq {
	pc = 0x82ED6C74; continue 'dispatch;
	}
	// 82ED6C60: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ED6C64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED6C68: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ED6C6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED6C70: 4E800421  bctrl
	ctx.lr = 0x82ED6C74;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED6C74 => {
    //   block [0x82ED6C74..0x82ED6C7C)
	// 82ED6C74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED6C78: 48000030  b 0x82ed6ca8
	pc = 0x82ED6CA8; continue 'dispatch;
            }
            0x82ED6C7C => {
    //   block [0x82ED6C7C..0x82ED6CA4)
	// 82ED6C7C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED6C80: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ED6C84: 396BBA90  addi r11, r11, -0x4570
	ctx.r[11].s64 = ctx.r[11].s64 + -17776;
	// 82ED6C88: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ED6C8C: 41820018  beq 0x82ed6ca4
	if ctx.cr[0].eq {
	pc = 0x82ED6CA4; continue 'dispatch;
	}
	// 82ED6C90: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ED6C94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED6C98: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ED6C9C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED6CA0: 4E800421  bctrl
	ctx.lr = 0x82ED6CA4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED6CA4 => {
    //   block [0x82ED6CA4..0x82ED6CA8)
	// 82ED6CA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82ED6CA8; continue 'dispatch;
            }
            0x82ED6CA8 => {
    //   block [0x82ED6CA8..0x82ED6CC0)
	// 82ED6CA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ED6CAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED6CB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED6CB4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ED6CB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED6CBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED6CC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED6CC0 size=300
    let mut pc: u32 = 0x82ED6CC0;
    'dispatch: loop {
        match pc {
            0x82ED6CC0 => {
    //   block [0x82ED6CC0..0x82ED6D0C)
	// 82ED6CC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED6CC4: 4BDD2741  bl 0x82ca9404
	ctx.lr = 0x82ED6CC8;
	sub_82CA93D0(ctx, base);
	// 82ED6CC8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED6CCC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED6CD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED6CD4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ED6CD8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82ED6CDC: 396BBAE8  addi r11, r11, -0x4518
	ctx.r[11].s64 = ctx.r[11].s64 + -17688;
	// 82ED6CE0: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82ED6CE4: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82ED6CE8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82ED6CEC: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82ED6CF0: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82ED6CF4: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82ED6CF8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ED6CFC: 409A0010  bne cr6, 0x82ed6d0c
	if !ctx.cr[6].eq {
	pc = 0x82ED6D0C; continue 'dispatch;
	}
	// 82ED6D00: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82ED6D04: 4B4134B5  bl 0x822ea1b8
	ctx.lr = 0x82ED6D08;
	sub_822EA1B8(ctx, base);
	// 82ED6D08: 48000034  b 0x82ed6d3c
	pc = 0x82ED6D3C; continue 'dispatch;
            }
            0x82ED6D0C => {
    //   block [0x82ED6D0C..0x82ED6D28)
	// 82ED6D0C: 3D6003FF  lis r11, 0x3ff
	ctx.r[11].s64 = 67043328;
	// 82ED6D10: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82ED6D14: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 82ED6D18: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED6D1C: 57CB3032  slwi r11, r30, 6
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED6D20: 40990008  ble cr6, 0x82ed6d28
	if !ctx.cr[6].gt {
	pc = 0x82ED6D28; continue 'dispatch;
	}
	// 82ED6D24: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x82ED6D28; continue 'dispatch;
            }
            0x82ED6D28 => {
    //   block [0x82ED6D28..0x82ED6D38)
	// 82ED6D28: 3940FFFB  li r10, -5
	ctx.r[10].s64 = -5;
	// 82ED6D2C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82ED6D30: 41990008  bgt cr6, 0x82ed6d38
	if ctx.cr[6].gt {
	pc = 0x82ED6D38; continue 'dispatch;
	}
	// 82ED6D34: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	pc = 0x82ED6D38; continue 'dispatch;
            }
            0x82ED6D38 => {
    //   block [0x82ED6D38..0x82ED6D3C)
	// 82ED6D38: 4B73FBF1  bl 0x82616928
	ctx.lr = 0x82ED6D3C;
	sub_82616928(ctx, base);
	pc = 0x82ED6D3C; continue 'dispatch;
            }
            0x82ED6D3C => {
    //   block [0x82ED6D3C..0x82ED6D60)
	// 82ED6D3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82ED6D40: 419A004C  beq cr6, 0x82ed6d8c
	if ctx.cr[6].eq {
	pc = 0x82ED6D8C; continue 'dispatch;
	}
	// 82ED6D44: 39030004  addi r8, r3, 4
	ctx.r[8].s64 = ctx.r[3].s64 + 4;
	// 82ED6D48: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82ED6D4C: 355EFFFF  addic. r10, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ED6D50: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 82ED6D54: 41800030  blt 0x82ed6d84
	if ctx.cr[0].lt {
	pc = 0x82ED6D84; continue 'dispatch;
	}
	// 82ED6D58: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82ED6D5C: 3929BAD0  addi r9, r9, -0x4530
	ctx.r[9].s64 = ctx.r[9].s64 + -17712;
	pc = 0x82ED6D60; continue 'dispatch;
            }
            0x82ED6D60 => {
    //   block [0x82ED6D60..0x82ED6D84)
	// 82ED6D60: 93AB000C  stw r29, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82ED6D64: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ED6D68: 93AB0010  stw r29, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 82ED6D6C: 93AB001C  stw r29, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 82ED6D70: 93AB0020  stw r29, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u32 ) };
	// 82ED6D74: 9BAB0008  stb r29, 8(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[29].u8 ) };
	// 82ED6D78: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ED6D7C: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 82ED6D80: 4080FFE0  bge 0x82ed6d60
	if !ctx.cr[0].lt {
	pc = 0x82ED6D60; continue 'dispatch;
	}
	pc = 0x82ED6D84; continue 'dispatch;
            }
            0x82ED6D84 => {
    //   block [0x82ED6D84..0x82ED6D8C)
	// 82ED6D84: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 82ED6D88: 48000008  b 0x82ed6d90
	pc = 0x82ED6D90; continue 'dispatch;
            }
            0x82ED6D8C => {
    //   block [0x82ED6D8C..0x82ED6D90)
	// 82ED6D8C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82ED6D90; continue 'dispatch;
            }
            0x82ED6D90 => {
    //   block [0x82ED6D90..0x82ED6DA8)
	// 82ED6D90: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED6D94: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82ED6D98: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82ED6D9C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82ED6DA0: 40990034  ble cr6, 0x82ed6dd4
	if !ctx.cr[6].gt {
	pc = 0x82ED6DD4; continue 'dispatch;
	}
	// 82ED6DA4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82ED6DA8; continue 'dispatch;
            }
            0x82ED6DA8 => {
    //   block [0x82ED6DA8..0x82ED6DD4)
	// 82ED6DA8: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED6DAC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82ED6DB0: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82ED6DB4: 93890018  stw r28, 0x18(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[28].u32 ) };
	// 82ED6DB8: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED6DBC: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82ED6DC0: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 82ED6DC4: 93690004  stw r27, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82ED6DC8: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82ED6DCC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82ED6DD0: 4198FFD8  blt cr6, 0x82ed6da8
	if ctx.cr[6].lt {
	pc = 0x82ED6DA8; continue 'dispatch;
	}
	pc = 0x82ED6DD4; continue 'dispatch;
            }
            0x82ED6DD4 => {
    //   block [0x82ED6DD4..0x82ED6DEC)
	// 82ED6DD4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82ED6DD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED6DDC: 4BFFF9DD  bl 0x82ed67b8
	ctx.lr = 0x82ED6DE0;
	sub_82ED67B8(ctx, base);
	// 82ED6DE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED6DE4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ED6DE8: 4BDD266C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED6DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED6DF0 size=88
    let mut pc: u32 = 0x82ED6DF0;
    'dispatch: loop {
        match pc {
            0x82ED6DF0 => {
    //   block [0x82ED6DF0..0x82ED6E2C)
	// 82ED6DF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED6DF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED6DF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ED6DFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED6E00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED6E04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED6E08: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ED6E0C: 4BFFFB7D  bl 0x82ed6988
	ctx.lr = 0x82ED6E10;
	sub_82ED6988(ctx, base);
	// 82ED6E10: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED6E14: 41820018  beq 0x82ed6e2c
	if ctx.cr[0].eq {
	pc = 0x82ED6E2C; continue 'dispatch;
	}
	// 82ED6E18: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ED6E1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED6E20: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ED6E24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED6E28: 4E800421  bctrl
	ctx.lr = 0x82ED6E2C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED6E2C => {
    //   block [0x82ED6E2C..0x82ED6E48)
	// 82ED6E2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED6E30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ED6E34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED6E38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED6E3C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ED6E40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED6E44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED6E48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED6E48 size=184
    let mut pc: u32 = 0x82ED6E48;
    'dispatch: loop {
        match pc {
            0x82ED6E48 => {
    //   block [0x82ED6E48..0x82ED6E88)
	// 82ED6E48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED6E4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED6E50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ED6E54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED6E58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED6E5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED6E60: 548B07BD  rlwinm. r11, r4, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED6E64: 41820058  beq 0x82ed6ebc
	if ctx.cr[0].eq {
	pc = 0x82ED6EBC; continue 'dispatch;
	}
	// 82ED6E68: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82ED6E6C: 3BDFFFFC  addi r30, r31, -4
	ctx.r[30].s64 = ctx.r[31].s64 + -4;
	// 82ED6E70: 556A3032  slwi r10, r11, 6
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ED6E74: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED6E78: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82ED6E7C: 4180001C  blt 0x82ed6e98
	if ctx.cr[0].lt {
	pc = 0x82ED6E98; continue 'dispatch;
	}
	// 82ED6E80: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82ED6E84: 3929BA90  addi r9, r9, -0x4570
	ctx.r[9].s64 = ctx.r[9].s64 + -17776;
	pc = 0x82ED6E88; continue 'dispatch;
            }
            0x82ED6E88 => {
    //   block [0x82ED6E88..0x82ED6E98)
	// 82ED6E88: 394AFFC0  addi r10, r10, -0x40
	ctx.r[10].s64 = ctx.r[10].s64 + -64;
	// 82ED6E8C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED6E90: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82ED6E94: 4080FFF4  bge 0x82ed6e88
	if !ctx.cr[0].lt {
	pc = 0x82ED6E88; continue 'dispatch;
	}
	pc = 0x82ED6E98; continue 'dispatch;
            }
            0x82ED6E98 => {
    //   block [0x82ED6E98..0x82ED6EB4)
	// 82ED6E98: 548B07FF  clrlwi. r11, r4, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED6E9C: 41820018  beq 0x82ed6eb4
	if ctx.cr[0].eq {
	pc = 0x82ED6EB4; continue 'dispatch;
	}
	// 82ED6EA0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ED6EA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED6EA8: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ED6EAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED6EB0: 4E800421  bctrl
	ctx.lr = 0x82ED6EB4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED6EB4 => {
    //   block [0x82ED6EB4..0x82ED6EBC)
	// 82ED6EB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED6EB8: 48000030  b 0x82ed6ee8
	pc = 0x82ED6EE8; continue 'dispatch;
            }
            0x82ED6EBC => {
    //   block [0x82ED6EBC..0x82ED6EE4)
	// 82ED6EBC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED6EC0: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ED6EC4: 396BBA90  addi r11, r11, -0x4570
	ctx.r[11].s64 = ctx.r[11].s64 + -17776;
	// 82ED6EC8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ED6ECC: 41820018  beq 0x82ed6ee4
	if ctx.cr[0].eq {
	pc = 0x82ED6EE4; continue 'dispatch;
	}
	// 82ED6ED0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ED6ED4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED6ED8: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82ED6EDC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED6EE0: 4E800421  bctrl
	ctx.lr = 0x82ED6EE4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED6EE4 => {
    //   block [0x82ED6EE4..0x82ED6EE8)
	// 82ED6EE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82ED6EE8; continue 'dispatch;
            }
            0x82ED6EE8 => {
    //   block [0x82ED6EE8..0x82ED6F00)
	// 82ED6EE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ED6EEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED6EF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED6EF4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ED6EF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED6EFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED6F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ED6F00 size=628
    let mut pc: u32 = 0x82ED6F00;
    'dispatch: loop {
        match pc {
            0x82ED6F00 => {
    //   block [0x82ED6F00..0x82ED6F84)
	// 82ED6F00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED6F04: 4BDD2509  bl 0x82ca940c
	ctx.lr = 0x82ED6F08;
	sub_82CA93D0(ctx, base);
	// 82ED6F08: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82ED6F0C: 4BDD6DC5  bl 0x82cadcd0
	ctx.lr = 0x82ED6F10;
	sub_82CADCA0(ctx, base);
	// 82ED6F10: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED6F14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED6F18: C0040058  lfs f0, 0x58(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED6F1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED6F20: C1240054  lfs f9, 0x54(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82ED6F24: C0A40054  lfs f5, 0x54(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82ED6F28: C0E40034  lfs f7, 0x34(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82ED6F2C: C0C4003C  lfs f6, 0x3c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82ED6F30: C1BF00F8  lfs f13, 0xf8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED6F34: ED6D0072  fmuls f11, f13, f1
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[1].f64) as f32) as f64);
	// 82ED6F38: C18B0BFC  lfs f12, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED6F3C: EDA000B2  fmuls f13, f0, f2
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[2].f64) as f32) as f64);
	// 82ED6F40: C15F00A8  lfs f10, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82ED6F44: C11F00B0  lfs f8, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82ED6F48: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED6F4C: EF6B133C  fnmsubs f27, f11, f12, f2
	ctx.f[27].f64 = -(((ctx.f[11].f64 * ctx.f[12].f64 - ctx.f[2].f64) as f32) as f64);
	// 82ED6F50: C164004C  lfs f11, 0x4c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED6F54: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED6F58: EDA90372  fmuls f13, f9, f13
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED6F5C: C124004C  lfs f9, 0x4c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82ED6F60: ED4A0272  fmuls f10, f10, f9
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[9].f64) as f32) as f64);
	// 82ED6F64: C12B0C18  lfs f9, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82ED6F68: FF1B4800  fcmpu cr6, f27, f9
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[9].f64);
	// 82ED6F6C: ED45523A  fmadds f10, f5, f8, f10
	ctx.f[10].f64 = (((ctx.f[5].f64 * ctx.f[8].f64 + ctx.f[10].f64) as f32) as f64);
	// 82ED6F70: EF4A0032  fmuls f26, f10, f0
	ctx.f[26].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED6F74: EC07582A  fadds f0, f7, f11
	ctx.f[0].f64 = ((ctx.f[7].f64 + ctx.f[11].f64) as f32) as f64;
	// 82ED6F78: ED46682A  fadds f10, f6, f13
	ctx.f[10].f64 = ((ctx.f[6].f64 + ctx.f[13].f64) as f32) as f64;
	// 82ED6F7C: 40980008  bge cr6, 0x82ed6f84
	if !ctx.cr[6].lt {
	pc = 0x82ED6F84; continue 'dispatch;
	}
	// 82ED6F80: FF604890  fmr f27, f9
	ctx.f[27].f64 = ctx.f[9].f64;
	pc = 0x82ED6F84; continue 'dispatch;
            }
            0x82ED6F84 => {
    //   block [0x82ED6F84..0x82ED6FD4)
	// 82ED6F84: EDA10332  fmuls f13, f1, f12
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[12].f64) as f32) as f64);
	// 82ED6F88: C19F005C  lfs f12, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED6F8C: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82ED6F90: C11F0064  lfs f8, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82ED6F94: ED8A4028  fsubs f12, f10, f8
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[8].f64) as f32) as f64);
	// 82ED6F98: C15F0090  lfs f10, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82ED6F9C: C11F0098  lfs f8, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82ED6FA0: C17F0040  lfs f11, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED6FA4: EC0A0032  fmuls f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED6FA8: ED88033A  fmadds f12, f8, f12, f0
	ctx.f[12].f64 = (((ctx.f[8].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82ED6FAC: EC0C6828  fsubs f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82ED6FB0: EFED602A  fadds f31, f13, f12
	ctx.f[31].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82ED6FB4: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82ED6FB8: 419901AC  bgt cr6, 0x82ed7164
	if ctx.cr[6].gt {
	pc = 0x82ED7164; continue 'dispatch;
	}
	// 82ED6FBC: FDA05850  fneg f13, f11
	ctx.f[13].u64 = ctx.f[11].u64 ^ 0x8000_0000_0000_0000u64;
	// 82ED6FC0: FF1F6800  fcmpu cr6, f31, f13
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[13].f64);
	// 82ED6FC4: 419801A0  blt cr6, 0x82ed7164
	if ctx.cr[6].lt {
	pc = 0x82ED7164; continue 'dispatch;
	}
	// 82ED6FC8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED6FCC: 40980008  bge cr6, 0x82ed6fd4
	if !ctx.cr[6].lt {
	pc = 0x82ED6FD4; continue 'dispatch;
	}
	// 82ED6FD0: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82ED6FD4; continue 'dispatch;
            }
            0x82ED6FD4 => {
    //   block [0x82ED6FD4..0x82ED6FE0)
	// 82ED6FD4: FF1F5800  fcmpu cr6, f31, f11
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[11].f64);
	// 82ED6FD8: 40990008  ble cr6, 0x82ed6fe0
	if !ctx.cr[6].gt {
	pc = 0x82ED6FE0; continue 'dispatch;
	}
	// 82ED6FDC: FFE05890  fmr f31, f11
	ctx.f[31].f64 = ctx.f[11].f64;
	pc = 0x82ED6FE0; continue 'dispatch;
            }
            0x82ED6FE0 => {
    //   block [0x82ED6FE0..0x82ED705C)
	// 82ED6FE0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED6FE4: C38B0BE8  lfs f28, 0xbe8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3048 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82ED6FE8: FF1BE000  fcmpu cr6, f27, f28
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[28].f64);
	// 82ED6FEC: 40980148  bge cr6, 0x82ed7134
	if !ctx.cr[6].lt {
	pc = 0x82ED7134; continue 'dispatch;
	}
	// 82ED6FF0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED6FF4: C19F0070  lfs f12, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED6FF8: C17F0010  lfs f11, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED6FFC: C1ABBAF4  lfs f13, -0x450c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17676 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED7000: EFCC5B7A  fmadds f30, f12, f13, f11
	ctx.f[30].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 82ED7004: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82ED7008: 4199012C  bgt cr6, 0x82ed7134
	if ctx.cr[6].gt {
	pc = 0x82ED7134; continue 'dispatch;
	}
	// 82ED700C: FFA0F050  fneg f29, f30
	ctx.f[29].u64 = ctx.f[30].u64 ^ 0x8000_0000_0000_0000u64;
	// 82ED7010: FF1FE800  fcmpu cr6, f31, f29
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[29].f64);
	// 82ED7014: 41980120  blt cr6, 0x82ed7134
	if ctx.cr[6].lt {
	pc = 0x82ED7134; continue 'dispatch;
	}
	// 82ED7018: EDBF002A  fadds f13, f31, f0
	ctx.f[13].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	// 82ED701C: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ED7020: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED7024: FF0D4800  fcmpu cr6, f13, f9
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[9].f64);
	// 82ED7028: 40990088  ble cr6, 0x82ed70b0
	if !ctx.cr[6].gt {
	pc = 0x82ED70B0; continue 'dispatch;
	}
	// 82ED702C: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 82ED7030: 4199002C  bgt cr6, 0x82ed705c
	if ctx.cr[6].gt {
	pc = 0x82ED705C; continue 'dispatch;
	}
	// 82ED7034: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82ED7038: D00100F4  stfs f0, 0xf4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82ED703C: D3E100F8  stfs f31, 0xf8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82ED7040: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 82ED7044: D38100FC  stfs f28, 0xfc(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82ED7048: D3410100  stfs f26, 0x100(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82ED704C: 916100F0  stw r11, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 82ED7050: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ED7054: 99610104  stb r11, 0x104(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[11].u8 ) };
	// 82ED7058: 48000108  b 0x82ed7160
	pc = 0x82ED7160; continue 'dispatch;
            }
            0x82ED705C => {
    //   block [0x82ED705C..0x82ED70B0)
	// 82ED705C: 3BABAFB4  addi r29, r11, -0x504c
	ctx.r[29].s64 = ctx.r[11].s64 + -20556;
	// 82ED7060: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82ED7064: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ED7068: D3C10058  stfs f30, 0x58(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82ED706C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ED7070: D381005C  stfs f28, 0x5c(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82ED7074: D3410060  stfs f26, 0x60(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82ED7078: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82ED707C: 9BC10064  stb r30, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u8 ) };
	// 82ED7080: 48005DD9  bl 0x82edce58
	ctx.lr = 0x82ED7084;
	sub_82EDCE58(ctx, base);
	// 82ED7084: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82ED7088: D3C10094  stfs f30, 0x94(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82ED708C: D3E10098  stfs f31, 0x98(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82ED7090: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82ED7094: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82ED7098: D361009C  stfs f27, 0x9c(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82ED709C: D34100A0  stfs f26, 0xa0(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82ED70A0: 93A10090  stw r29, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[29].u32 ) };
	// 82ED70A4: 9BC100A4  stb r30, 0xa4(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[30].u8 ) };
	// 82ED70A8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82ED70AC: 480000B0  b 0x82ed715c
	pc = 0x82ED715C; continue 'dispatch;
            }
            0x82ED70B0 => {
    //   block [0x82ED70B0..0x82ED70E0)
	// 82ED70B0: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82ED70B4: 4198002C  blt cr6, 0x82ed70e0
	if ctx.cr[6].lt {
	pc = 0x82ED70E0; continue 'dispatch;
	}
	// 82ED70B8: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82ED70BC: D00100B4  stfs f0, 0xb4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82ED70C0: D3E100B8  stfs f31, 0xb8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82ED70C4: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82ED70C8: D38100BC  stfs f28, 0xbc(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82ED70CC: D34100C0  stfs f26, 0xc0(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82ED70D0: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82ED70D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ED70D8: 996100C4  stb r11, 0xc4(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[11].u8 ) };
	// 82ED70DC: 48000084  b 0x82ed7160
	pc = 0x82ED7160; continue 'dispatch;
            }
            0x82ED70E0 => {
    //   block [0x82ED70E0..0x82ED7134)
	// 82ED70E0: 3BABAFB4  addi r29, r11, -0x504c
	ctx.r[29].s64 = ctx.r[11].s64 + -20556;
	// 82ED70E4: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82ED70E8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ED70EC: D3A10078  stfs f29, 0x78(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82ED70F0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82ED70F4: D361007C  stfs f27, 0x7c(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82ED70F8: D3410080  stfs f26, 0x80(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82ED70FC: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82ED7100: 9BC10084  stb r30, 0x84(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u8 ) };
	// 82ED7104: 48005D55  bl 0x82edce58
	ctx.lr = 0x82ED7108;
	sub_82EDCE58(ctx, base);
	// 82ED7108: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82ED710C: D3A100D4  stfs f29, 0xd4(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82ED7110: D3E100D8  stfs f31, 0xd8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82ED7114: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 82ED7118: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82ED711C: D38100DC  stfs f28, 0xdc(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82ED7120: D34100E0  stfs f26, 0xe0(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82ED7124: 93A100D0  stw r29, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[29].u32 ) };
	// 82ED7128: 9BC100E4  stb r30, 0xe4(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[30].u8 ) };
	// 82ED712C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82ED7130: 4800002C  b 0x82ed715c
	pc = 0x82ED715C; continue 'dispatch;
            }
            0x82ED7134 => {
    //   block [0x82ED7134..0x82ED715C)
	// 82ED7134: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED7138: D0010114  stfs f0, 0x114(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82ED713C: D3E10118  stfs f31, 0x118(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 82ED7140: 38810110  addi r4, r1, 0x110
	ctx.r[4].s64 = ctx.r[1].s64 + 272;
	// 82ED7144: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82ED7148: D361011C  stfs f27, 0x11c(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 82ED714C: D3410120  stfs f26, 0x120(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82ED7150: 91610110  stw r11, 0x110(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82ED7154: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ED7158: 99610124  stb r11, 0x124(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), ctx.r[11].u8 ) };
	pc = 0x82ED715C; continue 'dispatch;
            }
            0x82ED715C => {
    //   block [0x82ED715C..0x82ED7160)
	// 82ED715C: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82ED7160; continue 'dispatch;
            }
            0x82ED7160 => {
    //   block [0x82ED7160..0x82ED7164)
	// 82ED7160: 48005CF9  bl 0x82edce58
	ctx.lr = 0x82ED7164;
	sub_82EDCE58(ctx, base);
	pc = 0x82ED7164; continue 'dispatch;
            }
            0x82ED7164 => {
    //   block [0x82ED7164..0x82ED7174)
	// 82ED7164: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 82ED7168: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82ED716C: 4BDD6BB1  bl 0x82cadd1c
	ctx.lr = 0x82ED7170;
	sub_82CADCEC(ctx, base);
	// 82ED7170: 4BDD22EC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED7178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ED7178 size=1196
    let mut pc: u32 = 0x82ED7178;
    'dispatch: loop {
        match pc {
            0x82ED7178 => {
    //   block [0x82ED7178..0x82ED72C4)
	// 82ED7178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED717C: 4BDD227D  bl 0x82ca93f8
	ctx.lr = 0x82ED7180;
	sub_82CA93D0(ctx, base);
	// 82ED7180: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 82ED7184: 4BDD6B1D  bl 0x82cadca0
	ctx.lr = 0x82ED7188;
	sub_82CADCA0(ctx, base);
	// 82ED7188: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED718C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ED7190: C1850008  lfs f12, 8(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED7194: C0050000  lfs f0, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED7198: FDC01890  fmr f14, f3
	ctx.f[14].f64 = ctx.f[3].f64;
	// 82ED719C: 396BDBFC  addi r11, r11, -0x2404
	ctx.r[11].s64 = ctx.r[11].s64 + -9220;
	// 82ED71A0: C1A50004  lfs f13, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED71A4: EC8000B2  fmuls f4, f0, f2
	ctx.f[4].f64 = (((ctx.f[0].f64 * ctx.f[2].f64) as f32) as f64);
	// 82ED71A8: C1040000  lfs f8, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82ED71AC: EC6D00B2  fmuls f3, f13, f2
	ctx.f[3].f64 = (((ctx.f[13].f64 * ctx.f[2].f64) as f32) as f64);
	// 82ED71B0: C0E40004  lfs f7, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82ED71B4: EC4C00B2  fmuls f2, f12, f2
	ctx.f[2].f64 = (((ctx.f[12].f64 * ctx.f[2].f64) as f32) as f64);
	// 82ED71B8: C0C40008  lfs f6, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82ED71BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED71C0: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED71C4: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 82ED71C8: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82ED71CC: EFE002F2  fmuls f31, f0, f11
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82ED71D0: C12B0004  lfs f9, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82ED71D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED71D8: EFAC0272  fmuls f29, f12, f9
	ctx.f[29].f64 = (((ctx.f[12].f64 * ctx.f[9].f64) as f32) as f64);
	// 82ED71DC: 3B9F00A8  addi r28, r31, 0xa8
	ctx.r[28].s64 = ctx.r[31].s64 + 168;
	// 82ED71E0: EF8D02B2  fmuls f28, f13, f10
	ctx.f[28].f64 = (((ctx.f[13].f64 * ctx.f[10].f64) as f32) as f64);
	// 82ED71E4: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 82ED71E8: C36B0BEC  lfs f27, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82ED71EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED71F0: FCA0D890  fmr f5, f27
	ctx.f[5].f64 = ctx.f[27].f64;
	// 82ED71F4: FE00D890  fmr f16, f27
	ctx.f[16].f64 = ctx.f[27].f64;
	// 82ED71F8: ED4CFAB8  fmsubs f10, f12, f10, f31
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[10].f64 - ctx.f[31].f64) as f32) as f64);
	// 82ED71FC: C28B0C1C  lfs f20, 0xc1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3100 as u32) ) };
	ctx.f[20].f64 = (tmp.f32 as f64);
	// 82ED7200: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED7204: ED6DEAF8  fmsubs f11, f13, f11, f29
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[11].f64 - ctx.f[29].f64) as f32) as f64);
	// 82ED7208: C3BF005C  lfs f29, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82ED720C: ED20E278  fmsubs f9, f0, f9, f28
	ctx.f[9].f64 = (((ctx.f[0].f64 * ctx.f[9].f64 - ctx.f[28].f64) as f32) as f64);
	// 82ED7210: C39F0064  lfs f28, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82ED7214: FFC0A090  fmr f30, f20
	ctx.f[30].f64 = ctx.f[20].f64;
	// 82ED7218: C26B0C18  lfs f19, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[19].f64 = (tmp.f32 as f64);
	// 82ED721C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED7220: FDE09890  fmr f15, f19
	ctx.f[15].f64 = ctx.f[19].f64;
	// 82ED7224: C3EB0BFC  lfs f31, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82ED7228: EC0407F2  fmuls f0, f4, f31
	ctx.f[0].f64 = (((ctx.f[4].f64 * ctx.f[31].f64) as f32) as f64);
	// 82ED722C: EDA307F2  fmuls f13, f3, f31
	ctx.f[13].f64 = (((ctx.f[3].f64 * ctx.f[31].f64) as f32) as f64);
	// 82ED7230: EC8B0072  fmuls f4, f11, f1
	ctx.f[4].f64 = (((ctx.f[11].f64 * ctx.f[1].f64) as f32) as f64);
	// 82ED7234: EC6A0072  fmuls f3, f10, f1
	ctx.f[3].f64 = (((ctx.f[10].f64 * ctx.f[1].f64) as f32) as f64);
	// 82ED7238: ED8207F2  fmuls f12, f2, f31
	ctx.f[12].f64 = (((ctx.f[2].f64 * ctx.f[31].f64) as f32) as f64);
	// 82ED723C: EC490072  fmuls f2, f9, f1
	ctx.f[2].f64 = (((ctx.f[9].f64 * ctx.f[1].f64) as f32) as f64);
	// 82ED7240: ED68002A  fadds f11, f8, f0
	ctx.f[11].f64 = ((ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64;
	// 82ED7244: ED080028  fsubs f8, f8, f0
	ctx.f[8].f64 = (((ctx.f[8].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED7248: EC0407F2  fmuls f0, f4, f31
	ctx.f[0].f64 = (((ctx.f[4].f64 * ctx.f[31].f64) as f32) as f64);
	// 82ED724C: ED47682A  fadds f10, f7, f13
	ctx.f[10].f64 = ((ctx.f[7].f64 + ctx.f[13].f64) as f32) as f64;
	// 82ED7250: ECE76828  fsubs f7, f7, f13
	ctx.f[7].f64 = (((ctx.f[7].f64 - ctx.f[13].f64) as f32) as f64);
	// 82ED7254: EDA307F2  fmuls f13, f3, f31
	ctx.f[13].f64 = (((ctx.f[3].f64 * ctx.f[31].f64) as f32) as f64);
	// 82ED7258: ED26602A  fadds f9, f6, f12
	ctx.f[9].f64 = ((ctx.f[6].f64 + ctx.f[12].f64) as f32) as f64;
	// 82ED725C: ECC66028  fsubs f6, f6, f12
	ctx.f[6].f64 = (((ctx.f[6].f64 - ctx.f[12].f64) as f32) as f64);
	// 82ED7260: ED8207F2  fmuls f12, f2, f31
	ctx.f[12].f64 = (((ctx.f[2].f64 * ctx.f[31].f64) as f32) as f64);
	// 82ED7264: EC80582A  fadds f4, f0, f11
	ctx.f[4].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 82ED7268: D08100B0  stfs f4, 0xb0(r1)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82ED726C: EC8D502A  fadds f4, f13, f10
	ctx.f[4].f64 = ((ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64;
	// 82ED7270: D08100B4  stfs f4, 0xb4(r1)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82ED7274: EC80402A  fadds f4, f0, f8
	ctx.f[4].f64 = ((ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64;
	// 82ED7278: D08100BC  stfs f4, 0xbc(r1)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82ED727C: ED080028  fsubs f8, f8, f0
	ctx.f[8].f64 = (((ctx.f[8].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED7280: D10100C8  stfs f8, 0xc8(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82ED7284: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED7288: D00100D4  stfs f0, 0xd4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82ED728C: EC8C482A  fadds f4, f12, f9
	ctx.f[4].f64 = ((ctx.f[12].f64 + ctx.f[9].f64) as f32) as f64;
	// 82ED7290: D08100B8  stfs f4, 0xb8(r1)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82ED7294: EC8D382A  fadds f4, f13, f7
	ctx.f[4].f64 = ((ctx.f[13].f64 + ctx.f[7].f64) as f32) as f64;
	// 82ED7298: D08100C0  stfs f4, 0xc0(r1)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82ED729C: ED076828  fsubs f8, f7, f13
	ctx.f[8].f64 = (((ctx.f[7].f64 - ctx.f[13].f64) as f32) as f64);
	// 82ED72A0: D10100CC  stfs f8, 0xcc(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82ED72A4: EC0A6828  fsubs f0, f10, f13
	ctx.f[0].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82ED72A8: D00100D8  stfs f0, 0xd8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82ED72AC: EC8C302A  fadds f4, f12, f6
	ctx.f[4].f64 = ((ctx.f[12].f64 + ctx.f[6].f64) as f32) as f64;
	// 82ED72B0: D08100C4  stfs f4, 0xc4(r1)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82ED72B4: ED066028  fsubs f8, f6, f12
	ctx.f[8].f64 = (((ctx.f[6].f64 - ctx.f[12].f64) as f32) as f64);
	// 82ED72B8: D10100D0  stfs f8, 0xd0(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82ED72BC: EC096028  fsubs f0, f9, f12
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 82ED72C0: D00100DC  stfs f0, 0xdc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	pc = 0x82ED72C4; continue 'dispatch;
            }
            0x82ED72C4 => {
    //   block [0x82ED72C4..0x82ED72F0)
	// 82ED72C4: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED72C8: EDA0E828  fsubs f13, f0, f29
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[29].f64) as f32) as f64);
	// 82ED72CC: C18A0008  lfs f12, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED72D0: C01C0008  lfs f0, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED72D4: ED8CE028  fsubs f12, f12, f28
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[28].f64) as f32) as f64);
	// 82ED72D8: C17C0000  lfs f11, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED72DC: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED72E0: EC0C02F8  fmsubs f0, f12, f11, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED72E4: FF050000  fcmpu cr6, f5, f0
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[0].f64);
	// 82ED72E8: 40990008  ble cr6, 0x82ed72f0
	if !ctx.cr[6].gt {
	pc = 0x82ED72F0; continue 'dispatch;
	}
	// 82ED72EC: FCA00090  fmr f5, f0
	ctx.f[5].f64 = ctx.f[0].f64;
	pc = 0x82ED72F0; continue 'dispatch;
            }
            0x82ED72F0 => {
    //   block [0x82ED72F0..0x82ED72FC)
	// 82ED72F0: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 82ED72F4: 40980008  bge cr6, 0x82ed72fc
	if !ctx.cr[6].lt {
	pc = 0x82ED72FC; continue 'dispatch;
	}
	// 82ED72F8: FFC00090  fmr f30, f0
	ctx.f[30].f64 = ctx.f[0].f64;
	pc = 0x82ED72FC; continue 'dispatch;
            }
            0x82ED72FC => {
    //   block [0x82ED72FC..0x82ED731C)
	// 82ED72FC: C17C0000  lfs f11, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED7300: EDAB0372  fmuls f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED7304: C17C0008  lfs f11, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED7308: EDAB6B3A  fmadds f13, f11, f12, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82ED730C: FF0D8000  fcmpu cr6, f13, f16
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[16].f64);
	// 82ED7310: 4098000C  bge cr6, 0x82ed731c
	if !ctx.cr[6].lt {
	pc = 0x82ED731C; continue 'dispatch;
	}
	// 82ED7314: FE006890  fmr f16, f13
	ctx.f[16].f64 = ctx.f[13].f64;
	// 82ED7318: FDE00090  fmr f15, f0
	ctx.f[15].f64 = ctx.f[0].f64;
	pc = 0x82ED731C; continue 'dispatch;
            }
            0x82ED731C => {
    //   block [0x82ED731C..0x82ED733C)
	// 82ED731C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82ED7320: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82ED7324: 4082FFA0  bne 0x82ed72c4
	if !ctx.cr[0].eq {
	pc = 0x82ED72C4; continue 'dispatch;
	}
	// 82ED7328: C01F0040  lfs f0, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED732C: FDA00050  fneg f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82ED7330: FF056800  fcmpu cr6, f5, f13
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[13].f64);
	// 82ED7334: 40980008  bge cr6, 0x82ed733c
	if !ctx.cr[6].lt {
	pc = 0x82ED733C; continue 'dispatch;
	}
	// 82ED7338: FCA06890  fmr f5, f13
	ctx.f[5].f64 = ctx.f[13].f64;
	pc = 0x82ED733C; continue 'dispatch;
            }
            0x82ED733C => {
    //   block [0x82ED733C..0x82ED7348)
	// 82ED733C: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 82ED7340: 40990008  ble cr6, 0x82ed7348
	if !ctx.cr[6].gt {
	pc = 0x82ED7348; continue 'dispatch;
	}
	// 82ED7344: FFC00090  fmr f30, f0
	ctx.f[30].f64 = ctx.f[0].f64;
	pc = 0x82ED7348; continue 'dispatch;
            }
            0x82ED7348 => {
    //   block [0x82ED7348..0x82ED7370)
	// 82ED7348: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82ED734C: C19F0070  lfs f12, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED7350: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ED7354: EEACF7FA  fmadds f21, f12, f31, f30
	ctx.f[21].f64 = (((ctx.f[12].f64 * ctx.f[31].f64 + ctx.f[30].f64) as f32) as f64);
	// 82ED7358: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82ED735C: C1AA0C14  lfs f13, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED7360: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED7364: 4182000C  beq 0x82ed7370
	if ctx.cr[0].eq {
	pc = 0x82ED7370; continue 'dispatch;
	}
	// 82ED7368: C16B000C  lfs f11, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED736C: 48000008  b 0x82ed7374
	pc = 0x82ED7374; continue 'dispatch;
            }
            0x82ED7370 => {
    //   block [0x82ED7370..0x82ED7374)
	// 82ED7370: FD606890  fmr f11, f13
	ctx.f[11].f64 = ctx.f[13].f64;
	pc = 0x82ED7374; continue 'dispatch;
            }
            0x82ED7374 => {
    //   block [0x82ED7374..0x82ED738C)
	// 82ED7374: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ED7378: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED737C: C00A0A54  lfs f0, 0xa54(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED7380: EFAB0032  fmuls f29, f11, f0
	ctx.f[29].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED7384: 41820008  beq 0x82ed738c
	if ctx.cr[0].eq {
	pc = 0x82ED738C; continue 'dispatch;
	}
	// 82ED7388: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82ED738C; continue 'dispatch;
            }
            0x82ED738C => {
    //   block [0x82ED738C..0x82ED73BC)
	// 82ED738C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED7390: ED752828  fsubs f11, f21, f5
	ctx.f[11].f64 = (((ctx.f[21].f64 - ctx.f[5].f64) as f32) as f64);
	// 82ED7394: C00B0AC8  lfs f0, 0xac8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2760 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED7398: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED739C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED73A0: C1AB0C4C  lfs f13, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED73A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ED73A8: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED73AC: EEC0E82A  fadds f22, f0, f29
	ctx.f[22].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 82ED73B0: FF0B6800  fcmpu cr6, f11, f13
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[13].f64);
	// 82ED73B4: 41990008  bgt cr6, 0x82ed73bc
	if ctx.cr[6].gt {
	pc = 0x82ED73BC; continue 'dispatch;
	}
	// 82ED73B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82ED73BC; continue 'dispatch;
            }
            0x82ED73BC => {
    //   block [0x82ED73BC..0x82ED7450)
	// 82ED73BC: C01C0000  lfs f0, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED73C0: 3B3F0090  addi r25, r31, 0x90
	ctx.r[25].s64 = ctx.r[31].s64 + 144;
	// 82ED73C4: C1BC0004  lfs f13, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED73C8: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82ED73CC: C19C0008  lfs f12, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED73D0: EDAD0772  fmuls f13, f13, f29
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[29].f64) as f32) as f64);
	// 82ED73D4: ED8C0772  fmuls f12, f12, f29
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[29].f64) as f32) as f64);
	// 82ED73D8: C11F005C  lfs f8, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82ED73DC: C0FF0060  lfs f7, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82ED73E0: FF402890  fmr f26, f5
	ctx.f[26].f64 = ctx.f[5].f64;
	// 82ED73E4: C0DF0064  lfs f6, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82ED73E8: FF05A800  fcmpu cr6, f5, f21
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[21].f64);
	// 82ED73EC: C1790000  lfs f11, 0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED73F0: 5578063E  clrlwi r24, r11, 0x18
	ctx.r[24].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82ED73F4: C1590004  lfs f10, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82ED73F8: ED6B0172  fmuls f11, f11, f5
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[5].f64) as f32) as f64);
	// 82ED73FC: C1390008  lfs f9, 8(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82ED7400: ED4A0172  fmuls f10, f10, f5
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[5].f64) as f32) as f64);
	// 82ED7404: ED290172  fmuls f9, f9, f5
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[5].f64) as f32) as f64);
	// 82ED7408: EC080028  fsubs f0, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED740C: EDA76828  fsubs f13, f7, f13
	ctx.f[13].f64 = (((ctx.f[7].f64 - ctx.f[13].f64) as f32) as f64);
	// 82ED7410: ED866028  fsubs f12, f6, f12
	ctx.f[12].f64 = (((ctx.f[6].f64 - ctx.f[12].f64) as f32) as f64);
	// 82ED7414: EF20582A  fadds f25, f0, f11
	ctx.f[25].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 82ED7418: D3210050  stfs f25, 0x50(r1)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82ED741C: EF0D502A  fadds f24, f13, f10
	ctx.f[24].f64 = ((ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64;
	// 82ED7420: D3010054  stfs f24, 0x54(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82ED7424: EEEC482A  fadds f23, f12, f9
	ctx.f[23].f64 = ((ctx.f[12].f64 + ctx.f[9].f64) as f32) as f64;
	// 82ED7428: D2E10058  stfs f23, 0x58(r1)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82ED742C: 409801E8  bge cr6, 0x82ed7614
	if !ctx.cr[6].lt {
	pc = 0x82ED7614; continue 'dispatch;
	}
	// 82ED7430: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82ED7434: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82ED7438: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ED743C: 3B6B9128  addi r27, r11, -0x6ed8
	ctx.r[27].s64 = ctx.r[11].s64 + -28376;
	// 82ED7440: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED7444: C2290C8C  lfs f17, 0xc8c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3212 as u32) ) };
	ctx.f[17].f64 = (tmp.f32 as f64);
	// 82ED7448: 3B4BAFB4  addi r26, r11, -0x504c
	ctx.r[26].s64 = ctx.r[11].s64 + -20556;
	// 82ED744C: C24A0BE8  lfs f18, 0xbe8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3048 as u32) ) };
	ctx.f[18].f64 = (tmp.f32 as f64);
	pc = 0x82ED7450; continue 'dispatch;
            }
            0x82ED7450 => {
    //   block [0x82ED7450..0x82ED7490)
	// 82ED7450: C01C0000  lfs f0, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED7454: FFC0D890  fmr f30, f27
	ctx.f[30].f64 = ctx.f[27].f64;
	// 82ED7458: C1BC0004  lfs f13, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED745C: EC0005B2  fmuls f0, f0, f22
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[22].f64) as f32) as f64);
	// 82ED7460: C19C0008  lfs f12, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED7464: EDB60372  fmuls f13, f22, f13
	ctx.f[13].f64 = (((ctx.f[22].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED7468: ED960332  fmuls f12, f22, f12
	ctx.f[12].f64 = (((ctx.f[22].f64 * ctx.f[12].f64) as f32) as f64);
	// 82ED746C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ED7470: FF80A090  fmr f28, f20
	ctx.f[28].f64 = ctx.f[20].f64;
	// 82ED7474: 3BC100B0  addi r30, r1, 0xb0
	ctx.r[30].s64 = ctx.r[1].s64 + 176;
	// 82ED7478: EC00C82A  fadds f0, f0, f25
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[25].f64) as f32) as f64;
	// 82ED747C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82ED7480: EC0DC02A  fadds f0, f13, f24
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[24].f64) as f32) as f64;
	// 82ED7484: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82ED7488: EC0CB82A  fadds f0, f12, f23
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[23].f64) as f32) as f64;
	// 82ED748C: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	pc = 0x82ED7490; continue 'dispatch;
            }
            0x82ED7490 => {
    //   block [0x82ED7490..0x82ED74CC)
	// 82ED7490: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	// 82ED7494: FC20B090  fmr f1, f22
	ctx.f[1].f64 = ctx.f[22].f64;
	// 82ED7498: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 82ED749C: 57AB07BE  clrlwi r11, r29, 0x1e
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000003u64;
	// 82ED74A0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82ED74A4: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82ED74A8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82ED74AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ED74B0: 7CEB5214  add r7, r11, r10
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82ED74B4: 480089B5  bl 0x82edfe68
	ctx.lr = 0x82ED74B8;
	sub_82EDFE68(ctx, base);
	// 82ED74B8: FF01D800  fcmpu cr6, f1, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[27].f64);
	// 82ED74BC: 419A001C  beq cr6, 0x82ed74d8
	if ctx.cr[6].eq {
	pc = 0x82ED74D8; continue 'dispatch;
	}
	// 82ED74C0: FF1C0800  fcmpu cr6, f28, f1
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[1].f64);
	// 82ED74C4: 40980008  bge cr6, 0x82ed74cc
	if !ctx.cr[6].lt {
	pc = 0x82ED74CC; continue 'dispatch;
	}
	// 82ED74C8: FF800890  fmr f28, f1
	ctx.f[28].f64 = ctx.f[1].f64;
	pc = 0x82ED74CC; continue 'dispatch;
            }
            0x82ED74CC => {
    //   block [0x82ED74CC..0x82ED74D8)
	// 82ED74CC: FF1E0800  fcmpu cr6, f30, f1
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[1].f64);
	// 82ED74D0: 40990008  ble cr6, 0x82ed74d8
	if !ctx.cr[6].gt {
	pc = 0x82ED74D8; continue 'dispatch;
	}
	// 82ED74D4: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	pc = 0x82ED74D8; continue 'dispatch;
            }
            0x82ED74D8 => {
    //   block [0x82ED74D8..0x82ED74FC)
	// 82ED74D8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82ED74DC: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 82ED74E0: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82ED74E4: 4198FFAC  blt cr6, 0x82ed7490
	if ctx.cr[6].lt {
	pc = 0x82ED7490; continue 'dispatch;
	}
	// 82ED74E8: FF1CE800  fcmpu cr6, f28, f29
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[29].f64);
	// 82ED74EC: 419800E4  blt cr6, 0x82ed75d0
	if ctx.cr[6].lt {
	pc = 0x82ED75D0; continue 'dispatch;
	}
	// 82ED74F0: FF1EE800  fcmpu cr6, f30, f29
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[29].f64);
	// 82ED74F4: 40980008  bge cr6, 0x82ed74fc
	if !ctx.cr[6].lt {
	pc = 0x82ED74FC; continue 'dispatch;
	}
	// 82ED74F8: FFC0E890  fmr f30, f29
	ctx.f[30].f64 = ctx.f[29].f64;
	pc = 0x82ED74FC; continue 'dispatch;
            }
            0x82ED74FC => {
    //   block [0x82ED74FC..0x82ED7528)
	// 82ED74FC: EDBEE828  fsubs f13, f30, f29
	ctx.f[13].f64 = (((ctx.f[30].f64 - ctx.f[29].f64) as f32) as f64);
	// 82ED7500: C17F00F8  lfs f11, 0xf8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED7504: C01F0070  lfs f0, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED7508: C19F0040  lfs f12, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED750C: ED4D02F2  fmuls f10, f13, f11
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82ED7510: EDA0D7FC  fnmsubs f13, f0, f31, f26
	ctx.f[13].f64 = -(((ctx.f[0].f64 * ctx.f[31].f64 - ctx.f[26].f64) as f32) as f64);
	// 82ED7514: FD606050  fneg f11, f12
	ctx.f[11].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 82ED7518: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82ED751C: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82ED7520: 40980008  bge cr6, 0x82ed7528
	if !ctx.cr[6].lt {
	pc = 0x82ED7528; continue 'dispatch;
	}
	// 82ED7524: FDA05890  fmr f13, f11
	ctx.f[13].f64 = ctx.f[11].f64;
	pc = 0x82ED7528; continue 'dispatch;
            }
            0x82ED7528 => {
    //   block [0x82ED7528..0x82ED7534)
	// 82ED7528: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82ED752C: 40990008  ble cr6, 0x82ed7534
	if !ctx.cr[6].gt {
	pc = 0x82ED7534; continue 'dispatch;
	}
	// 82ED7530: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	pc = 0x82ED7534; continue 'dispatch;
            }
            0x82ED7534 => {
    //   block [0x82ED7534..0x82ED7560)
	// 82ED7534: FF109800  fcmpu cr6, f16, f19
	ctx.cr[6].compare_f64(ctx.f[16].f64, ctx.f[19].f64);
	// 82ED7538: 40980070  bge cr6, 0x82ed75a8
	if !ctx.cr[6].lt {
	pc = 0x82ED75A8; continue 'dispatch;
	}
	// 82ED753C: FF0A9000  fcmpu cr6, f10, f18
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[18].f64);
	// 82ED7540: 40980068  bge cr6, 0x82ed75a8
	if !ctx.cr[6].lt {
	pc = 0x82ED75A8; continue 'dispatch;
	}
	// 82ED7544: FF0F9800  fcmpu cr6, f15, f19
	ctx.cr[6].compare_f64(ctx.f[15].f64, ctx.f[19].f64);
	// 82ED7548: 41990018  bgt cr6, 0x82ed7560
	if ctx.cr[6].gt {
	pc = 0x82ED7560; continue 'dispatch;
	}
	// 82ED754C: C19F0070  lfs f12, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED7550: C17F0010  lfs f11, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED7554: ED8C5C78  fmsubs f12, f12, f17, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[17].f64 - ctx.f[11].f64) as f32) as f64);
	// 82ED7558: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82ED755C: 40980020  bge cr6, 0x82ed757c
	if !ctx.cr[6].lt {
	pc = 0x82ED757C; continue 'dispatch;
	}
	pc = 0x82ED7560; continue 'dispatch;
            }
            0x82ED7560 => {
    //   block [0x82ED7560..0x82ED757C)
	// 82ED7560: FF0F9800  fcmpu cr6, f15, f19
	ctx.cr[6].compare_f64(ctx.f[15].f64, ctx.f[19].f64);
	// 82ED7564: 40990044  ble cr6, 0x82ed75a8
	if !ctx.cr[6].gt {
	pc = 0x82ED75A8; continue 'dispatch;
	}
	// 82ED7568: C19F0070  lfs f12, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED756C: C17F0010  lfs f11, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED7570: ED8C5FFA  fmadds f12, f12, f31, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[31].f64 + ctx.f[11].f64) as f32) as f64);
	// 82ED7574: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82ED7578: 41990030  bgt cr6, 0x82ed75a8
	if ctx.cr[6].gt {
	pc = 0x82ED75A8; continue 'dispatch;
	}
	pc = 0x82ED757C; continue 'dispatch;
            }
            0x82ED757C => {
    //   block [0x82ED757C..0x82ED75A8)
	// 82ED757C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82ED7580: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ED7584: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82ED7588: 93410070  stw r26, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[26].u32 ) };
	// 82ED758C: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82ED7590: 9B010084  stb r24, 0x84(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[24].u8 ) };
	// 82ED7594: D241007C  stfs f18, 0x7c(r1)
	tmp.f32 = (ctx.f[18].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82ED7598: D1C10080  stfs f14, 0x80(r1)
	tmp.f32 = (ctx.f[14].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82ED759C: 480058BD  bl 0x82edce58
	ctx.lr = 0x82ED75A0;
	sub_82EDCE58(ctx, base);
	// 82ED75A0: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 82ED75A4: 4800002C  b 0x82ed75d0
	pc = 0x82ED75D0; continue 'dispatch;
            }
            0x82ED75A8 => {
    //   block [0x82ED75A8..0x82ED75D0)
	// 82ED75A8: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82ED75AC: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ED75B0: D1A10094  stfs f13, 0x94(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82ED75B4: 93410090  stw r26, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[26].u32 ) };
	// 82ED75B8: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82ED75BC: 9B0100A4  stb r24, 0xa4(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[24].u8 ) };
	// 82ED75C0: D141009C  stfs f10, 0x9c(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82ED75C4: D1C100A0  stfs f14, 0xa0(r1)
	tmp.f32 = (ctx.f[14].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82ED75C8: 48005891  bl 0x82edce58
	ctx.lr = 0x82ED75CC;
	sub_82EDCE58(ctx, base);
	// 82ED75CC: 93610090  stw r27, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[27].u32 ) };
	pc = 0x82ED75D0; continue 'dispatch;
            }
            0x82ED75D0 => {
    //   block [0x82ED75D0..0x82ED7614)
	// 82ED75D0: C01F0070  lfs f0, 0x70(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED75D4: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82ED75D8: C1B90000  lfs f13, 0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED75DC: C1990004  lfs f12, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED75E0: C1790008  lfs f11, 8(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED75E4: EF40D02A  fadds f26, f0, f26
	ctx.f[26].f64 = ((ctx.f[0].f64 + ctx.f[26].f64) as f32) as f64;
	// 82ED75E8: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED75EC: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED75F0: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED75F4: FF1AA800  fcmpu cr6, f26, f21
	ctx.cr[6].compare_f64(ctx.f[26].f64, ctx.f[21].f64);
	// 82ED75F8: EF2DC82A  fadds f25, f13, f25
	ctx.f[25].f64 = ((ctx.f[13].f64 + ctx.f[25].f64) as f32) as f64;
	// 82ED75FC: D3210050  stfs f25, 0x50(r1)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82ED7600: EF0CC02A  fadds f24, f12, f24
	ctx.f[24].f64 = ((ctx.f[12].f64 + ctx.f[24].f64) as f32) as f64;
	// 82ED7604: D3010054  stfs f24, 0x54(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82ED7608: EEE0B82A  fadds f23, f0, f23
	ctx.f[23].f64 = ((ctx.f[0].f64 + ctx.f[23].f64) as f32) as f64;
	// 82ED760C: D2E10058  stfs f23, 0x58(r1)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82ED7610: 4198FE40  blt cr6, 0x82ed7450
	if ctx.cr[6].lt {
	pc = 0x82ED7450; continue 'dispatch;
	}
	pc = 0x82ED7614; continue 'dispatch;
            }
            0x82ED7614 => {
    //   block [0x82ED7614..0x82ED7624)
	// 82ED7614: 382101C0  addi r1, r1, 0x1c0
	ctx.r[1].s64 = ctx.r[1].s64 + 448;
	// 82ED7618: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 82ED761C: 4BDD66D1  bl 0x82cadcec
	ctx.lr = 0x82ED7620;
	sub_82CADCEC(ctx, base);
	// 82ED7620: 4BDD1E28  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED7628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ED7628 size=1136
    let mut pc: u32 = 0x82ED7628;
    'dispatch: loop {
        match pc {
            0x82ED7628 => {
    //   block [0x82ED7628..0x82ED7680)
	// 82ED7628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED762C: 4BDD1DDD  bl 0x82ca9408
	ctx.lr = 0x82ED7630;
	sub_82CA93D0(ctx, base);
	// 82ED7630: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82ED7634: 4BDD6699  bl 0x82cadccc
	ctx.lr = 0x82ED7638;
	sub_82CADCA0(ctx, base);
	// 82ED7638: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED763C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ED7640: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82ED7644: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED7648: 388BC178  addi r4, r11, -0x3e88
	ctx.r[4].s64 = ctx.r[11].s64 + -16008;
	// 82ED764C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82ED7650: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED7654: 4B311025  bl 0x821e8678
	ctx.lr = 0x82ED7658;
	sub_821E8678(ctx, base);
	// 82ED7658: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ED765C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED7660: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED7664: 3F808334  lis r28, -0x7ccc
	ctx.r[28].s64 = -2093744128;
	// 82ED7668: C3AA0C14  lfs f29, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82ED766C: C36B0BFC  lfs f27, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82ED7670: 41820010  beq 0x82ed7680
	if ctx.cr[0].eq {
	pc = 0x82ED7680; continue 'dispatch;
	}
	// 82ED7674: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED7678: EC0006F2  fmuls f0, f0, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82ED767C: 4800001C  b 0x82ed7698
	pc = 0x82ED7698; continue 'dispatch;
            }
            0x82ED7680 => {
    //   block [0x82ED7680..0x82ED7694)
	// 82ED7680: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82ED7684: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED7688: 4182000C  beq 0x82ed7694
	if ctx.cr[0].eq {
	pc = 0x82ED7694; continue 'dispatch;
	}
	// 82ED768C: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED7690: 48000008  b 0x82ed7698
	pc = 0x82ED7698; continue 'dispatch;
            }
            0x82ED7694 => {
    //   block [0x82ED7694..0x82ED7698)
	// 82ED7694: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	pc = 0x82ED7698; continue 'dispatch;
            }
            0x82ED7698 => {
    //   block [0x82ED7698..0x82ED7718)
	// 82ED7698: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ED769C: C15F00B8  lfs f10, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82ED76A0: EC0A002A  fadds f0, f10, f0
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82ED76A4: C1BE0038  lfs f13, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED76A8: C19E003C  lfs f12, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED76AC: C17E0034  lfs f11, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED76B0: C14B0038  lfs f10, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82ED76B4: EDAD5028  fsubs f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82ED76B8: C12B003C  lfs f9, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82ED76BC: EFEC4828  fsubs f31, f12, f9
	ctx.f[31].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 82ED76C0: C18B0034  lfs f12, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED76C4: EFCB6028  fsubs f30, f11, f12
	ctx.f[30].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82ED76C8: C19F00A0  lfs f12, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED76CC: C17F00A4  lfs f11, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED76D0: C13F009C  lfs f9, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82ED76D4: FD400050  fneg f10, f0
	ctx.f[10].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82ED76D8: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED76DC: EDAB6FFA  fmadds f13, f11, f31, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[31].f64 + ctx.f[13].f64) as f32) as f64);
	// 82ED76E0: EDBE6A7A  fmadds f13, f30, f9, f13
	ctx.f[13].f64 = (((ctx.f[30].f64 * ctx.f[9].f64 + ctx.f[13].f64) as f32) as f64);
	// 82ED76E4: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 82ED76E8: 419803A0  blt cr6, 0x82ed7a88
	if ctx.cr[6].lt {
	pc = 0x82ED7A88; continue 'dispatch;
	}
	// 82ED76EC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ED76F0: 41990398  bgt cr6, 0x82ed7a88
	if ctx.cr[6].gt {
	pc = 0x82ED7A88; continue 'dispatch;
	}
	// 82ED76F4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82ED76F8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82ED76FC: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82ED7700: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED7704: 4B310F75  bl 0x821e8678
	ctx.lr = 0x82ED7708;
	sub_821E8678(ctx, base);
	// 82ED7708: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED770C: 4182000C  beq 0x82ed7718
	if ctx.cr[0].eq {
	pc = 0x82ED7718; continue 'dispatch;
	}
	// 82ED7710: C3230004  lfs f25, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82ED7714: 4800001C  b 0x82ed7730
	pc = 0x82ED7730; continue 'dispatch;
            }
            0x82ED7718 => {
    //   block [0x82ED7718..0x82ED772C)
	// 82ED7718: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82ED771C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED7720: 4182000C  beq 0x82ed772c
	if ctx.cr[0].eq {
	pc = 0x82ED772C; continue 'dispatch;
	}
	// 82ED7724: C32B000C  lfs f25, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82ED7728: 48000008  b 0x82ed7730
	pc = 0x82ED7730; continue 'dispatch;
            }
            0x82ED772C => {
    //   block [0x82ED772C..0x82ED7730)
	// 82ED772C: FF20E890  fmr f25, f29
	ctx.f[25].f64 = ctx.f[29].f64;
	pc = 0x82ED7730; continue 'dispatch;
            }
            0x82ED7730 => {
    //   block [0x82ED7730..0x82ED7760)
	// 82ED7730: C01F0070  lfs f0, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED7734: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82ED7738: EC00C82A  fadds f0, f0, f25
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[25].f64) as f32) as f64;
	// 82ED773C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82ED7740: 388BDA4C  addi r4, r11, -0x25b4
	ctx.r[4].s64 = ctx.r[11].s64 + -9652;
	// 82ED7744: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED7748: EF8006F2  fmuls f28, f0, f27
	ctx.f[28].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82ED774C: 4B310F2D  bl 0x821e8678
	ctx.lr = 0x82ED7750;
	sub_821E8678(ctx, base);
	// 82ED7750: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82ED7754: 4182000C  beq 0x82ed7760
	if ctx.cr[0].eq {
	pc = 0x82ED7760; continue 'dispatch;
	}
	// 82ED7758: C3BD0004  lfs f29, 4(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82ED775C: 48000014  b 0x82ed7770
	pc = 0x82ED7770; continue 'dispatch;
            }
            0x82ED7760 => {
    //   block [0x82ED7760..0x82ED7770)
	// 82ED7760: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82ED7764: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED7768: 41820008  beq 0x82ed7770
	if ctx.cr[0].eq {
	pc = 0x82ED7770; continue 'dispatch;
	}
	// 82ED776C: C3AB000C  lfs f29, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	pc = 0x82ED7770; continue 'dispatch;
            }
            0x82ED7770 => {
    //   block [0x82ED7770..0x82ED779C)
	// 82ED7770: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82ED7774: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82ED7778: 388BD2C0  addi r4, r11, -0x2d40
	ctx.r[4].s64 = ctx.r[11].s64 + -11584;
	// 82ED777C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED7780: 4B310EF9  bl 0x821e8678
	ctx.lr = 0x82ED7784;
	sub_821E8678(ctx, base);
	// 82ED7784: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED7788: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED778C: C34B0C18  lfs f26, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82ED7790: 4182000C  beq 0x82ed779c
	if ctx.cr[0].eq {
	pc = 0x82ED779C; continue 'dispatch;
	}
	// 82ED7794: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 82ED7798: 48000024  b 0x82ed77bc
	pc = 0x82ED77BC; continue 'dispatch;
            }
            0x82ED779C => {
    //   block [0x82ED779C..0x82ED77BC)
	// 82ED779C: C01E004C  lfs f0, 0x4c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED77A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82ED77A4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82ED77A8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82ED77AC: C01E0054  lfs f0, 0x54(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED77B0: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82ED77B4: D3410054  stfs f26, 0x54(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82ED77B8: 4B3A7AB1  bl 0x8227f268
	ctx.lr = 0x82ED77BC;
	sub_8227F268(ctx, base);
	pc = 0x82ED77BC; continue 'dispatch;
            }
            0x82ED77BC => {
    //   block [0x82ED77BC..0x82ED7868)
	// 82ED77BC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ED77C0: C1430000  lfs f10, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82ED77C4: D1410060  stfs f10, 0x60(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82ED77C8: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED77CC: 396BDBFC  addi r11, r11, -0x2404
	ctx.r[11].s64 = ctx.r[11].s64 + -9220;
	// 82ED77D0: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED77D4: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82ED77D8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82ED77DC: C1230008  lfs f9, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82ED77E0: D1210068  stfs f9, 0x68(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82ED77E4: C0DF00A8  lfs f6, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82ED77E8: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED77EC: C0EB0000  lfs f7, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82ED77F0: ECA902F2  fmuls f5, f9, f11
	ctx.f[5].f64 = (((ctx.f[9].f64 * ctx.f[11].f64) as f32) as f64);
	// 82ED77F4: ECED01F2  fmuls f7, f13, f7
	ctx.f[7].f64 = (((ctx.f[13].f64 * ctx.f[7].f64) as f32) as f64);
	// 82ED77F8: C10B0008  lfs f8, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82ED77FC: C00A0010  lfs f0, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED7800: C09F00B0  lfs f4, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82ED7804: C19E0058  lfs f12, 0x58(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED7808: C07E004C  lfs f3, 0x4c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82ED780C: C05E0054  lfs f2, 0x54(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82ED7810: ED0D2A38  fmsubs f8, f13, f8, f5
	ctx.f[8].f64 = (((ctx.f[13].f64 * ctx.f[8].f64 - ctx.f[5].f64) as f32) as f64);
	// 82ED7814: ED6A3AF8  fmsubs f11, f10, f11, f7
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[11].f64 - ctx.f[7].f64) as f32) as f64);
	// 82ED7818: EDA001B2  fmuls f13, f0, f6
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[6].f64) as f32) as f64);
	// 82ED781C: ECE40032  fmuls f7, f4, f0
	ctx.f[7].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED7820: FCA03090  fmr f5, f6
	ctx.f[5].f64 = ctx.f[6].f64;
	// 82ED7824: EDAC68F8  fmsubs f13, f12, f3, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[3].f64 - ctx.f[13].f64) as f32) as f64);
	// 82ED7828: ED823B38  fmsubs f12, f2, f12, f7
	ctx.f[12].f64 = (((ctx.f[2].f64 * ctx.f[12].f64 - ctx.f[7].f64) as f32) as f64);
	// 82ED782C: FCE03090  fmr f7, f6
	ctx.f[7].f64 = ctx.f[6].f64;
	// 82ED7830: FCC02090  fmr f6, f4
	ctx.f[6].f64 = ctx.f[4].f64;
	// 82ED7834: EDAD0172  fmuls f13, f13, f5
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[5].f64) as f32) as f64);
	// 82ED7838: ECE707B2  fmuls f7, f7, f30
	ctx.f[7].f64 = (((ctx.f[7].f64 * ctx.f[30].f64) as f32) as f64);
	// 82ED783C: ECA46B3A  fmadds f5, f4, f12, f13
	ctx.f[5].f64 = (((ctx.f[4].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82ED7840: ECC63FFA  fmadds f6, f6, f31, f7
	ctx.f[6].f64 = (((ctx.f[6].f64 * ctx.f[31].f64 + ctx.f[7].f64) as f32) as f64);
	// 82ED7844: 409A0104  bne cr6, 0x82ed7948
	if !ctx.cr[6].eq {
	pc = 0x82ED7948; continue 'dispatch;
	}
	// 82ED7848: FF06D000  fcmpu cr6, f6, f26
	ctx.cr[6].compare_f64(ctx.f[6].f64, ctx.f[26].f64);
	// 82ED784C: 4198023C  blt cr6, 0x82ed7a88
	if ctx.cr[6].lt {
	pc = 0x82ED7A88; continue 'dispatch;
	}
	// 82ED7850: C17F0010  lfs f11, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED7854: EDABE02A  fadds f13, f11, f28
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[28].f64) as f32) as f64;
	// 82ED7858: FF066800  fcmpu cr6, f6, f13
	ctx.cr[6].compare_f64(ctx.f[6].f64, ctx.f[13].f64);
	// 82ED785C: 4098000C  bge cr6, 0x82ed7868
	if !ctx.cr[6].lt {
	pc = 0x82ED7868; continue 'dispatch;
	}
	// 82ED7860: FC00D090  fmr f0, f26
	ctx.f[0].f64 = ctx.f[26].f64;
	// 82ED7864: 48000090  b 0x82ed78f4
	pc = 0x82ED78F4; continue 'dispatch;
            }
            0x82ED7868 => {
    //   block [0x82ED7868..0x82ED78DC)
	// 82ED7868: FD800050  fneg f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82ED786C: FF056000  fcmpu cr6, f5, f12
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[12].f64);
	// 82ED7870: 4099006C  ble cr6, 0x82ed78dc
	if !ctx.cr[6].gt {
	pc = 0x82ED78DC; continue 'dispatch;
	}
	// 82ED7874: C19F0008  lfs f12, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED7878: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED787C: EC0C583A  fmadds f0, f12, f0, f11
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82ED7880: C18B0C4C  lfs f12, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED7884: EC00E02A  fadds f0, f0, f28
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[28].f64) as f32) as f64;
	// 82ED7888: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82ED788C: FF060000  fcmpu cr6, f6, f0
	ctx.cr[6].compare_f64(ctx.f[6].f64, ctx.f[0].f64);
	// 82ED7890: 4199004C  bgt cr6, 0x82ed78dc
	if ctx.cr[6].gt {
	pc = 0x82ED78DC; continue 'dispatch;
	}
	// 82ED7894: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED7898: C13F0098  lfs f9, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82ED789C: C00B0C68  lfs f0, 0xc68(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED78A0: ED4D0032  fmuls f10, f13, f0
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED78A4: C01F0090  lfs f0, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED78A8: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82ED78AC: EC0907FA  fmadds f0, f9, f31, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82ED78B0: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82ED78B4: 41980028  blt cr6, 0x82ed78dc
	if ctx.cr[6].lt {
	pc = 0x82ED78DC; continue 'dispatch;
	}
	// 82ED78B8: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82ED78BC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED78C0: 4199001C  bgt cr6, 0x82ed78dc
	if ctx.cr[6].gt {
	pc = 0x82ED78DC; continue 'dispatch;
	}
	// 82ED78C4: C01F00F8  lfs f0, 0xf8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED78C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED78CC: EC0001B2  fmuls f0, f0, f6
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[6].f64) as f32) as f64);
	// 82ED78D0: C1AB0BEC  lfs f13, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED78D4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED78D8: 409A0014  bne cr6, 0x82ed78ec
	if !ctx.cr[6].eq {
	pc = 0x82ED78EC; continue 'dispatch;
	}
	pc = 0x82ED78DC; continue 'dispatch;
            }
            0x82ED78DC => {
    //   block [0x82ED78DC..0x82ED78EC)
	// 82ED78DC: FF05D000  fcmpu cr6, f5, f26
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[26].f64);
	// 82ED78E0: 409801A8  bge cr6, 0x82ed7a88
	if !ctx.cr[6].lt {
	pc = 0x82ED7A88; continue 'dispatch;
	}
	// 82ED78E4: EC062824  fdivs f0, f6, f5
	ctx.f[0].f64 = ((ctx.f[6].f64 / ctx.f[5].f64) as f32) as f64;
	// 82ED78E8: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x82ED78EC; continue 'dispatch;
            }
            0x82ED78EC => {
    //   block [0x82ED78EC..0x82ED78F4)
	// 82ED78EC: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82ED78F0: 41980198  blt cr6, 0x82ed7a88
	if ctx.cr[6].lt {
	pc = 0x82ED7A88; continue 'dispatch;
	}
	pc = 0x82ED78F4; continue 'dispatch;
            }
            0x82ED78F4 => {
    //   block [0x82ED78F4..0x82ED7914)
	// 82ED78F4: C1BF00B4  lfs f13, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED78F8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED78FC: 40990018  ble cr6, 0x82ed7914
	if !ctx.cr[6].gt {
	pc = 0x82ED7914; continue 'dispatch;
	}
	// 82ED7900: C19F00F8  lfs f12, 0xf8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED7904: ED8C0672  fmuls f12, f12, f25
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[25].f64) as f32) as f64);
	// 82ED7908: EDAC6EFA  fmadds f13, f12, f27, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[27].f64 + ctx.f[13].f64) as f32) as f64);
	// 82ED790C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED7910: 41990178  bgt cr6, 0x82ed7a88
	if ctx.cr[6].gt {
	pc = 0x82ED7A88; continue 'dispatch;
	}
	pc = 0x82ED7914; continue 'dispatch;
            }
            0x82ED7914 => {
    //   block [0x82ED7914..0x82ED7928)
	// 82ED7914: C1BF00F8  lfs f13, 0xf8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED7918: EC4D02FC  fnmsubs f2, f13, f11, f0
	ctx.f[2].f64 = -(((ctx.f[13].f64 * ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED791C: FF02D000  fcmpu cr6, f2, f26
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[26].f64);
	// 82ED7920: 40980008  bge cr6, 0x82ed7928
	if !ctx.cr[6].lt {
	pc = 0x82ED7928; continue 'dispatch;
	}
	// 82ED7924: FC40D090  fmr f2, f26
	ctx.f[2].f64 = ctx.f[26].f64;
	pc = 0x82ED7928; continue 'dispatch;
            }
            0x82ED7928 => {
    //   block [0x82ED7928..0x82ED7948)
	// 82ED7928: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED792C: FC20C890  fmr f1, f25
	ctx.f[1].f64 = ctx.f[25].f64;
	// 82ED7930: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ED7934: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED7938: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED793C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED7940: 4E800421  bctrl
	ctx.lr = 0x82ED7944;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED7944: 48000144  b 0x82ed7a88
	pc = 0x82ED7A88; continue 'dispatch;
            }
            0x82ED7948 => {
    //   block [0x82ED7948..0x82ED798C)
	// 82ED7948: C0FF0010  lfs f7, 0x10(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82ED794C: EC0A07B2  fmuls f0, f10, f30
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[30].f64) as f32) as f64);
	// 82ED7950: EDBD3EFA  fmadds f13, f29, f27, f7
	ctx.f[13].f64 = (((ctx.f[29].f64 * ctx.f[27].f64 + ctx.f[7].f64) as f32) as f64);
	// 82ED7954: EC0907FA  fmadds f0, f9, f31, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82ED7958: FD806850  fneg f12, f13
	ctx.f[12].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 82ED795C: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82ED7960: 41980034  blt cr6, 0x82ed7994
	if ctx.cr[6].lt {
	pc = 0x82ED7994; continue 'dispatch;
	}
	// 82ED7964: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED7968: 4199002C  bgt cr6, 0x82ed7994
	if ctx.cr[6].gt {
	pc = 0x82ED7994; continue 'dispatch;
	}
	// 82ED796C: EDA807B2  fmuls f13, f8, f30
	ctx.f[13].f64 = (((ctx.f[8].f64 * ctx.f[30].f64) as f32) as f64);
	// 82ED7970: EC193EFA  fmadds f0, f25, f27, f7
	ctx.f[0].f64 = (((ctx.f[25].f64 * ctx.f[27].f64 + ctx.f[7].f64) as f32) as f64);
	// 82ED7974: EDAB6FFA  fmadds f13, f11, f31, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[31].f64 + ctx.f[13].f64) as f32) as f64);
	// 82ED7978: FD800050  fneg f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82ED797C: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82ED7980: 41980014  blt cr6, 0x82ed7994
	if ctx.cr[6].lt {
	pc = 0x82ED7994; continue 'dispatch;
	}
	// 82ED7984: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ED7988: 4199000C  bgt cr6, 0x82ed7994
	if ctx.cr[6].gt {
	pc = 0x82ED7994; continue 'dispatch;
	}
	pc = 0x82ED798C; continue 'dispatch;
            }
            0x82ED798C => {
    //   block [0x82ED798C..0x82ED7994)
	// 82ED798C: FC00D090  fmr f0, f26
	ctx.f[0].f64 = ctx.f[26].f64;
	// 82ED7990: 48000024  b 0x82ed79b4
	pc = 0x82ED79B4; continue 'dispatch;
            }
            0x82ED7994 => {
    //   block [0x82ED7994..0x82ED79B4)
	// 82ED7994: FF06D000  fcmpu cr6, f6, f26
	ctx.cr[6].compare_f64(ctx.f[6].f64, ctx.f[26].f64);
	// 82ED7998: 4198FFF4  blt cr6, 0x82ed798c
	if ctx.cr[6].lt {
	pc = 0x82ED798C; continue 'dispatch;
	}
	// 82ED799C: FF05D000  fcmpu cr6, f5, f26
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[26].f64);
	// 82ED79A0: 409800E8  bge cr6, 0x82ed7a88
	if !ctx.cr[6].lt {
	pc = 0x82ED7A88; continue 'dispatch;
	}
	// 82ED79A4: EC062824  fdivs f0, f6, f5
	ctx.f[0].f64 = ((ctx.f[6].f64 / ctx.f[5].f64) as f32) as f64;
	// 82ED79A8: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82ED79AC: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82ED79B0: 419800D8  blt cr6, 0x82ed7a88
	if ctx.cr[6].lt {
	pc = 0x82ED7A88; continue 'dispatch;
	}
	pc = 0x82ED79B4; continue 'dispatch;
            }
            0x82ED79B4 => {
    //   block [0x82ED79B4..0x82ED79D0)
	// 82ED79B4: C17F00B4  lfs f11, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED79B8: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82ED79BC: 40990034  ble cr6, 0x82ed79f0
	if !ctx.cr[6].gt {
	pc = 0x82ED79F0; continue 'dispatch;
	}
	// 82ED79C0: FF19E800  fcmpu cr6, f25, f29
	ctx.cr[6].compare_f64(ctx.f[25].f64, ctx.f[29].f64);
	// 82ED79C4: 4099000C  ble cr6, 0x82ed79d0
	if !ctx.cr[6].gt {
	pc = 0x82ED79D0; continue 'dispatch;
	}
	// 82ED79C8: FD80C890  fmr f12, f25
	ctx.f[12].f64 = ctx.f[25].f64;
	// 82ED79CC: 48000008  b 0x82ed79d4
	pc = 0x82ED79D4; continue 'dispatch;
            }
            0x82ED79D0 => {
    //   block [0x82ED79D0..0x82ED79D4)
	// 82ED79D0: FD80E890  fmr f12, f29
	ctx.f[12].f64 = ctx.f[29].f64;
	pc = 0x82ED79D4; continue 'dispatch;
            }
            0x82ED79D4 => {
    //   block [0x82ED79D4..0x82ED79F0)
	// 82ED79D4: C15F00F8  lfs f10, 0xf8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82ED79D8: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82ED79DC: ED8A0332  fmuls f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 * ctx.f[12].f64) as f32) as f64);
	// 82ED79E0: C1AB11D0  lfs f13, 0x11d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4560 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED79E4: EDAC5B7A  fmadds f13, f12, f13, f11
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 82ED79E8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED79EC: 4199009C  bgt cr6, 0x82ed7a88
	if ctx.cr[6].gt {
	pc = 0x82ED7A88; continue 'dispatch;
	}
	pc = 0x82ED79F0; continue 'dispatch;
            }
            0x82ED79F0 => {
    //   block [0x82ED79F0..0x82ED7A04)
	// 82ED79F0: C1BF00F8  lfs f13, 0xf8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED79F4: EC0D01FC  fnmsubs f0, f13, f7, f0
	ctx.f[0].f64 = -(((ctx.f[13].f64 * ctx.f[7].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED79F8: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82ED79FC: 40980008  bge cr6, 0x82ed7a04
	if !ctx.cr[6].lt {
	pc = 0x82ED7A04; continue 'dispatch;
	}
	// 82ED7A00: FC00D090  fmr f0, f26
	ctx.f[0].f64 = ctx.f[26].f64;
	pc = 0x82ED7A04; continue 'dispatch;
            }
            0x82ED7A04 => {
    //   block [0x82ED7A04..0x82ED7A88)
	// 82ED7A04: C19E004C  lfs f12, 0x4c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED7A08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED7A0C: FD006090  fmr f8, f12
	ctx.f[8].f64 = ctx.f[12].f64;
	// 82ED7A10: C13F00A8  lfs f9, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82ED7A14: C15E0054  lfs f10, 0x54(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82ED7A18: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82ED7A1C: C0FF00B0  lfs f7, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82ED7A20: FC20C890  fmr f1, f25
	ctx.f[1].f64 = ctx.f[25].f64;
	// 82ED7A24: C1BE0058  lfs f13, 0x58(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED7A28: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82ED7A2C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED7A30: C17E0050  lfs f11, 0x50(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED7A34: C0DE0034  lfs f6, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82ED7A38: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82ED7A3C: C0BE0038  lfs f5, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82ED7A40: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82ED7A44: C09E003C  lfs f4, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82ED7A48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED7A4C: ED290232  fmuls f9, f9, f8
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[8].f64) as f32) as f64);
	// 82ED7A50: FD005090  fmr f8, f10
	ctx.f[8].f64 = ctx.f[10].f64;
	// 82ED7A54: ED2849FA  fmadds f9, f8, f7, f9
	ctx.f[9].f64 = (((ctx.f[8].f64 * ctx.f[7].f64 + ctx.f[9].f64) as f32) as f64);
	// 82ED7A58: EC690372  fmuls f3, f9, f13
	ctx.f[3].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED7A5C: EDAC0032  fmuls f13, f12, f0
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED7A60: ED8B0032  fmuls f12, f11, f0
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED7A64: EC0A0032  fmuls f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED7A68: EDA6682A  fadds f13, f6, f13
	ctx.f[13].f64 = ((ctx.f[6].f64 + ctx.f[13].f64) as f32) as f64;
	// 82ED7A6C: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82ED7A70: EDA5602A  fadds f13, f5, f12
	ctx.f[13].f64 = ((ctx.f[5].f64 + ctx.f[12].f64) as f32) as f64;
	// 82ED7A74: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82ED7A78: EC04002A  fadds f0, f4, f0
	ctx.f[0].f64 = ((ctx.f[4].f64 + ctx.f[0].f64) as f32) as f64;
	// 82ED7A7C: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82ED7A80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED7A84: 4E800421  bctrl
	ctx.lr = 0x82ED7A88;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED7A88 => {
    //   block [0x82ED7A88..0x82ED7A98)
	// 82ED7A88: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82ED7A8C: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82ED7A90: 4BDD6289  bl 0x82cadd18
	ctx.lr = 0x82ED7A94;
	sub_82CADCEC(ctx, base);
	// 82ED7A94: 4BDD19C4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED7A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ED7A98 size=572
    let mut pc: u32 = 0x82ED7A98;
    'dispatch: loop {
        match pc {
            0x82ED7A98 => {
    //   block [0x82ED7A98..0x82ED7B20)
	// 82ED7A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED7A9C: 4BDD196D  bl 0x82ca9408
	ctx.lr = 0x82ED7AA0;
	sub_82CA93D0(ctx, base);
	// 82ED7AA0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED7AA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED7AA8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ED7AAC: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 82ED7AB0: 9BDF00E5  stb r30, 0xe5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(229 as u32), ctx.r[30].u8 ) };
	// 82ED7AB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED7AB8: 409A0214  bne cr6, 0x82ed7ccc
	if !ctx.cr[6].eq {
	pc = 0x82ED7CCC; continue 'dispatch;
	}
	// 82ED7ABC: 3B9F005C  addi r28, r31, 0x5c
	ctx.r[28].s64 = ctx.r[31].s64 + 92;
	// 82ED7AC0: C01F0080  lfs f0, 0x80(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED7AC4: C19F0084  lfs f12, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED7AC8: C17F00F8  lfs f11, 0xf8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED7ACC: C15F0008  lfs f10, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82ED7AD0: C1BC0000  lfs f13, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED7AD4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82ED7AD8: C1BC0004  lfs f13, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED7ADC: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82ED7AE0: C13C0008  lfs f9, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82ED7AE4: C19F0088  lfs f12, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED7AE8: ED8C4828  fsubs f12, f12, f9
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 82ED7AEC: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED7AF0: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82ED7AF4: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82ED7AF8: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82ED7AFC: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82ED7B00: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82ED7B04: 4098001C  bge cr6, 0x82ed7b20
	if !ctx.cr[6].lt {
	pc = 0x82ED7B20; continue 'dispatch;
	}
	// 82ED7B08: C01F0074  lfs f0, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED7B0C: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82ED7B10: C01F0078  lfs f0, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED7B14: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82ED7B18: C01F007C  lfs f0, 0x7c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED7B1C: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	pc = 0x82ED7B20; continue 'dispatch;
            }
            0x82ED7B20 => {
    //   block [0x82ED7B20..0x82ED7B3C)
	// 82ED7B20: 4B388E99  bl 0x822609b8
	ctx.lr = 0x82ED7B24;
	sub_822609B8(ctx, base);
	// 82ED7B24: 897F00E4  lbz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 82ED7B28: C003004C  lfs f0, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED7B2C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED7B30: 4182000C  beq 0x82ed7b3c
	if ctx.cr[0].eq {
	pc = 0x82ED7B3C; continue 'dispatch;
	}
	// 82ED7B34: 9BDF00E4  stb r30, 0xe4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[30].u8 ) };
	// 82ED7B38: 48000010  b 0x82ed7b48
	pc = 0x82ED7B48; continue 'dispatch;
            }
            0x82ED7B3C => {
    //   block [0x82ED7B3C..0x82ED7B48)
	// 82ED7B3C: C1BF00C0  lfs f13, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED7B40: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED7B44: 41980188  blt cr6, 0x82ed7ccc
	if ctx.cr[6].lt {
	pc = 0x82ED7CCC; continue 'dispatch;
	}
	pc = 0x82ED7B48; continue 'dispatch;
            }
            0x82ED7B48 => {
    //   block [0x82ED7B48..0x82ED7B90)
	// 82ED7B48: C1BF0008  lfs f13, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED7B4C: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ED7B50: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82ED7B54: D01F00C0  stfs f0, 0xc0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82ED7B58: 4B2EC791  bl 0x821c42e8
	ctx.lr = 0x82ED7B5C;
	sub_821C42E8(ctx, base);
	// 82ED7B5C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ED7B60: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82ED7B64: 906BE1DC  stw r3, -0x1e24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-7716 as u32), ctx.r[3].u32 ) };
	// 82ED7B68: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED7B6C: C19F00BC  lfs f12, 0xbc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED7B70: 995F00E5  stb r10, 0xe5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(229 as u32), ctx.r[10].u8 ) };
	// 82ED7B74: C17F00F8  lfs f11, 0xf8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED7B78: C01F003C  lfs f0, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED7B7C: C1AB0BFC  lfs f13, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED7B80: EDAC6AFA  fmadds f13, f12, f11, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 82ED7B84: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED7B88: 41980008  blt cr6, 0x82ed7b90
	if ctx.cr[6].lt {
	pc = 0x82ED7B90; continue 'dispatch;
	}
	// 82ED7B8C: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82ED7B90; continue 'dispatch;
            }
            0x82ED7B90 => {
    //   block [0x82ED7B90..0x82ED7BC4)
	// 82ED7B90: C05F0040  lfs f2, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82ED7B94: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ED7B98: D01F00B4  stfs f0, 0xb4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82ED7B9C: FC600090  fmr f3, f0
	ctx.f[3].f64 = ctx.f[0].f64;
	// 82ED7BA0: FC201050  fneg f1, f2
	ctx.f[1].u64 = ctx.f[2].u64 ^ 0x8000_0000_0000_0000u64;
	// 82ED7BA4: 480051C5  bl 0x82edcd68
	ctx.lr = 0x82ED7BA8;
	sub_82EDCD68(ctx, base);
	// 82ED7BA8: 807F004C  lwz r3, 0x4c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82ED7BAC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED7BB0: 41820070  beq 0x82ed7c20
	if ctx.cr[0].eq {
	pc = 0x82ED7C20; continue 'dispatch;
	}
	// 82ED7BB4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82ED7BB8: C03F0004  lfs f1, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ED7BBC: 4BFB00ED  bl 0x82e87ca8
	ctx.lr = 0x82ED7BC0;
	sub_82E87CA8(ctx, base);
	// 82ED7BC0: 48000054  b 0x82ed7c14
	pc = 0x82ED7C14; continue 'dispatch;
            }
            0x82ED7BC4 => {
    //   block [0x82ED7BC4..0x82ED7BF4)
	// 82ED7BC4: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ED7BC8: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82ED7BCC: 419A0040  beq cr6, 0x82ed7c0c
	if ctx.cr[6].eq {
	pc = 0x82ED7C0C; continue 'dispatch;
	}
	// 82ED7BD0: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82ED7BD4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED7BD8: 4182001C  beq 0x82ed7bf4
	if ctx.cr[0].eq {
	pc = 0x82ED7BF4; continue 'dispatch;
	}
	// 82ED7BDC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ED7BE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED7BE4: 4E800421  bctrl
	ctx.lr = 0x82ED7BE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED7BE8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82ED7BEC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ED7BF0: 409A001C  bne cr6, 0x82ed7c0c
	if !ctx.cr[6].eq {
	pc = 0x82ED7C0C; continue 'dispatch;
	}
            }
            0x82ED7BF4 => {
    //   block [0x82ED7BF4..0x82ED7C0C)
	// 82ED7BF4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED7BF8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ED7BFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED7C00: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ED7C04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED7C08: 4E800421  bctrl
	ctx.lr = 0x82ED7C0C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED7C0C => {
    //   block [0x82ED7C0C..0x82ED7C14)
	// 82ED7C0C: 807F004C  lwz r3, 0x4c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82ED7C10: 4BFAFB61  bl 0x82e87770
	ctx.lr = 0x82ED7C14;
	sub_82E87770(ctx, base);
	pc = 0x82ED7C14; continue 'dispatch;
            }
            0x82ED7C14 => {
    //   block [0x82ED7C14..0x82ED7C20)
	// 82ED7C14: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82ED7C18: 4082FFAC  bne 0x82ed7bc4
	if !ctx.cr[0].eq {
	pc = 0x82ED7BC4; continue 'dispatch;
	}
	// 82ED7C1C: 480000B0  b 0x82ed7ccc
	pc = 0x82ED7CCC; continue 'dispatch;
            }
            0x82ED7C20 => {
    //   block [0x82ED7C20..0x82ED7C34)
	// 82ED7C20: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82ED7C24: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82ED7C28: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED7C2C: 83AB0008  lwz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED7C30: 48000094  b 0x82ed7cc4
	pc = 0x82ED7CC4; continue 'dispatch;
            }
            0x82ED7C34 => {
    //   block [0x82ED7C34..0x82ED7C68)
	// 82ED7C34: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED7C38: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ED7C3C: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82ED7C40: 419A0080  beq cr6, 0x82ed7cc0
	if ctx.cr[6].eq {
	pc = 0x82ED7CC0; continue 'dispatch;
	}
	// 82ED7C44: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82ED7C48: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED7C4C: 4182001C  beq 0x82ed7c68
	if ctx.cr[0].eq {
	pc = 0x82ED7C68; continue 'dispatch;
	}
	// 82ED7C50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ED7C54: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED7C58: 4E800421  bctrl
	ctx.lr = 0x82ED7C5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED7C5C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82ED7C60: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ED7C64: 409A005C  bne cr6, 0x82ed7cc0
	if !ctx.cr[6].eq {
	pc = 0x82ED7CC0; continue 'dispatch;
	}
            }
            0x82ED7C68 => {
    //   block [0x82ED7C68..0x82ED7CC0)
	// 82ED7C68: C01F0004  lfs f0, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED7C6C: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED7C70: C1BC0000  lfs f13, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED7C74: C01E0034  lfs f0, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED7C78: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED7C7C: C19C0004  lfs f12, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED7C80: C1BE0038  lfs f13, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED7C84: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82ED7C88: C15E003C  lfs f10, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82ED7C8C: C19C0008  lfs f12, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED7C90: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82ED7C94: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED7C98: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82ED7C9C: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82ED7CA0: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82ED7CA4: 4098001C  bge cr6, 0x82ed7cc0
	if !ctx.cr[6].lt {
	pc = 0x82ED7CC0; continue 'dispatch;
	}
	// 82ED7CA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED7CAC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ED7CB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED7CB4: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ED7CB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED7CBC: 4E800421  bctrl
	ctx.lr = 0x82ED7CC0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED7CC0 => {
    //   block [0x82ED7CC0..0x82ED7CC4)
	// 82ED7CC0: 83BD000C  lwz r29, 0xc(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x82ED7CC4; continue 'dispatch;
            }
            0x82ED7CC4 => {
    //   block [0x82ED7CC4..0x82ED7CCC)
	// 82ED7CC4: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED7CC8: 4082FF6C  bne 0x82ed7c34
	if !ctx.cr[0].eq {
	pc = 0x82ED7C34; continue 'dispatch;
	}
	pc = 0x82ED7CCC; continue 'dispatch;
            }
            0x82ED7CCC => {
    //   block [0x82ED7CCC..0x82ED7CD4)
	// 82ED7CCC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82ED7CD0: 4BDD1788  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED7CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ED7CD8 size=1680
    let mut pc: u32 = 0x82ED7CD8;
    'dispatch: loop {
        match pc {
            0x82ED7CD8 => {
    //   block [0x82ED7CD8..0x82ED7DC8)
	// 82ED7CD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED7CDC: 4BDD171D  bl 0x82ca93f8
	ctx.lr = 0x82ED7CE0;
	sub_82CA93D0(ctx, base);
	// 82ED7CE0: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 82ED7CE4: 4BDD5FDD  bl 0x82cadcc0
	ctx.lr = 0x82ED7CE8;
	sub_82CADCA0(ctx, base);
	// 82ED7CE8: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED7CEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED7CF0: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED7CF4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED7CF8: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED7CFC: 4B2EC5ED  bl 0x821c42e8
	ctx.lr = 0x82ED7D00;
	sub_821C42E8(ctx, base);
	// 82ED7D00: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ED7D04: 816BE1DC  lwz r11, -0x1e24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7716 as u32) ) } as u64;
	// 82ED7D08: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82ED7D0C: 409A064C  bne cr6, 0x82ed8358
	if !ctx.cr[6].eq {
	pc = 0x82ED8358; continue 'dispatch;
	}
	// 82ED7D10: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED7D14: C01F0040  lfs f0, 0x40(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED7D18: C1BF00B4  lfs f13, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED7D1C: 3BDF005C  addi r30, r31, 0x5c
	ctx.r[30].s64 = ctx.r[31].s64 + 92;
	// 82ED7D20: C19F0090  lfs f12, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED7D24: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ED7D28: C17F0094  lfs f11, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED7D2C: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED7D30: C15F0098  lfs f10, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82ED7D34: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED7D38: C36A0010  lfs f27, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82ED7D3C: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED7D40: EDAD06F2  fmuls f13, f13, f27
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[27].f64) as f32) as f64);
	// 82ED7D44: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED7D48: C13F00A8  lfs f9, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82ED7D4C: 3B4BDAC0  addi r26, r11, -0x2540
	ctx.r[26].s64 = ctx.r[11].s64 + -9536;
	// 82ED7D50: C11F00AC  lfs f8, 0xac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82ED7D54: C0FF00B0  lfs f7, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82ED7D58: C0DE0004  lfs f6, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82ED7D5C: C0BE0008  lfs f5, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82ED7D60: 817A0048  lwz r11, 0x48(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED7D64: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82ED7D68: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82ED7D6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED7D70: ED855028  fsubs f12, f5, f10
	ctx.f[12].f64 = (((ctx.f[5].f64 - ctx.f[10].f64) as f32) as f64);
	// 82ED7D74: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82ED7D78: ED290372  fmuls f9, f9, f13
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED7D7C: ED080372  fmuls f8, f8, f13
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED7D80: ECE70372  fmuls f7, f7, f13
	ctx.f[7].f64 = (((ctx.f[7].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED7D84: EDA65828  fsubs f13, f6, f11
	ctx.f[13].f64 = (((ctx.f[6].f64 - ctx.f[11].f64) as f32) as f64);
	// 82ED7D88: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82ED7D8C: ED69002A  fadds f11, f9, f0
	ctx.f[11].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 82ED7D90: D1610060  stfs f11, 0x60(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82ED7D94: ED27602A  fadds f9, f7, f12
	ctx.f[9].f64 = ((ctx.f[7].f64 + ctx.f[12].f64) as f32) as f64;
	// 82ED7D98: D1210068  stfs f9, 0x68(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82ED7D9C: ED48682A  fadds f10, f8, f13
	ctx.f[10].f64 = ((ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64;
	// 82ED7DA0: D1410064  stfs f10, 0x64(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82ED7DA4: 419A0024  beq cr6, 0x82ed7dc8
	if ctx.cr[6].eq {
	pc = 0x82ED7DC8; continue 'dispatch;
	}
	// 82ED7DA8: 38E000FF  li r7, 0xff
	ctx.r[7].s64 = 255;
	// 82ED7DAC: 38C000FF  li r6, 0xff
	ctx.r[6].s64 = 255;
	// 82ED7DB0: 38A000FF  li r5, 0xff
	ctx.r[5].s64 = 255;
	// 82ED7DB4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82ED7DB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ED7DBC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED7DC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED7DC4: 4E800421  bctrl
	ctx.lr = 0x82ED7DC8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED7DC8 => {
    //   block [0x82ED7DC8..0x82ED7DF8)
	// 82ED7DC8: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ED7DCC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED7DD0: 832B0008  lwz r25, 8(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED7DD4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED7DD8: 28190000  cmplwi r25, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED7DDC: C32B0C18  lfs f25, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82ED7DE0: 4182023C  beq 0x82ed801c
	if ctx.cr[0].eq {
	pc = 0x82ED801C; continue 'dispatch;
	}
	// 82ED7DE4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ED7DE8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED7DEC: 3B000003  li r24, 3
	ctx.r[24].s64 = 3;
	// 82ED7DF0: C38A0BFC  lfs f28, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82ED7DF4: C34B0BEC  lfs f26, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	pc = 0x82ED7DF8; continue 'dispatch;
            }
            0x82ED7DF8 => {
    //   block [0x82ED7DF8..0x82ED7E10)
	// 82ED7DF8: C0190010  lfs f0, 0x10(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED7DFC: C1BF00B4  lfs f13, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED7E00: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED7E04: 4198000C  blt cr6, 0x82ed7e10
	if ctx.cr[6].lt {
	pc = 0x82ED7E10; continue 'dispatch;
	}
	// 82ED7E08: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82ED7E0C: 48000020  b 0x82ed7e2c
	pc = 0x82ED7E2C; continue 'dispatch;
            }
            0x82ED7E10 => {
    //   block [0x82ED7E10..0x82ED7E28)
	// 82ED7E10: FF00C800  fcmpu cr6, f0, f25
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[25].f64);
	// 82ED7E14: 41990014  bgt cr6, 0x82ed7e28
	if ctx.cr[6].gt {
	pc = 0x82ED7E28; continue 'dispatch;
	}
	// 82ED7E18: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82ED7E1C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82ED7E20: 3B6000FF  li r27, 0xff
	ctx.r[27].s64 = 255;
	// 82ED7E24: 48000010  b 0x82ed7e34
	pc = 0x82ED7E34; continue 'dispatch;
            }
            0x82ED7E28 => {
    //   block [0x82ED7E28..0x82ED7E2C)
	// 82ED7E28: 3BA000FF  li r29, 0xff
	ctx.r[29].s64 = 255;
	pc = 0x82ED7E2C; continue 'dispatch;
            }
            0x82ED7E2C => {
    //   block [0x82ED7E2C..0x82ED7E34)
	// 82ED7E2C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82ED7E30: 3B8000FF  li r28, 0xff
	ctx.r[28].s64 = 255;
	pc = 0x82ED7E34; continue 'dispatch;
            }
            0x82ED7E34 => {
    //   block [0x82ED7E34..0x82ED7E70)
	// 82ED7E34: 89790018  lbz r11, 0x18(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ED7E38: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED7E3C: 41820034  beq 0x82ed7e70
	if ctx.cr[0].eq {
	pc = 0x82ED7E70; continue 'dispatch;
	}
	// 82ED7E40: 57A9043E  clrlwi r9, r29, 0x10
	ctx.r[9].u64 = ctx.r[29].u32 as u64 & 0x0000FFFFu64;
	// 82ED7E44: 578A043E  clrlwi r10, r28, 0x10
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x0000FFFFu64;
	// 82ED7E48: 576B043E  clrlwi r11, r27, 0x10
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x0000FFFFu64;
	// 82ED7E4C: 392900FF  addi r9, r9, 0xff
	ctx.r[9].s64 = ctx.r[9].s64 + 255;
	// 82ED7E50: 394A00FF  addi r10, r10, 0xff
	ctx.r[10].s64 = ctx.r[10].s64 + 255;
	// 82ED7E54: 396B00FF  addi r11, r11, 0xff
	ctx.r[11].s64 = ctx.r[11].s64 + 255;
	// 82ED7E58: 7D29C3D6  divw r9, r9, r24
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[24].s32;
	// 82ED7E5C: 7D4AC3D6  divw r10, r10, r24
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[24].s32;
	// 82ED7E60: 7D6BC3D6  divw r11, r11, r24
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[24].s32;
	// 82ED7E64: 553D043E  clrlwi r29, r9, 0x10
	ctx.r[29].u64 = ctx.r[9].u32 as u64 & 0x0000FFFFu64;
	// 82ED7E68: 555C043E  clrlwi r28, r10, 0x10
	ctx.r[28].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 82ED7E6C: 557B043E  clrlwi r27, r11, 0x10
	ctx.r[27].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	pc = 0x82ED7E70; continue 'dispatch;
            }
            0x82ED7E70 => {
    //   block [0x82ED7E70..0x82ED7F08)
	// 82ED7E70: C0190010  lfs f0, 0x10(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED7E74: 817A0048  lwz r11, 0x48(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED7E78: EC0006F2  fmuls f0, f0, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82ED7E7C: C19F00A8  lfs f12, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED7E80: C17F00AC  lfs f11, 0xac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED7E84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED7E88: C15F00B0  lfs f10, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82ED7E8C: C1B90008  lfs f13, 8(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED7E90: C13F0094  lfs f9, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82ED7E94: C11E0000  lfs f8, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82ED7E98: ED290372  fmuls f9, f9, f13
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED7E9C: C0FE0004  lfs f7, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82ED7EA0: C0DE0008  lfs f6, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82ED7EA4: C0BF0098  lfs f5, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82ED7EA8: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82ED7EAC: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED7EB0: EC0A0032  fmuls f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED7EB4: C15F0090  lfs f10, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82ED7EB8: ED4A0372  fmuls f10, f10, f13
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED7EBC: EDA50372  fmuls f13, f5, f13
	ctx.f[13].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED7EC0: EFE8602A  fadds f31, f8, f12
	ctx.f[31].f64 = ((ctx.f[8].f64 + ctx.f[12].f64) as f32) as f64;
	// 82ED7EC4: EFCB382A  fadds f30, f11, f7
	ctx.f[30].f64 = ((ctx.f[11].f64 + ctx.f[7].f64) as f32) as f64;
	// 82ED7EC8: EFA0302A  fadds f29, f0, f6
	ctx.f[29].f64 = ((ctx.f[0].f64 + ctx.f[6].f64) as f32) as f64;
	// 82ED7ECC: EC0AF82A  fadds f0, f10, f31
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[31].f64) as f32) as f64;
	// 82ED7ED0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82ED7ED4: ED89F02A  fadds f12, f9, f30
	ctx.f[12].f64 = ((ctx.f[9].f64 + ctx.f[30].f64) as f32) as f64;
	// 82ED7ED8: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82ED7EDC: EDADE82A  fadds f13, f13, f29
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[29].f64) as f32) as f64;
	// 82ED7EE0: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82ED7EE4: 419A0024  beq cr6, 0x82ed7f08
	if ctx.cr[6].eq {
	pc = 0x82ED7F08; continue 'dispatch;
	}
	// 82ED7EE8: 38E00080  li r7, 0x80
	ctx.r[7].s64 = 128;
	// 82ED7EEC: 38C00080  li r6, 0x80
	ctx.r[6].s64 = 128;
	// 82ED7EF0: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 82ED7EF4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82ED7EF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ED7EFC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED7F00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED7F04: 4E800421  bctrl
	ctx.lr = 0x82ED7F08;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED7F08 => {
    //   block [0x82ED7F08..0x82ED7F68)
	// 82ED7F08: C019000C  lfs f0, 0xc(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED7F0C: 817A0048  lwz r11, 0x48(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED7F10: C1BF0090  lfs f13, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED7F14: C19F0094  lfs f12, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED7F18: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED7F1C: C17F0098  lfs f11, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED7F20: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED7F24: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED7F28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED7F2C: EDADF82A  fadds f13, f13, f31
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	// 82ED7F30: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82ED7F34: ED8CF02A  fadds f12, f12, f30
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[30].f64) as f32) as f64;
	// 82ED7F38: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82ED7F3C: EC00E82A  fadds f0, f0, f29
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 82ED7F40: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82ED7F44: 419A0024  beq cr6, 0x82ed7f68
	if ctx.cr[6].eq {
	pc = 0x82ED7F68; continue 'dispatch;
	}
	// 82ED7F48: 5767043E  clrlwi r7, r27, 0x10
	ctx.r[7].u64 = ctx.r[27].u32 as u64 & 0x0000FFFFu64;
	// 82ED7F4C: 5786043E  clrlwi r6, r28, 0x10
	ctx.r[6].u64 = ctx.r[28].u32 as u64 & 0x0000FFFFu64;
	// 82ED7F50: 57A5043E  clrlwi r5, r29, 0x10
	ctx.r[5].u64 = ctx.r[29].u32 as u64 & 0x0000FFFFu64;
	// 82ED7F54: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82ED7F58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ED7F5C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED7F60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED7F64: 4E800421  bctrl
	ctx.lr = 0x82ED7F68;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED7F68 => {
    //   block [0x82ED7F68..0x82ED8010)
	// 82ED7F68: C0190014  lfs f0, 0x14(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED7F6C: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82ED7F70: 409800A0  bge cr6, 0x82ed8010
	if !ctx.cr[6].lt {
	pc = 0x82ED8010; continue 'dispatch;
	}
	// 82ED7F74: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED7F78: 817A0048  lwz r11, 0x48(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED7F7C: C0010060  lfs f0, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED7F80: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82ED7F84: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED7F88: C1810054  lfs f12, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED7F8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED7F90: ED8D602A  fadds f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82ED7F94: C1A10068  lfs f13, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED7F98: C1610058  lfs f11, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED7F9C: ED6D582A  fadds f11, f13, f11
	ctx.f[11].f64 = ((ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64;
	// 82ED7FA0: C15F00A8  lfs f10, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82ED7FA4: C13F00AC  lfs f9, 0xac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82ED7FA8: C11F00B0  lfs f8, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82ED7FAC: EDA00732  fmuls f13, f0, f28
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 82ED7FB0: D1A10080  stfs f13, 0x80(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82ED7FB4: ED8C0732  fmuls f12, f12, f28
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[28].f64) as f32) as f64);
	// 82ED7FB8: D1810084  stfs f12, 0x84(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82ED7FBC: ED6B0732  fmuls f11, f11, f28
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[28].f64) as f32) as f64);
	// 82ED7FC0: D1610088  stfs f11, 0x88(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82ED7FC4: C0190014  lfs f0, 0x14(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED7FC8: ED4002B2  fmuls f10, f0, f10
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 82ED7FCC: ED290032  fmuls f9, f9, f0
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED7FD0: EC080032  fmuls f0, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED7FD4: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82ED7FD8: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82ED7FDC: EDA9602A  fadds f13, f9, f12
	ctx.f[13].f64 = ((ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64;
	// 82ED7FE0: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82ED7FE4: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 82ED7FE8: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82ED7FEC: 419A0024  beq cr6, 0x82ed8010
	if ctx.cr[6].eq {
	pc = 0x82ED8010; continue 'dispatch;
	}
	// 82ED7FF0: 5767043E  clrlwi r7, r27, 0x10
	ctx.r[7].u64 = ctx.r[27].u32 as u64 & 0x0000FFFFu64;
	// 82ED7FF4: 5786043E  clrlwi r6, r28, 0x10
	ctx.r[6].u64 = ctx.r[28].u32 as u64 & 0x0000FFFFu64;
	// 82ED7FF8: 57A5043E  clrlwi r5, r29, 0x10
	ctx.r[5].u64 = ctx.r[29].u32 as u64 & 0x0000FFFFu64;
	// 82ED7FFC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82ED8000: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82ED8004: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED8008: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED800C: 4E800421  bctrl
	ctx.lr = 0x82ED8010;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED8010 => {
    //   block [0x82ED8010..0x82ED801C)
	// 82ED8010: 83390020  lwz r25, 0x20(r25)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ED8014: 28190000  cmplwi r25, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED8018: 4082FDE0  bne 0x82ed7df8
	if !ctx.cr[0].eq {
	pc = 0x82ED7DF8; continue 'dispatch;
	}
	pc = 0x82ED801C; continue 'dispatch;
            }
            0x82ED801C => {
    //   block [0x82ED801C..0x82ED8088)
	// 82ED801C: C01F0040  lfs f0, 0x40(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8020: 817A0048  lwz r11, 0x48(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED8024: C1BF0090  lfs f13, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED8028: C19F0094  lfs f12, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED802C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED8030: C17F0098  lfs f11, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED8034: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED8038: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED803C: C15E0004  lfs f10, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82ED8040: C17E0000  lfs f11, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED8044: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED8048: C13E0008  lfs f9, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82ED804C: EDAD582A  fadds f13, f13, f11
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64;
	// 82ED8050: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82ED8054: ED8A602A  fadds f12, f10, f12
	ctx.f[12].f64 = ((ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64;
	// 82ED8058: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82ED805C: EC09002A  fadds f0, f9, f0
	ctx.f[0].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 82ED8060: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82ED8064: 419A0024  beq cr6, 0x82ed8088
	if ctx.cr[6].eq {
	pc = 0x82ED8088; continue 'dispatch;
	}
	// 82ED8068: 38E000FF  li r7, 0xff
	ctx.r[7].s64 = 255;
	// 82ED806C: 38C000FF  li r6, 0xff
	ctx.r[6].s64 = 255;
	// 82ED8070: 38A000FF  li r5, 0xff
	ctx.r[5].s64 = 255;
	// 82ED8074: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82ED8078: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ED807C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED8080: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED8084: 4E800421  bctrl
	ctx.lr = 0x82ED8088;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED8088 => {
    //   block [0x82ED8088..0x82ED80F8)
	// 82ED8088: C01F00B4  lfs f0, 0xb4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED808C: 817A0048  lwz r11, 0x48(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED8090: EC0006F2  fmuls f0, f0, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82ED8094: C1BF00A8  lfs f13, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED8098: C19F00AC  lfs f12, 0xac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED809C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED80A0: C17F00B0  lfs f11, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED80A4: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED80A8: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED80AC: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED80B0: C1610050  lfs f11, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED80B4: EDAD582A  fadds f13, f13, f11
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64;
	// 82ED80B8: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82ED80BC: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED80C0: EDAC682A  fadds f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 82ED80C4: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82ED80C8: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED80CC: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82ED80D0: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82ED80D4: 419A0024  beq cr6, 0x82ed80f8
	if ctx.cr[6].eq {
	pc = 0x82ED80F8; continue 'dispatch;
	}
	// 82ED80D8: 38E00080  li r7, 0x80
	ctx.r[7].s64 = 128;
	// 82ED80DC: 38C00080  li r6, 0x80
	ctx.r[6].s64 = 128;
	// 82ED80E0: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 82ED80E4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82ED80E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ED80EC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED80F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED80F4: 4E800421  bctrl
	ctx.lr = 0x82ED80F8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED80F8 => {
    //   block [0x82ED80F8..0x82ED8160)
	// 82ED80F8: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED80FC: C01F00B4  lfs f0, 0xb4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8100: C19F0040  lfs f12, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED8104: 39400007  li r10, 7
	ctx.r[10].s64 = 7;
	// 82ED8108: C17F0098  lfs f11, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED810C: C13F00B8  lfs f9, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82ED8110: C15F009C  lfs f10, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82ED8114: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED8118: 39610098  addi r11, r1, 0x98
	ctx.r[11].s64 = ctx.r[1].s64 + 152;
	// 82ED811C: ECCD0032  fmuls f6, f13, f0
	ctx.f[6].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED8120: C01F0090  lfs f0, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8124: C1BF0094  lfs f13, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED8128: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED812C: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82ED8130: C11F00A0  lfs f8, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82ED8134: ED8B0332  fmuls f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82ED8138: C0FF00A4  lfs f7, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82ED813C: ED6A0272  fmuls f11, f10, f9
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[9].f64) as f32) as f64);
	// 82ED8140: C0BF00B0  lfs f5, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82ED8144: ED480272  fmuls f10, f8, f9
	ctx.f[10].f64 = (((ctx.f[8].f64 * ctx.f[9].f64) as f32) as f64);
	// 82ED8148: C11F00A8  lfs f8, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82ED814C: ED270272  fmuls f9, f7, f9
	ctx.f[9].f64 = (((ctx.f[7].f64 * ctx.f[9].f64) as f32) as f64);
	// 82ED8150: C0FF00AC  lfs f7, 0xac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82ED8154: ED0801B2  fmuls f8, f8, f6
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[6].f64) as f32) as f64);
	// 82ED8158: ECE701B2  fmuls f7, f7, f6
	ctx.f[7].f64 = (((ctx.f[7].f64 * ctx.f[6].f64) as f32) as f64);
	// 82ED815C: ECC501B2  fmuls f6, f5, f6
	ctx.f[6].f64 = (((ctx.f[5].f64 * ctx.f[6].f64) as f32) as f64);
	pc = 0x82ED8160; continue 'dispatch;
            }
            0x82ED8160 => {
    //   block [0x82ED8160..0x82ED82A4)
	// 82ED8160: D32BFFF8  stfs f25, -8(r11)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82ED8164: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82ED8168: D32BFFFC  stfs f25, -4(r11)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82ED816C: D32B0000  stfs f25, 0(r11)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82ED8170: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82ED8174: 4080FFEC  bge 0x82ed8160
	if !ctx.cr[0].lt {
	pc = 0x82ED8160; continue 'dispatch;
	}
	// 82ED8178: C0BE0000  lfs f5, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82ED817C: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82ED8180: C09E0004  lfs f4, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82ED8184: ECA50028  fsubs f5, f5, f0
	ctx.f[5].f64 = (((ctx.f[5].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED8188: C07E0008  lfs f3, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82ED818C: EC846828  fsubs f4, f4, f13
	ctx.f[4].f64 = (((ctx.f[4].f64 - ctx.f[13].f64) as f32) as f64);
	// 82ED8190: C05E0000  lfs f2, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82ED8194: EC636028  fsubs f3, f3, f12
	ctx.f[3].f64 = (((ctx.f[3].f64 - ctx.f[12].f64) as f32) as f64);
	// 82ED8198: C3DE0000  lfs f30, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82ED819C: EC420028  fsubs f2, f2, f0
	ctx.f[2].f64 = (((ctx.f[2].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED81A0: C37E0000  lfs f27, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82ED81A4: EFDE002A  fadds f30, f30, f0
	ctx.f[30].f64 = ((ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64;
	// 82ED81A8: C03E0004  lfs f1, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82ED81AC: EF7B002A  fadds f27, f27, f0
	ctx.f[27].f64 = ((ctx.f[27].f64 + ctx.f[0].f64) as f32) as f64;
	// 82ED81B0: C3FE0008  lfs f31, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82ED81B4: EC216828  fsubs f1, f1, f13
	ctx.f[1].f64 = (((ctx.f[1].f64 - ctx.f[13].f64) as f32) as f64);
	// 82ED81B8: C3BE0004  lfs f29, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82ED81BC: EFFF6028  fsubs f31, f31, f12
	ctx.f[31].f64 = (((ctx.f[31].f64 - ctx.f[12].f64) as f32) as f64);
	// 82ED81C0: C39E0008  lfs f28, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82ED81C4: EFBD682A  fadds f29, f29, f13
	ctx.f[29].f64 = ((ctx.f[29].f64 + ctx.f[13].f64) as f32) as f64;
	// 82ED81C8: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED81CC: EF9C602A  fadds f28, f28, f12
	ctx.f[28].f64 = ((ctx.f[28].f64 + ctx.f[12].f64) as f32) as f64;
	// 82ED81D0: C35E0004  lfs f26, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82ED81D4: EF20602A  fadds f25, f0, f12
	ctx.f[25].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 82ED81D8: EF5A682A  fadds f26, f26, f13
	ctx.f[26].f64 = ((ctx.f[26].f64 + ctx.f[13].f64) as f32) as f64;
	// 82ED81DC: 3BE10090  addi r31, r1, 0x90
	ctx.r[31].s64 = ctx.r[1].s64 + 144;
	// 82ED81E0: EC055828  fsubs f0, f5, f11
	ctx.f[0].f64 = (((ctx.f[5].f64 - ctx.f[11].f64) as f32) as f64);
	// 82ED81E4: 3B600004  li r27, 4
	ctx.r[27].s64 = 4;
	// 82ED81E8: EDA45028  fsubs f13, f4, f10
	ctx.f[13].f64 = (((ctx.f[4].f64 - ctx.f[10].f64) as f32) as f64);
	// 82ED81EC: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82ED81F0: ED834828  fsubs f12, f3, f9
	ctx.f[12].f64 = (((ctx.f[3].f64 - ctx.f[9].f64) as f32) as f64);
	// 82ED81F4: D1A10094  stfs f13, 0x94(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82ED81F8: ECA2582A  fadds f5, f2, f11
	ctx.f[5].f64 = ((ctx.f[2].f64 + ctx.f[11].f64) as f32) as f64;
	// 82ED81FC: D1810098  stfs f12, 0x98(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82ED8200: EC81502A  fadds f4, f1, f10
	ctx.f[4].f64 = ((ctx.f[1].f64 + ctx.f[10].f64) as f32) as f64;
	// 82ED8204: D0A1009C  stfs f5, 0x9c(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82ED8208: EC7F482A  fadds f3, f31, f9
	ctx.f[3].f64 = ((ctx.f[31].f64 + ctx.f[9].f64) as f32) as f64;
	// 82ED820C: D08100A0  stfs f4, 0xa0(r1)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82ED8210: EC5E582A  fadds f2, f30, f11
	ctx.f[2].f64 = ((ctx.f[30].f64 + ctx.f[11].f64) as f32) as f64;
	// 82ED8214: D06100A4  stfs f3, 0xa4(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82ED8218: EC3D502A  fadds f1, f29, f10
	ctx.f[1].f64 = ((ctx.f[29].f64 + ctx.f[10].f64) as f32) as f64;
	// 82ED821C: D04100A8  stfs f2, 0xa8(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82ED8220: EFFC482A  fadds f31, f28, f9
	ctx.f[31].f64 = ((ctx.f[28].f64 + ctx.f[9].f64) as f32) as f64;
	// 82ED8224: D02100AC  stfs f1, 0xac(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82ED8228: ED7B5828  fsubs f11, f27, f11
	ctx.f[11].f64 = (((ctx.f[27].f64 - ctx.f[11].f64) as f32) as f64);
	// 82ED822C: D3E100B0  stfs f31, 0xb0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82ED8230: ED5A5028  fsubs f10, f26, f10
	ctx.f[10].f64 = (((ctx.f[26].f64 - ctx.f[10].f64) as f32) as f64);
	// 82ED8234: D16100B4  stfs f11, 0xb4(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82ED8238: ED394828  fsubs f9, f25, f9
	ctx.f[9].f64 = (((ctx.f[25].f64 - ctx.f[9].f64) as f32) as f64);
	// 82ED823C: D14100B8  stfs f10, 0xb8(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82ED8240: EFC0402A  fadds f30, f0, f8
	ctx.f[30].f64 = ((ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64;
	// 82ED8244: D12100BC  stfs f9, 0xbc(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82ED8248: EFAD382A  fadds f29, f13, f7
	ctx.f[29].f64 = ((ctx.f[13].f64 + ctx.f[7].f64) as f32) as f64;
	// 82ED824C: D3C100C0  stfs f30, 0xc0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82ED8250: EF8C302A  fadds f28, f12, f6
	ctx.f[28].f64 = ((ctx.f[12].f64 + ctx.f[6].f64) as f32) as f64;
	// 82ED8254: D3A100C4  stfs f29, 0xc4(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82ED8258: EF65402A  fadds f27, f5, f8
	ctx.f[27].f64 = ((ctx.f[5].f64 + ctx.f[8].f64) as f32) as f64;
	// 82ED825C: D38100C8  stfs f28, 0xc8(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82ED8260: EF44382A  fadds f26, f4, f7
	ctx.f[26].f64 = ((ctx.f[4].f64 + ctx.f[7].f64) as f32) as f64;
	// 82ED8264: D36100CC  stfs f27, 0xcc(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82ED8268: EF23302A  fadds f25, f3, f6
	ctx.f[25].f64 = ((ctx.f[3].f64 + ctx.f[6].f64) as f32) as f64;
	// 82ED826C: D34100D0  stfs f26, 0xd0(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82ED8270: EF02402A  fadds f24, f2, f8
	ctx.f[24].f64 = ((ctx.f[2].f64 + ctx.f[8].f64) as f32) as f64;
	// 82ED8274: D32100D4  stfs f25, 0xd4(r1)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82ED8278: EEE1382A  fadds f23, f1, f7
	ctx.f[23].f64 = ((ctx.f[1].f64 + ctx.f[7].f64) as f32) as f64;
	// 82ED827C: D30100D8  stfs f24, 0xd8(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82ED8280: EEDF302A  fadds f22, f31, f6
	ctx.f[22].f64 = ((ctx.f[31].f64 + ctx.f[6].f64) as f32) as f64;
	// 82ED8284: D2E100DC  stfs f23, 0xdc(r1)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82ED8288: ED0B402A  fadds f8, f11, f8
	ctx.f[8].f64 = ((ctx.f[11].f64 + ctx.f[8].f64) as f32) as f64;
	// 82ED828C: D2C100E0  stfs f22, 0xe0(r1)
	tmp.f32 = (ctx.f[22].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82ED8290: ECEA382A  fadds f7, f10, f7
	ctx.f[7].f64 = ((ctx.f[10].f64 + ctx.f[7].f64) as f32) as f64;
	// 82ED8294: D10100E4  stfs f8, 0xe4(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82ED8298: ECC9302A  fadds f6, f9, f6
	ctx.f[6].f64 = ((ctx.f[9].f64 + ctx.f[6].f64) as f32) as f64;
	// 82ED829C: D0E100E8  stfs f7, 0xe8(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82ED82A0: D0C100EC  stfs f6, 0xec(r1)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), tmp.u32 ) };
	pc = 0x82ED82A4; continue 'dispatch;
            }
            0x82ED82A4 => {
    //   block [0x82ED82A4..0x82ED8348)
	// 82ED82A4: 817A0048  lwz r11, 0x48(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED82A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED82AC: 419A009C  beq cr6, 0x82ed8348
	if ctx.cr[6].eq {
	pc = 0x82ED8348; continue 'dispatch;
	}
	// 82ED82B0: 7F8B1670  srawi r11, r28, 2
	ctx.xer.ca = (ctx.r[28].s32 < 0) && ((ctx.r[28].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[28].s32 >> 2) as i64;
	// 82ED82B4: 38E000C8  li r7, 0xc8
	ctx.r[7].s64 = 200;
	// 82ED82B8: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82ED82BC: 38C000C8  li r6, 0xc8
	ctx.r[6].s64 = 200;
	// 82ED82C0: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82ED82C4: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 82ED82C8: 7D4AE050  subf r10, r10, r28
	ctx.r[10].s64 = ctx.r[28].s64 - ctx.r[10].s64;
	// 82ED82CC: 38A000C8  li r5, 0xc8
	ctx.r[5].s64 = 200;
	// 82ED82D0: 1FCA000C  mulli r30, r10, 0xc
	ctx.r[30].s32 = ((ctx.r[10].s32 as i64 * 12 as i64) as i32);
	ctx.r[30].s64 = ctx.r[30].s32 as i64;
	// 82ED82D4: 815A0048  lwz r10, 0x48(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED82D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED82DC: 7C9E5A14  add r4, r30, r11
	ctx.r[4].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82ED82E0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82ED82E4: 4E800421  bctrl
	ctx.lr = 0x82ED82E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED82E8: 817A0048  lwz r11, 0x48(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED82EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED82F0: 419A0058  beq cr6, 0x82ed8348
	if ctx.cr[6].eq {
	pc = 0x82ED8348; continue 'dispatch;
	}
	// 82ED82F4: 396100C0  addi r11, r1, 0xc0
	ctx.r[11].s64 = ctx.r[1].s64 + 192;
	// 82ED82F8: 3BBF0030  addi r29, r31, 0x30
	ctx.r[29].s64 = ctx.r[31].s64 + 48;
	// 82ED82FC: 7C9E5A14  add r4, r30, r11
	ctx.r[4].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82ED8300: 817A0048  lwz r11, 0x48(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED8304: 38E000C8  li r7, 0xc8
	ctx.r[7].s64 = 200;
	// 82ED8308: 38C000C8  li r6, 0xc8
	ctx.r[6].s64 = 200;
	// 82ED830C: 38A000C8  li r5, 0xc8
	ctx.r[5].s64 = 200;
	// 82ED8310: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82ED8314: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED8318: 4E800421  bctrl
	ctx.lr = 0x82ED831C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED831C: 817A0048  lwz r11, 0x48(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED8320: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED8324: 419A0024  beq cr6, 0x82ed8348
	if ctx.cr[6].eq {
	pc = 0x82ED8348; continue 'dispatch;
	}
	// 82ED8328: 38E000C8  li r7, 0xc8
	ctx.r[7].s64 = 200;
	// 82ED832C: 38C000C8  li r6, 0xc8
	ctx.r[6].s64 = 200;
	// 82ED8330: 38A000C8  li r5, 0xc8
	ctx.r[5].s64 = 200;
	// 82ED8334: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ED8338: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED833C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED8340: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED8344: 4E800421  bctrl
	ctx.lr = 0x82ED8348;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED8348 => {
    //   block [0x82ED8348..0x82ED8358)
	// 82ED8348: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82ED834C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82ED8350: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82ED8354: 4082FF50  bne 0x82ed82a4
	if !ctx.cr[0].eq {
	pc = 0x82ED82A4; continue 'dispatch;
	}
	pc = 0x82ED8358; continue 'dispatch;
            }
            0x82ED8358 => {
    //   block [0x82ED8358..0x82ED8368)
	// 82ED8358: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 82ED835C: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 82ED8360: 4BDD59AD  bl 0x82cadd0c
	ctx.lr = 0x82ED8364;
	sub_82CADCEC(ctx, base);
	// 82ED8364: 4BDD10E4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED8368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED8368 size=96
    let mut pc: u32 = 0x82ED8368;
    'dispatch: loop {
        match pc {
            0x82ED8368 => {
    //   block [0x82ED8368..0x82ED83AC)
	// 82ED8368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED836C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED8370: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ED8374: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED8378: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED837C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED8380: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ED8384: 809F008C  lwz r4, 0x8c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82ED8388: 7F04F000  cmpw cr6, r4, r30
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[30].s32, &mut ctx.xer);
	// 82ED838C: 419A0024  beq cr6, 0x82ed83b0
	if ctx.cr[6].eq {
	pc = 0x82ED83B0; continue 'dispatch;
	}
	// 82ED8390: 817F0100  lwz r11, 0x100(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 82ED8394: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED8398: 41820014  beq 0x82ed83ac
	if ctx.cr[0].eq {
	pc = 0x82ED83AC; continue 'dispatch;
	}
	// 82ED839C: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ED83A0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ED83A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED83A8: 4E800421  bctrl
	ctx.lr = 0x82ED83AC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED83AC => {
    //   block [0x82ED83AC..0x82ED83B0)
	// 82ED83AC: 93DF008C  stw r30, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[30].u32 ) };
	pc = 0x82ED83B0; continue 'dispatch;
            }
            0x82ED83B0 => {
    //   block [0x82ED83B0..0x82ED83C8)
	// 82ED83B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ED83B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED83B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED83BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ED83C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED83C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED83C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ED83C8 size=328
    let mut pc: u32 = 0x82ED83C8;
    'dispatch: loop {
        match pc {
            0x82ED83C8 => {
    //   block [0x82ED83C8..0x82ED8458)
	// 82ED83C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED83CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED83D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED83D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED83D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED83DC: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82ED83E0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED83E4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ED83E8: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 82ED83EC: 419A00B8  beq cr6, 0x82ed84a4
	if ctx.cr[6].eq {
	pc = 0x82ED84A4; continue 'dispatch;
	}
	// 82ED83F0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ED83F4: C1AB0018  lfs f13, 0x18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED83F8: C00A0C18  lfs f0, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED83FC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ED8400: 419A00A0  beq cr6, 0x82ed84a0
	if ctx.cr[6].eq {
	pc = 0x82ED84A0; continue 'dispatch;
	}
	// 82ED8404: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED8408: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ED840C: 389F005C  addi r4, r31, 0x5c
	ctx.r[4].s64 = ctx.r[31].s64 + 92;
	// 82ED8410: 38AB0004  addi r5, r11, 4
	ctx.r[5].s64 = ctx.r[11].s64 + 4;
	// 82ED8414: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED8418: 816A0050  lwz r11, 0x50(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ED841C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED8420: 4E800421  bctrl
	ctx.lr = 0x82ED8424;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED8424: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED8428: 41820030  beq 0x82ed8458
	if ctx.cr[0].eq {
	pc = 0x82ED8458; continue 'dispatch;
	}
	// 82ED842C: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED8430: 38BF0074  addi r5, r31, 0x74
	ctx.r[5].s64 = ctx.r[31].s64 + 116;
	// 82ED8434: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 82ED8438: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82ED843C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED8440: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82ED8444: 816A0050  lwz r11, 0x50(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ED8448: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED844C: 4E800421  bctrl
	ctx.lr = 0x82ED8450;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED8450: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED8454: 4082004C  bne 0x82ed84a0
	if !ctx.cr[0].eq {
	pc = 0x82ED84A0; continue 'dispatch;
	}
            }
            0x82ED8458 => {
    //   block [0x82ED8458..0x82ED8474)
	// 82ED8458: 817F00FC  lwz r11, 0xfc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 82ED845C: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82ED8460: 419A0014  beq cr6, 0x82ed8474
	if ctx.cr[6].eq {
	pc = 0x82ED8474; continue 'dispatch;
	}
	// 82ED8464: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82ED8468: 419A000C  beq cr6, 0x82ed8474
	if ctx.cr[6].eq {
	pc = 0x82ED8474; continue 'dispatch;
	}
	// 82ED846C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82ED8470: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED8474; continue 'dispatch;
            }
            0x82ED8474 => {
    //   block [0x82ED8474..0x82ED84A0)
	// 82ED8474: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 82ED8478: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ED847C: 917F00E0  stw r11, 0xe0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	// 82ED8480: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED8484: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED8488: 409A0074  bne cr6, 0x82ed84fc
	if !ctx.cr[6].eq {
	pc = 0x82ED84FC; continue 'dispatch;
	}
	// 82ED848C: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82ED8490: C01F0024  lfs f0, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8494: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82ED8498: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 82ED849C: 48000060  b 0x82ed84fc
	pc = 0x82ED84FC; continue 'dispatch;
            }
            0x82ED84A0 => {
    //   block [0x82ED84A0..0x82ED84A4)
	// 82ED84A0: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	pc = 0x82ED84A4; continue 'dispatch;
            }
            0x82ED84A4 => {
    //   block [0x82ED84A4..0x82ED84FC)
	// 82ED84A4: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED84A8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ED84AC: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82ED84B0: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED84B4: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82ED84B8: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED84BC: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82ED84C0: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 82ED84C4: C00B0018  lfs f0, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED84C8: D01F00C8  stfs f0, 0xc8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82ED84CC: D01F00CC  stfs f0, 0xcc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82ED84D0: C00B001C  lfs f0, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED84D4: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82ED84D8: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED84DC: D01F00D0  stfs f0, 0xd0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82ED84E0: C00B0020  lfs f0, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED84E4: D01F00D8  stfs f0, 0xd8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82ED84E8: 915F00E0  stw r10, 0xe0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[10].u32 ) };
	// 82ED84EC: 817F00FC  lwz r11, 0xfc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 82ED84F0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82ED84F4: 419A0008  beq cr6, 0x82ed84fc
	if ctx.cr[6].eq {
	pc = 0x82ED84FC; continue 'dispatch;
	}
	// 82ED84F8: 915F00FC  stw r10, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[10].u32 ) };
	pc = 0x82ED84FC; continue 'dispatch;
            }
            0x82ED84FC => {
    //   block [0x82ED84FC..0x82ED8510)
	// 82ED84FC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ED8500: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED8504: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED8508: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED850C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED8510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ED8510 size=504
    let mut pc: u32 = 0x82ED8510;
    'dispatch: loop {
        match pc {
            0x82ED8510 => {
    //   block [0x82ED8510..0x82ED8558)
	// 82ED8510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED8514: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED8518: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED851C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED8520: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED8524: 817F00FC  lwz r11, 0xfc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 82ED8528: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82ED852C: 41980050  blt cr6, 0x82ed857c
	if ctx.cr[6].lt {
	pc = 0x82ED857C; continue 'dispatch;
	}
	// 82ED8530: 419A0044  beq cr6, 0x82ed8574
	if ctx.cr[6].eq {
	pc = 0x82ED8574; continue 'dispatch;
	}
	// 82ED8534: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82ED8538: 419A0020  beq cr6, 0x82ed8558
	if ctx.cr[6].eq {
	pc = 0x82ED8558; continue 'dispatch;
	}
	// 82ED853C: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82ED8540: 409A01B4  bne cr6, 0x82ed86f4
	if !ctx.cr[6].eq {
	pc = 0x82ED86F4; continue 'dispatch;
	}
	// 82ED8544: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82ED8548: 4BFFFE21  bl 0x82ed8368
	ctx.lr = 0x82ED854C;
	sub_82ED8368(ctx, base);
	// 82ED854C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED8550: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8554: 48000018  b 0x82ed856c
	pc = 0x82ED856C; continue 'dispatch;
            }
            0x82ED8558 => {
    //   block [0x82ED8558..0x82ED856C)
	// 82ED8558: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82ED855C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED8560: 4BFFFE09  bl 0x82ed8368
	ctx.lr = 0x82ED8564;
	sub_82ED8368(ctx, base);
	// 82ED8564: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED8568: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82ED856C; continue 'dispatch;
            }
            0x82ED856C => {
    //   block [0x82ED856C..0x82ED8574)
	// 82ED856C: D01F00D8  stfs f0, 0xd8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82ED8570: 48000184  b 0x82ed86f4
	pc = 0x82ED86F4; continue 'dispatch;
            }
            0x82ED8574 => {
    //   block [0x82ED8574..0x82ED857C)
	// 82ED8574: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82ED8578: 48000174  b 0x82ed86ec
	pc = 0x82ED86EC; continue 'dispatch;
            }
            0x82ED857C => {
    //   block [0x82ED857C..0x82ED85CC)
	// 82ED857C: 897F0014  lbz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED8580: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED8584: 418200E8  beq 0x82ed866c
	if ctx.cr[0].eq {
	pc = 0x82ED866C; continue 'dispatch;
	}
	// 82ED8588: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED858C: C1BF0044  lfs f13, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED8590: C16B0C18  lfs f11, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED8594: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82ED8598: 419A00B4  beq cr6, 0x82ed864c
	if ctx.cr[6].eq {
	pc = 0x82ED864C; continue 'dispatch;
	}
	// 82ED859C: C19F00D4  lfs f12, 0xd4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED85A0: C01F00B4  lfs f0, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED85A4: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82ED85A8: 409800A4  bge cr6, 0x82ed864c
	if !ctx.cr[6].lt {
	pc = 0x82ED864C; continue 'dispatch;
	}
	// 82ED85AC: C01F00F8  lfs f0, 0xf8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED85B0: C15F00BC  lfs f10, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82ED85B4: C13F003C  lfs f9, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82ED85B8: EC0002B2  fmuls f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 82ED85BC: EDA90372  fmuls f13, f9, f13
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED85C0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED85C4: 41980008  blt cr6, 0x82ed85cc
	if ctx.cr[6].lt {
	pc = 0x82ED85CC; continue 'dispatch;
	}
	// 82ED85C8: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82ED85CC; continue 'dispatch;
            }
            0x82ED85CC => {
    //   block [0x82ED85CC..0x82ED8624)
	// 82ED85CC: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82ED85D0: 4199007C  bgt cr6, 0x82ed864c
	if ctx.cr[6].gt {
	pc = 0x82ED864C; continue 'dispatch;
	}
	// 82ED85D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED85D8: C1BF0018  lfs f13, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED85DC: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED85E0: C19F00D8  lfs f12, 0xd8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED85E4: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED85E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED85EC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82ED85F0: C1AA0010  lfs f13, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED85F4: ED400372  fmuls f10, f0, f13
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED85F8: C00B0A7C  lfs f0, 0xa7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED85FC: EC0A0032  fmuls f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED8600: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82ED8604: 41990048  bgt cr6, 0x82ed864c
	if ctx.cr[6].gt {
	pc = 0x82ED864C; continue 'dispatch;
	}
	// 82ED8608: C01F001C  lfs f0, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED860C: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82ED8610: 40990014  ble cr6, 0x82ed8624
	if !ctx.cr[6].gt {
	pc = 0x82ED8624; continue 'dispatch;
	}
	// 82ED8614: D17F00D8  stfs f11, 0xd8(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82ED8618: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82ED861C: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82ED8620: 480000CC  b 0x82ed86ec
	pc = 0x82ED86EC; continue 'dispatch;
            }
            0x82ED8624 => {
    //   block [0x82ED8624..0x82ED8644)
	// 82ED8624: C01F0020  lfs f0, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8628: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED862C: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82ED8630: 40990014  ble cr6, 0x82ed8644
	if !ctx.cr[6].gt {
	pc = 0x82ED8644; continue 'dispatch;
	}
	// 82ED8634: D1BF00D8  stfs f13, 0xd8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82ED8638: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82ED863C: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82ED8640: 480000B0  b 0x82ed86f0
	pc = 0x82ED86F0; continue 'dispatch;
            }
            0x82ED8644 => {
    //   block [0x82ED8644..0x82ED864C)
	// 82ED8644: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82ED8648: 480000A8  b 0x82ed86f0
	pc = 0x82ED86F0; continue 'dispatch;
            }
            0x82ED864C => {
    //   block [0x82ED864C..0x82ED866C)
	// 82ED864C: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED8650: C01F00D8  lfs f0, 0xd8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8654: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED8658: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED865C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED8660: 4098FFE4  bge cr6, 0x82ed8644
	if !ctx.cr[6].lt {
	pc = 0x82ED8644; continue 'dispatch;
	}
	// 82ED8664: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ED8668: 48000088  b 0x82ed86f0
	pc = 0x82ED86F0; continue 'dispatch;
            }
            0x82ED866C => {
    //   block [0x82ED866C..0x82ED8690)
	// 82ED866C: C1BF00BC  lfs f13, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED8670: C01F00F8  lfs f0, 0xf8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8674: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED8678: C19F0044  lfs f12, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED867C: C1BF003C  lfs f13, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED8680: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED8684: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED8688: 41980008  blt cr6, 0x82ed8690
	if ctx.cr[6].lt {
	pc = 0x82ED8690; continue 'dispatch;
	}
	// 82ED868C: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82ED8690; continue 'dispatch;
            }
            0x82ED8690 => {
    //   block [0x82ED8690..0x82ED86C0)
	// 82ED8690: C1BF00D4  lfs f13, 0xd4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED8694: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ED8698: 40980050  bge cr6, 0x82ed86e8
	if !ctx.cr[6].lt {
	pc = 0x82ED86E8; continue 'dispatch;
	}
	// 82ED869C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED86A0: C1BF001C  lfs f13, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED86A4: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED86A8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ED86AC: 40990014  ble cr6, 0x82ed86c0
	if !ctx.cr[6].gt {
	pc = 0x82ED86C0; continue 'dispatch;
	}
	// 82ED86B0: D01F00D8  stfs f0, 0xd8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82ED86B4: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82ED86B8: D1BF00E8  stfs f13, 0xe8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82ED86BC: 48000030  b 0x82ed86ec
	pc = 0x82ED86EC; continue 'dispatch;
            }
            0x82ED86C0 => {
    //   block [0x82ED86C0..0x82ED86E8)
	// 82ED86C0: C1BF0020  lfs f13, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED86C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED86C8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ED86CC: 4099FF78  ble cr6, 0x82ed8644
	if !ctx.cr[6].gt {
	pc = 0x82ED8644; continue 'dispatch;
	}
	// 82ED86D0: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED86D4: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82ED86D8: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED86DC: D01F00D8  stfs f0, 0xd8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82ED86E0: D1BF00E8  stfs f13, 0xe8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82ED86E4: 4800000C  b 0x82ed86f0
	pc = 0x82ED86F0; continue 'dispatch;
            }
            0x82ED86E8 => {
    //   block [0x82ED86E8..0x82ED86EC)
	// 82ED86E8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x82ED86EC; continue 'dispatch;
            }
            0x82ED86EC => {
    //   block [0x82ED86EC..0x82ED86F0)
	// 82ED86EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82ED86F0; continue 'dispatch;
            }
            0x82ED86F0 => {
    //   block [0x82ED86F0..0x82ED86F4)
	// 82ED86F0: 4BFFFC79  bl 0x82ed8368
	ctx.lr = 0x82ED86F4;
	sub_82ED8368(ctx, base);
	pc = 0x82ED86F4; continue 'dispatch;
            }
            0x82ED86F4 => {
    //   block [0x82ED86F4..0x82ED8708)
	// 82ED86F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ED86F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED86FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED8700: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED8704: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED8708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ED8708 size=588
    let mut pc: u32 = 0x82ED8708;
    'dispatch: loop {
        match pc {
            0x82ED8708 => {
    //   block [0x82ED8708..0x82ED8778)
	// 82ED8708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED870C: 4BDD0D01  bl 0x82ca940c
	ctx.lr = 0x82ED8710;
	sub_82CA93D0(ctx, base);
	// 82ED8710: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82ED8714: 4BDD55B5  bl 0x82cadcc8
	ctx.lr = 0x82ED8718;
	sub_82CADCA0(ctx, base);
	// 82ED8718: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED871C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED8720: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ED8724: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED8728: C01F00D8  lfs f0, 0xd8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED872C: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82ED8730: C01F0080  lfs f0, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8734: C1BF005C  lfs f13, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED8738: EF606828  fsubs f27, f0, f13
	ctx.f[27].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82ED873C: C3CB0C18  lfs f30, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82ED8740: C01F0088  lfs f0, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8744: C1BF0064  lfs f13, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED8748: EFA06828  fsubs f29, f0, f13
	ctx.f[29].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82ED874C: FF1BF000  fcmpu cr6, f27, f30
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[30].f64);
	// 82ED8750: 409A0028  bne cr6, 0x82ed8778
	if !ctx.cr[6].eq {
	pc = 0x82ED8778; continue 'dispatch;
	}
	// 82ED8754: FF1DF000  fcmpu cr6, f29, f30
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[30].f64);
	// 82ED8758: 409A0020  bne cr6, 0x82ed8778
	if !ctx.cr[6].eq {
	pc = 0x82ED8778; continue 'dispatch;
	}
	// 82ED875C: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ED8760: C00B004C  lfs f0, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8764: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82ED8768: C00B0050  lfs f0, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED876C: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82ED8770: C00B0054  lfs f0, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8774: 48000114  b 0x82ed8888
	pc = 0x82ED8888; continue 'dispatch;
            }
            0x82ED8778 => {
    //   block [0x82ED8778..0x82ED87CC)
	// 82ED8778: EC1B06F2  fmuls f0, f27, f27
	ctx.f[0].f64 = (((ctx.f[27].f64 * ctx.f[27].f64) as f32) as f64);
	// 82ED877C: 897F002C  lbz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82ED8780: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED8784: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED8788: C34B0C14  lfs f26, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82ED878C: EC1D077A  fmadds f0, f29, f29, f0
	ctx.f[0].f64 = (((ctx.f[29].f64 * ctx.f[29].f64 + ctx.f[0].f64) as f32) as f64);
	// 82ED8790: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82ED8794: EFFA0024  fdivs f31, f26, f0
	ctx.f[31].f64 = ((ctx.f[26].f64 / ctx.f[0].f64) as f32) as f64;
	// 82ED8798: 418200F8  beq 0x82ed8890
	if ctx.cr[0].eq {
	pc = 0x82ED8890; continue 'dispatch;
	}
	// 82ED879C: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ED87A0: C00B004C  lfs f0, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED87A4: EC0006F2  fmuls f0, f0, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82ED87A8: C1AB0054  lfs f13, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED87AC: C18B0050  lfs f12, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED87B0: EC0D077A  fmadds f0, f13, f29, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[29].f64 + ctx.f[0].f64) as f32) as f64);
	// 82ED87B4: EC0C07BA  fmadds f0, f12, f30, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64);
	// 82ED87B8: EF8007F2  fmuls f28, f0, f31
	ctx.f[28].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82ED87BC: FF1CF000  fcmpu cr6, f28, f30
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[30].f64);
	// 82ED87C0: 4098000C  bge cr6, 0x82ed87cc
	if !ctx.cr[6].lt {
	pc = 0x82ED87CC; continue 'dispatch;
	}
	// 82ED87C4: FF80F090  fmr f28, f30
	ctx.f[28].f64 = ctx.f[30].f64;
	// 82ED87C8: 48000010  b 0x82ed87d8
	pc = 0x82ED87D8; continue 'dispatch;
            }
            0x82ED87CC => {
    //   block [0x82ED87CC..0x82ED87D8)
	// 82ED87CC: FF1CD000  fcmpu cr6, f28, f26
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[26].f64);
	// 82ED87D0: 40990008  ble cr6, 0x82ed87d8
	if !ctx.cr[6].gt {
	pc = 0x82ED87D8; continue 'dispatch;
	}
	// 82ED87D4: FF80D090  fmr f28, f26
	ctx.f[28].f64 = ctx.f[26].f64;
	pc = 0x82ED87D8; continue 'dispatch;
            }
            0x82ED87D8 => {
    //   block [0x82ED87D8..0x82ED87EC)
	// 82ED87D8: 4B3881E1  bl 0x822609b8
	ctx.lr = 0x82ED87DC;
	sub_822609B8(ctx, base);
	// 82ED87DC: C0030058  lfs f0, 0x58(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED87E0: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82ED87E4: 40990008  ble cr6, 0x82ed87ec
	if !ctx.cr[6].gt {
	pc = 0x82ED87EC; continue 'dispatch;
	}
	// 82ED87E8: FC00D090  fmr f0, f26
	ctx.f[0].f64 = ctx.f[26].f64;
	pc = 0x82ED87EC; continue 'dispatch;
            }
            0x82ED87EC => {
    //   block [0x82ED87EC..0x82ED8814)
	// 82ED87EC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ED87F0: C19F0030  lfs f12, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED87F4: C1ABE1F0  lfs f13, -0x1e10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7696 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED87F8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED87FC: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED8800: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED8804: C1ABBAF8  lfs f13, -0x4508(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17672 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED8808: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED880C: 40990008  ble cr6, 0x82ed8814
	if !ctx.cr[6].gt {
	pc = 0x82ED8814; continue 'dispatch;
	}
	// 82ED8810: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82ED8814; continue 'dispatch;
            }
            0x82ED8814 => {
    //   block [0x82ED8814..0x82ED8864)
	// 82ED8814: FF000090  fmr f24, f0
	ctx.f[24].f64 = ctx.f[0].f64;
	// 82ED8818: FC20C090  fmr f1, f24
	ctx.f[1].f64 = ctx.f[24].f64;
	// 82ED881C: 4B361695  bl 0x82239eb0
	ctx.lr = 0x82ED8820;
	sub_82239EB0(ctx, base);
	// 82ED8820: FF400818  frsp f26, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[26].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82ED8824: FF1CD000  fcmpu cr6, f28, f26
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[26].f64);
	// 82ED8828: 41990068  bgt cr6, 0x82ed8890
	if ctx.cr[6].gt {
	pc = 0x82ED8890; continue 'dispatch;
	}
	// 82ED882C: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ED8830: FC20C090  fmr f1, f24
	ctx.f[1].f64 = ctx.f[24].f64;
	// 82ED8834: C38B0054  lfs f28, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82ED8838: FC00E090  fmr f0, f28
	ctx.f[0].f64 = ctx.f[28].f64;
	// 82ED883C: C3EB004C  lfs f31, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82ED8840: FDA0F890  fmr f13, f31
	ctx.f[13].f64 = ctx.f[31].f64;
	// 82ED8844: C32B0050  lfs f25, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82ED8848: EC0006F2  fmuls f0, f0, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82ED884C: EC0D0778  fmsubs f0, f13, f29, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[29].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED8850: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82ED8854: 41980010  blt cr6, 0x82ed8864
	if ctx.cr[6].lt {
	pc = 0x82ED8864; continue 'dispatch;
	}
	// 82ED8858: 4B361739  bl 0x82239f90
	ctx.lr = 0x82ED885C;
	sub_82239F90(ctx, base);
	// 82ED885C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82ED8860: 48000010  b 0x82ed8870
	pc = 0x82ED8870; continue 'dispatch;
            }
            0x82ED8864 => {
    //   block [0x82ED8864..0x82ED8870)
	// 82ED8864: 4B36172D  bl 0x82239f90
	ctx.lr = 0x82ED8868;
	sub_82239F90(ctx, base);
	// 82ED8868: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82ED886C: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x82ED8870; continue 'dispatch;
            }
            0x82ED8870 => {
    //   block [0x82ED8870..0x82ED8888)
	// 82ED8870: EDA00732  fmuls f13, f0, f28
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 82ED8874: D33E0008  stfs f25, 8(r30)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82ED8878: ED9C06B2  fmuls f12, f28, f26
	ctx.f[12].f64 = (((ctx.f[28].f64 * ctx.f[26].f64) as f32) as f64);
	// 82ED887C: EDBF6EB8  fmsubs f13, f31, f26, f13
	ctx.f[13].f64 = (((ctx.f[31].f64 * ctx.f[26].f64 - ctx.f[13].f64) as f32) as f64);
	// 82ED8880: D1BE0004  stfs f13, 4(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82ED8884: EC0067FA  fmadds f0, f0, f31, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[12].f64) as f32) as f64);
	pc = 0x82ED8888; continue 'dispatch;
            }
            0x82ED8888 => {
    //   block [0x82ED8888..0x82ED8890)
	// 82ED8888: D01E000C  stfs f0, 0xc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82ED888C: 4800001C  b 0x82ed88a8
	pc = 0x82ED88A8; continue 'dispatch;
            }
            0x82ED8890 => {
    //   block [0x82ED8890..0x82ED88A8)
	// 82ED8890: ED9D07F2  fmuls f12, f29, f31
	ctx.f[12].f64 = (((ctx.f[29].f64 * ctx.f[31].f64) as f32) as f64);
	// 82ED8894: D19E000C  stfs f12, 0xc(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82ED8898: EDBF07B2  fmuls f13, f31, f30
	ctx.f[13].f64 = (((ctx.f[31].f64 * ctx.f[30].f64) as f32) as f64);
	// 82ED889C: D1BE0008  stfs f13, 8(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82ED88A0: EC1B07F2  fmuls f0, f27, f31
	ctx.f[0].f64 = (((ctx.f[27].f64 * ctx.f[31].f64) as f32) as f64);
	// 82ED88A4: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	pc = 0x82ED88A8; continue 'dispatch;
            }
            0x82ED88A8 => {
    //   block [0x82ED88A8..0x82ED88E4)
	// 82ED88A8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82ED88AC: 389F00A8  addi r4, r31, 0xa8
	ctx.r[4].s64 = ctx.r[31].s64 + 168;
	// 82ED88B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED88B4: 9BBE001C  stb r29, 0x1c(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[29].u8 ) };
	// 82ED88B8: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED88BC: 895F00EC  lbz r10, 0xec(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82ED88C0: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82ED88C4: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED88C8: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED88CC: EC0D06F8  fmsubs f0, f13, f27, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[27].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED88D0: C1BF0034  lfs f13, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED88D4: FD800210  fabs f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82ED88D8: C00B0B6C  lfs f0, 0xb6c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2924 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED88DC: 41820008  beq 0x82ed88e4
	if ctx.cr[0].eq {
	pc = 0x82ED88E4; continue 'dispatch;
	}
	// 82ED88E0: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x82ED88E4; continue 'dispatch;
            }
            0x82ED88E4 => {
    //   block [0x82ED88E4..0x82ED88F4)
	// 82ED88E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82ED88E8: 419A000C  beq cr6, 0x82ed88f4
	if ctx.cr[6].eq {
	pc = 0x82ED88F4; continue 'dispatch;
	}
	// 82ED88EC: C01F0038  lfs f0, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED88F0: 4800000C  b 0x82ed88fc
	pc = 0x82ED88FC; continue 'dispatch;
            }
            0x82ED88F4 => {
    //   block [0x82ED88F4..0x82ED88FC)
	// 82ED88F4: C17F0038  lfs f11, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED88F8: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x82ED88FC; continue 'dispatch;
            }
            0x82ED88FC => {
    //   block [0x82ED88FC..0x82ED893C)
	// 82ED88FC: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82ED8900: 4099003C  ble cr6, 0x82ed893c
	if !ctx.cr[6].gt {
	pc = 0x82ED893C; continue 'dispatch;
	}
	// 82ED8904: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82ED8908: 40980034  bge cr6, 0x82ed893c
	if !ctx.cr[6].lt {
	pc = 0x82ED893C; continue 'dispatch;
	}
	// 82ED890C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82ED8910: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82ED8914: 997E001C  stb r11, 0x1c(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 82ED8918: 997F00EC  stb r11, 0xec(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u8 ) };
	// 82ED891C: 4BFAD44D  bl 0x82e85d68
	ctx.lr = 0x82ED8920;
	sub_82E85D68(ctx, base);
	// 82ED8920: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8924: D01E0010  stfs f0, 0x10(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82ED8928: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED892C: D01E0014  stfs f0, 0x14(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82ED8930: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8934: D01E0018  stfs f0, 0x18(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82ED8938: 48000008  b 0x82ed8940
	pc = 0x82ED8940; continue 'dispatch;
            }
            0x82ED893C => {
    //   block [0x82ED893C..0x82ED8940)
	// 82ED893C: 9BBF00EC  stb r29, 0xec(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[29].u8 ) };
	pc = 0x82ED8940; continue 'dispatch;
            }
            0x82ED8940 => {
    //   block [0x82ED8940..0x82ED8954)
	// 82ED8940: 9BBE001D  stb r29, 0x1d(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(29 as u32), ctx.r[29].u8 ) };
	// 82ED8944: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82ED8948: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82ED894C: 4BDD53C9  bl 0x82cadd14
	ctx.lr = 0x82ED8950;
	sub_82CADCEC(ctx, base);
	// 82ED8950: 4BDD0B0C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED8958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82ED8958 size=1152
    let mut pc: u32 = 0x82ED8958;
    'dispatch: loop {
        match pc {
            0x82ED8958 => {
    //   block [0x82ED8958..0x82ED89AC)
	// 82ED8958: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED895C: C0CB0C18  lfs f6, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82ED8960: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED8964: FF013000  fcmpu cr6, f1, f6
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[6].f64);
	// 82ED8968: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82ED896C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ED8970: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED8974: D0C30004  stfs f6, 4(r3)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82ED8978: D0C30008  stfs f6, 8(r3)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82ED897C: D0C3000C  stfs f6, 0xc(r3)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82ED8980: D0C30010  stfs f6, 0x10(r3)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82ED8984: C0AB0BFC  lfs f5, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82ED8988: D0C30014  stfs f6, 0x14(r3)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82ED898C: D0C30018  stfs f6, 0x18(r3)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82ED8990: D0C3001C  stfs f6, 0x1c(r3)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82ED8994: 409A0018  bne cr6, 0x82ed89ac
	if !ctx.cr[6].eq {
	pc = 0x82ED89AC; continue 'dispatch;
	}
	// 82ED8998: C00400BC  lfs f0, 0xbc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED899C: C1A400F8  lfs f13, 0xf8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(248 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED89A0: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED89A4: FF026800  fcmpu cr6, f2, f13
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[13].f64);
	// 82ED89A8: 41990018  bgt cr6, 0x82ed89c0
	if ctx.cr[6].gt {
	pc = 0x82ED89C0; continue 'dispatch;
	}
	pc = 0x82ED89AC; continue 'dispatch;
            }
            0x82ED89AC => {
    //   block [0x82ED89AC..0x82ED89C0)
	// 82ED89AC: C0040070  lfs f0, 0x70(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED89B0: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED89B4: EDA00172  fmuls f13, f0, f5
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[5].f64) as f32) as f64);
	// 82ED89B8: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED89BC: EC0068B8  fmsubs f0, f0, f2, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[2].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x82ED89C0; continue 'dispatch;
            }
            0x82ED89C0 => {
    //   block [0x82ED89C0..0x82ED89E8)
	// 82ED89C0: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED89C4: C1840008  lfs f12, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED89C8: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED89CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED89D0: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED89D4: C08B0C4C  lfs f4, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82ED89D8: EDAD0132  fmuls f13, f13, f4
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[4].f64) as f32) as f64);
	// 82ED89DC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED89E0: 40980008  bge cr6, 0x82ed89e8
	if !ctx.cr[6].lt {
	pc = 0x82ED89E8; continue 'dispatch;
	}
	// 82ED89E4: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82ED89E8; continue 'dispatch;
            }
            0x82ED89E8 => {
    //   block [0x82ED89E8..0x82ED8A78)
	// 82ED89E8: C14400B0  lfs f10, 0xb0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(176 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82ED89EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED89F0: C12400AC  lfs f9, 0xac(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(172 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82ED89F4: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED89F8: C0E400A8  lfs f7, 0xa8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(168 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82ED89FC: ED290032  fmuls f9, f9, f0
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED8A00: C1A40098  lfs f13, 0x98(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(152 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED8A04: EC070032  fmuls f0, f7, f0
	ctx.f[0].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED8A08: C1840094  lfs f12, 0x94(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED8A0C: EDAD0072  fmuls f13, f13, f1
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[1].f64) as f32) as f64);
	// 82ED8A10: C1640090  lfs f11, 0x90(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED8A14: ED8C0072  fmuls f12, f12, f1
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[1].f64) as f32) as f64);
	// 82ED8A18: ED6B0072  fmuls f11, f11, f1
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[1].f64) as f32) as f64);
	// 82ED8A1C: C0E40064  lfs f7, 0x64(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(100 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82ED8A20: C0640060  lfs f3, 0x60(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(96 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82ED8A24: C044005C  lfs f2, 0x5c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(92 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82ED8A28: C10B0BEC  lfs f8, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82ED8A2C: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82ED8A30: ED89602A  fadds f12, f9, f12
	ctx.f[12].f64 = ((ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64;
	// 82ED8A34: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 82ED8A38: EDA7682A  fadds f13, f7, f13
	ctx.f[13].f64 = ((ctx.f[7].f64 + ctx.f[13].f64) as f32) as f64;
	// 82ED8A3C: D1A3000C  stfs f13, 0xc(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82ED8A40: ED83602A  fadds f12, f3, f12
	ctx.f[12].f64 = ((ctx.f[3].f64 + ctx.f[12].f64) as f32) as f64;
	// 82ED8A44: D1830008  stfs f12, 8(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82ED8A48: EC02002A  fadds f0, f2, f0
	ctx.f[0].f64 = ((ctx.f[2].f64 + ctx.f[0].f64) as f32) as f64;
	// 82ED8A4C: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82ED8A50: D0230014  stfs f1, 0x14(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82ED8A54: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED8A58: C1A40010  lfs f13, 0x10(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED8A5C: C0040070  lfs f0, 0x70(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8A60: EC00697A  fmadds f0, f0, f5, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[5].f64 + ctx.f[13].f64) as f32) as f64);
	// 82ED8A64: C1A400B4  lfs f13, 0xb4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(180 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED8A68: ED610028  fsubs f11, f1, f0
	ctx.f[11].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED8A6C: EC00082A  fadds f0, f0, f1
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 82ED8A70: 7D4B5379  or. r11, r10, r10
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED8A74: 4182003C  beq 0x82ed8ab0
	if ctx.cr[0].eq {
	pc = 0x82ED8AB0; continue 'dispatch;
	}
	pc = 0x82ED8A78; continue 'dispatch;
            }
            0x82ED8A78 => {
    //   block [0x82ED8A78..0x82ED8A94)
	// 82ED8A78: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED8A7C: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82ED8A80: 41990030  bgt cr6, 0x82ed8ab0
	if ctx.cr[6].gt {
	pc = 0x82ED8AB0; continue 'dispatch;
	}
	// 82ED8A84: C18B0010  lfs f12, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED8A88: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82ED8A8C: 40980008  bge cr6, 0x82ed8a94
	if !ctx.cr[6].lt {
	pc = 0x82ED8A94; continue 'dispatch;
	}
	// 82ED8A90: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	pc = 0x82ED8A94; continue 'dispatch;
            }
            0x82ED8A94 => {
    //   block [0x82ED8A94..0x82ED8AA4)
	// 82ED8A94: C18B0014  lfs f12, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED8A98: FF0C4000  fcmpu cr6, f12, f8
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[8].f64);
	// 82ED8A9C: 40980008  bge cr6, 0x82ed8aa4
	if !ctx.cr[6].lt {
	pc = 0x82ED8AA4; continue 'dispatch;
	}
	// 82ED8AA0: FD006090  fmr f8, f12
	ctx.f[8].f64 = ctx.f[12].f64;
	pc = 0x82ED8AA4; continue 'dispatch;
            }
            0x82ED8AA4 => {
    //   block [0x82ED8AA4..0x82ED8AB0)
	// 82ED8AA4: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ED8AA8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED8AAC: 4082FFCC  bne 0x82ed8a78
	if !ctx.cr[0].eq {
	pc = 0x82ED8A78; continue 'dispatch;
	}
	pc = 0x82ED8AB0; continue 'dispatch;
            }
            0x82ED8AB0 => {
    //   block [0x82ED8AB0..0x82ED8AB8)
	// 82ED8AB0: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED8AB4: 48000034  b 0x82ed8ae8
	pc = 0x82ED8AE8; continue 'dispatch;
            }
            0x82ED8AB8 => {
    //   block [0x82ED8AB8..0x82ED8AD4)
	// 82ED8AB8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8ABC: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82ED8AC0: 41980030  blt cr6, 0x82ed8af0
	if ctx.cr[6].lt {
	pc = 0x82ED8AF0; continue 'dispatch;
	}
	// 82ED8AC4: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8AC8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED8ACC: 40980008  bge cr6, 0x82ed8ad4
	if !ctx.cr[6].lt {
	pc = 0x82ED8AD4; continue 'dispatch;
	}
	// 82ED8AD0: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	pc = 0x82ED8AD4; continue 'dispatch;
            }
            0x82ED8AD4 => {
    //   block [0x82ED8AD4..0x82ED8AE4)
	// 82ED8AD4: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8AD8: FF004000  fcmpu cr6, f0, f8
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[8].f64);
	// 82ED8ADC: 40980008  bge cr6, 0x82ed8ae4
	if !ctx.cr[6].lt {
	pc = 0x82ED8AE4; continue 'dispatch;
	}
	// 82ED8AE0: FD000090  fmr f8, f0
	ctx.f[8].f64 = ctx.f[0].f64;
	pc = 0x82ED8AE4; continue 'dispatch;
            }
            0x82ED8AE4 => {
    //   block [0x82ED8AE4..0x82ED8AE8)
	// 82ED8AE4: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	pc = 0x82ED8AE8; continue 'dispatch;
            }
            0x82ED8AE8 => {
    //   block [0x82ED8AE8..0x82ED8AF0)
	// 82ED8AE8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED8AEC: 4082FFCC  bne 0x82ed8ab8
	if !ctx.cr[0].eq {
	pc = 0x82ED8AB8; continue 'dispatch;
	}
	pc = 0x82ED8AF0; continue 'dispatch;
            }
            0x82ED8AF0 => {
    //   block [0x82ED8AF0..0x82ED8B34)
	// 82ED8AF0: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED8AF4: C0040044  lfs f0, 0x44(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8AF8: FF003000  fcmpu cr6, f0, f6
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[6].f64);
	// 82ED8AFC: C16B0010  lfs f11, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED8B00: 419A0058  beq cr6, 0x82ed8b58
	if ctx.cr[6].eq {
	pc = 0x82ED8B58; continue 'dispatch;
	}
	// 82ED8B04: C184003C  lfs f12, 0x3c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED8B08: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED8B0C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ED8B10: 40980048  bge cr6, 0x82ed8b58
	if !ctx.cr[6].lt {
	pc = 0x82ED8B58; continue 'dispatch;
	}
	// 82ED8B14: FF083000  fcmpu cr6, f8, f6
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[6].f64);
	// 82ED8B18: 4199001C  bgt cr6, 0x82ed8b34
	if ctx.cr[6].gt {
	pc = 0x82ED8B34; continue 'dispatch;
	}
	// 82ED8B1C: C00400F4  lfs f0, 0xf4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(244 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8B20: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED8B24: ED840028  fsubs f12, f4, f0
	ctx.f[12].f64 = (((ctx.f[4].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED8B28: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED8B2C: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82ED8B30: 48000020  b 0x82ed8b50
	pc = 0x82ED8B50; continue 'dispatch;
            }
            0x82ED8B34 => {
    //   block [0x82ED8B34..0x82ED8B50)
	// 82ED8B34: FF085800  fcmpu cr6, f8, f11
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[11].f64);
	// 82ED8B38: 40980020  bge cr6, 0x82ed8b58
	if !ctx.cr[6].lt {
	pc = 0x82ED8B58; continue 'dispatch;
	}
	// 82ED8B3C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82ED8B40: C18400F4  lfs f12, 0xf4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(244 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED8B44: ED4B0372  fmuls f10, f11, f13
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED8B48: EC00523A  fmadds f0, f0, f8, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[10].f64) as f32) as f64);
	// 82ED8B4C: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	pc = 0x82ED8B50; continue 'dispatch;
            }
            0x82ED8B50 => {
    //   block [0x82ED8B50..0x82ED8B58)
	// 82ED8B50: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82ED8B54: 48000008  b 0x82ed8b5c
	pc = 0x82ED8B5C; continue 'dispatch;
            }
            0x82ED8B58 => {
    //   block [0x82ED8B58..0x82ED8B5C)
	// 82ED8B58: D163001C  stfs f11, 0x1c(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	pc = 0x82ED8B5C; continue 'dispatch;
            }
            0x82ED8B5C => {
    //   block [0x82ED8B5C..0x82ED8B98)
	// 82ED8B5C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED8B60: FF013000  fcmpu cr6, f1, f6
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[6].f64);
	// 82ED8B64: C0EB0C14  lfs f7, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82ED8B68: 409A0034  bne cr6, 0x82ed8b9c
	if !ctx.cr[6].eq {
	pc = 0x82ED8B9C; continue 'dispatch;
	}
	// 82ED8B6C: 89640014  lbz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED8B70: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED8B74: 41820024  beq 0x82ed8b98
	if ctx.cr[0].eq {
	pc = 0x82ED8B98; continue 'dispatch;
	}
	// 82ED8B78: C0040018  lfs f0, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8B7C: FF003000  fcmpu cr6, f0, f6
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[6].f64);
	// 82ED8B80: 40990018  ble cr6, 0x82ed8b98
	if !ctx.cr[6].gt {
	pc = 0x82ED8B98; continue 'dispatch;
	}
	// 82ED8B84: EC070028  fsubs f0, f7, f0
	ctx.f[0].f64 = (((ctx.f[7].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED8B88: C183001C  lfs f12, 0x1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED8B8C: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82ED8B90: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82ED8B94: 40980008  bge cr6, 0x82ed8b9c
	if !ctx.cr[6].lt {
	pc = 0x82ED8B9C; continue 'dispatch;
	}
	pc = 0x82ED8B98; continue 'dispatch;
            }
            0x82ED8B98 => {
    //   block [0x82ED8B98..0x82ED8B9C)
	// 82ED8B98: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	pc = 0x82ED8B9C; continue 'dispatch;
            }
            0x82ED8B9C => {
    //   block [0x82ED8B9C..0x82ED8BB8)
	// 82ED8B9C: D1A30018  stfs f13, 0x18(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82ED8BA0: 550B063F  clrlwi. r11, r8, 0x18
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED8BA4: 41820014  beq 0x82ed8bb8
	if ctx.cr[0].eq {
	pc = 0x82ED8BB8; continue 'dispatch;
	}
	// 82ED8BA8: C0040010  lfs f0, 0x10(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8BAC: C1A40070  lfs f13, 0x70(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED8BB0: EC00693A  fmadds f0, f0, f4, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[4].f64 + ctx.f[13].f64) as f32) as f64);
	// 82ED8BB4: 48000008  b 0x82ed8bbc
	pc = 0x82ED8BBC; continue 'dispatch;
            }
            0x82ED8BB8 => {
    //   block [0x82ED8BB8..0x82ED8BBC)
	// 82ED8BB8: FC003090  fmr f0, f6
	ctx.f[0].f64 = ctx.f[6].f64;
	pc = 0x82ED8BBC; continue 'dispatch;
            }
            0x82ED8BBC => {
    //   block [0x82ED8BBC..0x82ED8BCC)
	// 82ED8BBC: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82ED8BC0: 4099000C  ble cr6, 0x82ed8bcc
	if !ctx.cr[6].gt {
	pc = 0x82ED8BCC; continue 'dispatch;
	}
	// 82ED8BC4: ED810028  fsubs f12, f1, f0
	ctx.f[12].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED8BC8: 48000008  b 0x82ed8bd0
	pc = 0x82ED8BD0; continue 'dispatch;
            }
            0x82ED8BCC => {
    //   block [0x82ED8BCC..0x82ED8BD0)
	// 82ED8BCC: ED800828  fsubs f12, f0, f1
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	pc = 0x82ED8BD0; continue 'dispatch;
            }
            0x82ED8BD0 => {
    //   block [0x82ED8BD0..0x82ED8BEC)
	// 82ED8BD0: C00400F0  lfs f0, 0xf0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8BD4: C1A400C8  lfs f13, 0xc8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(200 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED8BD8: ED000332  fmuls f8, f0, f12
	ctx.f[8].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82ED8BDC: FF016800  fcmpu cr6, f1, f13
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[13].f64);
	// 82ED8BE0: 4098000C  bge cr6, 0x82ed8bec
	if !ctx.cr[6].lt {
	pc = 0x82ED8BEC; continue 'dispatch;
	}
	// 82ED8BE4: EDAD0828  fsubs f13, f13, f1
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[1].f64) as f32) as f64);
	// 82ED8BE8: 48000008  b 0x82ed8bf0
	pc = 0x82ED8BF0; continue 'dispatch;
            }
            0x82ED8BEC => {
    //   block [0x82ED8BEC..0x82ED8BF0)
	// 82ED8BEC: EDA16828  fsubs f13, f1, f13
	ctx.f[13].f64 = (((ctx.f[1].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x82ED8BF0; continue 'dispatch;
            }
            0x82ED8BF0 => {
    //   block [0x82ED8BF0..0x82ED8C10)
	// 82ED8BF0: 89640014  lbz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED8BF4: ED2D0032  fmuls f9, f13, f0
	ctx.f[9].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED8BF8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED8BFC: 41820014  beq 0x82ed8c10
	if ctx.cr[0].eq {
	pc = 0x82ED8C10; continue 'dispatch;
	}
	// 82ED8C00: C0040018  lfs f0, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8C04: EC070028  fsubs f0, f7, f0
	ctx.f[0].f64 = (((ctx.f[7].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED8C08: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82ED8C0C: 48000008  b 0x82ed8c14
	pc = 0x82ED8C14; continue 'dispatch;
            }
            0x82ED8C10 => {
    //   block [0x82ED8C10..0x82ED8C14)
	// 82ED8C10: FC005890  fmr f0, f11
	ctx.f[0].f64 = ctx.f[11].f64;
	pc = 0x82ED8C14; continue 'dispatch;
            }
            0x82ED8C14 => {
    //   block [0x82ED8C14..0x82ED8C28)
	// 82ED8C14: C1A3001C  lfs f13, 0x1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED8C18: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ED8C1C: 4198000C  blt cr6, 0x82ed8c28
	if ctx.cr[6].lt {
	pc = 0x82ED8C28; continue 'dispatch;
	}
	// 82ED8C20: FD403090  fmr f10, f6
	ctx.f[10].f64 = ctx.f[6].f64;
	// 82ED8C24: 4800000C  b 0x82ed8c30
	pc = 0x82ED8C30; continue 'dispatch;
            }
            0x82ED8C28 => {
    //   block [0x82ED8C28..0x82ED8C30)
	// 82ED8C28: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82ED8C2C: ED470028  fsubs f10, f7, f0
	ctx.f[10].f64 = (((ctx.f[7].f64 - ctx.f[0].f64) as f32) as f64);
	pc = 0x82ED8C30; continue 'dispatch;
            }
            0x82ED8C30 => {
    //   block [0x82ED8C30..0x82ED8C54)
	// 82ED8C30: 81640050  lwz r11, 0x50(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ED8C34: C16400B4  lfs f11, 0xb4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(180 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED8C38: FF013000  fcmpu cr6, f1, f6
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[6].f64);
	// 82ED8C3C: FD805890  fmr f12, f11
	ctx.f[12].f64 = ctx.f[11].f64;
	// 82ED8C40: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED8C44: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED8C48: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED8C4C: 40990070  ble cr6, 0x82ed8cbc
	if !ctx.cr[6].gt {
	pc = 0x82ED8CBC; continue 'dispatch;
	}
	// 82ED8C50: 41820100  beq 0x82ed8d50
	if ctx.cr[0].eq {
	pc = 0x82ED8D50; continue 'dispatch;
	}
	pc = 0x82ED8C54; continue 'dispatch;
            }
            0x82ED8C54 => {
    //   block [0x82ED8C54..0x82ED8C6C)
	// 82ED8C54: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8C58: FF003000  fcmpu cr6, f0, f6
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[6].f64);
	// 82ED8C5C: 41990010  bgt cr6, 0x82ed8c6c
	if ctx.cr[6].gt {
	pc = 0x82ED8C6C; continue 'dispatch;
	}
	// 82ED8C60: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ED8C64: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED8C68: 4082FFEC  bne 0x82ed8c54
	if !ctx.cr[0].eq {
	pc = 0x82ED8C54; continue 'dispatch;
	}
	pc = 0x82ED8C6C; continue 'dispatch;
            }
            0x82ED8C6C => {
    //   block [0x82ED8C6C..0x82ED8C74)
	// 82ED8C6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED8C70: 419A00E0  beq cr6, 0x82ed8d50
	if ctx.cr[6].eq {
	pc = 0x82ED8D50; continue 'dispatch;
	}
	pc = 0x82ED8C74; continue 'dispatch;
            }
            0x82ED8C74 => {
    //   block [0x82ED8C74..0x82ED8C9C)
	// 82ED8C74: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED8C78: FF0D0800  fcmpu cr6, f13, f1
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[1].f64);
	// 82ED8C7C: 419900D4  bgt cr6, 0x82ed8d50
	if ctx.cr[6].gt {
	pc = 0x82ED8D50; continue 'dispatch;
	}
	// 82ED8C80: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8C84: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82ED8C88: 40990014  ble cr6, 0x82ed8c9c
	if !ctx.cr[6].gt {
	pc = 0x82ED8C9C; continue 'dispatch;
	}
	// 82ED8C8C: EC610132  fmuls f3, f1, f4
	ctx.f[3].f64 = (((ctx.f[1].f64 * ctx.f[4].f64) as f32) as f64);
	// 82ED8C90: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82ED8C94: FF001800  fcmpu cr6, f0, f3
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[3].f64);
	// 82ED8C98: 419900B8  bgt cr6, 0x82ed8d50
	if ctx.cr[6].gt {
	pc = 0x82ED8D50; continue 'dispatch;
	}
	pc = 0x82ED8C9C; continue 'dispatch;
            }
            0x82ED8C9C => {
    //   block [0x82ED8C9C..0x82ED8CAC)
	// 82ED8C9C: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8CA0: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82ED8CA4: 40980008  bge cr6, 0x82ed8cac
	if !ctx.cr[6].lt {
	pc = 0x82ED8CAC; continue 'dispatch;
	}
	// 82ED8CA8: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	pc = 0x82ED8CAC; continue 'dispatch;
            }
            0x82ED8CAC => {
    //   block [0x82ED8CAC..0x82ED8CBC)
	// 82ED8CAC: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ED8CB0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED8CB4: 4082FFC0  bne 0x82ed8c74
	if !ctx.cr[0].eq {
	pc = 0x82ED8C74; continue 'dispatch;
	}
	// 82ED8CB8: 48000098  b 0x82ed8d50
	pc = 0x82ED8D50; continue 'dispatch;
            }
            0x82ED8CBC => {
    //   block [0x82ED8CBC..0x82ED8CC8)
	// 82ED8CBC: FF013000  fcmpu cr6, f1, f6
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[6].f64);
	// 82ED8CC0: 40980070  bge cr6, 0x82ed8d30
	if !ctx.cr[6].lt {
	pc = 0x82ED8D30; continue 'dispatch;
	}
	// 82ED8CC4: 4182008C  beq 0x82ed8d50
	if ctx.cr[0].eq {
	pc = 0x82ED8D50; continue 'dispatch;
	}
	pc = 0x82ED8CC8; continue 'dispatch;
            }
            0x82ED8CC8 => {
    //   block [0x82ED8CC8..0x82ED8CE0)
	// 82ED8CC8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8CCC: FF003000  fcmpu cr6, f0, f6
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[6].f64);
	// 82ED8CD0: 41990010  bgt cr6, 0x82ed8ce0
	if ctx.cr[6].gt {
	pc = 0x82ED8CE0; continue 'dispatch;
	}
	// 82ED8CD4: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ED8CD8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED8CDC: 4082FFEC  bne 0x82ed8cc8
	if !ctx.cr[0].eq {
	pc = 0x82ED8CC8; continue 'dispatch;
	}
	pc = 0x82ED8CE0; continue 'dispatch;
            }
            0x82ED8CE0 => {
    //   block [0x82ED8CE0..0x82ED8CE8)
	// 82ED8CE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED8CE4: 419A006C  beq cr6, 0x82ed8d50
	if ctx.cr[6].eq {
	pc = 0x82ED8D50; continue 'dispatch;
	}
	pc = 0x82ED8CE8; continue 'dispatch;
            }
            0x82ED8CE8 => {
    //   block [0x82ED8CE8..0x82ED8D10)
	// 82ED8CE8: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED8CEC: FF0D0800  fcmpu cr6, f13, f1
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[1].f64);
	// 82ED8CF0: 41980060  blt cr6, 0x82ed8d50
	if ctx.cr[6].lt {
	pc = 0x82ED8D50; continue 'dispatch;
	}
	// 82ED8CF4: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8CF8: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82ED8CFC: 40980014  bge cr6, 0x82ed8d10
	if !ctx.cr[6].lt {
	pc = 0x82ED8D10; continue 'dispatch;
	}
	// 82ED8D00: EC610132  fmuls f3, f1, f4
	ctx.f[3].f64 = (((ctx.f[1].f64 * ctx.f[4].f64) as f32) as f64);
	// 82ED8D04: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82ED8D08: FF001800  fcmpu cr6, f0, f3
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[3].f64);
	// 82ED8D0C: 41980044  blt cr6, 0x82ed8d50
	if ctx.cr[6].lt {
	pc = 0x82ED8D50; continue 'dispatch;
	}
	pc = 0x82ED8D10; continue 'dispatch;
            }
            0x82ED8D10 => {
    //   block [0x82ED8D10..0x82ED8D20)
	// 82ED8D10: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8D14: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82ED8D18: 40980008  bge cr6, 0x82ed8d20
	if !ctx.cr[6].lt {
	pc = 0x82ED8D20; continue 'dispatch;
	}
	// 82ED8D1C: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	pc = 0x82ED8D20; continue 'dispatch;
            }
            0x82ED8D20 => {
    //   block [0x82ED8D20..0x82ED8D30)
	// 82ED8D20: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED8D24: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED8D28: 4082FFC0  bne 0x82ed8ce8
	if !ctx.cr[0].eq {
	pc = 0x82ED8CE8; continue 'dispatch;
	}
	// 82ED8D2C: 48000024  b 0x82ed8d50
	pc = 0x82ED8D50; continue 'dispatch;
            }
            0x82ED8D30 => {
    //   block [0x82ED8D30..0x82ED8D34)
	// 82ED8D30: 4182001C  beq 0x82ed8d4c
	if ctx.cr[0].eq {
	pc = 0x82ED8D4C; continue 'dispatch;
	}
	pc = 0x82ED8D34; continue 'dispatch;
            }
            0x82ED8D34 => {
    //   block [0x82ED8D34..0x82ED8D4C)
	// 82ED8D34: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8D38: FF003000  fcmpu cr6, f0, f6
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[6].f64);
	// 82ED8D3C: 41990010  bgt cr6, 0x82ed8d4c
	if ctx.cr[6].gt {
	pc = 0x82ED8D4C; continue 'dispatch;
	}
	// 82ED8D40: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ED8D44: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED8D48: 4082FFEC  bne 0x82ed8d34
	if !ctx.cr[0].eq {
	pc = 0x82ED8D34; continue 'dispatch;
	}
	pc = 0x82ED8D4C; continue 'dispatch;
            }
            0x82ED8D4C => {
    //   block [0x82ED8D4C..0x82ED8D50)
	// 82ED8D4C: C18B0010  lfs f12, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82ED8D50; continue 'dispatch;
            }
            0x82ED8D50 => {
    //   block [0x82ED8D50..0x82ED8D70)
	// 82ED8D50: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 82ED8D54: 4098001C  bge cr6, 0x82ed8d70
	if !ctx.cr[6].lt {
	pc = 0x82ED8D70; continue 'dispatch;
	}
	// 82ED8D58: C00400B4  lfs f0, 0xb4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8D5C: EDA0602A  fadds f13, f0, f12
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 82ED8D60: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82ED8D64: EC002828  fsubs f0, f0, f5
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[5].f64) as f32) as f64);
	// 82ED8D68: EC000132  fmuls f0, f0, f4
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[4].f64) as f32) as f64);
	// 82ED8D6C: 48000008  b 0x82ed8d74
	pc = 0x82ED8D74; continue 'dispatch;
            }
            0x82ED8D70 => {
    //   block [0x82ED8D70..0x82ED8D74)
	// 82ED8D70: FC003090  fmr f0, f6
	ctx.f[0].f64 = ctx.f[6].f64;
	pc = 0x82ED8D74; continue 'dispatch;
            }
            0x82ED8D74 => {
    //   block [0x82ED8D74..0x82ED8DB8)
	// 82ED8D74: EDA0502A  fadds f13, f0, f10
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64;
	// 82ED8D78: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED8D7C: C00BBE10  lfs f0, -0x41f0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8D80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED8D84: EC0D483A  fmadds f0, f13, f0, f9
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[9].f64) as f32) as f64);
	// 82ED8D88: EDA0402A  fadds f13, f0, f8
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64;
	// 82ED8D8C: C00B0C7C  lfs f0, 0xc7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8D90: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED8D94: D1830010  stfs f12, 0x10(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82ED8D98: C1A40070  lfs f13, 0x70(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED8D9C: C1640010  lfs f11, 0x10(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED8DA0: EDAD597A  fmadds f13, f13, f5, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[5].f64 + ctx.f[11].f64) as f32) as f64);
	// 82ED8DA4: C00400C8  lfs f0, 0xc8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8DA8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED8DAC: 4099000C  ble cr6, 0x82ed8db8
	if !ctx.cr[6].gt {
	pc = 0x82ED8DB8; continue 'dispatch;
	}
	// 82ED8DB0: FF013000  fcmpu cr6, f1, f6
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[6].f64);
	// 82ED8DB4: 41980018  blt cr6, 0x82ed8dcc
	if ctx.cr[6].lt {
	pc = 0x82ED8DCC; continue 'dispatch;
	}
	pc = 0x82ED8DB8; continue 'dispatch;
            }
            0x82ED8DB8 => {
    //   block [0x82ED8DB8..0x82ED8DCC)
	// 82ED8DB8: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 82ED8DBC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED8DC0: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 82ED8DC4: FF013000  fcmpu cr6, f1, f6
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[6].f64);
	// 82ED8DC8: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	pc = 0x82ED8DCC; continue 'dispatch;
            }
            0x82ED8DCC => {
    //   block [0x82ED8DCC..0x82ED8DD8)
	// 82ED8DCC: EC0C382A  fadds f0, f12, f7
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[7].f64) as f32) as f64;
	// 82ED8DD0: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82ED8DD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED8DD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ED8DD8 size=888
    let mut pc: u32 = 0x82ED8DD8;
    'dispatch: loop {
        match pc {
            0x82ED8DD8 => {
    //   block [0x82ED8DD8..0x82ED8E08)
	// 82ED8DD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED8DDC: 4BDD060D  bl 0x82ca93e8
	ctx.lr = 0x82ED8DE0;
	sub_82CA93D0(ctx, base);
	// 82ED8DE0: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 82ED8DE4: 4BDD4ED9  bl 0x82cadcbc
	ctx.lr = 0x82ED8DE8;
	sub_82CADCA0(ctx, base);
	// 82ED8DE8: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED8DEC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82ED8DF0: 815900C4  lwz r10, 0xc4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(196 as u32) ) } as u64;
	// 82ED8DF4: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED8DF8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED8DFC: 3A8BFFFF  addi r20, r11, -1
	ctx.r[20].s64 = ctx.r[11].s64 + -1;
	// 82ED8E00: 40820008  bne 0x82ed8e08
	if !ctx.cr[0].eq {
	pc = 0x82ED8E08; continue 'dispatch;
	}
	// 82ED8E04: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	pc = 0x82ED8E08; continue 'dispatch;
            }
            0x82ED8E08 => {
    //   block [0x82ED8E08..0x82ED8E40)
	// 82ED8E08: 2B140002  cmplwi cr6, r20, 2
	ctx.cr[6].compare_u32(ctx.r[20].u32, 2 as u32, &mut ctx.xer);
	// 82ED8E0C: 40990034  ble cr6, 0x82ed8e40
	if !ctx.cr[6].gt {
	pc = 0x82ED8E40; continue 'dispatch;
	}
	// 82ED8E10: 7A8B0020  clrldi r11, r20, 0x20
	ctx.r[11].u64 = ctx.r[20].u64 & 0x00000000FFFFFFFFu64;
	// 82ED8E14: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82ED8E18: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82ED8E1C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82ED8E20: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED8E24: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82ED8E28: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8E2C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED8E30: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED8E34: C00BBB00  lfs f0, -0x4500(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17664 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8E38: EEA06824  fdivs f21, f0, f13
	ctx.f[21].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82ED8E3C: 4800000C  b 0x82ed8e48
	pc = 0x82ED8E48; continue 'dispatch;
            }
            0x82ED8E40 => {
    //   block [0x82ED8E40..0x82ED8E48)
	// 82ED8E40: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED8E44: C2ABBB00  lfs f21, -0x4500(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17664 as u32) ) };
	ctx.f[21].f64 = (tmp.f32 as f64);
	pc = 0x82ED8E48; continue 'dispatch;
            }
            0x82ED8E48 => {
    //   block [0x82ED8E48..0x82ED8E98)
	// 82ED8E48: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED8E4C: 830A0008  lwz r24, 8(r10)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED8E50: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 82ED8E54: 28180000  cmplwi r24, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED8E58: C2CB0AE4  lfs f22, 0xae4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2788 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 82ED8E5C: 418202E4  beq 0x82ed9140
	if ctx.cr[0].eq {
	pc = 0x82ED9140; continue 'dispatch;
	}
	// 82ED8E60: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ED8E64: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82ED8E68: 3BABDAC0  addi r29, r11, -0x2540
	ctx.r[29].s64 = ctx.r[11].s64 + -9536;
	// 82ED8E6C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ED8E70: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 82ED8E74: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ED8E78: 3B6BDBE4  addi r27, r11, -0x241c
	ctx.r[27].s64 = ctx.r[11].s64 + -9244;
	// 82ED8E7C: C2E8BAFC  lfs f23, -0x4504(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-17668 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 82ED8E80: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82ED8E84: 5495063E  clrlwi r21, r4, 0x18
	ctx.r[21].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82ED8E88: C3291504  lfs f25, 0x1504(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(5380 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82ED8E8C: 3AF9005C  addi r23, r25, 0x5c
	ctx.r[23].s64 = ctx.r[25].s64 + 92;
	// 82ED8E90: C30A0BFC  lfs f24, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 82ED8E94: 3B4BDBF0  addi r26, r11, -0x2410
	ctx.r[26].s64 = ctx.r[11].s64 + -9232;
	pc = 0x82ED8E98; continue 'dispatch;
            }
            0x82ED8E98 => {
    //   block [0x82ED8E98..0x82ED8EAC)
	// 82ED8E98: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 82ED8E9C: 409A0010  bne cr6, 0x82ed8eac
	if !ctx.cr[6].eq {
	pc = 0x82ED8EAC; continue 'dispatch;
	}
	// 82ED8EA0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ED8EA4: 3B8000FF  li r28, 0xff
	ctx.r[28].s64 = 255;
	// 82ED8EA8: 48000014  b 0x82ed8ebc
	pc = 0x82ED8EBC; continue 'dispatch;
            }
            0x82ED8EAC => {
    //   block [0x82ED8EAC..0x82ED8EBC)
	// 82ED8EAC: 7F16A040  cmplw cr6, r22, r20
	ctx.cr[6].compare_u32(ctx.r[22].u32, ctx.r[20].u32, &mut ctx.xer);
	// 82ED8EB0: 3BC000FF  li r30, 0xff
	ctx.r[30].s64 = 255;
	// 82ED8EB4: 409A0010  bne cr6, 0x82ed8ec4
	if !ctx.cr[6].eq {
	pc = 0x82ED8EC4; continue 'dispatch;
	}
	// 82ED8EB8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x82ED8EBC; continue 'dispatch;
            }
            0x82ED8EBC => {
    //   block [0x82ED8EBC..0x82ED8EC4)
	// 82ED8EBC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82ED8EC0: 48000018  b 0x82ed8ed8
	pc = 0x82ED8ED8; continue 'dispatch;
            }
            0x82ED8EC4 => {
    //   block [0x82ED8EC4..0x82ED8ED8)
	// 82ED8EC4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82ED8EC8: FC00B65E  fctidz f0, f22
	ctx.f[0].s64 = if ctx.f[22].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[22].f64.trunc() as i64 };
	// 82ED8ECC: EED6A828  fsubs f22, f22, f21
	ctx.f[22].f64 = (((ctx.f[22].f64 - ctx.f[21].f64) as f32) as f64);
	// 82ED8ED0: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82ED8ED4: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82ED8ED8; continue 'dispatch;
            }
            0x82ED8ED8 => {
    //   block [0x82ED8ED8..0x82ED8EE8)
	// 82ED8ED8: C0190070  lfs f0, 0x70(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED8EDC: 3BF80008  addi r31, r24, 8
	ctx.r[31].s64 = ctx.r[24].s64 + 8;
	// 82ED8EE0: EFE00632  fmuls f31, f0, f24
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[24].f64) as f32) as f64);
	// 82ED8EE4: FFC0C890  fmr f30, f25
	ctx.f[30].f64 = ctx.f[25].f64;
	pc = 0x82ED8EE8; continue 'dispatch;
            }
            0x82ED8EE8 => {
    //   block [0x82ED8EE8..0x82ED9024)
	// 82ED8EE8: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82ED8EEC: 4B3610A5  bl 0x82239f90
	ctx.lr = 0x82ED8EF0;
	sub_82239F90(ctx, base);
	// 82ED8EF0: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 82ED8EF4: C1BA0000  lfs f13, 0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED8EF8: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82ED8EFC: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82ED8F00: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82ED8F04: EF800372  fmuls f28, f0, f13
	ctx.f[28].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED8F08: C1BA0004  lfs f13, 4(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED8F0C: EF600372  fmuls f27, f0, f13
	ctx.f[27].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED8F10: C1BA0008  lfs f13, 8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED8F14: EF400372  fmuls f26, f0, f13
	ctx.f[26].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED8F18: 4B360F99  bl 0x82239eb0
	ctx.lr = 0x82ED8F1C;
	sub_82239EB0(ctx, base);
	// 82ED8F1C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82ED8F20: C1BB0000  lfs f13, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED8F24: C19B0004  lfs f12, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED8F28: EFBEC828  fsubs f29, f30, f25
	ctx.f[29].f64 = (((ctx.f[30].f64 - ctx.f[25].f64) as f32) as f64);
	// 82ED8F2C: C17B0008  lfs f11, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED8F30: C15F0000  lfs f10, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82ED8F34: C13F0004  lfs f9, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82ED8F38: C11F0008  lfs f8, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82ED8F3C: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82ED8F40: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82ED8F44: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED8F48: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82ED8F4C: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82ED8F50: EDAD502A  fadds f13, f13, f10
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64;
	// 82ED8F54: ED89602A  fadds f12, f9, f12
	ctx.f[12].f64 = ((ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64;
	// 82ED8F58: EC08002A  fadds f0, f8, f0
	ctx.f[0].f64 = ((ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64;
	// 82ED8F5C: EDADE02A  fadds f13, f13, f28
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[28].f64) as f32) as f64;
	// 82ED8F60: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82ED8F64: EDACD82A  fadds f13, f12, f27
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[27].f64) as f32) as f64;
	// 82ED8F68: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82ED8F6C: EC00D02A  fadds f0, f0, f26
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[26].f64) as f32) as f64;
	// 82ED8F70: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82ED8F74: 4B36101D  bl 0x82239f90
	ctx.lr = 0x82ED8F78;
	sub_82239F90(ctx, base);
	// 82ED8F78: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 82ED8F7C: C1BA0000  lfs f13, 0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED8F80: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82ED8F84: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82ED8F88: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82ED8F8C: EFA00372  fmuls f29, f0, f13
	ctx.f[29].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED8F90: C1BA0004  lfs f13, 4(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED8F94: EF800372  fmuls f28, f0, f13
	ctx.f[28].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED8F98: C1BA0008  lfs f13, 8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED8F9C: EF600372  fmuls f27, f0, f13
	ctx.f[27].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED8FA0: 4B360F11  bl 0x82239eb0
	ctx.lr = 0x82ED8FA4;
	sub_82239EB0(ctx, base);
	// 82ED8FA4: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82ED8FA8: C1BB0000  lfs f13, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED8FAC: C19B0004  lfs f12, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED8FB0: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED8FB4: C17B0008  lfs f11, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED8FB8: C15F0000  lfs f10, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82ED8FBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED8FC0: C13F0004  lfs f9, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82ED8FC4: C11F0008  lfs f8, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82ED8FC8: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82ED8FCC: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED8FD0: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82ED8FD4: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82ED8FD8: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82ED8FDC: ED89602A  fadds f12, f9, f12
	ctx.f[12].f64 = ((ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64;
	// 82ED8FE0: EC08002A  fadds f0, f8, f0
	ctx.f[0].f64 = ((ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64;
	// 82ED8FE4: EDADE82A  fadds f13, f13, f29
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[29].f64) as f32) as f64;
	// 82ED8FE8: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82ED8FEC: EDACE02A  fadds f13, f12, f28
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[28].f64) as f32) as f64;
	// 82ED8FF0: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82ED8FF4: EC00D82A  fadds f0, f0, f27
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[27].f64) as f32) as f64;
	// 82ED8FF8: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82ED8FFC: 419A0028  beq cr6, 0x82ed9024
	if ctx.cr[6].eq {
	pc = 0x82ED9024; continue 'dispatch;
	}
	// 82ED9000: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82ED9004: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82ED9008: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ED900C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82ED9010: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82ED9014: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED9018: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED901C: 4E800421  bctrl
	ctx.lr = 0x82ED9020;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED9020: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
            }
            0x82ED9024 => {
    //   block [0x82ED9024..0x82ED90A0)
	// 82ED9024: EFDEC82A  fadds f30, f30, f25
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ((ctx.f[30].f64 + ctx.f[25].f64) as f32) as f64;
	// 82ED9028: FF1EB800  fcmpu cr6, f30, f23
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[23].f64);
	// 82ED902C: 4099FEBC  ble cr6, 0x82ed8ee8
	if !ctx.cr[6].gt {
	pc = 0x82ED8EE8; continue 'dispatch;
	}
	// 82ED9030: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 82ED9034: 419A006C  beq cr6, 0x82ed90a0
	if ctx.cr[6].eq {
	pc = 0x82ED90A0; continue 'dispatch;
	}
	// 82ED9038: C0180020  lfs f0, 0x20(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED903C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED9040: C1B900AC  lfs f13, 0xac(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(172 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED9044: C19900B0  lfs f12, 0xb0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(176 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED9048: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED904C: C13900A8  lfs f9, 0xa8(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(168 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82ED9050: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED9054: EC090032  fmuls f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED9058: C17F0008  lfs f11, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED905C: C15F0004  lfs f10, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82ED9060: C13F0000  lfs f9, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82ED9064: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82ED9068: D1A1007C  stfs f13, 0x7c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82ED906C: ED8B602A  fadds f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 82ED9070: D1810080  stfs f12, 0x80(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82ED9074: EC09002A  fadds f0, f9, f0
	ctx.f[0].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 82ED9078: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82ED907C: 419A0024  beq cr6, 0x82ed90a0
	if ctx.cr[6].eq {
	pc = 0x82ED90A0; continue 'dispatch;
	}
	// 82ED9080: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED9084: 38E00080  li r7, 0x80
	ctx.r[7].s64 = 128;
	// 82ED9088: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82ED908C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ED9090: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82ED9094: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED9098: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED909C: 4E800421  bctrl
	ctx.lr = 0x82ED90A0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED90A0 => {
    //   block [0x82ED90A0..0x82ED90DC)
	// 82ED90A0: 80790048  lwz r3, 0x48(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED90A4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82ED90A8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82ED90AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED90B0: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ED90B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED90B8: 4E800421  bctrl
	ctx.lr = 0x82ED90BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED90BC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED90C0: 4082001C  bne 0x82ed90dc
	if !ctx.cr[0].eq {
	pc = 0x82ED90DC; continue 'dispatch;
	}
	// 82ED90C4: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED90C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED90CC: 419A0064  beq cr6, 0x82ed9130
	if ctx.cr[6].eq {
	pc = 0x82ED9130; continue 'dispatch;
	}
	// 82ED90D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ED90D4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82ED90D8: 48000040  b 0x82ed9118
	pc = 0x82ED9118; continue 'dispatch;
            }
            0x82ED90DC => {
    //   block [0x82ED90DC..0x82ED9118)
	// 82ED90DC: 80790048  lwz r3, 0x48(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED90E0: 3BD90074  addi r30, r25, 0x74
	ctx.r[30].s64 = ctx.r[25].s64 + 116;
	// 82ED90E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ED90E8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ED90EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED90F0: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ED90F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED90F8: 4E800421  bctrl
	ctx.lr = 0x82ED90FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED90FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED9100: 40820030  bne 0x82ed9130
	if !ctx.cr[0].eq {
	pc = 0x82ED9130; continue 'dispatch;
	}
	// 82ED9104: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED9108: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED910C: 419A0024  beq cr6, 0x82ed9130
	if ctx.cr[6].eq {
	pc = 0x82ED9130; continue 'dispatch;
	}
	// 82ED9110: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82ED9114: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            0x82ED9118 => {
    //   block [0x82ED9118..0x82ED9130)
	// 82ED9118: 817D0048  lwz r11, 0x48(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED911C: 38A000FF  li r5, 0xff
	ctx.r[5].s64 = 255;
	// 82ED9120: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82ED9124: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82ED9128: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED912C: 4E800421  bctrl
	ctx.lr = 0x82ED9130;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED9130 => {
    //   block [0x82ED9130..0x82ED9140)
	// 82ED9130: 83180028  lwz r24, 0x28(r24)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ED9134: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 82ED9138: 28180000  cmplwi r24, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED913C: 4082FD5C  bne 0x82ed8e98
	if !ctx.cr[0].eq {
	pc = 0x82ED8E98; continue 'dispatch;
	}
	pc = 0x82ED9140; continue 'dispatch;
            }
            0x82ED9140 => {
    //   block [0x82ED9140..0x82ED9150)
	// 82ED9140: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 82ED9144: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 82ED9148: 4BDD4BC1  bl 0x82cadd08
	ctx.lr = 0x82ED914C;
	sub_82CADCEC(ctx, base);
	// 82ED914C: 4BDD02EC  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED9150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ED9150 size=888
    let mut pc: u32 = 0x82ED9150;
    'dispatch: loop {
        match pc {
            0x82ED9150 => {
    //   block [0x82ED9150..0x82ED918C)
	// 82ED9150: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED9154: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED9158: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ED915C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED9160: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 82ED9164: 4BDD4B71  bl 0x82cadcd4
	ctx.lr = 0x82ED9168;
	sub_82CADCA0(ctx, base);
	// 82ED9168: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED916C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED9170: 897F00E6  lbz r11, 0xe6(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(230 as u32) ) } as u64;
	// 82ED9174: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED9178: 41820014  beq 0x82ed918c
	if ctx.cr[0].eq {
	pc = 0x82ED918C; continue 'dispatch;
	}
	// 82ED917C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ED9180: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ED9184: 997F00E6  stb r11, 0xe6(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(230 as u32), ctx.r[11].u8 ) };
	// 82ED9188: 48000320  b 0x82ed94a8
	pc = 0x82ED94A8; continue 'dispatch;
            }
            0x82ED918C => {
    //   block [0x82ED918C..0x82ED919C)
	// 82ED918C: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82ED9190: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED9194: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82ED9198: 4098000C  bge cr6, 0x82ed91a4
	if !ctx.cr[6].lt {
	pc = 0x82ED91A4; continue 'dispatch;
	}
	pc = 0x82ED919C; continue 'dispatch;
            }
            0x82ED919C => {
    //   block [0x82ED919C..0x82ED91A4)
	// 82ED919C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82ED91A0: 48000308  b 0x82ed94a8
	pc = 0x82ED94A8; continue 'dispatch;
            }
            0x82ED91A4 => {
    //   block [0x82ED91A4..0x82ED9258)
	// 82ED91A4: 389F005C  addi r4, r31, 0x5c
	ctx.r[4].s64 = ctx.r[31].s64 + 92;
	// 82ED91A8: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED91AC: 3BDF0080  addi r30, r31, 0x80
	ctx.r[30].s64 = ctx.r[31].s64 + 128;
	// 82ED91B0: C17F0008  lfs f11, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED91B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED91B8: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED91BC: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED91C0: EF8C6828  fsubs f28, f12, f13
	ctx.f[28].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82ED91C4: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED91C8: C0030010  lfs f0, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED91CC: C1840000  lfs f12, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED91D0: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED91D4: EF6D6028  fsubs f27, f13, f12
	ctx.f[27].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82ED91D8: C12B0C4C  lfs f9, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82ED91DC: EC000272  fmuls f0, f0, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[9].f64) as f32) as f64);
	// 82ED91E0: EDBB06F2  fmuls f13, f27, f27
	ctx.f[13].f64 = (((ctx.f[27].f64 * ctx.f[27].f64) as f32) as f64);
	// 82ED91E4: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED91E8: EDBC6F3A  fmadds f13, f28, f28, f13
	ctx.f[13].f64 = (((ctx.f[28].f64 * ctx.f[28].f64 + ctx.f[13].f64) as f32) as f64);
	// 82ED91EC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ED91F0: 4198FFAC  blt cr6, 0x82ed919c
	if ctx.cr[6].lt {
	pc = 0x82ED919C; continue 'dispatch;
	}
	// 82ED91F4: C01F00A8  lfs f0, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED91F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED91FC: EC1B0032  fmuls f0, f27, f0
	ctx.f[0].f64 = (((ctx.f[27].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED9200: C1BF00B0  lfs f13, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED9204: C0DF00F8  lfs f6, 0xf8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82ED9208: EC0D073A  fmadds f0, f13, f28, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[28].f64 + ctx.f[0].f64) as f32) as f64);
	// 82ED920C: ECA001B2  fmuls f5, f0, f6
	ctx.f[5].f64 = (((ctx.f[0].f64 * ctx.f[6].f64) as f32) as f64);
	// 82ED9210: C00B0EE0  lfs f0, 0xee0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED9214: FF050000  fcmpu cr6, f5, f0
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[0].f64);
	// 82ED9218: 4198FF84  blt cr6, 0x82ed919c
	if ctx.cr[6].lt {
	pc = 0x82ED919C; continue 'dispatch;
	}
	// 82ED921C: C15F00C8  lfs f10, 0xc8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82ED9220: FDA05210  fabs f13, f10
	ctx.f[13].u64 = ctx.f[10].u64 & !0x8000_0000_0000_0000u64;
	// 82ED9224: C01F0040  lfs f0, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED9228: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ED922C: 4199FF70  bgt cr6, 0x82ed919c
	if ctx.cr[6].gt {
	pc = 0x82ED919C; continue 'dispatch;
	}
	// 82ED9230: 897F0014  lbz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED9234: C1A30010  lfs f13, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED9238: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED923C: 4182001C  beq 0x82ed9258
	if ctx.cr[0].eq {
	pc = 0x82ED9258; continue 'dispatch;
	}
	// 82ED9240: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED9244: C19F0018  lfs f12, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED9248: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED924C: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82ED9250: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED9254: 48000008  b 0x82ed925c
	pc = 0x82ED925C; continue 'dispatch;
            }
            0x82ED9258 => {
    //   block [0x82ED9258..0x82ED925C)
	// 82ED9258: FD806890  fmr f12, f13
	ctx.f[12].f64 = ctx.f[13].f64;
	pc = 0x82ED925C; continue 'dispatch;
            }
            0x82ED925C => {
    //   block [0x82ED925C..0x82ED9288)
	// 82ED925C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED9260: 815F0050  lwz r10, 0x50(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ED9264: C00B0BE8  lfs f0, 0xbe8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3048 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED9268: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED926C: C3CB0C18  lfs f30, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82ED9270: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED9274: FC0AF02E  fsel f0, f10, f0, f30
	ctx.f[0].f64 = if ctx.f[10].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[30].f64 };
	// 82ED9278: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED927C: EC00502A  fadds f0, f0, f10
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64;
	// 82ED9280: 7D4B5379  or. r11, r10, r10
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED9284: 4182FF18  beq 0x82ed919c
	if ctx.cr[0].eq {
	pc = 0x82ED919C; continue 'dispatch;
	}
	pc = 0x82ED9288; continue 'dispatch;
            }
            0x82ED9288 => {
    //   block [0x82ED9288..0x82ED92A0)
	// 82ED9288: C10B000C  lfs f8, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82ED928C: FF080000  fcmpu cr6, f8, f0
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[0].f64);
	// 82ED9290: 41990010  bgt cr6, 0x82ed92a0
	if ctx.cr[6].gt {
	pc = 0x82ED92A0; continue 'dispatch;
	}
	// 82ED9294: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ED9298: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED929C: 4082FFEC  bne 0x82ed9288
	if !ctx.cr[0].eq {
	pc = 0x82ED9288; continue 'dispatch;
	}
	pc = 0x82ED92A0; continue 'dispatch;
            }
            0x82ED92A0 => {
    //   block [0x82ED92A0..0x82ED92C4)
	// 82ED92A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED92A4: 419AFEF8  beq cr6, 0x82ed919c
	if ctx.cr[6].eq {
	pc = 0x82ED919C; continue 'dispatch;
	}
	// 82ED92A8: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED92AC: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82ED92B0: 4198FEEC  blt cr6, 0x82ed919c
	if ctx.cr[6].lt {
	pc = 0x82ED919C; continue 'dispatch;
	}
	// 82ED92B4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED92B8: 4099000C  ble cr6, 0x82ed92c4
	if !ctx.cr[6].gt {
	pc = 0x82ED92C4; continue 'dispatch;
	}
	// 82ED92BC: FFA06890  fmr f29, f13
	ctx.f[29].f64 = ctx.f[13].f64;
	// 82ED92C0: 48000008  b 0x82ed92c8
	pc = 0x82ED92C8; continue 'dispatch;
            }
            0x82ED92C4 => {
    //   block [0x82ED92C4..0x82ED92C8)
	// 82ED92C4: FFA00090  fmr f29, f0
	ctx.f[29].f64 = ctx.f[0].f64;
	pc = 0x82ED92C8; continue 'dispatch;
            }
            0x82ED92C8 => {
    //   block [0x82ED92C8..0x82ED92F4)
	// 82ED92C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED92CC: C19F0070  lfs f12, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED92D0: C11F0010  lfs f8, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82ED92D4: FDAA57AE  fsel f13, f10, f30, f10
	ctx.f[13].f64 = if ctx.f[10].f64 >= 0.0 { ctx.f[30].f64 } else { ctx.f[10].f64 };
	// 82ED92D8: FF0AF000  fcmpu cr6, f10, f30
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[30].f64);
	// 82ED92DC: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED92E0: EC0C403A  fmadds f0, f12, f0, f8
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 82ED92E4: EC8D0028  fsubs f4, f13, f0
	ctx.f[4].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED92E8: 4099000C  ble cr6, 0x82ed92f4
	if !ctx.cr[6].gt {
	pc = 0x82ED92F4; continue 'dispatch;
	}
	// 82ED92EC: FDA05090  fmr f13, f10
	ctx.f[13].f64 = ctx.f[10].f64;
	// 82ED92F0: 48000008  b 0x82ed92f8
	pc = 0x82ED92F8; continue 'dispatch;
            }
            0x82ED92F4 => {
    //   block [0x82ED92F4..0x82ED92F8)
	// 82ED92F4: FDA0F090  fmr f13, f30
	ctx.f[13].f64 = ctx.f[30].f64;
	pc = 0x82ED92F8; continue 'dispatch;
            }
            0x82ED92F8 => {
    //   block [0x82ED92F8..0x82ED9318)
	// 82ED92F8: ED6B0272  fmuls f11, f11, f9
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[9].f64) as f32) as f64);
	// 82ED92FC: C19F00B4  lfs f12, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED9300: ECED002A  fadds f7, f13, f0
	ctx.f[7].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82ED9304: EDA059BA  fmadds f13, f0, f6, f11
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[6].f64 + ctx.f[11].f64) as f32) as f64);
	// 82ED9308: EDAD282A  fadds f13, f13, f5
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[5].f64) as f32) as f64;
	// 82ED930C: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82ED9310: 41980008  blt cr6, 0x82ed9318
	if ctx.cr[6].lt {
	pc = 0x82ED9318; continue 'dispatch;
	}
	// 82ED9314: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	pc = 0x82ED9318; continue 'dispatch;
            }
            0x82ED9318 => {
    //   block [0x82ED9318..0x82ED9328)
	// 82ED9318: C3FF003C  lfs f31, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82ED931C: 7D4B5379  or. r11, r10, r10
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED9320: FD20F890  fmr f9, f31
	ctx.f[9].f64 = ctx.f[31].f64;
	// 82ED9324: 41820044  beq 0x82ed9368
	if ctx.cr[0].eq {
	pc = 0x82ED9368; continue 'dispatch;
	}
	pc = 0x82ED9328; continue 'dispatch;
            }
            0x82ED9328 => {
    //   block [0x82ED9328..0x82ED935C)
	// 82ED9328: C10B000C  lfs f8, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82ED932C: FF082000  fcmpu cr6, f8, f4
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[4].f64);
	// 82ED9330: 4198002C  blt cr6, 0x82ed935c
	if ctx.cr[6].lt {
	pc = 0x82ED935C; continue 'dispatch;
	}
	// 82ED9334: C10B0008  lfs f8, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82ED9338: FF083800  fcmpu cr6, f8, f7
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[7].f64);
	// 82ED933C: 4199002C  bgt cr6, 0x82ed9368
	if ctx.cr[6].gt {
	pc = 0x82ED9368; continue 'dispatch;
	}
	// 82ED9340: 892B0018  lbz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ED9344: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED9348: 40820014  bne 0x82ed935c
	if !ctx.cr[0].eq {
	pc = 0x82ED935C; continue 'dispatch;
	}
	// 82ED934C: C10B0010  lfs f8, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82ED9350: FF084800  fcmpu cr6, f8, f9
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[9].f64);
	// 82ED9354: 40980008  bge cr6, 0x82ed935c
	if !ctx.cr[6].lt {
	pc = 0x82ED935C; continue 'dispatch;
	}
	// 82ED9358: FD204090  fmr f9, f8
	ctx.f[9].f64 = ctx.f[8].f64;
	pc = 0x82ED935C; continue 'dispatch;
            }
            0x82ED935C => {
    //   block [0x82ED935C..0x82ED9368)
	// 82ED935C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ED9360: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED9364: 4082FFC4  bne 0x82ed9328
	if !ctx.cr[0].eq {
	pc = 0x82ED9328; continue 'dispatch;
	}
	pc = 0x82ED9368; continue 'dispatch;
            }
            0x82ED9368 => {
    //   block [0x82ED9368..0x82ED938C)
	// 82ED9368: FF096800  fcmpu cr6, f9, f13
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[13].f64);
	// 82ED936C: 4198FE30  blt cr6, 0x82ed919c
	if ctx.cr[6].lt {
	pc = 0x82ED919C; continue 'dispatch;
	}
	// 82ED9370: EDA059BA  fmadds f13, f0, f6, f11
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[6].f64 + ctx.f[11].f64) as f32) as f64);
	// 82ED9374: ED6A0028  fsubs f11, f10, f0
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED9378: ED4A002A  fadds f10, f10, f0
	ctx.f[10].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82ED937C: EDAD282A  fadds f13, f13, f5
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[5].f64) as f32) as f64;
	// 82ED9380: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82ED9384: 41980008  blt cr6, 0x82ed938c
	if ctx.cr[6].lt {
	pc = 0x82ED938C; continue 'dispatch;
	}
	// 82ED9388: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	pc = 0x82ED938C; continue 'dispatch;
            }
            0x82ED938C => {
    //   block [0x82ED938C..0x82ED9394)
	// 82ED938C: 7D4B5379  or. r11, r10, r10
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED9390: 41820038  beq 0x82ed93c8
	if ctx.cr[0].eq {
	pc = 0x82ED93C8; continue 'dispatch;
	}
	pc = 0x82ED9394; continue 'dispatch;
            }
            0x82ED9394 => {
    //   block [0x82ED9394..0x82ED93BC)
	// 82ED9394: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED9398: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82ED939C: 41980020  blt cr6, 0x82ed93bc
	if ctx.cr[6].lt {
	pc = 0x82ED93BC; continue 'dispatch;
	}
	// 82ED93A0: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED93A4: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82ED93A8: 41990020  bgt cr6, 0x82ed93c8
	if ctx.cr[6].gt {
	pc = 0x82ED93C8; continue 'dispatch;
	}
	// 82ED93AC: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED93B0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82ED93B4: 40980008  bge cr6, 0x82ed93bc
	if !ctx.cr[6].lt {
	pc = 0x82ED93BC; continue 'dispatch;
	}
	// 82ED93B8: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	pc = 0x82ED93BC; continue 'dispatch;
            }
            0x82ED93BC => {
    //   block [0x82ED93BC..0x82ED93C8)
	// 82ED93BC: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ED93C0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED93C4: 4082FFD0  bne 0x82ed9394
	if !ctx.cr[0].eq {
	pc = 0x82ED9394; continue 'dispatch;
	}
	pc = 0x82ED93C8; continue 'dispatch;
            }
            0x82ED93C8 => {
    //   block [0x82ED93C8..0x82ED93F8)
	// 82ED93C8: FF1F6800  fcmpu cr6, f31, f13
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[13].f64);
	// 82ED93CC: 4198FDD0  blt cr6, 0x82ed919c
	if ctx.cr[6].lt {
	pc = 0x82ED919C; continue 'dispatch;
	}
	// 82ED93D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED93D4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82ED93D8: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ED93DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED93E0: 4E800421  bctrl
	ctx.lr = 0x82ED93E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED93E4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED93E8: 4182FDB4  beq 0x82ed919c
	if ctx.cr[0].eq {
	pc = 0x82ED919C; continue 'dispatch;
	}
	// 82ED93EC: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82ED93F0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82ED93F4: 48000028  b 0x82ed941c
	pc = 0x82ED941C; continue 'dispatch;
            }
            0x82ED93F8 => {
    //   block [0x82ED93F8..0x82ED941C)
	// 82ED93F8: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED93FC: 9949002C  stb r10, 0x2c(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(44 as u32), ctx.r[10].u8 ) };
	// 82ED9400: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED9404: 80EB0010  lwz r7, 0x10(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED9408: 81090028  lwz r8, 0x28(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ED940C: 90E90028  stw r7, 0x28(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(40 as u32), ctx.r[7].u32 ) };
	// 82ED9410: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED9414: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82ED9418: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	pc = 0x82ED941C; continue 'dispatch;
            }
            0x82ED941C => {
    //   block [0x82ED941C..0x82ED94A8)
	// 82ED941C: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED9420: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82ED9424: 409AFFD4  bne cr6, 0x82ed93f8
	if !ctx.cr[6].eq {
	pc = 0x82ED93F8; continue 'dispatch;
	}
	// 82ED9428: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82ED942C: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82ED9430: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82ED9434: C01F0090  lfs f0, 0x90(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED9438: EC0006F2  fmuls f0, f0, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82ED943C: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82ED9440: 3929AFB4  addi r9, r9, -0x504c
	ctx.r[9].s64 = ctx.r[9].s64 + -20556;
	// 82ED9444: C19E0000  lfs f12, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED9448: 3908AFB4  addi r8, r8, -0x504c
	ctx.r[8].s64 = ctx.r[8].s64 + -20556;
	// 82ED944C: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82ED9450: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED9454: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82ED9458: C1BF0098  lfs f13, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED945C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82ED9460: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82ED9464: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82ED9468: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED946C: 809F00C4  lwz r4, 0xc4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82ED9470: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82ED9474: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 82ED9478: D3C10070  stfs f30, 0x70(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82ED947C: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82ED9480: D3A1007C  stfs f29, 0x7c(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82ED9484: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82ED9488: EC0D073A  fmadds f0, f13, f28, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[28].f64 + ctx.f[0].f64) as f32) as f64);
	// 82ED948C: D181006C  stfs f12, 0x6c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82ED9490: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82ED9494: 4800B975  bl 0x82ee4e08
	ctx.lr = 0x82ED9498;
	sub_82EE4E08(ctx, base);
	// 82ED9498: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82ED949C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ED94A0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED94A4: 917F00E0  stw r11, 0xe0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	pc = 0x82ED94A8; continue 'dispatch;
            }
            0x82ED94A8 => {
    //   block [0x82ED94A8..0x82ED94C8)
	// 82ED94A8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82ED94AC: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 82ED94B0: 4BDD4871  bl 0x82cadd20
	ctx.lr = 0x82ED94B4;
	sub_82CADCEC(ctx, base);
	// 82ED94B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED94B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED94BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ED94C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED94C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED94C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ED94C8 size=1024
    let mut pc: u32 = 0x82ED94C8;
    'dispatch: loop {
        match pc {
            0x82ED94C8 => {
    //   block [0x82ED94C8..0x82ED94EC)
	// 82ED94C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED94CC: 4BDCFF31  bl 0x82ca93fc
	ctx.lr = 0x82ED94D0;
	sub_82CA93D0(ctx, base);
	// 82ED94D0: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 82ED94D4: 4BDD47FD  bl 0x82cadcd0
	ctx.lr = 0x82ED94D8;
	sub_82CADCA0(ctx, base);
	// 82ED94D8: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED94DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED94E0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ED94E4: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82ED94E8: 48000028  b 0x82ed9510
	pc = 0x82ED9510; continue 'dispatch;
            }
            0x82ED94EC => {
    //   block [0x82ED94EC..0x82ED9510)
	// 82ED94EC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED94F0: 9BCA002C  stb r30, 0x2c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(44 as u32), ctx.r[30].u8 ) };
	// 82ED94F4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED94F8: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82ED94FC: 812A0028  lwz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ED9500: 910A0028  stw r8, 0x28(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(40 as u32), ctx.r[8].u32 ) };
	// 82ED9504: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED9508: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82ED950C: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	pc = 0x82ED9510; continue 'dispatch;
            }
            0x82ED9510 => {
    //   block [0x82ED9510..0x82ED9570)
	// 82ED9510: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED9514: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82ED9518: 409AFFD4  bne cr6, 0x82ed94ec
	if !ctx.cr[6].eq {
	pc = 0x82ED94EC; continue 'dispatch;
	}
	// 82ED951C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ED9520: 93CB000C  stw r30, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82ED9524: 93CB0014  stw r30, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82ED9528: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82ED952C: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82ED9530: C01F0070  lfs f0, 0x70(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED9534: C1BF0010  lfs f13, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED9538: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82ED953C: C3DF00B4  lfs f30, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82ED9540: 7FD9F378  mr r25, r30
	ctx.r[25].u64 = ctx.r[30].u64;
	// 82ED9544: C34A0BFC  lfs f26, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82ED9548: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82ED954C: EDA06EBA  fmadds f13, f0, f26, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[26].f64 + ctx.f[13].f64) as f32) as f64);
	// 82ED9550: 3BAAAFB4  addi r29, r10, -0x504c
	ctx.r[29].s64 = ctx.r[10].s64 + -20556;
	// 82ED9554: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED9558: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ED955C: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 82ED9560: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82ED9564: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED9568: C36A0C18  lfs f27, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82ED956C: 48000064  b 0x82ed95d0
	pc = 0x82ED95D0; continue 'dispatch;
            }
            0x82ED9570 => {
    //   block [0x82ED9570..0x82ED9588)
	// 82ED9570: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82ED9574: 409A0014  bne cr6, 0x82ed9588
	if !ctx.cr[6].eq {
	pc = 0x82ED9588; continue 'dispatch;
	}
	// 82ED9578: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED957C: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82ED9580: 41980008  blt cr6, 0x82ed9588
	if ctx.cr[6].lt {
	pc = 0x82ED9588; continue 'dispatch;
	}
	// 82ED9584: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	pc = 0x82ED9588; continue 'dispatch;
            }
            0x82ED9588 => {
    //   block [0x82ED9588..0x82ED95B0)
	// 82ED9588: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82ED958C: 409A0024  bne cr6, 0x82ed95b0
	if !ctx.cr[6].eq {
	pc = 0x82ED95B0; continue 'dispatch;
	}
	// 82ED9590: FC006850  fneg f0, f13
	ctx.f[0].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 82ED9594: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED9598: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82ED959C: 40990030  ble cr6, 0x82ed95cc
	if !ctx.cr[6].gt {
	pc = 0x82ED95CC; continue 'dispatch;
	}
	// 82ED95A0: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82ED95A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED95A8: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 82ED95AC: 419A0020  beq cr6, 0x82ed95cc
	if ctx.cr[6].eq {
	pc = 0x82ED95CC; continue 'dispatch;
	}
	pc = 0x82ED95B0; continue 'dispatch;
            }
            0x82ED95B0 => {
    //   block [0x82ED95B0..0x82ED95C0)
	// 82ED95B0: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED95B4: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82ED95B8: 40980008  bge cr6, 0x82ed95c0
	if !ctx.cr[6].lt {
	pc = 0x82ED95C0; continue 'dispatch;
	}
	// 82ED95BC: FFC00090  fmr f30, f0
	ctx.f[30].f64 = ctx.f[0].f64;
	pc = 0x82ED95C0; continue 'dispatch;
            }
            0x82ED95C0 => {
    //   block [0x82ED95C0..0x82ED95CC)
	// 82ED95C0: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED95C4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED95C8: 41990014  bgt cr6, 0x82ed95dc
	if ctx.cr[6].gt {
	pc = 0x82ED95DC; continue 'dispatch;
	}
	pc = 0x82ED95CC; continue 'dispatch;
            }
            0x82ED95CC => {
    //   block [0x82ED95CC..0x82ED95D0)
	// 82ED95CC: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	pc = 0x82ED95D0; continue 'dispatch;
            }
            0x82ED95D0 => {
    //   block [0x82ED95D0..0x82ED95DC)
	// 82ED95D0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED95D4: 4082FF9C  bne 0x82ed9570
	if !ctx.cr[0].eq {
	pc = 0x82ED9570; continue 'dispatch;
	}
	// 82ED95D8: 48000008  b 0x82ed95e0
	pc = 0x82ED95E0; continue 'dispatch;
            }
            0x82ED95DC => {
    //   block [0x82ED95DC..0x82ED95E0)
	// 82ED95DC: 7D795B78  mr r25, r11
	ctx.r[25].u64 = ctx.r[11].u64;
	pc = 0x82ED95E0; continue 'dispatch;
            }
            0x82ED95E0 => {
    //   block [0x82ED95E0..0x82ED9614)
	// 82ED95E0: 89690018  lbz r11, 0x18(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ED95E4: 7FDAF378  mr r26, r30
	ctx.r[26].u64 = ctx.r[30].u64;
	// 82ED95E8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED95EC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED95F0: 3B8BAFB4  addi r28, r11, -0x504c
	ctx.r[28].s64 = ctx.r[11].s64 + -20556;
	// 82ED95F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82ED95F8: 3B6B9128  addi r27, r11, -0x6ed8
	ctx.r[27].s64 = ctx.r[11].s64 + -28376;
	// 82ED95FC: 41820018  beq 0x82ed9614
	if ctx.cr[0].eq {
	pc = 0x82ED9614; continue 'dispatch;
	}
	// 82ED9600: C01F00F8  lfs f0, 0xf8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED9604: C1BF00BC  lfs f13, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED9608: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED960C: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 82ED9610: 409900C4  ble cr6, 0x82ed96d4
	if !ctx.cr[6].gt {
	pc = 0x82ED96D4; continue 'dispatch;
	}
	pc = 0x82ED9614; continue 'dispatch;
            }
            0x82ED9614 => {
    //   block [0x82ED9614..0x82ED96C0)
	// 82ED9614: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED9618: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82ED961C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82ED9620: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82ED9624: FC20D890  fmr f1, f27
	ctx.f[1].f64 = ctx.f[27].f64;
	// 82ED9628: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ED962C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82ED9630: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82ED9634: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED9638: 4E800421  bctrl
	ctx.lr = 0x82ED963C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED963C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82ED9640: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 82ED9644: 809F00C4  lwz r4, 0xc4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82ED9648: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82ED964C: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82ED9650: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82ED9654: 4800B7B5  bl 0x82ee4e08
	ctx.lr = 0x82ED9658;
	sub_82EE4E08(ctx, base);
	// 82ED9658: C01F00B4  lfs f0, 0xb4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED965C: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 82ED9660: 419A0258  beq cr6, 0x82ed98b8
	if ctx.cr[6].eq {
	pc = 0x82ED98B8; continue 'dispatch;
	}
	// 82ED9664: C01F00F8  lfs f0, 0xf8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED9668: C1BF00BC  lfs f13, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED966C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED9670: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 82ED9674: 41990244  bgt cr6, 0x82ed98b8
	if ctx.cr[6].gt {
	pc = 0x82ED98B8; continue 'dispatch;
	}
	// 82ED9678: 897F0014  lbz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82ED967C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED9680: 41820048  beq 0x82ed96c8
	if ctx.cr[0].eq {
	pc = 0x82ED96C8; continue 'dispatch;
	}
	// 82ED9684: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED9688: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82ED968C: 4099003C  ble cr6, 0x82ed96c8
	if !ctx.cr[6].gt {
	pc = 0x82ED96C8; continue 'dispatch;
	}
	// 82ED9690: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED9694: 815F00C4  lwz r10, 0xc4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82ED9698: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED969C: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82ED96A0: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82ED96A4: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED96A8: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED96AC: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82ED96B0: C1AB0020  lfs f13, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED96B4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ED96B8: 40980008  bge cr6, 0x82ed96c0
	if !ctx.cr[6].lt {
	pc = 0x82ED96C0; continue 'dispatch;
	}
	// 82ED96BC: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
            }
            0x82ED96C0 => {
    //   block [0x82ED96C0..0x82ED96C8)
	// 82ED96C0: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED96C4: 41820008  beq 0x82ed96cc
	if ctx.cr[0].eq {
	pc = 0x82ED96CC; continue 'dispatch;
	}
	pc = 0x82ED96C8; continue 'dispatch;
            }
            0x82ED96C8 => {
    //   block [0x82ED96C8..0x82ED96CC)
	// 82ED96C8: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	pc = 0x82ED96CC; continue 'dispatch;
            }
            0x82ED96CC => {
    //   block [0x82ED96CC..0x82ED96D4)
	// 82ED96CC: 8101005C  lwz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82ED96D0: 936100B0  stw r27, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[27].u32 ) };
	pc = 0x82ED96D4; continue 'dispatch;
            }
            0x82ED96D4 => {
    //   block [0x82ED96D4..0x82ED96F8)
	// 82ED96D4: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 82ED96D8: C01F0070  lfs f0, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED96DC: C1BF0040  lfs f13, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED96E0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82ED96E4: C3FF000C  lfs f31, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82ED96E8: FFA0F090  fmr f29, f30
	ctx.f[29].f64 = ctx.f[30].f64;
	// 82ED96EC: EF806EBC  fnmsubs f28, f0, f26, f13
	ctx.f[28].f64 = -(((ctx.f[0].f64 * ctx.f[26].f64 - ctx.f[13].f64) as f32) as f64);
	// 82ED96F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ED96F4: 480000D0  b 0x82ed97c4
	pc = 0x82ED97C4; continue 'dispatch;
            }
            0x82ED96F8 => {
    //   block [0x82ED96F8..0x82ED970C)
	// 82ED96F8: C01F0070  lfs f0, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED96FC: EDA0FEBA  fmadds f13, f0, f26, f31
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[26].f64 + ctx.f[31].f64) as f32) as f64);
	// 82ED9700: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED9704: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82ED9708: 40990030  ble cr6, 0x82ed9738
	if !ctx.cr[6].gt {
	pc = 0x82ED9738; continue 'dispatch;
	}
	pc = 0x82ED970C; continue 'dispatch;
            }
            0x82ED970C => {
    //   block [0x82ED970C..0x82ED972C)
	// 82ED970C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82ED9710: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ED9714: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED9718: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82ED971C: 40980010  bge cr6, 0x82ed972c
	if !ctx.cr[6].lt {
	pc = 0x82ED972C; continue 'dispatch;
	}
	// 82ED9720: FFA00090  fmr f29, f0
	ctx.f[29].f64 = ctx.f[0].f64;
	// 82ED9724: FF1DD800  fcmpu cr6, f29, f27
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[27].f64);
	// 82ED9728: 419A00A4  beq cr6, 0x82ed97cc
	if ctx.cr[6].eq {
	pc = 0x82ED97CC; continue 'dispatch;
	}
	pc = 0x82ED972C; continue 'dispatch;
            }
            0x82ED972C => {
    //   block [0x82ED972C..0x82ED9738)
	// 82ED972C: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED9730: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ED9734: 4199FFD8  bgt cr6, 0x82ed970c
	if ctx.cr[6].gt {
	pc = 0x82ED970C; continue 'dispatch;
	}
	pc = 0x82ED9738; continue 'dispatch;
            }
            0x82ED9738 => {
    //   block [0x82ED9738..0x82ED9780)
	// 82ED9738: FF1DD800  fcmpu cr6, f29, f27
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[27].f64);
	// 82ED973C: 419A0090  beq cr6, 0x82ed97cc
	if ctx.cr[6].eq {
	pc = 0x82ED97CC; continue 'dispatch;
	}
	// 82ED9740: 894B0018  lbz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ED9744: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED9748: 40820074  bne 0x82ed97bc
	if !ctx.cr[0].eq {
	pc = 0x82ED97BC; continue 'dispatch;
	}
	// 82ED974C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED9750: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82ED9754: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82ED9758: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82ED975C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82ED9760: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ED9764: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82ED9768: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82ED976C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED9770: 4E800421  bctrl
	ctx.lr = 0x82ED9774;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED9774: 809F00C4  lwz r4, 0xc4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82ED9778: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED977C: 48000018  b 0x82ed9794
	pc = 0x82ED9794; continue 'dispatch;
            }
            0x82ED9780 => {
    //   block [0x82ED9780..0x82ED9794)
	// 82ED9780: C00B0014  lfs f0, 0x14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED9784: C1A10080  lfs f13, 0x80(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED9788: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED978C: 40980010  bge cr6, 0x82ed979c
	if !ctx.cr[6].lt {
	pc = 0x82ED979C; continue 'dispatch;
	}
	// 82ED9790: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	pc = 0x82ED9794; continue 'dispatch;
            }
            0x82ED9794 => {
    //   block [0x82ED9794..0x82ED979C)
	// 82ED9794: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED9798: 4082FFE8  bne 0x82ed9780
	if !ctx.cr[0].eq {
	pc = 0x82ED9780; continue 'dispatch;
	}
	pc = 0x82ED979C; continue 'dispatch;
            }
            0x82ED979C => {
    //   block [0x82ED979C..0x82ED97BC)
	// 82ED979C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82ED97A0: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82ED97A4: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82ED97A8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82ED97AC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82ED97B0: 4800B659  bl 0x82ee4e08
	ctx.lr = 0x82ED97B4;
	sub_82EE4E08(ctx, base);
	// 82ED97B4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82ED97B8: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	pc = 0x82ED97BC; continue 'dispatch;
            }
            0x82ED97BC => {
    //   block [0x82ED97BC..0x82ED97C4)
	// 82ED97BC: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED97C0: EFFF002A  fadds f31, f31, f0
	ctx.f[31].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	pc = 0x82ED97C4; continue 'dispatch;
            }
            0x82ED97C4 => {
    //   block [0x82ED97C4..0x82ED97CC)
	// 82ED97C4: FF1FE000  fcmpu cr6, f31, f28
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[28].f64);
	// 82ED97C8: 4198FF30  blt cr6, 0x82ed96f8
	if ctx.cr[6].lt {
	pc = 0x82ED96F8; continue 'dispatch;
	}
	pc = 0x82ED97CC; continue 'dispatch;
            }
            0x82ED97CC => {
    //   block [0x82ED97CC..0x82ED97E4)
	// 82ED97CC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82ED97D0: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED97D4: FFA0E050  fneg f29, f28
	ctx.f[29].u64 = ctx.f[28].u64 ^ 0x8000_0000_0000_0000u64;
	// 82ED97D8: FFE00050  fneg f31, f0
	ctx.f[31].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82ED97DC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ED97E0: 480000D0  b 0x82ed98b0
	pc = 0x82ED98B0; continue 'dispatch;
            }
            0x82ED97E4 => {
    //   block [0x82ED97E4..0x82ED97F8)
	// 82ED97E4: C01F0070  lfs f0, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED97E8: EDA0FEBC  fnmsubs f13, f0, f26, f31
	ctx.f[13].f64 = -(((ctx.f[0].f64 * ctx.f[26].f64 - ctx.f[31].f64) as f32) as f64);
	// 82ED97EC: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED97F0: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82ED97F4: 40980030  bge cr6, 0x82ed9824
	if !ctx.cr[6].lt {
	pc = 0x82ED9824; continue 'dispatch;
	}
	pc = 0x82ED97F8; continue 'dispatch;
            }
            0x82ED97F8 => {
    //   block [0x82ED97F8..0x82ED9818)
	// 82ED97F8: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82ED97FC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82ED9800: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED9804: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82ED9808: 40980010  bge cr6, 0x82ed9818
	if !ctx.cr[6].lt {
	pc = 0x82ED9818; continue 'dispatch;
	}
	// 82ED980C: FFC00090  fmr f30, f0
	ctx.f[30].f64 = ctx.f[0].f64;
	// 82ED9810: FF1ED800  fcmpu cr6, f30, f27
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[27].f64);
	// 82ED9814: 419A00A4  beq cr6, 0x82ed98b8
	if ctx.cr[6].eq {
	pc = 0x82ED98B8; continue 'dispatch;
	}
	pc = 0x82ED9818; continue 'dispatch;
            }
            0x82ED9818 => {
    //   block [0x82ED9818..0x82ED9824)
	// 82ED9818: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED981C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82ED9820: 4198FFD8  blt cr6, 0x82ed97f8
	if ctx.cr[6].lt {
	pc = 0x82ED97F8; continue 'dispatch;
	}
	pc = 0x82ED9824; continue 'dispatch;
            }
            0x82ED9824 => {
    //   block [0x82ED9824..0x82ED986C)
	// 82ED9824: FF1ED800  fcmpu cr6, f30, f27
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[27].f64);
	// 82ED9828: 419A0090  beq cr6, 0x82ed98b8
	if ctx.cr[6].eq {
	pc = 0x82ED98B8; continue 'dispatch;
	}
	// 82ED982C: 894B0018  lbz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82ED9830: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED9834: 40820074  bne 0x82ed98a8
	if !ctx.cr[0].eq {
	pc = 0x82ED98A8; continue 'dispatch;
	}
	// 82ED9838: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED983C: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82ED9840: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82ED9844: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82ED9848: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82ED984C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ED9850: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82ED9854: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82ED9858: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED985C: 4E800421  bctrl
	ctx.lr = 0x82ED9860;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED9860: 809F00C4  lwz r4, 0xc4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82ED9864: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED9868: 48000018  b 0x82ed9880
	pc = 0x82ED9880; continue 'dispatch;
            }
            0x82ED986C => {
    //   block [0x82ED986C..0x82ED9880)
	// 82ED986C: C00B0014  lfs f0, 0x14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED9870: C1A100A0  lfs f13, 0xa0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED9874: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED9878: 40980010  bge cr6, 0x82ed9888
	if !ctx.cr[6].lt {
	pc = 0x82ED9888; continue 'dispatch;
	}
	// 82ED987C: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	pc = 0x82ED9880; continue 'dispatch;
            }
            0x82ED9880 => {
    //   block [0x82ED9880..0x82ED9888)
	// 82ED9880: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED9884: 4082FFE8  bne 0x82ed986c
	if !ctx.cr[0].eq {
	pc = 0x82ED986C; continue 'dispatch;
	}
	pc = 0x82ED9888; continue 'dispatch;
            }
            0x82ED9888 => {
    //   block [0x82ED9888..0x82ED98A8)
	// 82ED9888: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82ED988C: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82ED9890: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82ED9894: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82ED9898: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82ED989C: 4800B56D  bl 0x82ee4e08
	ctx.lr = 0x82ED98A0;
	sub_82EE4E08(ctx, base);
	// 82ED98A0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82ED98A4: 93610090  stw r27, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[27].u32 ) };
	pc = 0x82ED98A8; continue 'dispatch;
            }
            0x82ED98A8 => {
    //   block [0x82ED98A8..0x82ED98B0)
	// 82ED98A8: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED98AC: EFFF0028  fsubs f31, f31, f0
	ctx.f[31].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	pc = 0x82ED98B0; continue 'dispatch;
            }
            0x82ED98B0 => {
    //   block [0x82ED98B0..0x82ED98B8)
	// 82ED98B0: FF1FE800  fcmpu cr6, f31, f29
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[29].f64);
	// 82ED98B4: 4199FF30  bgt cr6, 0x82ed97e4
	if ctx.cr[6].gt {
	pc = 0x82ED97E4; continue 'dispatch;
	}
	pc = 0x82ED98B8; continue 'dispatch;
            }
            0x82ED98B8 => {
    //   block [0x82ED98B8..0x82ED98C8)
	// 82ED98B8: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 82ED98BC: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 82ED98C0: 4BDD445D  bl 0x82cadd1c
	ctx.lr = 0x82ED98C4;
	sub_82CADCEC(ctx, base);
	// 82ED98C4: 4BDCFB88  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED98C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ED98C8 size=180
    let mut pc: u32 = 0x82ED98C8;
    'dispatch: loop {
        match pc {
            0x82ED98C8 => {
    //   block [0x82ED98C8..0x82ED9934)
	// 82ED98C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED98CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED98D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82ED98D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED98D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED98DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED98E0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82ED98E4: 897F00E5  lbz r11, 0xe5(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(229 as u32) ) } as u64;
	// 82ED98E8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED98EC: 4182006C  beq 0x82ed9958
	if ctx.cr[0].eq {
	pc = 0x82ED9958; continue 'dispatch;
	}
	// 82ED98F0: 9BDF00E5  stb r30, 0xe5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(229 as u32), ctx.r[30].u8 ) };
	// 82ED98F4: 4BFFF85D  bl 0x82ed9150
	ctx.lr = 0x82ED98F8;
	sub_82ED9150(ctx, base);
	// 82ED98F8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82ED98FC: 40820068  bne 0x82ed9964
	if !ctx.cr[0].eq {
	pc = 0x82ED9964; continue 'dispatch;
	}
	// 82ED9900: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED9904: 4BFFFBC5  bl 0x82ed94c8
	ctx.lr = 0x82ED9908;
	sub_82ED94C8(ctx, base);
	// 82ED9908: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82ED990C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82ED9910: 917F00E0  stw r11, 0xe0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	// 82ED9914: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82ED9918: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED991C: 409A003C  bne cr6, 0x82ed9958
	if !ctx.cr[6].eq {
	pc = 0x82ED9958; continue 'dispatch;
	}
	// 82ED9920: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82ED9924: C01F0024  lfs f0, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED9928: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82ED992C: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 82ED9930: 48000028  b 0x82ed9958
	pc = 0x82ED9958; continue 'dispatch;
            }
            0x82ED9934 => {
    //   block [0x82ED9934..0x82ED9958)
	// 82ED9934: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82ED9938: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82ED993C: 40980028  bge cr6, 0x82ed9964
	if !ctx.cr[6].lt {
	pc = 0x82ED9964; continue 'dispatch;
	}
	// 82ED9940: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED9944: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED9948: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82ED994C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED9950: 4E800421  bctrl
	ctx.lr = 0x82ED9954;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82ED9954: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
            }
            0x82ED9958 => {
    //   block [0x82ED9958..0x82ED9964)
	// 82ED9958: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 82ED995C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82ED9960: 409AFFD4  bne cr6, 0x82ed9934
	if !ctx.cr[6].eq {
	pc = 0x82ED9934; continue 'dispatch;
	}
	pc = 0x82ED9964; continue 'dispatch;
            }
            0x82ED9964 => {
    //   block [0x82ED9964..0x82ED997C)
	// 82ED9964: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82ED9968: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED996C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED9970: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82ED9974: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED9978: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED9980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82ED9980 size=136
    let mut pc: u32 = 0x82ED9980;
    'dispatch: loop {
        match pc {
            0x82ED9980 => {
    //   block [0x82ED9980..0x82ED99C0)
	// 82ED9980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED9984: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82ED9988: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82ED998C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED9990: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82ED9994: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED9998: 396BBB08  addi r11, r11, -0x44f8
	ctx.r[11].s64 = ctx.r[11].s64 + -17656;
	// 82ED999C: 807F00D4  lwz r3, 0xd4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82ED99A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED99A4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82ED99A8: 41820018  beq 0x82ed99c0
	if ctx.cr[0].eq {
	pc = 0x82ED99C0; continue 'dispatch;
	}
	// 82ED99AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED99B0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ED99B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED99B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED99BC: 4E800421  bctrl
	ctx.lr = 0x82ED99C0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED99C0 => {
    //   block [0x82ED99C0..0x82ED99E0)
	// 82ED99C0: 807F0118  lwz r3, 0x118(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82ED99C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED99C8: 41820018  beq 0x82ed99e0
	if ctx.cr[0].eq {
	pc = 0x82ED99E0; continue 'dispatch;
	}
	// 82ED99CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED99D0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82ED99D4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82ED99D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82ED99DC: 4E800421  bctrl
	ctx.lr = 0x82ED99E0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82ED99E0 => {
    //   block [0x82ED99E0..0x82ED9A08)
	// 82ED99E0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82ED99E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED99E8: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82ED99EC: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 82ED99F0: 4BFDB9D9  bl 0x82eb53c8
	ctx.lr = 0x82ED99F4;
	sub_82EB53C8(ctx, base);
	// 82ED99F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82ED99F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82ED99FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82ED9A00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82ED9A04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED9A08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82ED9A08 size=12
    let mut pc: u32 = 0x82ED9A08;
    'dispatch: loop {
        match pc {
            0x82ED9A08 => {
    //   block [0x82ED9A08..0x82ED9A14)
	// 82ED9A08: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82ED9A0C: 386B89BC  addi r3, r11, -0x7644
	ctx.r[3].s64 = ctx.r[11].s64 + -30276;
	// 82ED9A10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED9A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82ED9A18 size=52
    let mut pc: u32 = 0x82ED9A18;
    'dispatch: loop {
        match pc {
            0x82ED9A18 => {
    //   block [0x82ED9A18..0x82ED9A4C)
	// 82ED9A18: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82ED9A1C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED9A20: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
	// 82ED9A24: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED9A28: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED9A2C: C1AB0C18  lfs f13, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED9A30: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED9A34: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 82ED9A38: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED9A3C: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED9A40: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82ED9A44: D0030104  stfs f0, 0x104(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82ED9A48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82ED9A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82ED9A50 size=1988
    let mut pc: u32 = 0x82ED9A50;
    'dispatch: loop {
        match pc {
            0x82ED9A50 => {
    //   block [0x82ED9A50..0x82ED9AAC)
	// 82ED9A50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82ED9A54: 4BDCF9B5  bl 0x82ca9408
	ctx.lr = 0x82ED9A58;
	sub_82CA93D0(ctx, base);
	// 82ED9A58: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82ED9A5C: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82ED9A60: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82ED9A64: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82ED9A68: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82ED9A6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED9A70: 482E25F1  bl 0x831bc060
	ctx.lr = 0x82ED9A74;
	sub_831BC060(ctx, base);
	// 82ED9A74: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82ED9A78: 41820788  beq 0x82eda200
	if ctx.cr[0].eq {
	pc = 0x82EDA200; continue 'dispatch;
	}
	// 82ED9A7C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED9A80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED9A84: 388BBC30  addi r4, r11, -0x43d0
	ctx.r[4].s64 = ctx.r[11].s64 + -17360;
	// 82ED9A88: 4BDD30C9  bl 0x82cacb50
	ctx.lr = 0x82ED9A8C;
	sub_82CACB50(ctx, base);
	// 82ED9A8C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED9A90: 40820098  bne 0x82ed9b28
	if !ctx.cr[0].eq {
	pc = 0x82ED9B28; continue 'dispatch;
	}
	// 82ED9A94: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82ED9A98: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82ED9A9C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED9AA0: 4182000C  beq 0x82ed9aac
	if ctx.cr[0].eq {
	pc = 0x82ED9AAC; continue 'dispatch;
	}
	// 82ED9AA4: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82ED9AA8: 4800000C  b 0x82ed9ab4
	pc = 0x82ED9AB4; continue 'dispatch;
            }
            0x82ED9AAC => {
    //   block [0x82ED9AAC..0x82ED9AB4)
	// 82ED9AAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED9AB0: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82ED9AB4; continue 'dispatch;
            }
            0x82ED9AB4 => {
    //   block [0x82ED9AB4..0x82ED9B1C)
	// 82ED9AB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED9AB8: 4BA34251  bl 0x8290dd08
	ctx.lr = 0x82ED9ABC;
	sub_8290DD08(ctx, base);
	// 82ED9ABC: 4BDD20F5  bl 0x82cabbb0
	ctx.lr = 0x82ED9AC0;
	sub_82CABBB0(ctx, base);
	// 82ED9AC0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82ED9AC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED9AC8: EFE007F2  fmuls f31, f0, f31
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82ED9ACC: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED9AD0: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82ED9AD4: 4099004C  ble cr6, 0x82ed9b20
	if !ctx.cr[6].gt {
	pc = 0x82ED9B20; continue 'dispatch;
	}
	// 82ED9AD8: 807C0058  lwz r3, 0x58(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ED9ADC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED9AE0: 4182003C  beq 0x82ed9b1c
	if ctx.cr[0].eq {
	pc = 0x82ED9B1C; continue 'dispatch;
	}
	// 82ED9AE4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82ED9AE8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82ED9AEC: 3BEBC5C8  addi r31, r11, -0x3a38
	ctx.r[31].s64 = ctx.r[11].s64 + -14904;
	// 82ED9AF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ED9AF4: 4B30EB85  bl 0x821e8678
	ctx.lr = 0x82ED9AF8;
	sub_821E8678(ctx, base);
	// 82ED9AF8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED9AFC: 41820020  beq 0x82ed9b1c
	if ctx.cr[0].eq {
	pc = 0x82ED9B1C; continue 'dispatch;
	}
	// 82ED9B00: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82ED9B04: 807C0058  lwz r3, 0x58(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ED9B08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ED9B0C: 4B30EB6D  bl 0x821e8678
	ctx.lr = 0x82ED9B10;
	sub_821E8678(ctx, base);
	// 82ED9B10: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED9B14: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82ED9B18: 409906E8  ble cr6, 0x82eda200
	if !ctx.cr[6].gt {
	pc = 0x82EDA200; continue 'dispatch;
	}
	pc = 0x82ED9B1C; continue 'dispatch;
            }
            0x82ED9B1C => {
    //   block [0x82ED9B1C..0x82ED9B20)
	// 82ED9B1C: D3FC0010  stfs f31, 0x10(r28)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(16 as u32), tmp.u32 ) };
	pc = 0x82ED9B20; continue 'dispatch;
            }
            0x82ED9B20 => {
    //   block [0x82ED9B20..0x82ED9B28)
	// 82ED9B20: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82ED9B24: 480006E0  b 0x82eda204
	pc = 0x82EDA204; continue 'dispatch;
            }
            0x82ED9B28 => {
    //   block [0x82ED9B28..0x82ED9B58)
	// 82ED9B28: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED9B2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED9B30: 388BBC1C  addi r4, r11, -0x43e4
	ctx.r[4].s64 = ctx.r[11].s64 + -17380;
	// 82ED9B34: 4BDD301D  bl 0x82cacb50
	ctx.lr = 0x82ED9B38;
	sub_82CACB50(ctx, base);
	// 82ED9B38: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED9B3C: 408200A0  bne 0x82ed9bdc
	if !ctx.cr[0].eq {
	pc = 0x82ED9BDC; continue 'dispatch;
	}
	// 82ED9B40: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82ED9B44: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82ED9B48: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED9B4C: 4182000C  beq 0x82ed9b58
	if ctx.cr[0].eq {
	pc = 0x82ED9B58; continue 'dispatch;
	}
	// 82ED9B50: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82ED9B54: 4800000C  b 0x82ed9b60
	pc = 0x82ED9B60; continue 'dispatch;
            }
            0x82ED9B58 => {
    //   block [0x82ED9B58..0x82ED9B60)
	// 82ED9B58: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED9B5C: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82ED9B60; continue 'dispatch;
            }
            0x82ED9B60 => {
    //   block [0x82ED9B60..0x82ED9BD4)
	// 82ED9B60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED9B64: 4BA341A5  bl 0x8290dd08
	ctx.lr = 0x82ED9B68;
	sub_8290DD08(ctx, base);
	// 82ED9B68: 4BDD2049  bl 0x82cabbb0
	ctx.lr = 0x82ED9B6C;
	sub_82CABBB0(ctx, base);
	// 82ED9B6C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82ED9B70: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED9B74: EFE007F2  fmuls f31, f0, f31
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82ED9B78: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED9B7C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82ED9B80: 4099FFA0  ble cr6, 0x82ed9b20
	if !ctx.cr[6].gt {
	pc = 0x82ED9B20; continue 'dispatch;
	}
	// 82ED9B84: 807C0058  lwz r3, 0x58(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ED9B88: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED9B8C: 41820048  beq 0x82ed9bd4
	if ctx.cr[0].eq {
	pc = 0x82ED9BD4; continue 'dispatch;
	}
	// 82ED9B90: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82ED9B94: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82ED9B98: 3BEBC5C8  addi r31, r11, -0x3a38
	ctx.r[31].s64 = ctx.r[11].s64 + -14904;
	// 82ED9B9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ED9BA0: 4B30EAD9  bl 0x821e8678
	ctx.lr = 0x82ED9BA4;
	sub_821E8678(ctx, base);
	// 82ED9BA4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED9BA8: 4182002C  beq 0x82ed9bd4
	if ctx.cr[0].eq {
	pc = 0x82ED9BD4; continue 'dispatch;
	}
	// 82ED9BAC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82ED9BB0: 807C0058  lwz r3, 0x58(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ED9BB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ED9BB8: 4B30EAC1  bl 0x821e8678
	ctx.lr = 0x82ED9BBC;
	sub_821E8678(ctx, base);
	// 82ED9BBC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED9BC0: C1A30004  lfs f13, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED9BC4: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED9BC8: EC1F0032  fmuls f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED9BCC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED9BD0: 40990630  ble cr6, 0x82eda200
	if !ctx.cr[6].gt {
	pc = 0x82EDA200; continue 'dispatch;
	}
	pc = 0x82ED9BD4; continue 'dispatch;
            }
            0x82ED9BD4 => {
    //   block [0x82ED9BD4..0x82ED9BDC)
	// 82ED9BD4: D3FC0018  stfs f31, 0x18(r28)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82ED9BD8: 4BFFFF48  b 0x82ed9b20
	pc = 0x82ED9B20; continue 'dispatch;
            }
            0x82ED9BDC => {
    //   block [0x82ED9BDC..0x82ED9C14)
	// 82ED9BDC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED9BE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED9BE4: 388BBC08  addi r4, r11, -0x43f8
	ctx.r[4].s64 = ctx.r[11].s64 + -17400;
	// 82ED9BE8: 4BDD2F69  bl 0x82cacb50
	ctx.lr = 0x82ED9BEC;
	sub_82CACB50(ctx, base);
	// 82ED9BEC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED9BF0: 408200AC  bne 0x82ed9c9c
	if !ctx.cr[0].eq {
	pc = 0x82ED9C9C; continue 'dispatch;
	}
	// 82ED9BF4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82ED9BF8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ED9BFC: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82ED9C00: C3CA0C14  lfs f30, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82ED9C04: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED9C08: 4182000C  beq 0x82ed9c14
	if ctx.cr[0].eq {
	pc = 0x82ED9C14; continue 'dispatch;
	}
	// 82ED9C0C: C3EB000C  lfs f31, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82ED9C10: 48000008  b 0x82ed9c18
	pc = 0x82ED9C18; continue 'dispatch;
            }
            0x82ED9C14 => {
    //   block [0x82ED9C14..0x82ED9C18)
	// 82ED9C14: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	pc = 0x82ED9C18; continue 'dispatch;
            }
            0x82ED9C18 => {
    //   block [0x82ED9C18..0x82ED9C8C)
	// 82ED9C18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED9C1C: 4BA340ED  bl 0x8290dd08
	ctx.lr = 0x82ED9C20;
	sub_8290DD08(ctx, base);
	// 82ED9C20: 4BDD1F91  bl 0x82cabbb0
	ctx.lr = 0x82ED9C24;
	sub_82CABBB0(ctx, base);
	// 82ED9C24: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82ED9C28: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED9C2C: EFE007F2  fmuls f31, f0, f31
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82ED9C30: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED9C34: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82ED9C38: 4099FEE8  ble cr6, 0x82ed9b20
	if !ctx.cr[6].gt {
	pc = 0x82ED9B20; continue 'dispatch;
	}
	// 82ED9C3C: 807C0058  lwz r3, 0x58(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ED9C40: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED9C44: 41820048  beq 0x82ed9c8c
	if ctx.cr[0].eq {
	pc = 0x82ED9C8C; continue 'dispatch;
	}
	// 82ED9C48: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82ED9C4C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82ED9C50: 3BEBC5C8  addi r31, r11, -0x3a38
	ctx.r[31].s64 = ctx.r[11].s64 + -14904;
	// 82ED9C54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ED9C58: 4B30EA21  bl 0x821e8678
	ctx.lr = 0x82ED9C5C;
	sub_821E8678(ctx, base);
	// 82ED9C5C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED9C60: 4182002C  beq 0x82ed9c8c
	if ctx.cr[0].eq {
	pc = 0x82ED9C8C; continue 'dispatch;
	}
	// 82ED9C64: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82ED9C68: 807C0058  lwz r3, 0x58(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(88 as u32) ) } as u64;
	// 82ED9C6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ED9C70: 4B30EA09  bl 0x821e8678
	ctx.lr = 0x82ED9C74;
	sub_821E8678(ctx, base);
	// 82ED9C74: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED9C78: C1A30004  lfs f13, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED9C7C: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED9C80: EC1F0032  fmuls f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82ED9C84: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82ED9C88: 40990578  ble cr6, 0x82eda200
	if !ctx.cr[6].gt {
	pc = 0x82EDA200; continue 'dispatch;
	}
	pc = 0x82ED9C8C; continue 'dispatch;
            }
            0x82ED9C8C => {
    //   block [0x82ED9C8C..0x82ED9C9C)
	// 82ED9C8C: EC1EF824  fdivs f0, f30, f31
	ctx.f[0].f64 = ((ctx.f[30].f64 / ctx.f[31].f64) as f32) as f64;
	// 82ED9C90: D3FC0048  stfs f31, 0x48(r28)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82ED9C94: D01C0100  stfs f0, 0x100(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82ED9C98: 4BFFFE88  b 0x82ed9b20
	pc = 0x82ED9B20; continue 'dispatch;
            }
            0x82ED9C9C => {
    //   block [0x82ED9C9C..0x82ED9CD0)
	// 82ED9C9C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED9CA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED9CA4: 388BBBF0  addi r4, r11, -0x4410
	ctx.r[4].s64 = ctx.r[11].s64 + -17424;
	// 82ED9CA8: 4BDD2EA9  bl 0x82cacb50
	ctx.lr = 0x82ED9CAC;
	sub_82CACB50(ctx, base);
	// 82ED9CAC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED9CB0: 4082003C  bne 0x82ed9cec
	if !ctx.cr[0].eq {
	pc = 0x82ED9CEC; continue 'dispatch;
	}
	// 82ED9CB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED9CB8: 4BA34051  bl 0x8290dd08
	ctx.lr = 0x82ED9CBC;
	sub_8290DD08(ctx, base);
	// 82ED9CBC: 4BDD1EF5  bl 0x82cabbb0
	ctx.lr = 0x82ED9CC0;
	sub_82CABBB0(ctx, base);
	// 82ED9CC0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED9CC4: C01C0014  lfs f0, 0x14(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED9CC8: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82ED9CCC: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82ED9CD0; continue 'dispatch;
            }
            0x82ED9CD0 => {
    //   block [0x82ED9CD0..0x82ED9CDC)
	// 82ED9CD0: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82ED9CD4: 41980008  blt cr6, 0x82ed9cdc
	if ctx.cr[6].lt {
	pc = 0x82ED9CDC; continue 'dispatch;
	}
	// 82ED9CD8: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82ED9CDC; continue 'dispatch;
            }
            0x82ED9CDC => {
    //   block [0x82ED9CDC..0x82ED9CEC)
	// 82ED9CDC: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82ED9CE0: 409AFFF0  bne cr6, 0x82ed9cd0
	if !ctx.cr[6].eq {
	pc = 0x82ED9CD0; continue 'dispatch;
	}
	// 82ED9CE4: D01C0014  stfs f0, 0x14(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82ED9CE8: 4BFFFE38  b 0x82ed9b20
	pc = 0x82ED9B20; continue 'dispatch;
            }
            0x82ED9CEC => {
    //   block [0x82ED9CEC..0x82ED9D1C)
	// 82ED9CEC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED9CF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED9CF4: 388BBBDC  addi r4, r11, -0x4424
	ctx.r[4].s64 = ctx.r[11].s64 + -17444;
	// 82ED9CF8: 4BDD2E59  bl 0x82cacb50
	ctx.lr = 0x82ED9CFC;
	sub_82CACB50(ctx, base);
	// 82ED9CFC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED9D00: 40820060  bne 0x82ed9d60
	if !ctx.cr[0].eq {
	pc = 0x82ED9D60; continue 'dispatch;
	}
	// 82ED9D04: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82ED9D08: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82ED9D0C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED9D10: 4182000C  beq 0x82ed9d1c
	if ctx.cr[0].eq {
	pc = 0x82ED9D1C; continue 'dispatch;
	}
	// 82ED9D14: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82ED9D18: 4800000C  b 0x82ed9d24
	pc = 0x82ED9D24; continue 'dispatch;
            }
            0x82ED9D1C => {
    //   block [0x82ED9D1C..0x82ED9D24)
	// 82ED9D1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED9D20: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82ED9D24; continue 'dispatch;
            }
            0x82ED9D24 => {
    //   block [0x82ED9D24..0x82ED9D44)
	// 82ED9D24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED9D28: 4BA33FE1  bl 0x8290dd08
	ctx.lr = 0x82ED9D2C;
	sub_8290DD08(ctx, base);
	// 82ED9D2C: 4BDD1E85  bl 0x82cabbb0
	ctx.lr = 0x82ED9D30;
	sub_82CABBB0(ctx, base);
	// 82ED9D30: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82ED9D34: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED9D38: C01C001C  lfs f0, 0x1c(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED9D3C: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED9D40: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	pc = 0x82ED9D44; continue 'dispatch;
            }
            0x82ED9D44 => {
    //   block [0x82ED9D44..0x82ED9D50)
	// 82ED9D44: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82ED9D48: 40990008  ble cr6, 0x82ed9d50
	if !ctx.cr[6].gt {
	pc = 0x82ED9D50; continue 'dispatch;
	}
	// 82ED9D4C: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82ED9D50; continue 'dispatch;
            }
            0x82ED9D50 => {
    //   block [0x82ED9D50..0x82ED9D60)
	// 82ED9D50: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82ED9D54: 409AFFF0  bne cr6, 0x82ed9d44
	if !ctx.cr[6].eq {
	pc = 0x82ED9D44; continue 'dispatch;
	}
	// 82ED9D58: D01C001C  stfs f0, 0x1c(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82ED9D5C: 4BFFFDC4  b 0x82ed9b20
	pc = 0x82ED9B20; continue 'dispatch;
            }
            0x82ED9D60 => {
    //   block [0x82ED9D60..0x82ED9D90)
	// 82ED9D60: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED9D64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED9D68: 388BAF10  addi r4, r11, -0x50f0
	ctx.r[4].s64 = ctx.r[11].s64 + -20720;
	// 82ED9D6C: 4BDD2DE5  bl 0x82cacb50
	ctx.lr = 0x82ED9D70;
	sub_82CACB50(ctx, base);
	// 82ED9D70: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED9D74: 40820060  bne 0x82ed9dd4
	if !ctx.cr[0].eq {
	pc = 0x82ED9DD4; continue 'dispatch;
	}
	// 82ED9D78: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82ED9D7C: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82ED9D80: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED9D84: 4182000C  beq 0x82ed9d90
	if ctx.cr[0].eq {
	pc = 0x82ED9D90; continue 'dispatch;
	}
	// 82ED9D88: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82ED9D8C: 4800000C  b 0x82ed9d98
	pc = 0x82ED9D98; continue 'dispatch;
            }
            0x82ED9D90 => {
    //   block [0x82ED9D90..0x82ED9D98)
	// 82ED9D90: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED9D94: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82ED9D98; continue 'dispatch;
            }
            0x82ED9D98 => {
    //   block [0x82ED9D98..0x82ED9DB8)
	// 82ED9D98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED9D9C: 4BA33F6D  bl 0x8290dd08
	ctx.lr = 0x82ED9DA0;
	sub_8290DD08(ctx, base);
	// 82ED9DA0: 4BDD1E11  bl 0x82cabbb0
	ctx.lr = 0x82ED9DA4;
	sub_82CABBB0(ctx, base);
	// 82ED9DA4: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82ED9DA8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED9DAC: C01C0020  lfs f0, 0x20(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED9DB0: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED9DB4: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	pc = 0x82ED9DB8; continue 'dispatch;
            }
            0x82ED9DB8 => {
    //   block [0x82ED9DB8..0x82ED9DC4)
	// 82ED9DB8: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82ED9DBC: 41980008  blt cr6, 0x82ed9dc4
	if ctx.cr[6].lt {
	pc = 0x82ED9DC4; continue 'dispatch;
	}
	// 82ED9DC0: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82ED9DC4; continue 'dispatch;
            }
            0x82ED9DC4 => {
    //   block [0x82ED9DC4..0x82ED9DD4)
	// 82ED9DC4: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82ED9DC8: 409AFFF0  bne cr6, 0x82ed9db8
	if !ctx.cr[6].eq {
	pc = 0x82ED9DB8; continue 'dispatch;
	}
	// 82ED9DCC: D01C0020  stfs f0, 0x20(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82ED9DD0: 4BFFFD50  b 0x82ed9b20
	pc = 0x82ED9B20; continue 'dispatch;
            }
            0x82ED9DD4 => {
    //   block [0x82ED9DD4..0x82ED9EB4)
	// 82ED9DD4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED9DD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED9DDC: 3BABBBCC  addi r29, r11, -0x4434
	ctx.r[29].s64 = ctx.r[11].s64 + -17460;
	// 82ED9DE0: 482E2281  bl 0x831bc060
	ctx.lr = 0x82ED9DE4;
	sub_831BC060(ctx, base);
	// 82ED9DE4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82ED9DE8: 4BDD2D69  bl 0x82cacb50
	ctx.lr = 0x82ED9DEC;
	sub_82CACB50(ctx, base);
	// 82ED9DEC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED9DF0: 408200D8  bne 0x82ed9ec8
	if !ctx.cr[0].eq {
	pc = 0x82ED9EC8; continue 'dispatch;
	}
	// 82ED9DF4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82ED9DF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED9DFC: 3BEB1694  addi r31, r11, 0x1694
	ctx.r[31].s64 = ctx.r[11].s64 + 5780;
	// 82ED9E00: 4BA33F09  bl 0x8290dd08
	ctx.lr = 0x82ED9E04;
	sub_8290DD08(ctx, base);
	// 82ED9E04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ED9E08: 4BDD2D49  bl 0x82cacb50
	ctx.lr = 0x82ED9E0C;
	sub_82CACB50(ctx, base);
	// 82ED9E0C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED9E10: 418200AC  beq 0x82ed9ebc
	if ctx.cr[0].eq {
	pc = 0x82ED9EBC; continue 'dispatch;
	}
	// 82ED9E14: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED9E18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED9E1C: 3BEB0F40  addi r31, r11, 0xf40
	ctx.r[31].s64 = ctx.r[11].s64 + 3904;
	// 82ED9E20: 4BA33EE9  bl 0x8290dd08
	ctx.lr = 0x82ED9E24;
	sub_8290DD08(ctx, base);
	// 82ED9E24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ED9E28: 4BDD2D29  bl 0x82cacb50
	ctx.lr = 0x82ED9E2C;
	sub_82CACB50(ctx, base);
	// 82ED9E2C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED9E30: 4182008C  beq 0x82ed9ebc
	if ctx.cr[0].eq {
	pc = 0x82ED9EBC; continue 'dispatch;
	}
	// 82ED9E34: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82ED9E38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED9E3C: 3BEBD56C  addi r31, r11, -0x2a94
	ctx.r[31].s64 = ctx.r[11].s64 + -10900;
	// 82ED9E40: 4BA33EC9  bl 0x8290dd08
	ctx.lr = 0x82ED9E44;
	sub_8290DD08(ctx, base);
	// 82ED9E44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ED9E48: 4BDD2D09  bl 0x82cacb50
	ctx.lr = 0x82ED9E4C;
	sub_82CACB50(ctx, base);
	// 82ED9E4C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED9E50: 4182006C  beq 0x82ed9ebc
	if ctx.cr[0].eq {
	pc = 0x82ED9EBC; continue 'dispatch;
	}
	// 82ED9E54: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82ED9E58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED9E5C: 3BEB1698  addi r31, r11, 0x1698
	ctx.r[31].s64 = ctx.r[11].s64 + 5784;
	// 82ED9E60: 4BA33EA9  bl 0x8290dd08
	ctx.lr = 0x82ED9E64;
	sub_8290DD08(ctx, base);
	// 82ED9E64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ED9E68: 4BDD2CE9  bl 0x82cacb50
	ctx.lr = 0x82ED9E6C;
	sub_82CACB50(ctx, base);
	// 82ED9E6C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED9E70: 41820044  beq 0x82ed9eb4
	if ctx.cr[0].eq {
	pc = 0x82ED9EB4; continue 'dispatch;
	}
	// 82ED9E74: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82ED9E78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED9E7C: 3BEB1700  addi r31, r11, 0x1700
	ctx.r[31].s64 = ctx.r[11].s64 + 5888;
	// 82ED9E80: 4BA33E89  bl 0x8290dd08
	ctx.lr = 0x82ED9E84;
	sub_8290DD08(ctx, base);
	// 82ED9E84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ED9E88: 4BDD2CC9  bl 0x82cacb50
	ctx.lr = 0x82ED9E8C;
	sub_82CACB50(ctx, base);
	// 82ED9E8C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED9E90: 41820024  beq 0x82ed9eb4
	if ctx.cr[0].eq {
	pc = 0x82ED9EB4; continue 'dispatch;
	}
	// 82ED9E94: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82ED9E98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED9E9C: 3BEB7088  addi r31, r11, 0x7088
	ctx.r[31].s64 = ctx.r[11].s64 + 28808;
	// 82ED9EA0: 4BA33E69  bl 0x8290dd08
	ctx.lr = 0x82ED9EA4;
	sub_8290DD08(ctx, base);
	// 82ED9EA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82ED9EA8: 4BDD2CA9  bl 0x82cacb50
	ctx.lr = 0x82ED9EAC;
	sub_82CACB50(ctx, base);
	// 82ED9EAC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED9EB0: 40820350  bne 0x82eda200
	if !ctx.cr[0].eq {
	pc = 0x82EDA200; continue 'dispatch;
	}
	pc = 0x82ED9EB4; continue 'dispatch;
            }
            0x82ED9EB4 => {
    //   block [0x82ED9EB4..0x82ED9EBC)
	// 82ED9EB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82ED9EB8: 48000008  b 0x82ed9ec0
	pc = 0x82ED9EC0; continue 'dispatch;
            }
            0x82ED9EBC => {
    //   block [0x82ED9EBC..0x82ED9EC0)
	// 82ED9EBC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82ED9EC0; continue 'dispatch;
            }
            0x82ED9EC0 => {
    //   block [0x82ED9EC0..0x82ED9EC8)
	// 82ED9EC0: 997C0024  stb r11, 0x24(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 82ED9EC4: 4BFFFC5C  b 0x82ed9b20
	pc = 0x82ED9B20; continue 'dispatch;
            }
            0x82ED9EC8 => {
    //   block [0x82ED9EC8..0x82ED9EF8)
	// 82ED9EC8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82ED9ECC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED9ED0: 388B2520  addi r4, r11, 0x2520
	ctx.r[4].s64 = ctx.r[11].s64 + 9504;
	// 82ED9ED4: 4BDD2C7D  bl 0x82cacb50
	ctx.lr = 0x82ED9ED8;
	sub_82CACB50(ctx, base);
	// 82ED9ED8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED9EDC: 40820060  bne 0x82ed9f3c
	if !ctx.cr[0].eq {
	pc = 0x82ED9F3C; continue 'dispatch;
	}
	// 82ED9EE0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82ED9EE4: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82ED9EE8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82ED9EEC: 4182000C  beq 0x82ed9ef8
	if ctx.cr[0].eq {
	pc = 0x82ED9EF8; continue 'dispatch;
	}
	// 82ED9EF0: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82ED9EF4: 4800000C  b 0x82ed9f00
	pc = 0x82ED9F00; continue 'dispatch;
            }
            0x82ED9EF8 => {
    //   block [0x82ED9EF8..0x82ED9F00)
	// 82ED9EF8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED9EFC: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82ED9F00; continue 'dispatch;
            }
            0x82ED9F00 => {
    //   block [0x82ED9F00..0x82ED9F20)
	// 82ED9F00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED9F04: 4BA33E05  bl 0x8290dd08
	ctx.lr = 0x82ED9F08;
	sub_8290DD08(ctx, base);
	// 82ED9F08: 4BDD1CA9  bl 0x82cabbb0
	ctx.lr = 0x82ED9F0C;
	sub_82CABBB0(ctx, base);
	// 82ED9F0C: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82ED9F10: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED9F14: C01C0028  lfs f0, 0x28(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED9F18: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82ED9F1C: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	pc = 0x82ED9F20; continue 'dispatch;
            }
            0x82ED9F20 => {
    //   block [0x82ED9F20..0x82ED9F2C)
	// 82ED9F20: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82ED9F24: 40990008  ble cr6, 0x82ed9f2c
	if !ctx.cr[6].gt {
	pc = 0x82ED9F2C; continue 'dispatch;
	}
	// 82ED9F28: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82ED9F2C; continue 'dispatch;
            }
            0x82ED9F2C => {
    //   block [0x82ED9F2C..0x82ED9F3C)
	// 82ED9F2C: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82ED9F30: 409AFFF0  bne cr6, 0x82ed9f20
	if !ctx.cr[6].eq {
	pc = 0x82ED9F20; continue 'dispatch;
	}
	// 82ED9F34: D01C0028  stfs f0, 0x28(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82ED9F38: 4BFFFBE8  b 0x82ed9b20
	pc = 0x82ED9B20; continue 'dispatch;
            }
            0x82ED9F3C => {
    //   block [0x82ED9F3C..0x82ED9F78)
	// 82ED9F3C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED9F40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED9F44: 388BBBC0  addi r4, r11, -0x4440
	ctx.r[4].s64 = ctx.r[11].s64 + -17472;
	// 82ED9F48: 4BDD2C09  bl 0x82cacb50
	ctx.lr = 0x82ED9F4C;
	sub_82CACB50(ctx, base);
	// 82ED9F4C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED9F50: 4082004C  bne 0x82ed9f9c
	if !ctx.cr[0].eq {
	pc = 0x82ED9F9C; continue 'dispatch;
	}
	// 82ED9F54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED9F58: 4BA33DB1  bl 0x8290dd08
	ctx.lr = 0x82ED9F5C;
	sub_8290DD08(ctx, base);
	// 82ED9F5C: 4BDD1C55  bl 0x82cabbb0
	ctx.lr = 0x82ED9F60;
	sub_82CABBB0(ctx, base);
	// 82ED9F60: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82ED9F64: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED9F68: C1BC002C  lfs f13, 0x2c(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82ED9F6C: FC000818  frsp f0, f1
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82ED9F70: C16A0C18  lfs f11, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82ED9F74: C18B0C14  lfs f12, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82ED9F78; continue 'dispatch;
            }
            0x82ED9F78 => {
    //   block [0x82ED9F78..0x82ED9F8C)
	// 82ED9F78: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82ED9F7C: 41980010  blt cr6, 0x82ed9f8c
	if ctx.cr[6].lt {
	pc = 0x82ED9F8C; continue 'dispatch;
	}
	// 82ED9F80: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82ED9F84: 41990008  bgt cr6, 0x82ed9f8c
	if ctx.cr[6].gt {
	pc = 0x82ED9F8C; continue 'dispatch;
	}
	// 82ED9F88: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	pc = 0x82ED9F8C; continue 'dispatch;
            }
            0x82ED9F8C => {
    //   block [0x82ED9F8C..0x82ED9F9C)
	// 82ED9F8C: FF0D6800  fcmpu cr6, f13, f13
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[13].f64);
	// 82ED9F90: 409AFFE8  bne cr6, 0x82ed9f78
	if !ctx.cr[6].eq {
	pc = 0x82ED9F78; continue 'dispatch;
	}
	// 82ED9F94: D1BC002C  stfs f13, 0x2c(r28)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82ED9F98: 4BFFFB88  b 0x82ed9b20
	pc = 0x82ED9B20; continue 'dispatch;
            }
            0x82ED9F9C => {
    //   block [0x82ED9F9C..0x82ED9FD0)
	// 82ED9F9C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED9FA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED9FA4: 388BBBB0  addi r4, r11, -0x4450
	ctx.r[4].s64 = ctx.r[11].s64 + -17488;
	// 82ED9FA8: 4BDD2BA9  bl 0x82cacb50
	ctx.lr = 0x82ED9FAC;
	sub_82CACB50(ctx, base);
	// 82ED9FAC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82ED9FB0: 4082003C  bne 0x82ed9fec
	if !ctx.cr[0].eq {
	pc = 0x82ED9FEC; continue 'dispatch;
	}
	// 82ED9FB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82ED9FB8: 4BA33D51  bl 0x8290dd08
	ctx.lr = 0x82ED9FBC;
	sub_8290DD08(ctx, base);
	// 82ED9FBC: 4BDD1BF5  bl 0x82cabbb0
	ctx.lr = 0x82ED9FC0;
	sub_82CABBB0(ctx, base);
	// 82ED9FC0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82ED9FC4: C01C0030  lfs f0, 0x30(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82ED9FC8: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82ED9FCC: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82ED9FD0; continue 'dispatch;
            }
            0x82ED9FD0 => {
    //   block [0x82ED9FD0..0x82ED9FDC)
	// 82ED9FD0: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82ED9FD4: 41980008  blt cr6, 0x82ed9fdc
	if ctx.cr[6].lt {
	pc = 0x82ED9FDC; continue 'dispatch;
	}
	// 82ED9FD8: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82ED9FDC; continue 'dispatch;
            }
            0x82ED9FDC => {
    //   block [0x82ED9FDC..0x82ED9FEC)
	// 82ED9FDC: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82ED9FE0: 409AFFF0  bne cr6, 0x82ed9fd0
	if !ctx.cr[6].eq {
	pc = 0x82ED9FD0; continue 'dispatch;
	}
	// 82ED9FE4: D01C0030  stfs f0, 0x30(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82ED9FE8: 4BFFFB38  b 0x82ed9b20
	pc = 0x82ED9B20; continue 'dispatch;
            }
            0x82ED9FEC => {
    //   block [0x82ED9FEC..0x82EDA020)
	// 82ED9FEC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82ED9FF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82ED9FF4: 388BBBA0  addi r4, r11, -0x4460
	ctx.r[4].s64 = ctx.r[11].s64 + -17504;
	// 82ED9FF8: 4BDD2B59  bl 0x82cacb50
	ctx.lr = 0x82ED9FFC;
	sub_82CACB50(ctx, base);
	// 82ED9FFC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDA000: 4082003C  bne 0x82eda03c
	if !ctx.cr[0].eq {
	pc = 0x82EDA03C; continue 'dispatch;
	}
	// 82EDA004: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDA008: 4BA33D01  bl 0x8290dd08
	ctx.lr = 0x82EDA00C;
	sub_8290DD08(ctx, base);
	// 82EDA00C: 4BDD1BA5  bl 0x82cabbb0
	ctx.lr = 0x82EDA010;
	sub_82CABBB0(ctx, base);
	// 82EDA010: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDA014: C01C0034  lfs f0, 0x34(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA018: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDA01C: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EDA020; continue 'dispatch;
            }
            0x82EDA020 => {
    //   block [0x82EDA020..0x82EDA02C)
	// 82EDA020: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDA024: 41980008  blt cr6, 0x82eda02c
	if ctx.cr[6].lt {
	pc = 0x82EDA02C; continue 'dispatch;
	}
	// 82EDA028: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDA02C; continue 'dispatch;
            }
            0x82EDA02C => {
    //   block [0x82EDA02C..0x82EDA03C)
	// 82EDA02C: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDA030: 409AFFF0  bne cr6, 0x82eda020
	if !ctx.cr[6].eq {
	pc = 0x82EDA020; continue 'dispatch;
	}
	// 82EDA034: D01C0034  stfs f0, 0x34(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82EDA038: 4BFFFAE8  b 0x82ed9b20
	pc = 0x82ED9B20; continue 'dispatch;
            }
            0x82EDA03C => {
    //   block [0x82EDA03C..0x82EDA070)
	// 82EDA03C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDA040: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDA044: 388BBB94  addi r4, r11, -0x446c
	ctx.r[4].s64 = ctx.r[11].s64 + -17516;
	// 82EDA048: 4BDD2B09  bl 0x82cacb50
	ctx.lr = 0x82EDA04C;
	sub_82CACB50(ctx, base);
	// 82EDA04C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDA050: 4082003C  bne 0x82eda08c
	if !ctx.cr[0].eq {
	pc = 0x82EDA08C; continue 'dispatch;
	}
	// 82EDA054: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDA058: 4BA33CB1  bl 0x8290dd08
	ctx.lr = 0x82EDA05C;
	sub_8290DD08(ctx, base);
	// 82EDA05C: 4BDD1B55  bl 0x82cabbb0
	ctx.lr = 0x82EDA060;
	sub_82CABBB0(ctx, base);
	// 82EDA060: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDA064: C01C0038  lfs f0, 0x38(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA068: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDA06C: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EDA070; continue 'dispatch;
            }
            0x82EDA070 => {
    //   block [0x82EDA070..0x82EDA07C)
	// 82EDA070: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDA074: 41980008  blt cr6, 0x82eda07c
	if ctx.cr[6].lt {
	pc = 0x82EDA07C; continue 'dispatch;
	}
	// 82EDA078: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDA07C; continue 'dispatch;
            }
            0x82EDA07C => {
    //   block [0x82EDA07C..0x82EDA08C)
	// 82EDA07C: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDA080: 409AFFF0  bne cr6, 0x82eda070
	if !ctx.cr[6].eq {
	pc = 0x82EDA070; continue 'dispatch;
	}
	// 82EDA084: D01C0038  stfs f0, 0x38(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82EDA088: 4BFFFA98  b 0x82ed9b20
	pc = 0x82ED9B20; continue 'dispatch;
            }
            0x82EDA08C => {
    //   block [0x82EDA08C..0x82EDA0C0)
	// 82EDA08C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDA090: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDA094: 388BBB78  addi r4, r11, -0x4488
	ctx.r[4].s64 = ctx.r[11].s64 + -17544;
	// 82EDA098: 4BDD2AB9  bl 0x82cacb50
	ctx.lr = 0x82EDA09C;
	sub_82CACB50(ctx, base);
	// 82EDA09C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDA0A0: 40820020  bne 0x82eda0c0
	if !ctx.cr[0].eq {
	pc = 0x82EDA0C0; continue 'dispatch;
	}
	// 82EDA0A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDA0A8: 4BA33C61  bl 0x8290dd08
	ctx.lr = 0x82EDA0AC;
	sub_8290DD08(ctx, base);
	// 82EDA0AC: 4BDD0315  bl 0x82caa3c0
	ctx.lr = 0x82EDA0B0;
	sub_82CAA3C0(ctx, base);
	// 82EDA0B0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDA0B4: 4180FA6C  blt 0x82ed9b20
	if ctx.cr[0].lt {
	pc = 0x82ED9B20; continue 'dispatch;
	}
	// 82EDA0B8: 907C003C  stw r3, 0x3c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(60 as u32), ctx.r[3].u32 ) };
	// 82EDA0BC: 4BFFFA64  b 0x82ed9b20
	pc = 0x82ED9B20; continue 'dispatch;
            }
            0x82EDA0C0 => {
    //   block [0x82EDA0C0..0x82EDA0F4)
	// 82EDA0C0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDA0C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDA0C8: 388BBB68  addi r4, r11, -0x4498
	ctx.r[4].s64 = ctx.r[11].s64 + -17560;
	// 82EDA0CC: 4BDD2A85  bl 0x82cacb50
	ctx.lr = 0x82EDA0D0;
	sub_82CACB50(ctx, base);
	// 82EDA0D0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDA0D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDA0D8: 40820038  bne 0x82eda110
	if !ctx.cr[0].eq {
	pc = 0x82EDA110; continue 'dispatch;
	}
	// 82EDA0DC: 4BA33C2D  bl 0x8290dd08
	ctx.lr = 0x82EDA0E0;
	sub_8290DD08(ctx, base);
	// 82EDA0E0: 4BDD1AD1  bl 0x82cabbb0
	ctx.lr = 0x82EDA0E4;
	sub_82CABBB0(ctx, base);
	// 82EDA0E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDA0E8: C01C0040  lfs f0, 0x40(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA0EC: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDA0F0: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EDA0F4; continue 'dispatch;
            }
            0x82EDA0F4 => {
    //   block [0x82EDA0F4..0x82EDA100)
	// 82EDA0F4: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDA0F8: 40990008  ble cr6, 0x82eda100
	if !ctx.cr[6].gt {
	pc = 0x82EDA100; continue 'dispatch;
	}
	// 82EDA0FC: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDA100; continue 'dispatch;
            }
            0x82EDA100 => {
    //   block [0x82EDA100..0x82EDA110)
	// 82EDA100: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDA104: 409AFFF0  bne cr6, 0x82eda0f4
	if !ctx.cr[6].eq {
	pc = 0x82EDA0F4; continue 'dispatch;
	}
	// 82EDA108: D01C0040  stfs f0, 0x40(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82EDA10C: 4BFFFA14  b 0x82ed9b20
	pc = 0x82ED9B20; continue 'dispatch;
            }
            0x82EDA110 => {
    //   block [0x82EDA110..0x82EDA1EC)
	// 82EDA110: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDA114: 3BEBBB5C  addi r31, r11, -0x44a4
	ctx.r[31].s64 = ctx.r[11].s64 + -17572;
	// 82EDA118: 482E1F49  bl 0x831bc060
	ctx.lr = 0x82EDA11C;
	sub_831BC060(ctx, base);
	// 82EDA11C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDA120: 4BDD2A31  bl 0x82cacb50
	ctx.lr = 0x82EDA124;
	sub_82CACB50(ctx, base);
	// 82EDA124: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDA128: 408200D8  bne 0x82eda200
	if !ctx.cr[0].eq {
	pc = 0x82EDA200; continue 'dispatch;
	}
	// 82EDA12C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EDA130: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDA134: 3BEB1694  addi r31, r11, 0x1694
	ctx.r[31].s64 = ctx.r[11].s64 + 5780;
	// 82EDA138: 4BA33BD1  bl 0x8290dd08
	ctx.lr = 0x82EDA13C;
	sub_8290DD08(ctx, base);
	// 82EDA13C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDA140: 4BDD2A11  bl 0x82cacb50
	ctx.lr = 0x82EDA144;
	sub_82CACB50(ctx, base);
	// 82EDA144: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDA148: 418200AC  beq 0x82eda1f4
	if ctx.cr[0].eq {
	pc = 0x82EDA1F4; continue 'dispatch;
	}
	// 82EDA14C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDA150: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDA154: 3BEB0F40  addi r31, r11, 0xf40
	ctx.r[31].s64 = ctx.r[11].s64 + 3904;
	// 82EDA158: 4BA33BB1  bl 0x8290dd08
	ctx.lr = 0x82EDA15C;
	sub_8290DD08(ctx, base);
	// 82EDA15C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDA160: 4BDD29F1  bl 0x82cacb50
	ctx.lr = 0x82EDA164;
	sub_82CACB50(ctx, base);
	// 82EDA164: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDA168: 4182008C  beq 0x82eda1f4
	if ctx.cr[0].eq {
	pc = 0x82EDA1F4; continue 'dispatch;
	}
	// 82EDA16C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82EDA170: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDA174: 3BEBD56C  addi r31, r11, -0x2a94
	ctx.r[31].s64 = ctx.r[11].s64 + -10900;
	// 82EDA178: 4BA33B91  bl 0x8290dd08
	ctx.lr = 0x82EDA17C;
	sub_8290DD08(ctx, base);
	// 82EDA17C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDA180: 4BDD29D1  bl 0x82cacb50
	ctx.lr = 0x82EDA184;
	sub_82CACB50(ctx, base);
	// 82EDA184: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDA188: 4182006C  beq 0x82eda1f4
	if ctx.cr[0].eq {
	pc = 0x82EDA1F4; continue 'dispatch;
	}
	// 82EDA18C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EDA190: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDA194: 3BEB1698  addi r31, r11, 0x1698
	ctx.r[31].s64 = ctx.r[11].s64 + 5784;
	// 82EDA198: 4BA33B71  bl 0x8290dd08
	ctx.lr = 0x82EDA19C;
	sub_8290DD08(ctx, base);
	// 82EDA19C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDA1A0: 4BDD29B1  bl 0x82cacb50
	ctx.lr = 0x82EDA1A4;
	sub_82CACB50(ctx, base);
	// 82EDA1A4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDA1A8: 41820044  beq 0x82eda1ec
	if ctx.cr[0].eq {
	pc = 0x82EDA1EC; continue 'dispatch;
	}
	// 82EDA1AC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EDA1B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDA1B4: 3BEB1700  addi r31, r11, 0x1700
	ctx.r[31].s64 = ctx.r[11].s64 + 5888;
	// 82EDA1B8: 4BA33B51  bl 0x8290dd08
	ctx.lr = 0x82EDA1BC;
	sub_8290DD08(ctx, base);
	// 82EDA1BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDA1C0: 4BDD2991  bl 0x82cacb50
	ctx.lr = 0x82EDA1C4;
	sub_82CACB50(ctx, base);
	// 82EDA1C4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDA1C8: 41820024  beq 0x82eda1ec
	if ctx.cr[0].eq {
	pc = 0x82EDA1EC; continue 'dispatch;
	}
	// 82EDA1CC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EDA1D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDA1D4: 3BEB7088  addi r31, r11, 0x7088
	ctx.r[31].s64 = ctx.r[11].s64 + 28808;
	// 82EDA1D8: 4BA33B31  bl 0x8290dd08
	ctx.lr = 0x82EDA1DC;
	sub_8290DD08(ctx, base);
	// 82EDA1DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDA1E0: 4BDD2971  bl 0x82cacb50
	ctx.lr = 0x82EDA1E4;
	sub_82CACB50(ctx, base);
	// 82EDA1E4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDA1E8: 40820018  bne 0x82eda200
	if !ctx.cr[0].eq {
	pc = 0x82EDA200; continue 'dispatch;
	}
	pc = 0x82EDA1EC; continue 'dispatch;
            }
            0x82EDA1EC => {
    //   block [0x82EDA1EC..0x82EDA1F4)
	// 82EDA1EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EDA1F0: 48000008  b 0x82eda1f8
	pc = 0x82EDA1F8; continue 'dispatch;
            }
            0x82EDA1F4 => {
    //   block [0x82EDA1F4..0x82EDA1F8)
	// 82EDA1F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82EDA1F8; continue 'dispatch;
            }
            0x82EDA1F8 => {
    //   block [0x82EDA1F8..0x82EDA200)
	// 82EDA1F8: 997C0044  stb r11, 0x44(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(68 as u32), ctx.r[11].u8 ) };
	// 82EDA1FC: 4BFFF924  b 0x82ed9b20
	pc = 0x82ED9B20; continue 'dispatch;
            }
            0x82EDA200 => {
    //   block [0x82EDA200..0x82EDA204)
	// 82EDA200: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EDA204; continue 'dispatch;
            }
            0x82EDA204 => {
    //   block [0x82EDA204..0x82EDA214)
	// 82EDA204: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EDA208: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82EDA20C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82EDA210: 4BDCF248  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDA218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EDA218 size=20
    let mut pc: u32 = 0x82EDA218;
    'dispatch: loop {
        match pc {
            0x82EDA218 => {
    //   block [0x82EDA218..0x82EDA22C)
	// 82EDA218: 81630098  lwz r11, 0x98(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(152 as u32) ) } as u64;
	// 82EDA21C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDA220: 419A000C  beq cr6, 0x82eda22c
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82EDA22C);
		return;
	}
	// 82EDA224: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EDA228: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDA268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EDA268 size=88
    let mut pc: u32 = 0x82EDA268;
    'dispatch: loop {
        match pc {
            0x82EDA268 => {
    //   block [0x82EDA268..0x82EDA2A4)
	// 82EDA268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDA26C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EDA270: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EDA274: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EDA278: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDA27C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDA280: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EDA284: 4BFFF6FD  bl 0x82ed9980
	ctx.lr = 0x82EDA288;
	sub_82ED9980(ctx, base);
	// 82EDA288: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDA28C: 41820018  beq 0x82eda2a4
	if ctx.cr[0].eq {
	pc = 0x82EDA2A4; continue 'dispatch;
	}
	// 82EDA290: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EDA294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDA298: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EDA29C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDA2A0: 4E800421  bctrl
	ctx.lr = 0x82EDA2A4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EDA2A4 => {
    //   block [0x82EDA2A4..0x82EDA2C0)
	// 82EDA2A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDA2A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EDA2AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EDA2B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EDA2B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EDA2B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EDA2BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDA2C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EDA2C0 size=312
    let mut pc: u32 = 0x82EDA2C0;
    'dispatch: loop {
        match pc {
            0x82EDA2C0 => {
    //   block [0x82EDA2C0..0x82EDA31C)
	// 82EDA2C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDA2C4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EDA2C8: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82EDA2CC: C00B0BEC  lfs f0, 0xbec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA2D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EDA2D4: C1A80C14  lfs f13, 0xc14(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDA2D8: 996300FA  stb r11, 0xfa(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(250 as u32), ctx.r[11].u8 ) };
	// 82EDA2DC: D0030080  stfs f0, 0x80(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EDA2E0: D0030084  stfs f0, 0x84(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EDA2E4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDA2E8: D0030088  stfs f0, 0x88(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EDA2EC: D003008C  stfs f0, 0x8c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EDA2F0: C0030084  lfs f0, 0x84(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA2F4: D0030090  stfs f0, 0x90(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82EDA2F8: C0030088  lfs f0, 0x88(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA2FC: D0030094  stfs f0, 0x94(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82EDA300: 91430098  stw r10, 0x98(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), ctx.r[10].u32 ) };
	// 82EDA304: 91430110  stw r10, 0x110(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(272 as u32), ctx.r[10].u32 ) };
	// 82EDA308: 812B0718  lwz r9, 0x718(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDA30C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDA310: 4182000C  beq 0x82eda31c
	if ctx.cr[0].eq {
	pc = 0x82EDA31C; continue 'dispatch;
	}
	// 82EDA314: C009000C  lfs f0, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA318: 48000008  b 0x82eda320
	pc = 0x82EDA320; continue 'dispatch;
            }
            0x82EDA31C => {
    //   block [0x82EDA31C..0x82EDA320)
	// 82EDA31C: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDA320; continue 'dispatch;
            }
            0x82EDA320 => {
    //   block [0x82EDA320..0x82EDA334)
	// 82EDA320: D0030074  stfs f0, 0x74(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EDA324: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDA328: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDA32C: 41820008  beq 0x82eda334
	if ctx.cr[0].eq {
	pc = 0x82EDA334; continue 'dispatch;
	}
	// 82EDA330: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82EDA334; continue 'dispatch;
            }
            0x82EDA334 => {
    //   block [0x82EDA334..0x82EDA358)
	// 82EDA334: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EDA338: 816300D4  lwz r11, 0xd4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EDA33C: D1A30078  stfs f13, 0x78(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EDA340: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDA344: C0090C18  lfs f0, 0xc18(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA348: D00300CC  stfs f0, 0xcc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EDA34C: D00300D0  stfs f0, 0xd0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82EDA350: 41820040  beq 0x82eda390
	if ctx.cr[0].eq {
	pc = 0x82EDA390; continue 'dispatch;
	}
	// 82EDA354: 48000028  b 0x82eda37c
	pc = 0x82EDA37C; continue 'dispatch;
            }
            0x82EDA358 => {
    //   block [0x82EDA358..0x82EDA37C)
	// 82EDA358: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDA35C: 99490030  stb r10, 0x30(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(48 as u32), ctx.r[10].u8 ) };
	// 82EDA360: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDA364: 80EB0010  lwz r7, 0x10(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EDA368: 8109002C  lwz r8, 0x2c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EDA36C: 90E9002C  stw r7, 0x2c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(44 as u32), ctx.r[7].u32 ) };
	// 82EDA370: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDA374: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82EDA378: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	pc = 0x82EDA37C; continue 'dispatch;
            }
            0x82EDA37C => {
    //   block [0x82EDA37C..0x82EDA390)
	// 82EDA37C: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDA380: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EDA384: 409AFFD4  bne cr6, 0x82eda358
	if !ctx.cr[6].eq {
	pc = 0x82EDA358; continue 'dispatch;
	}
	// 82EDA388: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EDA38C: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	pc = 0x82EDA390; continue 'dispatch;
            }
            0x82EDA390 => {
    //   block [0x82EDA390..0x82EDA3BC)
	// 82EDA390: D00300D8  stfs f0, 0xd8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EDA394: D00300DC  stfs f0, 0xdc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EDA398: D00300E0  stfs f0, 0xe0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EDA39C: 914300F4  stw r10, 0xf4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(244 as u32), ctx.r[10].u32 ) };
	// 82EDA3A0: 81630118  lwz r11, 0x118(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(280 as u32) ) } as u64;
	// 82EDA3A4: D00300E4  stfs f0, 0xe4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EDA3A8: D00300FC  stfs f0, 0xfc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82EDA3AC: 994300F9  stb r10, 0xf9(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(249 as u32), ctx.r[10].u8 ) };
	// 82EDA3B0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDA3B4: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
	// 82EDA3B8: 48000028  b 0x82eda3e0
	pc = 0x82EDA3E0; continue 'dispatch;
            }
            0x82EDA3BC => {
    //   block [0x82EDA3BC..0x82EDA3E0)
	// 82EDA3BC: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDA3C0: 99490020  stb r10, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[10].u8 ) };
	// 82EDA3C4: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDA3C8: 80EB0010  lwz r7, 0x10(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EDA3CC: 8109001C  lwz r8, 0x1c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EDA3D0: 90E9001C  stw r7, 0x1c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[7].u32 ) };
	// 82EDA3D4: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDA3D8: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82EDA3DC: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	pc = 0x82EDA3E0; continue 'dispatch;
            }
            0x82EDA3E0 => {
    //   block [0x82EDA3E0..0x82EDA3F8)
	// 82EDA3E0: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDA3E4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EDA3E8: 409AFFD4  bne cr6, 0x82eda3bc
	if !ctx.cr[6].eq {
	pc = 0x82EDA3BC; continue 'dispatch;
	}
	// 82EDA3EC: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EDA3F0: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82EDA3F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDA3F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EDA3F8 size=1776
    let mut pc: u32 = 0x82EDA3F8;
    'dispatch: loop {
        match pc {
            0x82EDA3F8 => {
    //   block [0x82EDA3F8..0x82EDA4EC)
	// 82EDA3F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDA3FC: 4BDCF001  bl 0x82ca93fc
	ctx.lr = 0x82EDA400;
	sub_82CA93D0(ctx, base);
	// 82EDA400: DBA1FFA8  stfd f29, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[29].u64 ) };
	// 82EDA404: DBC1FFB0  stfd f30, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 82EDA408: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82EDA40C: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDA410: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDA414: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EDA418: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82EDA41C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDA420: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDA424: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EDA428: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA42C: D01F005C  stfs f0, 0x5c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EDA430: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA434: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EDA438: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA43C: D01F0064  stfs f0, 0x64(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EDA440: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDA444: C1BE000C  lfs f13, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDA448: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EDA44C: C19F005C  lfs f12, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDA450: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDA454: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EDA458: C17F0060  lfs f11, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDA45C: C14B0010  lfs f10, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EDA460: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDA464: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDA468: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EDA46C: C3AB0C18  lfs f29, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EDA470: FF0AE800  fcmpu cr6, f10, f29
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[29].f64);
	// 82EDA474: 40990560  ble cr6, 0x82eda9d4
	if !ctx.cr[6].gt {
	pc = 0x82EDA9D4; continue 'dispatch;
	}
	// 82EDA478: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EDA47C: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EDA480: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EDA484: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82EDA488: 419A054C  beq cr6, 0x82eda9d4
	if ctx.cr[6].eq {
	pc = 0x82EDA9D4; continue 'dispatch;
	}
	// 82EDA48C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDA490: C1BF0080  lfs f13, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDA494: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EDA498: 3F608334  lis r27, -0x7ccc
	ctx.r[27].s64 = -2093744128;
	// 82EDA49C: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82EDA4A0: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82EDA4A4: C00B0BEC  lfs f0, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA4A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDA4AC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EDA4B0: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EDA4B4: 409A0038  bne cr6, 0x82eda4ec
	if !ctx.cr[6].eq {
	pc = 0x82EDA4EC; continue 'dispatch;
	}
	// 82EDA4B8: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA4BC: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EDA4C0: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA4C4: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EDA4C8: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA4CC: C1BF0080  lfs f13, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDA4D0: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EDA4D4: D1BF008C  stfs f13, 0x8c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EDA4D8: C01F0084  lfs f0, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA4DC: D01F0090  stfs f0, 0x90(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82EDA4E0: C01F0088  lfs f0, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA4E4: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82EDA4E8: 48000158  b 0x82eda640
	pc = 0x82EDA640; continue 'dispatch;
            }
            0x82EDA4EC => {
    //   block [0x82EDA4EC..0x82EDA518)
	// 82EDA4EC: C01F0088  lfs f0, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA4F0: 817B0718  lwz r11, 0x718(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDA4F4: C1BE000C  lfs f13, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDA4F8: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EDA4FC: C17F0080  lfs f11, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDA500: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA504: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDA508: ED6B0028  fsubs f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EDA50C: 4182000C  beq 0x82eda518
	if ctx.cr[0].eq {
	pc = 0x82EDA518; continue 'dispatch;
	}
	// 82EDA510: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDA514: 48000008  b 0x82eda51c
	pc = 0x82EDA51C; continue 'dispatch;
            }
            0x82EDA518 => {
    //   block [0x82EDA518..0x82EDA51C)
	// 82EDA518: FDA0F890  fmr f13, f31
	ctx.f[13].f64 = ctx.f[31].f64;
	pc = 0x82EDA51C; continue 'dispatch;
            }
            0x82EDA51C => {
    //   block [0x82EDA51C..0x82EDA52C)
	// 82EDA51C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDA520: 4182000C  beq 0x82eda52c
	if ctx.cr[0].eq {
	pc = 0x82EDA52C; continue 'dispatch;
	}
	// 82EDA524: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA528: 48000008  b 0x82eda530
	pc = 0x82EDA530; continue 'dispatch;
            }
            0x82EDA52C => {
    //   block [0x82EDA52C..0x82EDA530)
	// 82EDA52C: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x82EDA530; continue 'dispatch;
            }
            0x82EDA530 => {
    //   block [0x82EDA530..0x82EDA5B4)
	// 82EDA530: ED8C0332  fmuls f12, f12, f12
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EDA534: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EDA538: EDAB62FA  fmadds f13, f11, f11, f12
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64);
	// 82EDA53C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EDA540: 419900E8  bgt cr6, 0x82eda628
	if ctx.cr[6].gt {
	pc = 0x82EDA628; continue 'dispatch;
	}
	// 82EDA544: 4B386475  bl 0x822609b8
	ctx.lr = 0x82EDA548;
	sub_822609B8(ctx, base);
	// 82EDA548: C01F00CC  lfs f0, 0xcc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA54C: C1A3004C  lfs f13, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDA550: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EDA554: 409800D4  bge cr6, 0x82eda628
	if !ctx.cr[6].lt {
	pc = 0x82EDA628; continue 'dispatch;
	}
	// 82EDA558: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDA55C: 4BFFFCBD  bl 0x82eda218
	ctx.lr = 0x82EDA560;
	sub_82EDA218(ctx, base);
	// 82EDA560: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDA564: 408200A4  bne 0x82eda608
	if !ctx.cr[0].eq {
	pc = 0x82EDA608; continue 'dispatch;
	}
	// 82EDA568: D3BF00D8  stfs f29, 0xd8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EDA56C: D3BF00DC  stfs f29, 0xdc(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EDA570: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA574: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EDA578: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA57C: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EDA580: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA584: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EDA588: C01F0080  lfs f0, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA58C: D01F008C  stfs f0, 0x8c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EDA590: C01F0084  lfs f0, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA594: D01F0090  stfs f0, 0x90(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82EDA598: C01F0088  lfs f0, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA59C: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82EDA5A0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDA5A4: 817F00D4  lwz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EDA5A8: C00A0010  lfs f0, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA5AC: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EDA5B0: 48000028  b 0x82eda5d8
	pc = 0x82EDA5D8; continue 'dispatch;
            }
            0x82EDA5B4 => {
    //   block [0x82EDA5B4..0x82EDA5D8)
	// 82EDA5B4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDA5B8: 9B8A0030  stb r28, 0x30(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(48 as u32), ctx.r[28].u8 ) };
	// 82EDA5BC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDA5C0: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EDA5C4: 812A002C  lwz r9, 0x2c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EDA5C8: 910A002C  stw r8, 0x2c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(44 as u32), ctx.r[8].u32 ) };
	// 82EDA5CC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDA5D0: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82EDA5D4: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	pc = 0x82EDA5D8; continue 'dispatch;
            }
            0x82EDA5D8 => {
    //   block [0x82EDA5D8..0x82EDA5EC)
	// 82EDA5D8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDA5DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EDA5E0: 409AFFD4  bne cr6, 0x82eda5b4
	if !ctx.cr[6].eq {
	pc = 0x82EDA5B4; continue 'dispatch;
	}
	// 82EDA5E4: 938B000C  stw r28, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82EDA5E8: 938B0014  stw r28, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[28].u32 ) };
	pc = 0x82EDA5EC; continue 'dispatch;
            }
            0x82EDA5EC => {
    //   block [0x82EDA5EC..0x82EDA608)
	// 82EDA5EC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EDA5F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDA5F4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82EDA5F8: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EDA5FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDA600: 4E800421  bctrl
	ctx.lr = 0x82EDA604;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EDA604: 480004D0  b 0x82edaad4
	pc = 0x82EDAAD4; continue 'dispatch;
            }
            0x82EDA608 => {
    //   block [0x82EDA608..0x82EDA628)
	// 82EDA608: C01F0080  lfs f0, 0x80(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA60C: C1BF005C  lfs f13, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDA610: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EDA614: 409A0030  bne cr6, 0x82eda644
	if !ctx.cr[6].eq {
	pc = 0x82EDA644; continue 'dispatch;
	}
	// 82EDA618: C01F0088  lfs f0, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA61C: C1BF0064  lfs f13, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDA620: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EDA624: 409A0020  bne cr6, 0x82eda644
	if !ctx.cr[6].eq {
	pc = 0x82EDA644; continue 'dispatch;
	}
	pc = 0x82EDA628; continue 'dispatch;
            }
            0x82EDA628 => {
    //   block [0x82EDA628..0x82EDA640)
	// 82EDA628: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA62C: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EDA630: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA634: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EDA638: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA63C: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	pc = 0x82EDA640; continue 'dispatch;
            }
            0x82EDA640 => {
    //   block [0x82EDA640..0x82EDA644)
	// 82EDA640: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	pc = 0x82EDA644; continue 'dispatch;
            }
            0x82EDA644 => {
    //   block [0x82EDA644..0x82EDA658)
	// 82EDA644: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EDA648: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDA64C: 4182000C  beq 0x82eda658
	if ctx.cr[0].eq {
	pc = 0x82EDA658; continue 'dispatch;
	}
	// 82EDA650: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA654: 4800001C  b 0x82eda670
	pc = 0x82EDA670; continue 'dispatch;
            }
            0x82EDA658 => {
    //   block [0x82EDA658..0x82EDA66C)
	// 82EDA658: 817B0718  lwz r11, 0x718(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDA65C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDA660: 4182000C  beq 0x82eda66c
	if ctx.cr[0].eq {
	pc = 0x82EDA66C; continue 'dispatch;
	}
	// 82EDA664: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA668: 48000008  b 0x82eda670
	pc = 0x82EDA670; continue 'dispatch;
            }
            0x82EDA66C => {
    //   block [0x82EDA66C..0x82EDA670)
	// 82EDA66C: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x82EDA670; continue 'dispatch;
            }
            0x82EDA670 => {
    //   block [0x82EDA670..0x82EDA69C)
	// 82EDA670: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EDA674: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EDA678: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDA67C: 41820030  beq 0x82eda6ac
	if ctx.cr[0].eq {
	pc = 0x82EDA6AC; continue 'dispatch;
	}
	// 82EDA680: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA684: C1BF0074  lfs f13, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDA688: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EDA68C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EDA690: 4199000C  bgt cr6, 0x82eda69c
	if ctx.cr[6].gt {
	pc = 0x82EDA69C; continue 'dispatch;
	}
	// 82EDA694: D1BF0078  stfs f13, 0x78(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EDA698: 4800001C  b 0x82eda6b4
	pc = 0x82EDA6B4; continue 'dispatch;
            }
            0x82EDA69C => {
    //   block [0x82EDA69C..0x82EDA6AC)
	// 82EDA69C: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EDA6A0: 9B5F007C  stb r26, 0x7c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[26].u8 ) };
	// 82EDA6A4: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EDA6A8: 48000010  b 0x82eda6b8
	pc = 0x82EDA6B8; continue 'dispatch;
            }
            0x82EDA6AC => {
    //   block [0x82EDA6AC..0x82EDA6B4)
	// 82EDA6AC: C01F0074  lfs f0, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA6B0: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	pc = 0x82EDA6B4; continue 'dispatch;
            }
            0x82EDA6B4 => {
    //   block [0x82EDA6B4..0x82EDA6B8)
	// 82EDA6B4: 9B9F007C  stb r28, 0x7c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[28].u8 ) };
	pc = 0x82EDA6B8; continue 'dispatch;
            }
            0x82EDA6B8 => {
    //   block [0x82EDA6B8..0x82EDA6D8)
	// 82EDA6B8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EDA6BC: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EDA6C0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDA6C4: C3CA0BFC  lfs f30, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EDA6C8: 41820010  beq 0x82eda6d8
	if ctx.cr[0].eq {
	pc = 0x82EDA6D8; continue 'dispatch;
	}
	// 82EDA6CC: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA6D0: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EDA6D4: 4800001C  b 0x82eda6f0
	pc = 0x82EDA6F0; continue 'dispatch;
            }
            0x82EDA6D8 => {
    //   block [0x82EDA6D8..0x82EDA6EC)
	// 82EDA6D8: 817B0718  lwz r11, 0x718(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDA6DC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDA6E0: 4182000C  beq 0x82eda6ec
	if ctx.cr[0].eq {
	pc = 0x82EDA6EC; continue 'dispatch;
	}
	// 82EDA6E4: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA6E8: 48000008  b 0x82eda6f0
	pc = 0x82EDA6F0; continue 'dispatch;
            }
            0x82EDA6EC => {
    //   block [0x82EDA6EC..0x82EDA6F0)
	// 82EDA6EC: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x82EDA6F0; continue 'dispatch;
            }
            0x82EDA6F0 => {
    //   block [0x82EDA6F0..0x82EDA8A8)
	// 82EDA6F0: C1BF0020  lfs f13, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDA6F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EDA6F8: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EDA6FC: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EDA700: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EDA704: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EDA708: C1BF0080  lfs f13, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDA70C: C01F005C  lfs f0, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA710: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EDA714: C19F0060  lfs f12, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDA718: C1BF0084  lfs f13, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDA71C: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EDA720: C17F0088  lfs f11, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDA724: C19F0064  lfs f12, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDA728: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EDA72C: D3A10054  stfs f29, 0x54(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EDA730: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDA734: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EDA738: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EDA73C: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EDA740: D01F00C8  stfs f0, 0xc8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EDA744: C19F005C  lfs f12, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDA748: EC1F0024  fdivs f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EDA74C: C1BF0080  lfs f13, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDA750: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EDA754: C17F0084  lfs f11, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDA758: C15F0088  lfs f10, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EDA75C: C19F0060  lfs f12, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDA760: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EDA764: C17F0064  lfs f11, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDA768: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EDA76C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDA770: D1BF00B4  stfs f13, 0xb4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82EDA774: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDA778: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EDA77C: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDA780: D01F00BC  stfs f0, 0xbc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82EDA784: D19F00B8  stfs f12, 0xb8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82EDA788: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EDA78C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EDA790: 4B3A4AD9  bl 0x8227f268
	ctx.lr = 0x82EDA794;
	sub_8227F268(ctx, base);
	// 82EDA794: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA798: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82EDA79C: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA7A0: D01F00A0  stfs f0, 0xa0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82EDA7A4: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA7A8: D01F00A4  stfs f0, 0xa4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82EDA7AC: C17F00B8  lfs f11, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDA7B0: C1BF00A4  lfs f13, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDA7B4: ED0B0372  fmuls f8, f11, f13
	ctx.f[8].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EDA7B8: C01F00BC  lfs f0, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA7BC: C13F009C  lfs f9, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EDA7C0: C19F00A0  lfs f12, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDA7C4: ECE90032  fmuls f7, f9, f0
	ctx.f[7].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDA7C8: C15F00B4  lfs f10, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EDA7CC: EC004338  fmsubs f0, f0, f12, f8
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EDA7D0: D01F00A8  stfs f0, 0xa8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82EDA7D4: ED8A0332  fmuls f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EDA7D8: EDAA3B78  fmsubs f13, f10, f13, f7
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[13].f64 - ctx.f[7].f64) as f32) as f64);
	// 82EDA7DC: D1BF00AC  stfs f13, 0xac(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82EDA7E0: ED8962F8  fmsubs f12, f9, f11, f12
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EDA7E4: D19F00B0  stfs f12, 0xb0(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82EDA7E8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDA7EC: C1BF0078  lfs f13, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDA7F0: FD806890  fmr f12, f13
	ctx.f[12].f64 = ctx.f[13].f64;
	// 82EDA7F4: C17F002C  lfs f11, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDA7F8: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA7FC: EC1F0024  fdivs f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EDA800: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82EDA804: FD400090  fmr f10, f0
	ctx.f[10].f64 = ctx.f[0].f64;
	// 82EDA808: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDA80C: EDAA0332  fmuls f13, f10, f12
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EDA810: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EDA814: D01F0108  stfs f0, 0x108(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82EDA818: EC0D02F2  fmuls f0, f13, f11
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EDA81C: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82EDA820: 4B386199  bl 0x822609b8
	ctx.lr = 0x82EDA824;
	sub_822609B8(ctx, base);
	// 82EDA824: 817F0098  lwz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82EDA828: C01F00FC  lfs f0, 0xfc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA82C: C1A30058  lfs f13, 0x58(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDA830: 57AA063F  clrlwi. r10, r29, 0x18
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EDA834: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EDA838: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82EDA83C: D01F00FC  stfs f0, 0xfc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82EDA840: 41820068  beq 0x82eda8a8
	if ctx.cr[0].eq {
	pc = 0x82EDA8A8; continue 'dispatch;
	}
	// 82EDA844: C01F010C  lfs f0, 0x10c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA848: C1BF0108  lfs f13, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDA84C: ED40682A  fadds f10, f0, f13
	ctx.f[10].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EDA850: C1BF008C  lfs f13, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDA854: C01F005C  lfs f0, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA858: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EDA85C: C19F0094  lfs f12, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDA860: C1BF0064  lfs f13, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDA864: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EDA868: C19F009C  lfs f12, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDA86C: C13F00A4  lfs f9, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EDA870: C17F0104  lfs f11, 0x104(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDA874: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDA878: ED89637A  fmadds f12, f9, f13, f12
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 82EDA87C: D19F00DC  stfs f12, 0xdc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EDA880: D19F00D8  stfs f12, 0xd8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EDA884: C19F00B4  lfs f12, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDA888: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDA88C: C19F00BC  lfs f12, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDA890: EC0C037A  fmadds f0, f12, f13, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EDA894: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EDA898: D01F00E4  stfs f0, 0xe4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EDA89C: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EDA8A0: 40980008  bge cr6, 0x82eda8a8
	if !ctx.cr[6].lt {
	pc = 0x82EDA8A8; continue 'dispatch;
	}
	// 82EDA8A4: 9B5F00F8  stb r26, 0xf8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[26].u8 ) };
	pc = 0x82EDA8A8; continue 'dispatch;
            }
            0x82EDA8A8 => {
    //   block [0x82EDA8A8..0x82EDA91C)
	// 82EDA8A8: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82EDA8AC: 419A00BC  beq cr6, 0x82eda968
	if ctx.cr[6].eq {
	pc = 0x82EDA968; continue 'dispatch;
	}
	// 82EDA8B0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82EDA8B4: 419A00A0  beq cr6, 0x82eda954
	if ctx.cr[6].eq {
	pc = 0x82EDA954; continue 'dispatch;
	}
	// 82EDA8B8: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82EDA8BC: 409A00E4  bne cr6, 0x82eda9a0
	if !ctx.cr[6].eq {
	pc = 0x82EDA9A0; continue 'dispatch;
	}
	// 82EDA8C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EDA8C4: 409A0070  bne cr6, 0x82eda934
	if !ctx.cr[6].eq {
	pc = 0x82EDA934; continue 'dispatch;
	}
	// 82EDA8C8: C01F00FC  lfs f0, 0xfc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA8CC: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82EDA8D0: 40990064  ble cr6, 0x82eda934
	if !ctx.cr[6].gt {
	pc = 0x82EDA934; continue 'dispatch;
	}
	// 82EDA8D4: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EDA8D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EDA8DC: 409A00C4  bne cr6, 0x82eda9a0
	if !ctx.cr[6].eq {
	pc = 0x82EDA9A0; continue 'dispatch;
	}
	// 82EDA8E0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDA8E4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82EDA8E8: C01F008C  lfs f0, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA8EC: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 82EDA8F0: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 82EDA8F4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82EDA8F8: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82EDA8FC: 806B0264  lwz r3, 0x264(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(612 as u32) ) } as u64;
	// 82EDA900: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EDA904: C01F0090  lfs f0, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA908: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EDA90C: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82EDA910: C01F0094  lfs f0, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA914: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82EDA918: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82EDA91C; continue 'dispatch;
            }
            0x82EDA91C => {
    //   block [0x82EDA91C..0x82EDA934)
	// 82EDA91C: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82EDA920: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82EDA924: 4200FFF8  bdnz 0x82eda91c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EDA91C; continue 'dispatch;
	}
	// 82EDA928: 9B8100C8  stb r28, 0xc8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[28].u8 ) };
	// 82EDA92C: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82EDA930: 48000180  b 0x82edaab0
	pc = 0x82EDAAB0; continue 'dispatch;
            }
            0x82EDA934 => {
    //   block [0x82EDA934..0x82EDA948)
	// 82EDA934: C01F00FC  lfs f0, 0xfc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA938: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82EDA93C: 4199000C  bgt cr6, 0x82eda948
	if ctx.cr[6].gt {
	pc = 0x82EDA948; continue 'dispatch;
	}
	// 82EDA940: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDA944: 9B4B0397  stb r26, 0x397(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(919 as u32), ctx.r[26].u8 ) };
	pc = 0x82EDA948; continue 'dispatch;
            }
            0x82EDA948 => {
    //   block [0x82EDA948..0x82EDA954)
	// 82EDA948: C01F0038  lfs f0, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA94C: D01F00FC  stfs f0, 0xfc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82EDA950: 48000048  b 0x82eda998
	pc = 0x82EDA998; continue 'dispatch;
            }
            0x82EDA954 => {
    //   block [0x82EDA954..0x82EDA968)
	// 82EDA954: C01F00FC  lfs f0, 0xfc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA958: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82EDA95C: 40980044  bge cr6, 0x82eda9a0
	if !ctx.cr[6].lt {
	pc = 0x82EDA9A0; continue 'dispatch;
	}
	// 82EDA960: 939F0110  stw r28, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[28].u32 ) };
	// 82EDA964: 4800003C  b 0x82eda9a0
	pc = 0x82EDA9A0; continue 'dispatch;
            }
            0x82EDA968 => {
    //   block [0x82EDA968..0x82EDA990)
	// 82EDA968: C01F00FC  lfs f0, 0xfc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA96C: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82EDA970: 41990030  bgt cr6, 0x82eda9a0
	if ctx.cr[6].gt {
	pc = 0x82EDA9A0; continue 'dispatch;
	}
	// 82EDA974: C01F0034  lfs f0, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA978: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82EDA97C: 40990014  ble cr6, 0x82eda990
	if !ctx.cr[6].gt {
	pc = 0x82EDA990; continue 'dispatch;
	}
	// 82EDA980: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82EDA984: D01F00FC  stfs f0, 0xfc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82EDA988: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82EDA98C: 4800000C  b 0x82eda998
	pc = 0x82EDA998; continue 'dispatch;
            }
            0x82EDA990 => {
    //   block [0x82EDA990..0x82EDA998)
	// 82EDA990: D3BF00FC  stfs f29, 0xfc(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82EDA994: 939F0110  stw r28, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[28].u32 ) };
	pc = 0x82EDA998; continue 'dispatch;
            }
            0x82EDA998 => {
    //   block [0x82EDA998..0x82EDA9A0)
	// 82EDA998: 9B5F00F8  stb r26, 0xf8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[26].u8 ) };
	// 82EDA99C: 9B5F00FA  stb r26, 0xfa(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(250 as u32), ctx.r[26].u8 ) };
	pc = 0x82EDA9A0; continue 'dispatch;
            }
            0x82EDA9A0 => {
    //   block [0x82EDA9A0..0x82EDA9D4)
	// 82EDA9A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EDA9A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDA9A8: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EDA9AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDA9B0: 4E800421  bctrl
	ctx.lr = 0x82EDA9B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EDA9B4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EDA9B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDA9BC: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EDA9C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDA9C4: 4E800421  bctrl
	ctx.lr = 0x82EDA9C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EDA9C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDA9CC: 48007755  bl 0x82ee2120
	ctx.lr = 0x82EDA9D0;
	sub_82EE2120(ctx, base);
	// 82EDA9D0: 4BFFFC1C  b 0x82eda5ec
	pc = 0x82EDA5EC; continue 'dispatch;
            }
            0x82EDA9D4 => {
    //   block [0x82EDA9D4..0x82EDAA28)
	// 82EDA9D4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EDA9D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDA9DC: 48007595  bl 0x82ee1f70
	ctx.lr = 0x82EDA9E0;
	sub_82EE1F70(ctx, base);
	// 82EDA9E0: D3BF00D8  stfs f29, 0xd8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EDA9E4: D3BF00DC  stfs f29, 0xdc(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EDA9E8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EDA9EC: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA9F0: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EDA9F4: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDA9F8: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EDA9FC: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDAA00: C1BF0080  lfs f13, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDAA04: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EDAA08: D1BF008C  stfs f13, 0x8c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EDAA0C: C01F0084  lfs f0, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDAA10: D01F0090  stfs f0, 0x90(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82EDAA14: C01F0088  lfs f0, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDAA18: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82EDAA1C: 817F00D4  lwz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EDAA20: D3BF00E8  stfs f29, 0xe8(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EDAA24: 48000028  b 0x82edaa4c
	pc = 0x82EDAA4C; continue 'dispatch;
            }
            0x82EDAA28 => {
    //   block [0x82EDAA28..0x82EDAA4C)
	// 82EDAA28: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDAA2C: 9B8A0030  stb r28, 0x30(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(48 as u32), ctx.r[28].u8 ) };
	// 82EDAA30: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDAA34: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EDAA38: 812A002C  lwz r9, 0x2c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EDAA3C: 910A002C  stw r8, 0x2c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(44 as u32), ctx.r[8].u32 ) };
	// 82EDAA40: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDAA44: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82EDAA48: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	pc = 0x82EDAA4C; continue 'dispatch;
            }
            0x82EDAA4C => {
    //   block [0x82EDAA4C..0x82EDAA9C)
	// 82EDAA4C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDAA50: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EDAA54: 409AFFD4  bne cr6, 0x82edaa28
	if !ctx.cr[6].eq {
	pc = 0x82EDAA28; continue 'dispatch;
	}
	// 82EDAA58: 938B000C  stw r28, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82EDAA5C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82EDAA60: 938B0014  stw r28, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[28].u32 ) };
	// 82EDAA64: C01F008C  lfs f0, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDAA68: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDAA6C: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 82EDAA70: 390100E0  addi r8, r1, 0xe0
	ctx.r[8].s64 = ctx.r[1].s64 + 224;
	// 82EDAA74: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82EDAA78: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82EDAA7C: 806B0264  lwz r3, 0x264(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(612 as u32) ) } as u64;
	// 82EDAA80: D00100D4  stfs f0, 0xd4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EDAA84: C01F0090  lfs f0, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDAA88: 914100D0  stw r10, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[10].u32 ) };
	// 82EDAA8C: D00100D8  stfs f0, 0xd8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EDAA90: C01F0094  lfs f0, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDAA94: D00100DC  stfs f0, 0xdc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EDAA98: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82EDAA9C; continue 'dispatch;
            }
            0x82EDAA9C => {
    //   block [0x82EDAA9C..0x82EDAAB0)
	// 82EDAA9C: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82EDAAA0: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82EDAAA4: 4200FFF8  bdnz 0x82edaa9c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EDAA9C; continue 'dispatch;
	}
	// 82EDAAA8: 9B810128  stb r28, 0x128(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), ctx.r[28].u8 ) };
	// 82EDAAAC: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
	pc = 0x82EDAAB0; continue 'dispatch;
            }
            0x82EDAAB0 => {
    //   block [0x82EDAAB0..0x82EDAAD4)
	// 82EDAAB0: C02B0010  lfs f1, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EDAAB4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EDAAB8: 809F0058  lwz r4, 0x58(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EDAABC: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82EDAAC0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EDAAC4: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 82EDAAC8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EDAACC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDAAD0: 4E800421  bctrl
	ctx.lr = 0x82EDAAD4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EDAAD4 => {
    //   block [0x82EDAAD4..0x82EDAAE8)
	// 82EDAAD4: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 82EDAAD8: CBA1FFA8  lfd f29, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82EDAADC: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82EDAAE0: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82EDAAE4: 4BDCE968  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDAAE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EDAAE8 size=368
    let mut pc: u32 = 0x82EDAAE8;
    'dispatch: loop {
        match pc {
            0x82EDAAE8 => {
    //   block [0x82EDAAE8..0x82EDAB48)
	// 82EDAAE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDAAEC: 4BDCE921  bl 0x82ca940c
	ctx.lr = 0x82EDAAF0;
	sub_82CA93D0(ctx, base);
	// 82EDAAF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDAAF4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDAAF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDAAFC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EDAB00: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EDAB04: 396BA2F0  addi r11, r11, -0x5d10
	ctx.r[11].s64 = ctx.r[11].s64 + -23824;
	// 82EDAB08: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EDAB0C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EDAB10: 93BF0014  stw r29, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 82EDAB14: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EDAB18: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82EDAB1C: 93BF0010  stw r29, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 82EDAB20: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82EDAB24: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82EDAB28: 419A0124  beq cr6, 0x82edac4c
	if ctx.cr[6].eq {
	pc = 0x82EDAC4C; continue 'dispatch;
	}
	// 82EDAB2C: 3D6004EC  lis r11, 0x4ec
	ctx.r[11].s64 = 82575360;
	// 82EDAB30: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82EDAB34: 616B4EC4  ori r11, r11, 0x4ec4
	ctx.r[11].u64 = ctx.r[11].u64 | 20164;
	// 82EDAB38: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EDAB3C: 1D7E0034  mulli r11, r30, 0x34
	ctx.r[11].s32 = ((ctx.r[30].s32 as i64 * 52 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EDAB40: 40990008  ble cr6, 0x82edab48
	if !ctx.cr[6].gt {
	pc = 0x82EDAB48; continue 'dispatch;
	}
	// 82EDAB44: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x82EDAB48; continue 'dispatch;
            }
            0x82EDAB48 => {
    //   block [0x82EDAB48..0x82EDAB58)
	// 82EDAB48: 3940FFFB  li r10, -5
	ctx.r[10].s64 = -5;
	// 82EDAB4C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EDAB50: 41990008  bgt cr6, 0x82edab58
	if ctx.cr[6].gt {
	pc = 0x82EDAB58; continue 'dispatch;
	}
	// 82EDAB54: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	pc = 0x82EDAB58; continue 'dispatch;
            }
            0x82EDAB58 => {
    //   block [0x82EDAB58..0x82EDAB94)
	// 82EDAB58: 4B73BDD1  bl 0x82616928
	ctx.lr = 0x82EDAB5C;
	sub_82616928(ctx, base);
	// 82EDAB5C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDAB60: 41820080  beq 0x82edabe0
	if ctx.cr[0].eq {
	pc = 0x82EDABE0; continue 'dispatch;
	}
	// 82EDAB64: 38A30004  addi r5, r3, 4
	ctx.r[5].s64 = ctx.r[3].s64 + 4;
	// 82EDAB68: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82EDAB6C: 355EFFFF  addic. r10, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EDAB70: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 82EDAB74: 41800064  blt 0x82edabd8
	if ctx.cr[0].lt {
	pc = 0x82EDABD8; continue 'dispatch;
	}
	// 82EDAB78: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82EDAB7C: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82EDAB80: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 82EDAB84: 39690010  addi r11, r9, 0x10
	ctx.r[11].s64 = ctx.r[9].s64 + 16;
	// 82EDAB88: 3908AFB4  addi r8, r8, -0x504c
	ctx.r[8].s64 = ctx.r[8].s64 + -20556;
	// 82EDAB8C: C0060C18  lfs f0, 0xc18(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDAB90: 38E7BC40  addi r7, r7, -0x43c0
	ctx.r[7].s64 = ctx.r[7].s64 + -17344;
	pc = 0x82EDAB94; continue 'dispatch;
            }
            0x82EDAB94 => {
    //   block [0x82EDAB94..0x82EDABD8)
	// 82EDAB94: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82EDAB98: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EDAB9C: 910BFFF4  stw r8, -0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), ctx.r[8].u32 ) };
	// 82EDABA0: D00BFFF8  stfs f0, -8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82EDABA4: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82EDABA8: 39290034  addi r9, r9, 0x34
	ctx.r[9].s64 = ctx.r[9].s64 + 52;
	// 82EDABAC: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EDABB0: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EDABB4: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EDABB8: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EDABBC: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EDABC0: D00B0014  stfs f0, 0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EDABC4: 93AB0018  stw r29, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 82EDABC8: 93AB001C  stw r29, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 82EDABCC: 9BAB0020  stb r29, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82EDABD0: 396B0034  addi r11, r11, 0x34
	ctx.r[11].s64 = ctx.r[11].s64 + 52;
	// 82EDABD4: 4080FFC0  bge 0x82edab94
	if !ctx.cr[0].lt {
	pc = 0x82EDAB94; continue 'dispatch;
	}
	pc = 0x82EDABD8; continue 'dispatch;
            }
            0x82EDABD8 => {
    //   block [0x82EDABD8..0x82EDABE0)
	// 82EDABD8: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82EDABDC: 48000008  b 0x82edabe4
	pc = 0x82EDABE4; continue 'dispatch;
            }
            0x82EDABE0 => {
    //   block [0x82EDABE0..0x82EDABE4)
	// 82EDABE0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82EDABE4; continue 'dispatch;
            }
            0x82EDABE4 => {
    //   block [0x82EDABE4..0x82EDAC04)
	// 82EDABE4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EDABE8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EDABEC: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EDABF0: 93AB0028  stw r29, 0x28(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[29].u32 ) };
	// 82EDABF4: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EDABF8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EDABFC: 4099003C  ble cr6, 0x82edac38
	if !ctx.cr[6].gt {
	pc = 0x82EDAC38; continue 'dispatch;
	}
	// 82EDAC00: 39600034  li r11, 0x34
	ctx.r[11].s64 = 52;
	pc = 0x82EDAC04; continue 'dispatch;
            }
            0x82EDAC04 => {
    //   block [0x82EDAC04..0x82EDAC38)
	// 82EDAC04: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDAC08: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EDAC0C: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EDAC10: 3909FFCC  addi r8, r9, -0x34
	ctx.r[8].s64 = ctx.r[9].s64 + -52;
	// 82EDAC14: 91090028  stw r8, 0x28(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(40 as u32), ctx.r[8].u32 ) };
	// 82EDAC18: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDAC1C: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EDAC20: 396B0034  addi r11, r11, 0x34
	ctx.r[11].s64 = ctx.r[11].s64 + 52;
	// 82EDAC24: 81090028  lwz r8, 0x28(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EDAC28: 9128002C  stw r9, 0x2c(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 82EDAC2C: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EDAC30: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EDAC34: 4198FFD0  blt cr6, 0x82edac04
	if ctx.cr[6].lt {
	pc = 0x82EDAC04; continue 'dispatch;
	}
	pc = 0x82EDAC38; continue 'dispatch;
            }
            0x82EDAC38 => {
    //   block [0x82EDAC38..0x82EDAC4C)
	// 82EDAC38: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EDAC3C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDAC40: 1D6B0034  mulli r11, r11, 0x34
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 52 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EDAC44: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EDAC48: 93ABFFF8  stw r29, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[29].u32 ) };
	pc = 0x82EDAC4C; continue 'dispatch;
            }
            0x82EDAC4C => {
    //   block [0x82EDAC4C..0x82EDAC58)
	// 82EDAC4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDAC50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EDAC54: 4BDCE808  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDAC58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EDAC58 size=360
    let mut pc: u32 = 0x82EDAC58;
    'dispatch: loop {
        match pc {
            0x82EDAC58 => {
    //   block [0x82EDAC58..0x82EDACB8)
	// 82EDAC58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDAC5C: 4BDCE7B1  bl 0x82ca940c
	ctx.lr = 0x82EDAC60;
	sub_82CA93D0(ctx, base);
	// 82EDAC60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDAC64: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDAC68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDAC6C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EDAC70: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EDAC74: 396BA2F0  addi r11, r11, -0x5d10
	ctx.r[11].s64 = ctx.r[11].s64 + -23824;
	// 82EDAC78: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EDAC7C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EDAC80: 93BF0014  stw r29, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 82EDAC84: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EDAC88: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82EDAC8C: 93BF0010  stw r29, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 82EDAC90: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82EDAC94: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82EDAC98: 419A011C  beq cr6, 0x82edadb4
	if ctx.cr[6].eq {
	pc = 0x82EDADB4; continue 'dispatch;
	}
	// 82EDAC9C: 3D60071C  lis r11, 0x71c
	ctx.r[11].s64 = 119275520;
	// 82EDACA0: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82EDACA4: 616B71C7  ori r11, r11, 0x71c7
	ctx.r[11].u64 = ctx.r[11].u64 | 29127;
	// 82EDACA8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EDACAC: 1D7E0024  mulli r11, r30, 0x24
	ctx.r[11].s32 = ((ctx.r[30].s32 as i64 * 36 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EDACB0: 40990008  ble cr6, 0x82edacb8
	if !ctx.cr[6].gt {
	pc = 0x82EDACB8; continue 'dispatch;
	}
	// 82EDACB4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x82EDACB8; continue 'dispatch;
            }
            0x82EDACB8 => {
    //   block [0x82EDACB8..0x82EDACC8)
	// 82EDACB8: 3940FFFB  li r10, -5
	ctx.r[10].s64 = -5;
	// 82EDACBC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EDACC0: 41990008  bgt cr6, 0x82edacc8
	if ctx.cr[6].gt {
	pc = 0x82EDACC8; continue 'dispatch;
	}
	// 82EDACC4: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	pc = 0x82EDACC8; continue 'dispatch;
            }
            0x82EDACC8 => {
    //   block [0x82EDACC8..0x82EDAD0C)
	// 82EDACC8: 4B73BC61  bl 0x82616928
	ctx.lr = 0x82EDACCC;
	sub_82616928(ctx, base);
	// 82EDACCC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDACD0: 41820078  beq 0x82edad48
	if ctx.cr[0].eq {
	pc = 0x82EDAD48; continue 'dispatch;
	}
	// 82EDACD4: 38830004  addi r4, r3, 4
	ctx.r[4].s64 = ctx.r[3].s64 + 4;
	// 82EDACD8: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82EDACDC: 355EFFFF  addic. r10, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EDACE0: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EDACE4: 4180005C  blt 0x82edad40
	if ctx.cr[0].lt {
	pc = 0x82EDAD40; continue 'dispatch;
	}
	// 82EDACE8: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82EDACEC: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82EDACF0: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82EDACF4: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 82EDACF8: 39690010  addi r11, r9, 0x10
	ctx.r[11].s64 = ctx.r[9].s64 + 16;
	// 82EDACFC: C1A50C14  lfs f13, 0xc14(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDAD00: 3908AFB4  addi r8, r8, -0x504c
	ctx.r[8].s64 = ctx.r[8].s64 + -20556;
	// 82EDAD04: C0060C18  lfs f0, 0xc18(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDAD08: 38E7BC44  addi r7, r7, -0x43bc
	ctx.r[7].s64 = ctx.r[7].s64 + -17340;
	pc = 0x82EDAD0C; continue 'dispatch;
            }
            0x82EDAD0C => {
    //   block [0x82EDAD0C..0x82EDAD40)
	// 82EDAD0C: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82EDAD10: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EDAD14: 910BFFF4  stw r8, -0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), ctx.r[8].u32 ) };
	// 82EDAD18: D00BFFF8  stfs f0, -8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82EDAD1C: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82EDAD20: 39290024  addi r9, r9, 0x24
	ctx.r[9].s64 = ctx.r[9].s64 + 36;
	// 82EDAD24: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EDAD28: D1AB0004  stfs f13, 4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EDAD2C: 93AB0008  stw r29, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EDAD30: 93AB000C  stw r29, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82EDAD34: 9BAB0010  stb r29, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[29].u8 ) };
	// 82EDAD38: 396B0024  addi r11, r11, 0x24
	ctx.r[11].s64 = ctx.r[11].s64 + 36;
	// 82EDAD3C: 4080FFD0  bge 0x82edad0c
	if !ctx.cr[0].lt {
	pc = 0x82EDAD0C; continue 'dispatch;
	}
	pc = 0x82EDAD40; continue 'dispatch;
            }
            0x82EDAD40 => {
    //   block [0x82EDAD40..0x82EDAD48)
	// 82EDAD40: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EDAD44: 48000008  b 0x82edad4c
	pc = 0x82EDAD4C; continue 'dispatch;
            }
            0x82EDAD48 => {
    //   block [0x82EDAD48..0x82EDAD4C)
	// 82EDAD48: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82EDAD4C; continue 'dispatch;
            }
            0x82EDAD4C => {
    //   block [0x82EDAD4C..0x82EDAD6C)
	// 82EDAD4C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EDAD50: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EDAD54: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EDAD58: 93AB0018  stw r29, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 82EDAD5C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EDAD60: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EDAD64: 4099003C  ble cr6, 0x82edada0
	if !ctx.cr[6].gt {
	pc = 0x82EDADA0; continue 'dispatch;
	}
	// 82EDAD68: 39600024  li r11, 0x24
	ctx.r[11].s64 = 36;
	pc = 0x82EDAD6C; continue 'dispatch;
            }
            0x82EDAD6C => {
    //   block [0x82EDAD6C..0x82EDADA0)
	// 82EDAD6C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDAD70: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EDAD74: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EDAD78: 3909FFDC  addi r8, r9, -0x24
	ctx.r[8].s64 = ctx.r[9].s64 + -36;
	// 82EDAD7C: 91090018  stw r8, 0x18(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 82EDAD80: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDAD84: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EDAD88: 396B0024  addi r11, r11, 0x24
	ctx.r[11].s64 = ctx.r[11].s64 + 36;
	// 82EDAD8C: 81090018  lwz r8, 0x18(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EDAD90: 9128001C  stw r9, 0x1c(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 82EDAD94: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EDAD98: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EDAD9C: 4198FFD0  blt cr6, 0x82edad6c
	if ctx.cr[6].lt {
	pc = 0x82EDAD6C; continue 'dispatch;
	}
	pc = 0x82EDADA0; continue 'dispatch;
            }
            0x82EDADA0 => {
    //   block [0x82EDADA0..0x82EDADB4)
	// 82EDADA0: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EDADA4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDADA8: 1D6B0024  mulli r11, r11, 0x24
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 36 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EDADAC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EDADB0: 93ABFFF8  stw r29, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[29].u32 ) };
	pc = 0x82EDADB4; continue 'dispatch;
            }
            0x82EDADB4 => {
    //   block [0x82EDADB4..0x82EDADC0)
	// 82EDADB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDADB8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EDADBC: 4BDCE6A0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDADC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EDADC0 size=192
    let mut pc: u32 = 0x82EDADC0;
    'dispatch: loop {
        match pc {
            0x82EDADC0 => {
    //   block [0x82EDADC0..0x82EDAE00)
	// 82EDADC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDADC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EDADC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EDADCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EDADD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDADD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDADD8: 548B07BD  rlwinm. r11, r4, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDADDC: 4182005C  beq 0x82edae38
	if ctx.cr[0].eq {
	pc = 0x82EDAE38; continue 'dispatch;
	}
	// 82EDADE0: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EDADE4: 3BDFFFFC  addi r30, r31, -4
	ctx.r[30].s64 = ctx.r[31].s64 + -4;
	// 82EDADE8: 1D4B0024  mulli r10, r11, 0x24
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 36 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EDADEC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDADF0: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82EDADF4: 41800020  blt 0x82edae14
	if ctx.cr[0].lt {
	pc = 0x82EDAE14; continue 'dispatch;
	}
	// 82EDADF8: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82EDADFC: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	pc = 0x82EDAE00; continue 'dispatch;
            }
            0x82EDAE00 => {
    //   block [0x82EDAE00..0x82EDAE14)
	// 82EDAE00: 394AFFDC  addi r10, r10, -0x24
	ctx.r[10].s64 = ctx.r[10].s64 + -36;
	// 82EDAE04: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDAE08: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EDAE0C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EDAE10: 4080FFF0  bge 0x82edae00
	if !ctx.cr[0].lt {
	pc = 0x82EDAE00; continue 'dispatch;
	}
	pc = 0x82EDAE14; continue 'dispatch;
            }
            0x82EDAE14 => {
    //   block [0x82EDAE14..0x82EDAE30)
	// 82EDAE14: 548B07FF  clrlwi. r11, r4, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDAE18: 41820018  beq 0x82edae30
	if ctx.cr[0].eq {
	pc = 0x82EDAE30; continue 'dispatch;
	}
	// 82EDAE1C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EDAE20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDAE24: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EDAE28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDAE2C: 4E800421  bctrl
	ctx.lr = 0x82EDAE30;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EDAE30 => {
    //   block [0x82EDAE30..0x82EDAE38)
	// 82EDAE30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDAE34: 48000034  b 0x82edae68
	pc = 0x82EDAE68; continue 'dispatch;
            }
            0x82EDAE38 => {
    //   block [0x82EDAE38..0x82EDAE64)
	// 82EDAE38: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EDAE3C: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EDAE40: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EDAE44: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EDAE48: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EDAE4C: 41820018  beq 0x82edae64
	if ctx.cr[0].eq {
	pc = 0x82EDAE64; continue 'dispatch;
	}
	// 82EDAE50: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EDAE54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDAE58: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EDAE5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDAE60: 4E800421  bctrl
	ctx.lr = 0x82EDAE64;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EDAE64 => {
    //   block [0x82EDAE64..0x82EDAE68)
	// 82EDAE64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82EDAE68; continue 'dispatch;
            }
            0x82EDAE68 => {
    //   block [0x82EDAE68..0x82EDAE80)
	// 82EDAE68: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EDAE6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EDAE70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EDAE74: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EDAE78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EDAE7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDAE80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EDAE80 size=568
    let mut pc: u32 = 0x82EDAE80;
    'dispatch: loop {
        match pc {
            0x82EDAE80 => {
    //   block [0x82EDAE80..0x82EDAECC)
	// 82EDAE80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDAE84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EDAE88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EDAE8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EDAE90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDAE94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDAE98: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EDAE9C: 4BFDA495  bl 0x82eb5330
	ctx.lr = 0x82EDAEA0;
	sub_82EB5330(ctx, base);
	// 82EDAEA0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDAEA4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EDAEA8: 396BBB08  addi r11, r11, -0x44f8
	ctx.r[11].s64 = ctx.r[11].s64 + -17656;
	// 82EDAEAC: C1890C14  lfs f12, 0xc14(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDAEB0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EDAEB4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDAEB8: 814B0718  lwz r10, 0x718(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDAEBC: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDAEC0: 4182000C  beq 0x82edaecc
	if ctx.cr[0].eq {
	pc = 0x82EDAECC; continue 'dispatch;
	}
	// 82EDAEC4: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDAEC8: 48000008  b 0x82edaed0
	pc = 0x82EDAED0; continue 'dispatch;
            }
            0x82EDAECC => {
    //   block [0x82EDAECC..0x82EDAED0)
	// 82EDAECC: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	pc = 0x82EDAED0; continue 'dispatch;
            }
            0x82EDAED0 => {
    //   block [0x82EDAED0..0x82EDAF00)
	// 82EDAED0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EDAED4: C00A0AC8  lfs f0, 0xac8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2760 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDAED8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EDAEDC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDAEE0: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EDAEE4: C1AA0BF8  lfs f13, 0xbf8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3064 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDAEE8: D1BF0014  stfs f13, 0x14(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EDAEEC: 814B0718  lwz r10, 0x718(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDAEF0: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDAEF4: 4182000C  beq 0x82edaf00
	if ctx.cr[0].eq {
	pc = 0x82EDAF00; continue 'dispatch;
	}
	// 82EDAEF8: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDAEFC: 48000008  b 0x82edaf04
	pc = 0x82EDAF04; continue 'dispatch;
            }
            0x82EDAF00 => {
    //   block [0x82EDAF00..0x82EDAF04)
	// 82EDAF00: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	pc = 0x82EDAF04; continue 'dispatch;
            }
            0x82EDAF04 => {
    //   block [0x82EDAF04..0x82EDAF28)
	// 82EDAF04: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EDAF08: C16ABDF4  lfs f11, -0x420c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16908 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDAF0C: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EDAF10: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EDAF14: 814B0718  lwz r10, 0x718(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDAF18: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDAF1C: 4182000C  beq 0x82edaf28
	if ctx.cr[0].eq {
	pc = 0x82EDAF28; continue 'dispatch;
	}
	// 82EDAF20: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDAF24: 48000008  b 0x82edaf2c
	pc = 0x82EDAF2C; continue 'dispatch;
            }
            0x82EDAF28 => {
    //   block [0x82EDAF28..0x82EDAF2C)
	// 82EDAF28: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	pc = 0x82EDAF2C; continue 'dispatch;
            }
            0x82EDAF2C => {
    //   block [0x82EDAF2C..0x82EDAF48)
	// 82EDAF2C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EDAF30: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EDAF34: 814B0718  lwz r10, 0x718(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDAF38: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDAF3C: 4182000C  beq 0x82edaf48
	if ctx.cr[0].eq {
	pc = 0x82EDAF48; continue 'dispatch;
	}
	// 82EDAF40: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDAF44: 48000008  b 0x82edaf4c
	pc = 0x82EDAF4C; continue 'dispatch;
            }
            0x82EDAF48 => {
    //   block [0x82EDAF48..0x82EDAF4C)
	// 82EDAF48: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	pc = 0x82EDAF4C; continue 'dispatch;
            }
            0x82EDAF4C => {
    //   block [0x82EDAF4C..0x82EDAF70)
	// 82EDAF4C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EDAF50: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EDAF54: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EDAF58: 995F0024  stb r10, 0x24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[10].u8 ) };
	// 82EDAF5C: 812B0718  lwz r9, 0x718(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDAF60: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDAF64: 4182000C  beq 0x82edaf70
	if ctx.cr[0].eq {
	pc = 0x82EDAF70; continue 'dispatch;
	}
	// 82EDAF68: C1A9000C  lfs f13, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDAF6C: 48000008  b 0x82edaf74
	pc = 0x82EDAF74; continue 'dispatch;
            }
            0x82EDAF70 => {
    //   block [0x82EDAF70..0x82EDAF74)
	// 82EDAF70: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	pc = 0x82EDAF74; continue 'dispatch;
            }
            0x82EDAF74 => {
    //   block [0x82EDAF74..0x82EDAFC0)
	// 82EDAF74: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EDAF78: D1BF0028  stfs f13, 0x28(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82EDAF7C: 39000064  li r8, 0x64
	ctx.r[8].s64 = 100;
	// 82EDAF80: D19F002C  stfs f12, 0x2c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EDAF84: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82EDAF88: D19F0038  stfs f12, 0x38(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82EDAF8C: C009BE10  lfs f0, -0x41f0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDAF90: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EDAF94: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EDAF98: 911F003C  stw r8, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[8].u32 ) };
	// 82EDAF9C: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82EDAFA0: 98FF0044  stb r7, 0x44(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[7].u8 ) };
	// 82EDAFA4: C1A989CC  lfs f13, -0x7634(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-30260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDAFA8: D1BF0040  stfs f13, 0x40(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82EDAFAC: 812B0718  lwz r9, 0x718(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDAFB0: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDAFB4: 4182000C  beq 0x82edafc0
	if ctx.cr[0].eq {
	pc = 0x82EDAFC0; continue 'dispatch;
	}
	// 82EDAFB8: C009000C  lfs f0, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDAFBC: 48000008  b 0x82edafc4
	pc = 0x82EDAFC4; continue 'dispatch;
            }
            0x82EDAFC0 => {
    //   block [0x82EDAFC0..0x82EDAFC4)
	// 82EDAFC0: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	pc = 0x82EDAFC4; continue 'dispatch;
            }
            0x82EDAFC4 => {
    //   block [0x82EDAFC4..0x82EDB054)
	// 82EDAFC4: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EDAFC8: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82EDAFCC: 915F0054  stw r10, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82EDAFD0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EDAFD4: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDAFD8: C0090C18  lfs f0, 0xc18(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDAFDC: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EDAFE0: 81080014  lwz r8, 0x14(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EDAFE4: 3929AFB4  addi r9, r9, -0x504c
	ctx.r[9].s64 = ctx.r[9].s64 + -20556;
	// 82EDAFE8: 911F0058  stw r8, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 82EDAFEC: D01F005C  stfs f0, 0x5c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EDAFF0: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EDAFF4: D01F0064  stfs f0, 0x64(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EDAFF8: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EDAFFC: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EDB000: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EDB004: D01F008C  stfs f0, 0x8c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EDB008: D01F0090  stfs f0, 0x90(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82EDB00C: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82EDB010: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82EDB014: D01F00A0  stfs f0, 0xa0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82EDB018: D01F00A4  stfs f0, 0xa4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82EDB01C: D01F00A8  stfs f0, 0xa8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82EDB020: D01F00AC  stfs f0, 0xac(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82EDB024: D01F00B0  stfs f0, 0xb0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82EDB028: D01F00B4  stfs f0, 0xb4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82EDB02C: D01F00B8  stfs f0, 0xb8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82EDB030: D01F00BC  stfs f0, 0xbc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82EDB034: 915F00D4  stw r10, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[10].u32 ) };
	// 82EDB038: 913F00F0  stw r9, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[9].u32 ) };
	// 82EDB03C: 915F00F4  stw r10, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[10].u32 ) };
	// 82EDB040: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDB044: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDB048: 4182000C  beq 0x82edb054
	if ctx.cr[0].eq {
	pc = 0x82EDB054; continue 'dispatch;
	}
	// 82EDB04C: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDB050: 48000008  b 0x82edb058
	pc = 0x82EDB058; continue 'dispatch;
            }
            0x82EDB054 => {
    //   block [0x82EDB054..0x82EDB058)
	// 82EDB054: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	pc = 0x82EDB058; continue 'dispatch;
            }
            0x82EDB058 => {
    //   block [0x82EDB058..0x82EDB0B8)
	// 82EDB058: EDAD02F2  fmuls f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EDB05C: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82EDB060: D01F0108  stfs f0, 0x108(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82EDB064: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDB068: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82EDB06C: 915F0114  stw r10, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[10].u32 ) };
	// 82EDB070: 915F0118  stw r10, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[10].u32 ) };
	// 82EDB074: EC0C6824  fdivs f0, f12, f13
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EDB078: D01F0100  stfs f0, 0x100(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82EDB07C: 4BFFF245  bl 0x82eda2c0
	ctx.lr = 0x82EDB080;
	sub_82EDA2C0(ctx, base);
	// 82EDB080: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDB084: 3BCBBC48  addi r30, r11, -0x43b8
	ctx.r[30].s64 = ctx.r[11].s64 + -17336;
	// 82EDB088: 4B385931  bl 0x822609b8
	ctx.lr = 0x82EDB08C;
	sub_822609B8(ctx, base);
	// 82EDB08C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EDB090: 4BFA61A9  bl 0x82e81238
	ctx.lr = 0x82EDB094;
	sub_82E81238(ctx, base);
	// 82EDB094: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EDB098: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDB09C: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EDB0A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EDB0A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EDB0A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EDB0AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EDB0B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EDB0B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDB0B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EDB0B8 size=320
    let mut pc: u32 = 0x82EDB0B8;
    'dispatch: loop {
        match pc {
            0x82EDB0B8 => {
    //   block [0x82EDB0B8..0x82EDB10C)
	// 82EDB0B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDB0BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EDB0C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EDB0C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EDB0C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDB0CC: 3FC08334  lis r30, -0x7ccc
	ctx.r[30].s64 = -2093744128;
	// 82EDB0D0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDB0D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDB0D8: 388B1BA0  addi r4, r11, 0x1ba0
	ctx.r[4].s64 = ctx.r[11].s64 + 7072;
	// 82EDB0DC: 807E0718  lwz r3, 0x718(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDB0E0: 4B38CB41  bl 0x82267c20
	ctx.lr = 0x82EDB0E4;
	sub_82267C20(ctx, base);
	// 82EDB0E4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EDB0E8: 907F004C  stw r3, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[3].u32 ) };
	// 82EDB0EC: 807E0718  lwz r3, 0x718(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDB0F0: 388B8BE4  addi r4, r11, -0x741c
	ctx.r[4].s64 = ctx.r[11].s64 + -29724;
	// 82EDB0F4: 4B38CB2D  bl 0x82267c20
	ctx.lr = 0x82EDB0F8;
	sub_82267C20(ctx, base);
	// 82EDB0F8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDB0FC: 907F0050  stw r3, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EDB100: 4082000C  bne 0x82edb10c
	if !ctx.cr[0].eq {
	pc = 0x82EDB10C; continue 'dispatch;
	}
	// 82EDB104: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EDB108: 480000D8  b 0x82edb1e0
	pc = 0x82EDB1E0; continue 'dispatch;
            }
            0x82EDB10C => {
    //   block [0x82EDB10C..0x82EDB1AC)
	// 82EDB10C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDB110: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EDB114: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EDB118: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82EDB11C: 4B30D55D  bl 0x821e8678
	ctx.lr = 0x82EDB120;
	sub_821E8678(ctx, base);
	// 82EDB120: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EDB124: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDB128: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EDB12C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EDB130: 388BDA4C  addi r4, r11, -0x25b4
	ctx.r[4].s64 = ctx.r[11].s64 + -9652;
	// 82EDB134: 915F006C  stw r10, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 82EDB138: 4B30D541  bl 0x821e8678
	ctx.lr = 0x82EDB13C;
	sub_821E8678(ctx, base);
	// 82EDB13C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EDB140: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EDB144: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDB148: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EDB14C: 388BC178  addi r4, r11, -0x3e88
	ctx.r[4].s64 = ctx.r[11].s64 + -16008;
	// 82EDB150: 915F0070  stw r10, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82EDB154: 4B30D525  bl 0x821e8678
	ctx.lr = 0x82EDB158;
	sub_821E8678(ctx, base);
	// 82EDB158: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EDB15C: C01F0048  lfs f0, 0x48(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDB160: C1BF001C  lfs f13, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDB164: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82EDB168: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EDB16C: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82EDB170: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82EDB174: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDB178: C00B0C68  lfs f0, 0xc68(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDB17C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDB180: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82EDB184: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 82EDB188: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EDB18C: 23CB0001  subfic r30, r11, 1
	ctx.xer.ca = ctx.r[11].u32 <= 1 as u32;
	ctx.r[30].s64 = (1 as i64) - ctx.r[11].s64;
	// 82EDB190: 4B73B799  bl 0x82616928
	ctx.lr = 0x82EDB194;
	sub_82616928(ctx, base);
	// 82EDB194: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDB198: 41820014  beq 0x82edb1ac
	if ctx.cr[0].eq {
	pc = 0x82EDB1AC; continue 'dispatch;
	}
	// 82EDB19C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EDB1A0: 4BFFF949  bl 0x82edaae8
	ctx.lr = 0x82EDB1A4;
	sub_82EDAAE8(ctx, base);
	// 82EDB1A4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EDB1A8: 48000008  b 0x82edb1b0
	pc = 0x82EDB1B0; continue 'dispatch;
            }
            0x82EDB1AC => {
    //   block [0x82EDB1AC..0x82EDB1B0)
	// 82EDB1AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EDB1B0; continue 'dispatch;
            }
            0x82EDB1B0 => {
    //   block [0x82EDB1B0..0x82EDB1D4)
	// 82EDB1B0: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82EDB1B4: 917F00D4  stw r11, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 82EDB1B8: 4B73B771  bl 0x82616928
	ctx.lr = 0x82EDB1BC;
	sub_82616928(ctx, base);
	// 82EDB1BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDB1C0: 41820014  beq 0x82edb1d4
	if ctx.cr[0].eq {
	pc = 0x82EDB1D4; continue 'dispatch;
	}
	// 82EDB1C4: 38800024  li r4, 0x24
	ctx.r[4].s64 = 36;
	// 82EDB1C8: 4BFFFA91  bl 0x82edac58
	ctx.lr = 0x82EDB1CC;
	sub_82EDAC58(ctx, base);
	// 82EDB1CC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EDB1D0: 48000008  b 0x82edb1d8
	pc = 0x82EDB1D8; continue 'dispatch;
            }
            0x82EDB1D4 => {
    //   block [0x82EDB1D4..0x82EDB1D8)
	// 82EDB1D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EDB1D8; continue 'dispatch;
            }
            0x82EDB1D8 => {
    //   block [0x82EDB1D8..0x82EDB1E0)
	// 82EDB1D8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EDB1DC: 917F0118  stw r11, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	pc = 0x82EDB1E0; continue 'dispatch;
            }
            0x82EDB1E0 => {
    //   block [0x82EDB1E0..0x82EDB1F8)
	// 82EDB1E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EDB1E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EDB1E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EDB1EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EDB1F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EDB1F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDB1F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EDB1F8 size=88
    let mut pc: u32 = 0x82EDB1F8;
    'dispatch: loop {
        match pc {
            0x82EDB1F8 => {
    //   block [0x82EDB1F8..0x82EDB234)
	// 82EDB1F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDB1FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EDB200: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EDB204: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EDB208: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDB20C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDB210: 3860011C  li r3, 0x11c
	ctx.r[3].s64 = 284;
	// 82EDB214: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EDB218: 4B73B711  bl 0x82616928
	ctx.lr = 0x82EDB21C;
	sub_82616928(ctx, base);
	// 82EDB21C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDB220: 41820014  beq 0x82edb234
	if ctx.cr[0].eq {
	pc = 0x82EDB234; continue 'dispatch;
	}
	// 82EDB224: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EDB228: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDB22C: 4BFFFC55  bl 0x82edae80
	ctx.lr = 0x82EDB230;
	sub_82EDAE80(ctx, base);
	// 82EDB230: 48000008  b 0x82edb238
	pc = 0x82EDB238; continue 'dispatch;
            }
            0x82EDB234 => {
    //   block [0x82EDB234..0x82EDB238)
	// 82EDB234: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EDB238; continue 'dispatch;
            }
            0x82EDB238 => {
    //   block [0x82EDB238..0x82EDB250)
	// 82EDB238: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EDB23C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EDB240: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EDB244: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EDB248: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EDB24C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDB250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EDB250 size=104
    let mut pc: u32 = 0x82EDB250;
    'dispatch: loop {
        match pc {
            0x82EDB250 => {
    //   block [0x82EDB250..0x82EDB290)
	// 82EDB250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDB254: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EDB258: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EDB25C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDB260: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDB264: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDB268: 396BBC88  addi r11, r11, -0x4378
	ctx.r[11].s64 = ctx.r[11].s64 + -17272;
	// 82EDB26C: 807F00CC  lwz r3, 0xcc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82EDB270: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDB274: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EDB278: 41820018  beq 0x82edb290
	if ctx.cr[0].eq {
	pc = 0x82EDB290; continue 'dispatch;
	}
	// 82EDB27C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EDB280: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EDB284: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EDB288: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDB28C: 4E800421  bctrl
	ctx.lr = 0x82EDB290;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EDB290 => {
    //   block [0x82EDB290..0x82EDB2B8)
	// 82EDB290: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EDB294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDB298: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EDB29C: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82EDB2A0: 4BFDA129  bl 0x82eb53c8
	ctx.lr = 0x82EDB2A4;
	sub_82EB53C8(ctx, base);
	// 82EDB2A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EDB2A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EDB2AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EDB2B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EDB2B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDB2B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EDB2B8 size=12
    let mut pc: u32 = 0x82EDB2B8;
    'dispatch: loop {
        match pc {
            0x82EDB2B8 => {
    //   block [0x82EDB2B8..0x82EDB2C4)
	// 82EDB2B8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EDB2BC: 386B8AD0  addi r3, r11, -0x7530
	ctx.r[3].s64 = ctx.r[11].s64 + -30000;
	// 82EDB2C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDB2C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EDB2C8 size=80
    let mut pc: u32 = 0x82EDB2C8;
    'dispatch: loop {
        match pc {
            0x82EDB2C8 => {
    //   block [0x82EDB2C8..0x82EDB2F0)
	// 82EDB2C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDB2CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EDB2D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EDB2D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDB2D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDB2DC: 4BFE8D9D  bl 0x82ec4078
	ctx.lr = 0x82EDB2E0;
	sub_82EC4078(ctx, base);
	// 82EDB2E0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDB2E4: 4082000C  bne 0x82edb2f0
	if !ctx.cr[0].eq {
	pc = 0x82EDB2F0; continue 'dispatch;
	}
	// 82EDB2E8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EDB2EC: 48000018  b 0x82edb304
	pc = 0x82EDB304; continue 'dispatch;
            }
            0x82EDB2F0 => {
    //   block [0x82EDB2F0..0x82EDB304)
	// 82EDB2F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EDB2F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDB2F8: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EDB2FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDB300: 4E800421  bctrl
	ctx.lr = 0x82EDB304;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EDB304 => {
    //   block [0x82EDB304..0x82EDB318)
	// 82EDB304: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EDB308: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EDB30C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EDB310: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EDB314: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDB318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EDB318 size=88
    let mut pc: u32 = 0x82EDB318;
    'dispatch: loop {
        match pc {
            0x82EDB318 => {
    //   block [0x82EDB318..0x82EDB32C)
	// 82EDB318: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EDB31C: C1A30050  lfs f13, 0x50(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDB320: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDB324: C16A0C14  lfs f11, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDB328: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EDB32C; continue 'dispatch;
            }
            0x82EDB32C => {
    //   block [0x82EDB32C..0x82EDB340)
	// 82EDB32C: FF016000  fcmpu cr6, f1, f12
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[12].f64);
	// 82EDB330: 41980010  blt cr6, 0x82edb340
	if ctx.cr[6].lt {
	pc = 0x82EDB340; continue 'dispatch;
	}
	// 82EDB334: FF015800  fcmpu cr6, f1, f11
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[11].f64);
	// 82EDB338: 41990008  bgt cr6, 0x82edb340
	if ctx.cr[6].gt {
	pc = 0x82EDB340; continue 'dispatch;
	}
	// 82EDB33C: FDA00890  fmr f13, f1
	ctx.f[13].f64 = ctx.f[1].f64;
	pc = 0x82EDB340; continue 'dispatch;
            }
            0x82EDB340 => {
    //   block [0x82EDB340..0x82EDB370)
	// 82EDB340: FF0D6800  fcmpu cr6, f13, f13
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[13].f64);
	// 82EDB344: 409AFFE8  bne cr6, 0x82edb32c
	if !ctx.cr[6].eq {
	pc = 0x82EDB32C; continue 'dispatch;
	}
	// 82EDB348: D1A30050  stfs f13, 0x50(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EDB34C: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDB350: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82EDB354: C0030048  lfs f0, 0x48(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDB358: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EDB35C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82EDB360: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EDB364: EC0B0024  fdivs f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EDB368: D00300FC  stfs f0, 0xfc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82EDB36C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDB370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EDB370 size=576
    let mut pc: u32 = 0x82EDB370;
    'dispatch: loop {
        match pc {
            0x82EDB370 => {
    //   block [0x82EDB370..0x82EDB3BC)
	// 82EDB370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDB374: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EDB378: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EDB37C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EDB380: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDB384: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDB388: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EDB38C: 4BFD9FA5  bl 0x82eb5330
	ctx.lr = 0x82EDB390;
	sub_82EB5330(ctx, base);
	// 82EDB390: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDB394: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EDB398: 396BBC88  addi r11, r11, -0x4378
	ctx.r[11].s64 = ctx.r[11].s64 + -17272;
	// 82EDB39C: C1690C14  lfs f11, 0xc14(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDB3A0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EDB3A4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDB3A8: 814B0718  lwz r10, 0x718(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDB3AC: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDB3B0: 4182000C  beq 0x82edb3bc
	if ctx.cr[0].eq {
	pc = 0x82EDB3BC; continue 'dispatch;
	}
	// 82EDB3B4: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDB3B8: 48000008  b 0x82edb3c0
	pc = 0x82EDB3C0; continue 'dispatch;
            }
            0x82EDB3BC => {
    //   block [0x82EDB3BC..0x82EDB3C0)
	// 82EDB3BC: FDA05890  fmr f13, f11
	ctx.f[13].f64 = ctx.f[11].f64;
	pc = 0x82EDB3C0; continue 'dispatch;
            }
            0x82EDB3C0 => {
    //   block [0x82EDB3C0..0x82EDB3F0)
	// 82EDB3C0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EDB3C4: C00A0AC8  lfs f0, 0xac8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2760 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDB3C8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EDB3CC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDB3D0: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EDB3D4: C14A0BF8  lfs f10, 0xbf8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3064 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EDB3D8: D15F0014  stfs f10, 0x14(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EDB3DC: 814B0718  lwz r10, 0x718(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDB3E0: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDB3E4: 4182000C  beq 0x82edb3f0
	if ctx.cr[0].eq {
	pc = 0x82EDB3F0; continue 'dispatch;
	}
	// 82EDB3E8: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDB3EC: 48000008  b 0x82edb3f4
	pc = 0x82EDB3F4; continue 'dispatch;
            }
            0x82EDB3F0 => {
    //   block [0x82EDB3F0..0x82EDB3F4)
	// 82EDB3F0: FC005890  fmr f0, f11
	ctx.f[0].f64 = ctx.f[11].f64;
	pc = 0x82EDB3F4; continue 'dispatch;
            }
            0x82EDB3F4 => {
    //   block [0x82EDB3F4..0x82EDB418)
	// 82EDB3F4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EDB3F8: C1AA0BFC  lfs f13, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDB3FC: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EDB400: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EDB404: 814B0718  lwz r10, 0x718(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDB408: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDB40C: 4182000C  beq 0x82edb418
	if ctx.cr[0].eq {
	pc = 0x82EDB418; continue 'dispatch;
	}
	// 82EDB410: C18A000C  lfs f12, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDB414: 48000008  b 0x82edb41c
	pc = 0x82EDB41C; continue 'dispatch;
            }
            0x82EDB418 => {
    //   block [0x82EDB418..0x82EDB41C)
	// 82EDB418: FD805890  fmr f12, f11
	ctx.f[12].f64 = ctx.f[11].f64;
	pc = 0x82EDB41C; continue 'dispatch;
            }
            0x82EDB41C => {
    //   block [0x82EDB41C..0x82EDB478)
	// 82EDB41C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EDB420: D1BF0028  stfs f13, 0x28(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82EDB424: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EDB428: D1BF002C  stfs f13, 0x2c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EDB42C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82EDB430: D17F0030  stfs f11, 0x30(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EDB434: C0090A7C  lfs f0, 0xa7c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDB438: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EDB43C: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDB440: D19F001C  stfs f12, 0x1c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EDB444: 995F0020  stb r10, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[10].u8 ) };
	// 82EDB448: 911F0034  stw r8, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[8].u32 ) };
	// 82EDB44C: 995F0038  stb r10, 0x38(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u8 ) };
	// 82EDB450: C0090C18  lfs f0, 0xc18(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDB454: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EDB458: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EDB45C: C18989CC  lfs f12, -0x7634(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-30260 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDB460: D19F003C  stfs f12, 0x3c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82EDB464: 812B0718  lwz r9, 0x718(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDB468: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDB46C: 4182000C  beq 0x82edb478
	if ctx.cr[0].eq {
	pc = 0x82EDB478; continue 'dispatch;
	}
	// 82EDB470: C1A9000C  lfs f13, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDB474: 48000008  b 0x82edb47c
	pc = 0x82EDB47C; continue 'dispatch;
            }
            0x82EDB478 => {
    //   block [0x82EDB478..0x82EDB47C)
	// 82EDB478: FDA05890  fmr f13, f11
	ctx.f[13].f64 = ctx.f[11].f64;
	pc = 0x82EDB47C; continue 'dispatch;
            }
            0x82EDB47C => {
    //   block [0x82EDB47C..0x82EDB498)
	// 82EDB47C: EDAD02B2  fmuls f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EDB480: D1BF0040  stfs f13, 0x40(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82EDB484: 812B0718  lwz r9, 0x718(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDB488: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDB48C: 4182000C  beq 0x82edb498
	if ctx.cr[0].eq {
	pc = 0x82EDB498; continue 'dispatch;
	}
	// 82EDB490: C189000C  lfs f12, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDB494: 48000008  b 0x82edb49c
	pc = 0x82EDB49C; continue 'dispatch;
            }
            0x82EDB498 => {
    //   block [0x82EDB498..0x82EDB49C)
	// 82EDB498: FD805890  fmr f12, f11
	ctx.f[12].f64 = ctx.f[11].f64;
	pc = 0x82EDB49C; continue 'dispatch;
            }
            0x82EDB49C => {
    //   block [0x82EDB49C..0x82EDB4CC)
	// 82EDB49C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EDB4A0: C1A90A98  lfs f13, 0xa98(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2712 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDB4A4: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EDB4A8: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EDB4AC: D1BF0044  stfs f13, 0x44(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82EDB4B0: C1A9BDF4  lfs f13, -0x420c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16908 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDB4B4: D1BF0048  stfs f13, 0x48(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82EDB4B8: 812B0718  lwz r9, 0x718(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDB4BC: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDB4C0: 4182000C  beq 0x82edb4cc
	if ctx.cr[0].eq {
	pc = 0x82EDB4CC; continue 'dispatch;
	}
	// 82EDB4C4: C189000C  lfs f12, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDB4C8: 48000008  b 0x82edb4d0
	pc = 0x82EDB4D0; continue 'dispatch;
            }
            0x82EDB4CC => {
    //   block [0x82EDB4CC..0x82EDB4D0)
	// 82EDB4CC: FD805890  fmr f12, f11
	ctx.f[12].f64 = ctx.f[11].f64;
	pc = 0x82EDB4D0; continue 'dispatch;
            }
            0x82EDB4D0 => {
    //   block [0x82EDB4D0..0x82EDB55C)
	// 82EDB4D0: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EDB4D4: D17F0050  stfs f11, 0x50(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EDB4D8: D19F004C  stfs f12, 0x4c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82EDB4DC: 915F005C  stw r10, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82EDB4E0: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDB4E4: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EDB4E8: 3929AFB4  addi r9, r9, -0x504c
	ctx.r[9].s64 = ctx.r[9].s64 + -20556;
	// 82EDB4EC: 81080014  lwz r8, 0x14(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EDB4F0: 911F0060  stw r8, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 82EDB4F4: D01F0064  stfs f0, 0x64(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EDB4F8: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EDB4FC: D01F006C  stfs f0, 0x6c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82EDB500: D01F007C  stfs f0, 0x7c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82EDB504: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EDB508: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EDB50C: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EDB510: D01F008C  stfs f0, 0x8c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EDB514: D01F0090  stfs f0, 0x90(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82EDB518: D01F0098  stfs f0, 0x98(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82EDB51C: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82EDB520: D01F00A0  stfs f0, 0xa0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82EDB524: D01F00A4  stfs f0, 0xa4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82EDB528: D01F00A8  stfs f0, 0xa8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82EDB52C: D01F00AC  stfs f0, 0xac(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82EDB530: D01F00B0  stfs f0, 0xb0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82EDB534: D01F00B4  stfs f0, 0xb4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82EDB538: D01F00B8  stfs f0, 0xb8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82EDB53C: 915F00CC  stw r10, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[10].u32 ) };
	// 82EDB540: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 82EDB544: 915F00E8  stw r10, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[10].u32 ) };
	// 82EDB548: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDB54C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDB550: 4182000C  beq 0x82edb55c
	if ctx.cr[0].eq {
	pc = 0x82EDB55C; continue 'dispatch;
	}
	// 82EDB554: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDB558: 48000008  b 0x82edb560
	pc = 0x82EDB560; continue 'dispatch;
            }
            0x82EDB55C => {
    //   block [0x82EDB55C..0x82EDB560)
	// 82EDB55C: FD805890  fmr f12, f11
	ctx.f[12].f64 = ctx.f[11].f64;
	pc = 0x82EDB560; continue 'dispatch;
            }
            0x82EDB560 => {
    //   block [0x82EDB560..0x82EDB5B0)
	// 82EDB560: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EDB564: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDB568: D01F00FC  stfs f0, 0xfc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82EDB56C: 915F0108  stw r10, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[10].u32 ) };
	// 82EDB570: D01F0100  stfs f0, 0x100(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82EDB574: 3BCBBC48  addi r30, r11, -0x43b8
	ctx.r[30].s64 = ctx.r[11].s64 + -17336;
	// 82EDB578: EC0B6824  fdivs f0, f11, f13
	ctx.f[0].f64 = ((ctx.f[11].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EDB57C: D01F00F8  stfs f0, 0xf8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82EDB580: 4B385439  bl 0x822609b8
	ctx.lr = 0x82EDB584;
	sub_822609B8(ctx, base);
	// 82EDB584: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EDB588: 4BFA5CB1  bl 0x82e81238
	ctx.lr = 0x82EDB58C;
	sub_82E81238(ctx, base);
	// 82EDB58C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EDB590: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDB594: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EDB598: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EDB59C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EDB5A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EDB5A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EDB5A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EDB5AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDB5B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EDB5B0 size=88
    let mut pc: u32 = 0x82EDB5B0;
    'dispatch: loop {
        match pc {
            0x82EDB5B0 => {
    //   block [0x82EDB5B0..0x82EDB5EC)
	// 82EDB5B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDB5B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EDB5B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EDB5BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EDB5C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDB5C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDB5C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EDB5CC: 4BFFFC85  bl 0x82edb250
	ctx.lr = 0x82EDB5D0;
	sub_82EDB250(ctx, base);
	// 82EDB5D0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDB5D4: 41820018  beq 0x82edb5ec
	if ctx.cr[0].eq {
	pc = 0x82EDB5EC; continue 'dispatch;
	}
	// 82EDB5D8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EDB5DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDB5E0: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EDB5E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDB5E8: 4E800421  bctrl
	ctx.lr = 0x82EDB5EC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EDB5EC => {
    //   block [0x82EDB5EC..0x82EDB608)
	// 82EDB5EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDB5F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EDB5F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EDB5F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EDB5FC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EDB600: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EDB604: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDB608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EDB608 size=2076
    let mut pc: u32 = 0x82EDB608;
    'dispatch: loop {
        match pc {
            0x82EDB608 => {
    //   block [0x82EDB608..0x82EDB664)
	// 82EDB608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDB60C: 4BDCDDFD  bl 0x82ca9408
	ctx.lr = 0x82EDB610;
	sub_82CA93D0(ctx, base);
	// 82EDB610: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82EDB614: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82EDB618: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDB61C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EDB620: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EDB624: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDB628: 482E0A39  bl 0x831bc060
	ctx.lr = 0x82EDB62C;
	sub_831BC060(ctx, base);
	// 82EDB62C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EDB630: 418207D8  beq 0x82edbe08
	if ctx.cr[0].eq {
	pc = 0x82EDBE08; continue 'dispatch;
	}
	// 82EDB634: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDB638: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDB63C: 388BBC30  addi r4, r11, -0x43d0
	ctx.r[4].s64 = ctx.r[11].s64 + -17360;
	// 82EDB640: 4BDD1511  bl 0x82cacb50
	ctx.lr = 0x82EDB644;
	sub_82CACB50(ctx, base);
	// 82EDB644: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDB648: 408200A0  bne 0x82edb6e8
	if !ctx.cr[0].eq {
	pc = 0x82EDB6E8; continue 'dispatch;
	}
	// 82EDB64C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDB650: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDB654: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDB658: 4182000C  beq 0x82edb664
	if ctx.cr[0].eq {
	pc = 0x82EDB664; continue 'dispatch;
	}
	// 82EDB65C: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EDB660: 4800000C  b 0x82edb66c
	pc = 0x82EDB66C; continue 'dispatch;
            }
            0x82EDB664 => {
    //   block [0x82EDB664..0x82EDB66C)
	// 82EDB664: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDB668: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EDB66C; continue 'dispatch;
            }
            0x82EDB66C => {
    //   block [0x82EDB66C..0x82EDB6D4)
	// 82EDB66C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDB670: 4BA32699  bl 0x8290dd08
	ctx.lr = 0x82EDB674;
	sub_8290DD08(ctx, base);
	// 82EDB674: 4BDD053D  bl 0x82cabbb0
	ctx.lr = 0x82EDB678;
	sub_82CABBB0(ctx, base);
	// 82EDB678: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDB67C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDB680: EFE007F2  fmuls f31, f0, f31
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EDB684: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDB688: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82EDB68C: 40990054  ble cr6, 0x82edb6e0
	if !ctx.cr[6].gt {
	pc = 0x82EDB6E0; continue 'dispatch;
	}
	// 82EDB690: 807C0060  lwz r3, 0x60(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EDB694: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDB698: 41820044  beq 0x82edb6dc
	if ctx.cr[0].eq {
	pc = 0x82EDB6DC; continue 'dispatch;
	}
	// 82EDB69C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDB6A0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EDB6A4: 3BEBC5C8  addi r31, r11, -0x3a38
	ctx.r[31].s64 = ctx.r[11].s64 + -14904;
	// 82EDB6A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDB6AC: 4B30CFCD  bl 0x821e8678
	ctx.lr = 0x82EDB6B0;
	sub_821E8678(ctx, base);
	// 82EDB6B0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDB6B4: 41820028  beq 0x82edb6dc
	if ctx.cr[0].eq {
	pc = 0x82EDB6DC; continue 'dispatch;
	}
	// 82EDB6B8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EDB6BC: 807C0060  lwz r3, 0x60(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EDB6C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDB6C4: 4B30CFB5  bl 0x821e8678
	ctx.lr = 0x82EDB6C8;
	sub_821E8678(ctx, base);
	// 82EDB6C8: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDB6CC: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82EDB6D0: 4199000C  bgt cr6, 0x82edb6dc
	if ctx.cr[6].gt {
	pc = 0x82EDB6DC; continue 'dispatch;
	}
	pc = 0x82EDB6D4; continue 'dispatch;
            }
            0x82EDB6D4 => {
    //   block [0x82EDB6D4..0x82EDB6DC)
	// 82EDB6D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EDB6D8: 4800073C  b 0x82edbe14
	pc = 0x82EDBE14; continue 'dispatch;
            }
            0x82EDB6DC => {
    //   block [0x82EDB6DC..0x82EDB6E0)
	// 82EDB6DC: D3FC0010  stfs f31, 0x10(r28)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(16 as u32), tmp.u32 ) };
	pc = 0x82EDB6E0; continue 'dispatch;
            }
            0x82EDB6E0 => {
    //   block [0x82EDB6E0..0x82EDB6E8)
	// 82EDB6E0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EDB6E4: 48000730  b 0x82edbe14
	pc = 0x82EDBE14; continue 'dispatch;
            }
            0x82EDB6E8 => {
    //   block [0x82EDB6E8..0x82EDB71C)
	// 82EDB6E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDB6EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDB6F0: 388BBD20  addi r4, r11, -0x42e0
	ctx.r[4].s64 = ctx.r[11].s64 + -17120;
	// 82EDB6F4: 4BDD145D  bl 0x82cacb50
	ctx.lr = 0x82EDB6F8;
	sub_82CACB50(ctx, base);
	// 82EDB6F8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDB6FC: 4082003C  bne 0x82edb738
	if !ctx.cr[0].eq {
	pc = 0x82EDB738; continue 'dispatch;
	}
	// 82EDB700: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDB704: 4BA32605  bl 0x8290dd08
	ctx.lr = 0x82EDB708;
	sub_8290DD08(ctx, base);
	// 82EDB708: 4BDD04A9  bl 0x82cabbb0
	ctx.lr = 0x82EDB70C;
	sub_82CABBB0(ctx, base);
	// 82EDB70C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDB710: C01C0048  lfs f0, 0x48(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDB714: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDB718: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EDB71C; continue 'dispatch;
            }
            0x82EDB71C => {
    //   block [0x82EDB71C..0x82EDB728)
	// 82EDB71C: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDB720: 40990008  ble cr6, 0x82edb728
	if !ctx.cr[6].gt {
	pc = 0x82EDB728; continue 'dispatch;
	}
	// 82EDB724: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDB728; continue 'dispatch;
            }
            0x82EDB728 => {
    //   block [0x82EDB728..0x82EDB738)
	// 82EDB728: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDB72C: 409AFFF0  bne cr6, 0x82edb71c
	if !ctx.cr[6].eq {
	pc = 0x82EDB71C; continue 'dispatch;
	}
	// 82EDB730: D01C0048  stfs f0, 0x48(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82EDB734: 4BFFFFAC  b 0x82edb6e0
	pc = 0x82EDB6E0; continue 'dispatch;
            }
            0x82EDB738 => {
    //   block [0x82EDB738..0x82EDB770)
	// 82EDB738: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDB73C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDB740: 388BBC08  addi r4, r11, -0x43f8
	ctx.r[4].s64 = ctx.r[11].s64 + -17400;
	// 82EDB744: 4BDD140D  bl 0x82cacb50
	ctx.lr = 0x82EDB748;
	sub_82CACB50(ctx, base);
	// 82EDB748: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDB74C: 408200AC  bne 0x82edb7f8
	if !ctx.cr[0].eq {
	pc = 0x82EDB7F8; continue 'dispatch;
	}
	// 82EDB750: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDB754: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EDB758: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDB75C: C3CA0C14  lfs f30, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EDB760: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDB764: 4182000C  beq 0x82edb770
	if ctx.cr[0].eq {
	pc = 0x82EDB770; continue 'dispatch;
	}
	// 82EDB768: C3EB000C  lfs f31, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EDB76C: 48000008  b 0x82edb774
	pc = 0x82EDB774; continue 'dispatch;
            }
            0x82EDB770 => {
    //   block [0x82EDB770..0x82EDB774)
	// 82EDB770: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	pc = 0x82EDB774; continue 'dispatch;
            }
            0x82EDB774 => {
    //   block [0x82EDB774..0x82EDB7E8)
	// 82EDB774: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDB778: 4BA32591  bl 0x8290dd08
	ctx.lr = 0x82EDB77C;
	sub_8290DD08(ctx, base);
	// 82EDB77C: 4BDD0435  bl 0x82cabbb0
	ctx.lr = 0x82EDB780;
	sub_82CABBB0(ctx, base);
	// 82EDB780: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDB784: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDB788: EFE007F2  fmuls f31, f0, f31
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EDB78C: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDB790: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82EDB794: 4099FF4C  ble cr6, 0x82edb6e0
	if !ctx.cr[6].gt {
	pc = 0x82EDB6E0; continue 'dispatch;
	}
	// 82EDB798: 807C0060  lwz r3, 0x60(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EDB79C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDB7A0: 41820048  beq 0x82edb7e8
	if ctx.cr[0].eq {
	pc = 0x82EDB7E8; continue 'dispatch;
	}
	// 82EDB7A4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDB7A8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EDB7AC: 3BEBC5C8  addi r31, r11, -0x3a38
	ctx.r[31].s64 = ctx.r[11].s64 + -14904;
	// 82EDB7B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDB7B4: 4B30CEC5  bl 0x821e8678
	ctx.lr = 0x82EDB7B8;
	sub_821E8678(ctx, base);
	// 82EDB7B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDB7BC: 4182002C  beq 0x82edb7e8
	if ctx.cr[0].eq {
	pc = 0x82EDB7E8; continue 'dispatch;
	}
	// 82EDB7C0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EDB7C4: 807C0060  lwz r3, 0x60(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EDB7C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDB7CC: 4B30CEAD  bl 0x821e8678
	ctx.lr = 0x82EDB7D0;
	sub_821E8678(ctx, base);
	// 82EDB7D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDB7D4: C1A30004  lfs f13, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDB7D8: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDB7DC: EC1F0032  fmuls f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDB7E0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EDB7E4: 4099FEF0  ble cr6, 0x82edb6d4
	if !ctx.cr[6].gt {
	pc = 0x82EDB6D4; continue 'dispatch;
	}
	pc = 0x82EDB7E8; continue 'dispatch;
            }
            0x82EDB7E8 => {
    //   block [0x82EDB7E8..0x82EDB7F8)
	// 82EDB7E8: EC1EF824  fdivs f0, f30, f31
	ctx.f[0].f64 = ((ctx.f[30].f64 / ctx.f[31].f64) as f32) as f64;
	// 82EDB7EC: D3FC004C  stfs f31, 0x4c(r28)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82EDB7F0: D01C00F8  stfs f0, 0xf8(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82EDB7F4: 4BFFFEEC  b 0x82edb6e0
	pc = 0x82EDB6E0; continue 'dispatch;
            }
            0x82EDB7F8 => {
    //   block [0x82EDB7F8..0x82EDB82C)
	// 82EDB7F8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDB7FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDB800: 388BBBF0  addi r4, r11, -0x4410
	ctx.r[4].s64 = ctx.r[11].s64 + -17424;
	// 82EDB804: 4BDD134D  bl 0x82cacb50
	ctx.lr = 0x82EDB808;
	sub_82CACB50(ctx, base);
	// 82EDB808: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDB80C: 4082003C  bne 0x82edb848
	if !ctx.cr[0].eq {
	pc = 0x82EDB848; continue 'dispatch;
	}
	// 82EDB810: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDB814: 4BA324F5  bl 0x8290dd08
	ctx.lr = 0x82EDB818;
	sub_8290DD08(ctx, base);
	// 82EDB818: 4BDD0399  bl 0x82cabbb0
	ctx.lr = 0x82EDB81C;
	sub_82CABBB0(ctx, base);
	// 82EDB81C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDB820: C01C0014  lfs f0, 0x14(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDB824: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDB828: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EDB82C; continue 'dispatch;
            }
            0x82EDB82C => {
    //   block [0x82EDB82C..0x82EDB838)
	// 82EDB82C: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDB830: 41980008  blt cr6, 0x82edb838
	if ctx.cr[6].lt {
	pc = 0x82EDB838; continue 'dispatch;
	}
	// 82EDB834: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDB838; continue 'dispatch;
            }
            0x82EDB838 => {
    //   block [0x82EDB838..0x82EDB848)
	// 82EDB838: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDB83C: 409AFFF0  bne cr6, 0x82edb82c
	if !ctx.cr[6].eq {
	pc = 0x82EDB82C; continue 'dispatch;
	}
	// 82EDB840: D01C0014  stfs f0, 0x14(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EDB844: 4BFFFE9C  b 0x82edb6e0
	pc = 0x82EDB6E0; continue 'dispatch;
            }
            0x82EDB848 => {
    //   block [0x82EDB848..0x82EDB878)
	// 82EDB848: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDB84C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDB850: 388BBBDC  addi r4, r11, -0x4424
	ctx.r[4].s64 = ctx.r[11].s64 + -17444;
	// 82EDB854: 4BDD12FD  bl 0x82cacb50
	ctx.lr = 0x82EDB858;
	sub_82CACB50(ctx, base);
	// 82EDB858: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDB85C: 40820060  bne 0x82edb8bc
	if !ctx.cr[0].eq {
	pc = 0x82EDB8BC; continue 'dispatch;
	}
	// 82EDB860: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDB864: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDB868: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDB86C: 4182000C  beq 0x82edb878
	if ctx.cr[0].eq {
	pc = 0x82EDB878; continue 'dispatch;
	}
	// 82EDB870: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EDB874: 4800000C  b 0x82edb880
	pc = 0x82EDB880; continue 'dispatch;
            }
            0x82EDB878 => {
    //   block [0x82EDB878..0x82EDB880)
	// 82EDB878: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDB87C: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EDB880; continue 'dispatch;
            }
            0x82EDB880 => {
    //   block [0x82EDB880..0x82EDB8A0)
	// 82EDB880: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDB884: 4BA32485  bl 0x8290dd08
	ctx.lr = 0x82EDB888;
	sub_8290DD08(ctx, base);
	// 82EDB888: 4BDD0329  bl 0x82cabbb0
	ctx.lr = 0x82EDB88C;
	sub_82CABBB0(ctx, base);
	// 82EDB88C: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDB890: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDB894: C01C0018  lfs f0, 0x18(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDB898: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDB89C: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	pc = 0x82EDB8A0; continue 'dispatch;
            }
            0x82EDB8A0 => {
    //   block [0x82EDB8A0..0x82EDB8AC)
	// 82EDB8A0: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDB8A4: 40990008  ble cr6, 0x82edb8ac
	if !ctx.cr[6].gt {
	pc = 0x82EDB8AC; continue 'dispatch;
	}
	// 82EDB8A8: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDB8AC; continue 'dispatch;
            }
            0x82EDB8AC => {
    //   block [0x82EDB8AC..0x82EDB8BC)
	// 82EDB8AC: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDB8B0: 409AFFF0  bne cr6, 0x82edb8a0
	if !ctx.cr[6].eq {
	pc = 0x82EDB8A0; continue 'dispatch;
	}
	// 82EDB8B4: D01C0018  stfs f0, 0x18(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EDB8B8: 4BFFFE28  b 0x82edb6e0
	pc = 0x82EDB6E0; continue 'dispatch;
            }
            0x82EDB8BC => {
    //   block [0x82EDB8BC..0x82EDB8EC)
	// 82EDB8BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDB8C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDB8C4: 388BAF10  addi r4, r11, -0x50f0
	ctx.r[4].s64 = ctx.r[11].s64 + -20720;
	// 82EDB8C8: 4BDD1289  bl 0x82cacb50
	ctx.lr = 0x82EDB8CC;
	sub_82CACB50(ctx, base);
	// 82EDB8CC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDB8D0: 40820060  bne 0x82edb930
	if !ctx.cr[0].eq {
	pc = 0x82EDB930; continue 'dispatch;
	}
	// 82EDB8D4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDB8D8: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDB8DC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDB8E0: 4182000C  beq 0x82edb8ec
	if ctx.cr[0].eq {
	pc = 0x82EDB8EC; continue 'dispatch;
	}
	// 82EDB8E4: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EDB8E8: 4800000C  b 0x82edb8f4
	pc = 0x82EDB8F4; continue 'dispatch;
            }
            0x82EDB8EC => {
    //   block [0x82EDB8EC..0x82EDB8F4)
	// 82EDB8EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDB8F0: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EDB8F4; continue 'dispatch;
            }
            0x82EDB8F4 => {
    //   block [0x82EDB8F4..0x82EDB914)
	// 82EDB8F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDB8F8: 4BA32411  bl 0x8290dd08
	ctx.lr = 0x82EDB8FC;
	sub_8290DD08(ctx, base);
	// 82EDB8FC: 4BDD02B5  bl 0x82cabbb0
	ctx.lr = 0x82EDB900;
	sub_82CABBB0(ctx, base);
	// 82EDB900: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDB904: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDB908: C01C001C  lfs f0, 0x1c(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDB90C: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDB910: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	pc = 0x82EDB914; continue 'dispatch;
            }
            0x82EDB914 => {
    //   block [0x82EDB914..0x82EDB920)
	// 82EDB914: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDB918: 41980008  blt cr6, 0x82edb920
	if ctx.cr[6].lt {
	pc = 0x82EDB920; continue 'dispatch;
	}
	// 82EDB91C: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDB920; continue 'dispatch;
            }
            0x82EDB920 => {
    //   block [0x82EDB920..0x82EDB930)
	// 82EDB920: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDB924: 409AFFF0  bne cr6, 0x82edb914
	if !ctx.cr[6].eq {
	pc = 0x82EDB914; continue 'dispatch;
	}
	// 82EDB928: D01C001C  stfs f0, 0x1c(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EDB92C: 4BFFFDB4  b 0x82edb6e0
	pc = 0x82EDB6E0; continue 'dispatch;
            }
            0x82EDB930 => {
    //   block [0x82EDB930..0x82EDBA24)
	// 82EDB930: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDB934: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDB938: 3BCBBBCC  addi r30, r11, -0x4434
	ctx.r[30].s64 = ctx.r[11].s64 + -17460;
	// 82EDB93C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EDB940: 4BDD1211  bl 0x82cacb50
	ctx.lr = 0x82EDB944;
	sub_82CACB50(ctx, base);
	// 82EDB944: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDB948: 408200F0  bne 0x82edba38
	if !ctx.cr[0].eq {
	pc = 0x82EDBA38; continue 'dispatch;
	}
	// 82EDB94C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDB950: 482E0711  bl 0x831bc060
	ctx.lr = 0x82EDB954;
	sub_831BC060(ctx, base);
	// 82EDB954: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EDB958: 4BDD11F9  bl 0x82cacb50
	ctx.lr = 0x82EDB95C;
	sub_82CACB50(ctx, base);
	// 82EDB95C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDB960: 408200D8  bne 0x82edba38
	if !ctx.cr[0].eq {
	pc = 0x82EDBA38; continue 'dispatch;
	}
	// 82EDB964: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EDB968: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDB96C: 3BEB1694  addi r31, r11, 0x1694
	ctx.r[31].s64 = ctx.r[11].s64 + 5780;
	// 82EDB970: 4BA32399  bl 0x8290dd08
	ctx.lr = 0x82EDB974;
	sub_8290DD08(ctx, base);
	// 82EDB974: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDB978: 4BDD11D9  bl 0x82cacb50
	ctx.lr = 0x82EDB97C;
	sub_82CACB50(ctx, base);
	// 82EDB97C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDB980: 418200AC  beq 0x82edba2c
	if ctx.cr[0].eq {
	pc = 0x82EDBA2C; continue 'dispatch;
	}
	// 82EDB984: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDB988: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDB98C: 3BEB0F40  addi r31, r11, 0xf40
	ctx.r[31].s64 = ctx.r[11].s64 + 3904;
	// 82EDB990: 4BA32379  bl 0x8290dd08
	ctx.lr = 0x82EDB994;
	sub_8290DD08(ctx, base);
	// 82EDB994: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDB998: 4BDD11B9  bl 0x82cacb50
	ctx.lr = 0x82EDB99C;
	sub_82CACB50(ctx, base);
	// 82EDB99C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDB9A0: 4182008C  beq 0x82edba2c
	if ctx.cr[0].eq {
	pc = 0x82EDBA2C; continue 'dispatch;
	}
	// 82EDB9A4: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82EDB9A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDB9AC: 3BEBD56C  addi r31, r11, -0x2a94
	ctx.r[31].s64 = ctx.r[11].s64 + -10900;
	// 82EDB9B0: 4BA32359  bl 0x8290dd08
	ctx.lr = 0x82EDB9B4;
	sub_8290DD08(ctx, base);
	// 82EDB9B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDB9B8: 4BDD1199  bl 0x82cacb50
	ctx.lr = 0x82EDB9BC;
	sub_82CACB50(ctx, base);
	// 82EDB9BC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDB9C0: 4182006C  beq 0x82edba2c
	if ctx.cr[0].eq {
	pc = 0x82EDBA2C; continue 'dispatch;
	}
	// 82EDB9C4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EDB9C8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDB9CC: 3BEB1698  addi r31, r11, 0x1698
	ctx.r[31].s64 = ctx.r[11].s64 + 5784;
	// 82EDB9D0: 4BA32339  bl 0x8290dd08
	ctx.lr = 0x82EDB9D4;
	sub_8290DD08(ctx, base);
	// 82EDB9D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDB9D8: 4BDD1179  bl 0x82cacb50
	ctx.lr = 0x82EDB9DC;
	sub_82CACB50(ctx, base);
	// 82EDB9DC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDB9E0: 41820044  beq 0x82edba24
	if ctx.cr[0].eq {
	pc = 0x82EDBA24; continue 'dispatch;
	}
	// 82EDB9E4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EDB9E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDB9EC: 3BEB1700  addi r31, r11, 0x1700
	ctx.r[31].s64 = ctx.r[11].s64 + 5888;
	// 82EDB9F0: 4BA32319  bl 0x8290dd08
	ctx.lr = 0x82EDB9F4;
	sub_8290DD08(ctx, base);
	// 82EDB9F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDB9F8: 4BDD1159  bl 0x82cacb50
	ctx.lr = 0x82EDB9FC;
	sub_82CACB50(ctx, base);
	// 82EDB9FC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDBA00: 41820024  beq 0x82edba24
	if ctx.cr[0].eq {
	pc = 0x82EDBA24; continue 'dispatch;
	}
	// 82EDBA04: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EDBA08: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDBA0C: 3BEB7088  addi r31, r11, 0x7088
	ctx.r[31].s64 = ctx.r[11].s64 + 28808;
	// 82EDBA10: 4BA322F9  bl 0x8290dd08
	ctx.lr = 0x82EDBA14;
	sub_8290DD08(ctx, base);
	// 82EDBA14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDBA18: 4BDD1139  bl 0x82cacb50
	ctx.lr = 0x82EDBA1C;
	sub_82CACB50(ctx, base);
	// 82EDBA1C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDBA20: 4082FCB4  bne 0x82edb6d4
	if !ctx.cr[0].eq {
	pc = 0x82EDB6D4; continue 'dispatch;
	}
	pc = 0x82EDBA24; continue 'dispatch;
            }
            0x82EDBA24 => {
    //   block [0x82EDBA24..0x82EDBA2C)
	// 82EDBA24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EDBA28: 48000008  b 0x82edba30
	pc = 0x82EDBA30; continue 'dispatch;
            }
            0x82EDBA2C => {
    //   block [0x82EDBA2C..0x82EDBA30)
	// 82EDBA2C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82EDBA30; continue 'dispatch;
            }
            0x82EDBA30 => {
    //   block [0x82EDBA30..0x82EDBA38)
	// 82EDBA30: 997C0020  stb r11, 0x20(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(32 as u32), ctx.r[11].u8 ) };
	// 82EDBA34: 4BFFFCAC  b 0x82edb6e0
	pc = 0x82EDB6E0; continue 'dispatch;
            }
            0x82EDBA38 => {
    //   block [0x82EDBA38..0x82EDBA88)
	// 82EDBA38: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDBA3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDBA40: 388BBD0C  addi r4, r11, -0x42f4
	ctx.r[4].s64 = ctx.r[11].s64 + -17140;
	// 82EDBA44: 4BDD110D  bl 0x82cacb50
	ctx.lr = 0x82EDBA48;
	sub_82CACB50(ctx, base);
	// 82EDBA48: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDBA4C: 4082003C  bne 0x82edba88
	if !ctx.cr[0].eq {
	pc = 0x82EDBA88; continue 'dispatch;
	}
	// 82EDBA50: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDBA54: 4BA322B5  bl 0x8290dd08
	ctx.lr = 0x82EDBA58;
	sub_8290DD08(ctx, base);
	// 82EDBA58: 4BDD0159  bl 0x82cabbb0
	ctx.lr = 0x82EDBA5C;
	sub_82CABBB0(ctx, base);
	// 82EDBA5C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDBA60: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDBA64: C1AB0C18  lfs f13, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDBA68: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EDBA6C: 4198FC74  blt cr6, 0x82edb6e0
	if ctx.cr[6].lt {
	pc = 0x82EDB6E0; continue 'dispatch;
	}
	// 82EDBA70: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDBA74: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDBA78: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EDBA7C: 4098FC64  bge cr6, 0x82edb6e0
	if !ctx.cr[6].lt {
	pc = 0x82EDB6E0; continue 'dispatch;
	}
	// 82EDBA80: D01C0024  stfs f0, 0x24(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EDBA84: 4BFFFC5C  b 0x82edb6e0
	pc = 0x82EDB6E0; continue 'dispatch;
            }
            0x82EDBA88 => {
    //   block [0x82EDBA88..0x82EDBABC)
	// 82EDBA88: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDBA8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDBA90: 388BBBC0  addi r4, r11, -0x4440
	ctx.r[4].s64 = ctx.r[11].s64 + -17472;
	// 82EDBA94: 4BDD10BD  bl 0x82cacb50
	ctx.lr = 0x82EDBA98;
	sub_82CACB50(ctx, base);
	// 82EDBA98: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDBA9C: 40820020  bne 0x82edbabc
	if !ctx.cr[0].eq {
	pc = 0x82EDBABC; continue 'dispatch;
	}
	// 82EDBAA0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDBAA4: 4BA32265  bl 0x8290dd08
	ctx.lr = 0x82EDBAA8;
	sub_8290DD08(ctx, base);
	// 82EDBAA8: 4BDD0109  bl 0x82cabbb0
	ctx.lr = 0x82EDBAAC;
	sub_82CABBB0(ctx, base);
	// 82EDBAAC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EDBAB0: FC200818  frsp f1, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDBAB4: 4BFFF865  bl 0x82edb318
	ctx.lr = 0x82EDBAB8;
	sub_82EDB318(ctx, base);
	// 82EDBAB8: 4BFFFC28  b 0x82edb6e0
	pc = 0x82EDB6E0; continue 'dispatch;
            }
            0x82EDBABC => {
    //   block [0x82EDBABC..0x82EDBAF0)
	// 82EDBABC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDBAC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDBAC4: 388BBBB0  addi r4, r11, -0x4450
	ctx.r[4].s64 = ctx.r[11].s64 + -17488;
	// 82EDBAC8: 4BDD1089  bl 0x82cacb50
	ctx.lr = 0x82EDBACC;
	sub_82CACB50(ctx, base);
	// 82EDBACC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDBAD0: 4082003C  bne 0x82edbb0c
	if !ctx.cr[0].eq {
	pc = 0x82EDBB0C; continue 'dispatch;
	}
	// 82EDBAD4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDBAD8: 4BA32231  bl 0x8290dd08
	ctx.lr = 0x82EDBADC;
	sub_8290DD08(ctx, base);
	// 82EDBADC: 4BDD00D5  bl 0x82cabbb0
	ctx.lr = 0x82EDBAE0;
	sub_82CABBB0(ctx, base);
	// 82EDBAE0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDBAE4: C01C0028  lfs f0, 0x28(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDBAE8: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDBAEC: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EDBAF0; continue 'dispatch;
            }
            0x82EDBAF0 => {
    //   block [0x82EDBAF0..0x82EDBAFC)
	// 82EDBAF0: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDBAF4: 41980008  blt cr6, 0x82edbafc
	if ctx.cr[6].lt {
	pc = 0x82EDBAFC; continue 'dispatch;
	}
	// 82EDBAF8: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDBAFC; continue 'dispatch;
            }
            0x82EDBAFC => {
    //   block [0x82EDBAFC..0x82EDBB0C)
	// 82EDBAFC: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDBB00: 409AFFF0  bne cr6, 0x82edbaf0
	if !ctx.cr[6].eq {
	pc = 0x82EDBAF0; continue 'dispatch;
	}
	// 82EDBB04: D01C0028  stfs f0, 0x28(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82EDBB08: 4BFFFBD8  b 0x82edb6e0
	pc = 0x82EDB6E0; continue 'dispatch;
            }
            0x82EDBB0C => {
    //   block [0x82EDBB0C..0x82EDBB40)
	// 82EDBB0C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDBB10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDBB14: 388BBBA0  addi r4, r11, -0x4460
	ctx.r[4].s64 = ctx.r[11].s64 + -17504;
	// 82EDBB18: 4BDD1039  bl 0x82cacb50
	ctx.lr = 0x82EDBB1C;
	sub_82CACB50(ctx, base);
	// 82EDBB1C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDBB20: 4082003C  bne 0x82edbb5c
	if !ctx.cr[0].eq {
	pc = 0x82EDBB5C; continue 'dispatch;
	}
	// 82EDBB24: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDBB28: 4BA321E1  bl 0x8290dd08
	ctx.lr = 0x82EDBB2C;
	sub_8290DD08(ctx, base);
	// 82EDBB2C: 4BDD0085  bl 0x82cabbb0
	ctx.lr = 0x82EDBB30;
	sub_82CABBB0(ctx, base);
	// 82EDBB30: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDBB34: C01C002C  lfs f0, 0x2c(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDBB38: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDBB3C: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EDBB40; continue 'dispatch;
            }
            0x82EDBB40 => {
    //   block [0x82EDBB40..0x82EDBB4C)
	// 82EDBB40: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDBB44: 41980008  blt cr6, 0x82edbb4c
	if ctx.cr[6].lt {
	pc = 0x82EDBB4C; continue 'dispatch;
	}
	// 82EDBB48: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDBB4C; continue 'dispatch;
            }
            0x82EDBB4C => {
    //   block [0x82EDBB4C..0x82EDBB5C)
	// 82EDBB4C: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDBB50: 409AFFF0  bne cr6, 0x82edbb40
	if !ctx.cr[6].eq {
	pc = 0x82EDBB40; continue 'dispatch;
	}
	// 82EDBB54: D01C002C  stfs f0, 0x2c(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EDBB58: 4BFFFB88  b 0x82edb6e0
	pc = 0x82EDB6E0; continue 'dispatch;
            }
            0x82EDBB5C => {
    //   block [0x82EDBB5C..0x82EDBB90)
	// 82EDBB5C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDBB60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDBB64: 388BBB94  addi r4, r11, -0x446c
	ctx.r[4].s64 = ctx.r[11].s64 + -17516;
	// 82EDBB68: 4BDD0FE9  bl 0x82cacb50
	ctx.lr = 0x82EDBB6C;
	sub_82CACB50(ctx, base);
	// 82EDBB6C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDBB70: 4082003C  bne 0x82edbbac
	if !ctx.cr[0].eq {
	pc = 0x82EDBBAC; continue 'dispatch;
	}
	// 82EDBB74: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDBB78: 4BA32191  bl 0x8290dd08
	ctx.lr = 0x82EDBB7C;
	sub_8290DD08(ctx, base);
	// 82EDBB7C: 4BDD0035  bl 0x82cabbb0
	ctx.lr = 0x82EDBB80;
	sub_82CABBB0(ctx, base);
	// 82EDBB80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDBB84: C01C0030  lfs f0, 0x30(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDBB88: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDBB8C: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EDBB90; continue 'dispatch;
            }
            0x82EDBB90 => {
    //   block [0x82EDBB90..0x82EDBB9C)
	// 82EDBB90: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDBB94: 41980008  blt cr6, 0x82edbb9c
	if ctx.cr[6].lt {
	pc = 0x82EDBB9C; continue 'dispatch;
	}
	// 82EDBB98: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDBB9C; continue 'dispatch;
            }
            0x82EDBB9C => {
    //   block [0x82EDBB9C..0x82EDBBAC)
	// 82EDBB9C: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDBBA0: 409AFFF0  bne cr6, 0x82edbb90
	if !ctx.cr[6].eq {
	pc = 0x82EDBB90; continue 'dispatch;
	}
	// 82EDBBA4: D01C0030  stfs f0, 0x30(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EDBBA8: 4BFFFB38  b 0x82edb6e0
	pc = 0x82EDB6E0; continue 'dispatch;
            }
            0x82EDBBAC => {
    //   block [0x82EDBBAC..0x82EDBBE0)
	// 82EDBBAC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDBBB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDBBB4: 388BBB78  addi r4, r11, -0x4488
	ctx.r[4].s64 = ctx.r[11].s64 + -17544;
	// 82EDBBB8: 4BDD0F99  bl 0x82cacb50
	ctx.lr = 0x82EDBBBC;
	sub_82CACB50(ctx, base);
	// 82EDBBBC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDBBC0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDBBC4: 4082001C  bne 0x82edbbe0
	if !ctx.cr[0].eq {
	pc = 0x82EDBBE0; continue 'dispatch;
	}
	// 82EDBBC8: 4BA32141  bl 0x8290dd08
	ctx.lr = 0x82EDBBCC;
	sub_8290DD08(ctx, base);
	// 82EDBBCC: 4BDCE7F5  bl 0x82caa3c0
	ctx.lr = 0x82EDBBD0;
	sub_82CAA3C0(ctx, base);
	// 82EDBBD0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDBBD4: 4180FB0C  blt 0x82edb6e0
	if ctx.cr[0].lt {
	pc = 0x82EDB6E0; continue 'dispatch;
	}
	// 82EDBBD8: 907C0034  stw r3, 0x34(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(52 as u32), ctx.r[3].u32 ) };
	// 82EDBBDC: 4BFFFB04  b 0x82edb6e0
	pc = 0x82EDB6E0; continue 'dispatch;
            }
            0x82EDBBE0 => {
    //   block [0x82EDBBE0..0x82EDBCBC)
	// 82EDBBE0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDBBE4: 3BCBBD00  addi r30, r11, -0x4300
	ctx.r[30].s64 = ctx.r[11].s64 + -17152;
	// 82EDBBE8: 482E0479  bl 0x831bc060
	ctx.lr = 0x82EDBBEC;
	sub_831BC060(ctx, base);
	// 82EDBBEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EDBBF0: 4BDD0F61  bl 0x82cacb50
	ctx.lr = 0x82EDBBF4;
	sub_82CACB50(ctx, base);
	// 82EDBBF4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDBBF8: 408200D8  bne 0x82edbcd0
	if !ctx.cr[0].eq {
	pc = 0x82EDBCD0; continue 'dispatch;
	}
	// 82EDBBFC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EDBC00: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDBC04: 3BEB1694  addi r31, r11, 0x1694
	ctx.r[31].s64 = ctx.r[11].s64 + 5780;
	// 82EDBC08: 4BA32101  bl 0x8290dd08
	ctx.lr = 0x82EDBC0C;
	sub_8290DD08(ctx, base);
	// 82EDBC0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDBC10: 4BDD0F41  bl 0x82cacb50
	ctx.lr = 0x82EDBC14;
	sub_82CACB50(ctx, base);
	// 82EDBC14: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDBC18: 418200AC  beq 0x82edbcc4
	if ctx.cr[0].eq {
	pc = 0x82EDBCC4; continue 'dispatch;
	}
	// 82EDBC1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDBC20: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDBC24: 3BEB0F40  addi r31, r11, 0xf40
	ctx.r[31].s64 = ctx.r[11].s64 + 3904;
	// 82EDBC28: 4BA320E1  bl 0x8290dd08
	ctx.lr = 0x82EDBC2C;
	sub_8290DD08(ctx, base);
	// 82EDBC2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDBC30: 4BDD0F21  bl 0x82cacb50
	ctx.lr = 0x82EDBC34;
	sub_82CACB50(ctx, base);
	// 82EDBC34: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDBC38: 4182008C  beq 0x82edbcc4
	if ctx.cr[0].eq {
	pc = 0x82EDBCC4; continue 'dispatch;
	}
	// 82EDBC3C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82EDBC40: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDBC44: 3BEBD56C  addi r31, r11, -0x2a94
	ctx.r[31].s64 = ctx.r[11].s64 + -10900;
	// 82EDBC48: 4BA320C1  bl 0x8290dd08
	ctx.lr = 0x82EDBC4C;
	sub_8290DD08(ctx, base);
	// 82EDBC4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDBC50: 4BDD0F01  bl 0x82cacb50
	ctx.lr = 0x82EDBC54;
	sub_82CACB50(ctx, base);
	// 82EDBC54: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDBC58: 4182006C  beq 0x82edbcc4
	if ctx.cr[0].eq {
	pc = 0x82EDBCC4; continue 'dispatch;
	}
	// 82EDBC5C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EDBC60: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDBC64: 3BEB1698  addi r31, r11, 0x1698
	ctx.r[31].s64 = ctx.r[11].s64 + 5784;
	// 82EDBC68: 4BA320A1  bl 0x8290dd08
	ctx.lr = 0x82EDBC6C;
	sub_8290DD08(ctx, base);
	// 82EDBC6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDBC70: 4BDD0EE1  bl 0x82cacb50
	ctx.lr = 0x82EDBC74;
	sub_82CACB50(ctx, base);
	// 82EDBC74: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDBC78: 41820044  beq 0x82edbcbc
	if ctx.cr[0].eq {
	pc = 0x82EDBCBC; continue 'dispatch;
	}
	// 82EDBC7C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EDBC80: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDBC84: 3BEB1700  addi r31, r11, 0x1700
	ctx.r[31].s64 = ctx.r[11].s64 + 5888;
	// 82EDBC88: 4BA32081  bl 0x8290dd08
	ctx.lr = 0x82EDBC8C;
	sub_8290DD08(ctx, base);
	// 82EDBC8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDBC90: 4BDD0EC1  bl 0x82cacb50
	ctx.lr = 0x82EDBC94;
	sub_82CACB50(ctx, base);
	// 82EDBC94: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDBC98: 41820024  beq 0x82edbcbc
	if ctx.cr[0].eq {
	pc = 0x82EDBCBC; continue 'dispatch;
	}
	// 82EDBC9C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EDBCA0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDBCA4: 3BEB7088  addi r31, r11, 0x7088
	ctx.r[31].s64 = ctx.r[11].s64 + 28808;
	// 82EDBCA8: 4BA32061  bl 0x8290dd08
	ctx.lr = 0x82EDBCAC;
	sub_8290DD08(ctx, base);
	// 82EDBCAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDBCB0: 4BDD0EA1  bl 0x82cacb50
	ctx.lr = 0x82EDBCB4;
	sub_82CACB50(ctx, base);
	// 82EDBCB4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDBCB8: 4082FA1C  bne 0x82edb6d4
	if !ctx.cr[0].eq {
	pc = 0x82EDB6D4; continue 'dispatch;
	}
	pc = 0x82EDBCBC; continue 'dispatch;
            }
            0x82EDBCBC => {
    //   block [0x82EDBCBC..0x82EDBCC4)
	// 82EDBCBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EDBCC0: 48000008  b 0x82edbcc8
	pc = 0x82EDBCC8; continue 'dispatch;
            }
            0x82EDBCC4 => {
    //   block [0x82EDBCC4..0x82EDBCC8)
	// 82EDBCC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82EDBCC8; continue 'dispatch;
            }
            0x82EDBCC8 => {
    //   block [0x82EDBCC8..0x82EDBCD0)
	// 82EDBCC8: 997C0038  stb r11, 0x38(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(56 as u32), ctx.r[11].u8 ) };
	// 82EDBCCC: 4BFFFA14  b 0x82edb6e0
	pc = 0x82EDB6E0; continue 'dispatch;
            }
            0x82EDBCD0 => {
    //   block [0x82EDBCD0..0x82EDBD04)
	// 82EDBCD0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDBCD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDBCD8: 388BBCEC  addi r4, r11, -0x4314
	ctx.r[4].s64 = ctx.r[11].s64 + -17172;
	// 82EDBCDC: 4BDD0E75  bl 0x82cacb50
	ctx.lr = 0x82EDBCE0;
	sub_82CACB50(ctx, base);
	// 82EDBCE0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDBCE4: 4082003C  bne 0x82edbd20
	if !ctx.cr[0].eq {
	pc = 0x82EDBD20; continue 'dispatch;
	}
	// 82EDBCE8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDBCEC: 4BA3201D  bl 0x8290dd08
	ctx.lr = 0x82EDBCF0;
	sub_8290DD08(ctx, base);
	// 82EDBCF0: 4BDCFEC1  bl 0x82cabbb0
	ctx.lr = 0x82EDBCF4;
	sub_82CABBB0(ctx, base);
	// 82EDBCF4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDBCF8: C01C003C  lfs f0, 0x3c(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDBCFC: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDBD00: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EDBD04; continue 'dispatch;
            }
            0x82EDBD04 => {
    //   block [0x82EDBD04..0x82EDBD10)
	// 82EDBD04: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDBD08: 40990008  ble cr6, 0x82edbd10
	if !ctx.cr[6].gt {
	pc = 0x82EDBD10; continue 'dispatch;
	}
	// 82EDBD0C: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDBD10; continue 'dispatch;
            }
            0x82EDBD10 => {
    //   block [0x82EDBD10..0x82EDBD20)
	// 82EDBD10: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDBD14: 409AFFF0  bne cr6, 0x82edbd04
	if !ctx.cr[6].eq {
	pc = 0x82EDBD04; continue 'dispatch;
	}
	// 82EDBD18: D01C003C  stfs f0, 0x3c(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82EDBD1C: 4BFFF9C4  b 0x82edb6e0
	pc = 0x82EDB6E0; continue 'dispatch;
            }
            0x82EDBD20 => {
    //   block [0x82EDBD20..0x82EDBD50)
	// 82EDBD20: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDBD24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDBD28: 388BBCDC  addi r4, r11, -0x4324
	ctx.r[4].s64 = ctx.r[11].s64 + -17188;
	// 82EDBD2C: 4BDD0E25  bl 0x82cacb50
	ctx.lr = 0x82EDBD30;
	sub_82CACB50(ctx, base);
	// 82EDBD30: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDBD34: 40820060  bne 0x82edbd94
	if !ctx.cr[0].eq {
	pc = 0x82EDBD94; continue 'dispatch;
	}
	// 82EDBD38: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDBD3C: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDBD40: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDBD44: 4182000C  beq 0x82edbd50
	if ctx.cr[0].eq {
	pc = 0x82EDBD50; continue 'dispatch;
	}
	// 82EDBD48: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EDBD4C: 4800000C  b 0x82edbd58
	pc = 0x82EDBD58; continue 'dispatch;
            }
            0x82EDBD50 => {
    //   block [0x82EDBD50..0x82EDBD58)
	// 82EDBD50: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDBD54: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EDBD58; continue 'dispatch;
            }
            0x82EDBD58 => {
    //   block [0x82EDBD58..0x82EDBD78)
	// 82EDBD58: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDBD5C: 4BA31FAD  bl 0x8290dd08
	ctx.lr = 0x82EDBD60;
	sub_8290DD08(ctx, base);
	// 82EDBD60: 4BDCFE51  bl 0x82cabbb0
	ctx.lr = 0x82EDBD64;
	sub_82CABBB0(ctx, base);
	// 82EDBD64: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDBD68: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDBD6C: C01C0040  lfs f0, 0x40(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDBD70: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDBD74: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	pc = 0x82EDBD78; continue 'dispatch;
            }
            0x82EDBD78 => {
    //   block [0x82EDBD78..0x82EDBD84)
	// 82EDBD78: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDBD7C: 40990008  ble cr6, 0x82edbd84
	if !ctx.cr[6].gt {
	pc = 0x82EDBD84; continue 'dispatch;
	}
	// 82EDBD80: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDBD84; continue 'dispatch;
            }
            0x82EDBD84 => {
    //   block [0x82EDBD84..0x82EDBD94)
	// 82EDBD84: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDBD88: 409AFFF0  bne cr6, 0x82edbd78
	if !ctx.cr[6].eq {
	pc = 0x82EDBD78; continue 'dispatch;
	}
	// 82EDBD8C: D01C0040  stfs f0, 0x40(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82EDBD90: 4BFFF950  b 0x82edb6e0
	pc = 0x82EDB6E0; continue 'dispatch;
            }
            0x82EDBD94 => {
    //   block [0x82EDBD94..0x82EDBDC4)
	// 82EDBD94: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDBD98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDBD9C: 388BBCCC  addi r4, r11, -0x4334
	ctx.r[4].s64 = ctx.r[11].s64 + -17204;
	// 82EDBDA0: 4BDD0DB1  bl 0x82cacb50
	ctx.lr = 0x82EDBDA4;
	sub_82CACB50(ctx, base);
	// 82EDBDA4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDBDA8: 40820060  bne 0x82edbe08
	if !ctx.cr[0].eq {
	pc = 0x82EDBE08; continue 'dispatch;
	}
	// 82EDBDAC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDBDB0: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDBDB4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDBDB8: 4182000C  beq 0x82edbdc4
	if ctx.cr[0].eq {
	pc = 0x82EDBDC4; continue 'dispatch;
	}
	// 82EDBDBC: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EDBDC0: 4800000C  b 0x82edbdcc
	pc = 0x82EDBDCC; continue 'dispatch;
            }
            0x82EDBDC4 => {
    //   block [0x82EDBDC4..0x82EDBDCC)
	// 82EDBDC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDBDC8: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EDBDCC; continue 'dispatch;
            }
            0x82EDBDCC => {
    //   block [0x82EDBDCC..0x82EDBDEC)
	// 82EDBDCC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDBDD0: 4BA31F39  bl 0x8290dd08
	ctx.lr = 0x82EDBDD4;
	sub_8290DD08(ctx, base);
	// 82EDBDD4: 4BDCFDDD  bl 0x82cabbb0
	ctx.lr = 0x82EDBDD8;
	sub_82CABBB0(ctx, base);
	// 82EDBDD8: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDBDDC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDBDE0: C01C0044  lfs f0, 0x44(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDBDE4: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDBDE8: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	pc = 0x82EDBDEC; continue 'dispatch;
            }
            0x82EDBDEC => {
    //   block [0x82EDBDEC..0x82EDBDF8)
	// 82EDBDEC: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDBDF0: 40990008  ble cr6, 0x82edbdf8
	if !ctx.cr[6].gt {
	pc = 0x82EDBDF8; continue 'dispatch;
	}
	// 82EDBDF4: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDBDF8; continue 'dispatch;
            }
            0x82EDBDF8 => {
    //   block [0x82EDBDF8..0x82EDBE08)
	// 82EDBDF8: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDBDFC: 409AFFF0  bne cr6, 0x82edbdec
	if !ctx.cr[6].eq {
	pc = 0x82EDBDEC; continue 'dispatch;
	}
	// 82EDBE00: D01C0044  stfs f0, 0x44(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82EDBE04: 4BFFF8DC  b 0x82edb6e0
	pc = 0x82EDB6E0; continue 'dispatch;
            }
            0x82EDBE08 => {
    //   block [0x82EDBE08..0x82EDBE14)
	// 82EDBE08: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EDBE0C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EDBE10: 4BFD9611  bl 0x82eb5420
	ctx.lr = 0x82EDBE14;
	sub_82EB5420(ctx, base);
	pc = 0x82EDBE14; continue 'dispatch;
            }
            0x82EDBE14 => {
    //   block [0x82EDBE14..0x82EDBE24)
	// 82EDBE14: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EDBE18: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82EDBE1C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82EDBE20: 4BDCD638  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDBE28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EDBE28 size=212
    let mut pc: u32 = 0x82EDBE28;
    'dispatch: loop {
        match pc {
            0x82EDBE28 => {
    //   block [0x82EDBE28..0x82EDBE80)
	// 82EDBE28: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDBE2C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EDBE30: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDBE34: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EDBE38: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82EDBE3C: 996300EE  stb r11, 0xee(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(238 as u32), ctx.r[11].u8 ) };
	// 82EDBE40: D003007C  stfs f0, 0x7c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82EDBE44: D0030080  stfs f0, 0x80(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EDBE48: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDBE4C: D0030084  stfs f0, 0x84(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EDBE50: D1A30088  stfs f13, 0x88(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EDBE54: C1A30080  lfs f13, 0x80(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDBE58: D1A3008C  stfs f13, 0x8c(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EDBE5C: C1A30084  lfs f13, 0x84(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(132 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDBE60: D1A30090  stfs f13, 0x90(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82EDBE64: 91430094  stw r10, 0x94(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	// 82EDBE68: 91430104  stw r10, 0x104(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(260 as u32), ctx.r[10].u32 ) };
	// 82EDBE6C: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDBE70: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDBE74: 4182000C  beq 0x82edbe80
	if ctx.cr[0].eq {
	pc = 0x82EDBE80; continue 'dispatch;
	}
	// 82EDBE78: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDBE7C: 4800000C  b 0x82edbe88
	pc = 0x82EDBE88; continue 'dispatch;
            }
            0x82EDBE80 => {
    //   block [0x82EDBE80..0x82EDBE88)
	// 82EDBE80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDBE84: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82EDBE88; continue 'dispatch;
            }
            0x82EDBE88 => {
    //   block [0x82EDBE88..0x82EDBEA0)
	// 82EDBE88: 816300CC  lwz r11, 0xcc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(204 as u32) ) } as u64;
	// 82EDBE8C: D1A30078  stfs f13, 0x78(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EDBE90: D00300C8  stfs f0, 0xc8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EDBE94: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDBE98: 41820040  beq 0x82edbed8
	if ctx.cr[0].eq {
	pc = 0x82EDBED8; continue 'dispatch;
	}
	// 82EDBE9C: 48000028  b 0x82edbec4
	pc = 0x82EDBEC4; continue 'dispatch;
            }
            0x82EDBEA0 => {
    //   block [0x82EDBEA0..0x82EDBEC4)
	// 82EDBEA0: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDBEA4: 9949002C  stb r10, 0x2c(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(44 as u32), ctx.r[10].u8 ) };
	// 82EDBEA8: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDBEAC: 80EB0010  lwz r7, 0x10(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EDBEB0: 81090028  lwz r8, 0x28(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EDBEB4: 90E90028  stw r7, 0x28(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(40 as u32), ctx.r[7].u32 ) };
	// 82EDBEB8: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDBEBC: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82EDBEC0: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	pc = 0x82EDBEC4; continue 'dispatch;
            }
            0x82EDBEC4 => {
    //   block [0x82EDBEC4..0x82EDBED8)
	// 82EDBEC4: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDBEC8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EDBECC: 409AFFD4  bne cr6, 0x82edbea0
	if !ctx.cr[6].eq {
	pc = 0x82EDBEA0; continue 'dispatch;
	}
	// 82EDBED0: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EDBED4: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	pc = 0x82EDBED8; continue 'dispatch;
            }
            0x82EDBED8 => {
    //   block [0x82EDBED8..0x82EDBEFC)
	// 82EDBED8: D00300D0  stfs f0, 0xd0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82EDBEDC: D00300D4  stfs f0, 0xd4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EDBEE0: D00300D8  stfs f0, 0xd8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EDBEE4: 914300E8  stw r10, 0xe8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(232 as u32), ctx.r[10].u32 ) };
	// 82EDBEE8: D00300DC  stfs f0, 0xdc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EDBEEC: 994300ED  stb r10, 0xed(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(237 as u32), ctx.r[10].u8 ) };
	// 82EDBEF0: D00300F0  stfs f0, 0xf0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82EDBEF4: 994300F4  stb r10, 0xf4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(244 as u32), ctx.r[10].u8 ) };
	// 82EDBEF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDBF00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EDBF00 size=1204
    let mut pc: u32 = 0x82EDBF00;
    'dispatch: loop {
        match pc {
            0x82EDBF00 => {
    //   block [0x82EDBF00..0x82EDBFDC)
	// 82EDBF00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDBF04: 4BDCD4F9  bl 0x82ca93fc
	ctx.lr = 0x82EDBF08;
	sub_82CA93D0(ctx, base);
	// 82EDBF08: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 82EDBF0C: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82EDBF10: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDBF14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDBF18: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EDBF1C: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82EDBF20: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EDBF24: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDBF28: D01F0064  stfs f0, 0x64(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EDBF2C: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDBF30: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EDBF34: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDBF38: D01F006C  stfs f0, 0x6c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82EDBF3C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDBF40: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDBF44: C01F0064  lfs f0, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDBF48: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EDBF4C: C19F0068  lfs f12, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDBF50: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDBF54: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EDBF58: C17E000C  lfs f11, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDBF5C: C19F006C  lfs f12, 0x6c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDBF60: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EDBF64: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDBF68: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EDBF6C: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EDBF70: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EDBF74: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EDBF78: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDBF7C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDBF80: C3CB0C18  lfs f30, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EDBF84: FF0DF000  fcmpu cr6, f13, f30
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[30].f64);
	// 82EDBF88: 40990418  ble cr6, 0x82edc3a0
	if !ctx.cr[6].gt {
	pc = 0x82EDC3A0; continue 'dispatch;
	}
	// 82EDBF8C: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82EDBF90: 419A0410  beq cr6, 0x82edc3a0
	if ctx.cr[6].eq {
	pc = 0x82EDC3A0; continue 'dispatch;
	}
	// 82EDBF94: C19F0084  lfs f12, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDBF98: 3F408334  lis r26, -0x7ccc
	ctx.r[26].s64 = -2093744128;
	// 82EDBF9C: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDBFA0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EDBFA4: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EDBFA8: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDBFAC: C17F007C  lfs f11, 0x7c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDBFB0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EDBFB4: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EDBFB8: 817A0718  lwz r11, 0x718(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDBFBC: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 82EDBFC0: C3EA0C14  lfs f31, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EDBFC4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDBFC8: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDBFCC: ED8D037A  fmadds f12, f13, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EDBFD0: 4182000C  beq 0x82edbfdc
	if ctx.cr[0].eq {
	pc = 0x82EDBFDC; continue 'dispatch;
	}
	// 82EDBFD4: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDBFD8: 48000008  b 0x82edbfe0
	pc = 0x82EDBFE0; continue 'dispatch;
            }
            0x82EDBFDC => {
    //   block [0x82EDBFDC..0x82EDBFE0)
	// 82EDBFDC: FDA0F890  fmr f13, f31
	ctx.f[13].f64 = ctx.f[31].f64;
	pc = 0x82EDBFE0; continue 'dispatch;
            }
            0x82EDBFE0 => {
    //   block [0x82EDBFE0..0x82EDBFF0)
	// 82EDBFE0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDBFE4: 4182000C  beq 0x82edbff0
	if ctx.cr[0].eq {
	pc = 0x82EDBFF0; continue 'dispatch;
	}
	// 82EDBFE8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDBFEC: 48000008  b 0x82edbff4
	pc = 0x82EDBFF4; continue 'dispatch;
            }
            0x82EDBFF0 => {
    //   block [0x82EDBFF0..0x82EDBFF4)
	// 82EDBFF0: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x82EDBFF4; continue 'dispatch;
            }
            0x82EDBFF4 => {
    //   block [0x82EDBFF4..0x82EDC008)
	// 82EDBFF4: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EDBFF8: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82EDBFFC: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82EDC000: 40990008  ble cr6, 0x82edc008
	if !ctx.cr[6].gt {
	pc = 0x82EDC008; continue 'dispatch;
	}
	// 82EDC004: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	pc = 0x82EDC008; continue 'dispatch;
            }
            0x82EDC008 => {
    //   block [0x82EDC008..0x82EDC170)
	// 82EDC008: 4B3849B1  bl 0x822609b8
	ctx.lr = 0x82EDC00C;
	sub_822609B8(ctx, base);
	// 82EDC00C: C1A30058  lfs f13, 0x58(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDC010: C01F00F0  lfs f0, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC014: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EDC018: D01F00F0  stfs f0, 0xf0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82EDC01C: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC020: D01F007C  stfs f0, 0x7c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82EDC024: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC028: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EDC02C: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC030: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EDC034: C19F0064  lfs f12, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDC038: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDC03C: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EDC040: C17E0008  lfs f11, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDC044: C19F0068  lfs f12, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDC048: C01F00C4  lfs f0, 0xc4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC04C: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EDC050: C15E000C  lfs f10, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EDC054: EC1F0024  fdivs f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EDC058: C17F006C  lfs f11, 0x6c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDC05C: 57A9063F  clrlwi. r9, r29, 0x18
	ctx.r[9].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EDC060: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EDC064: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EDC068: D1BF00B0  stfs f13, 0xb0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82EDC06C: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EDC070: D19F00B4  stfs f12, 0xb4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82EDC074: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EDC078: D01F00B8  stfs f0, 0xb8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82EDC07C: D1BF00A0  stfs f13, 0xa0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82EDC080: D3DF009C  stfs f30, 0x9c(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82EDC084: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EDC088: D01F0098  stfs f0, 0x98(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82EDC08C: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 82EDC090: C19F00A0  lfs f12, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDC094: C17F00B4  lfs f11, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDC098: C1BF00B8  lfs f13, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDC09C: ED0B0332  fmuls f8, f11, f12
	ctx.f[8].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EDC0A0: C13F0098  lfs f9, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EDC0A4: C15F00B0  lfs f10, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EDC0A8: ECE90372  fmuls f7, f9, f13
	ctx.f[7].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EDC0AC: ECCA0032  fmuls f6, f10, f0
	ctx.f[6].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDC0B0: EC0D4038  fmsubs f0, f13, f0, f8
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EDC0B4: D01F00A4  stfs f0, 0xa4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82EDC0B8: EDAA3B38  fmsubs f13, f10, f12, f7
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[12].f64 - ctx.f[7].f64) as f32) as f64);
	// 82EDC0BC: D1BF00A8  stfs f13, 0xa8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82EDC0C0: ED8932F8  fmsubs f12, f9, f11, f6
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[11].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EDC0C4: D19F00AC  stfs f12, 0xac(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82EDC0C8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDC0CC: 815F0094  lwz r10, 0x94(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EDC0D0: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC0D4: EC1F0024  fdivs f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EDC0D8: 915F0104  stw r10, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[10].u32 ) };
	// 82EDC0DC: D01F0100  stfs f0, 0x100(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82EDC0E0: 418200A0  beq 0x82edc180
	if ctx.cr[0].eq {
	pc = 0x82EDC180; continue 'dispatch;
	}
	// 82EDC0E4: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82EDC0E8: FD400090  fmr f10, f0
	ctx.f[10].f64 = ctx.f[0].f64;
	// 82EDC0EC: C1BF0014  lfs f13, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDC0F0: C0FF0088  lfs f7, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EDC0F4: C17F0048  lfs f11, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDC0F8: C19F0050  lfs f12, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDC0FC: C0080A98  lfs f0, 0xa98(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2712 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC100: ED8C02F2  fmuls f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EDC104: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDC108: C01F0064  lfs f0, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC10C: EC070028  fsubs f0, f7, f0
	ctx.f[0].f64 = (((ctx.f[7].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EDC110: C13F0098  lfs f9, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EDC114: C17F006C  lfs f11, 0x6c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDC118: C0DF0090  lfs f6, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EDC11C: ED665828  fsubs f11, f6, f11
	ctx.f[11].f64 = (((ctx.f[6].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EDC120: C11F00A0  lfs f8, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EDC124: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDC128: EC090032  fmuls f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDC12C: EC0802FA  fmadds f0, f8, f11, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EDC130: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EDC134: D01F00D0  stfs f0, 0xd0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82EDC138: C17F0064  lfs f11, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDC13C: C01F0088  lfs f0, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC140: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EDC144: C13F0090  lfs f9, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EDC148: C17F006C  lfs f11, 0x6c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDC14C: ED695828  fsubs f11, f9, f11
	ctx.f[11].f64 = (((ctx.f[9].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EDC150: C13F00B0  lfs f9, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EDC154: C11F00B8  lfs f8, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EDC158: EC000272  fmuls f0, f0, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[9].f64) as f32) as f64);
	// 82EDC15C: EC0802FA  fmadds f0, f8, f11, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EDC160: EC0002B2  fmuls f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EDC164: D01F00DC  stfs f0, 0xdc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EDC168: 41990008  bgt cr6, 0x82edc170
	if ctx.cr[6].gt {
	pc = 0x82EDC170; continue 'dispatch;
	}
	// 82EDC16C: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	pc = 0x82EDC170; continue 'dispatch;
            }
            0x82EDC170 => {
    //   block [0x82EDC170..0x82EDC17C)
	// 82EDC170: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EDC174: 40980008  bge cr6, 0x82edc17c
	if !ctx.cr[6].lt {
	pc = 0x82EDC17C; continue 'dispatch;
	}
	// 82EDC178: 9B9F00EC  stb r28, 0xec(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[28].u8 ) };
	pc = 0x82EDC17C; continue 'dispatch;
            }
            0x82EDC17C => {
    //   block [0x82EDC17C..0x82EDC180)
	// 82EDC17C: 9B9F00EE  stb r28, 0xee(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(238 as u32), ctx.r[28].u8 ) };
	pc = 0x82EDC180; continue 'dispatch;
            }
            0x82EDC180 => {
    //   block [0x82EDC180..0x82EDC1F0)
	// 82EDC180: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 82EDC184: 419A00B4  beq cr6, 0x82edc238
	if ctx.cr[6].eq {
	pc = 0x82EDC238; continue 'dispatch;
	}
	// 82EDC188: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 82EDC18C: 419A0098  beq cr6, 0x82edc224
	if ctx.cr[6].eq {
	pc = 0x82EDC224; continue 'dispatch;
	}
	// 82EDC190: 2F0A0005  cmpwi cr6, r10, 5
	ctx.cr[6].compare_i32(ctx.r[10].s32, 5, &mut ctx.xer);
	// 82EDC194: 409A0150  bne cr6, 0x82edc2e4
	if !ctx.cr[6].eq {
	pc = 0x82EDC2E4; continue 'dispatch;
	}
	// 82EDC198: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EDC19C: 409A006C  bne cr6, 0x82edc208
	if !ctx.cr[6].eq {
	pc = 0x82EDC208; continue 'dispatch;
	}
	// 82EDC1A0: C01F00F0  lfs f0, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC1A4: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82EDC1A8: 40990060  ble cr6, 0x82edc208
	if !ctx.cr[6].gt {
	pc = 0x82EDC208; continue 'dispatch;
	}
	// 82EDC1AC: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82EDC1B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EDC1B4: 409A0130  bne cr6, 0x82edc2e4
	if !ctx.cr[6].eq {
	pc = 0x82EDC2E4; continue 'dispatch;
	}
	// 82EDC1B8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82EDC1BC: 806B0264  lwz r3, 0x264(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(612 as u32) ) } as u64;
	// 82EDC1C0: C01F0088  lfs f0, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC1C4: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82EDC1C8: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 82EDC1CC: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EDC1D0: C01F008C  lfs f0, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC1D4: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 82EDC1D8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EDC1DC: C01F0090  lfs f0, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC1E0: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EDC1E4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82EDC1E8: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EDC1EC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82EDC1F0; continue 'dispatch;
            }
            0x82EDC1F0 => {
    //   block [0x82EDC1F0..0x82EDC208)
	// 82EDC1F0: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EDC1F4: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EDC1F8: 4200FFF8  bdnz 0x82edc1f0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EDC1F0; continue 'dispatch;
	}
	// 82EDC1FC: 9B6100A8  stb r27, 0xa8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[27].u8 ) };
	// 82EDC200: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EDC204: 4800008C  b 0x82edc290
	pc = 0x82EDC290; continue 'dispatch;
            }
            0x82EDC208 => {
    //   block [0x82EDC208..0x82EDC218)
	// 82EDC208: C01F00F0  lfs f0, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC20C: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82EDC210: 41990008  bgt cr6, 0x82edc218
	if ctx.cr[6].gt {
	pc = 0x82EDC218; continue 'dispatch;
	}
	// 82EDC214: 9B8B0397  stb r28, 0x397(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(919 as u32), ctx.r[28].u8 ) };
	pc = 0x82EDC218; continue 'dispatch;
            }
            0x82EDC218 => {
    //   block [0x82EDC218..0x82EDC224)
	// 82EDC218: C01F0030  lfs f0, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC21C: D01F00F0  stfs f0, 0xf0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82EDC220: 480000BC  b 0x82edc2dc
	pc = 0x82EDC2DC; continue 'dispatch;
            }
            0x82EDC224 => {
    //   block [0x82EDC224..0x82EDC238)
	// 82EDC224: C01F00F0  lfs f0, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC228: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82EDC22C: 409800B8  bge cr6, 0x82edc2e4
	if !ctx.cr[6].lt {
	pc = 0x82EDC2E4; continue 'dispatch;
	}
	// 82EDC230: 937F0104  stw r27, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[27].u32 ) };
	// 82EDC234: 480000B0  b 0x82edc2e4
	pc = 0x82EDC2E4; continue 'dispatch;
            }
            0x82EDC238 => {
    //   block [0x82EDC238..0x82EDC27C)
	// 82EDC238: C01F00F0  lfs f0, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC23C: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82EDC240: 40990078  ble cr6, 0x82edc2b8
	if !ctx.cr[6].gt {
	pc = 0x82EDC2B8; continue 'dispatch;
	}
	// 82EDC244: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82EDC248: 806B0264  lwz r3, 0x264(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(612 as u32) ) } as u64;
	// 82EDC24C: C01F0088  lfs f0, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC250: 392100C0  addi r9, r1, 0xc0
	ctx.r[9].s64 = ctx.r[1].s64 + 192;
	// 82EDC254: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 82EDC258: D00100B4  stfs f0, 0xb4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82EDC25C: C01F008C  lfs f0, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC260: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 82EDC264: D00100B8  stfs f0, 0xb8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82EDC268: C01F0090  lfs f0, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC26C: D00100BC  stfs f0, 0xbc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82EDC270: 914100B0  stw r10, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[10].u32 ) };
	// 82EDC274: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82EDC278: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82EDC27C; continue 'dispatch;
            }
            0x82EDC27C => {
    //   block [0x82EDC27C..0x82EDC290)
	// 82EDC27C: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EDC280: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82EDC284: 4200FFF8  bdnz 0x82edc27c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EDC27C; continue 'dispatch;
	}
	// 82EDC288: 9B610108  stb r27, 0x108(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[27].u8 ) };
	// 82EDC28C: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	pc = 0x82EDC290; continue 'dispatch;
            }
            0x82EDC290 => {
    //   block [0x82EDC290..0x82EDC2B8)
	// 82EDC290: C02B0010  lfs f1, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EDC294: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EDC298: 809F0060  lwz r4, 0x60(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EDC29C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82EDC2A0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EDC2A4: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 82EDC2A8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EDC2AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDC2B0: 4E800421  bctrl
	ctx.lr = 0x82EDC2B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EDC2B4: 480000F0  b 0x82edc3a4
	pc = 0x82EDC3A4; continue 'dispatch;
            }
            0x82EDC2B8 => {
    //   block [0x82EDC2B8..0x82EDC2D4)
	// 82EDC2B8: C01F002C  lfs f0, 0x2c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC2BC: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82EDC2C0: 40990014  ble cr6, 0x82edc2d4
	if !ctx.cr[6].gt {
	pc = 0x82EDC2D4; continue 'dispatch;
	}
	// 82EDC2C4: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82EDC2C8: D01F00F0  stfs f0, 0xf0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82EDC2CC: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 82EDC2D0: 4800000C  b 0x82edc2dc
	pc = 0x82EDC2DC; continue 'dispatch;
            }
            0x82EDC2D4 => {
    //   block [0x82EDC2D4..0x82EDC2DC)
	// 82EDC2D4: D3DF00F0  stfs f30, 0xf0(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82EDC2D8: 937F0104  stw r27, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[27].u32 ) };
	pc = 0x82EDC2DC; continue 'dispatch;
            }
            0x82EDC2DC => {
    //   block [0x82EDC2DC..0x82EDC2E4)
	// 82EDC2DC: 9B9F00EC  stb r28, 0xec(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[28].u8 ) };
	// 82EDC2E0: 9B9F00EE  stb r28, 0xee(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(238 as u32), ctx.r[28].u8 ) };
	pc = 0x82EDC2E4; continue 'dispatch;
            }
            0x82EDC2E4 => {
    //   block [0x82EDC2E4..0x82EDC2F8)
	// 82EDC2E4: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EDC2E8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDC2EC: 4182000C  beq 0x82edc2f8
	if ctx.cr[0].eq {
	pc = 0x82EDC2F8; continue 'dispatch;
	}
	// 82EDC2F0: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC2F4: 4800001C  b 0x82edc310
	pc = 0x82EDC310; continue 'dispatch;
            }
            0x82EDC2F8 => {
    //   block [0x82EDC2F8..0x82EDC30C)
	// 82EDC2F8: 817A0718  lwz r11, 0x718(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDC2FC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDC300: 4182000C  beq 0x82edc30c
	if ctx.cr[0].eq {
	pc = 0x82EDC30C; continue 'dispatch;
	}
	// 82EDC304: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC308: 48000008  b 0x82edc310
	pc = 0x82EDC310; continue 'dispatch;
            }
            0x82EDC30C => {
    //   block [0x82EDC30C..0x82EDC310)
	// 82EDC30C: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x82EDC310; continue 'dispatch;
            }
            0x82EDC310 => {
    //   block [0x82EDC310..0x82EDC33C)
	// 82EDC310: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EDC314: C1BF001C  lfs f13, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDC318: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EDC31C: D1BF00C0  stfs f13, 0xc0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82EDC320: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDC324: 41820018  beq 0x82edc33c
	if ctx.cr[0].eq {
	pc = 0x82EDC33C; continue 'dispatch;
	}
	// 82EDC328: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EDC32C: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDC330: C00A0BFC  lfs f0, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC334: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EDC338: 48000018  b 0x82edc350
	pc = 0x82EDC350; continue 'dispatch;
            }
            0x82EDC33C => {
    //   block [0x82EDC33C..0x82EDC34C)
	// 82EDC33C: 817A0718  lwz r11, 0x718(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDC340: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDC344: 41820008  beq 0x82edc34c
	if ctx.cr[0].eq {
	pc = 0x82EDC34C; continue 'dispatch;
	}
	// 82EDC348: C3EB000C  lfs f31, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EDC34C; continue 'dispatch;
            }
            0x82EDC34C => {
    //   block [0x82EDC34C..0x82EDC350)
	// 82EDC34C: EC0DF82A  fadds f0, f13, f31
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	pc = 0x82EDC350; continue 'dispatch;
            }
            0x82EDC350 => {
    //   block [0x82EDC350..0x82EDC3A0)
	// 82EDC350: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EDC354: D01F00C0  stfs f0, 0xc0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82EDC358: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDC35C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EDC360: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDC364: 4E800421  bctrl
	ctx.lr = 0x82EDC368;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EDC368: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EDC36C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDC370: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EDC374: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDC378: 4E800421  bctrl
	ctx.lr = 0x82EDC37C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EDC37C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDC380: 48008179  bl 0x82ee44f8
	ctx.lr = 0x82EDC384;
	sub_82EE44F8(ctx, base);
	// 82EDC384: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EDC388: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82EDC38C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDC390: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EDC394: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDC398: 4E800421  bctrl
	ctx.lr = 0x82EDC39C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EDC39C: 48000008  b 0x82edc3a4
	pc = 0x82EDC3A4; continue 'dispatch;
            }
            0x82EDC3A0 => {
    //   block [0x82EDC3A0..0x82EDC3A4)
	// 82EDC3A0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EDC3A4; continue 'dispatch;
            }
            0x82EDC3A4 => {
    //   block [0x82EDC3A4..0x82EDC3B4)
	// 82EDC3A4: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 82EDC3A8: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82EDC3AC: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82EDC3B0: 4BDCD09C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDC3B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EDC3B8 size=364
    let mut pc: u32 = 0x82EDC3B8;
    'dispatch: loop {
        match pc {
            0x82EDC3B8 => {
    //   block [0x82EDC3B8..0x82EDC418)
	// 82EDC3B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDC3BC: 4BDCD051  bl 0x82ca940c
	ctx.lr = 0x82EDC3C0;
	sub_82CA93D0(ctx, base);
	// 82EDC3C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDC3C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDC3C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDC3CC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EDC3D0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EDC3D4: 396BA2F0  addi r11, r11, -0x5d10
	ctx.r[11].s64 = ctx.r[11].s64 + -23824;
	// 82EDC3D8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EDC3DC: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EDC3E0: 93BF0014  stw r29, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 82EDC3E4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EDC3E8: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82EDC3EC: 93BF0010  stw r29, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 82EDC3F0: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82EDC3F4: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82EDC3F8: 419A0120  beq cr6, 0x82edc518
	if ctx.cr[6].eq {
	pc = 0x82EDC518; continue 'dispatch;
	}
	// 82EDC3FC: 3D600555  lis r11, 0x555
	ctx.r[11].s64 = 89456640;
	// 82EDC400: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82EDC404: 616B5555  ori r11, r11, 0x5555
	ctx.r[11].u64 = ctx.r[11].u64 | 21845;
	// 82EDC408: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EDC40C: 1D7E0030  mulli r11, r30, 0x30
	ctx.r[11].s32 = ((ctx.r[30].s32 as i64 * 48 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EDC410: 40990008  ble cr6, 0x82edc418
	if !ctx.cr[6].gt {
	pc = 0x82EDC418; continue 'dispatch;
	}
	// 82EDC414: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x82EDC418; continue 'dispatch;
            }
            0x82EDC418 => {
    //   block [0x82EDC418..0x82EDC428)
	// 82EDC418: 3940FFFB  li r10, -5
	ctx.r[10].s64 = -5;
	// 82EDC41C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EDC420: 41990008  bgt cr6, 0x82edc428
	if ctx.cr[6].gt {
	pc = 0x82EDC428; continue 'dispatch;
	}
	// 82EDC424: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	pc = 0x82EDC428; continue 'dispatch;
            }
            0x82EDC428 => {
    //   block [0x82EDC428..0x82EDC464)
	// 82EDC428: 4B73A501  bl 0x82616928
	ctx.lr = 0x82EDC42C;
	sub_82616928(ctx, base);
	// 82EDC42C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDC430: 4182007C  beq 0x82edc4ac
	if ctx.cr[0].eq {
	pc = 0x82EDC4AC; continue 'dispatch;
	}
	// 82EDC434: 38A30004  addi r5, r3, 4
	ctx.r[5].s64 = ctx.r[3].s64 + 4;
	// 82EDC438: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82EDC43C: 355EFFFF  addic. r10, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EDC440: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 82EDC444: 41800060  blt 0x82edc4a4
	if ctx.cr[0].lt {
	pc = 0x82EDC4A4; continue 'dispatch;
	}
	// 82EDC448: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82EDC44C: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82EDC450: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 82EDC454: 39690010  addi r11, r9, 0x10
	ctx.r[11].s64 = ctx.r[9].s64 + 16;
	// 82EDC458: 3908AFB4  addi r8, r8, -0x504c
	ctx.r[8].s64 = ctx.r[8].s64 + -20556;
	// 82EDC45C: C0060C18  lfs f0, 0xc18(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC460: 38E7BCC8  addi r7, r7, -0x4338
	ctx.r[7].s64 = ctx.r[7].s64 + -17208;
	pc = 0x82EDC464; continue 'dispatch;
            }
            0x82EDC464 => {
    //   block [0x82EDC464..0x82EDC4A4)
	// 82EDC464: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82EDC468: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EDC46C: 910BFFF4  stw r8, -0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), ctx.r[8].u32 ) };
	// 82EDC470: D00BFFF8  stfs f0, -8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82EDC474: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82EDC478: 39290030  addi r9, r9, 0x30
	ctx.r[9].s64 = ctx.r[9].s64 + 48;
	// 82EDC47C: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EDC480: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EDC484: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EDC488: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EDC48C: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EDC490: 93AB0014  stw r29, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 82EDC494: 93AB0018  stw r29, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 82EDC498: 9BAB001C  stb r29, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[29].u8 ) };
	// 82EDC49C: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 82EDC4A0: 4080FFC4  bge 0x82edc464
	if !ctx.cr[0].lt {
	pc = 0x82EDC464; continue 'dispatch;
	}
	pc = 0x82EDC4A4; continue 'dispatch;
            }
            0x82EDC4A4 => {
    //   block [0x82EDC4A4..0x82EDC4AC)
	// 82EDC4A4: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82EDC4A8: 48000008  b 0x82edc4b0
	pc = 0x82EDC4B0; continue 'dispatch;
            }
            0x82EDC4AC => {
    //   block [0x82EDC4AC..0x82EDC4B0)
	// 82EDC4AC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82EDC4B0; continue 'dispatch;
            }
            0x82EDC4B0 => {
    //   block [0x82EDC4B0..0x82EDC4D0)
	// 82EDC4B0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EDC4B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EDC4B8: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EDC4BC: 93AB0024  stw r29, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[29].u32 ) };
	// 82EDC4C0: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EDC4C4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EDC4C8: 4099003C  ble cr6, 0x82edc504
	if !ctx.cr[6].gt {
	pc = 0x82EDC504; continue 'dispatch;
	}
	// 82EDC4CC: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	pc = 0x82EDC4D0; continue 'dispatch;
            }
            0x82EDC4D0 => {
    //   block [0x82EDC4D0..0x82EDC504)
	// 82EDC4D0: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDC4D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EDC4D8: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EDC4DC: 3909FFD0  addi r8, r9, -0x30
	ctx.r[8].s64 = ctx.r[9].s64 + -48;
	// 82EDC4E0: 91090024  stw r8, 0x24(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), ctx.r[8].u32 ) };
	// 82EDC4E4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDC4E8: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EDC4EC: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 82EDC4F0: 81090024  lwz r8, 0x24(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EDC4F4: 91280028  stw r9, 0x28(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 82EDC4F8: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EDC4FC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EDC500: 4198FFD0  blt cr6, 0x82edc4d0
	if ctx.cr[6].lt {
	pc = 0x82EDC4D0; continue 'dispatch;
	}
	pc = 0x82EDC504; continue 'dispatch;
            }
            0x82EDC504 => {
    //   block [0x82EDC504..0x82EDC518)
	// 82EDC504: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EDC508: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDC50C: 1D6B0030  mulli r11, r11, 0x30
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 48 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EDC510: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EDC514: 93ABFFF8  stw r29, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[29].u32 ) };
	pc = 0x82EDC518; continue 'dispatch;
            }
            0x82EDC518 => {
    //   block [0x82EDC518..0x82EDC524)
	// 82EDC518: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDC51C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EDC520: 4BDCCF3C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDC528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EDC528 size=192
    let mut pc: u32 = 0x82EDC528;
    'dispatch: loop {
        match pc {
            0x82EDC528 => {
    //   block [0x82EDC528..0x82EDC568)
	// 82EDC528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDC52C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EDC530: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EDC534: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EDC538: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDC53C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDC540: 548B07BD  rlwinm. r11, r4, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDC544: 4182005C  beq 0x82edc5a0
	if ctx.cr[0].eq {
	pc = 0x82EDC5A0; continue 'dispatch;
	}
	// 82EDC548: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EDC54C: 3BDFFFFC  addi r30, r31, -4
	ctx.r[30].s64 = ctx.r[31].s64 + -4;
	// 82EDC550: 1D4B0030  mulli r10, r11, 0x30
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 48 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EDC554: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDC558: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82EDC55C: 41800020  blt 0x82edc57c
	if ctx.cr[0].lt {
	pc = 0x82EDC57C; continue 'dispatch;
	}
	// 82EDC560: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82EDC564: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	pc = 0x82EDC568; continue 'dispatch;
            }
            0x82EDC568 => {
    //   block [0x82EDC568..0x82EDC57C)
	// 82EDC568: 394AFFD0  addi r10, r10, -0x30
	ctx.r[10].s64 = ctx.r[10].s64 + -48;
	// 82EDC56C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDC570: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EDC574: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EDC578: 4080FFF0  bge 0x82edc568
	if !ctx.cr[0].lt {
	pc = 0x82EDC568; continue 'dispatch;
	}
	pc = 0x82EDC57C; continue 'dispatch;
            }
            0x82EDC57C => {
    //   block [0x82EDC57C..0x82EDC598)
	// 82EDC57C: 548B07FF  clrlwi. r11, r4, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDC580: 41820018  beq 0x82edc598
	if ctx.cr[0].eq {
	pc = 0x82EDC598; continue 'dispatch;
	}
	// 82EDC584: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EDC588: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDC58C: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EDC590: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDC594: 4E800421  bctrl
	ctx.lr = 0x82EDC598;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EDC598 => {
    //   block [0x82EDC598..0x82EDC5A0)
	// 82EDC598: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDC59C: 48000034  b 0x82edc5d0
	pc = 0x82EDC5D0; continue 'dispatch;
            }
            0x82EDC5A0 => {
    //   block [0x82EDC5A0..0x82EDC5CC)
	// 82EDC5A0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EDC5A4: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EDC5A8: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EDC5AC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EDC5B0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EDC5B4: 41820018  beq 0x82edc5cc
	if ctx.cr[0].eq {
	pc = 0x82EDC5CC; continue 'dispatch;
	}
	// 82EDC5B8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EDC5BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDC5C0: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EDC5C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDC5C8: 4E800421  bctrl
	ctx.lr = 0x82EDC5CC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EDC5CC => {
    //   block [0x82EDC5CC..0x82EDC5D0)
	// 82EDC5CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82EDC5D0; continue 'dispatch;
            }
            0x82EDC5D0 => {
    //   block [0x82EDC5D0..0x82EDC5E8)
	// 82EDC5D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EDC5D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EDC5D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EDC5DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EDC5E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EDC5E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDC5E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EDC5E8 size=88
    let mut pc: u32 = 0x82EDC5E8;
    'dispatch: loop {
        match pc {
            0x82EDC5E8 => {
    //   block [0x82EDC5E8..0x82EDC624)
	// 82EDC5E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDC5EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EDC5F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EDC5F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EDC5F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDC5FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDC600: 3860010C  li r3, 0x10c
	ctx.r[3].s64 = 268;
	// 82EDC604: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EDC608: 4B73A321  bl 0x82616928
	ctx.lr = 0x82EDC60C;
	sub_82616928(ctx, base);
	// 82EDC60C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDC610: 41820014  beq 0x82edc624
	if ctx.cr[0].eq {
	pc = 0x82EDC624; continue 'dispatch;
	}
	// 82EDC614: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EDC618: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDC61C: 4BFFED55  bl 0x82edb370
	ctx.lr = 0x82EDC620;
	sub_82EDB370(ctx, base);
	// 82EDC620: 48000008  b 0x82edc628
	pc = 0x82EDC628; continue 'dispatch;
            }
            0x82EDC624 => {
    //   block [0x82EDC624..0x82EDC628)
	// 82EDC624: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EDC628; continue 'dispatch;
            }
            0x82EDC628 => {
    //   block [0x82EDC628..0x82EDC640)
	// 82EDC628: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EDC62C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EDC630: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EDC634: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EDC638: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EDC63C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDC640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EDC640 size=300
    let mut pc: u32 = 0x82EDC640;
    'dispatch: loop {
        match pc {
            0x82EDC640 => {
    //   block [0x82EDC640..0x82EDC694)
	// 82EDC640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDC644: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EDC648: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EDC64C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EDC650: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDC654: 3FC08334  lis r30, -0x7ccc
	ctx.r[30].s64 = -2093744128;
	// 82EDC658: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDC65C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDC660: 388B1BA0  addi r4, r11, 0x1ba0
	ctx.r[4].s64 = ctx.r[11].s64 + 7072;
	// 82EDC664: 807E0718  lwz r3, 0x718(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDC668: 4B38B5B9  bl 0x82267c20
	ctx.lr = 0x82EDC66C;
	sub_82267C20(ctx, base);
	// 82EDC66C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EDC670: 907F0054  stw r3, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EDC674: 807E0718  lwz r3, 0x718(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDC678: 388B8BE4  addi r4, r11, -0x741c
	ctx.r[4].s64 = ctx.r[11].s64 + -29724;
	// 82EDC67C: 4B38B5A5  bl 0x82267c20
	ctx.lr = 0x82EDC680;
	sub_82267C20(ctx, base);
	// 82EDC680: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDC684: 907F0058  stw r3, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 82EDC688: 4082000C  bne 0x82edc694
	if !ctx.cr[0].eq {
	pc = 0x82EDC694; continue 'dispatch;
	}
	// 82EDC68C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EDC690: 480000C4  b 0x82edc754
	pc = 0x82EDC754; continue 'dispatch;
            }
            0x82EDC694 => {
    //   block [0x82EDC694..0x82EDC714)
	// 82EDC694: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDC698: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EDC69C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EDC6A0: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82EDC6A4: 4B30BFD5  bl 0x821e8678
	ctx.lr = 0x82EDC6A8;
	sub_821E8678(ctx, base);
	// 82EDC6A8: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EDC6AC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDC6B0: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EDC6B4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EDC6B8: 388BC178  addi r4, r11, -0x3e88
	ctx.r[4].s64 = ctx.r[11].s64 + -16008;
	// 82EDC6BC: 915F0074  stw r10, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 82EDC6C0: 4B30BFB9  bl 0x821e8678
	ctx.lr = 0x82EDC6C4;
	sub_821E8678(ctx, base);
	// 82EDC6C4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EDC6C8: C01F004C  lfs f0, 0x4c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC6CC: C1BF0018  lfs f13, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDC6D0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82EDC6D4: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EDC6D8: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82EDC6DC: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EDC6E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDC6E4: C00B0C68  lfs f0, 0xc68(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC6E8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDC6EC: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82EDC6F0: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 82EDC6F4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EDC6F8: 23CB0001  subfic r30, r11, 1
	ctx.xer.ca = ctx.r[11].u32 <= 1 as u32;
	ctx.r[30].s64 = (1 as i64) - ctx.r[11].s64;
	// 82EDC6FC: 4B73A22D  bl 0x82616928
	ctx.lr = 0x82EDC700;
	sub_82616928(ctx, base);
	// 82EDC700: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDC704: 41820010  beq 0x82edc714
	if ctx.cr[0].eq {
	pc = 0x82EDC714; continue 'dispatch;
	}
	// 82EDC708: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EDC70C: 4BFFFCAD  bl 0x82edc3b8
	ctx.lr = 0x82EDC710;
	sub_82EDC3B8(ctx, base);
	// 82EDC710: 48000008  b 0x82edc718
	pc = 0x82EDC718; continue 'dispatch;
            }
            0x82EDC714 => {
    //   block [0x82EDC714..0x82EDC718)
	// 82EDC714: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EDC718; continue 'dispatch;
            }
            0x82EDC718 => {
    //   block [0x82EDC718..0x82EDC750)
	// 82EDC718: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDC71C: C19F0050  lfs f12, 0x50(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDC720: 907F00CC  stw r3, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[3].u32 ) };
	// 82EDC724: C1AB0C18  lfs f13, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDC728: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82EDC72C: 419A0024  beq cr6, 0x82edc750
	if ctx.cr[6].eq {
	pc = 0x82EDC750; continue 'dispatch;
	}
	// 82EDC730: C01F0048  lfs f0, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC734: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EDC738: 419A0018  beq cr6, 0x82edc750
	if ctx.cr[6].eq {
	pc = 0x82EDC750; continue 'dispatch;
	}
	// 82EDC73C: EDA00332  fmuls f13, f0, f12
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EDC740: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDC744: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC748: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EDC74C: D01F00FC  stfs f0, 0xfc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	pc = 0x82EDC750; continue 'dispatch;
            }
            0x82EDC750 => {
    //   block [0x82EDC750..0x82EDC754)
	// 82EDC750: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EDC754; continue 'dispatch;
            }
            0x82EDC754 => {
    //   block [0x82EDC754..0x82EDC76C)
	// 82EDC754: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EDC758: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EDC75C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EDC760: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EDC764: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EDC768: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDC770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EDC770 size=96
    let mut pc: u32 = 0x82EDC770;
    'dispatch: loop {
        match pc {
            0x82EDC770 => {
    //   block [0x82EDC770..0x82EDC7B0)
	// 82EDC770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDC774: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EDC778: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EDC77C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDC780: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDC784: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDC788: 396B1C9C  addi r11, r11, 0x1c9c
	ctx.r[11].s64 = ctx.r[11].s64 + 7324;
	// 82EDC78C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDC790: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDC794: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EDC798: 41820018  beq 0x82edc7b0
	if ctx.cr[0].eq {
	pc = 0x82EDC7B0; continue 'dispatch;
	}
	// 82EDC79C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EDC7A0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EDC7A4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EDC7A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDC7AC: 4E800421  bctrl
	ctx.lr = 0x82EDC7B0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EDC7B0 => {
    //   block [0x82EDC7B0..0x82EDC7D0)
	// 82EDC7B0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EDC7B4: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EDC7B8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EDC7BC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EDC7C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EDC7C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EDC7C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EDC7CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDC7D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EDC7D0 size=120
    let mut pc: u32 = 0x82EDC7D0;
    'dispatch: loop {
        match pc {
            0x82EDC7D0 => {
    //   block [0x82EDC7D0..0x82EDC7F0)
	// 82EDC7D0: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDC7D4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EDC7D8: 994B0024  stb r10, 0x24(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[10].u8 ) };
	// 82EDC7DC: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDC7E0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EDC7E4: 409A000C  bne cr6, 0x82edc7f0
	if !ctx.cr[6].eq {
	pc = 0x82EDC7F0; continue 'dispatch;
	}
	// 82EDC7E8: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EDC7EC: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x82EDC7F0; continue 'dispatch;
            }
            0x82EDC7F0 => {
    //   block [0x82EDC7F0..0x82EDC804)
	// 82EDC7F0: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EDC7F4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EDC7F8: 409A000C  bne cr6, 0x82edc804
	if !ctx.cr[6].eq {
	pc = 0x82EDC804; continue 'dispatch;
	}
	// 82EDC7FC: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EDC800: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	pc = 0x82EDC804; continue 'dispatch;
            }
            0x82EDC804 => {
    //   block [0x82EDC804..0x82EDC818)
	// 82EDC804: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EDC808: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDC80C: 4182000C  beq 0x82edc818
	if ctx.cr[0].eq {
	pc = 0x82EDC818; continue 'dispatch;
	}
	// 82EDC810: 812B0020  lwz r9, 0x20(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EDC814: 912A0020  stw r9, 0x20(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	pc = 0x82EDC818; continue 'dispatch;
            }
            0x82EDC818 => {
    //   block [0x82EDC818..0x82EDC82C)
	// 82EDC818: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EDC81C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDC820: 4182000C  beq 0x82edc82c
	if ctx.cr[0].eq {
	pc = 0x82EDC82C; continue 'dispatch;
	}
	// 82EDC824: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EDC828: 912A001C  stw r9, 0x1c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	pc = 0x82EDC82C; continue 'dispatch;
            }
            0x82EDC82C => {
    //   block [0x82EDC82C..0x82EDC848)
	// 82EDC82C: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EDC830: 914B0020  stw r10, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 82EDC834: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EDC838: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EDC83C: 396AFFFF  addi r11, r10, -1
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	// 82EDC840: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82EDC844: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDC848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EDC848 size=88
    let mut pc: u32 = 0x82EDC848;
    'dispatch: loop {
        match pc {
            0x82EDC848 => {
    //   block [0x82EDC848..0x82EDC884)
	// 82EDC848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDC84C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EDC850: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EDC854: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EDC858: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDC85C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDC860: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EDC864: 4BFFFF0D  bl 0x82edc770
	ctx.lr = 0x82EDC868;
	sub_82EDC770(ctx, base);
	// 82EDC868: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDC86C: 41820018  beq 0x82edc884
	if ctx.cr[0].eq {
	pc = 0x82EDC884; continue 'dispatch;
	}
	// 82EDC870: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EDC874: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDC878: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EDC87C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDC880: 4E800421  bctrl
	ctx.lr = 0x82EDC884;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EDC884 => {
    //   block [0x82EDC884..0x82EDC8A0)
	// 82EDC884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDC888: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EDC88C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EDC890: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EDC894: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EDC898: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EDC89C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDC8A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EDC8A0 size=100
    let mut pc: u32 = 0x82EDC8A0;
    'dispatch: loop {
        match pc {
            0x82EDC8A0 => {
    //   block [0x82EDC8A0..0x82EDC8A8)
	// 82EDC8A0: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDC8A4: 48000020  b 0x82edc8c4
	pc = 0x82EDC8C4; continue 'dispatch;
            }
            0x82EDC8A8 => {
    //   block [0x82EDC8A8..0x82EDC8C4)
	// 82EDC8A8: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC8AC: FF001800  fcmpu cr6, f0, f3
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[3].f64);
	// 82EDC8B0: 41990024  bgt cr6, 0x82edc8d4
	if ctx.cr[6].gt {
	pc = 0x82EDC8D4; continue 'dispatch;
	}
	// 82EDC8B4: 80C80004  lwz r6, 4(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDC8B8: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82EDC8BC: 419A0010  beq cr6, 0x82edc8cc
	if ctx.cr[6].eq {
	pc = 0x82EDC8CC; continue 'dispatch;
	}
	// 82EDC8C0: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	pc = 0x82EDC8C4; continue 'dispatch;
            }
            0x82EDC8C4 => {
    //   block [0x82EDC8C4..0x82EDC8CC)
	// 82EDC8C4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDC8C8: 4082FFE0  bne 0x82edc8a8
	if !ctx.cr[0].eq {
	pc = 0x82EDC8A8; continue 'dispatch;
	}
	pc = 0x82EDC8CC; continue 'dispatch;
            }
            0x82EDC8CC => {
    //   block [0x82EDC8CC..0x82EDC8D4)
	// 82EDC8CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EDC8D0: 48000020  b 0x82edc8f0
	pc = 0x82EDC8F0; continue 'dispatch;
            }
            0x82EDC8D4 => {
    //   block [0x82EDC8D4..0x82EDC8E4)
	// 82EDC8D4: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC8D8: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82EDC8DC: 41990008  bgt cr6, 0x82edc8e4
	if ctx.cr[6].gt {
	pc = 0x82EDC8E4; continue 'dispatch;
	}
	// 82EDC8E0: FC000890  fmr f0, f1
	ctx.f[0].f64 = ctx.f[1].f64;
	pc = 0x82EDC8E4; continue 'dispatch;
            }
            0x82EDC8E4 => {
    //   block [0x82EDC8E4..0x82EDC8F0)
	// 82EDC8E4: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EDC8E8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EDC8EC: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82EDC8F0; continue 'dispatch;
            }
            0x82EDC8F0 => {
    //   block [0x82EDC8F0..0x82EDC904)
	// 82EDC8F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EDC8F4: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EDC8F8: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EDC8FC: 91680000  stw r11, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EDC900: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDC908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EDC908 size=100
    let mut pc: u32 = 0x82EDC908;
    'dispatch: loop {
        match pc {
            0x82EDC908 => {
    //   block [0x82EDC908..0x82EDC910)
	// 82EDC908: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDC90C: 48000020  b 0x82edc92c
	pc = 0x82EDC92C; continue 'dispatch;
            }
            0x82EDC910 => {
    //   block [0x82EDC910..0x82EDC92C)
	// 82EDC910: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC914: FF001800  fcmpu cr6, f0, f3
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[3].f64);
	// 82EDC918: 41980024  blt cr6, 0x82edc93c
	if ctx.cr[6].lt {
	pc = 0x82EDC93C; continue 'dispatch;
	}
	// 82EDC91C: 80C80004  lwz r6, 4(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDC920: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82EDC924: 419A0010  beq cr6, 0x82edc934
	if ctx.cr[6].eq {
	pc = 0x82EDC934; continue 'dispatch;
	}
	// 82EDC928: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	pc = 0x82EDC92C; continue 'dispatch;
            }
            0x82EDC92C => {
    //   block [0x82EDC92C..0x82EDC934)
	// 82EDC92C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDC930: 4082FFE0  bne 0x82edc910
	if !ctx.cr[0].eq {
	pc = 0x82EDC910; continue 'dispatch;
	}
	pc = 0x82EDC934; continue 'dispatch;
            }
            0x82EDC934 => {
    //   block [0x82EDC934..0x82EDC93C)
	// 82EDC934: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EDC938: 48000020  b 0x82edc958
	pc = 0x82EDC958; continue 'dispatch;
            }
            0x82EDC93C => {
    //   block [0x82EDC93C..0x82EDC94C)
	// 82EDC93C: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDC940: FF001000  fcmpu cr6, f0, f2
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[2].f64);
	// 82EDC944: 41980008  blt cr6, 0x82edc94c
	if ctx.cr[6].lt {
	pc = 0x82EDC94C; continue 'dispatch;
	}
	// 82EDC948: FC001090  fmr f0, f2
	ctx.f[0].f64 = ctx.f[2].f64;
	pc = 0x82EDC94C; continue 'dispatch;
            }
            0x82EDC94C => {
    //   block [0x82EDC94C..0x82EDC958)
	// 82EDC94C: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EDC950: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EDC954: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82EDC958; continue 'dispatch;
            }
            0x82EDC958 => {
    //   block [0x82EDC958..0x82EDC96C)
	// 82EDC958: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EDC95C: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EDC960: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EDC964: 91680000  stw r11, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EDC968: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDC970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EDC970 size=320
    let mut pc: u32 = 0x82EDC970;
    'dispatch: loop {
        match pc {
            0x82EDC970 => {
    //   block [0x82EDC970..0x82EDC9D0)
	// 82EDC970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDC974: 4BDCCA99  bl 0x82ca940c
	ctx.lr = 0x82EDC978;
	sub_82CA93D0(ctx, base);
	// 82EDC978: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDC97C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDC980: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDC984: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EDC988: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EDC98C: 396BA2F0  addi r11, r11, -0x5d10
	ctx.r[11].s64 = ctx.r[11].s64 + -23824;
	// 82EDC990: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82EDC994: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82EDC998: 93BF0014  stw r29, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 82EDC99C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EDC9A0: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82EDC9A4: 93BF0010  stw r29, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 82EDC9A8: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82EDC9AC: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82EDC9B0: 419A00F4  beq cr6, 0x82edcaa4
	if ctx.cr[6].eq {
	pc = 0x82EDCAA4; continue 'dispatch;
	}
	// 82EDC9B4: 3D600666  lis r11, 0x666
	ctx.r[11].s64 = 107347968;
	// 82EDC9B8: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82EDC9BC: 616B6666  ori r11, r11, 0x6666
	ctx.r[11].u64 = ctx.r[11].u64 | 26214;
	// 82EDC9C0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EDC9C4: 1D7E0028  mulli r11, r30, 0x28
	ctx.r[11].s32 = ((ctx.r[30].s32 as i64 * 40 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EDC9C8: 40990008  ble cr6, 0x82edc9d0
	if !ctx.cr[6].gt {
	pc = 0x82EDC9D0; continue 'dispatch;
	}
	// 82EDC9CC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x82EDC9D0; continue 'dispatch;
            }
            0x82EDC9D0 => {
    //   block [0x82EDC9D0..0x82EDC9E0)
	// 82EDC9D0: 3940FFFB  li r10, -5
	ctx.r[10].s64 = -5;
	// 82EDC9D4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EDC9D8: 41990008  bgt cr6, 0x82edc9e0
	if ctx.cr[6].gt {
	pc = 0x82EDC9E0; continue 'dispatch;
	}
	// 82EDC9DC: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	pc = 0x82EDC9E0; continue 'dispatch;
            }
            0x82EDC9E0 => {
    //   block [0x82EDC9E0..0x82EDCA10)
	// 82EDC9E0: 4B739F49  bl 0x82616928
	ctx.lr = 0x82EDC9E4;
	sub_82616928(ctx, base);
	// 82EDC9E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDC9E8: 41820050  beq 0x82edca38
	if ctx.cr[0].eq {
	pc = 0x82EDCA38; continue 'dispatch;
	}
	// 82EDC9EC: 38E30004  addi r7, r3, 4
	ctx.r[7].s64 = ctx.r[3].s64 + 4;
	// 82EDC9F0: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82EDC9F4: 355EFFFF  addic. r10, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EDC9F8: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 82EDC9FC: 41800034  blt 0x82edca30
	if ctx.cr[0].lt {
	pc = 0x82EDCA30; continue 'dispatch;
	}
	// 82EDCA00: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EDCA04: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82EDCA08: 3929AFB4  addi r9, r9, -0x504c
	ctx.r[9].s64 = ctx.r[9].s64 + -20556;
	// 82EDCA0C: 3908BD48  addi r8, r8, -0x42b8
	ctx.r[8].s64 = ctx.r[8].s64 + -17080;
	pc = 0x82EDCA10; continue 'dispatch;
            }
            0x82EDCA10 => {
    //   block [0x82EDCA10..0x82EDCA30)
	// 82EDCA10: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82EDCA14: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EDCA18: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EDCA1C: 93AB001C  stw r29, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 82EDCA20: 93AB0020  stw r29, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u32 ) };
	// 82EDCA24: 9BAB0024  stb r29, 0x24(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[29].u8 ) };
	// 82EDCA28: 396B0028  addi r11, r11, 0x28
	ctx.r[11].s64 = ctx.r[11].s64 + 40;
	// 82EDCA2C: 4080FFE4  bge 0x82edca10
	if !ctx.cr[0].lt {
	pc = 0x82EDCA10; continue 'dispatch;
	}
	pc = 0x82EDCA30; continue 'dispatch;
            }
            0x82EDCA30 => {
    //   block [0x82EDCA30..0x82EDCA38)
	// 82EDCA30: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 82EDCA34: 48000008  b 0x82edca3c
	pc = 0x82EDCA3C; continue 'dispatch;
            }
            0x82EDCA38 => {
    //   block [0x82EDCA38..0x82EDCA3C)
	// 82EDCA38: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82EDCA3C; continue 'dispatch;
            }
            0x82EDCA3C => {
    //   block [0x82EDCA3C..0x82EDCA5C)
	// 82EDCA3C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EDCA40: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EDCA44: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82EDCA48: 93AB001C  stw r29, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 82EDCA4C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EDCA50: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EDCA54: 4099003C  ble cr6, 0x82edca90
	if !ctx.cr[6].gt {
	pc = 0x82EDCA90; continue 'dispatch;
	}
	// 82EDCA58: 39600028  li r11, 0x28
	ctx.r[11].s64 = 40;
	pc = 0x82EDCA5C; continue 'dispatch;
            }
            0x82EDCA5C => {
    //   block [0x82EDCA5C..0x82EDCA90)
	// 82EDCA5C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDCA60: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EDCA64: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EDCA68: 3909FFD8  addi r8, r9, -0x28
	ctx.r[8].s64 = ctx.r[9].s64 + -40;
	// 82EDCA6C: 9109001C  stw r8, 0x1c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[8].u32 ) };
	// 82EDCA70: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDCA74: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EDCA78: 396B0028  addi r11, r11, 0x28
	ctx.r[11].s64 = ctx.r[11].s64 + 40;
	// 82EDCA7C: 8109001C  lwz r8, 0x1c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EDCA80: 91280020  stw r9, 0x20(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 82EDCA84: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EDCA88: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82EDCA8C: 4198FFD0  blt cr6, 0x82edca5c
	if ctx.cr[6].lt {
	pc = 0x82EDCA5C; continue 'dispatch;
	}
	pc = 0x82EDCA90; continue 'dispatch;
            }
            0x82EDCA90 => {
    //   block [0x82EDCA90..0x82EDCAA4)
	// 82EDCA90: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EDCA94: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDCA98: 1D6B0028  mulli r11, r11, 0x28
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 40 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EDCA9C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EDCAA0: 93ABFFF8  stw r29, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[29].u32 ) };
	pc = 0x82EDCAA4; continue 'dispatch;
            }
            0x82EDCAA4 => {
    //   block [0x82EDCAA4..0x82EDCAB0)
	// 82EDCAA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDCAA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EDCAAC: 4BDCC9B0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDCAB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EDCAB0 size=192
    let mut pc: u32 = 0x82EDCAB0;
    'dispatch: loop {
        match pc {
            0x82EDCAB0 => {
    //   block [0x82EDCAB0..0x82EDCAF0)
	// 82EDCAB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDCAB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EDCAB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EDCABC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EDCAC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDCAC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDCAC8: 548B07BD  rlwinm. r11, r4, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDCACC: 4182005C  beq 0x82edcb28
	if ctx.cr[0].eq {
	pc = 0x82EDCB28; continue 'dispatch;
	}
	// 82EDCAD0: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EDCAD4: 3BDFFFFC  addi r30, r31, -4
	ctx.r[30].s64 = ctx.r[31].s64 + -4;
	// 82EDCAD8: 1D4B0028  mulli r10, r11, 0x28
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 40 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EDCADC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDCAE0: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82EDCAE4: 41800020  blt 0x82edcb04
	if ctx.cr[0].lt {
	pc = 0x82EDCB04; continue 'dispatch;
	}
	// 82EDCAE8: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82EDCAEC: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	pc = 0x82EDCAF0; continue 'dispatch;
            }
            0x82EDCAF0 => {
    //   block [0x82EDCAF0..0x82EDCB04)
	// 82EDCAF0: 394AFFD8  addi r10, r10, -0x28
	ctx.r[10].s64 = ctx.r[10].s64 + -40;
	// 82EDCAF4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDCAF8: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EDCAFC: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EDCB00: 4080FFF0  bge 0x82edcaf0
	if !ctx.cr[0].lt {
	pc = 0x82EDCAF0; continue 'dispatch;
	}
	pc = 0x82EDCB04; continue 'dispatch;
            }
            0x82EDCB04 => {
    //   block [0x82EDCB04..0x82EDCB20)
	// 82EDCB04: 548B07FF  clrlwi. r11, r4, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDCB08: 41820018  beq 0x82edcb20
	if ctx.cr[0].eq {
	pc = 0x82EDCB20; continue 'dispatch;
	}
	// 82EDCB0C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EDCB10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDCB14: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EDCB18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDCB1C: 4E800421  bctrl
	ctx.lr = 0x82EDCB20;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EDCB20 => {
    //   block [0x82EDCB20..0x82EDCB28)
	// 82EDCB20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDCB24: 48000034  b 0x82edcb58
	pc = 0x82EDCB58; continue 'dispatch;
            }
            0x82EDCB28 => {
    //   block [0x82EDCB28..0x82EDCB54)
	// 82EDCB28: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EDCB2C: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EDCB30: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EDCB34: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EDCB38: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EDCB3C: 41820018  beq 0x82edcb54
	if ctx.cr[0].eq {
	pc = 0x82EDCB54; continue 'dispatch;
	}
	// 82EDCB40: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EDCB44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDCB48: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EDCB4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDCB50: 4E800421  bctrl
	ctx.lr = 0x82EDCB54;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EDCB54 => {
    //   block [0x82EDCB54..0x82EDCB58)
	// 82EDCB54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82EDCB58; continue 'dispatch;
            }
            0x82EDCB58 => {
    //   block [0x82EDCB58..0x82EDCB70)
	// 82EDCB58: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EDCB5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EDCB60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EDCB64: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EDCB68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EDCB6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDCB70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EDCB70 size=152
    let mut pc: u32 = 0x82EDCB70;
    'dispatch: loop {
        match pc {
            0x82EDCB70 => {
    //   block [0x82EDCB70..0x82EDCB90)
	// 82EDCB70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDCB74: 4BDCC899  bl 0x82ca940c
	ctx.lr = 0x82EDCB78;
	sub_82CA93D0(ctx, base);
	// 82EDCB78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDCB7C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EDCB80: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EDCB84: 4B73CAB5  bl 0x82619638
	ctx.lr = 0x82EDCB88;
	sub_82619638(ctx, base);
	// 82EDCB88: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDCB8C: 4182000C  beq 0x82edcb98
	if ctx.cr[0].eq {
	pc = 0x82EDCB98; continue 'dispatch;
	}
	pc = 0x82EDCB90; continue 'dispatch;
            }
            0x82EDCB90 => {
    //   block [0x82EDCB90..0x82EDCB98)
	// 82EDCB90: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EDCB94: 4800006C  b 0x82edcc00
	pc = 0x82EDCC00; continue 'dispatch;
            }
            0x82EDCB98 => {
    //   block [0x82EDCB98..0x82EDCBF0)
	// 82EDCB98: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDCB9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDCBA0: 3BCBBD4C  addi r30, r11, -0x42b4
	ctx.r[30].s64 = ctx.r[11].s64 + -17076;
	// 82EDCBA4: 482DF4BD  bl 0x831bc060
	ctx.lr = 0x82EDCBA8;
	sub_831BC060(ctx, base);
	// 82EDCBA8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EDCBAC: 4BDCFFA5  bl 0x82cacb50
	ctx.lr = 0x82EDCBB0;
	sub_82CACB50(ctx, base);
	// 82EDCBB0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDCBB4: 40820048  bne 0x82edcbfc
	if !ctx.cr[0].eq {
	pc = 0x82EDCBFC; continue 'dispatch;
	}
	// 82EDCBB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDCBBC: 4BA3114D  bl 0x8290dd08
	ctx.lr = 0x82EDCBC0;
	sub_8290DD08(ctx, base);
	// 82EDCBC0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDCBC4: 4182FFCC  beq 0x82edcb90
	if ctx.cr[0].eq {
	pc = 0x82EDCB90; continue 'dispatch;
	}
	// 82EDCBC8: 4BDCD7F9  bl 0x82caa3c0
	ctx.lr = 0x82EDCBCC;
	sub_82CAA3C0(ctx, base);
	// 82EDCBCC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EDCBD0: 4081FFC0  ble 0x82edcb90
	if !ctx.cr[0].gt {
	pc = 0x82EDCB90; continue 'dispatch;
	}
	// 82EDCBD4: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82EDCBD8: 4B739D51  bl 0x82616928
	ctx.lr = 0x82EDCBDC;
	sub_82616928(ctx, base);
	// 82EDCBDC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDCBE0: 41820010  beq 0x82edcbf0
	if ctx.cr[0].eq {
	pc = 0x82EDCBF0; continue 'dispatch;
	}
	// 82EDCBE4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDCBE8: 4BFFFD89  bl 0x82edc970
	ctx.lr = 0x82EDCBEC;
	sub_82EDC970(ctx, base);
	// 82EDCBEC: 48000008  b 0x82edcbf4
	pc = 0x82EDCBF4; continue 'dispatch;
            }
            0x82EDCBF0 => {
    //   block [0x82EDCBF0..0x82EDCBF4)
	// 82EDCBF0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EDCBF4; continue 'dispatch;
            }
            0x82EDCBF4 => {
    //   block [0x82EDCBF4..0x82EDCBFC)
	// 82EDCBF4: 907D0004  stw r3, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82EDCBF8: 4BFFFF98  b 0x82edcb90
	pc = 0x82EDCB90; continue 'dispatch;
            }
            0x82EDCBFC => {
    //   block [0x82EDCBFC..0x82EDCC00)
	// 82EDCBFC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EDCC00; continue 'dispatch;
            }
            0x82EDCC00 => {
    //   block [0x82EDCC00..0x82EDCC08)
	// 82EDCC00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EDCC04: 4BDCC858  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDCC08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EDCC08 size=52
    let mut pc: u32 = 0x82EDCC08;
    'dispatch: loop {
        match pc {
            0x82EDCC08 => {
    //   block [0x82EDCC08..0x82EDCC3C)
	// 82EDCC08: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EDCC0C: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDCC10: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDCC14: 40820028  bne 0x82edcc3c
	if !ctx.cr[0].eq {
		sub_82EDCC3C(ctx, base);
		return;
	}
	// 82EDCC18: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDCC1C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82EDCC20: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EDCC24: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 82EDCC28: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EDCC2C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EDCC30: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EDCC34: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EDCC38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDCC3C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EDCC3C size=224
    let mut pc: u32 = 0x82EDCC3C;
    'dispatch: loop {
        match pc {
            0x82EDCC3C => {
    //   block [0x82EDCC3C..0x82EDCCBC)
	// 82EDCC3C: 81240014  lwz r9, 0x14(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EDCC40: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82EDCC44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EDCC48: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EDCC4C: 91240014  stw r9, 0x14(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82EDCC50: 812B0020  lwz r9, 0x20(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EDCC54: 91240010  stw r9, 0x10(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82EDCC58: C0050004  lfs f0, 4(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDCC5C: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EDCC60: C0050008  lfs f0, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDCC64: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EDCC68: C005000C  lfs f0, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDCC6C: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EDCC70: C0050010  lfs f0, 0x10(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDCC74: D00B0014  stfs f0, 0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EDCC78: 89250014  lbz r9, 0x14(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EDCC7C: 992B0018  stb r9, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[9].u8 ) };
	// 82EDCC80: 990B0024  stb r8, 0x24(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[8].u8 ) };
	// 82EDCC84: 409A0054  bne cr6, 0x82edccd8
	if !ctx.cr[6].eq {
	pc = 0x82EDCCD8; continue 'dispatch;
	}
	// 82EDCC88: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EDCC8C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDCC90: 4082002C  bne 0x82edccbc
	if !ctx.cr[0].eq {
	pc = 0x82EDCCBC; continue 'dispatch;
	}
	// 82EDCC94: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EDCC98: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EDCC9C: 914B0020  stw r10, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 82EDCCA0: 81240008  lwz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDCCA4: 9149001C  stw r10, 0x1c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82EDCCA8: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EDCCAC: 9149001C  stw r10, 0x1c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82EDCCB0: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EDCCB4: 91490020  stw r10, 0x20(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 82EDCCB8: 48000044  b 0x82edccfc
	pc = 0x82EDCCFC; continue 'dispatch;
            }
            0x82EDCCBC => {
    //   block [0x82EDCCBC..0x82EDCCD8)
	// 82EDCCBC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EDCCC0: 914B001C  stw r10, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82EDCCC4: 912B0020  stw r9, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 82EDCCC8: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EDCCCC: 916A0020  stw r11, 0x20(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82EDCCD0: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EDCCD4: 48000028  b 0x82edccfc
	pc = 0x82EDCCFC; continue 'dispatch;
            }
            0x82EDCCD8 => {
    //   block [0x82EDCCD8..0x82EDCCF8)
	// 82EDCCD8: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EDCCDC: 914B0020  stw r10, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 82EDCCE0: 916A001C  stw r11, 0x1c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82EDCCE4: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDCCE8: 912B001C  stw r9, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 82EDCCEC: 4182000C  beq 0x82edccf8
	if ctx.cr[0].eq {
	pc = 0x82EDCCF8; continue 'dispatch;
	}
	// 82EDCCF0: 91690020  stw r11, 0x20(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82EDCCF4: 48000008  b 0x82edccfc
	pc = 0x82EDCCFC; continue 'dispatch;
            }
            0x82EDCCF8 => {
    //   block [0x82EDCCF8..0x82EDCCFC)
	// 82EDCCF8: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82EDCCFC; continue 'dispatch;
            }
            0x82EDCCFC => {
    //   block [0x82EDCCFC..0x82EDCD1C)
	// 82EDCCFC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EDCD00: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EDCD04: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82EDCD08: 394AAFB4  addi r10, r10, -0x504c
	ctx.r[10].s64 = ctx.r[10].s64 + -20556;
	// 82EDCD0C: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	// 82EDCD10: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EDCD14: 91260000  stw r9, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EDCD18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDCD20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EDCD20 size=72
    let mut pc: u32 = 0x82EDCD20;
    'dispatch: loop {
        match pc {
            0x82EDCD20 => {
    //   block [0x82EDCD20..0x82EDCD54)
	// 82EDCD20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDCD24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EDCD28: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDCD2C: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82EDCD30: 4B739BF9  bl 0x82616928
	ctx.lr = 0x82EDCD34;
	sub_82616928(ctx, base);
	// 82EDCD34: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDCD38: 4182001C  beq 0x82edcd54
	if ctx.cr[0].eq {
	pc = 0x82EDCD54; continue 'dispatch;
	}
	// 82EDCD3C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDCD40: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EDCD44: 396B1C9C  addi r11, r11, 0x1c9c
	ctx.r[11].s64 = ctx.r[11].s64 + 7324;
	// 82EDCD48: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EDCD4C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EDCD50: 48000008  b 0x82edcd58
	pc = 0x82EDCD58; continue 'dispatch;
            }
            0x82EDCD54 => {
    //   block [0x82EDCD54..0x82EDCD58)
	// 82EDCD54: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EDCD58; continue 'dispatch;
            }
            0x82EDCD58 => {
    //   block [0x82EDCD58..0x82EDCD68)
	// 82EDCD58: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EDCD5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EDCD60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EDCD64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDCD68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EDCD68 size=236
    let mut pc: u32 = 0x82EDCD68;
    'dispatch: loop {
        match pc {
            0x82EDCD68 => {
    //   block [0x82EDCD68..0x82EDCDAC)
	// 82EDCD68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDCD6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EDCD70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EDCD74: DBA1FFD8  stfd f29, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[29].u64 ) };
	// 82EDCD78: DBC1FFE0  stfd f30, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 82EDCD7C: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82EDCD80: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDCD84: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EDCD88: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82EDCD8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDCD90: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 82EDCD94: FFA01890  fmr f29, f3
	ctx.f[29].f64 = ctx.f[3].f64;
	// 82EDCD98: C00A0BEC  lfs f0, 0xbec(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDCD9C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EDCDA0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDCDA4: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EDCDA8: 48000028  b 0x82edcdd0
	pc = 0x82EDCDD0; continue 'dispatch;
            }
            0x82EDCDAC => {
    //   block [0x82EDCDAC..0x82EDCDD0)
	// 82EDCDAC: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDCDB0: 99490024  stb r10, 0x24(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), ctx.r[10].u8 ) };
	// 82EDCDB4: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDCDB8: 80EB0010  lwz r7, 0x10(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EDCDBC: 81090020  lwz r8, 0x20(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EDCDC0: 90E90020  stw r7, 0x20(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[7].u32 ) };
	// 82EDCDC4: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDCDC8: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82EDCDCC: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	pc = 0x82EDCDD0; continue 'dispatch;
            }
            0x82EDCDD0 => {
    //   block [0x82EDCDD0..0x82EDCE54)
	// 82EDCDD0: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDCDD4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EDCDD8: 409AFFD4  bne cr6, 0x82edcdac
	if !ctx.cr[6].eq {
	pc = 0x82EDCDAC; continue 'dispatch;
	}
	// 82EDCDDC: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EDCDE0: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EDCDE4: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82EDCDE8: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82EDCDEC: 3929AFB4  addi r9, r9, -0x504c
	ctx.r[9].s64 = ctx.r[9].s64 + -20556;
	// 82EDCDF0: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDCDF4: 3908AFB4  addi r8, r8, -0x504c
	ctx.r[8].s64 = ctx.r[8].s64 + -20556;
	// 82EDCDF8: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EDCDFC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EDCE00: D3C10068  stfs f30, 0x68(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EDCE04: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82EDCE08: D3A1006C  stfs f29, 0x6c(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82EDCE0C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EDCE10: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82EDCE14: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82EDCE18: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82EDCE1C: 91010060  stw r8, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 82EDCE20: 99410074  stb r10, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u8 ) };
	// 82EDCE24: 4BFFFDE5  bl 0x82edcc08
	ctx.lr = 0x82EDCE28;
	sub_82EDCC08(ctx, base);
	// 82EDCE28: D3BF0014  stfs f29, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EDCE2C: D3FF0008  stfs f31, 8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EDCE30: D3DF000C  stfs f30, 0xc(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EDCE34: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82EDCE38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EDCE3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EDCE40: CBA1FFD8  lfd f29, -0x28(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82EDCE44: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82EDCE48: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EDCE4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EDCE50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDCE58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EDCE58 size=1384
    let mut pc: u32 = 0x82EDCE58;
    'dispatch: loop {
        match pc {
            0x82EDCE58 => {
    //   block [0x82EDCE58..0x82EDCE80)
	// 82EDCE58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDCE5C: 4BDCC591  bl 0x82ca93ec
	ctx.lr = 0x82EDCE60;
	sub_82CA93D0(ctx, base);
	// 82EDCE60: 3981FFA0  addi r12, r1, -0x60
	ctx.r[12].s64 = ctx.r[1].s64 + -96;
	// 82EDCE64: 4BDD0E6D  bl 0x82cadcd0
	ctx.lr = 0x82EDCE68;
	sub_82CADCA0(ctx, base);
	// 82EDCE68: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDCE6C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EDCE70: C3A4000C  lfs f29, 0xc(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EDCE74: C01C0014  lfs f0, 0x14(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDCE78: FF1D0000  fcmpu cr6, f29, f0
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[0].f64);
	// 82EDCE7C: 4099000C  ble cr6, 0x82edce88
	if !ctx.cr[6].gt {
	pc = 0x82EDCE88; continue 'dispatch;
	}
	pc = 0x82EDCE80; continue 'dispatch;
            }
            0x82EDCE80 => {
    //   block [0x82EDCE80..0x82EDCE88)
	// 82EDCE80: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EDCE84: 4800052C  b 0x82edd3b0
	pc = 0x82EDD3B0; continue 'dispatch;
            }
            0x82EDCE88 => {
    //   block [0x82EDCE88..0x82EDCEDC)
	// 82EDCE88: C3C40004  lfs f30, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EDCE8C: 8AA40014  lbz r21, 0x14(r4)
	ctx.r[21].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EDCE90: C01C0008  lfs f0, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDCE94: C3840008  lfs f28, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EDCE98: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 82EDCE9C: C3440010  lfs f26, 0x10(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82EDCEA0: 4198050C  blt cr6, 0x82edd3ac
	if ctx.cr[6].lt {
	pc = 0x82EDD3AC; continue 'dispatch;
	}
	// 82EDCEA4: FF1EE000  fcmpu cr6, f30, f28
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[28].f64);
	// 82EDCEA8: 40980504  bge cr6, 0x82edd3ac
	if !ctx.cr[6].lt {
	pc = 0x82EDD3AC; continue 'dispatch;
	}
	// 82EDCEAC: C01C000C  lfs f0, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDCEB0: FF1C0000  fcmpu cr6, f28, f0
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[0].f64);
	// 82EDCEB4: 419904F8  bgt cr6, 0x82edd3ac
	if ctx.cr[6].gt {
	pc = 0x82EDD3AC; continue 'dispatch;
	}
	// 82EDCEB8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDCEBC: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EDCEC0: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EDCEC4: 394AFFFD  addi r10, r10, -3
	ctx.r[10].s64 = ctx.r[10].s64 + -3;
	// 82EDCEC8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EDCECC: 419904E0  bgt cr6, 0x82edd3ac
	if ctx.cr[6].gt {
	pc = 0x82EDD3AC; continue 'dispatch;
	}
	// 82EDCED0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDCED4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDCED8: 418204D4  beq 0x82edd3ac
	if ctx.cr[0].eq {
	pc = 0x82EDD3AC; continue 'dispatch;
	}
	pc = 0x82EDCEDC; continue 'dispatch;
            }
            0x82EDCEDC => {
    //   block [0x82EDCEDC..0x82EDCEF4)
	// 82EDCEDC: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDCEE0: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 82EDCEE4: 41980010  blt cr6, 0x82edcef4
	if ctx.cr[6].lt {
	pc = 0x82EDCEF4; continue 'dispatch;
	}
	// 82EDCEE8: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EDCEEC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDCEF0: 4082FFEC  bne 0x82edcedc
	if !ctx.cr[0].eq {
	pc = 0x82EDCEDC; continue 'dispatch;
	}
	pc = 0x82EDCEF4; continue 'dispatch;
            }
            0x82EDCEF4 => {
    //   block [0x82EDCEF4..0x82EDCF00)
	// 82EDCEF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EDCEF8: 419A04B4  beq cr6, 0x82edd3ac
	if ctx.cr[6].eq {
	pc = 0x82EDD3AC; continue 'dispatch;
	}
	// 82EDCEFC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	pc = 0x82EDCF00; continue 'dispatch;
            }
            0x82EDCF00 => {
    //   block [0x82EDCF00..0x82EDCF18)
	// 82EDCF00: C01F000C  lfs f0, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDCF04: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 82EDCF08: 40980010  bge cr6, 0x82edcf18
	if !ctx.cr[6].lt {
	pc = 0x82EDCF18; continue 'dispatch;
	}
	// 82EDCF0C: 83FF0020  lwz r31, 0x20(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EDCF10: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDCF14: 4082FFEC  bne 0x82edcf00
	if !ctx.cr[0].eq {
	pc = 0x82EDCF00; continue 'dispatch;
	}
	pc = 0x82EDCF18; continue 'dispatch;
            }
            0x82EDCF18 => {
    //   block [0x82EDCF18..0x82EDCF2C)
	// 82EDCF18: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82EDCF1C: 419A0490  beq cr6, 0x82edd3ac
	if ctx.cr[6].eq {
	pc = 0x82EDD3AC; continue 'dispatch;
	}
	// 82EDCF20: 56AA063F  clrlwi. r10, r21, 0x18
	ctx.r[10].u64 = ctx.r[21].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EDCF24: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EDCF28: 41820030  beq 0x82edcf58
	if ctx.cr[0].eq {
	pc = 0x82EDCF58; continue 'dispatch;
	}
	pc = 0x82EDCF2C; continue 'dispatch;
            }
            0x82EDCF2C => {
    //   block [0x82EDCF2C..0x82EDCF40)
	// 82EDCF2C: C00A0010  lfs f0, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDCF30: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82EDCF34: 4098000C  bge cr6, 0x82edcf40
	if !ctx.cr[6].lt {
	pc = 0x82EDCF40; continue 'dispatch;
	}
	// 82EDCF38: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82EDCF3C: 992A0018  stb r9, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[9].u8 ) };
	pc = 0x82EDCF40; continue 'dispatch;
            }
            0x82EDCF40 => {
    //   block [0x82EDCF40..0x82EDCF58)
	// 82EDCF40: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82EDCF44: 419A003C  beq cr6, 0x82edcf80
	if ctx.cr[6].eq {
	pc = 0x82EDCF80; continue 'dispatch;
	}
	// 82EDCF48: 814A0020  lwz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EDCF4C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDCF50: 4082FFDC  bne 0x82edcf2c
	if !ctx.cr[0].eq {
	pc = 0x82EDCF2C; continue 'dispatch;
	}
	// 82EDCF54: 4800002C  b 0x82edcf80
	pc = 0x82EDCF80; continue 'dispatch;
            }
            0x82EDCF58 => {
    //   block [0x82EDCF58..0x82EDCF7C)
	// 82EDCF58: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EDCF5C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDCF60: 4082001C  bne 0x82edcf7c
	if !ctx.cr[0].eq {
	pc = 0x82EDCF7C; continue 'dispatch;
	}
	// 82EDCF64: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82EDCF68: 419A0018  beq cr6, 0x82edcf80
	if ctx.cr[6].eq {
	pc = 0x82EDCF80; continue 'dispatch;
	}
	// 82EDCF6C: 814A0020  lwz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EDCF70: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDCF74: 4082FFE4  bne 0x82edcf58
	if !ctx.cr[0].eq {
	pc = 0x82EDCF58; continue 'dispatch;
	}
	// 82EDCF78: 48000008  b 0x82edcf80
	pc = 0x82EDCF80; continue 'dispatch;
            }
            0x82EDCF7C => {
    //   block [0x82EDCF7C..0x82EDCF80)
	// 82EDCF7C: 3AA00001  li r21, 1
	ctx.r[21].s64 = 1;
	pc = 0x82EDCF80; continue 'dispatch;
            }
            0x82EDCF80 => {
    //   block [0x82EDCF80..0x82EDCFF8)
	// 82EDCF80: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82EDCF84: 409A00C4  bne cr6, 0x82edd048
	if !ctx.cr[6].eq {
	pc = 0x82EDD048; continue 'dispatch;
	}
	// 82EDCF88: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDCF8C: FF1D6800  fcmpu cr6, f29, f13
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[13].f64);
	// 82EDCF90: 40980408  bge cr6, 0x82edd398
	if !ctx.cr[6].lt {
	pc = 0x82EDD398; continue 'dispatch;
	}
	// 82EDCF94: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EDCF98: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDCF9C: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82EDCFA0: 3BCAAFB4  addi r30, r10, -0x504c
	ctx.r[30].s64 = ctx.r[10].s64 + -20556;
	// 82EDCFA4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EDCFA8: 3BAAAFB4  addi r29, r10, -0x504c
	ctx.r[29].s64 = ctx.r[10].s64 + -20556;
	// 82EDCFAC: 419A004C  beq cr6, 0x82edcff8
	if ctx.cr[6].eq {
	pc = 0x82EDCFF8; continue 'dispatch;
	}
	// 82EDCFB0: C18B0014  lfs f12, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDCFB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EDCFB8: 38C10078  addi r6, r1, 0x78
	ctx.r[6].s64 = ctx.r[1].s64 + 120;
	// 82EDCFBC: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDCFC0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EDCFC4: D1810060  stfs f12, 0x60(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EDCFC8: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82EDCFCC: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EDCFD0: D3C10058  stfs f30, 0x58(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EDCFD4: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 82EDCFD8: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EDCFDC: 93E1007C  stw r31, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 82EDCFE0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82EDCFE4: 99610064  stb r11, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u8 ) };
	// 82EDCFE8: 4BFFFC21  bl 0x82edcc08
	ctx.lr = 0x82EDCFEC;
	sub_82EDCC08(ctx, base);
	// 82EDCFEC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EDCFF0: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EDCFF4: 916100B8  stw r11, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	pc = 0x82EDCFF8; continue 'dispatch;
            }
            0x82EDCFF8 => {
    //   block [0x82EDCFF8..0x82EDD040)
	// 82EDCFF8: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDCFFC: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 82EDD000: 419A0040  beq cr6, 0x82edd040
	if ctx.cr[6].eq {
	pc = 0x82EDD040; continue 'dispatch;
	}
	// 82EDD004: 38C10078  addi r6, r1, 0x78
	ctx.r[6].s64 = ctx.r[1].s64 + 120;
	// 82EDD008: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDD00C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EDD010: D3C10054  stfs f30, 0x54(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EDD014: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82EDD018: D3810058  stfs f28, 0x58(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EDD01C: D3A1005C  stfs f29, 0x5c(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EDD020: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 82EDD024: D3410060  stfs f26, 0x60(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EDD028: 93E1007C  stw r31, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 82EDD02C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82EDD030: 9AA10064  stb r21, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[21].u8 ) };
	// 82EDD034: 4BFFFBD5  bl 0x82edcc08
	ctx.lr = 0x82EDD038;
	sub_82EDCC08(ctx, base);
	// 82EDD038: D39F0008  stfs f28, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EDD03C: 4800035C  b 0x82edd398
	pc = 0x82EDD398; continue 'dispatch;
            }
            0x82EDD040 => {
    //   block [0x82EDD040..0x82EDD048)
	// 82EDD040: D3DF0008  stfs f30, 8(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EDD044: 48000348  b 0x82edd38c
	pc = 0x82EDD38C; continue 'dispatch;
            }
            0x82EDD048 => {
    //   block [0x82EDD048..0x82EDD0BC)
	// 82EDD048: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EDD04C: FC60E890  fmr f3, f29
	ctx.f[3].f64 = ctx.f[29].f64;
	// 82EDD050: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 82EDD054: FC40E090  fmr f2, f28
	ctx.f[2].f64 = ctx.f[28].f64;
	// 82EDD058: 3BCAAFB4  addi r30, r10, -0x504c
	ctx.r[30].s64 = ctx.r[10].s64 + -20556;
	// 82EDD05C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82EDD060: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 82EDD064: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82EDD068: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82EDD06C: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82EDD070: 39010098  addi r8, r1, 0x98
	ctx.r[8].s64 = ctx.r[1].s64 + 152;
	// 82EDD074: 93E1009C  stw r31, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[31].u32 ) };
	// 82EDD078: 38E100A0  addi r7, r1, 0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + 160;
	// 82EDD07C: 92C10084  stw r22, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[22].u32 ) };
	// 82EDD080: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EDD084: 93C10088  stw r30, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[30].u32 ) };
	// 82EDD088: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 82EDD08C: 7ED7B378  mr r23, r22
	ctx.r[23].u64 = ctx.r[22].u64;
	// 82EDD090: 93C10078  stw r30, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 82EDD094: 93C10098  stw r30, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[30].u32 ) };
	// 82EDD098: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 82EDD09C: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 82EDD0A0: 4BFFF801  bl 0x82edc8a0
	ctx.lr = 0x82EDD0A4;
	sub_82EDC8A0(ctx, base);
	// 82EDD0A4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDD0A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDD0AC: 3B2BAFB4  addi r25, r11, -0x504c
	ctx.r[25].s64 = ctx.r[11].s64 + -20556;
	// 82EDD0B0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EDD0B4: 3B4B9128  addi r26, r11, -0x6ed8
	ctx.r[26].s64 = ctx.r[11].s64 + -28376;
	// 82EDD0B8: 41820134  beq 0x82edd1ec
	if ctx.cr[0].eq {
	pc = 0x82EDD1EC; continue 'dispatch;
	}
	pc = 0x82EDD0BC; continue 'dispatch;
            }
            0x82EDD0BC => {
    //   block [0x82EDD0BC..0x82EDD120)
	// 82EDD0BC: 83010084  lwz r24, 0x84(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EDD0C0: 39410078  addi r10, r1, 0x78
	ctx.r[10].s64 = ctx.r[1].s64 + 120;
	// 82EDD0C4: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 82EDD0C8: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 82EDD0CC: 390100A8  addi r8, r1, 0xa8
	ctx.r[8].s64 = ctx.r[1].s64 + 168;
	// 82EDD0D0: FC40E090  fmr f2, f28
	ctx.f[2].f64 = ctx.f[28].f64;
	// 82EDD0D4: 38E100B0  addi r7, r1, 0xb0
	ctx.r[7].s64 = ctx.r[1].s64 + 176;
	// 82EDD0D8: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82EDD0DC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EDD0E0: 93C100A8  stw r30, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[30].u32 ) };
	// 82EDD0E4: 3AE00001  li r23, 1
	ctx.r[23].s64 = 1;
	// 82EDD0E8: 93E100AC  stw r31, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[31].u32 ) };
	// 82EDD0EC: 93C100B0  stw r30, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[30].u32 ) };
	// 82EDD0F0: 930100B4  stw r24, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[24].u32 ) };
	// 82EDD0F4: 4BFFF815  bl 0x82edc908
	ctx.lr = 0x82EDD0F8;
	sub_82EDC908(ctx, base);
	// 82EDD0F8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDD0FC: 418200F4  beq 0x82edd1f0
	if ctx.cr[0].eq {
	pc = 0x82EDD1F0; continue 'dispatch;
	}
	// 82EDD100: C3E10070  lfs f31, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EDD104: 7ED7B378  mr r23, r22
	ctx.r[23].u64 = ctx.r[22].u64;
	// 82EDD108: 7F18F840  cmplw cr6, r24, r31
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82EDD10C: 419A0124  beq cr6, 0x82edd230
	if ctx.cr[6].eq {
	pc = 0x82EDD230; continue 'dispatch;
	}
	// 82EDD110: C018000C  lfs f0, 0xc(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDD114: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EDD118: 40990008  ble cr6, 0x82edd120
	if !ctx.cr[6].gt {
	pc = 0x82EDD120; continue 'dispatch;
	}
	// 82EDD11C: D3F8000C  stfs f31, 0xc(r24)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x82EDD120; continue 'dispatch;
            }
            0x82EDD120 => {
    //   block [0x82EDD120..0x82EDD138)
	// 82EDD120: 83A1007C  lwz r29, 0x7c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EDD124: C3610090  lfs f27, 0x90(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82EDD128: C01D0008  lfs f0, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDD12C: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EDD130: 40980008  bge cr6, 0x82edd138
	if !ctx.cr[6].lt {
	pc = 0x82EDD138; continue 'dispatch;
	}
	// 82EDD134: D37D0008  stfs f27, 8(r29)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x82EDD138; continue 'dispatch;
            }
            0x82EDD138 => {
    //   block [0x82EDD138..0x82EDD140)
	// 82EDD138: 81780020  lwz r11, 0x20(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EDD13C: 836B0020  lwz r27, 0x20(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	pc = 0x82EDD140; continue 'dispatch;
            }
            0x82EDD140 => {
    //   block [0x82EDD140..0x82EDD164)
	// 82EDD140: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82EDD144: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82EDD148: 419A001C  beq cr6, 0x82edd164
	if ctx.cr[6].eq {
	pc = 0x82EDD164; continue 'dispatch;
	}
	// 82EDD14C: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82EDD150: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDD154: 4BFFF67D  bl 0x82edc7d0
	ctx.lr = 0x82EDD158;
	sub_82EDC7D0(ctx, base);
	// 82EDD158: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82EDD15C: 837B0020  lwz r27, 0x20(r27)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EDD160: 4BFFFFE0  b 0x82edd140
	pc = 0x82EDD140; continue 'dispatch;
            }
            0x82EDD164 => {
    //   block [0x82EDD164..0x82EDD1EC)
	// 82EDD164: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 82EDD168: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDD16C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EDD170: D3E10054  stfs f31, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EDD174: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82EDD178: D3610058  stfs f27, 0x58(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EDD17C: D3A1005C  stfs f29, 0x5c(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EDD180: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82EDD184: D3410060  stfs f26, 0x60(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EDD188: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 82EDD18C: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82EDD190: 9AA10064  stb r21, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[21].u8 ) };
	// 82EDD194: 4BFFFA75  bl 0x82edcc08
	ctx.lr = 0x82EDD198;
	sub_82EDCC08(ctx, base);
	// 82EDD198: 934100D0  stw r26, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[26].u32 ) };
	// 82EDD19C: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82EDD1A0: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82EDD1A4: 419A0050  beq cr6, 0x82edd1f4
	if ctx.cr[6].eq {
	pc = 0x82EDD1F4; continue 'dispatch;
	}
	// 82EDD1A8: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EDD1AC: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 82EDD1B0: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82EDD1B4: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 82EDD1B8: 39010098  addi r8, r1, 0x98
	ctx.r[8].s64 = ctx.r[1].s64 + 152;
	// 82EDD1BC: FC40E090  fmr f2, f28
	ctx.f[2].f64 = ctx.f[28].f64;
	// 82EDD1C0: 38E100A0  addi r7, r1, 0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + 160;
	// 82EDD1C4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82EDD1C8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EDD1CC: 93C10098  stw r30, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[30].u32 ) };
	// 82EDD1D0: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82EDD1D4: 93E1009C  stw r31, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[31].u32 ) };
	// 82EDD1D8: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 82EDD1DC: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 82EDD1E0: 4BFFF6C1  bl 0x82edc8a0
	ctx.lr = 0x82EDD1E4;
	sub_82EDC8A0(ctx, base);
	// 82EDD1E4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDD1E8: 4082FED4  bne 0x82edd0bc
	if !ctx.cr[0].eq {
	pc = 0x82EDD0BC; continue 'dispatch;
	}
	pc = 0x82EDD1EC; continue 'dispatch;
            }
            0x82EDD1EC => {
    //   block [0x82EDD1EC..0x82EDD1F0)
	// 82EDD1EC: 83010084  lwz r24, 0x84(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	pc = 0x82EDD1F0; continue 'dispatch;
            }
            0x82EDD1F0 => {
    //   block [0x82EDD1F0..0x82EDD1F4)
	// 82EDD1F0: C3E10070  lfs f31, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EDD1F4; continue 'dispatch;
            }
            0x82EDD1F4 => {
    //   block [0x82EDD1F4..0x82EDD20C)
	// 82EDD1F4: 56EB063F  clrlwi. r11, r23, 0x18
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDD1F8: 418201A0  beq 0x82edd398
	if ctx.cr[0].eq {
	pc = 0x82EDD398; continue 'dispatch;
	}
	// 82EDD1FC: 7F18F840  cmplw cr6, r24, r31
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82EDD200: 419A00F4  beq cr6, 0x82edd2f4
	if ctx.cr[6].eq {
	pc = 0x82EDD2F4; continue 'dispatch;
	}
	// 82EDD204: 81780020  lwz r11, 0x20(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EDD208: 83AB0020  lwz r29, 0x20(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	pc = 0x82EDD20C; continue 'dispatch;
            }
            0x82EDD20C => {
    //   block [0x82EDD20C..0x82EDD230)
	// 82EDD20C: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82EDD210: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82EDD214: 419A00AC  beq cr6, 0x82edd2c0
	if ctx.cr[6].eq {
	pc = 0x82EDD2C0; continue 'dispatch;
	}
	// 82EDD218: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82EDD21C: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDD220: 4BFFF5B1  bl 0x82edc7d0
	ctx.lr = 0x82EDD224;
	sub_82EDC7D0(ctx, base);
	// 82EDD224: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EDD228: 83BD0020  lwz r29, 0x20(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EDD22C: 4BFFFFE0  b 0x82edd20c
	pc = 0x82EDD20C; continue 'dispatch;
            }
            0x82EDD230 => {
    //   block [0x82EDD230..0x82EDD27C)
	// 82EDD230: C01F0008  lfs f0, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDD234: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82EDD238: 419A0044  beq cr6, 0x82edd27c
	if ctx.cr[6].eq {
	pc = 0x82EDD27C; continue 'dispatch;
	}
	// 82EDD23C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EDD240: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 82EDD244: C01F0010  lfs f0, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDD248: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EDD24C: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EDD250: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82EDD254: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDD258: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDD25C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EDD260: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82EDD264: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EDD268: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 82EDD26C: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82EDD270: 9AC10064  stb r22, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[22].u8 ) };
	// 82EDD274: 4BFFF995  bl 0x82edcc08
	ctx.lr = 0x82EDD278;
	sub_82EDCC08(ctx, base);
	// 82EDD278: 934100D8  stw r26, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[26].u32 ) };
	pc = 0x82EDD27C; continue 'dispatch;
            }
            0x82EDD27C => {
    //   block [0x82EDD27C..0x82EDD2C0)
	// 82EDD27C: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EDD280: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 82EDD284: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EDD288: C0010090  lfs f0, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDD28C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82EDD290: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDD294: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EDD298: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82EDD29C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EDD2A0: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82EDD2A4: D3A1005C  stfs f29, 0x5c(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EDD2A8: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82EDD2AC: D3410060  stfs f26, 0x60(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EDD2B0: 9AA10064  stb r21, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[21].u8 ) };
	// 82EDD2B4: 4BFFF955  bl 0x82edcc08
	ctx.lr = 0x82EDD2B8;
	sub_82EDCC08(ctx, base);
	// 82EDD2B8: 934100C0  stw r26, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[26].u32 ) };
	// 82EDD2BC: 4BFFFF38  b 0x82edd1f4
	pc = 0x82EDD1F4; continue 'dispatch;
            }
            0x82EDD2C0 => {
    //   block [0x82EDD2C0..0x82EDD2D4)
	// 82EDD2C0: C0180008  lfs f0, 8(r24)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDD2C4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EDD2C8: 4098000C  bge cr6, 0x82edd2d4
	if !ctx.cr[6].lt {
	pc = 0x82EDD2D4; continue 'dispatch;
	}
	// 82EDD2CC: D3F8000C  stfs f31, 0xc(r24)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EDD2D0: 48000010  b 0x82edd2e0
	pc = 0x82EDD2E0; continue 'dispatch;
            }
            0x82EDD2D4 => {
    //   block [0x82EDD2D4..0x82EDD2E0)
	// 82EDD2D4: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82EDD2D8: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDD2DC: 4BFFF4F5  bl 0x82edc7d0
	ctx.lr = 0x82EDD2E0;
	sub_82EDC7D0(ctx, base);
	pc = 0x82EDD2E0; continue 'dispatch;
            }
            0x82EDD2E0 => {
    //   block [0x82EDD2E0..0x82EDD2F4)
	// 82EDD2E0: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDD2E4: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 82EDD2E8: 409900A0  ble cr6, 0x82edd388
	if !ctx.cr[6].gt {
	pc = 0x82EDD388; continue 'dispatch;
	}
	// 82EDD2EC: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82EDD2F0: 48000060  b 0x82edd350
	pc = 0x82EDD350; continue 'dispatch;
            }
            0x82EDD2F4 => {
    //   block [0x82EDD2F4..0x82EDD340)
	// 82EDD2F4: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDD2F8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EDD2FC: 40980044  bge cr6, 0x82edd340
	if !ctx.cr[6].lt {
	pc = 0x82EDD340; continue 'dispatch;
	}
	// 82EDD300: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EDD304: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 82EDD308: C01F0010  lfs f0, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDD30C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EDD310: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EDD314: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82EDD318: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDD31C: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDD320: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EDD324: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82EDD328: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EDD32C: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 82EDD330: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82EDD334: 9AC10064  stb r22, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[22].u8 ) };
	// 82EDD338: 4BFFF8D1  bl 0x82edcc08
	ctx.lr = 0x82EDD33C;
	sub_82EDCC08(ctx, base);
	// 82EDD33C: 934100C8  stw r26, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[26].u32 ) };
	pc = 0x82EDD340; continue 'dispatch;
            }
            0x82EDD340 => {
    //   block [0x82EDD340..0x82EDD350)
	// 82EDD340: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDD344: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 82EDD348: 40990040  ble cr6, 0x82edd388
	if !ctx.cr[6].gt {
	pc = 0x82EDD388; continue 'dispatch;
	}
	// 82EDD34C: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	pc = 0x82EDD350; continue 'dispatch;
            }
            0x82EDD350 => {
    //   block [0x82EDD350..0x82EDD388)
	// 82EDD350: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 82EDD354: D39F0008  stfs f28, 8(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EDD358: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EDD35C: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDD360: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EDD364: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82EDD368: D3810058  stfs f28, 0x58(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EDD36C: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 82EDD370: D3A1005C  stfs f29, 0x5c(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EDD374: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 82EDD378: D3410060  stfs f26, 0x60(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EDD37C: 9AA10064  stb r21, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[21].u8 ) };
	// 82EDD380: 4BFFF889  bl 0x82edcc08
	ctx.lr = 0x82EDD384;
	sub_82EDCC08(ctx, base);
	// 82EDD384: 48000014  b 0x82edd398
	pc = 0x82EDD398; continue 'dispatch;
            }
            0x82EDD388 => {
    //   block [0x82EDD388..0x82EDD38C)
	// 82EDD388: D3FF0008  stfs f31, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x82EDD38C; continue 'dispatch;
            }
            0x82EDD38C => {
    //   block [0x82EDD38C..0x82EDD398)
	// 82EDD38C: D3BF0010  stfs f29, 0x10(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EDD390: 9ABF0018  stb r21, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[21].u8 ) };
	// 82EDD394: D35F0014  stfs f26, 0x14(r31)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	pc = 0x82EDD398; continue 'dispatch;
            }
            0x82EDD398 => {
    //   block [0x82EDD398..0x82EDD3AC)
	// 82EDD398: C01C0010  lfs f0, 0x10(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDD39C: FF1D0000  fcmpu cr6, f29, f0
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[0].f64);
	// 82EDD3A0: 4098FAE0  bge cr6, 0x82edce80
	if !ctx.cr[6].lt {
	pc = 0x82EDCE80; continue 'dispatch;
	}
	// 82EDD3A4: D3BC0010  stfs f29, 0x10(r28)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EDD3A8: 4BFFFAD8  b 0x82edce80
	pc = 0x82EDCE80; continue 'dispatch;
            }
            0x82EDD3AC => {
    //   block [0x82EDD3AC..0x82EDD3B0)
	// 82EDD3AC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EDD3B0; continue 'dispatch;
            }
            0x82EDD3B0 => {
    //   block [0x82EDD3B0..0x82EDD3C0)
	// 82EDD3B0: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 82EDD3B4: 3981FFA0  addi r12, r1, -0x60
	ctx.r[12].s64 = ctx.r[1].s64 + -96;
	// 82EDD3B8: 4BDD0965  bl 0x82cadd1c
	ctx.lr = 0x82EDD3BC;
	sub_82CADCEC(ctx, base);
	// 82EDD3BC: 4BDCC080  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDD3C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EDD3C0 size=144
    let mut pc: u32 = 0x82EDD3C0;
    'dispatch: loop {
        match pc {
            0x82EDD3C0 => {
    //   block [0x82EDD3C0..0x82EDD3E8)
	// 82EDD3C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDD3C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EDD3C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EDD3CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDD3D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDD3D4: 4BFA7FD5  bl 0x82e853a8
	ctx.lr = 0x82EDD3D8;
	sub_82E853A8(ctx, base);
	// 82EDD3D8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDD3DC: 4082000C  bne 0x82edd3e8
	if !ctx.cr[0].eq {
	pc = 0x82EDD3E8; continue 'dispatch;
	}
	// 82EDD3E0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EDD3E4: 48000058  b 0x82edd43c
	pc = 0x82EDD43C; continue 'dispatch;
            }
            0x82EDD3E8 => {
    //   block [0x82EDD3E8..0x82EDD410)
	// 82EDD3E8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDD3EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EDD3F0: 409A0028  bne cr6, 0x82edd418
	if !ctx.cr[6].eq {
	pc = 0x82EDD418; continue 'dispatch;
	}
	// 82EDD3F4: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82EDD3F8: 4B739531  bl 0x82616928
	ctx.lr = 0x82EDD3FC;
	sub_82616928(ctx, base);
	// 82EDD3FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDD400: 41820010  beq 0x82edd410
	if ctx.cr[0].eq {
	pc = 0x82EDD410; continue 'dispatch;
	}
	// 82EDD404: 38800032  li r4, 0x32
	ctx.r[4].s64 = 50;
	// 82EDD408: 4BFFF569  bl 0x82edc970
	ctx.lr = 0x82EDD40C;
	sub_82EDC970(ctx, base);
	// 82EDD40C: 48000008  b 0x82edd414
	pc = 0x82EDD414; continue 'dispatch;
            }
            0x82EDD410 => {
    //   block [0x82EDD410..0x82EDD414)
	// 82EDD410: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EDD414; continue 'dispatch;
            }
            0x82EDD414 => {
    //   block [0x82EDD414..0x82EDD418)
	// 82EDD414: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	pc = 0x82EDD418; continue 'dispatch;
            }
            0x82EDD418 => {
    //   block [0x82EDD418..0x82EDD43C)
	// 82EDD418: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDD41C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDD420: C06B0BEC  lfs f3, 0xbec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82EDD424: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDD428: C04B0C14  lfs f2, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EDD42C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDD430: C02B0EE0  lfs f1, 0xee0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EDD434: 4BFFF935  bl 0x82edcd68
	ctx.lr = 0x82EDD438;
	sub_82EDCD68(ctx, base);
	// 82EDD438: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EDD43C; continue 'dispatch;
            }
            0x82EDD43C => {
    //   block [0x82EDD43C..0x82EDD450)
	// 82EDD43C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EDD440: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EDD444: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EDD448: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EDD44C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDD450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EDD450 size=100
    let mut pc: u32 = 0x82EDD450;
    'dispatch: loop {
        match pc {
            0x82EDD450 => {
    //   block [0x82EDD450..0x82EDD490)
	// 82EDD450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDD454: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EDD458: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EDD45C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDD460: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDD464: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDD468: 396B5508  addi r11, r11, 0x5508
	ctx.r[11].s64 = ctx.r[11].s64 + 21768;
	// 82EDD46C: 807F00D4  lwz r3, 0xd4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EDD470: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDD474: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EDD478: 41820018  beq 0x82edd490
	if ctx.cr[0].eq {
	pc = 0x82EDD490; continue 'dispatch;
	}
	// 82EDD47C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EDD480: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EDD484: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EDD488: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDD48C: 4E800421  bctrl
	ctx.lr = 0x82EDD490;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EDD490 => {
    //   block [0x82EDD490..0x82EDD4B4)
	// 82EDD490: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EDD494: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EDD498: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 82EDD49C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EDD4A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EDD4A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EDD4A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EDD4AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EDD4B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDD4B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EDD4B8 size=12
    let mut pc: u32 = 0x82EDD4B8;
    'dispatch: loop {
        match pc {
            0x82EDD4B8 => {
    //   block [0x82EDD4B8..0x82EDD4C4)
	// 82EDD4B8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EDD4BC: 386B8CF8  addi r3, r11, -0x7308
	ctx.r[3].s64 = ctx.r[11].s64 + -29448;
	// 82EDD4C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDD4C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EDD4C8 size=8
    let mut pc: u32 = 0x82EDD4C8;
    'dispatch: loop {
        match pc {
            0x82EDD4C8 => {
    //   block [0x82EDD4C8..0x82EDD4D0)
	// 82EDD4C8: 90830054  stw r4, 0x54(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 82EDD4CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDD4D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EDD4D0 size=8
    let mut pc: u32 = 0x82EDD4D0;
    'dispatch: loop {
        match pc {
            0x82EDD4D0 => {
    //   block [0x82EDD4D0..0x82EDD4D8)
	// 82EDD4D0: 80630054  lwz r3, 0x54(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EDD4D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDD4D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EDD4D8 size=52
    let mut pc: u32 = 0x82EDD4D8;
    'dispatch: loop {
        match pc {
            0x82EDD4D8 => {
    //   block [0x82EDD4D8..0x82EDD50C)
	// 82EDD4D8: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EDD4DC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDD4E0: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
	// 82EDD4E4: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDD4E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDD4EC: C1AB0C18  lfs f13, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDD4F0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EDD4F4: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 82EDD4F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDD4FC: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDD500: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EDD504: D0030108  stfs f0, 0x108(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82EDD508: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDD510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EDD510 size=2228
    let mut pc: u32 = 0x82EDD510;
    'dispatch: loop {
        match pc {
            0x82EDD510 => {
    //   block [0x82EDD510..0x82EDD56C)
	// 82EDD510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDD514: 4BDCBEF5  bl 0x82ca9408
	ctx.lr = 0x82EDD518;
	sub_82CA93D0(ctx, base);
	// 82EDD518: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82EDD51C: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82EDD520: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDD524: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82EDD528: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EDD52C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDD530: 482DEB31  bl 0x831bc060
	ctx.lr = 0x82EDD534;
	sub_831BC060(ctx, base);
	// 82EDD534: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EDD538: 41820878  beq 0x82edddb0
	if ctx.cr[0].eq {
	pc = 0x82EDDDB0; continue 'dispatch;
	}
	// 82EDD53C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDD540: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDD544: 388BBC30  addi r4, r11, -0x43d0
	ctx.r[4].s64 = ctx.r[11].s64 + -17360;
	// 82EDD548: 4BDCF609  bl 0x82cacb50
	ctx.lr = 0x82EDD54C;
	sub_82CACB50(ctx, base);
	// 82EDD54C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDD550: 40820098  bne 0x82edd5e8
	if !ctx.cr[0].eq {
	pc = 0x82EDD5E8; continue 'dispatch;
	}
	// 82EDD554: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDD558: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDD55C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDD560: 4182000C  beq 0x82edd56c
	if ctx.cr[0].eq {
	pc = 0x82EDD56C; continue 'dispatch;
	}
	// 82EDD564: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EDD568: 4800000C  b 0x82edd574
	pc = 0x82EDD574; continue 'dispatch;
            }
            0x82EDD56C => {
    //   block [0x82EDD56C..0x82EDD574)
	// 82EDD56C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDD570: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EDD574; continue 'dispatch;
            }
            0x82EDD574 => {
    //   block [0x82EDD574..0x82EDD5DC)
	// 82EDD574: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDD578: 4BA30791  bl 0x8290dd08
	ctx.lr = 0x82EDD57C;
	sub_8290DD08(ctx, base);
	// 82EDD57C: 4BDCE635  bl 0x82cabbb0
	ctx.lr = 0x82EDD580;
	sub_82CABBB0(ctx, base);
	// 82EDD580: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDD584: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDD588: EFE007F2  fmuls f31, f0, f31
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EDD58C: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDD590: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82EDD594: 4099004C  ble cr6, 0x82edd5e0
	if !ctx.cr[6].gt {
	pc = 0x82EDD5E0; continue 'dispatch;
	}
	// 82EDD598: 807C0058  lwz r3, 0x58(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EDD59C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDD5A0: 4182003C  beq 0x82edd5dc
	if ctx.cr[0].eq {
	pc = 0x82EDD5DC; continue 'dispatch;
	}
	// 82EDD5A4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDD5A8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EDD5AC: 3BEBC5C8  addi r31, r11, -0x3a38
	ctx.r[31].s64 = ctx.r[11].s64 + -14904;
	// 82EDD5B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDD5B4: 4B30B0C5  bl 0x821e8678
	ctx.lr = 0x82EDD5B8;
	sub_821E8678(ctx, base);
	// 82EDD5B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDD5BC: 41820020  beq 0x82edd5dc
	if ctx.cr[0].eq {
	pc = 0x82EDD5DC; continue 'dispatch;
	}
	// 82EDD5C0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EDD5C4: 807C0058  lwz r3, 0x58(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EDD5C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDD5CC: 4B30B0AD  bl 0x821e8678
	ctx.lr = 0x82EDD5D0;
	sub_821E8678(ctx, base);
	// 82EDD5D0: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDD5D4: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82EDD5D8: 409907D8  ble cr6, 0x82edddb0
	if !ctx.cr[6].gt {
	pc = 0x82EDDDB0; continue 'dispatch;
	}
	pc = 0x82EDD5DC; continue 'dispatch;
            }
            0x82EDD5DC => {
    //   block [0x82EDD5DC..0x82EDD5E0)
	// 82EDD5DC: D3FC0004  stfs f31, 4(r28)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), tmp.u32 ) };
	pc = 0x82EDD5E0; continue 'dispatch;
            }
            0x82EDD5E0 => {
    //   block [0x82EDD5E0..0x82EDD5E8)
	// 82EDD5E0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EDD5E4: 480007D0  b 0x82edddb4
	pc = 0x82EDDDB4; continue 'dispatch;
            }
            0x82EDD5E8 => {
    //   block [0x82EDD5E8..0x82EDD618)
	// 82EDD5E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDD5EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDD5F0: 388BBC1C  addi r4, r11, -0x43e4
	ctx.r[4].s64 = ctx.r[11].s64 + -17380;
	// 82EDD5F4: 4BDCF55D  bl 0x82cacb50
	ctx.lr = 0x82EDD5F8;
	sub_82CACB50(ctx, base);
	// 82EDD5F8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDD5FC: 408200A0  bne 0x82edd69c
	if !ctx.cr[0].eq {
	pc = 0x82EDD69C; continue 'dispatch;
	}
	// 82EDD600: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDD604: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDD608: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDD60C: 4182000C  beq 0x82edd618
	if ctx.cr[0].eq {
	pc = 0x82EDD618; continue 'dispatch;
	}
	// 82EDD610: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EDD614: 4800000C  b 0x82edd620
	pc = 0x82EDD620; continue 'dispatch;
            }
            0x82EDD618 => {
    //   block [0x82EDD618..0x82EDD620)
	// 82EDD618: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDD61C: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EDD620; continue 'dispatch;
            }
            0x82EDD620 => {
    //   block [0x82EDD620..0x82EDD694)
	// 82EDD620: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDD624: 4BA306E5  bl 0x8290dd08
	ctx.lr = 0x82EDD628;
	sub_8290DD08(ctx, base);
	// 82EDD628: 4BDCE589  bl 0x82cabbb0
	ctx.lr = 0x82EDD62C;
	sub_82CABBB0(ctx, base);
	// 82EDD62C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDD630: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDD634: EFE007F2  fmuls f31, f0, f31
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EDD638: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDD63C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82EDD640: 4099FFA0  ble cr6, 0x82edd5e0
	if !ctx.cr[6].gt {
	pc = 0x82EDD5E0; continue 'dispatch;
	}
	// 82EDD644: 807C0058  lwz r3, 0x58(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EDD648: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDD64C: 41820048  beq 0x82edd694
	if ctx.cr[0].eq {
	pc = 0x82EDD694; continue 'dispatch;
	}
	// 82EDD650: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDD654: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EDD658: 3BEBC5C8  addi r31, r11, -0x3a38
	ctx.r[31].s64 = ctx.r[11].s64 + -14904;
	// 82EDD65C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDD660: 4B30B019  bl 0x821e8678
	ctx.lr = 0x82EDD664;
	sub_821E8678(ctx, base);
	// 82EDD664: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDD668: 4182002C  beq 0x82edd694
	if ctx.cr[0].eq {
	pc = 0x82EDD694; continue 'dispatch;
	}
	// 82EDD66C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EDD670: 807C0058  lwz r3, 0x58(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EDD674: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDD678: 4B30B001  bl 0x821e8678
	ctx.lr = 0x82EDD67C;
	sub_821E8678(ctx, base);
	// 82EDD67C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDD680: C1A30004  lfs f13, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDD684: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDD688: EC1F0032  fmuls f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDD68C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EDD690: 40990720  ble cr6, 0x82edddb0
	if !ctx.cr[6].gt {
	pc = 0x82EDDDB0; continue 'dispatch;
	}
	pc = 0x82EDD694; continue 'dispatch;
            }
            0x82EDD694 => {
    //   block [0x82EDD694..0x82EDD69C)
	// 82EDD694: D3FC000C  stfs f31, 0xc(r28)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EDD698: 4BFFFF48  b 0x82edd5e0
	pc = 0x82EDD5E0; continue 'dispatch;
            }
            0x82EDD69C => {
    //   block [0x82EDD69C..0x82EDD6D4)
	// 82EDD69C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDD6A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDD6A4: 388BBC08  addi r4, r11, -0x43f8
	ctx.r[4].s64 = ctx.r[11].s64 + -17400;
	// 82EDD6A8: 4BDCF4A9  bl 0x82cacb50
	ctx.lr = 0x82EDD6AC;
	sub_82CACB50(ctx, base);
	// 82EDD6AC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDD6B0: 408200AC  bne 0x82edd75c
	if !ctx.cr[0].eq {
	pc = 0x82EDD75C; continue 'dispatch;
	}
	// 82EDD6B4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDD6B8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EDD6BC: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDD6C0: C3CA0C14  lfs f30, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EDD6C4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDD6C8: 4182000C  beq 0x82edd6d4
	if ctx.cr[0].eq {
	pc = 0x82EDD6D4; continue 'dispatch;
	}
	// 82EDD6CC: C3EB000C  lfs f31, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EDD6D0: 48000008  b 0x82edd6d8
	pc = 0x82EDD6D8; continue 'dispatch;
            }
            0x82EDD6D4 => {
    //   block [0x82EDD6D4..0x82EDD6D8)
	// 82EDD6D4: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	pc = 0x82EDD6D8; continue 'dispatch;
            }
            0x82EDD6D8 => {
    //   block [0x82EDD6D8..0x82EDD74C)
	// 82EDD6D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDD6DC: 4BA3062D  bl 0x8290dd08
	ctx.lr = 0x82EDD6E0;
	sub_8290DD08(ctx, base);
	// 82EDD6E0: 4BDCE4D1  bl 0x82cabbb0
	ctx.lr = 0x82EDD6E4;
	sub_82CABBB0(ctx, base);
	// 82EDD6E4: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDD6E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDD6EC: EFE007F2  fmuls f31, f0, f31
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EDD6F0: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDD6F4: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82EDD6F8: 4099FEE8  ble cr6, 0x82edd5e0
	if !ctx.cr[6].gt {
	pc = 0x82EDD5E0; continue 'dispatch;
	}
	// 82EDD6FC: 807C0058  lwz r3, 0x58(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EDD700: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDD704: 41820048  beq 0x82edd74c
	if ctx.cr[0].eq {
	pc = 0x82EDD74C; continue 'dispatch;
	}
	// 82EDD708: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDD70C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EDD710: 3BEBC5C8  addi r31, r11, -0x3a38
	ctx.r[31].s64 = ctx.r[11].s64 + -14904;
	// 82EDD714: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDD718: 4B30AF61  bl 0x821e8678
	ctx.lr = 0x82EDD71C;
	sub_821E8678(ctx, base);
	// 82EDD71C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDD720: 4182002C  beq 0x82edd74c
	if ctx.cr[0].eq {
	pc = 0x82EDD74C; continue 'dispatch;
	}
	// 82EDD724: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EDD728: 807C0058  lwz r3, 0x58(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EDD72C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDD730: 4B30AF49  bl 0x821e8678
	ctx.lr = 0x82EDD734;
	sub_821E8678(ctx, base);
	// 82EDD734: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDD738: C1A30004  lfs f13, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDD73C: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDD740: EC1F0032  fmuls f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDD744: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EDD748: 40990668  ble cr6, 0x82edddb0
	if !ctx.cr[6].gt {
	pc = 0x82EDDDB0; continue 'dispatch;
	}
	pc = 0x82EDD74C; continue 'dispatch;
            }
            0x82EDD74C => {
    //   block [0x82EDD74C..0x82EDD75C)
	// 82EDD74C: EC1EF824  fdivs f0, f30, f31
	ctx.f[0].f64 = ((ctx.f[30].f64 / ctx.f[31].f64) as f32) as f64;
	// 82EDD750: D3FC0040  stfs f31, 0x40(r28)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82EDD754: D01C0104  stfs f0, 0x104(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82EDD758: 4BFFFE88  b 0x82edd5e0
	pc = 0x82EDD5E0; continue 'dispatch;
            }
            0x82EDD75C => {
    //   block [0x82EDD75C..0x82EDD790)
	// 82EDD75C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDD760: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDD764: 388BBBF0  addi r4, r11, -0x4410
	ctx.r[4].s64 = ctx.r[11].s64 + -17424;
	// 82EDD768: 4BDCF3E9  bl 0x82cacb50
	ctx.lr = 0x82EDD76C;
	sub_82CACB50(ctx, base);
	// 82EDD76C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDD770: 4082003C  bne 0x82edd7ac
	if !ctx.cr[0].eq {
	pc = 0x82EDD7AC; continue 'dispatch;
	}
	// 82EDD774: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDD778: 4BA30591  bl 0x8290dd08
	ctx.lr = 0x82EDD77C;
	sub_8290DD08(ctx, base);
	// 82EDD77C: 4BDCE435  bl 0x82cabbb0
	ctx.lr = 0x82EDD780;
	sub_82CABBB0(ctx, base);
	// 82EDD780: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDD784: C01C0008  lfs f0, 8(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDD788: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDD78C: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EDD790; continue 'dispatch;
            }
            0x82EDD790 => {
    //   block [0x82EDD790..0x82EDD79C)
	// 82EDD790: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDD794: 41980008  blt cr6, 0x82edd79c
	if ctx.cr[6].lt {
	pc = 0x82EDD79C; continue 'dispatch;
	}
	// 82EDD798: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDD79C; continue 'dispatch;
            }
            0x82EDD79C => {
    //   block [0x82EDD79C..0x82EDD7AC)
	// 82EDD79C: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDD7A0: 409AFFF0  bne cr6, 0x82edd790
	if !ctx.cr[6].eq {
	pc = 0x82EDD790; continue 'dispatch;
	}
	// 82EDD7A4: D01C0008  stfs f0, 8(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EDD7A8: 4BFFFE38  b 0x82edd5e0
	pc = 0x82EDD5E0; continue 'dispatch;
            }
            0x82EDD7AC => {
    //   block [0x82EDD7AC..0x82EDD7DC)
	// 82EDD7AC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDD7B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDD7B4: 388BBBDC  addi r4, r11, -0x4424
	ctx.r[4].s64 = ctx.r[11].s64 + -17444;
	// 82EDD7B8: 4BDCF399  bl 0x82cacb50
	ctx.lr = 0x82EDD7BC;
	sub_82CACB50(ctx, base);
	// 82EDD7BC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDD7C0: 40820060  bne 0x82edd820
	if !ctx.cr[0].eq {
	pc = 0x82EDD820; continue 'dispatch;
	}
	// 82EDD7C4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDD7C8: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDD7CC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDD7D0: 4182000C  beq 0x82edd7dc
	if ctx.cr[0].eq {
	pc = 0x82EDD7DC; continue 'dispatch;
	}
	// 82EDD7D4: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EDD7D8: 4800000C  b 0x82edd7e4
	pc = 0x82EDD7E4; continue 'dispatch;
            }
            0x82EDD7DC => {
    //   block [0x82EDD7DC..0x82EDD7E4)
	// 82EDD7DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDD7E0: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EDD7E4; continue 'dispatch;
            }
            0x82EDD7E4 => {
    //   block [0x82EDD7E4..0x82EDD804)
	// 82EDD7E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDD7E8: 4BA30521  bl 0x8290dd08
	ctx.lr = 0x82EDD7EC;
	sub_8290DD08(ctx, base);
	// 82EDD7EC: 4BDCE3C5  bl 0x82cabbb0
	ctx.lr = 0x82EDD7F0;
	sub_82CABBB0(ctx, base);
	// 82EDD7F0: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDD7F4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDD7F8: C01C0010  lfs f0, 0x10(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDD7FC: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDD800: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	pc = 0x82EDD804; continue 'dispatch;
            }
            0x82EDD804 => {
    //   block [0x82EDD804..0x82EDD810)
	// 82EDD804: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDD808: 40990008  ble cr6, 0x82edd810
	if !ctx.cr[6].gt {
	pc = 0x82EDD810; continue 'dispatch;
	}
	// 82EDD80C: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDD810; continue 'dispatch;
            }
            0x82EDD810 => {
    //   block [0x82EDD810..0x82EDD820)
	// 82EDD810: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDD814: 409AFFF0  bne cr6, 0x82edd804
	if !ctx.cr[6].eq {
	pc = 0x82EDD804; continue 'dispatch;
	}
	// 82EDD818: D01C0010  stfs f0, 0x10(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EDD81C: 4BFFFDC4  b 0x82edd5e0
	pc = 0x82EDD5E0; continue 'dispatch;
            }
            0x82EDD820 => {
    //   block [0x82EDD820..0x82EDD850)
	// 82EDD820: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDD824: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDD828: 388BAF10  addi r4, r11, -0x50f0
	ctx.r[4].s64 = ctx.r[11].s64 + -20720;
	// 82EDD82C: 4BDCF325  bl 0x82cacb50
	ctx.lr = 0x82EDD830;
	sub_82CACB50(ctx, base);
	// 82EDD830: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDD834: 40820060  bne 0x82edd894
	if !ctx.cr[0].eq {
	pc = 0x82EDD894; continue 'dispatch;
	}
	// 82EDD838: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDD83C: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDD840: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDD844: 4182000C  beq 0x82edd850
	if ctx.cr[0].eq {
	pc = 0x82EDD850; continue 'dispatch;
	}
	// 82EDD848: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EDD84C: 4800000C  b 0x82edd858
	pc = 0x82EDD858; continue 'dispatch;
            }
            0x82EDD850 => {
    //   block [0x82EDD850..0x82EDD858)
	// 82EDD850: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDD854: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EDD858; continue 'dispatch;
            }
            0x82EDD858 => {
    //   block [0x82EDD858..0x82EDD878)
	// 82EDD858: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDD85C: 4BA304AD  bl 0x8290dd08
	ctx.lr = 0x82EDD860;
	sub_8290DD08(ctx, base);
	// 82EDD860: 4BDCE351  bl 0x82cabbb0
	ctx.lr = 0x82EDD864;
	sub_82CABBB0(ctx, base);
	// 82EDD864: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDD868: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDD86C: C01C0014  lfs f0, 0x14(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDD870: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDD874: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	pc = 0x82EDD878; continue 'dispatch;
            }
            0x82EDD878 => {
    //   block [0x82EDD878..0x82EDD884)
	// 82EDD878: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDD87C: 41980008  blt cr6, 0x82edd884
	if ctx.cr[6].lt {
	pc = 0x82EDD884; continue 'dispatch;
	}
	// 82EDD880: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDD884; continue 'dispatch;
            }
            0x82EDD884 => {
    //   block [0x82EDD884..0x82EDD894)
	// 82EDD884: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDD888: 409AFFF0  bne cr6, 0x82edd878
	if !ctx.cr[6].eq {
	pc = 0x82EDD878; continue 'dispatch;
	}
	// 82EDD88C: D01C0014  stfs f0, 0x14(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EDD890: 4BFFFD50  b 0x82edd5e0
	pc = 0x82EDD5E0; continue 'dispatch;
            }
            0x82EDD894 => {
    //   block [0x82EDD894..0x82EDD974)
	// 82EDD894: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDD898: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDD89C: 3BCBBBCC  addi r30, r11, -0x4434
	ctx.r[30].s64 = ctx.r[11].s64 + -17460;
	// 82EDD8A0: 482DE7C1  bl 0x831bc060
	ctx.lr = 0x82EDD8A4;
	sub_831BC060(ctx, base);
	// 82EDD8A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EDD8A8: 4BDCF2A9  bl 0x82cacb50
	ctx.lr = 0x82EDD8AC;
	sub_82CACB50(ctx, base);
	// 82EDD8AC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDD8B0: 408200D8  bne 0x82edd988
	if !ctx.cr[0].eq {
	pc = 0x82EDD988; continue 'dispatch;
	}
	// 82EDD8B4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EDD8B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDD8BC: 3BEB1694  addi r31, r11, 0x1694
	ctx.r[31].s64 = ctx.r[11].s64 + 5780;
	// 82EDD8C0: 4BA30449  bl 0x8290dd08
	ctx.lr = 0x82EDD8C4;
	sub_8290DD08(ctx, base);
	// 82EDD8C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDD8C8: 4BDCF289  bl 0x82cacb50
	ctx.lr = 0x82EDD8CC;
	sub_82CACB50(ctx, base);
	// 82EDD8CC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDD8D0: 418200AC  beq 0x82edd97c
	if ctx.cr[0].eq {
	pc = 0x82EDD97C; continue 'dispatch;
	}
	// 82EDD8D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDD8D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDD8DC: 3BEB0F40  addi r31, r11, 0xf40
	ctx.r[31].s64 = ctx.r[11].s64 + 3904;
	// 82EDD8E0: 4BA30429  bl 0x8290dd08
	ctx.lr = 0x82EDD8E4;
	sub_8290DD08(ctx, base);
	// 82EDD8E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDD8E8: 4BDCF269  bl 0x82cacb50
	ctx.lr = 0x82EDD8EC;
	sub_82CACB50(ctx, base);
	// 82EDD8EC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDD8F0: 4182008C  beq 0x82edd97c
	if ctx.cr[0].eq {
	pc = 0x82EDD97C; continue 'dispatch;
	}
	// 82EDD8F4: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82EDD8F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDD8FC: 3BEBD56C  addi r31, r11, -0x2a94
	ctx.r[31].s64 = ctx.r[11].s64 + -10900;
	// 82EDD900: 4BA30409  bl 0x8290dd08
	ctx.lr = 0x82EDD904;
	sub_8290DD08(ctx, base);
	// 82EDD904: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDD908: 4BDCF249  bl 0x82cacb50
	ctx.lr = 0x82EDD90C;
	sub_82CACB50(ctx, base);
	// 82EDD90C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDD910: 4182006C  beq 0x82edd97c
	if ctx.cr[0].eq {
	pc = 0x82EDD97C; continue 'dispatch;
	}
	// 82EDD914: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EDD918: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDD91C: 3BEB1698  addi r31, r11, 0x1698
	ctx.r[31].s64 = ctx.r[11].s64 + 5784;
	// 82EDD920: 4BA303E9  bl 0x8290dd08
	ctx.lr = 0x82EDD924;
	sub_8290DD08(ctx, base);
	// 82EDD924: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDD928: 4BDCF229  bl 0x82cacb50
	ctx.lr = 0x82EDD92C;
	sub_82CACB50(ctx, base);
	// 82EDD92C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDD930: 41820044  beq 0x82edd974
	if ctx.cr[0].eq {
	pc = 0x82EDD974; continue 'dispatch;
	}
	// 82EDD934: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EDD938: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDD93C: 3BEB1700  addi r31, r11, 0x1700
	ctx.r[31].s64 = ctx.r[11].s64 + 5888;
	// 82EDD940: 4BA303C9  bl 0x8290dd08
	ctx.lr = 0x82EDD944;
	sub_8290DD08(ctx, base);
	// 82EDD944: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDD948: 4BDCF209  bl 0x82cacb50
	ctx.lr = 0x82EDD94C;
	sub_82CACB50(ctx, base);
	// 82EDD94C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDD950: 41820024  beq 0x82edd974
	if ctx.cr[0].eq {
	pc = 0x82EDD974; continue 'dispatch;
	}
	// 82EDD954: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EDD958: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDD95C: 3BEB7088  addi r31, r11, 0x7088
	ctx.r[31].s64 = ctx.r[11].s64 + 28808;
	// 82EDD960: 4BA303A9  bl 0x8290dd08
	ctx.lr = 0x82EDD964;
	sub_8290DD08(ctx, base);
	// 82EDD964: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDD968: 4BDCF1E9  bl 0x82cacb50
	ctx.lr = 0x82EDD96C;
	sub_82CACB50(ctx, base);
	// 82EDD96C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDD970: 40820440  bne 0x82edddb0
	if !ctx.cr[0].eq {
	pc = 0x82EDDDB0; continue 'dispatch;
	}
	pc = 0x82EDD974; continue 'dispatch;
            }
            0x82EDD974 => {
    //   block [0x82EDD974..0x82EDD97C)
	// 82EDD974: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EDD978: 48000008  b 0x82edd980
	pc = 0x82EDD980; continue 'dispatch;
            }
            0x82EDD97C => {
    //   block [0x82EDD97C..0x82EDD980)
	// 82EDD97C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82EDD980; continue 'dispatch;
            }
            0x82EDD980 => {
    //   block [0x82EDD980..0x82EDD988)
	// 82EDD980: 997C0018  stb r11, 0x18(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 82EDD984: 4BFFFC5C  b 0x82edd5e0
	pc = 0x82EDD5E0; continue 'dispatch;
            }
            0x82EDD988 => {
    //   block [0x82EDD988..0x82EDD9B8)
	// 82EDD988: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82EDD98C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDD990: 388B2520  addi r4, r11, 0x2520
	ctx.r[4].s64 = ctx.r[11].s64 + 9504;
	// 82EDD994: 4BDCF1BD  bl 0x82cacb50
	ctx.lr = 0x82EDD998;
	sub_82CACB50(ctx, base);
	// 82EDD998: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDD99C: 40820060  bne 0x82edd9fc
	if !ctx.cr[0].eq {
	pc = 0x82EDD9FC; continue 'dispatch;
	}
	// 82EDD9A0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDD9A4: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDD9A8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDD9AC: 4182000C  beq 0x82edd9b8
	if ctx.cr[0].eq {
	pc = 0x82EDD9B8; continue 'dispatch;
	}
	// 82EDD9B0: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EDD9B4: 4800000C  b 0x82edd9c0
	pc = 0x82EDD9C0; continue 'dispatch;
            }
            0x82EDD9B8 => {
    //   block [0x82EDD9B8..0x82EDD9C0)
	// 82EDD9B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDD9BC: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EDD9C0; continue 'dispatch;
            }
            0x82EDD9C0 => {
    //   block [0x82EDD9C0..0x82EDD9E0)
	// 82EDD9C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDD9C4: 4BA30345  bl 0x8290dd08
	ctx.lr = 0x82EDD9C8;
	sub_8290DD08(ctx, base);
	// 82EDD9C8: 4BDCE1E9  bl 0x82cabbb0
	ctx.lr = 0x82EDD9CC;
	sub_82CABBB0(ctx, base);
	// 82EDD9CC: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDD9D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDD9D4: C01C001C  lfs f0, 0x1c(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDD9D8: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDD9DC: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	pc = 0x82EDD9E0; continue 'dispatch;
            }
            0x82EDD9E0 => {
    //   block [0x82EDD9E0..0x82EDD9EC)
	// 82EDD9E0: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDD9E4: 40990008  ble cr6, 0x82edd9ec
	if !ctx.cr[6].gt {
	pc = 0x82EDD9EC; continue 'dispatch;
	}
	// 82EDD9E8: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDD9EC; continue 'dispatch;
            }
            0x82EDD9EC => {
    //   block [0x82EDD9EC..0x82EDD9FC)
	// 82EDD9EC: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDD9F0: 409AFFF0  bne cr6, 0x82edd9e0
	if !ctx.cr[6].eq {
	pc = 0x82EDD9E0; continue 'dispatch;
	}
	// 82EDD9F4: D01C001C  stfs f0, 0x1c(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EDD9F8: 4BFFFBE8  b 0x82edd5e0
	pc = 0x82EDD5E0; continue 'dispatch;
            }
            0x82EDD9FC => {
    //   block [0x82EDD9FC..0x82EDDA38)
	// 82EDD9FC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDDA00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDDA04: 388BBBC0  addi r4, r11, -0x4440
	ctx.r[4].s64 = ctx.r[11].s64 + -17472;
	// 82EDDA08: 4BDCF149  bl 0x82cacb50
	ctx.lr = 0x82EDDA0C;
	sub_82CACB50(ctx, base);
	// 82EDDA0C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDDA10: 4082004C  bne 0x82edda5c
	if !ctx.cr[0].eq {
	pc = 0x82EDDA5C; continue 'dispatch;
	}
	// 82EDDA14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDDA18: 4BA302F1  bl 0x8290dd08
	ctx.lr = 0x82EDDA1C;
	sub_8290DD08(ctx, base);
	// 82EDDA1C: 4BDCE195  bl 0x82cabbb0
	ctx.lr = 0x82EDDA20;
	sub_82CABBB0(ctx, base);
	// 82EDDA20: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EDDA24: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDDA28: C1BC0020  lfs f13, 0x20(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDDA2C: FC000818  frsp f0, f1
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDDA30: C16A0C18  lfs f11, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDDA34: C18B0C14  lfs f12, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EDDA38; continue 'dispatch;
            }
            0x82EDDA38 => {
    //   block [0x82EDDA38..0x82EDDA4C)
	// 82EDDA38: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EDDA3C: 41980010  blt cr6, 0x82edda4c
	if ctx.cr[6].lt {
	pc = 0x82EDDA4C; continue 'dispatch;
	}
	// 82EDDA40: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EDDA44: 41990008  bgt cr6, 0x82edda4c
	if ctx.cr[6].gt {
	pc = 0x82EDDA4C; continue 'dispatch;
	}
	// 82EDDA48: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	pc = 0x82EDDA4C; continue 'dispatch;
            }
            0x82EDDA4C => {
    //   block [0x82EDDA4C..0x82EDDA5C)
	// 82EDDA4C: FF0D6800  fcmpu cr6, f13, f13
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[13].f64);
	// 82EDDA50: 409AFFE8  bne cr6, 0x82edda38
	if !ctx.cr[6].eq {
	pc = 0x82EDDA38; continue 'dispatch;
	}
	// 82EDDA54: D1BC0020  stfs f13, 0x20(r28)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EDDA58: 4BFFFB88  b 0x82edd5e0
	pc = 0x82EDD5E0; continue 'dispatch;
            }
            0x82EDDA5C => {
    //   block [0x82EDDA5C..0x82EDDA90)
	// 82EDDA5C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDDA60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDDA64: 388BBBB0  addi r4, r11, -0x4450
	ctx.r[4].s64 = ctx.r[11].s64 + -17488;
	// 82EDDA68: 4BDCF0E9  bl 0x82cacb50
	ctx.lr = 0x82EDDA6C;
	sub_82CACB50(ctx, base);
	// 82EDDA6C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDDA70: 4082003C  bne 0x82eddaac
	if !ctx.cr[0].eq {
	pc = 0x82EDDAAC; continue 'dispatch;
	}
	// 82EDDA74: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDDA78: 4BA30291  bl 0x8290dd08
	ctx.lr = 0x82EDDA7C;
	sub_8290DD08(ctx, base);
	// 82EDDA7C: 4BDCE135  bl 0x82cabbb0
	ctx.lr = 0x82EDDA80;
	sub_82CABBB0(ctx, base);
	// 82EDDA80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDDA84: C01C0024  lfs f0, 0x24(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDDA88: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDDA8C: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EDDA90; continue 'dispatch;
            }
            0x82EDDA90 => {
    //   block [0x82EDDA90..0x82EDDA9C)
	// 82EDDA90: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDDA94: 41980008  blt cr6, 0x82edda9c
	if ctx.cr[6].lt {
	pc = 0x82EDDA9C; continue 'dispatch;
	}
	// 82EDDA98: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDDA9C; continue 'dispatch;
            }
            0x82EDDA9C => {
    //   block [0x82EDDA9C..0x82EDDAAC)
	// 82EDDA9C: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDDAA0: 409AFFF0  bne cr6, 0x82edda90
	if !ctx.cr[6].eq {
	pc = 0x82EDDA90; continue 'dispatch;
	}
	// 82EDDAA4: D01C0024  stfs f0, 0x24(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EDDAA8: 4BFFFB38  b 0x82edd5e0
	pc = 0x82EDD5E0; continue 'dispatch;
            }
            0x82EDDAAC => {
    //   block [0x82EDDAAC..0x82EDDAE0)
	// 82EDDAAC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDDAB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDDAB4: 388BBBA0  addi r4, r11, -0x4460
	ctx.r[4].s64 = ctx.r[11].s64 + -17504;
	// 82EDDAB8: 4BDCF099  bl 0x82cacb50
	ctx.lr = 0x82EDDABC;
	sub_82CACB50(ctx, base);
	// 82EDDABC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDDAC0: 4082003C  bne 0x82eddafc
	if !ctx.cr[0].eq {
	pc = 0x82EDDAFC; continue 'dispatch;
	}
	// 82EDDAC4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDDAC8: 4BA30241  bl 0x8290dd08
	ctx.lr = 0x82EDDACC;
	sub_8290DD08(ctx, base);
	// 82EDDACC: 4BDCE0E5  bl 0x82cabbb0
	ctx.lr = 0x82EDDAD0;
	sub_82CABBB0(ctx, base);
	// 82EDDAD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDDAD4: C01C0028  lfs f0, 0x28(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDDAD8: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDDADC: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EDDAE0; continue 'dispatch;
            }
            0x82EDDAE0 => {
    //   block [0x82EDDAE0..0x82EDDAEC)
	// 82EDDAE0: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDDAE4: 41980008  blt cr6, 0x82eddaec
	if ctx.cr[6].lt {
	pc = 0x82EDDAEC; continue 'dispatch;
	}
	// 82EDDAE8: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDDAEC; continue 'dispatch;
            }
            0x82EDDAEC => {
    //   block [0x82EDDAEC..0x82EDDAFC)
	// 82EDDAEC: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDDAF0: 409AFFF0  bne cr6, 0x82eddae0
	if !ctx.cr[6].eq {
	pc = 0x82EDDAE0; continue 'dispatch;
	}
	// 82EDDAF4: D01C0028  stfs f0, 0x28(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82EDDAF8: 4BFFFAE8  b 0x82edd5e0
	pc = 0x82EDD5E0; continue 'dispatch;
            }
            0x82EDDAFC => {
    //   block [0x82EDDAFC..0x82EDDB30)
	// 82EDDAFC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDDB00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDDB04: 388BBB94  addi r4, r11, -0x446c
	ctx.r[4].s64 = ctx.r[11].s64 + -17516;
	// 82EDDB08: 4BDCF049  bl 0x82cacb50
	ctx.lr = 0x82EDDB0C;
	sub_82CACB50(ctx, base);
	// 82EDDB0C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDDB10: 4082003C  bne 0x82eddb4c
	if !ctx.cr[0].eq {
	pc = 0x82EDDB4C; continue 'dispatch;
	}
	// 82EDDB14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDDB18: 4BA301F1  bl 0x8290dd08
	ctx.lr = 0x82EDDB1C;
	sub_8290DD08(ctx, base);
	// 82EDDB1C: 4BDCE095  bl 0x82cabbb0
	ctx.lr = 0x82EDDB20;
	sub_82CABBB0(ctx, base);
	// 82EDDB20: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDDB24: C01C002C  lfs f0, 0x2c(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDDB28: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDDB2C: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EDDB30; continue 'dispatch;
            }
            0x82EDDB30 => {
    //   block [0x82EDDB30..0x82EDDB3C)
	// 82EDDB30: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDDB34: 41980008  blt cr6, 0x82eddb3c
	if ctx.cr[6].lt {
	pc = 0x82EDDB3C; continue 'dispatch;
	}
	// 82EDDB38: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDDB3C; continue 'dispatch;
            }
            0x82EDDB3C => {
    //   block [0x82EDDB3C..0x82EDDB4C)
	// 82EDDB3C: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDDB40: 409AFFF0  bne cr6, 0x82eddb30
	if !ctx.cr[6].eq {
	pc = 0x82EDDB30; continue 'dispatch;
	}
	// 82EDDB44: D01C002C  stfs f0, 0x2c(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EDDB48: 4BFFFA98  b 0x82edd5e0
	pc = 0x82EDD5E0; continue 'dispatch;
            }
            0x82EDDB4C => {
    //   block [0x82EDDB4C..0x82EDDB80)
	// 82EDDB4C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDDB50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDDB54: 388BBB78  addi r4, r11, -0x4488
	ctx.r[4].s64 = ctx.r[11].s64 + -17544;
	// 82EDDB58: 4BDCEFF9  bl 0x82cacb50
	ctx.lr = 0x82EDDB5C;
	sub_82CACB50(ctx, base);
	// 82EDDB5C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDDB60: 40820020  bne 0x82eddb80
	if !ctx.cr[0].eq {
	pc = 0x82EDDB80; continue 'dispatch;
	}
	// 82EDDB64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDDB68: 4BA301A1  bl 0x8290dd08
	ctx.lr = 0x82EDDB6C;
	sub_8290DD08(ctx, base);
	// 82EDDB6C: 4BDCC855  bl 0x82caa3c0
	ctx.lr = 0x82EDDB70;
	sub_82CAA3C0(ctx, base);
	// 82EDDB70: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDDB74: 4180FA6C  blt 0x82edd5e0
	if ctx.cr[0].lt {
	pc = 0x82EDD5E0; continue 'dispatch;
	}
	// 82EDDB78: 907C0030  stw r3, 0x30(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(48 as u32), ctx.r[3].u32 ) };
	// 82EDDB7C: 4BFFFA64  b 0x82edd5e0
	pc = 0x82EDD5E0; continue 'dispatch;
            }
            0x82EDDB80 => {
    //   block [0x82EDDB80..0x82EDDBB4)
	// 82EDDB80: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDDB84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDDB88: 388BBB68  addi r4, r11, -0x4498
	ctx.r[4].s64 = ctx.r[11].s64 + -17560;
	// 82EDDB8C: 4BDCEFC5  bl 0x82cacb50
	ctx.lr = 0x82EDDB90;
	sub_82CACB50(ctx, base);
	// 82EDDB90: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDDB94: 4082003C  bne 0x82eddbd0
	if !ctx.cr[0].eq {
	pc = 0x82EDDBD0; continue 'dispatch;
	}
	// 82EDDB98: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDDB9C: 4BA3016D  bl 0x8290dd08
	ctx.lr = 0x82EDDBA0;
	sub_8290DD08(ctx, base);
	// 82EDDBA0: 4BDCE011  bl 0x82cabbb0
	ctx.lr = 0x82EDDBA4;
	sub_82CABBB0(ctx, base);
	// 82EDDBA4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDDBA8: C01C0034  lfs f0, 0x34(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDDBAC: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDDBB0: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EDDBB4; continue 'dispatch;
            }
            0x82EDDBB4 => {
    //   block [0x82EDDBB4..0x82EDDBC0)
	// 82EDDBB4: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDDBB8: 40990008  ble cr6, 0x82eddbc0
	if !ctx.cr[6].gt {
	pc = 0x82EDDBC0; continue 'dispatch;
	}
	// 82EDDBBC: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDDBC0; continue 'dispatch;
            }
            0x82EDDBC0 => {
    //   block [0x82EDDBC0..0x82EDDBD0)
	// 82EDDBC0: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDDBC4: 409AFFF0  bne cr6, 0x82eddbb4
	if !ctx.cr[6].eq {
	pc = 0x82EDDBB4; continue 'dispatch;
	}
	// 82EDDBC8: D01C0034  stfs f0, 0x34(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82EDDBCC: 4BFFFA14  b 0x82edd5e0
	pc = 0x82EDD5E0; continue 'dispatch;
            }
            0x82EDDBD0 => {
    //   block [0x82EDDBD0..0x82EDDC00)
	// 82EDDBD0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDDBD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDDBD8: 388BAD78  addi r4, r11, -0x5288
	ctx.r[4].s64 = ctx.r[11].s64 + -21128;
	// 82EDDBDC: 4BDCEF75  bl 0x82cacb50
	ctx.lr = 0x82EDDBE0;
	sub_82CACB50(ctx, base);
	// 82EDDBE0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDDBE4: 40820060  bne 0x82eddc44
	if !ctx.cr[0].eq {
	pc = 0x82EDDC44; continue 'dispatch;
	}
	// 82EDDBE8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDDBEC: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDDBF0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDDBF4: 4182000C  beq 0x82eddc00
	if ctx.cr[0].eq {
	pc = 0x82EDDC00; continue 'dispatch;
	}
	// 82EDDBF8: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EDDBFC: 4800000C  b 0x82eddc08
	pc = 0x82EDDC08; continue 'dispatch;
            }
            0x82EDDC00 => {
    //   block [0x82EDDC00..0x82EDDC08)
	// 82EDDC00: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDDC04: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EDDC08; continue 'dispatch;
            }
            0x82EDDC08 => {
    //   block [0x82EDDC08..0x82EDDC28)
	// 82EDDC08: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDDC0C: 4BA300FD  bl 0x8290dd08
	ctx.lr = 0x82EDDC10;
	sub_8290DD08(ctx, base);
	// 82EDDC10: 4BDCDFA1  bl 0x82cabbb0
	ctx.lr = 0x82EDDC14;
	sub_82CABBB0(ctx, base);
	// 82EDDC14: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDDC18: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDDC1C: C01C0038  lfs f0, 0x38(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDDC20: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDDC24: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	pc = 0x82EDDC28; continue 'dispatch;
            }
            0x82EDDC28 => {
    //   block [0x82EDDC28..0x82EDDC34)
	// 82EDDC28: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDDC2C: 41980008  blt cr6, 0x82eddc34
	if ctx.cr[6].lt {
	pc = 0x82EDDC34; continue 'dispatch;
	}
	// 82EDDC30: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDDC34; continue 'dispatch;
            }
            0x82EDDC34 => {
    //   block [0x82EDDC34..0x82EDDC44)
	// 82EDDC34: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDDC38: 409AFFF0  bne cr6, 0x82eddc28
	if !ctx.cr[6].eq {
	pc = 0x82EDDC28; continue 'dispatch;
	}
	// 82EDDC3C: D01C0038  stfs f0, 0x38(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82EDDC40: 4BFFF9A0  b 0x82edd5e0
	pc = 0x82EDD5E0; continue 'dispatch;
            }
            0x82EDDC44 => {
    //   block [0x82EDDC44..0x82EDDCB8)
	// 82EDDC44: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDDC48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDDC4C: 388BAD6C  addi r4, r11, -0x5294
	ctx.r[4].s64 = ctx.r[11].s64 + -21140;
	// 82EDDC50: 4BDCEF01  bl 0x82cacb50
	ctx.lr = 0x82EDDC54;
	sub_82CACB50(ctx, base);
	// 82EDDC54: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDDC58: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDDC5C: 40820064  bne 0x82eddcc0
	if !ctx.cr[0].eq {
	pc = 0x82EDDCC0; continue 'dispatch;
	}
	// 82EDDC60: 4BA300A9  bl 0x8290dd08
	ctx.lr = 0x82EDDC64;
	sub_8290DD08(ctx, base);
	// 82EDDC64: 4BDCDF4D  bl 0x82cabbb0
	ctx.lr = 0x82EDDC68;
	sub_82CABBB0(ctx, base);
	// 82EDDC68: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDDC6C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDDC70: C00B0A44  lfs f0, 0xa44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2628 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDDC74: FD806A10  fabs f12, f13
	ctx.f[12].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 82EDDC78: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82EDDC7C: 4199F964  bgt cr6, 0x82edd5e0
	if ctx.cr[6].gt {
	pc = 0x82EDD5E0; continue 'dispatch;
	}
	// 82EDDC80: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EDDC84: C00BE228  lfs f0, -0x1dd8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7640 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDDC88: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EDDC8C: 4B35C225  bl 0x82239eb0
	ctx.lr = 0x82EDDC90;
	sub_82239EB0(ctx, base);
	// 82EDDC90: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDDC94: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDDC98: D01C0044  stfs f0, 0x44(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82EDDC9C: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDDCA0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EDDCA4: 41990014  bgt cr6, 0x82eddcb8
	if ctx.cr[6].gt {
	pc = 0x82EDDCB8; continue 'dispatch;
	}
	// 82EDDCA8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDDCAC: C1AB0EE0  lfs f13, 0xee0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDDCB0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EDDCB4: 4098F92C  bge cr6, 0x82edd5e0
	if !ctx.cr[6].lt {
	pc = 0x82EDD5E0; continue 'dispatch;
	}
	pc = 0x82EDDCB8; continue 'dispatch;
            }
            0x82EDDCB8 => {
    //   block [0x82EDDCB8..0x82EDDCC0)
	// 82EDDCB8: D1BC0044  stfs f13, 0x44(r28)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82EDDCBC: 4BFFF924  b 0x82edd5e0
	pc = 0x82EDD5E0; continue 'dispatch;
            }
            0x82EDDCC0 => {
    //   block [0x82EDDCC0..0x82EDDD9C)
	// 82EDDCC0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDDCC4: 3BEBBB5C  addi r31, r11, -0x44a4
	ctx.r[31].s64 = ctx.r[11].s64 + -17572;
	// 82EDDCC8: 482DE399  bl 0x831bc060
	ctx.lr = 0x82EDDCCC;
	sub_831BC060(ctx, base);
	// 82EDDCCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDDCD0: 4BDCEE81  bl 0x82cacb50
	ctx.lr = 0x82EDDCD4;
	sub_82CACB50(ctx, base);
	// 82EDDCD4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDDCD8: 408200D8  bne 0x82edddb0
	if !ctx.cr[0].eq {
	pc = 0x82EDDDB0; continue 'dispatch;
	}
	// 82EDDCDC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EDDCE0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDDCE4: 3BEB1694  addi r31, r11, 0x1694
	ctx.r[31].s64 = ctx.r[11].s64 + 5780;
	// 82EDDCE8: 4BA30021  bl 0x8290dd08
	ctx.lr = 0x82EDDCEC;
	sub_8290DD08(ctx, base);
	// 82EDDCEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDDCF0: 4BDCEE61  bl 0x82cacb50
	ctx.lr = 0x82EDDCF4;
	sub_82CACB50(ctx, base);
	// 82EDDCF4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDDCF8: 418200AC  beq 0x82eddda4
	if ctx.cr[0].eq {
	pc = 0x82EDDDA4; continue 'dispatch;
	}
	// 82EDDCFC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDDD00: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDDD04: 3BEB0F40  addi r31, r11, 0xf40
	ctx.r[31].s64 = ctx.r[11].s64 + 3904;
	// 82EDDD08: 4BA30001  bl 0x8290dd08
	ctx.lr = 0x82EDDD0C;
	sub_8290DD08(ctx, base);
	// 82EDDD0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDDD10: 4BDCEE41  bl 0x82cacb50
	ctx.lr = 0x82EDDD14;
	sub_82CACB50(ctx, base);
	// 82EDDD14: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDDD18: 4182008C  beq 0x82eddda4
	if ctx.cr[0].eq {
	pc = 0x82EDDDA4; continue 'dispatch;
	}
	// 82EDDD1C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82EDDD20: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDDD24: 3BEBD56C  addi r31, r11, -0x2a94
	ctx.r[31].s64 = ctx.r[11].s64 + -10900;
	// 82EDDD28: 4BA2FFE1  bl 0x8290dd08
	ctx.lr = 0x82EDDD2C;
	sub_8290DD08(ctx, base);
	// 82EDDD2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDDD30: 4BDCEE21  bl 0x82cacb50
	ctx.lr = 0x82EDDD34;
	sub_82CACB50(ctx, base);
	// 82EDDD34: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDDD38: 4182006C  beq 0x82eddda4
	if ctx.cr[0].eq {
	pc = 0x82EDDDA4; continue 'dispatch;
	}
	// 82EDDD3C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EDDD40: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDDD44: 3BEB1698  addi r31, r11, 0x1698
	ctx.r[31].s64 = ctx.r[11].s64 + 5784;
	// 82EDDD48: 4BA2FFC1  bl 0x8290dd08
	ctx.lr = 0x82EDDD4C;
	sub_8290DD08(ctx, base);
	// 82EDDD4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDDD50: 4BDCEE01  bl 0x82cacb50
	ctx.lr = 0x82EDDD54;
	sub_82CACB50(ctx, base);
	// 82EDDD54: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDDD58: 41820044  beq 0x82eddd9c
	if ctx.cr[0].eq {
	pc = 0x82EDDD9C; continue 'dispatch;
	}
	// 82EDDD5C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EDDD60: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDDD64: 3BEB1700  addi r31, r11, 0x1700
	ctx.r[31].s64 = ctx.r[11].s64 + 5888;
	// 82EDDD68: 4BA2FFA1  bl 0x8290dd08
	ctx.lr = 0x82EDDD6C;
	sub_8290DD08(ctx, base);
	// 82EDDD6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDDD70: 4BDCEDE1  bl 0x82cacb50
	ctx.lr = 0x82EDDD74;
	sub_82CACB50(ctx, base);
	// 82EDDD74: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDDD78: 41820024  beq 0x82eddd9c
	if ctx.cr[0].eq {
	pc = 0x82EDDD9C; continue 'dispatch;
	}
	// 82EDDD7C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EDDD80: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82EDDD84: 3BEB7088  addi r31, r11, 0x7088
	ctx.r[31].s64 = ctx.r[11].s64 + 28808;
	// 82EDDD88: 4BA2FF81  bl 0x8290dd08
	ctx.lr = 0x82EDDD8C;
	sub_8290DD08(ctx, base);
	// 82EDDD8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDDD90: 4BDCEDC1  bl 0x82cacb50
	ctx.lr = 0x82EDDD94;
	sub_82CACB50(ctx, base);
	// 82EDDD94: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDDD98: 40820018  bne 0x82edddb0
	if !ctx.cr[0].eq {
	pc = 0x82EDDDB0; continue 'dispatch;
	}
	pc = 0x82EDDD9C; continue 'dispatch;
            }
            0x82EDDD9C => {
    //   block [0x82EDDD9C..0x82EDDDA4)
	// 82EDDD9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EDDDA0: 48000008  b 0x82eddda8
	pc = 0x82EDDDA8; continue 'dispatch;
            }
            0x82EDDDA4 => {
    //   block [0x82EDDDA4..0x82EDDDA8)
	// 82EDDDA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82EDDDA8; continue 'dispatch;
            }
            0x82EDDDA8 => {
    //   block [0x82EDDDA8..0x82EDDDB0)
	// 82EDDDA8: 997C003C  stb r11, 0x3c(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(60 as u32), ctx.r[11].u8 ) };
	// 82EDDDAC: 4BFFF834  b 0x82edd5e0
	pc = 0x82EDD5E0; continue 'dispatch;
            }
            0x82EDDDB0 => {
    //   block [0x82EDDDB0..0x82EDDDB4)
	// 82EDDDB0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EDDDB4; continue 'dispatch;
            }
            0x82EDDDB4 => {
    //   block [0x82EDDDB4..0x82EDDDC4)
	// 82EDDDB4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EDDDB8: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82EDDDBC: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82EDDDC0: 4BDCB698  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDDDC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EDDDC8 size=20
    let mut pc: u32 = 0x82EDDDC8;
    'dispatch: loop {
        match pc {
            0x82EDDDC8 => {
    //   block [0x82EDDDC8..0x82EDDDDC)
	// 82EDDDC8: 81630098  lwz r11, 0x98(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(152 as u32) ) } as u64;
	// 82EDDDCC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDDDD0: 419A000C  beq cr6, 0x82eddddc
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82EDDDDC);
		return;
	}
	// 82EDDDD4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EDDDD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDDE18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EDDE18 size=88
    let mut pc: u32 = 0x82EDDE18;
    'dispatch: loop {
        match pc {
            0x82EDDE18 => {
    //   block [0x82EDDE18..0x82EDDE54)
	// 82EDDE18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDDE1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EDDE20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EDDE24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EDDE28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDDE2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDDE30: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EDDE34: 4BFFF61D  bl 0x82edd450
	ctx.lr = 0x82EDDE38;
	sub_82EDD450(ctx, base);
	// 82EDDE38: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDDE3C: 41820018  beq 0x82edde54
	if ctx.cr[0].eq {
	pc = 0x82EDDE54; continue 'dispatch;
	}
	// 82EDDE40: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EDDE44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDDE48: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EDDE4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDDE50: 4E800421  bctrl
	ctx.lr = 0x82EDDE54;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EDDE54 => {
    //   block [0x82EDDE54..0x82EDDE70)
	// 82EDDE54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDDE58: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EDDE5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EDDE60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EDDE64: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EDDE68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EDDE6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDDE70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EDDE70 size=244
    let mut pc: u32 = 0x82EDDE70;
    'dispatch: loop {
        match pc {
            0x82EDDE70 => {
    //   block [0x82EDDE70..0x82EDDECC)
	// 82EDDE70: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDDE74: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EDDE78: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82EDDE7C: C00B0BEC  lfs f0, 0xbec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDDE80: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EDDE84: C1A80C14  lfs f13, 0xc14(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDDE88: 996300FA  stb r11, 0xfa(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(250 as u32), ctx.r[11].u8 ) };
	// 82EDDE8C: D0030080  stfs f0, 0x80(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EDDE90: D0030084  stfs f0, 0x84(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EDDE94: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDDE98: D0030088  stfs f0, 0x88(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EDDE9C: D003008C  stfs f0, 0x8c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EDDEA0: C0030084  lfs f0, 0x84(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDDEA4: D0030090  stfs f0, 0x90(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82EDDEA8: C0030088  lfs f0, 0x88(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDDEAC: D0030094  stfs f0, 0x94(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82EDDEB0: 91430098  stw r10, 0x98(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), ctx.r[10].u32 ) };
	// 82EDDEB4: 91430114  stw r10, 0x114(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(276 as u32), ctx.r[10].u32 ) };
	// 82EDDEB8: 812B0718  lwz r9, 0x718(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDDEBC: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDDEC0: 4182000C  beq 0x82eddecc
	if ctx.cr[0].eq {
	pc = 0x82EDDECC; continue 'dispatch;
	}
	// 82EDDEC4: C009000C  lfs f0, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDDEC8: 48000008  b 0x82edded0
	pc = 0x82EDDED0; continue 'dispatch;
            }
            0x82EDDECC => {
    //   block [0x82EDDECC..0x82EDDED0)
	// 82EDDECC: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDDED0; continue 'dispatch;
            }
            0x82EDDED0 => {
    //   block [0x82EDDED0..0x82EDDEE4)
	// 82EDDED0: D0030074  stfs f0, 0x74(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EDDED4: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDDED8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDDEDC: 41820008  beq 0x82eddee4
	if ctx.cr[0].eq {
	pc = 0x82EDDEE4; continue 'dispatch;
	}
	// 82EDDEE0: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82EDDEE4; continue 'dispatch;
            }
            0x82EDDEE4 => {
    //   block [0x82EDDEE4..0x82EDDF08)
	// 82EDDEE4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EDDEE8: 816300D4  lwz r11, 0xd4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EDDEEC: D1A30078  stfs f13, 0x78(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EDDEF0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDDEF4: C0090C18  lfs f0, 0xc18(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDDEF8: D00300CC  stfs f0, 0xcc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EDDEFC: D00300D0  stfs f0, 0xd0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82EDDF00: 41820040  beq 0x82eddf40
	if ctx.cr[0].eq {
	pc = 0x82EDDF40; continue 'dispatch;
	}
	// 82EDDF04: 48000028  b 0x82eddf2c
	pc = 0x82EDDF2C; continue 'dispatch;
            }
            0x82EDDF08 => {
    //   block [0x82EDDF08..0x82EDDF2C)
	// 82EDDF08: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDDF0C: 99490030  stb r10, 0x30(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(48 as u32), ctx.r[10].u8 ) };
	// 82EDDF10: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDDF14: 80EB0010  lwz r7, 0x10(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EDDF18: 8109002C  lwz r8, 0x2c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EDDF1C: 90E9002C  stw r7, 0x2c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(44 as u32), ctx.r[7].u32 ) };
	// 82EDDF20: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDDF24: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82EDDF28: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	pc = 0x82EDDF2C; continue 'dispatch;
            }
            0x82EDDF2C => {
    //   block [0x82EDDF2C..0x82EDDF40)
	// 82EDDF2C: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDDF30: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EDDF34: 409AFFD4  bne cr6, 0x82eddf08
	if !ctx.cr[6].eq {
	pc = 0x82EDDF08; continue 'dispatch;
	}
	// 82EDDF38: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EDDF3C: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	pc = 0x82EDDF40; continue 'dispatch;
            }
            0x82EDDF40 => {
    //   block [0x82EDDF40..0x82EDDF64)
	// 82EDDF40: D00300D8  stfs f0, 0xd8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EDDF44: D00300DC  stfs f0, 0xdc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EDDF48: D00300E0  stfs f0, 0xe0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EDDF4C: 914300F4  stw r10, 0xf4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(244 as u32), ctx.r[10].u32 ) };
	// 82EDDF50: D00300E4  stfs f0, 0xe4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EDDF54: 994300F9  stb r10, 0xf9(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(249 as u32), ctx.r[10].u8 ) };
	// 82EDDF58: D00300FC  stfs f0, 0xfc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82EDDF5C: 99430100  stb r10, 0x100(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(256 as u32), ctx.r[10].u8 ) };
	// 82EDDF60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDDF68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EDDF68 size=1708
    let mut pc: u32 = 0x82EDDF68;
    'dispatch: loop {
        match pc {
            0x82EDDF68 => {
    //   block [0x82EDDF68..0x82EDE050)
	// 82EDDF68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDDF6C: 4BDCB495  bl 0x82ca9400
	ctx.lr = 0x82EDDF70;
	sub_82CA93D0(ctx, base);
	// 82EDDF70: DBA1FFB0  stfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[29].u64 ) };
	// 82EDDF74: DBC1FFB8  stfd f30, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 82EDDF78: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82EDDF7C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDDF80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDDF84: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EDDF88: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82EDDF8C: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EDDF90: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDDF94: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EDDF98: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDDF9C: D01F005C  stfs f0, 0x5c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EDDFA0: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDDFA4: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EDDFA8: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDDFAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDDFB0: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82EDDFB4: D01F0064  stfs f0, 0x64(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EDDFB8: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EDDFBC: C13E0004  lfs f9, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EDDFC0: C01F0060  lfs f0, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDDFC4: EC004828  fsubs f0, f0, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EDDFC8: C15E0008  lfs f10, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EDDFCC: C19E0000  lfs f12, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDDFD0: C17F005C  lfs f11, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDDFD4: C12A0010  lfs f9, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EDDFD8: ED6B6028  fsubs f11, f11, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EDDFDC: C3CB0C18  lfs f30, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EDDFE0: FF09F000  fcmpu cr6, f9, f30
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[30].f64);
	// 82EDDFE4: EDAD5028  fsubs f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EDDFE8: 409905E0  ble cr6, 0x82ede5c8
	if !ctx.cr[6].gt {
	pc = 0x82EDE5C8; continue 'dispatch;
	}
	// 82EDDFEC: ED6B02F2  fmuls f11, f11, f11
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EDDFF0: EC00583A  fmadds f0, f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EDDFF4: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EDDFF8: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82EDDFFC: 419A05CC  beq cr6, 0x82ede5c8
	if ctx.cr[6].eq {
	pc = 0x82EDE5C8; continue 'dispatch;
	}
	// 82EDE000: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDE004: C1BF0080  lfs f13, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDE008: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EDE00C: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82EDE010: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 82EDE014: C00B0BEC  lfs f0, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE018: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EDE01C: 409A0034  bne cr6, 0x82ede050
	if !ctx.cr[6].eq {
	pc = 0x82EDE050; continue 'dispatch;
	}
	// 82EDE020: D19F0080  stfs f12, 0x80(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EDE024: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	// 82EDE028: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE02C: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EDE030: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE034: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EDE038: D1BF008C  stfs f13, 0x8c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EDE03C: C01F0084  lfs f0, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE040: D01F0090  stfs f0, 0x90(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82EDE044: C01F0088  lfs f0, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE048: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82EDE04C: 48000174  b 0x82ede1c0
	pc = 0x82EDE1C0; continue 'dispatch;
            }
            0x82EDE050 => {
    //   block [0x82EDE050..0x82EDE080)
	// 82EDE050: C00A0034  lfs f0, 0x34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE054: C1BF0088  lfs f13, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDE058: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDE05C: EC0D5028  fsubs f0, f13, f10
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EDE060: C13F0080  lfs f9, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EDE064: EDA96028  fsubs f13, f9, f12
	ctx.f[13].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EDE068: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDE06C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EDE070: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EDE074: 4099000C  ble cr6, 0x82ede080
	if !ctx.cr[6].gt {
	pc = 0x82EDE080; continue 'dispatch;
	}
	// 82EDE078: D19F0080  stfs f12, 0x80(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EDE07C: 48000134  b 0x82ede1b0
	pc = 0x82EDE1B0; continue 'dispatch;
            }
            0x82EDE080 => {
    //   block [0x82EDE080..0x82EDE0F0)
	// 82EDE080: 4B382939  bl 0x822609b8
	ctx.lr = 0x82EDE084;
	sub_822609B8(ctx, base);
	// 82EDE084: C01F00CC  lfs f0, 0xcc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE088: C1A3004C  lfs f13, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDE08C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EDE090: 40980118  bge cr6, 0x82ede1a8
	if !ctx.cr[6].lt {
	pc = 0x82EDE1A8; continue 'dispatch;
	}
	// 82EDE094: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDE098: 4BFFFD31  bl 0x82edddc8
	ctx.lr = 0x82EDE09C;
	sub_82EDDDC8(ctx, base);
	// 82EDE09C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDE0A0: 408200E8  bne 0x82ede188
	if !ctx.cr[0].eq {
	pc = 0x82EDE188; continue 'dispatch;
	}
	// 82EDE0A4: D3DF00D8  stfs f30, 0xd8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EDE0A8: D3DF00DC  stfs f30, 0xdc(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EDE0AC: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE0B0: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EDE0B4: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE0B8: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EDE0BC: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE0C0: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EDE0C4: C01F0080  lfs f0, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE0C8: D01F008C  stfs f0, 0x8c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EDE0CC: C01F0084  lfs f0, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE0D0: D01F0090  stfs f0, 0x90(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82EDE0D4: C01F0088  lfs f0, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE0D8: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82EDE0DC: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EDE0E0: 817F00D4  lwz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EDE0E4: C00A0010  lfs f0, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE0E8: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EDE0EC: 48000028  b 0x82ede114
	pc = 0x82EDE114; continue 'dispatch;
            }
            0x82EDE0F0 => {
    //   block [0x82EDE0F0..0x82EDE114)
	// 82EDE0F0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDE0F4: 9B6A0030  stb r27, 0x30(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(48 as u32), ctx.r[27].u8 ) };
	// 82EDE0F8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDE0FC: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EDE100: 812A002C  lwz r9, 0x2c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EDE104: 910A002C  stw r8, 0x2c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(44 as u32), ctx.r[8].u32 ) };
	// 82EDE108: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDE10C: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82EDE110: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	pc = 0x82EDE114; continue 'dispatch;
            }
            0x82EDE114 => {
    //   block [0x82EDE114..0x82EDE188)
	// 82EDE114: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDE118: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EDE11C: 409AFFD4  bne cr6, 0x82ede0f0
	if !ctx.cr[6].eq {
	pc = 0x82EDE0F0; continue 'dispatch;
	}
	// 82EDE120: 936B000C  stw r27, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	// 82EDE124: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EDE128: 936B0014  stw r27, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[27].u32 ) };
	// 82EDE12C: C01F00E8  lfs f0, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE130: D01C0000  stfs f0, 0(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EDE134: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EDE138: C1BF0080  lfs f13, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDE13C: C01F005C  lfs f0, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE140: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EDE144: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EDE148: C19F0084  lfs f12, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDE14C: C01F0060  lfs f0, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE150: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EDE154: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EDE158: C1BF0088  lfs f13, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDE15C: C01F0064  lfs f0, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE160: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EDE164: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EDE168: 4B3A1101  bl 0x8227f268
	ctx.lr = 0x82EDE16C;
	sub_8227F268(ctx, base);
	// 82EDE16C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EDE170: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE174: D01C0004  stfs f0, 4(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EDE178: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE17C: D01C0008  stfs f0, 8(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EDE180: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE184: 48000464  b 0x82ede5e8
	pc = 0x82EDE5E8; continue 'dispatch;
            }
            0x82EDE188 => {
    //   block [0x82EDE188..0x82EDE1A8)
	// 82EDE188: C01F0080  lfs f0, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE18C: C1BF005C  lfs f13, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDE190: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EDE194: 409A0030  bne cr6, 0x82ede1c4
	if !ctx.cr[6].eq {
	pc = 0x82EDE1C4; continue 'dispatch;
	}
	// 82EDE198: C01F0088  lfs f0, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE19C: C1BF0064  lfs f13, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDE1A0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EDE1A4: 409A0020  bne cr6, 0x82ede1c4
	if !ctx.cr[6].eq {
	pc = 0x82EDE1C4; continue 'dispatch;
	}
	pc = 0x82EDE1A8; continue 'dispatch;
            }
            0x82EDE1A8 => {
    //   block [0x82EDE1A8..0x82EDE1B0)
	// 82EDE1A8: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE1AC: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	pc = 0x82EDE1B0; continue 'dispatch;
            }
            0x82EDE1B0 => {
    //   block [0x82EDE1B0..0x82EDE1C0)
	// 82EDE1B0: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE1B4: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EDE1B8: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE1BC: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	pc = 0x82EDE1C0; continue 'dispatch;
            }
            0x82EDE1C0 => {
    //   block [0x82EDE1C0..0x82EDE1C4)
	// 82EDE1C0: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	pc = 0x82EDE1C4; continue 'dispatch;
            }
            0x82EDE1C4 => {
    //   block [0x82EDE1C4..0x82EDE1E4)
	// 82EDE1C4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EDE1C8: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EDE1CC: 3D208334  lis r9, -0x7ccc
	ctx.r[9].s64 = -2093744128;
	// 82EDE1D0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDE1D4: C3EA0C14  lfs f31, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EDE1D8: 4182000C  beq 0x82ede1e4
	if ctx.cr[0].eq {
	pc = 0x82EDE1E4; continue 'dispatch;
	}
	// 82EDE1DC: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE1E0: 4800001C  b 0x82ede1fc
	pc = 0x82EDE1FC; continue 'dispatch;
            }
            0x82EDE1E4 => {
    //   block [0x82EDE1E4..0x82EDE1F8)
	// 82EDE1E4: 81690718  lwz r11, 0x718(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDE1E8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDE1EC: 4182000C  beq 0x82ede1f8
	if ctx.cr[0].eq {
	pc = 0x82EDE1F8; continue 'dispatch;
	}
	// 82EDE1F0: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE1F4: 48000008  b 0x82ede1fc
	pc = 0x82EDE1FC; continue 'dispatch;
            }
            0x82EDE1F8 => {
    //   block [0x82EDE1F8..0x82EDE1FC)
	// 82EDE1F8: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x82EDE1FC; continue 'dispatch;
            }
            0x82EDE1FC => {
    //   block [0x82EDE1FC..0x82EDE228)
	// 82EDE1FC: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EDE200: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EDE204: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDE208: 41820030  beq 0x82ede238
	if ctx.cr[0].eq {
	pc = 0x82EDE238; continue 'dispatch;
	}
	// 82EDE20C: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE210: C1BF0074  lfs f13, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDE214: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EDE218: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EDE21C: 4199000C  bgt cr6, 0x82ede228
	if ctx.cr[6].gt {
	pc = 0x82EDE228; continue 'dispatch;
	}
	// 82EDE220: D1BF0078  stfs f13, 0x78(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EDE224: 4800001C  b 0x82ede240
	pc = 0x82EDE240; continue 'dispatch;
            }
            0x82EDE228 => {
    //   block [0x82EDE228..0x82EDE238)
	// 82EDE228: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EDE22C: 9B5F007C  stb r26, 0x7c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[26].u8 ) };
	// 82EDE230: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EDE234: 48000010  b 0x82ede244
	pc = 0x82EDE244; continue 'dispatch;
            }
            0x82EDE238 => {
    //   block [0x82EDE238..0x82EDE240)
	// 82EDE238: C01F0074  lfs f0, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE23C: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	pc = 0x82EDE240; continue 'dispatch;
            }
            0x82EDE240 => {
    //   block [0x82EDE240..0x82EDE244)
	// 82EDE240: 9B7F007C  stb r27, 0x7c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[27].u8 ) };
	pc = 0x82EDE244; continue 'dispatch;
            }
            0x82EDE244 => {
    //   block [0x82EDE244..0x82EDE264)
	// 82EDE244: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EDE248: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EDE24C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDE250: C3AA0BFC  lfs f29, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EDE254: 41820010  beq 0x82ede264
	if ctx.cr[0].eq {
	pc = 0x82EDE264; continue 'dispatch;
	}
	// 82EDE258: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE25C: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EDE260: 4800001C  b 0x82ede27c
	pc = 0x82EDE27C; continue 'dispatch;
            }
            0x82EDE264 => {
    //   block [0x82EDE264..0x82EDE278)
	// 82EDE264: 81690718  lwz r11, 0x718(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDE268: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDE26C: 4182000C  beq 0x82ede278
	if ctx.cr[0].eq {
	pc = 0x82EDE278; continue 'dispatch;
	}
	// 82EDE270: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE274: 48000008  b 0x82ede27c
	pc = 0x82EDE27C; continue 'dispatch;
            }
            0x82EDE278 => {
    //   block [0x82EDE278..0x82EDE27C)
	// 82EDE278: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x82EDE27C; continue 'dispatch;
            }
            0x82EDE27C => {
    //   block [0x82EDE27C..0x82EDE434)
	// 82EDE27C: C1BF0014  lfs f13, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDE280: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EDE284: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EDE288: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EDE28C: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EDE290: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EDE294: C1BF0080  lfs f13, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDE298: C01F005C  lfs f0, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE29C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EDE2A0: C19F0060  lfs f12, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDE2A4: C1BF0084  lfs f13, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDE2A8: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EDE2AC: C17F0088  lfs f11, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDE2B0: C19F0064  lfs f12, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDE2B4: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EDE2B8: D3C10054  stfs f30, 0x54(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EDE2BC: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDE2C0: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EDE2C4: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EDE2C8: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EDE2CC: D01F00C8  stfs f0, 0xc8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EDE2D0: C19F005C  lfs f12, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDE2D4: EC1F0024  fdivs f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EDE2D8: C1BF0080  lfs f13, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDE2DC: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EDE2E0: C17F0084  lfs f11, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDE2E4: C15F0088  lfs f10, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EDE2E8: C19F0060  lfs f12, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDE2EC: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EDE2F0: C17F0064  lfs f11, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDE2F4: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EDE2F8: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDE2FC: D1BF00B4  stfs f13, 0xb4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82EDE300: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDE304: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EDE308: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDE30C: D01F00BC  stfs f0, 0xbc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82EDE310: D19F00B8  stfs f12, 0xb8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82EDE314: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EDE318: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EDE31C: 4B3A0F4D  bl 0x8227f268
	ctx.lr = 0x82EDE320;
	sub_8227F268(ctx, base);
	// 82EDE320: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE324: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82EDE328: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE32C: D01F00A0  stfs f0, 0xa0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82EDE330: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE334: D01F00A4  stfs f0, 0xa4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82EDE338: C17F00B8  lfs f11, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDE33C: C1BF00A4  lfs f13, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDE340: ED0B0372  fmuls f8, f11, f13
	ctx.f[8].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EDE344: C01F00BC  lfs f0, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE348: C13F009C  lfs f9, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EDE34C: C19F00A0  lfs f12, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDE350: ECE90032  fmuls f7, f9, f0
	ctx.f[7].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDE354: C15F00B4  lfs f10, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EDE358: EC004338  fmsubs f0, f0, f12, f8
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EDE35C: D01F00A8  stfs f0, 0xa8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82EDE360: ED8A0332  fmuls f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EDE364: EDAA3B78  fmsubs f13, f10, f13, f7
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[13].f64 - ctx.f[7].f64) as f32) as f64);
	// 82EDE368: D1BF00AC  stfs f13, 0xac(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82EDE36C: ED8962F8  fmsubs f12, f9, f11, f12
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EDE370: D19F00B0  stfs f12, 0xb0(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82EDE374: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EDE378: C1BF0078  lfs f13, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDE37C: FD806890  fmr f12, f13
	ctx.f[12].f64 = ctx.f[13].f64;
	// 82EDE380: C17F0020  lfs f11, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDE384: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE388: EC1F0024  fdivs f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EDE38C: D01F0108  stfs f0, 0x108(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82EDE390: FD400090  fmr f10, f0
	ctx.f[10].f64 = ctx.f[0].f64;
	// 82EDE394: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDE398: EDAC02B2  fmuls f13, f12, f10
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EDE39C: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EDE3A0: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82EDE3A4: EC0D02F2  fmuls f0, f13, f11
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EDE3A8: D01F0110  stfs f0, 0x110(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 82EDE3AC: 4B38260D  bl 0x822609b8
	ctx.lr = 0x82EDE3B0;
	sub_822609B8(ctx, base);
	// 82EDE3B0: 817F0098  lwz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82EDE3B4: C01F00FC  lfs f0, 0xfc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE3B8: C1A30058  lfs f13, 0x58(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDE3BC: 57AA063F  clrlwi. r10, r29, 0x18
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EDE3C0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EDE3C4: 917F0114  stw r11, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 82EDE3C8: D01F00FC  stfs f0, 0xfc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82EDE3CC: 41820068  beq 0x82ede434
	if ctx.cr[0].eq {
	pc = 0x82EDE434; continue 'dispatch;
	}
	// 82EDE3D0: C01F010C  lfs f0, 0x10c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE3D4: C1BF0110  lfs f13, 0x110(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDE3D8: ED40682A  fadds f10, f0, f13
	ctx.f[10].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EDE3DC: C1BF008C  lfs f13, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDE3E0: C01F005C  lfs f0, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE3E4: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EDE3E8: C19F0094  lfs f12, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDE3EC: C1BF0064  lfs f13, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDE3F0: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EDE3F4: C19F009C  lfs f12, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDE3F8: C13F00A4  lfs f9, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EDE3FC: C17F0108  lfs f11, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDE400: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDE404: ED89637A  fmadds f12, f9, f13, f12
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 82EDE408: D19F00DC  stfs f12, 0xdc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EDE40C: D19F00D8  stfs f12, 0xd8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EDE410: C19F00B4  lfs f12, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDE414: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EDE418: C19F00BC  lfs f12, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDE41C: EC0C037A  fmadds f0, f12, f13, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EDE420: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EDE424: D01F00E4  stfs f0, 0xe4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EDE428: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EDE42C: 40980008  bge cr6, 0x82ede434
	if !ctx.cr[6].lt {
	pc = 0x82EDE434; continue 'dispatch;
	}
	// 82EDE430: 9B5F00F8  stb r26, 0xf8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[26].u8 ) };
	pc = 0x82EDE434; continue 'dispatch;
            }
            0x82EDE434 => {
    //   block [0x82EDE434..0x82EDE4EC)
	// 82EDE434: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82EDE438: 419A010C  beq cr6, 0x82ede544
	if ctx.cr[6].eq {
	pc = 0x82EDE544; continue 'dispatch;
	}
	// 82EDE43C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82EDE440: 419A00F0  beq cr6, 0x82ede530
	if ctx.cr[6].eq {
	pc = 0x82EDE530; continue 'dispatch;
	}
	// 82EDE444: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82EDE448: 409A0134  bne cr6, 0x82ede57c
	if !ctx.cr[6].eq {
	pc = 0x82EDE57C; continue 'dispatch;
	}
	// 82EDE44C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EDE450: 409A00C0  bne cr6, 0x82ede510
	if !ctx.cr[6].eq {
	pc = 0x82EDE510; continue 'dispatch;
	}
	// 82EDE454: C01F00FC  lfs f0, 0xfc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE458: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82EDE45C: 409900B4  ble cr6, 0x82ede510
	if !ctx.cr[6].gt {
	pc = 0x82EDE510; continue 'dispatch;
	}
	// 82EDE460: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EDE464: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EDE468: 409A0114  bne cr6, 0x82ede57c
	if !ctx.cr[6].eq {
	pc = 0x82EDE57C; continue 'dispatch;
	}
	// 82EDE46C: D3DC0000  stfs f30, 0(r28)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EDE470: C17F008C  lfs f11, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDE474: C01F005C  lfs f0, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE478: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EDE47C: C1BF0060  lfs f13, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDE480: C15F0090  lfs f10, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EDE484: EDAA6828  fsubs f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EDE488: C19F0064  lfs f12, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDE48C: C17F0094  lfs f11, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDE490: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EDE494: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDE498: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EDE49C: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EDE4A0: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EDE4A4: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82EDE4A8: 419A0044  beq cr6, 0x82ede4ec
	if ctx.cr[6].eq {
	pc = 0x82EDE4EC; continue 'dispatch;
	}
	// 82EDE4AC: FD605090  fmr f11, f10
	ctx.f[11].f64 = ctx.f[10].f64;
	// 82EDE4B0: C19F008C  lfs f12, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDE4B4: C1BF005C  lfs f13, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDE4B8: EC1F0024  fdivs f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EDE4BC: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EDE4C0: C19F0060  lfs f12, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDE4C4: C15F0094  lfs f10, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EDE4C8: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EDE4CC: C17F0064  lfs f11, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDE4D0: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EDE4D4: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDE4D8: D1BC0004  stfs f13, 4(r28)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EDE4DC: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDE4E0: D19C0008  stfs f12, 8(r28)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EDE4E4: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDE4E8: 48000018  b 0x82ede500
	pc = 0x82EDE500; continue 'dispatch;
            }
            0x82EDE4EC => {
    //   block [0x82EDE4EC..0x82EDE500)
	// 82EDE4EC: C01F00B4  lfs f0, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE4F0: D01C0004  stfs f0, 4(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EDE4F4: C01F00B8  lfs f0, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE4F8: D01C0008  stfs f0, 8(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EDE4FC: C01F00BC  lfs f0, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82EDE500; continue 'dispatch;
            }
            0x82EDE500 => {
    //   block [0x82EDE500..0x82EDE510)
	// 82EDE500: D01C000C  stfs f0, 0xc(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EDE504: 9B7C001C  stb r27, 0x1c(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(28 as u32), ctx.r[27].u8 ) };
	// 82EDE508: 9B7C001D  stb r27, 0x1d(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(29 as u32), ctx.r[27].u8 ) };
	// 82EDE50C: 480000F4  b 0x82ede600
	pc = 0x82EDE600; continue 'dispatch;
            }
            0x82EDE510 => {
    //   block [0x82EDE510..0x82EDE524)
	// 82EDE510: C01F00FC  lfs f0, 0xfc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE514: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82EDE518: 4199000C  bgt cr6, 0x82ede524
	if ctx.cr[6].gt {
	pc = 0x82EDE524; continue 'dispatch;
	}
	// 82EDE51C: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EDE520: 9B4B01B5  stb r26, 0x1b5(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(437 as u32), ctx.r[26].u8 ) };
	pc = 0x82EDE524; continue 'dispatch;
            }
            0x82EDE524 => {
    //   block [0x82EDE524..0x82EDE530)
	// 82EDE524: C01F002C  lfs f0, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE528: D01F00FC  stfs f0, 0xfc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82EDE52C: 48000048  b 0x82ede574
	pc = 0x82EDE574; continue 'dispatch;
            }
            0x82EDE530 => {
    //   block [0x82EDE530..0x82EDE544)
	// 82EDE530: C01F00FC  lfs f0, 0xfc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE534: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82EDE538: 40980044  bge cr6, 0x82ede57c
	if !ctx.cr[6].lt {
	pc = 0x82EDE57C; continue 'dispatch;
	}
	// 82EDE53C: 937F0114  stw r27, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[27].u32 ) };
	// 82EDE540: 4800003C  b 0x82ede57c
	pc = 0x82EDE57C; continue 'dispatch;
            }
            0x82EDE544 => {
    //   block [0x82EDE544..0x82EDE56C)
	// 82EDE544: C01F00FC  lfs f0, 0xfc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE548: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82EDE54C: 41990030  bgt cr6, 0x82ede57c
	if ctx.cr[6].gt {
	pc = 0x82EDE57C; continue 'dispatch;
	}
	// 82EDE550: C01F0028  lfs f0, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE554: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82EDE558: 40990014  ble cr6, 0x82ede56c
	if !ctx.cr[6].gt {
	pc = 0x82EDE56C; continue 'dispatch;
	}
	// 82EDE55C: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82EDE560: D01F00FC  stfs f0, 0xfc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82EDE564: 917F0114  stw r11, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 82EDE568: 4800000C  b 0x82ede574
	pc = 0x82EDE574; continue 'dispatch;
            }
            0x82EDE56C => {
    //   block [0x82EDE56C..0x82EDE574)
	// 82EDE56C: D3DF00FC  stfs f30, 0xfc(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82EDE570: 937F0114  stw r27, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[27].u32 ) };
	pc = 0x82EDE574; continue 'dispatch;
            }
            0x82EDE574 => {
    //   block [0x82EDE574..0x82EDE57C)
	// 82EDE574: 9B5F00F8  stb r26, 0xf8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[26].u8 ) };
	// 82EDE578: 9B5F00FA  stb r26, 0xfa(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(250 as u32), ctx.r[26].u8 ) };
	pc = 0x82EDE57C; continue 'dispatch;
            }
            0x82EDE57C => {
    //   block [0x82EDE57C..0x82EDE5C8)
	// 82EDE57C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EDE580: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDE584: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EDE588: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDE58C: 4E800421  bctrl
	ctx.lr = 0x82EDE590;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EDE590: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EDE594: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDE598: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EDE59C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDE5A0: 4E800421  bctrl
	ctx.lr = 0x82EDE5A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EDE5A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDE5A8: 48008781  bl 0x82ee6d28
	ctx.lr = 0x82EDE5AC;
	sub_82EE6D28(ctx, base);
	// 82EDE5AC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EDE5B0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EDE5B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDE5B8: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EDE5BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDE5C0: 4E800421  bctrl
	ctx.lr = 0x82EDE5C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EDE5C4: 4800003C  b 0x82ede600
	pc = 0x82EDE600; continue 'dispatch;
            }
            0x82EDE5C8 => {
    //   block [0x82EDE5C8..0x82EDE5E8)
	// 82EDE5C8: D3DC0000  stfs f30, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EDE5CC: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EDE5D0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82EDE5D4: C00B004C  lfs f0, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE5D8: D01C0004  stfs f0, 4(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EDE5DC: C00B0050  lfs f0, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE5E0: D01C0008  stfs f0, 8(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EDE5E4: C00B0054  lfs f0, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82EDE5E8; continue 'dispatch;
            }
            0x82EDE5E8 => {
    //   block [0x82EDE5E8..0x82EDE600)
	// 82EDE5E8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EDE5EC: D01C000C  stfs f0, 0xc(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EDE5F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDE5F4: 9B7C001C  stb r27, 0x1c(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(28 as u32), ctx.r[27].u8 ) };
	// 82EDE5F8: 9B7C001D  stb r27, 0x1d(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(29 as u32), ctx.r[27].u8 ) };
	// 82EDE5FC: 4800857D  bl 0x82ee6b78
	ctx.lr = 0x82EDE600;
	sub_82EE6B78(ctx, base);
	pc = 0x82EDE600; continue 'dispatch;
            }
            0x82EDE600 => {
    //   block [0x82EDE600..0x82EDE614)
	// 82EDE600: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82EDE604: CBA1FFB0  lfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82EDE608: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82EDE60C: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82EDE610: 4BDCAE40  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDE618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EDE618 size=192
    let mut pc: u32 = 0x82EDE618;
    'dispatch: loop {
        match pc {
            0x82EDE618 => {
    //   block [0x82EDE618..0x82EDE658)
	// 82EDE618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDE61C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EDE620: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EDE624: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EDE628: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDE62C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDE630: 548B07BD  rlwinm. r11, r4, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDE634: 4182005C  beq 0x82ede690
	if ctx.cr[0].eq {
	pc = 0x82EDE690; continue 'dispatch;
	}
	// 82EDE638: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EDE63C: 3BDFFFFC  addi r30, r31, -4
	ctx.r[30].s64 = ctx.r[31].s64 + -4;
	// 82EDE640: 1D4B0034  mulli r10, r11, 0x34
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 52 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EDE644: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDE648: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82EDE64C: 41800020  blt 0x82ede66c
	if ctx.cr[0].lt {
	pc = 0x82EDE66C; continue 'dispatch;
	}
	// 82EDE650: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82EDE654: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	pc = 0x82EDE658; continue 'dispatch;
            }
            0x82EDE658 => {
    //   block [0x82EDE658..0x82EDE66C)
	// 82EDE658: 394AFFCC  addi r10, r10, -0x34
	ctx.r[10].s64 = ctx.r[10].s64 + -52;
	// 82EDE65C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDE660: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EDE664: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EDE668: 4080FFF0  bge 0x82ede658
	if !ctx.cr[0].lt {
	pc = 0x82EDE658; continue 'dispatch;
	}
	pc = 0x82EDE66C; continue 'dispatch;
            }
            0x82EDE66C => {
    //   block [0x82EDE66C..0x82EDE688)
	// 82EDE66C: 548B07FF  clrlwi. r11, r4, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDE670: 41820018  beq 0x82ede688
	if ctx.cr[0].eq {
	pc = 0x82EDE688; continue 'dispatch;
	}
	// 82EDE674: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EDE678: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDE67C: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EDE680: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDE684: 4E800421  bctrl
	ctx.lr = 0x82EDE688;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EDE688 => {
    //   block [0x82EDE688..0x82EDE690)
	// 82EDE688: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDE68C: 48000034  b 0x82ede6c0
	pc = 0x82EDE6C0; continue 'dispatch;
            }
            0x82EDE690 => {
    //   block [0x82EDE690..0x82EDE6BC)
	// 82EDE690: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EDE694: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EDE698: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EDE69C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EDE6A0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EDE6A4: 41820018  beq 0x82ede6bc
	if ctx.cr[0].eq {
	pc = 0x82EDE6BC; continue 'dispatch;
	}
	// 82EDE6A8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EDE6AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDE6B0: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EDE6B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDE6B8: 4E800421  bctrl
	ctx.lr = 0x82EDE6BC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EDE6BC => {
    //   block [0x82EDE6BC..0x82EDE6C0)
	// 82EDE6BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82EDE6C0; continue 'dispatch;
            }
            0x82EDE6C0 => {
    //   block [0x82EDE6C0..0x82EDE6D8)
	// 82EDE6C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EDE6C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EDE6C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EDE6CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EDE6D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EDE6D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDE6D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EDE6D8 size=588
    let mut pc: u32 = 0x82EDE6D8;
    'dispatch: loop {
        match pc {
            0x82EDE6D8 => {
    //   block [0x82EDE6D8..0x82EDE720)
	// 82EDE6D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDE6DC: 4BDCAD2D  bl 0x82ca9408
	ctx.lr = 0x82EDE6E0;
	sub_82CA93D0(ctx, base);
	// 82EDE6E0: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82EDE6E4: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82EDE6E8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDE6EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDE6F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDE6F4: 396B5508  addi r11, r11, 0x5508
	ctx.r[11].s64 = ctx.r[11].s64 + 21768;
	// 82EDE6F8: 3FC08334  lis r30, -0x7ccc
	ctx.r[30].s64 = -2093744128;
	// 82EDE6FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EDE700: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82EDE704: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EDE708: 817E0718  lwz r11, 0x718(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDE70C: C3EA0C14  lfs f31, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EDE710: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDE714: 4182000C  beq 0x82ede720
	if ctx.cr[0].eq {
	pc = 0x82EDE720; continue 'dispatch;
	}
	// 82EDE718: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDE71C: 48000008  b 0x82ede724
	pc = 0x82EDE724; continue 'dispatch;
            }
            0x82EDE720 => {
    //   block [0x82EDE720..0x82EDE724)
	// 82EDE720: FDA0F890  fmr f13, f31
	ctx.f[13].f64 = ctx.f[31].f64;
	pc = 0x82EDE724; continue 'dispatch;
            }
            0x82EDE724 => {
    //   block [0x82EDE724..0x82EDE754)
	// 82EDE724: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDE728: C00B0AC8  lfs f0, 0xac8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2760 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE72C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDE730: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDE734: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EDE738: C1AB0BF8  lfs f13, 0xbf8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3064 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDE73C: D1BF0008  stfs f13, 8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EDE740: 817E0718  lwz r11, 0x718(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDE744: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDE748: 4182000C  beq 0x82ede754
	if ctx.cr[0].eq {
	pc = 0x82EDE754; continue 'dispatch;
	}
	// 82EDE74C: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE750: 48000008  b 0x82ede758
	pc = 0x82EDE758; continue 'dispatch;
            }
            0x82EDE754 => {
    //   block [0x82EDE754..0x82EDE758)
	// 82EDE754: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x82EDE758; continue 'dispatch;
            }
            0x82EDE758 => {
    //   block [0x82EDE758..0x82EDE77C)
	// 82EDE758: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDE75C: C3CBBDF4  lfs f30, -0x420c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16908 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EDE760: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EDE764: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EDE768: 817E0718  lwz r11, 0x718(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDE76C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDE770: 4182000C  beq 0x82ede77c
	if ctx.cr[0].eq {
	pc = 0x82EDE77C; continue 'dispatch;
	}
	// 82EDE774: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE778: 48000008  b 0x82ede780
	pc = 0x82EDE780; continue 'dispatch;
            }
            0x82EDE77C => {
    //   block [0x82EDE77C..0x82EDE780)
	// 82EDE77C: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x82EDE780; continue 'dispatch;
            }
            0x82EDE780 => {
    //   block [0x82EDE780..0x82EDE79C)
	// 82EDE780: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EDE784: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EDE788: 817E0718  lwz r11, 0x718(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDE78C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDE790: 4182000C  beq 0x82ede79c
	if ctx.cr[0].eq {
	pc = 0x82EDE79C; continue 'dispatch;
	}
	// 82EDE794: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE798: 48000008  b 0x82ede7a0
	pc = 0x82EDE7A0; continue 'dispatch;
            }
            0x82EDE79C => {
    //   block [0x82EDE79C..0x82EDE7A0)
	// 82EDE79C: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x82EDE7A0; continue 'dispatch;
            }
            0x82EDE7A0 => {
    //   block [0x82EDE7A0..0x82EDE7C4)
	// 82EDE7A0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EDE7A4: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EDE7A8: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EDE7AC: 9BBF0018  stb r29, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 82EDE7B0: 817E0718  lwz r11, 0x718(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDE7B4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDE7B8: 4182000C  beq 0x82ede7c4
	if ctx.cr[0].eq {
	pc = 0x82EDE7C4; continue 'dispatch;
	}
	// 82EDE7BC: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE7C0: 48000008  b 0x82ede7c8
	pc = 0x82EDE7C8; continue 'dispatch;
            }
            0x82EDE7C4 => {
    //   block [0x82EDE7C4..0x82EDE7C8)
	// 82EDE7C4: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x82EDE7C8; continue 'dispatch;
            }
            0x82EDE7C8 => {
    //   block [0x82EDE7C8..0x82EDE80C)
	// 82EDE7C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDE7CC: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EDE7D0: 39400064  li r10, 0x64
	ctx.r[10].s64 = 100;
	// 82EDE7D4: D3FF0020  stfs f31, 0x20(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EDE7D8: D3FF002C  stfs f31, 0x2c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82EDE7DC: C1ABBE10  lfs f13, -0x41f0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16880 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDE7E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDE7E4: D1BF0024  stfs f13, 0x24(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EDE7E8: 915F0030  stw r10, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 82EDE7EC: D1BF0028  stfs f13, 0x28(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82EDE7F0: C00B89CC  lfs f0, -0x7634(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30260 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE7F4: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82EDE7F8: 817E0718  lwz r11, 0x718(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDE7FC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDE800: 4182000C  beq 0x82ede80c
	if ctx.cr[0].eq {
	pc = 0x82EDE80C; continue 'dispatch;
	}
	// 82EDE804: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE808: 48000008  b 0x82ede810
	pc = 0x82EDE810; continue 'dispatch;
            }
            0x82EDE80C => {
    //   block [0x82EDE80C..0x82EDE810)
	// 82EDE80C: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x82EDE810; continue 'dispatch;
            }
            0x82EDE810 => {
    //   block [0x82EDE810..0x82EDE83C)
	// 82EDE810: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDE814: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EDE818: C18B0C4C  lfs f12, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDE81C: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EDE820: 995F003C  stb r10, 0x3c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[10].u8 ) };
	// 82EDE824: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82EDE828: 817E0718  lwz r11, 0x718(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDE82C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDE830: 4182000C  beq 0x82ede83c
	if ctx.cr[0].eq {
	pc = 0x82EDE83C; continue 'dispatch;
	}
	// 82EDE834: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDE838: 48000008  b 0x82ede840
	pc = 0x82EDE840; continue 'dispatch;
            }
            0x82EDE83C => {
    //   block [0x82EDE83C..0x82EDE840)
	// 82EDE83C: FD80F890  fmr f12, f31
	ctx.f[12].f64 = ctx.f[31].f64;
	pc = 0x82EDE840; continue 'dispatch;
            }
            0x82EDE840 => {
    //   block [0x82EDE840..0x82EDE8EC)
	// 82EDE840: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EDE844: C00BE228  lfs f0, -0x1dd8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7640 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE848: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EDE84C: EC0C07B2  fmuls f0, f12, f30
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EDE850: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82EDE854: 4B35B65D  bl 0x82239eb0
	ctx.lr = 0x82EDE858;
	sub_82239EB0(ctx, base);
	// 82EDE858: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDE85C: D1BF0044  stfs f13, 0x44(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82EDE860: 939F0048  stw r28, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[28].u32 ) };
	// 82EDE864: 93BF0054  stw r29, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82EDE868: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDE86C: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDE870: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE874: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDE878: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EDE87C: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EDE880: 915F0058  stw r10, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82EDE884: D01F005C  stfs f0, 0x5c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EDE888: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EDE88C: D01F0064  stfs f0, 0x64(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EDE890: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EDE894: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EDE898: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EDE89C: D01F008C  stfs f0, 0x8c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EDE8A0: D01F0090  stfs f0, 0x90(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82EDE8A4: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82EDE8A8: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82EDE8AC: D01F00A0  stfs f0, 0xa0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82EDE8B0: D01F00A4  stfs f0, 0xa4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82EDE8B4: D01F00A8  stfs f0, 0xa8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82EDE8B8: D01F00AC  stfs f0, 0xac(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82EDE8BC: D01F00B0  stfs f0, 0xb0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82EDE8C0: D01F00B4  stfs f0, 0xb4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82EDE8C4: D01F00B8  stfs f0, 0xb8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82EDE8C8: D01F00BC  stfs f0, 0xbc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82EDE8CC: 93BF00D4  stw r29, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[29].u32 ) };
	// 82EDE8D0: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 82EDE8D4: 93BF00F4  stw r29, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[29].u32 ) };
	// 82EDE8D8: 817E0718  lwz r11, 0x718(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDE8DC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDE8E0: 4182000C  beq 0x82ede8ec
	if ctx.cr[0].eq {
	pc = 0x82EDE8EC; continue 'dispatch;
	}
	// 82EDE8E4: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDE8E8: 48000008  b 0x82ede8f0
	pc = 0x82EDE8F0; continue 'dispatch;
            }
            0x82EDE8EC => {
    //   block [0x82EDE8EC..0x82EDE8F0)
	// 82EDE8EC: FDA0F890  fmr f13, f31
	ctx.f[13].f64 = ctx.f[31].f64;
	pc = 0x82EDE8F0; continue 'dispatch;
            }
            0x82EDE8F0 => {
    //   block [0x82EDE8F0..0x82EDE924)
	// 82EDE8F0: EDAD07B2  fmuls f13, f13, f30
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EDE8F4: D01F0108  stfs f0, 0x108(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82EDE8F8: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82EDE8FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDE900: D01F0110  stfs f0, 0x110(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 82EDE904: 93BF0118  stw r29, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[29].u32 ) };
	// 82EDE908: EC1F6824  fdivs f0, f31, f13
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EDE90C: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82EDE910: 4BFFF561  bl 0x82edde70
	ctx.lr = 0x82EDE914;
	sub_82EDDE70(ctx, base);
	// 82EDE914: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EDE918: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82EDE91C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82EDE920: 4BDCAB38  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDE928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EDE928 size=280
    let mut pc: u32 = 0x82EDE928;
    'dispatch: loop {
        match pc {
            0x82EDE928 => {
    //   block [0x82EDE928..0x82EDE97C)
	// 82EDE928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDE92C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EDE930: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EDE934: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EDE938: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDE93C: 3FC08334  lis r30, -0x7ccc
	ctx.r[30].s64 = -2093744128;
	// 82EDE940: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDE944: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDE948: 388B1BA0  addi r4, r11, 0x1ba0
	ctx.r[4].s64 = ctx.r[11].s64 + 7072;
	// 82EDE94C: 807E0718  lwz r3, 0x718(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDE950: 4B3892D1  bl 0x82267c20
	ctx.lr = 0x82EDE954;
	sub_82267C20(ctx, base);
	// 82EDE954: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EDE958: 907F004C  stw r3, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[3].u32 ) };
	// 82EDE95C: 807E0718  lwz r3, 0x718(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDE960: 388B8BE4  addi r4, r11, -0x741c
	ctx.r[4].s64 = ctx.r[11].s64 + -29724;
	// 82EDE964: 4B3892BD  bl 0x82267c20
	ctx.lr = 0x82EDE968;
	sub_82267C20(ctx, base);
	// 82EDE968: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDE96C: 907F0050  stw r3, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EDE970: 4082000C  bne 0x82ede97c
	if !ctx.cr[0].eq {
	pc = 0x82EDE97C; continue 'dispatch;
	}
	// 82EDE974: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EDE978: 480000B0  b 0x82edea28
	pc = 0x82EDEA28; continue 'dispatch;
            }
            0x82EDE97C => {
    //   block [0x82EDE97C..0x82EDEA1C)
	// 82EDE97C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDE980: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EDE984: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EDE988: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82EDE98C: 4B309CED  bl 0x821e8678
	ctx.lr = 0x82EDE990;
	sub_821E8678(ctx, base);
	// 82EDE990: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EDE994: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDE998: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EDE99C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EDE9A0: 388BDA4C  addi r4, r11, -0x25b4
	ctx.r[4].s64 = ctx.r[11].s64 + -9652;
	// 82EDE9A4: 915F006C  stw r10, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 82EDE9A8: 4B309CD1  bl 0x821e8678
	ctx.lr = 0x82EDE9AC;
	sub_821E8678(ctx, base);
	// 82EDE9AC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EDE9B0: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EDE9B4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDE9B8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EDE9BC: 388BC178  addi r4, r11, -0x3e88
	ctx.r[4].s64 = ctx.r[11].s64 + -16008;
	// 82EDE9C0: 915F0070  stw r10, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82EDE9C4: 4B309CB5  bl 0x821e8678
	ctx.lr = 0x82EDE9C8;
	sub_821E8678(ctx, base);
	// 82EDE9C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EDE9CC: C01F0040  lfs f0, 0x40(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE9D0: C1BF0010  lfs f13, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDE9D4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82EDE9D8: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EDE9DC: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82EDE9E0: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82EDE9E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDE9E8: C00B0C68  lfs f0, 0xc68(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDE9EC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDE9F0: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82EDE9F4: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 82EDE9F8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EDE9FC: 23CB0001  subfic r30, r11, 1
	ctx.xer.ca = ctx.r[11].u32 <= 1 as u32;
	ctx.r[30].s64 = (1 as i64) - ctx.r[11].s64;
	// 82EDEA00: 4B737F29  bl 0x82616928
	ctx.lr = 0x82EDEA04;
	sub_82616928(ctx, base);
	// 82EDEA04: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDEA08: 41820014  beq 0x82edea1c
	if ctx.cr[0].eq {
	pc = 0x82EDEA1C; continue 'dispatch;
	}
	// 82EDEA0C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EDEA10: 4BFFC0D9  bl 0x82edaae8
	ctx.lr = 0x82EDEA14;
	sub_82EDAAE8(ctx, base);
	// 82EDEA14: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EDEA18: 48000008  b 0x82edea20
	pc = 0x82EDEA20; continue 'dispatch;
            }
            0x82EDEA1C => {
    //   block [0x82EDEA1C..0x82EDEA20)
	// 82EDEA1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EDEA20; continue 'dispatch;
            }
            0x82EDEA20 => {
    //   block [0x82EDEA20..0x82EDEA28)
	// 82EDEA20: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EDEA24: 917F00D4  stw r11, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	pc = 0x82EDEA28; continue 'dispatch;
            }
            0x82EDEA28 => {
    //   block [0x82EDEA28..0x82EDEA40)
	// 82EDEA28: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EDEA2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EDEA30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EDEA34: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EDEA38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EDEA3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDEA40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EDEA40 size=72
    let mut pc: u32 = 0x82EDEA40;
    'dispatch: loop {
        match pc {
            0x82EDEA40 => {
    //   block [0x82EDEA40..0x82EDEA70)
	// 82EDEA40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDEA44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EDEA48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EDEA4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDEA50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDEA54: 3860011C  li r3, 0x11c
	ctx.r[3].s64 = 284;
	// 82EDEA58: 4B737ED1  bl 0x82616928
	ctx.lr = 0x82EDEA5C;
	sub_82616928(ctx, base);
	// 82EDEA5C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDEA60: 41820010  beq 0x82edea70
	if ctx.cr[0].eq {
	pc = 0x82EDEA70; continue 'dispatch;
	}
	// 82EDEA64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDEA68: 4BFFFC71  bl 0x82ede6d8
	ctx.lr = 0x82EDEA6C;
	sub_82EDE6D8(ctx, base);
	// 82EDEA6C: 48000008  b 0x82edea74
	pc = 0x82EDEA74; continue 'dispatch;
            }
            0x82EDEA70 => {
    //   block [0x82EDEA70..0x82EDEA74)
	// 82EDEA70: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EDEA74; continue 'dispatch;
            }
            0x82EDEA74 => {
    //   block [0x82EDEA74..0x82EDEA88)
	// 82EDEA74: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EDEA78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EDEA7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EDEA80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EDEA84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDEA88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EDEA88 size=100
    let mut pc: u32 = 0x82EDEA88;
    'dispatch: loop {
        match pc {
            0x82EDEA88 => {
    //   block [0x82EDEA88..0x82EDEAC8)
	// 82EDEA88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDEA8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EDEA90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EDEA94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDEA98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDEA9C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDEAA0: 396BBD80  addi r11, r11, -0x4280
	ctx.r[11].s64 = ctx.r[11].s64 + -17024;
	// 82EDEAA4: 807F00C4  lwz r3, 0xc4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EDEAA8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDEAAC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EDEAB0: 41820018  beq 0x82edeac8
	if ctx.cr[0].eq {
	pc = 0x82EDEAC8; continue 'dispatch;
	}
	// 82EDEAB4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EDEAB8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EDEABC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EDEAC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDEAC4: 4E800421  bctrl
	ctx.lr = 0x82EDEAC8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EDEAC8 => {
    //   block [0x82EDEAC8..0x82EDEAEC)
	// 82EDEAC8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EDEACC: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EDEAD0: 917F00DC  stw r11, 0xdc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), ctx.r[11].u32 ) };
	// 82EDEAD4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EDEAD8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EDEADC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EDEAE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EDEAE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EDEAE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDEAF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EDEAF0 size=12
    let mut pc: u32 = 0x82EDEAF0;
    'dispatch: loop {
        match pc {
            0x82EDEAF0 => {
    //   block [0x82EDEAF0..0x82EDEAFC)
	// 82EDEAF0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EDEAF4: 386B8E0C  addi r3, r11, -0x71f4
	ctx.r[3].s64 = ctx.r[11].s64 + -29172;
	// 82EDEAF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDEB00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EDEB00 size=88
    let mut pc: u32 = 0x82EDEB00;
    'dispatch: loop {
        match pc {
            0x82EDEB00 => {
    //   block [0x82EDEB00..0x82EDEB14)
	// 82EDEB00: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EDEB04: C1A30044  lfs f13, 0x44(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDEB08: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDEB0C: C16A0C14  lfs f11, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDEB10: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EDEB14; continue 'dispatch;
            }
            0x82EDEB14 => {
    //   block [0x82EDEB14..0x82EDEB28)
	// 82EDEB14: FF016000  fcmpu cr6, f1, f12
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[12].f64);
	// 82EDEB18: 41980010  blt cr6, 0x82edeb28
	if ctx.cr[6].lt {
	pc = 0x82EDEB28; continue 'dispatch;
	}
	// 82EDEB1C: FF015800  fcmpu cr6, f1, f11
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[11].f64);
	// 82EDEB20: 41990008  bgt cr6, 0x82edeb28
	if ctx.cr[6].gt {
	pc = 0x82EDEB28; continue 'dispatch;
	}
	// 82EDEB24: FDA00890  fmr f13, f1
	ctx.f[13].f64 = ctx.f[1].f64;
	pc = 0x82EDEB28; continue 'dispatch;
            }
            0x82EDEB28 => {
    //   block [0x82EDEB28..0x82EDEB58)
	// 82EDEB28: FF0D6800  fcmpu cr6, f13, f13
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[13].f64);
	// 82EDEB2C: 409AFFE8  bne cr6, 0x82edeb14
	if !ctx.cr[6].eq {
	pc = 0x82EDEB14; continue 'dispatch;
	}
	// 82EDEB30: D1A30044  stfs f13, 0x44(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82EDEB34: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDEB38: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82EDEB3C: C003003C  lfs f0, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDEB40: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EDEB44: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82EDEB48: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EDEB4C: EC0B0024  fdivs f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EDEB50: D00300F4  stfs f0, 0xf4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82EDEB54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDEB58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EDEB58 size=88
    let mut pc: u32 = 0x82EDEB58;
    'dispatch: loop {
        match pc {
            0x82EDEB58 => {
    //   block [0x82EDEB58..0x82EDEB94)
	// 82EDEB58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDEB5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EDEB60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EDEB64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EDEB68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDEB6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDEB70: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EDEB74: 4BFFFF15  bl 0x82edea88
	ctx.lr = 0x82EDEB78;
	sub_82EDEA88(ctx, base);
	// 82EDEB78: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDEB7C: 41820018  beq 0x82edeb94
	if ctx.cr[0].eq {
	pc = 0x82EDEB94; continue 'dispatch;
	}
	// 82EDEB80: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EDEB84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDEB88: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 82EDEB8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDEB90: 4E800421  bctrl
	ctx.lr = 0x82EDEB94;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EDEB94 => {
    //   block [0x82EDEB94..0x82EDEBB0)
	// 82EDEB94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDEB98: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EDEB9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EDEBA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EDEBA4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EDEBA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EDEBAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDEBB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EDEBB0 size=2040
    let mut pc: u32 = 0x82EDEBB0;
    'dispatch: loop {
        match pc {
            0x82EDEBB0 => {
    //   block [0x82EDEBB0..0x82EDEC0C)
	// 82EDEBB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDEBB4: 4BDCA855  bl 0x82ca9408
	ctx.lr = 0x82EDEBB8;
	sub_82CA93D0(ctx, base);
	// 82EDEBB8: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82EDEBBC: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82EDEBC0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDEBC4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EDEBC8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82EDEBCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDEBD0: 482DD491  bl 0x831bc060
	ctx.lr = 0x82EDEBD4;
	sub_831BC060(ctx, base);
	// 82EDEBD4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82EDEBD8: 418207BC  beq 0x82edf394
	if ctx.cr[0].eq {
	pc = 0x82EDF394; continue 'dispatch;
	}
	// 82EDEBDC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDEBE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDEBE4: 388BBC30  addi r4, r11, -0x43d0
	ctx.r[4].s64 = ctx.r[11].s64 + -17360;
	// 82EDEBE8: 4BDCDF69  bl 0x82cacb50
	ctx.lr = 0x82EDEBEC;
	sub_82CACB50(ctx, base);
	// 82EDEBEC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDEBF0: 40820098  bne 0x82edec88
	if !ctx.cr[0].eq {
	pc = 0x82EDEC88; continue 'dispatch;
	}
	// 82EDEBF4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDEBF8: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDEBFC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDEC00: 4182000C  beq 0x82edec0c
	if ctx.cr[0].eq {
	pc = 0x82EDEC0C; continue 'dispatch;
	}
	// 82EDEC04: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EDEC08: 4800000C  b 0x82edec14
	pc = 0x82EDEC14; continue 'dispatch;
            }
            0x82EDEC0C => {
    //   block [0x82EDEC0C..0x82EDEC14)
	// 82EDEC0C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDEC10: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EDEC14; continue 'dispatch;
            }
            0x82EDEC14 => {
    //   block [0x82EDEC14..0x82EDEC7C)
	// 82EDEC14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDEC18: 4BA2F0F1  bl 0x8290dd08
	ctx.lr = 0x82EDEC1C;
	sub_8290DD08(ctx, base);
	// 82EDEC1C: 4BDCCF95  bl 0x82cabbb0
	ctx.lr = 0x82EDEC20;
	sub_82CABBB0(ctx, base);
	// 82EDEC20: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDEC24: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDEC28: EFE007F2  fmuls f31, f0, f31
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EDEC2C: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDEC30: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82EDEC34: 4099004C  ble cr6, 0x82edec80
	if !ctx.cr[6].gt {
	pc = 0x82EDEC80; continue 'dispatch;
	}
	// 82EDEC38: 807C0058  lwz r3, 0x58(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EDEC3C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDEC40: 4182003C  beq 0x82edec7c
	if ctx.cr[0].eq {
	pc = 0x82EDEC7C; continue 'dispatch;
	}
	// 82EDEC44: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDEC48: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EDEC4C: 3BEBC5C8  addi r31, r11, -0x3a38
	ctx.r[31].s64 = ctx.r[11].s64 + -14904;
	// 82EDEC50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDEC54: 4B309A25  bl 0x821e8678
	ctx.lr = 0x82EDEC58;
	sub_821E8678(ctx, base);
	// 82EDEC58: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDEC5C: 41820020  beq 0x82edec7c
	if ctx.cr[0].eq {
	pc = 0x82EDEC7C; continue 'dispatch;
	}
	// 82EDEC60: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EDEC64: 807C0058  lwz r3, 0x58(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EDEC68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDEC6C: 4B309A0D  bl 0x821e8678
	ctx.lr = 0x82EDEC70;
	sub_821E8678(ctx, base);
	// 82EDEC70: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDEC74: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82EDEC78: 4099071C  ble cr6, 0x82edf394
	if !ctx.cr[6].gt {
	pc = 0x82EDF394; continue 'dispatch;
	}
	pc = 0x82EDEC7C; continue 'dispatch;
            }
            0x82EDEC7C => {
    //   block [0x82EDEC7C..0x82EDEC80)
	// 82EDEC7C: D3FC0004  stfs f31, 4(r28)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), tmp.u32 ) };
	pc = 0x82EDEC80; continue 'dispatch;
            }
            0x82EDEC80 => {
    //   block [0x82EDEC80..0x82EDEC88)
	// 82EDEC80: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EDEC84: 48000714  b 0x82edf398
	pc = 0x82EDF398; continue 'dispatch;
            }
            0x82EDEC88 => {
    //   block [0x82EDEC88..0x82EDECBC)
	// 82EDEC88: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDEC8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDEC90: 388BBD20  addi r4, r11, -0x42e0
	ctx.r[4].s64 = ctx.r[11].s64 + -17120;
	// 82EDEC94: 4BDCDEBD  bl 0x82cacb50
	ctx.lr = 0x82EDEC98;
	sub_82CACB50(ctx, base);
	// 82EDEC98: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDEC9C: 4082003C  bne 0x82edecd8
	if !ctx.cr[0].eq {
	pc = 0x82EDECD8; continue 'dispatch;
	}
	// 82EDECA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDECA4: 4BA2F065  bl 0x8290dd08
	ctx.lr = 0x82EDECA8;
	sub_8290DD08(ctx, base);
	// 82EDECA8: 4BDCCF09  bl 0x82cabbb0
	ctx.lr = 0x82EDECAC;
	sub_82CABBB0(ctx, base);
	// 82EDECAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDECB0: C01C003C  lfs f0, 0x3c(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDECB4: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDECB8: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EDECBC; continue 'dispatch;
            }
            0x82EDECBC => {
    //   block [0x82EDECBC..0x82EDECC8)
	// 82EDECBC: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDECC0: 40990008  ble cr6, 0x82edecc8
	if !ctx.cr[6].gt {
	pc = 0x82EDECC8; continue 'dispatch;
	}
	// 82EDECC4: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDECC8; continue 'dispatch;
            }
            0x82EDECC8 => {
    //   block [0x82EDECC8..0x82EDECD8)
	// 82EDECC8: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDECCC: 409AFFF0  bne cr6, 0x82edecbc
	if !ctx.cr[6].eq {
	pc = 0x82EDECBC; continue 'dispatch;
	}
	// 82EDECD0: D01C003C  stfs f0, 0x3c(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82EDECD4: 4BFFFFAC  b 0x82edec80
	pc = 0x82EDEC80; continue 'dispatch;
            }
            0x82EDECD8 => {
    //   block [0x82EDECD8..0x82EDED10)
	// 82EDECD8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDECDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDECE0: 388BBC08  addi r4, r11, -0x43f8
	ctx.r[4].s64 = ctx.r[11].s64 + -17400;
	// 82EDECE4: 4BDCDE6D  bl 0x82cacb50
	ctx.lr = 0x82EDECE8;
	sub_82CACB50(ctx, base);
	// 82EDECE8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDECEC: 408200AC  bne 0x82eded98
	if !ctx.cr[0].eq {
	pc = 0x82EDED98; continue 'dispatch;
	}
	// 82EDECF0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDECF4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EDECF8: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDECFC: C3CA0C14  lfs f30, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EDED00: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDED04: 4182000C  beq 0x82eded10
	if ctx.cr[0].eq {
	pc = 0x82EDED10; continue 'dispatch;
	}
	// 82EDED08: C3EB000C  lfs f31, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EDED0C: 48000008  b 0x82eded14
	pc = 0x82EDED14; continue 'dispatch;
            }
            0x82EDED10 => {
    //   block [0x82EDED10..0x82EDED14)
	// 82EDED10: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	pc = 0x82EDED14; continue 'dispatch;
            }
            0x82EDED14 => {
    //   block [0x82EDED14..0x82EDED88)
	// 82EDED14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDED18: 4BA2EFF1  bl 0x8290dd08
	ctx.lr = 0x82EDED1C;
	sub_8290DD08(ctx, base);
	// 82EDED1C: 4BDCCE95  bl 0x82cabbb0
	ctx.lr = 0x82EDED20;
	sub_82CABBB0(ctx, base);
	// 82EDED20: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDED24: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDED28: EFE007F2  fmuls f31, f0, f31
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EDED2C: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDED30: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82EDED34: 4099FF4C  ble cr6, 0x82edec80
	if !ctx.cr[6].gt {
	pc = 0x82EDEC80; continue 'dispatch;
	}
	// 82EDED38: 807C0058  lwz r3, 0x58(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EDED3C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDED40: 41820048  beq 0x82eded88
	if ctx.cr[0].eq {
	pc = 0x82EDED88; continue 'dispatch;
	}
	// 82EDED44: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDED48: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EDED4C: 3BEBC5C8  addi r31, r11, -0x3a38
	ctx.r[31].s64 = ctx.r[11].s64 + -14904;
	// 82EDED50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDED54: 4B309925  bl 0x821e8678
	ctx.lr = 0x82EDED58;
	sub_821E8678(ctx, base);
	// 82EDED58: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDED5C: 4182002C  beq 0x82eded88
	if ctx.cr[0].eq {
	pc = 0x82EDED88; continue 'dispatch;
	}
	// 82EDED60: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EDED64: 807C0058  lwz r3, 0x58(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EDED68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDED6C: 4B30990D  bl 0x821e8678
	ctx.lr = 0x82EDED70;
	sub_821E8678(ctx, base);
	// 82EDED70: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDED74: C1A30004  lfs f13, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDED78: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDED7C: EC1F0032  fmuls f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDED80: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EDED84: 40990610  ble cr6, 0x82edf394
	if !ctx.cr[6].gt {
	pc = 0x82EDF394; continue 'dispatch;
	}
	pc = 0x82EDED88; continue 'dispatch;
            }
            0x82EDED88 => {
    //   block [0x82EDED88..0x82EDED98)
	// 82EDED88: EC1EF824  fdivs f0, f30, f31
	ctx.f[0].f64 = ((ctx.f[30].f64 / ctx.f[31].f64) as f32) as f64;
	// 82EDED8C: D3FC0040  stfs f31, 0x40(r28)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82EDED90: D01C00F0  stfs f0, 0xf0(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82EDED94: 4BFFFEEC  b 0x82edec80
	pc = 0x82EDEC80; continue 'dispatch;
            }
            0x82EDED98 => {
    //   block [0x82EDED98..0x82EDEDCC)
	// 82EDED98: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDED9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDEDA0: 388BBBF0  addi r4, r11, -0x4410
	ctx.r[4].s64 = ctx.r[11].s64 + -17424;
	// 82EDEDA4: 4BDCDDAD  bl 0x82cacb50
	ctx.lr = 0x82EDEDA8;
	sub_82CACB50(ctx, base);
	// 82EDEDA8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDEDAC: 4082003C  bne 0x82edede8
	if !ctx.cr[0].eq {
	pc = 0x82EDEDE8; continue 'dispatch;
	}
	// 82EDEDB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDEDB4: 4BA2EF55  bl 0x8290dd08
	ctx.lr = 0x82EDEDB8;
	sub_8290DD08(ctx, base);
	// 82EDEDB8: 4BDCCDF9  bl 0x82cabbb0
	ctx.lr = 0x82EDEDBC;
	sub_82CABBB0(ctx, base);
	// 82EDEDBC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDEDC0: C01C0008  lfs f0, 8(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDEDC4: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDEDC8: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EDEDCC; continue 'dispatch;
            }
            0x82EDEDCC => {
    //   block [0x82EDEDCC..0x82EDEDD8)
	// 82EDEDCC: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDEDD0: 41980008  blt cr6, 0x82ededd8
	if ctx.cr[6].lt {
	pc = 0x82EDEDD8; continue 'dispatch;
	}
	// 82EDEDD4: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDEDD8; continue 'dispatch;
            }
            0x82EDEDD8 => {
    //   block [0x82EDEDD8..0x82EDEDE8)
	// 82EDEDD8: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDEDDC: 409AFFF0  bne cr6, 0x82ededcc
	if !ctx.cr[6].eq {
	pc = 0x82EDEDCC; continue 'dispatch;
	}
	// 82EDEDE0: D01C0008  stfs f0, 8(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EDEDE4: 4BFFFE9C  b 0x82edec80
	pc = 0x82EDEC80; continue 'dispatch;
            }
            0x82EDEDE8 => {
    //   block [0x82EDEDE8..0x82EDEE18)
	// 82EDEDE8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDEDEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDEDF0: 388BBBDC  addi r4, r11, -0x4424
	ctx.r[4].s64 = ctx.r[11].s64 + -17444;
	// 82EDEDF4: 4BDCDD5D  bl 0x82cacb50
	ctx.lr = 0x82EDEDF8;
	sub_82CACB50(ctx, base);
	// 82EDEDF8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDEDFC: 40820060  bne 0x82edee5c
	if !ctx.cr[0].eq {
	pc = 0x82EDEE5C; continue 'dispatch;
	}
	// 82EDEE00: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDEE04: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDEE08: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDEE0C: 4182000C  beq 0x82edee18
	if ctx.cr[0].eq {
	pc = 0x82EDEE18; continue 'dispatch;
	}
	// 82EDEE10: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EDEE14: 4800000C  b 0x82edee20
	pc = 0x82EDEE20; continue 'dispatch;
            }
            0x82EDEE18 => {
    //   block [0x82EDEE18..0x82EDEE20)
	// 82EDEE18: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDEE1C: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EDEE20; continue 'dispatch;
            }
            0x82EDEE20 => {
    //   block [0x82EDEE20..0x82EDEE40)
	// 82EDEE20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDEE24: 4BA2EEE5  bl 0x8290dd08
	ctx.lr = 0x82EDEE28;
	sub_8290DD08(ctx, base);
	// 82EDEE28: 4BDCCD89  bl 0x82cabbb0
	ctx.lr = 0x82EDEE2C;
	sub_82CABBB0(ctx, base);
	// 82EDEE2C: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDEE30: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDEE34: C01C000C  lfs f0, 0xc(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDEE38: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDEE3C: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	pc = 0x82EDEE40; continue 'dispatch;
            }
            0x82EDEE40 => {
    //   block [0x82EDEE40..0x82EDEE4C)
	// 82EDEE40: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDEE44: 40990008  ble cr6, 0x82edee4c
	if !ctx.cr[6].gt {
	pc = 0x82EDEE4C; continue 'dispatch;
	}
	// 82EDEE48: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDEE4C; continue 'dispatch;
            }
            0x82EDEE4C => {
    //   block [0x82EDEE4C..0x82EDEE5C)
	// 82EDEE4C: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDEE50: 409AFFF0  bne cr6, 0x82edee40
	if !ctx.cr[6].eq {
	pc = 0x82EDEE40; continue 'dispatch;
	}
	// 82EDEE54: D01C000C  stfs f0, 0xc(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EDEE58: 4BFFFE28  b 0x82edec80
	pc = 0x82EDEC80; continue 'dispatch;
            }
            0x82EDEE5C => {
    //   block [0x82EDEE5C..0x82EDEE8C)
	// 82EDEE5C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDEE60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDEE64: 388BAF10  addi r4, r11, -0x50f0
	ctx.r[4].s64 = ctx.r[11].s64 + -20720;
	// 82EDEE68: 4BDCDCE9  bl 0x82cacb50
	ctx.lr = 0x82EDEE6C;
	sub_82CACB50(ctx, base);
	// 82EDEE6C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDEE70: 40820060  bne 0x82edeed0
	if !ctx.cr[0].eq {
	pc = 0x82EDEED0; continue 'dispatch;
	}
	// 82EDEE74: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDEE78: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDEE7C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDEE80: 4182000C  beq 0x82edee8c
	if ctx.cr[0].eq {
	pc = 0x82EDEE8C; continue 'dispatch;
	}
	// 82EDEE84: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EDEE88: 4800000C  b 0x82edee94
	pc = 0x82EDEE94; continue 'dispatch;
            }
            0x82EDEE8C => {
    //   block [0x82EDEE8C..0x82EDEE94)
	// 82EDEE8C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDEE90: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EDEE94; continue 'dispatch;
            }
            0x82EDEE94 => {
    //   block [0x82EDEE94..0x82EDEEB4)
	// 82EDEE94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDEE98: 4BA2EE71  bl 0x8290dd08
	ctx.lr = 0x82EDEE9C;
	sub_8290DD08(ctx, base);
	// 82EDEE9C: 4BDCCD15  bl 0x82cabbb0
	ctx.lr = 0x82EDEEA0;
	sub_82CABBB0(ctx, base);
	// 82EDEEA0: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDEEA4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDEEA8: C01C0010  lfs f0, 0x10(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDEEAC: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDEEB0: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	pc = 0x82EDEEB4; continue 'dispatch;
            }
            0x82EDEEB4 => {
    //   block [0x82EDEEB4..0x82EDEEC0)
	// 82EDEEB4: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDEEB8: 41980008  blt cr6, 0x82edeec0
	if ctx.cr[6].lt {
	pc = 0x82EDEEC0; continue 'dispatch;
	}
	// 82EDEEBC: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDEEC0; continue 'dispatch;
            }
            0x82EDEEC0 => {
    //   block [0x82EDEEC0..0x82EDEED0)
	// 82EDEEC0: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDEEC4: 409AFFF0  bne cr6, 0x82edeeb4
	if !ctx.cr[6].eq {
	pc = 0x82EDEEB4; continue 'dispatch;
	}
	// 82EDEEC8: D01C0010  stfs f0, 0x10(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EDEECC: 4BFFFDB4  b 0x82edec80
	pc = 0x82EDEC80; continue 'dispatch;
            }
            0x82EDEED0 => {
    //   block [0x82EDEED0..0x82EDEFB0)
	// 82EDEED0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDEED4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDEED8: 3BABBBCC  addi r29, r11, -0x4434
	ctx.r[29].s64 = ctx.r[11].s64 + -17460;
	// 82EDEEDC: 482DD185  bl 0x831bc060
	ctx.lr = 0x82EDEEE0;
	sub_831BC060(ctx, base);
	// 82EDEEE0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EDEEE4: 4BDCDC6D  bl 0x82cacb50
	ctx.lr = 0x82EDEEE8;
	sub_82CACB50(ctx, base);
	// 82EDEEE8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDEEEC: 408200D8  bne 0x82edefc4
	if !ctx.cr[0].eq {
	pc = 0x82EDEFC4; continue 'dispatch;
	}
	// 82EDEEF0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EDEEF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDEEF8: 3BEB1694  addi r31, r11, 0x1694
	ctx.r[31].s64 = ctx.r[11].s64 + 5780;
	// 82EDEEFC: 4BA2EE0D  bl 0x8290dd08
	ctx.lr = 0x82EDEF00;
	sub_8290DD08(ctx, base);
	// 82EDEF00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDEF04: 4BDCDC4D  bl 0x82cacb50
	ctx.lr = 0x82EDEF08;
	sub_82CACB50(ctx, base);
	// 82EDEF08: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDEF0C: 418200AC  beq 0x82edefb8
	if ctx.cr[0].eq {
	pc = 0x82EDEFB8; continue 'dispatch;
	}
	// 82EDEF10: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDEF14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDEF18: 3BEB0F40  addi r31, r11, 0xf40
	ctx.r[31].s64 = ctx.r[11].s64 + 3904;
	// 82EDEF1C: 4BA2EDED  bl 0x8290dd08
	ctx.lr = 0x82EDEF20;
	sub_8290DD08(ctx, base);
	// 82EDEF20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDEF24: 4BDCDC2D  bl 0x82cacb50
	ctx.lr = 0x82EDEF28;
	sub_82CACB50(ctx, base);
	// 82EDEF28: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDEF2C: 4182008C  beq 0x82edefb8
	if ctx.cr[0].eq {
	pc = 0x82EDEFB8; continue 'dispatch;
	}
	// 82EDEF30: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82EDEF34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDEF38: 3BEBD56C  addi r31, r11, -0x2a94
	ctx.r[31].s64 = ctx.r[11].s64 + -10900;
	// 82EDEF3C: 4BA2EDCD  bl 0x8290dd08
	ctx.lr = 0x82EDEF40;
	sub_8290DD08(ctx, base);
	// 82EDEF40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDEF44: 4BDCDC0D  bl 0x82cacb50
	ctx.lr = 0x82EDEF48;
	sub_82CACB50(ctx, base);
	// 82EDEF48: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDEF4C: 4182006C  beq 0x82edefb8
	if ctx.cr[0].eq {
	pc = 0x82EDEFB8; continue 'dispatch;
	}
	// 82EDEF50: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EDEF54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDEF58: 3BEB1698  addi r31, r11, 0x1698
	ctx.r[31].s64 = ctx.r[11].s64 + 5784;
	// 82EDEF5C: 4BA2EDAD  bl 0x8290dd08
	ctx.lr = 0x82EDEF60;
	sub_8290DD08(ctx, base);
	// 82EDEF60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDEF64: 4BDCDBED  bl 0x82cacb50
	ctx.lr = 0x82EDEF68;
	sub_82CACB50(ctx, base);
	// 82EDEF68: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDEF6C: 41820044  beq 0x82edefb0
	if ctx.cr[0].eq {
	pc = 0x82EDEFB0; continue 'dispatch;
	}
	// 82EDEF70: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EDEF74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDEF78: 3BEB1700  addi r31, r11, 0x1700
	ctx.r[31].s64 = ctx.r[11].s64 + 5888;
	// 82EDEF7C: 4BA2ED8D  bl 0x8290dd08
	ctx.lr = 0x82EDEF80;
	sub_8290DD08(ctx, base);
	// 82EDEF80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDEF84: 4BDCDBCD  bl 0x82cacb50
	ctx.lr = 0x82EDEF88;
	sub_82CACB50(ctx, base);
	// 82EDEF88: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDEF8C: 41820024  beq 0x82edefb0
	if ctx.cr[0].eq {
	pc = 0x82EDEFB0; continue 'dispatch;
	}
	// 82EDEF90: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EDEF94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDEF98: 3BEB7088  addi r31, r11, 0x7088
	ctx.r[31].s64 = ctx.r[11].s64 + 28808;
	// 82EDEF9C: 4BA2ED6D  bl 0x8290dd08
	ctx.lr = 0x82EDEFA0;
	sub_8290DD08(ctx, base);
	// 82EDEFA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDEFA4: 4BDCDBAD  bl 0x82cacb50
	ctx.lr = 0x82EDEFA8;
	sub_82CACB50(ctx, base);
	// 82EDEFA8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDEFAC: 408203E8  bne 0x82edf394
	if !ctx.cr[0].eq {
	pc = 0x82EDF394; continue 'dispatch;
	}
	pc = 0x82EDEFB0; continue 'dispatch;
            }
            0x82EDEFB0 => {
    //   block [0x82EDEFB0..0x82EDEFB8)
	// 82EDEFB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EDEFB4: 48000008  b 0x82edefbc
	pc = 0x82EDEFBC; continue 'dispatch;
            }
            0x82EDEFB8 => {
    //   block [0x82EDEFB8..0x82EDEFBC)
	// 82EDEFB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82EDEFBC; continue 'dispatch;
            }
            0x82EDEFBC => {
    //   block [0x82EDEFBC..0x82EDEFC4)
	// 82EDEFBC: 997C0014  stb r11, 0x14(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 82EDEFC0: 4BFFFCC0  b 0x82edec80
	pc = 0x82EDEC80; continue 'dispatch;
            }
            0x82EDEFC4 => {
    //   block [0x82EDEFC4..0x82EDF014)
	// 82EDEFC4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDEFC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDEFCC: 388BBD0C  addi r4, r11, -0x42f4
	ctx.r[4].s64 = ctx.r[11].s64 + -17140;
	// 82EDEFD0: 4BDCDB81  bl 0x82cacb50
	ctx.lr = 0x82EDEFD4;
	sub_82CACB50(ctx, base);
	// 82EDEFD4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDEFD8: 4082003C  bne 0x82edf014
	if !ctx.cr[0].eq {
	pc = 0x82EDF014; continue 'dispatch;
	}
	// 82EDEFDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDEFE0: 4BA2ED29  bl 0x8290dd08
	ctx.lr = 0x82EDEFE4;
	sub_8290DD08(ctx, base);
	// 82EDEFE4: 4BDCCBCD  bl 0x82cabbb0
	ctx.lr = 0x82EDEFE8;
	sub_82CABBB0(ctx, base);
	// 82EDEFE8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDEFEC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDEFF0: C1AB0C18  lfs f13, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDEFF4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EDEFF8: 4198FC88  blt cr6, 0x82edec80
	if ctx.cr[6].lt {
	pc = 0x82EDEC80; continue 'dispatch;
	}
	// 82EDEFFC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDF000: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDF004: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EDF008: 4098FC78  bge cr6, 0x82edec80
	if !ctx.cr[6].lt {
	pc = 0x82EDEC80; continue 'dispatch;
	}
	// 82EDF00C: D01C0018  stfs f0, 0x18(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EDF010: 4BFFFC70  b 0x82edec80
	pc = 0x82EDEC80; continue 'dispatch;
            }
            0x82EDF014 => {
    //   block [0x82EDF014..0x82EDF048)
	// 82EDF014: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDF018: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDF01C: 388BBBC0  addi r4, r11, -0x4440
	ctx.r[4].s64 = ctx.r[11].s64 + -17472;
	// 82EDF020: 4BDCDB31  bl 0x82cacb50
	ctx.lr = 0x82EDF024;
	sub_82CACB50(ctx, base);
	// 82EDF024: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDF028: 40820020  bne 0x82edf048
	if !ctx.cr[0].eq {
	pc = 0x82EDF048; continue 'dispatch;
	}
	// 82EDF02C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDF030: 4BA2ECD9  bl 0x8290dd08
	ctx.lr = 0x82EDF034;
	sub_8290DD08(ctx, base);
	// 82EDF034: 4BDCCB7D  bl 0x82cabbb0
	ctx.lr = 0x82EDF038;
	sub_82CABBB0(ctx, base);
	// 82EDF038: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EDF03C: FC200818  frsp f1, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDF040: 4BFFFAC1  bl 0x82edeb00
	ctx.lr = 0x82EDF044;
	sub_82EDEB00(ctx, base);
	// 82EDF044: 4BFFFC3C  b 0x82edec80
	pc = 0x82EDEC80; continue 'dispatch;
            }
            0x82EDF048 => {
    //   block [0x82EDF048..0x82EDF07C)
	// 82EDF048: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDF04C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDF050: 388BBBB0  addi r4, r11, -0x4450
	ctx.r[4].s64 = ctx.r[11].s64 + -17488;
	// 82EDF054: 4BDCDAFD  bl 0x82cacb50
	ctx.lr = 0x82EDF058;
	sub_82CACB50(ctx, base);
	// 82EDF058: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDF05C: 4082003C  bne 0x82edf098
	if !ctx.cr[0].eq {
	pc = 0x82EDF098; continue 'dispatch;
	}
	// 82EDF060: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDF064: 4BA2ECA5  bl 0x8290dd08
	ctx.lr = 0x82EDF068;
	sub_8290DD08(ctx, base);
	// 82EDF068: 4BDCCB49  bl 0x82cabbb0
	ctx.lr = 0x82EDF06C;
	sub_82CABBB0(ctx, base);
	// 82EDF06C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDF070: C01C001C  lfs f0, 0x1c(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF074: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDF078: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EDF07C; continue 'dispatch;
            }
            0x82EDF07C => {
    //   block [0x82EDF07C..0x82EDF088)
	// 82EDF07C: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDF080: 41980008  blt cr6, 0x82edf088
	if ctx.cr[6].lt {
	pc = 0x82EDF088; continue 'dispatch;
	}
	// 82EDF084: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDF088; continue 'dispatch;
            }
            0x82EDF088 => {
    //   block [0x82EDF088..0x82EDF098)
	// 82EDF088: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDF08C: 409AFFF0  bne cr6, 0x82edf07c
	if !ctx.cr[6].eq {
	pc = 0x82EDF07C; continue 'dispatch;
	}
	// 82EDF090: D01C001C  stfs f0, 0x1c(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EDF094: 4BFFFBEC  b 0x82edec80
	pc = 0x82EDEC80; continue 'dispatch;
            }
            0x82EDF098 => {
    //   block [0x82EDF098..0x82EDF0CC)
	// 82EDF098: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDF09C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDF0A0: 388BBBA0  addi r4, r11, -0x4460
	ctx.r[4].s64 = ctx.r[11].s64 + -17504;
	// 82EDF0A4: 4BDCDAAD  bl 0x82cacb50
	ctx.lr = 0x82EDF0A8;
	sub_82CACB50(ctx, base);
	// 82EDF0A8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDF0AC: 4082003C  bne 0x82edf0e8
	if !ctx.cr[0].eq {
	pc = 0x82EDF0E8; continue 'dispatch;
	}
	// 82EDF0B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDF0B4: 4BA2EC55  bl 0x8290dd08
	ctx.lr = 0x82EDF0B8;
	sub_8290DD08(ctx, base);
	// 82EDF0B8: 4BDCCAF9  bl 0x82cabbb0
	ctx.lr = 0x82EDF0BC;
	sub_82CABBB0(ctx, base);
	// 82EDF0BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDF0C0: C01C0020  lfs f0, 0x20(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF0C4: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDF0C8: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EDF0CC; continue 'dispatch;
            }
            0x82EDF0CC => {
    //   block [0x82EDF0CC..0x82EDF0D8)
	// 82EDF0CC: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDF0D0: 41980008  blt cr6, 0x82edf0d8
	if ctx.cr[6].lt {
	pc = 0x82EDF0D8; continue 'dispatch;
	}
	// 82EDF0D4: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDF0D8; continue 'dispatch;
            }
            0x82EDF0D8 => {
    //   block [0x82EDF0D8..0x82EDF0E8)
	// 82EDF0D8: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDF0DC: 409AFFF0  bne cr6, 0x82edf0cc
	if !ctx.cr[6].eq {
	pc = 0x82EDF0CC; continue 'dispatch;
	}
	// 82EDF0E0: D01C0020  stfs f0, 0x20(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EDF0E4: 4BFFFB9C  b 0x82edec80
	pc = 0x82EDEC80; continue 'dispatch;
            }
            0x82EDF0E8 => {
    //   block [0x82EDF0E8..0x82EDF11C)
	// 82EDF0E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDF0EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDF0F0: 388BBB94  addi r4, r11, -0x446c
	ctx.r[4].s64 = ctx.r[11].s64 + -17516;
	// 82EDF0F4: 4BDCDA5D  bl 0x82cacb50
	ctx.lr = 0x82EDF0F8;
	sub_82CACB50(ctx, base);
	// 82EDF0F8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDF0FC: 4082003C  bne 0x82edf138
	if !ctx.cr[0].eq {
	pc = 0x82EDF138; continue 'dispatch;
	}
	// 82EDF100: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDF104: 4BA2EC05  bl 0x8290dd08
	ctx.lr = 0x82EDF108;
	sub_8290DD08(ctx, base);
	// 82EDF108: 4BDCCAA9  bl 0x82cabbb0
	ctx.lr = 0x82EDF10C;
	sub_82CABBB0(ctx, base);
	// 82EDF10C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDF110: C01C0024  lfs f0, 0x24(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF114: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDF118: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EDF11C; continue 'dispatch;
            }
            0x82EDF11C => {
    //   block [0x82EDF11C..0x82EDF128)
	// 82EDF11C: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDF120: 41980008  blt cr6, 0x82edf128
	if ctx.cr[6].lt {
	pc = 0x82EDF128; continue 'dispatch;
	}
	// 82EDF124: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDF128; continue 'dispatch;
            }
            0x82EDF128 => {
    //   block [0x82EDF128..0x82EDF138)
	// 82EDF128: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDF12C: 409AFFF0  bne cr6, 0x82edf11c
	if !ctx.cr[6].eq {
	pc = 0x82EDF11C; continue 'dispatch;
	}
	// 82EDF130: D01C0024  stfs f0, 0x24(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EDF134: 4BFFFB4C  b 0x82edec80
	pc = 0x82EDEC80; continue 'dispatch;
            }
            0x82EDF138 => {
    //   block [0x82EDF138..0x82EDF16C)
	// 82EDF138: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDF13C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDF140: 388BBB78  addi r4, r11, -0x4488
	ctx.r[4].s64 = ctx.r[11].s64 + -17544;
	// 82EDF144: 4BDCDA0D  bl 0x82cacb50
	ctx.lr = 0x82EDF148;
	sub_82CACB50(ctx, base);
	// 82EDF148: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDF14C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDF150: 4082001C  bne 0x82edf16c
	if !ctx.cr[0].eq {
	pc = 0x82EDF16C; continue 'dispatch;
	}
	// 82EDF154: 4BA2EBB5  bl 0x8290dd08
	ctx.lr = 0x82EDF158;
	sub_8290DD08(ctx, base);
	// 82EDF158: 4BDCB269  bl 0x82caa3c0
	ctx.lr = 0x82EDF15C;
	sub_82CAA3C0(ctx, base);
	// 82EDF15C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDF160: 4180FB20  blt 0x82edec80
	if ctx.cr[0].lt {
	pc = 0x82EDEC80; continue 'dispatch;
	}
	// 82EDF164: 907C0028  stw r3, 0x28(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(40 as u32), ctx.r[3].u32 ) };
	// 82EDF168: 4BFFFB18  b 0x82edec80
	pc = 0x82EDEC80; continue 'dispatch;
            }
            0x82EDF16C => {
    //   block [0x82EDF16C..0x82EDF248)
	// 82EDF16C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDF170: 3BABBD00  addi r29, r11, -0x4300
	ctx.r[29].s64 = ctx.r[11].s64 + -17152;
	// 82EDF174: 482DCEED  bl 0x831bc060
	ctx.lr = 0x82EDF178;
	sub_831BC060(ctx, base);
	// 82EDF178: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EDF17C: 4BDCD9D5  bl 0x82cacb50
	ctx.lr = 0x82EDF180;
	sub_82CACB50(ctx, base);
	// 82EDF180: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDF184: 408200D8  bne 0x82edf25c
	if !ctx.cr[0].eq {
	pc = 0x82EDF25C; continue 'dispatch;
	}
	// 82EDF188: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EDF18C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDF190: 3BEB1694  addi r31, r11, 0x1694
	ctx.r[31].s64 = ctx.r[11].s64 + 5780;
	// 82EDF194: 4BA2EB75  bl 0x8290dd08
	ctx.lr = 0x82EDF198;
	sub_8290DD08(ctx, base);
	// 82EDF198: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDF19C: 4BDCD9B5  bl 0x82cacb50
	ctx.lr = 0x82EDF1A0;
	sub_82CACB50(ctx, base);
	// 82EDF1A0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDF1A4: 418200AC  beq 0x82edf250
	if ctx.cr[0].eq {
	pc = 0x82EDF250; continue 'dispatch;
	}
	// 82EDF1A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDF1AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDF1B0: 3BEB0F40  addi r31, r11, 0xf40
	ctx.r[31].s64 = ctx.r[11].s64 + 3904;
	// 82EDF1B4: 4BA2EB55  bl 0x8290dd08
	ctx.lr = 0x82EDF1B8;
	sub_8290DD08(ctx, base);
	// 82EDF1B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDF1BC: 4BDCD995  bl 0x82cacb50
	ctx.lr = 0x82EDF1C0;
	sub_82CACB50(ctx, base);
	// 82EDF1C0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDF1C4: 4182008C  beq 0x82edf250
	if ctx.cr[0].eq {
	pc = 0x82EDF250; continue 'dispatch;
	}
	// 82EDF1C8: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82EDF1CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDF1D0: 3BEBD56C  addi r31, r11, -0x2a94
	ctx.r[31].s64 = ctx.r[11].s64 + -10900;
	// 82EDF1D4: 4BA2EB35  bl 0x8290dd08
	ctx.lr = 0x82EDF1D8;
	sub_8290DD08(ctx, base);
	// 82EDF1D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDF1DC: 4BDCD975  bl 0x82cacb50
	ctx.lr = 0x82EDF1E0;
	sub_82CACB50(ctx, base);
	// 82EDF1E0: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDF1E4: 4182006C  beq 0x82edf250
	if ctx.cr[0].eq {
	pc = 0x82EDF250; continue 'dispatch;
	}
	// 82EDF1E8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 82EDF1EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDF1F0: 3BEB1698  addi r31, r11, 0x1698
	ctx.r[31].s64 = ctx.r[11].s64 + 5784;
	// 82EDF1F4: 4BA2EB15  bl 0x8290dd08
	ctx.lr = 0x82EDF1F8;
	sub_8290DD08(ctx, base);
	// 82EDF1F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDF1FC: 4BDCD955  bl 0x82cacb50
	ctx.lr = 0x82EDF200;
	sub_82CACB50(ctx, base);
	// 82EDF200: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDF204: 41820044  beq 0x82edf248
	if ctx.cr[0].eq {
	pc = 0x82EDF248; continue 'dispatch;
	}
	// 82EDF208: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EDF20C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDF210: 3BEB1700  addi r31, r11, 0x1700
	ctx.r[31].s64 = ctx.r[11].s64 + 5888;
	// 82EDF214: 4BA2EAF5  bl 0x8290dd08
	ctx.lr = 0x82EDF218;
	sub_8290DD08(ctx, base);
	// 82EDF218: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDF21C: 4BDCD935  bl 0x82cacb50
	ctx.lr = 0x82EDF220;
	sub_82CACB50(ctx, base);
	// 82EDF220: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDF224: 41820024  beq 0x82edf248
	if ctx.cr[0].eq {
	pc = 0x82EDF248; continue 'dispatch;
	}
	// 82EDF228: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82EDF22C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDF230: 3BEB7088  addi r31, r11, 0x7088
	ctx.r[31].s64 = ctx.r[11].s64 + 28808;
	// 82EDF234: 4BA2EAD5  bl 0x8290dd08
	ctx.lr = 0x82EDF238;
	sub_8290DD08(ctx, base);
	// 82EDF238: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDF23C: 4BDCD915  bl 0x82cacb50
	ctx.lr = 0x82EDF240;
	sub_82CACB50(ctx, base);
	// 82EDF240: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDF244: 40820150  bne 0x82edf394
	if !ctx.cr[0].eq {
	pc = 0x82EDF394; continue 'dispatch;
	}
	pc = 0x82EDF248; continue 'dispatch;
            }
            0x82EDF248 => {
    //   block [0x82EDF248..0x82EDF250)
	// 82EDF248: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EDF24C: 48000008  b 0x82edf254
	pc = 0x82EDF254; continue 'dispatch;
            }
            0x82EDF250 => {
    //   block [0x82EDF250..0x82EDF254)
	// 82EDF250: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82EDF254; continue 'dispatch;
            }
            0x82EDF254 => {
    //   block [0x82EDF254..0x82EDF25C)
	// 82EDF254: 997C002C  stb r11, 0x2c(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(44 as u32), ctx.r[11].u8 ) };
	// 82EDF258: 4BFFFA28  b 0x82edec80
	pc = 0x82EDEC80; continue 'dispatch;
            }
            0x82EDF25C => {
    //   block [0x82EDF25C..0x82EDF290)
	// 82EDF25C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDF260: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDF264: 388BBCEC  addi r4, r11, -0x4314
	ctx.r[4].s64 = ctx.r[11].s64 + -17172;
	// 82EDF268: 4BDCD8E9  bl 0x82cacb50
	ctx.lr = 0x82EDF26C;
	sub_82CACB50(ctx, base);
	// 82EDF26C: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDF270: 4082003C  bne 0x82edf2ac
	if !ctx.cr[0].eq {
	pc = 0x82EDF2AC; continue 'dispatch;
	}
	// 82EDF274: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDF278: 4BA2EA91  bl 0x8290dd08
	ctx.lr = 0x82EDF27C;
	sub_8290DD08(ctx, base);
	// 82EDF27C: 4BDCC935  bl 0x82cabbb0
	ctx.lr = 0x82EDF280;
	sub_82CABBB0(ctx, base);
	// 82EDF280: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDF284: C01C0030  lfs f0, 0x30(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF288: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDF28C: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EDF290; continue 'dispatch;
            }
            0x82EDF290 => {
    //   block [0x82EDF290..0x82EDF29C)
	// 82EDF290: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDF294: 40990008  ble cr6, 0x82edf29c
	if !ctx.cr[6].gt {
	pc = 0x82EDF29C; continue 'dispatch;
	}
	// 82EDF298: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDF29C; continue 'dispatch;
            }
            0x82EDF29C => {
    //   block [0x82EDF29C..0x82EDF2AC)
	// 82EDF29C: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDF2A0: 409AFFF0  bne cr6, 0x82edf290
	if !ctx.cr[6].eq {
	pc = 0x82EDF290; continue 'dispatch;
	}
	// 82EDF2A4: D01C0030  stfs f0, 0x30(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EDF2A8: 4BFFF9D8  b 0x82edec80
	pc = 0x82EDEC80; continue 'dispatch;
            }
            0x82EDF2AC => {
    //   block [0x82EDF2AC..0x82EDF2DC)
	// 82EDF2AC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDF2B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDF2B4: 388BBCDC  addi r4, r11, -0x4324
	ctx.r[4].s64 = ctx.r[11].s64 + -17188;
	// 82EDF2B8: 4BDCD899  bl 0x82cacb50
	ctx.lr = 0x82EDF2BC;
	sub_82CACB50(ctx, base);
	// 82EDF2BC: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDF2C0: 40820060  bne 0x82edf320
	if !ctx.cr[0].eq {
	pc = 0x82EDF320; continue 'dispatch;
	}
	// 82EDF2C4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDF2C8: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDF2CC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDF2D0: 4182000C  beq 0x82edf2dc
	if ctx.cr[0].eq {
	pc = 0x82EDF2DC; continue 'dispatch;
	}
	// 82EDF2D4: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EDF2D8: 4800000C  b 0x82edf2e4
	pc = 0x82EDF2E4; continue 'dispatch;
            }
            0x82EDF2DC => {
    //   block [0x82EDF2DC..0x82EDF2E4)
	// 82EDF2DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDF2E0: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EDF2E4; continue 'dispatch;
            }
            0x82EDF2E4 => {
    //   block [0x82EDF2E4..0x82EDF304)
	// 82EDF2E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDF2E8: 4BA2EA21  bl 0x8290dd08
	ctx.lr = 0x82EDF2EC;
	sub_8290DD08(ctx, base);
	// 82EDF2EC: 4BDCC8C5  bl 0x82cabbb0
	ctx.lr = 0x82EDF2F0;
	sub_82CABBB0(ctx, base);
	// 82EDF2F0: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDF2F4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDF2F8: C01C0034  lfs f0, 0x34(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF2FC: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDF300: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	pc = 0x82EDF304; continue 'dispatch;
            }
            0x82EDF304 => {
    //   block [0x82EDF304..0x82EDF310)
	// 82EDF304: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDF308: 40990008  ble cr6, 0x82edf310
	if !ctx.cr[6].gt {
	pc = 0x82EDF310; continue 'dispatch;
	}
	// 82EDF30C: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDF310; continue 'dispatch;
            }
            0x82EDF310 => {
    //   block [0x82EDF310..0x82EDF320)
	// 82EDF310: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDF314: 409AFFF0  bne cr6, 0x82edf304
	if !ctx.cr[6].eq {
	pc = 0x82EDF304; continue 'dispatch;
	}
	// 82EDF318: D01C0034  stfs f0, 0x34(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82EDF31C: 4BFFF964  b 0x82edec80
	pc = 0x82EDEC80; continue 'dispatch;
            }
            0x82EDF320 => {
    //   block [0x82EDF320..0x82EDF350)
	// 82EDF320: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDF324: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDF328: 388BBCCC  addi r4, r11, -0x4334
	ctx.r[4].s64 = ctx.r[11].s64 + -17204;
	// 82EDF32C: 4BDCD825  bl 0x82cacb50
	ctx.lr = 0x82EDF330;
	sub_82CACB50(ctx, base);
	// 82EDF330: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDF334: 40820060  bne 0x82edf394
	if !ctx.cr[0].eq {
	pc = 0x82EDF394; continue 'dispatch;
	}
	// 82EDF338: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDF33C: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDF340: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDF344: 4182000C  beq 0x82edf350
	if ctx.cr[0].eq {
	pc = 0x82EDF350; continue 'dispatch;
	}
	// 82EDF348: C3EB000C  lfs f31, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EDF34C: 4800000C  b 0x82edf358
	pc = 0x82EDF358; continue 'dispatch;
            }
            0x82EDF350 => {
    //   block [0x82EDF350..0x82EDF358)
	// 82EDF350: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDF354: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82EDF358; continue 'dispatch;
            }
            0x82EDF358 => {
    //   block [0x82EDF358..0x82EDF378)
	// 82EDF358: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EDF35C: 4BA2E9AD  bl 0x8290dd08
	ctx.lr = 0x82EDF360;
	sub_8290DD08(ctx, base);
	// 82EDF360: 4BDCC851  bl 0x82cabbb0
	ctx.lr = 0x82EDF364;
	sub_82CABBB0(ctx, base);
	// 82EDF364: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EDF368: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDF36C: C01C0038  lfs f0, 0x38(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF370: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDF374: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	pc = 0x82EDF378; continue 'dispatch;
            }
            0x82EDF378 => {
    //   block [0x82EDF378..0x82EDF384)
	// 82EDF378: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDF37C: 40990008  ble cr6, 0x82edf384
	if !ctx.cr[6].gt {
	pc = 0x82EDF384; continue 'dispatch;
	}
	// 82EDF380: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EDF384; continue 'dispatch;
            }
            0x82EDF384 => {
    //   block [0x82EDF384..0x82EDF394)
	// 82EDF384: FF000000  fcmpu cr6, f0, f0
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[0].f64);
	// 82EDF388: 409AFFF0  bne cr6, 0x82edf378
	if !ctx.cr[6].eq {
	pc = 0x82EDF378; continue 'dispatch;
	}
	// 82EDF38C: D01C0038  stfs f0, 0x38(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82EDF390: 4BFFF8F0  b 0x82edec80
	pc = 0x82EDEC80; continue 'dispatch;
            }
            0x82EDF394 => {
    //   block [0x82EDF394..0x82EDF398)
	// 82EDF394: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EDF398; continue 'dispatch;
            }
            0x82EDF398 => {
    //   block [0x82EDF398..0x82EDF3A8)
	// 82EDF398: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EDF39C: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82EDF3A0: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82EDF3A4: 4BDCA0B4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDF3A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EDF3A8 size=212
    let mut pc: u32 = 0x82EDF3A8;
    'dispatch: loop {
        match pc {
            0x82EDF3A8 => {
    //   block [0x82EDF3A8..0x82EDF400)
	// 82EDF3A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDF3AC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EDF3B0: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF3B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EDF3B8: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82EDF3BC: 996300E6  stb r11, 0xe6(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(230 as u32), ctx.r[11].u8 ) };
	// 82EDF3C0: D0030074  stfs f0, 0x74(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EDF3C4: D0030078  stfs f0, 0x78(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EDF3C8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDF3CC: D003007C  stfs f0, 0x7c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82EDF3D0: D1A30080  stfs f13, 0x80(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EDF3D4: C1A30078  lfs f13, 0x78(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDF3D8: D1A30084  stfs f13, 0x84(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EDF3DC: C1A3007C  lfs f13, 0x7c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDF3E0: D1A30088  stfs f13, 0x88(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EDF3E4: 9143008C  stw r10, 0x8c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	// 82EDF3E8: 914300FC  stw r10, 0xfc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(252 as u32), ctx.r[10].u32 ) };
	// 82EDF3EC: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDF3F0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDF3F4: 4182000C  beq 0x82edf400
	if ctx.cr[0].eq {
	pc = 0x82EDF400; continue 'dispatch;
	}
	// 82EDF3F8: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDF3FC: 4800000C  b 0x82edf408
	pc = 0x82EDF408; continue 'dispatch;
            }
            0x82EDF400 => {
    //   block [0x82EDF400..0x82EDF408)
	// 82EDF400: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDF404: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82EDF408; continue 'dispatch;
            }
            0x82EDF408 => {
    //   block [0x82EDF408..0x82EDF420)
	// 82EDF408: 816300C4  lwz r11, 0xc4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EDF40C: D1A30070  stfs f13, 0x70(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82EDF410: D00300C0  stfs f0, 0xc0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82EDF414: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDF418: 41820040  beq 0x82edf458
	if ctx.cr[0].eq {
	pc = 0x82EDF458; continue 'dispatch;
	}
	// 82EDF41C: 48000028  b 0x82edf444
	pc = 0x82EDF444; continue 'dispatch;
            }
            0x82EDF420 => {
    //   block [0x82EDF420..0x82EDF444)
	// 82EDF420: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDF424: 9949002C  stb r10, 0x2c(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(44 as u32), ctx.r[10].u8 ) };
	// 82EDF428: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDF42C: 80EB0010  lwz r7, 0x10(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EDF430: 81090028  lwz r8, 0x28(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EDF434: 90E90028  stw r7, 0x28(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(40 as u32), ctx.r[7].u32 ) };
	// 82EDF438: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDF43C: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82EDF440: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	pc = 0x82EDF444; continue 'dispatch;
            }
            0x82EDF444 => {
    //   block [0x82EDF444..0x82EDF458)
	// 82EDF444: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EDF448: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EDF44C: 409AFFD4  bne cr6, 0x82edf420
	if !ctx.cr[6].eq {
	pc = 0x82EDF420; continue 'dispatch;
	}
	// 82EDF450: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EDF454: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	pc = 0x82EDF458; continue 'dispatch;
            }
            0x82EDF458 => {
    //   block [0x82EDF458..0x82EDF47C)
	// 82EDF458: D00300C8  stfs f0, 0xc8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EDF45C: D00300CC  stfs f0, 0xcc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EDF460: D00300D0  stfs f0, 0xd0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82EDF464: 914300E0  stw r10, 0xe0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(224 as u32), ctx.r[10].u32 ) };
	// 82EDF468: D00300D4  stfs f0, 0xd4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EDF46C: 994300E5  stb r10, 0xe5(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(229 as u32), ctx.r[10].u8 ) };
	// 82EDF470: D00300E8  stfs f0, 0xe8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EDF474: 994300EC  stb r10, 0xec(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(236 as u32), ctx.r[10].u8 ) };
	// 82EDF478: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDF480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EDF480 size=1188
    let mut pc: u32 = 0x82EDF480;
    'dispatch: loop {
        match pc {
            0x82EDF480 => {
    //   block [0x82EDF480..0x82EDF558)
	// 82EDF480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDF484: 4BDC9F7D  bl 0x82ca9400
	ctx.lr = 0x82EDF488;
	sub_82CA93D0(ctx, base);
	// 82EDF488: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82EDF48C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDF490: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDF494: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EDF498: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EDF49C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82EDF4A0: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EDF4A4: C3EA0C18  lfs f31, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EDF4A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDF4AC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EDF4B0: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF4B4: D01F005C  stfs f0, 0x5c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EDF4B8: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF4BC: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EDF4C0: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF4C4: D01F0064  stfs f0, 0x64(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EDF4C8: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EDF4CC: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDF4D0: C01F005C  lfs f0, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF4D4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EDF4D8: C19F0060  lfs f12, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDF4DC: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDF4E0: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EDF4E4: C17E0008  lfs f11, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDF4E8: C19F0064  lfs f12, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDF4EC: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EDF4F0: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDF4F4: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EDF4F8: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EDF4FC: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EDF500: D01F00BC  stfs f0, 0xbc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82EDF504: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDF508: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 82EDF50C: 409903D4  ble cr6, 0x82edf8e0
	if !ctx.cr[6].gt {
	pc = 0x82EDF8E0; continue 'dispatch;
	}
	// 82EDF510: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EDF514: 419A03CC  beq cr6, 0x82edf8e0
	if ctx.cr[6].eq {
	pc = 0x82EDF8E0; continue 'dispatch;
	}
	// 82EDF518: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF51C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82EDF520: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDF524: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDF528: C01F007C  lfs f0, 0x7c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF52C: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82EDF530: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EDF534: C19E0000  lfs f12, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDF538: C15F0074  lfs f10, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EDF53C: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82EDF540: EDAA6028  fsubs f13, f10, f12
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EDF544: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDF548: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EDF54C: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EDF550: 40990008  ble cr6, 0x82edf558
	if !ctx.cr[6].gt {
	pc = 0x82EDF558; continue 'dispatch;
	}
	// 82EDF554: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	pc = 0x82EDF558; continue 'dispatch;
            }
            0x82EDF558 => {
    //   block [0x82EDF558..0x82EDF6C8)
	// 82EDF558: 4B381461  bl 0x822609b8
	ctx.lr = 0x82EDF55C;
	sub_822609B8(ctx, base);
	// 82EDF55C: C1A30058  lfs f13, 0x58(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDF560: C01F00E8  lfs f0, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF564: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDF568: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EDF56C: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EDF570: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF574: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EDF578: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF57C: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EDF580: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF584: D01F007C  stfs f0, 0x7c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82EDF588: C19F005C  lfs f12, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDF58C: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDF590: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EDF594: C17E0004  lfs f11, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDF598: C19F0060  lfs f12, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDF59C: C01F00BC  lfs f0, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF5A0: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EDF5A4: C10B0C14  lfs f8, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EDF5A8: C15E0008  lfs f10, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EDF5AC: EC080024  fdivs f0, f8, f0
	ctx.f[0].f64 = ((ctx.f[8].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EDF5B0: C17F0064  lfs f11, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDF5B4: 57AA063F  clrlwi. r10, r29, 0x18
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82EDF5B8: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EDF5BC: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EDF5C0: D1BF00A8  stfs f13, 0xa8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82EDF5C4: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EDF5C8: D19F00AC  stfs f12, 0xac(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82EDF5CC: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EDF5D0: D01F00B0  stfs f0, 0xb0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82EDF5D4: D1BF0098  stfs f13, 0x98(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82EDF5D8: D3FF0094  stfs f31, 0x94(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82EDF5DC: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EDF5E0: D01F0090  stfs f0, 0x90(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82EDF5E4: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82EDF5E8: C19F0098  lfs f12, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDF5EC: C17F00AC  lfs f11, 0xac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDF5F0: C1BF00B0  lfs f13, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDF5F4: ECEB0332  fmuls f7, f11, f12
	ctx.f[7].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EDF5F8: C13F0090  lfs f9, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EDF5FC: C15F00A8  lfs f10, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EDF600: ECC90372  fmuls f6, f9, f13
	ctx.f[6].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EDF604: ECAA0032  fmuls f5, f10, f0
	ctx.f[5].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDF608: EC0D3838  fmsubs f0, f13, f0, f7
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 - ctx.f[7].f64) as f32) as f64);
	// 82EDF60C: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82EDF610: EDAA3338  fmsubs f13, f10, f12, f6
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[12].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EDF614: D1BF00A0  stfs f13, 0xa0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82EDF618: ED892AF8  fmsubs f12, f9, f11, f5
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[11].f64 - ctx.f[5].f64) as f32) as f64);
	// 82EDF61C: D19F00A4  stfs f12, 0xa4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82EDF620: 813F0048  lwz r9, 0x48(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EDF624: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EDF628: C0090010  lfs f0, 0x10(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF62C: EC080024  fdivs f0, f8, f0
	ctx.f[0].f64 = ((ctx.f[8].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EDF630: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 82EDF634: D01F00F8  stfs f0, 0xf8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82EDF638: 418200A0  beq 0x82edf6d8
	if ctx.cr[0].eq {
	pc = 0x82EDF6D8; continue 'dispatch;
	}
	// 82EDF63C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82EDF640: FD400090  fmr f10, f0
	ctx.f[10].f64 = ctx.f[0].f64;
	// 82EDF644: C1BF0008  lfs f13, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDF648: C0DF0080  lfs f6, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EDF64C: C17F003C  lfs f11, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDF650: C19F0044  lfs f12, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDF654: C0080A98  lfs f0, 0xa98(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2712 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF658: ED8C02F2  fmuls f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EDF65C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDF660: C01F005C  lfs f0, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF664: EC060028  fsubs f0, f6, f0
	ctx.f[0].f64 = (((ctx.f[6].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EDF668: C13F0090  lfs f9, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EDF66C: C17F0064  lfs f11, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDF670: C0BF0088  lfs f5, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82EDF674: ED655828  fsubs f11, f5, f11
	ctx.f[11].f64 = (((ctx.f[5].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EDF678: C0FF0098  lfs f7, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EDF67C: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EDF680: EC090032  fmuls f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDF684: EC0702FA  fmadds f0, f7, f11, f0
	ctx.f[0].f64 = (((ctx.f[7].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EDF688: D01F00CC  stfs f0, 0xcc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EDF68C: D01F00C8  stfs f0, 0xc8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EDF690: C17F005C  lfs f11, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDF694: C01F0080  lfs f0, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF698: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EDF69C: C13F0088  lfs f9, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EDF6A0: C17F0064  lfs f11, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDF6A4: ED695828  fsubs f11, f9, f11
	ctx.f[11].f64 = (((ctx.f[9].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EDF6A8: C13F00A8  lfs f9, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EDF6AC: C0FF00B0  lfs f7, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EDF6B0: EC090032  fmuls f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDF6B4: EC0702FA  fmadds f0, f7, f11, f0
	ctx.f[0].f64 = (((ctx.f[7].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EDF6B8: EC0002B2  fmuls f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EDF6BC: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EDF6C0: 41990008  bgt cr6, 0x82edf6c8
	if ctx.cr[6].gt {
	pc = 0x82EDF6C8; continue 'dispatch;
	}
	// 82EDF6C4: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	pc = 0x82EDF6C8; continue 'dispatch;
            }
            0x82EDF6C8 => {
    //   block [0x82EDF6C8..0x82EDF6D4)
	// 82EDF6C8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EDF6CC: 40980008  bge cr6, 0x82edf6d4
	if !ctx.cr[6].lt {
	pc = 0x82EDF6D4; continue 'dispatch;
	}
	// 82EDF6D0: 9B7F00E4  stb r27, 0xe4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[27].u8 ) };
	pc = 0x82EDF6D4; continue 'dispatch;
            }
            0x82EDF6D4 => {
    //   block [0x82EDF6D4..0x82EDF6D8)
	// 82EDF6D4: 9B7F00E6  stb r27, 0xe6(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(230 as u32), ctx.r[27].u8 ) };
	pc = 0x82EDF6D8; continue 'dispatch;
            }
            0x82EDF6D8 => {
    //   block [0x82EDF6D8..0x82EDF714)
	// 82EDF6D8: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82EDF6DC: 419A0068  beq cr6, 0x82edf744
	if ctx.cr[6].eq {
	pc = 0x82EDF744; continue 'dispatch;
	}
	// 82EDF6E0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82EDF6E4: 419A004C  beq cr6, 0x82edf730
	if ctx.cr[6].eq {
	pc = 0x82EDF730; continue 'dispatch;
	}
	// 82EDF6E8: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82EDF6EC: 409A0134  bne cr6, 0x82edf820
	if !ctx.cr[6].eq {
	pc = 0x82EDF820; continue 'dispatch;
	}
	// 82EDF6F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EDF6F4: 409A0020  bne cr6, 0x82edf714
	if !ctx.cr[6].eq {
	pc = 0x82EDF714; continue 'dispatch;
	}
	// 82EDF6F8: C01F00E8  lfs f0, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF6FC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EDF700: 40990014  ble cr6, 0x82edf714
	if !ctx.cr[6].gt {
	pc = 0x82EDF714; continue 'dispatch;
	}
	// 82EDF704: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 82EDF708: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EDF70C: 409A0114  bne cr6, 0x82edf820
	if !ctx.cr[6].eq {
	pc = 0x82EDF820; continue 'dispatch;
	}
	// 82EDF710: 48000040  b 0x82edf750
	pc = 0x82EDF750; continue 'dispatch;
            }
            0x82EDF714 => {
    //   block [0x82EDF714..0x82EDF724)
	// 82EDF714: C01F00E8  lfs f0, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF718: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EDF71C: 41990008  bgt cr6, 0x82edf724
	if ctx.cr[6].gt {
	pc = 0x82EDF724; continue 'dispatch;
	}
	// 82EDF720: 9B6901B5  stb r27, 0x1b5(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(437 as u32), ctx.r[27].u8 ) };
	pc = 0x82EDF724; continue 'dispatch;
            }
            0x82EDF724 => {
    //   block [0x82EDF724..0x82EDF730)
	// 82EDF724: C01F0024  lfs f0, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF728: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EDF72C: 480000EC  b 0x82edf818
	pc = 0x82EDF818; continue 'dispatch;
            }
            0x82EDF730 => {
    //   block [0x82EDF730..0x82EDF744)
	// 82EDF730: C01F00E8  lfs f0, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF734: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EDF738: 409800E8  bge cr6, 0x82edf820
	if !ctx.cr[6].lt {
	pc = 0x82EDF820; continue 'dispatch;
	}
	// 82EDF73C: 935F00FC  stw r26, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[26].u32 ) };
	// 82EDF740: 480000E0  b 0x82edf820
	pc = 0x82EDF820; continue 'dispatch;
            }
            0x82EDF744 => {
    //   block [0x82EDF744..0x82EDF750)
	// 82EDF744: C01F00E8  lfs f0, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF748: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EDF74C: 409900A8  ble cr6, 0x82edf7f4
	if !ctx.cr[6].gt {
	pc = 0x82EDF7F4; continue 'dispatch;
	}
	pc = 0x82EDF750; continue 'dispatch;
            }
            0x82EDF750 => {
    //   block [0x82EDF750..0x82EDF7D0)
	// 82EDF750: D3FC0000  stfs f31, 0(r28)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EDF754: C17F0080  lfs f11, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDF758: C01F005C  lfs f0, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF75C: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EDF760: C1BF0060  lfs f13, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDF764: C15F0084  lfs f10, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EDF768: EDAA6828  fsubs f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EDF76C: C19F0064  lfs f12, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDF770: C17F0088  lfs f11, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDF774: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EDF778: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDF77C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EDF780: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EDF784: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EDF788: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EDF78C: 419A0044  beq cr6, 0x82edf7d0
	if ctx.cr[6].eq {
	pc = 0x82EDF7D0; continue 'dispatch;
	}
	// 82EDF790: FD605090  fmr f11, f10
	ctx.f[11].f64 = ctx.f[10].f64;
	// 82EDF794: C19F0080  lfs f12, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDF798: C1BF005C  lfs f13, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDF79C: EC080024  fdivs f0, f8, f0
	ctx.f[0].f64 = ((ctx.f[8].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EDF7A0: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EDF7A4: C19F0060  lfs f12, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDF7A8: C15F0088  lfs f10, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EDF7AC: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EDF7B0: C17F0064  lfs f11, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDF7B4: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EDF7B8: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDF7BC: D1BC0004  stfs f13, 4(r28)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EDF7C0: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDF7C4: D19C0008  stfs f12, 8(r28)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EDF7C8: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDF7CC: 48000018  b 0x82edf7e4
	pc = 0x82EDF7E4; continue 'dispatch;
            }
            0x82EDF7D0 => {
    //   block [0x82EDF7D0..0x82EDF7E4)
	// 82EDF7D0: C01F00A8  lfs f0, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF7D4: D01C0004  stfs f0, 4(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EDF7D8: C01F00AC  lfs f0, 0xac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF7DC: D01C0008  stfs f0, 8(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EDF7E0: C01F00B0  lfs f0, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82EDF7E4; continue 'dispatch;
            }
            0x82EDF7E4 => {
    //   block [0x82EDF7E4..0x82EDF7F4)
	// 82EDF7E4: D01C000C  stfs f0, 0xc(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EDF7E8: 9B5C001C  stb r26, 0x1c(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(28 as u32), ctx.r[26].u8 ) };
	// 82EDF7EC: 9B5C001D  stb r26, 0x1d(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(29 as u32), ctx.r[26].u8 ) };
	// 82EDF7F0: 48000128  b 0x82edf918
	pc = 0x82EDF918; continue 'dispatch;
            }
            0x82EDF7F4 => {
    //   block [0x82EDF7F4..0x82EDF810)
	// 82EDF7F4: C01F0020  lfs f0, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF7F8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EDF7FC: 40990014  ble cr6, 0x82edf810
	if !ctx.cr[6].gt {
	pc = 0x82EDF810; continue 'dispatch;
	}
	// 82EDF800: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82EDF804: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EDF808: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 82EDF80C: 4800000C  b 0x82edf818
	pc = 0x82EDF818; continue 'dispatch;
            }
            0x82EDF810 => {
    //   block [0x82EDF810..0x82EDF818)
	// 82EDF810: D3FF00E8  stfs f31, 0xe8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EDF814: 935F00FC  stw r26, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[26].u32 ) };
	pc = 0x82EDF818; continue 'dispatch;
            }
            0x82EDF818 => {
    //   block [0x82EDF818..0x82EDF820)
	// 82EDF818: 9B7F00E4  stb r27, 0xe4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[27].u8 ) };
	// 82EDF81C: 9B7F00E6  stb r27, 0xe6(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(230 as u32), ctx.r[27].u8 ) };
	pc = 0x82EDF820; continue 'dispatch;
            }
            0x82EDF820 => {
    //   block [0x82EDF820..0x82EDF838)
	// 82EDF820: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EDF824: 3D408334  lis r10, -0x7ccc
	ctx.r[10].s64 = -2093744128;
	// 82EDF828: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDF82C: 4182000C  beq 0x82edf838
	if ctx.cr[0].eq {
	pc = 0x82EDF838; continue 'dispatch;
	}
	// 82EDF830: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF834: 4800001C  b 0x82edf850
	pc = 0x82EDF850; continue 'dispatch;
            }
            0x82EDF838 => {
    //   block [0x82EDF838..0x82EDF84C)
	// 82EDF838: 816A0718  lwz r11, 0x718(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDF83C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDF840: 4182000C  beq 0x82edf84c
	if ctx.cr[0].eq {
	pc = 0x82EDF84C; continue 'dispatch;
	}
	// 82EDF844: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF848: 48000008  b 0x82edf850
	pc = 0x82EDF850; continue 'dispatch;
            }
            0x82EDF84C => {
    //   block [0x82EDF84C..0x82EDF850)
	// 82EDF84C: FC004090  fmr f0, f8
	ctx.f[0].f64 = ctx.f[8].f64;
	pc = 0x82EDF850; continue 'dispatch;
            }
            0x82EDF850 => {
    //   block [0x82EDF850..0x82EDF87C)
	// 82EDF850: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EDF854: C1BF0010  lfs f13, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDF858: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82EDF85C: D1BF00B8  stfs f13, 0xb8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82EDF860: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDF864: 41820018  beq 0x82edf87c
	if ctx.cr[0].eq {
	pc = 0x82EDF87C; continue 'dispatch;
	}
	// 82EDF868: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EDF86C: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDF870: C00A0BFC  lfs f0, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF874: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EDF878: 48000018  b 0x82edf890
	pc = 0x82EDF890; continue 'dispatch;
            }
            0x82EDF87C => {
    //   block [0x82EDF87C..0x82EDF88C)
	// 82EDF87C: 816A0718  lwz r11, 0x718(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDF880: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDF884: 41820008  beq 0x82edf88c
	if ctx.cr[0].eq {
	pc = 0x82EDF88C; continue 'dispatch;
	}
	// 82EDF888: C10B000C  lfs f8, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	pc = 0x82EDF88C; continue 'dispatch;
            }
            0x82EDF88C => {
    //   block [0x82EDF88C..0x82EDF890)
	// 82EDF88C: EC08682A  fadds f0, f8, f13
	ctx.f[0].f64 = ((ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64;
	pc = 0x82EDF890; continue 'dispatch;
            }
            0x82EDF890 => {
    //   block [0x82EDF890..0x82EDF8E0)
	// 82EDF890: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EDF894: D01F00B8  stfs f0, 0xb8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82EDF898: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDF89C: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EDF8A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDF8A4: 4E800421  bctrl
	ctx.lr = 0x82EDF8A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EDF8A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EDF8AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDF8B0: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EDF8B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDF8B8: 4E800421  bctrl
	ctx.lr = 0x82EDF8BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EDF8BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDF8C0: 4BFF8C51  bl 0x82ed8510
	ctx.lr = 0x82EDF8C4;
	sub_82ED8510(ctx, base);
	// 82EDF8C4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EDF8C8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EDF8CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDF8D0: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EDF8D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EDF8D8: 4E800421  bctrl
	ctx.lr = 0x82EDF8DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EDF8DC: 4800003C  b 0x82edf918
	pc = 0x82EDF918; continue 'dispatch;
            }
            0x82EDF8E0 => {
    //   block [0x82EDF8E0..0x82EDF918)
	// 82EDF8E0: D3FC0000  stfs f31, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EDF8E4: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EDF8E8: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82EDF8EC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EDF8F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDF8F4: C00B004C  lfs f0, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF8F8: D01C0004  stfs f0, 4(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EDF8FC: C00B0050  lfs f0, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF900: D01C0008  stfs f0, 8(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EDF904: C00B0054  lfs f0, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF908: D01C000C  stfs f0, 0xc(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EDF90C: 9B5C001C  stb r26, 0x1c(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(28 as u32), ctx.r[26].u8 ) };
	// 82EDF910: 9B5C001D  stb r26, 0x1d(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(29 as u32), ctx.r[26].u8 ) };
	// 82EDF914: 4BFF8A55  bl 0x82ed8368
	ctx.lr = 0x82EDF918;
	sub_82ED8368(ctx, base);
	pc = 0x82EDF918; continue 'dispatch;
            }
            0x82EDF918 => {
    //   block [0x82EDF918..0x82EDF924)
	// 82EDF918: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EDF91C: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82EDF920: 4BDC9B30  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDF928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EDF928 size=496
    let mut pc: u32 = 0x82EDF928;
    'dispatch: loop {
        match pc {
            0x82EDF928 => {
    //   block [0x82EDF928..0x82EDF954)
	// 82EDF928: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDF92C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EDF930: 396BBD80  addi r11, r11, -0x4280
	ctx.r[11].s64 = ctx.r[11].s64 + -17024;
	// 82EDF934: C1690C14  lfs f11, 0xc14(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDF938: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EDF93C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDF940: 814B0718  lwz r10, 0x718(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDF944: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDF948: 4182000C  beq 0x82edf954
	if ctx.cr[0].eq {
	pc = 0x82EDF954; continue 'dispatch;
	}
	// 82EDF94C: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDF950: 48000008  b 0x82edf958
	pc = 0x82EDF958; continue 'dispatch;
            }
            0x82EDF954 => {
    //   block [0x82EDF954..0x82EDF958)
	// 82EDF954: FDA05890  fmr f13, f11
	ctx.f[13].f64 = ctx.f[11].f64;
	pc = 0x82EDF958; continue 'dispatch;
            }
            0x82EDF958 => {
    //   block [0x82EDF958..0x82EDF988)
	// 82EDF958: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EDF95C: C00A0AC8  lfs f0, 0xac8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2760 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF960: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EDF964: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDF968: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EDF96C: C14A0BF8  lfs f10, 0xbf8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3064 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EDF970: D1430008  stfs f10, 8(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EDF974: 814B0718  lwz r10, 0x718(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDF978: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDF97C: 4182000C  beq 0x82edf988
	if ctx.cr[0].eq {
	pc = 0x82EDF988; continue 'dispatch;
	}
	// 82EDF980: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF984: 48000008  b 0x82edf98c
	pc = 0x82EDF98C; continue 'dispatch;
            }
            0x82EDF988 => {
    //   block [0x82EDF988..0x82EDF98C)
	// 82EDF988: FC005890  fmr f0, f11
	ctx.f[0].f64 = ctx.f[11].f64;
	pc = 0x82EDF98C; continue 'dispatch;
            }
            0x82EDF98C => {
    //   block [0x82EDF98C..0x82EDF9B0)
	// 82EDF98C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EDF990: C1AA0BFC  lfs f13, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDF994: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EDF998: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EDF99C: 814B0718  lwz r10, 0x718(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDF9A0: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDF9A4: 4182000C  beq 0x82edf9b0
	if ctx.cr[0].eq {
	pc = 0x82EDF9B0; continue 'dispatch;
	}
	// 82EDF9A8: C18A000C  lfs f12, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDF9AC: 48000008  b 0x82edf9b4
	pc = 0x82EDF9B4; continue 'dispatch;
            }
            0x82EDF9B0 => {
    //   block [0x82EDF9B0..0x82EDF9B4)
	// 82EDF9B0: FD805890  fmr f12, f11
	ctx.f[12].f64 = ctx.f[11].f64;
	pc = 0x82EDF9B4; continue 'dispatch;
            }
            0x82EDF9B4 => {
    //   block [0x82EDF9B4..0x82EDFA10)
	// 82EDF9B4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EDF9B8: D1A3001C  stfs f13, 0x1c(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EDF9BC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EDF9C0: D1A30020  stfs f13, 0x20(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EDF9C4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82EDF9C8: D1630024  stfs f11, 0x24(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82EDF9CC: C0090A7C  lfs f0, 0xa7c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF9D0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EDF9D4: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDF9D8: D1830010  stfs f12, 0x10(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EDF9DC: 99430014  stb r10, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 82EDF9E0: 91030028  stw r8, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[8].u32 ) };
	// 82EDF9E4: 9943002C  stb r10, 0x2c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[10].u8 ) };
	// 82EDF9E8: C0090C18  lfs f0, 0xc18(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDF9EC: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EDF9F0: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EDF9F4: C18989CC  lfs f12, -0x7634(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-30260 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDF9F8: D1830030  stfs f12, 0x30(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82EDF9FC: 812B0718  lwz r9, 0x718(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDFA00: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDFA04: 4182000C  beq 0x82edfa10
	if ctx.cr[0].eq {
	pc = 0x82EDFA10; continue 'dispatch;
	}
	// 82EDFA08: C1A9000C  lfs f13, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDFA0C: 48000008  b 0x82edfa14
	pc = 0x82EDFA14; continue 'dispatch;
            }
            0x82EDFA10 => {
    //   block [0x82EDFA10..0x82EDFA14)
	// 82EDFA10: FDA05890  fmr f13, f11
	ctx.f[13].f64 = ctx.f[11].f64;
	pc = 0x82EDFA14; continue 'dispatch;
            }
            0x82EDFA14 => {
    //   block [0x82EDFA14..0x82EDFA30)
	// 82EDFA14: EDAD02B2  fmuls f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EDFA18: D1A30034  stfs f13, 0x34(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82EDFA1C: 812B0718  lwz r9, 0x718(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDFA20: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDFA24: 4182000C  beq 0x82edfa30
	if ctx.cr[0].eq {
	pc = 0x82EDFA30; continue 'dispatch;
	}
	// 82EDFA28: C189000C  lfs f12, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDFA2C: 48000008  b 0x82edfa34
	pc = 0x82EDFA34; continue 'dispatch;
            }
            0x82EDFA30 => {
    //   block [0x82EDFA30..0x82EDFA34)
	// 82EDFA30: FD805890  fmr f12, f11
	ctx.f[12].f64 = ctx.f[11].f64;
	pc = 0x82EDFA34; continue 'dispatch;
            }
            0x82EDFA34 => {
    //   block [0x82EDFA34..0x82EDFA64)
	// 82EDFA34: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EDFA38: C1A90A98  lfs f13, 0xa98(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2712 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDFA3C: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EDFA40: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EDFA44: D1A30038  stfs f13, 0x38(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82EDFA48: C1A9BDF4  lfs f13, -0x420c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16908 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDFA4C: D1A3003C  stfs f13, 0x3c(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82EDFA50: 812B0718  lwz r9, 0x718(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDFA54: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDFA58: 4182000C  beq 0x82edfa64
	if ctx.cr[0].eq {
	pc = 0x82EDFA64; continue 'dispatch;
	}
	// 82EDFA5C: C189000C  lfs f12, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDFA60: 48000008  b 0x82edfa68
	pc = 0x82EDFA68; continue 'dispatch;
            }
            0x82EDFA64 => {
    //   block [0x82EDFA64..0x82EDFA68)
	// 82EDFA64: FD805890  fmr f12, f11
	ctx.f[12].f64 = ctx.f[11].f64;
	pc = 0x82EDFA68; continue 'dispatch;
            }
            0x82EDFA68 => {
    //   block [0x82EDFA68..0x82EDFAF8)
	// 82EDFA68: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EDFA6C: D1630044  stfs f11, 0x44(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82EDFA70: D1830040  stfs f12, 0x40(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82EDFA74: 90830048  stw r4, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[4].u32 ) };
	// 82EDFA78: 91430054  stw r10, 0x54(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82EDFA7C: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EDFA80: 81040004  lwz r8, 4(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EDFA84: 3929AFB4  addi r9, r9, -0x504c
	ctx.r[9].s64 = ctx.r[9].s64 + -20556;
	// 82EDFA88: 81080014  lwz r8, 0x14(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EDFA8C: 91030058  stw r8, 0x58(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 82EDFA90: D003005C  stfs f0, 0x5c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EDFA94: D0030060  stfs f0, 0x60(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EDFA98: D0030064  stfs f0, 0x64(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EDFA9C: D0030074  stfs f0, 0x74(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EDFAA0: D0030078  stfs f0, 0x78(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EDFAA4: D003007C  stfs f0, 0x7c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82EDFAA8: D0030080  stfs f0, 0x80(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EDFAAC: D0030084  stfs f0, 0x84(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EDFAB0: D0030088  stfs f0, 0x88(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EDFAB4: D0030090  stfs f0, 0x90(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82EDFAB8: D0030094  stfs f0, 0x94(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82EDFABC: D0030098  stfs f0, 0x98(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82EDFAC0: D003009C  stfs f0, 0x9c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82EDFAC4: D00300A0  stfs f0, 0xa0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82EDFAC8: D00300A4  stfs f0, 0xa4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82EDFACC: D00300A8  stfs f0, 0xa8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82EDFAD0: D00300AC  stfs f0, 0xac(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82EDFAD4: D00300B0  stfs f0, 0xb0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82EDFAD8: 914300C4  stw r10, 0xc4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(196 as u32), ctx.r[10].u32 ) };
	// 82EDFADC: 912300DC  stw r9, 0xdc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(220 as u32), ctx.r[9].u32 ) };
	// 82EDFAE0: 914300E0  stw r10, 0xe0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(224 as u32), ctx.r[10].u32 ) };
	// 82EDFAE4: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDFAE8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDFAEC: 4182000C  beq 0x82edfaf8
	if ctx.cr[0].eq {
	pc = 0x82EDFAF8; continue 'dispatch;
	}
	// 82EDFAF0: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDFAF4: 48000008  b 0x82edfafc
	pc = 0x82EDFAFC; continue 'dispatch;
            }
            0x82EDFAF8 => {
    //   block [0x82EDFAF8..0x82EDFAFC)
	// 82EDFAF8: FD805890  fmr f12, f11
	ctx.f[12].f64 = ctx.f[11].f64;
	pc = 0x82EDFAFC; continue 'dispatch;
            }
            0x82EDFAFC => {
    //   block [0x82EDFAFC..0x82EDFB18)
	// 82EDFAFC: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EDFB00: D00300F4  stfs f0, 0xf4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82EDFB04: D00300F8  stfs f0, 0xf8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82EDFB08: 91430100  stw r10, 0x100(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(256 as u32), ctx.r[10].u32 ) };
	// 82EDFB0C: EC0B6824  fdivs f0, f11, f13
	ctx.f[0].f64 = ((ctx.f[11].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EDFB10: D00300F0  stfs f0, 0xf0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82EDFB14: 4BFFF894  b 0x82edf3a8
	sub_82EDF3A8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDFB18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EDFB18 size=300
    let mut pc: u32 = 0x82EDFB18;
    'dispatch: loop {
        match pc {
            0x82EDFB18 => {
    //   block [0x82EDFB18..0x82EDFB6C)
	// 82EDFB18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDFB1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EDFB20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EDFB24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EDFB28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDFB2C: 3FC08334  lis r30, -0x7ccc
	ctx.r[30].s64 = -2093744128;
	// 82EDFB30: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDFB34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDFB38: 388B1BA0  addi r4, r11, 0x1ba0
	ctx.r[4].s64 = ctx.r[11].s64 + 7072;
	// 82EDFB3C: 807E0718  lwz r3, 0x718(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDFB40: 4B3880E1  bl 0x82267c20
	ctx.lr = 0x82EDFB44;
	sub_82267C20(ctx, base);
	// 82EDFB44: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EDFB48: 907F004C  stw r3, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[3].u32 ) };
	// 82EDFB4C: 807E0718  lwz r3, 0x718(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EDFB50: 388B8BE4  addi r4, r11, -0x741c
	ctx.r[4].s64 = ctx.r[11].s64 + -29724;
	// 82EDFB54: 4B3880CD  bl 0x82267c20
	ctx.lr = 0x82EDFB58;
	sub_82267C20(ctx, base);
	// 82EDFB58: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDFB5C: 907F0050  stw r3, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82EDFB60: 4082000C  bne 0x82edfb6c
	if !ctx.cr[0].eq {
	pc = 0x82EDFB6C; continue 'dispatch;
	}
	// 82EDFB64: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EDFB68: 480000C4  b 0x82edfc2c
	pc = 0x82EDFC2C; continue 'dispatch;
            }
            0x82EDFB6C => {
    //   block [0x82EDFB6C..0x82EDFBEC)
	// 82EDFB6C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDFB70: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EDFB74: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EDFB78: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82EDFB7C: 4B308AFD  bl 0x821e8678
	ctx.lr = 0x82EDFB80;
	sub_821E8678(ctx, base);
	// 82EDFB80: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82EDFB84: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EDFB88: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EDFB8C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EDFB90: 388BC178  addi r4, r11, -0x3e88
	ctx.r[4].s64 = ctx.r[11].s64 + -16008;
	// 82EDFB94: 915F006C  stw r10, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 82EDFB98: 4B308AE1  bl 0x821e8678
	ctx.lr = 0x82EDFB9C;
	sub_821E8678(ctx, base);
	// 82EDFB9C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EDFBA0: C01F0040  lfs f0, 0x40(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDFBA4: C1BF000C  lfs f13, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDFBA8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82EDFBAC: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EDFBB0: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82EDFBB4: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82EDFBB8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDFBBC: C00B0C68  lfs f0, 0xc68(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDFBC0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EDFBC4: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82EDFBC8: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 82EDFBCC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EDFBD0: 23CB0001  subfic r30, r11, 1
	ctx.xer.ca = ctx.r[11].u32 <= 1 as u32;
	ctx.r[30].s64 = (1 as i64) - ctx.r[11].s64;
	// 82EDFBD4: 4B736D55  bl 0x82616928
	ctx.lr = 0x82EDFBD8;
	sub_82616928(ctx, base);
	// 82EDFBD8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDFBDC: 41820010  beq 0x82edfbec
	if ctx.cr[0].eq {
	pc = 0x82EDFBEC; continue 'dispatch;
	}
	// 82EDFBE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EDFBE4: 4BFFC7D5  bl 0x82edc3b8
	ctx.lr = 0x82EDFBE8;
	sub_82EDC3B8(ctx, base);
	// 82EDFBE8: 48000008  b 0x82edfbf0
	pc = 0x82EDFBF0; continue 'dispatch;
            }
            0x82EDFBEC => {
    //   block [0x82EDFBEC..0x82EDFBF0)
	// 82EDFBEC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EDFBF0; continue 'dispatch;
            }
            0x82EDFBF0 => {
    //   block [0x82EDFBF0..0x82EDFC28)
	// 82EDFBF0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDFBF4: C19F0044  lfs f12, 0x44(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDFBF8: 907F00C4  stw r3, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[3].u32 ) };
	// 82EDFBFC: C1AB0C18  lfs f13, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDFC00: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82EDFC04: 419A0024  beq cr6, 0x82edfc28
	if ctx.cr[6].eq {
	pc = 0x82EDFC28; continue 'dispatch;
	}
	// 82EDFC08: C01F003C  lfs f0, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDFC0C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EDFC10: 419A0018  beq cr6, 0x82edfc28
	if ctx.cr[6].eq {
	pc = 0x82EDFC28; continue 'dispatch;
	}
	// 82EDFC14: EDA00332  fmuls f13, f0, f12
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EDFC18: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDFC1C: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDFC20: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EDFC24: D01F00F4  stfs f0, 0xf4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	pc = 0x82EDFC28; continue 'dispatch;
            }
            0x82EDFC28 => {
    //   block [0x82EDFC28..0x82EDFC2C)
	// 82EDFC28: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EDFC2C; continue 'dispatch;
            }
            0x82EDFC2C => {
    //   block [0x82EDFC2C..0x82EDFC44)
	// 82EDFC2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EDFC30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EDFC34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EDFC38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EDFC3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EDFC40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDFC48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EDFC48 size=72
    let mut pc: u32 = 0x82EDFC48;
    'dispatch: loop {
        match pc {
            0x82EDFC48 => {
    //   block [0x82EDFC48..0x82EDFC78)
	// 82EDFC48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDFC4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EDFC50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EDFC54: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDFC58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDFC5C: 38600104  li r3, 0x104
	ctx.r[3].s64 = 260;
	// 82EDFC60: 4B736CC9  bl 0x82616928
	ctx.lr = 0x82EDFC64;
	sub_82616928(ctx, base);
	// 82EDFC64: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDFC68: 41820010  beq 0x82edfc78
	if ctx.cr[0].eq {
	pc = 0x82EDFC78; continue 'dispatch;
	}
	// 82EDFC6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EDFC70: 4BFFFCB9  bl 0x82edf928
	ctx.lr = 0x82EDFC74;
	sub_82EDF928(ctx, base);
	// 82EDFC74: 48000008  b 0x82edfc7c
	pc = 0x82EDFC7C; continue 'dispatch;
            }
            0x82EDFC78 => {
    //   block [0x82EDFC78..0x82EDFC7C)
	// 82EDFC78: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EDFC7C; continue 'dispatch;
            }
            0x82EDFC7C => {
    //   block [0x82EDFC7C..0x82EDFC90)
	// 82EDFC7C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EDFC80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EDFC84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EDFC88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EDFC8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDFC90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EDFC90 size=200
    let mut pc: u32 = 0x82EDFC90;
    'dispatch: loop {
        match pc {
            0x82EDFC90 => {
    //   block [0x82EDFC90..0x82EDFCC4)
	// 82EDFC90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDFC94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EDFC98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EDFC9C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDFCA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDFCA4: 4BFD30FD  bl 0x82eb2da0
	ctx.lr = 0x82EDFCA8;
	sub_82EB2DA0(ctx, base);
	// 82EDFCA8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EDFCAC: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82EDFCB0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EDFCB4: 806B0400  lwz r3, 0x400(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EDFCB8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDFCBC: 40810054  ble 0x82edfd10
	if !ctx.cr[0].gt {
	pc = 0x82EDFD10; continue 'dispatch;
	}
	// 82EDFCC0: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82EDFCC4; continue 'dispatch;
            }
            0x82EDFCC4 => {
    //   block [0x82EDFCC4..0x82EDFCD0)
	// 82EDFCC4: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EDFCC8: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EDFCCC: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	pc = 0x82EDFCD0; continue 'dispatch;
            }
            0x82EDFCD0 => {
    //   block [0x82EDFCD0..0x82EDFCF4)
	// 82EDFCD0: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EDFCD4: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EDFCD8: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDFCDC: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82EDFCE0: 41820014  beq 0x82edfcf4
	if ctx.cr[0].eq {
	pc = 0x82EDFCF4; continue 'dispatch;
	}
	// 82EDFCE4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EDFCE8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82EDFCEC: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82EDFCF0: 419AFFE0  beq cr6, 0x82edfcd0
	if ctx.cr[6].eq {
	pc = 0x82EDFCD0; continue 'dispatch;
	}
	pc = 0x82EDFCF4; continue 'dispatch;
            }
            0x82EDFCF4 => {
    //   block [0x82EDFCF4..0x82EDFD10)
	// 82EDFCF4: 2C070000  cmpwi r7, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EDFCF8: 41820028  beq 0x82edfd20
	if ctx.cr[0].eq {
	pc = 0x82EDFD20; continue 'dispatch;
	}
	// 82EDFCFC: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EDFD00: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82EDFD04: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EDFD08: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EDFD0C: 4198FFB8  blt cr6, 0x82edfcc4
	if ctx.cr[6].lt {
	pc = 0x82EDFCC4; continue 'dispatch;
	}
	pc = 0x82EDFD10; continue 'dispatch;
            }
            0x82EDFD10 => {
    //   block [0x82EDFD10..0x82EDFD20)
	// 82EDFD10: 2F030100  cmpwi cr6, r3, 0x100
	ctx.cr[6].compare_i32(ctx.r[3].s32, 256, &mut ctx.xer);
	// 82EDFD14: 409A0018  bne cr6, 0x82edfd2c
	if !ctx.cr[6].eq {
	pc = 0x82EDFD2C; continue 'dispatch;
	}
	// 82EDFD18: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EDFD1C: 48000028  b 0x82edfd44
	pc = 0x82EDFD44; continue 'dispatch;
            }
            0x82EDFD20 => {
    //   block [0x82EDFD20..0x82EDFD2C)
	// 82EDFD20: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EDFD24: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EDFD28: 48000018  b 0x82edfd40
	pc = 0x82EDFD40; continue 'dispatch;
            }
            0x82EDFD2C => {
    //   block [0x82EDFD2C..0x82EDFD40)
	// 82EDFD2C: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EDFD30: 7FEA592E  stwx r31, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 82EDFD34: 814B0400  lwz r10, 0x400(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EDFD38: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EDFD3C: 914B0400  stw r10, 0x400(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1024 as u32), ctx.r[10].u32 ) };
	pc = 0x82EDFD40; continue 'dispatch;
            }
            0x82EDFD40 => {
    //   block [0x82EDFD40..0x82EDFD44)
	// 82EDFD40: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EDFD44; continue 'dispatch;
            }
            0x82EDFD44 => {
    //   block [0x82EDFD44..0x82EDFD58)
	// 82EDFD44: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EDFD48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EDFD4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EDFD50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EDFD54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDFD58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EDFD58 size=196
    let mut pc: u32 = 0x82EDFD58;
    'dispatch: loop {
        match pc {
            0x82EDFD58 => {
    //   block [0x82EDFD58..0x82EDFD90)
	// 82EDFD58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDFD5C: 4BDC96A9  bl 0x82ca9404
	ctx.lr = 0x82EDFD60;
	sub_82CA93D0(ctx, base);
	// 82EDFD60: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDFD64: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDFD68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDFD6C: 392BB254  addi r9, r11, -0x4dac
	ctx.r[9].s64 = ctx.r[11].s64 + -19884;
	// 82EDFD70: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 82EDFD74: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82EDFD78: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EDFD7C: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EDFD80: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82EDFD84: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EDFD88: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82EDFD8C: 7D445050  subf r10, r4, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	pc = 0x82EDFD90; continue 'dispatch;
            }
            0x82EDFD90 => {
    //   block [0x82EDFD90..0x82EDFDBC)
	// 82EDFD90: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EDFD94: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EDFD98: 7D2A59AE  stbx r9, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 82EDFD9C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EDFDA0: 4082FFF0  bne 0x82edfd90
	if !ctx.cr[0].eq {
	pc = 0x82EDFD90; continue 'dispatch;
	}
	// 82EDFDA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDFDA8: 4BFFFEE9  bl 0x82edfc90
	ctx.lr = 0x82EDFDAC;
	sub_82EDFC90(ctx, base);
	// 82EDFDAC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDFDB0: 4082000C  bne 0x82edfdbc
	if !ctx.cr[0].eq {
	pc = 0x82EDFDBC; continue 'dispatch;
	}
	// 82EDFDB4: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EDFDB8: 48000010  b 0x82edfdc8
	pc = 0x82EDFDC8; continue 'dispatch;
            }
            0x82EDFDBC => {
    //   block [0x82EDFDBC..0x82EDFDC8)
	// 82EDFDBC: 4BFD2FE5  bl 0x82eb2da0
	ctx.lr = 0x82EDFDC0;
	sub_82EB2DA0(ctx, base);
	// 82EDFDC0: 81630400  lwz r11, 0x400(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1024 as u32) ) } as u64;
	// 82EDFDC4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x82EDFDC8; continue 'dispatch;
            }
            0x82EDFDC8 => {
    //   block [0x82EDFDC8..0x82EDFDEC)
	// 82EDFDC8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EDFDCC: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82EDFDD0: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82EDFDD4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EDFDD8: 93BF010C  stw r29, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[29].u32 ) };
	// 82EDFDDC: 409A0010  bne cr6, 0x82edfdec
	if !ctx.cr[6].eq {
	pc = 0x82EDFDEC; continue 'dispatch;
	}
	// 82EDFDE0: 4BF9FC79  bl 0x82e7fa58
	ctx.lr = 0x82EDFDE4;
	sub_82E7FA58(ctx, base);
	// 82EDFDE4: 907F0110  stw r3, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[3].u32 ) };
	// 82EDFDE8: 4800000C  b 0x82edfdf4
	pc = 0x82EDFDF4; continue 'dispatch;
            }
            0x82EDFDEC => {
    //   block [0x82EDFDEC..0x82EDFDF4)
	// 82EDFDEC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EDFDF0: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	pc = 0x82EDFDF4; continue 'dispatch;
            }
            0x82EDFDF4 => {
    //   block [0x82EDFDF4..0x82EDFE10)
	// 82EDFDF4: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EDFDF8: 41820018  beq 0x82edfe10
	if ctx.cr[0].eq {
	pc = 0x82EDFE10; continue 'dispatch;
	}
	// 82EDFDFC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EDFE00: 813F0110  lwz r9, 0x110(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EDFE04: 814BDB44  lwz r10, -0x24bc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9404 as u32) ) } as u64;
	// 82EDFE08: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 82EDFE0C: 914BDB44  stw r10, -0x24bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9404 as u32), ctx.r[10].u32 ) };
	pc = 0x82EDFE10; continue 'dispatch;
            }
            0x82EDFE10 => {
    //   block [0x82EDFE10..0x82EDFE1C)
	// 82EDFE10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDFE14: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EDFE18: 4BDC963C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDFE20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EDFE20 size=72
    let mut pc: u32 = 0x82EDFE20;
    'dispatch: loop {
        match pc {
            0x82EDFE20 => {
    //   block [0x82EDFE20..0x82EDFE68)
	// 82EDFE20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDFE24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EDFE28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EDFE2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDFE30: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EDFE34: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EDFE38: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EDFE3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDFE40: 4BFFFF19  bl 0x82edfd58
	ctx.lr = 0x82EDFE44;
	sub_82EDFD58(ctx, base);
	// 82EDFE44: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EDFE48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EDFE4C: 396BB230  addi r11, r11, -0x4dd0
	ctx.r[11].s64 = ctx.r[11].s64 + -19920;
	// 82EDFE50: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EDFE54: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EDFE58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EDFE5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EDFE60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EDFE64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDFE68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EDFE68 size=284
    let mut pc: u32 = 0x82EDFE68;
    'dispatch: loop {
        match pc {
            0x82EDFE68 => {
    //   block [0x82EDFE68..0x82EDFEA8)
	// 82EDFE68: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDFE6C: C1660000  lfs f11, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDFE70: C1230008  lfs f9, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EDFE74: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EDFE78: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EDFE7C: C1840008  lfs f12, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDFE80: C0C60008  lfs f6, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EDFE84: C1470000  lfs f10, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EDFE88: C0A70008  lfs f5, 8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82EDFE8C: 4098001C  bge cr6, 0x82edfea8
	if !ctx.cr[6].lt {
	pc = 0x82EDFEA8; continue 'dispatch;
	}
	// 82EDFE90: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82EDFE94: 40980014  bge cr6, 0x82edfea8
	if !ctx.cr[6].lt {
	pc = 0x82EDFEA8; continue 'dispatch;
	}
	// 82EDFE98: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EDFE9C: 4098000C  bge cr6, 0x82edfea8
	if !ctx.cr[6].lt {
	pc = 0x82EDFEA8; continue 'dispatch;
	}
	// 82EDFEA0: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 82EDFEA4: 419800E0  blt cr6, 0x82edff84
	if ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x82EDFF84);
		return;
	}
	pc = 0x82EDFEA8; continue 'dispatch;
            }
            0x82EDFEA8 => {
    //   block [0x82EDFEA8..0x82EDFEC8)
	// 82EDFEA8: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EDFEAC: 4099001C  ble cr6, 0x82edfec8
	if !ctx.cr[6].gt {
	pc = 0x82EDFEC8; continue 'dispatch;
	}
	// 82EDFEB0: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82EDFEB4: 40990014  ble cr6, 0x82edfec8
	if !ctx.cr[6].gt {
	pc = 0x82EDFEC8; continue 'dispatch;
	}
	// 82EDFEB8: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EDFEBC: 4099000C  ble cr6, 0x82edfec8
	if !ctx.cr[6].gt {
	pc = 0x82EDFEC8; continue 'dispatch;
	}
	// 82EDFEC0: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 82EDFEC4: 419900C0  bgt cr6, 0x82edff84
	if ctx.cr[6].gt {
		crate::recompiler::externs::call(ctx, base, 0x82EDFF84);
		return;
	}
	pc = 0x82EDFEC8; continue 'dispatch;
            }
            0x82EDFEC8 => {
    //   block [0x82EDFEC8..0x82EDFEE8)
	// 82EDFEC8: FF093000  fcmpu cr6, f9, f6
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[6].f64);
	// 82EDFECC: 4098001C  bge cr6, 0x82edfee8
	if !ctx.cr[6].lt {
	pc = 0x82EDFEE8; continue 'dispatch;
	}
	// 82EDFED0: FF0C3000  fcmpu cr6, f12, f6
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[6].f64);
	// 82EDFED4: 40980014  bge cr6, 0x82edfee8
	if !ctx.cr[6].lt {
	pc = 0x82EDFEE8; continue 'dispatch;
	}
	// 82EDFED8: FF092800  fcmpu cr6, f9, f5
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[5].f64);
	// 82EDFEDC: 4098000C  bge cr6, 0x82edfee8
	if !ctx.cr[6].lt {
	pc = 0x82EDFEE8; continue 'dispatch;
	}
	// 82EDFEE0: FF0C2800  fcmpu cr6, f12, f5
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[5].f64);
	// 82EDFEE4: 419800A0  blt cr6, 0x82edff84
	if ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x82EDFF84);
		return;
	}
	pc = 0x82EDFEE8; continue 'dispatch;
            }
            0x82EDFEE8 => {
    //   block [0x82EDFEE8..0x82EDFF08)
	// 82EDFEE8: FF093000  fcmpu cr6, f9, f6
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[6].f64);
	// 82EDFEEC: 4099001C  ble cr6, 0x82edff08
	if !ctx.cr[6].gt {
	pc = 0x82EDFF08; continue 'dispatch;
	}
	// 82EDFEF0: FF0C3000  fcmpu cr6, f12, f6
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[6].f64);
	// 82EDFEF4: 40990014  ble cr6, 0x82edff08
	if !ctx.cr[6].gt {
	pc = 0x82EDFF08; continue 'dispatch;
	}
	// 82EDFEF8: FF092800  fcmpu cr6, f9, f5
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[5].f64);
	// 82EDFEFC: 4099000C  ble cr6, 0x82edff08
	if !ctx.cr[6].gt {
	pc = 0x82EDFF08; continue 'dispatch;
	}
	// 82EDFF00: FF0C2800  fcmpu cr6, f12, f5
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[5].f64);
	// 82EDFF04: 41990080  bgt cr6, 0x82edff84
	if ctx.cr[6].gt {
		crate::recompiler::externs::call(ctx, base, 0x82EDFF84);
		return;
	}
	pc = 0x82EDFF08; continue 'dispatch;
            }
            0x82EDFF08 => {
    //   block [0x82EDFF08..0x82EDFF84)
	// 82EDFF08: ED0D0028  fsubs f8, f13, f0
	ctx.f[8].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EDFF0C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDFF10: EDAA5828  fsubs f13, f10, f11
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EDFF14: ECEC4828  fsubs f7, f12, f9
	ctx.f[7].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EDFF18: ED405828  fsubs f10, f0, f11
	ctx.f[10].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EDFF1C: ED853028  fsubs f12, f5, f6
	ctx.f[12].f64 = (((ctx.f[5].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EDFF20: ED293028  fsubs f9, f9, f6
	ctx.f[9].f64 = (((ctx.f[9].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EDFF24: EC070372  fmuls f0, f7, f13
	ctx.f[0].f64 = (((ctx.f[7].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EDFF28: ED6C0238  fmsubs f11, f12, f8, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[8].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EDFF2C: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDFF30: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 82EDFF34: 419A0050  beq cr6, 0x82edff84
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82EDFF84);
		return;
	}
	// 82EDFF38: ED8C02B2  fmuls f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EDFF3C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDFF40: C0CB0C14  lfs f6, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EDFF44: ED665824  fdivs f11, f6, f11
	ctx.f[11].f64 = ((ctx.f[6].f64 / ctx.f[11].f64) as f32) as f64;
	// 82EDFF48: EDA96378  fmsubs f13, f9, f13, f12
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EDFF4C: ED8D02F2  fmuls f12, f13, f11
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EDFF50: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82EDFF54: 41980030  blt cr6, 0x82edff84
	if ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x82EDFF84);
		return;
	}
	// 82EDFF58: FF0C3000  fcmpu cr6, f12, f6
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[6].f64);
	// 82EDFF5C: 40980028  bge cr6, 0x82edff84
	if !ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x82EDFF84);
		return;
	}
	// 82EDFF60: EDA702B2  fmuls f13, f7, f10
	ctx.f[13].f64 = (((ctx.f[7].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EDFF64: EDA96A38  fmsubs f13, f9, f8, f13
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EDFF68: EDAD02F2  fmuls f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EDFF6C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EDFF70: 41980014  blt cr6, 0x82edff84
	if ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x82EDFF84);
		return;
	}
	// 82EDFF74: FF0D3000  fcmpu cr6, f13, f6
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[6].f64);
	// 82EDFF78: 4098000C  bge cr6, 0x82edff84
	if !ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x82EDFF84);
		return;
	}
	// 82EDFF7C: EC2C0072  fmuls f1, f12, f1
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[1].f64) as f32) as f64);
	// 82EDFF80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EDFF90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EDFF90 size=792
    let mut pc: u32 = 0x82EDFF90;
    'dispatch: loop {
        match pc {
            0x82EDFF90 => {
    //   block [0x82EDFF90..0x82EDFFC8)
	// 82EDFF90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EDFF94: 4BDC9479  bl 0x82ca940c
	ctx.lr = 0x82EDFF98;
	sub_82CA93D0(ctx, base);
	// 82EDFF98: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82EDFF9C: 4BDCDD35  bl 0x82cadcd0
	ctx.lr = 0x82EDFFA0;
	sub_82CADCA0(ctx, base);
	// 82EDFFA0: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EDFFA4: FF801090  fmr f28, f2
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[2].f64;
	// 82EDFFA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EDFFAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDFFB0: C13F0108  lfs f9, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EDFFB4: C14B0C18  lfs f10, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EDFFB8: EDBC4828  fsubs f13, f28, f9
	ctx.f[13].f64 = (((ctx.f[28].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EDFFBC: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 82EDFFC0: 40980008  bge cr6, 0x82edffc8
	if !ctx.cr[6].lt {
	pc = 0x82EDFFC8; continue 'dispatch;
	}
	// 82EDFFC4: FDA05090  fmr f13, f10
	ctx.f[13].f64 = ctx.f[10].f64;
	pc = 0x82EDFFC8; continue 'dispatch;
            }
            0x82EDFFC8 => {
    //   block [0x82EDFFC8..0x82EE0080)
	// 82EDFFC8: C044004C  lfs f2, 0x4c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EDFFCC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EDFFD0: C07F00B4  lfs f3, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82EDFFD4: FF1C5000  fcmpu cr6, f28, f10
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[10].f64);
	// 82EDFFD8: C0040058  lfs f0, 0x58(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EDFFDC: EC6300B2  fmuls f3, f3, f2
	ctx.f[3].f64 = (((ctx.f[3].f64 * ctx.f[2].f64) as f32) as f64);
	// 82EDFFE0: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EDFFE4: C0440054  lfs f2, 0x54(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EDFFE8: C3FF00BC  lfs f31, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EDFFEC: C184004C  lfs f12, 0x4c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EDFFF0: C0A40054  lfs f5, 0x54(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82EDFFF4: C1640034  lfs f11, 0x34(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EDFFF8: C104003C  lfs f8, 0x3c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EDFFFC: C0FF009C  lfs f7, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EE0000: C09F0064  lfs f4, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82EE0004: C0DF00A4  lfs f6, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EE0008: EC621FFA  fmadds f3, f2, f31, f3
	ctx.f[3].f64 = (((ctx.f[2].f64 * ctx.f[31].f64 + ctx.f[3].f64) as f32) as f64);
	// 82EE000C: C34B0BE8  lfs f26, 0xbe8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3048 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82EE0010: ED8D0332  fmuls f12, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE0014: EDA50372  fmuls f13, f5, f13
	ctx.f[13].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE0018: C0BF005C  lfs f5, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82EE001C: EF630032  fmuls f27, f3, f0
	ctx.f[27].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE0020: EC0B602A  fadds f0, f11, f12
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EE0024: ED88682A  fadds f12, f8, f13
	ctx.f[12].f64 = ((ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE0028: EDA02828  fsubs f13, f0, f5
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[5].f64) as f32) as f64);
	// 82EE002C: ED6C2028  fsubs f11, f12, f4
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[4].f64) as f32) as f64);
	// 82EE0030: EDA70372  fmuls f13, f7, f13
	ctx.f[13].f64 = (((ctx.f[7].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE0034: EDA66AFA  fmadds f13, f6, f11, f13
	ctx.f[13].f64 = (((ctx.f[6].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE0038: 409A007C  bne cr6, 0x82ee00b4
	if !ctx.cr[6].eq {
	pc = 0x82EE00B4; continue 'dispatch;
	}
	// 82EE003C: FD602890  fmr f11, f5
	ctx.f[11].f64 = ctx.f[5].f64;
	// 82EE0040: FD002090  fmr f8, f4
	ctx.f[8].f64 = ctx.f[4].f64;
	// 82EE0044: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EE0048: C17F00B4  lfs f11, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE004C: ED8C4028  fsubs f12, f12, f8
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EE0050: FD00F890  fmr f8, f31
	ctx.f[8].f64 = ctx.f[31].f64;
	// 82EE0054: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE0058: EC08033A  fmadds f0, f8, f12, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE005C: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EE0060: 4098003C  bge cr6, 0x82ee009c
	if !ctx.cr[6].lt {
	pc = 0x82EE009C; continue 'dispatch;
	}
	// 82EE0064: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE0068: C18B0C8C  lfs f12, 0xc8c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE006C: ED810332  fmuls f12, f1, f12
	ctx.f[12].f64 = (((ctx.f[1].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE0070: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EE0074: 4199000C  bgt cr6, 0x82ee0080
	if ctx.cr[6].gt {
	pc = 0x82EE0080; continue 'dispatch;
	}
	// 82EE0078: FD80D090  fmr f12, f26
	ctx.f[12].f64 = ctx.f[26].f64;
	// 82EE007C: 4800002C  b 0x82ee00a8
	pc = 0x82EE00A8; continue 'dispatch;
            }
            0x82EE0080 => {
    //   block [0x82EE0080..0x82EE009C)
	// 82EE0080: ED610072  fmuls f11, f1, f1
	ctx.f[11].f64 = (((ctx.f[1].f64 * ctx.f[1].f64) as f32) as f64);
	// 82EE0084: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE0088: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE008C: C18B0A7C  lfs f12, 0xa7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2684 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE0090: EC0B0338  fmsubs f0, f11, f12, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE0094: ED80002C  fsqrts f12, f0
	ctx.f[12].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EE0098: 48000010  b 0x82ee00a8
	pc = 0x82EE00A8; continue 'dispatch;
            }
            0x82EE009C => {
    //   block [0x82EE009C..0x82EE00A8)
	// 82EE009C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE00A0: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE00A4: ED810032  fmuls f12, f1, f0
	ctx.f[12].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x82EE00A8; continue 'dispatch;
            }
            0x82EE00A8 => {
    //   block [0x82EE00A8..0x82EE00B4)
	// 82EE00A8: EC0D6028  fsubs f0, f13, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE00AC: EFEC682A  fadds f31, f12, f13
	ctx.f[31].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE00B0: 48000030  b 0x82ee00e0
	pc = 0x82EE00E0; continue 'dispatch;
            }
            0x82EE00B4 => {
    //   block [0x82EE00B4..0x82EE00E0)
	// 82EE00B4: C19F0104  lfs f12, 0x104(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE00B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE00BC: ED6C0072  fmuls f11, f12, f1
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[1].f64) as f32) as f64);
	// 82EE00C0: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE00C4: ED810032  fmuls f12, f1, f0
	ctx.f[12].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE00C8: EF8BE03C  fnmsubs f28, f11, f0, f28
	ctx.f[28].f64 = -(((ctx.f[11].f64 * ctx.f[0].f64 - ctx.f[28].f64) as f32) as f64);
	// 82EE00CC: EC0D6028  fsubs f0, f13, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE00D0: EFEC682A  fadds f31, f12, f13
	ctx.f[31].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE00D4: FF1C5000  fcmpu cr6, f28, f10
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[10].f64);
	// 82EE00D8: 40980008  bge cr6, 0x82ee00e0
	if !ctx.cr[6].lt {
	pc = 0x82EE00E0; continue 'dispatch;
	}
	// 82EE00DC: FF805090  fmr f28, f10
	ctx.f[28].f64 = ctx.f[10].f64;
	pc = 0x82EE00E0; continue 'dispatch;
            }
            0x82EE00E0 => {
    //   block [0x82EE00E0..0x82EE0104)
	// 82EE00E0: C19F0048  lfs f12, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE00E4: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EE00E8: 419901B0  bgt cr6, 0x82ee0298
	if ctx.cr[6].gt {
	pc = 0x82EE0298; continue 'dispatch;
	}
	// 82EE00EC: FDA06050  fneg f13, f12
	ctx.f[13].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE00F0: FF1F6800  fcmpu cr6, f31, f13
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[13].f64);
	// 82EE00F4: 419801A4  blt cr6, 0x82ee0298
	if ctx.cr[6].lt {
	pc = 0x82EE0298; continue 'dispatch;
	}
	// 82EE00F8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE00FC: 40980008  bge cr6, 0x82ee0104
	if !ctx.cr[6].lt {
	pc = 0x82EE0104; continue 'dispatch;
	}
	// 82EE0100: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EE0104; continue 'dispatch;
            }
            0x82EE0104 => {
    //   block [0x82EE0104..0x82EE0110)
	// 82EE0104: FF1F6000  fcmpu cr6, f31, f12
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[12].f64);
	// 82EE0108: 40990008  ble cr6, 0x82ee0110
	if !ctx.cr[6].gt {
	pc = 0x82EE0110; continue 'dispatch;
	}
	// 82EE010C: FFE06090  fmr f31, f12
	ctx.f[31].f64 = ctx.f[12].f64;
	pc = 0x82EE0110; continue 'dispatch;
            }
            0x82EE0110 => {
    //   block [0x82EE0110..0x82EE0188)
	// 82EE0110: EDA9D02A  fadds f13, f9, f26
	ctx.f[13].f64 = ((ctx.f[9].f64 + ctx.f[26].f64) as f32) as f64;
	// 82EE0114: FF1C6800  fcmpu cr6, f28, f13
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[13].f64);
	// 82EE0118: 40980150  bge cr6, 0x82ee0268
	if !ctx.cr[6].lt {
	pc = 0x82EE0268; continue 'dispatch;
	}
	// 82EE011C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE0120: C17F0074  lfs f11, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE0124: C13F0020  lfs f9, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE0128: C18BBAF4  lfs f12, -0x450c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17676 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE012C: EFCB4B3A  fmadds f30, f11, f12, f9
	ctx.f[30].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 + ctx.f[9].f64) as f32) as f64);
	// 82EE0130: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82EE0134: 41990134  bgt cr6, 0x82ee0268
	if ctx.cr[6].gt {
	pc = 0x82EE0268; continue 'dispatch;
	}
	// 82EE0138: FFA0F050  fneg f29, f30
	ctx.f[29].u64 = ctx.f[30].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE013C: FF1FE800  fcmpu cr6, f31, f29
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[29].f64);
	// 82EE0140: 41980128  blt cr6, 0x82ee0268
	if ctx.cr[6].lt {
	pc = 0x82EE0268; continue 'dispatch;
	}
	// 82EE0144: ED9F002A  fadds f12, f31, f0
	ctx.f[12].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EE0148: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EE014C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE0150: FF0C5000  fcmpu cr6, f12, f10
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[10].f64);
	// 82EE0154: 40990088  ble cr6, 0x82ee01dc
	if !ctx.cr[6].gt {
	pc = 0x82EE01DC; continue 'dispatch;
	}
	// 82EE0158: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 82EE015C: 4199002C  bgt cr6, 0x82ee0188
	if ctx.cr[6].gt {
	pc = 0x82EE0188; continue 'dispatch;
	}
	// 82EE0160: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EE0164: D00100F4  stfs f0, 0xf4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82EE0168: D3E100F8  stfs f31, 0xf8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82EE016C: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 82EE0170: D1A100FC  stfs f13, 0xfc(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82EE0174: D3610100  stfs f27, 0x100(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82EE0178: 916100F0  stw r11, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 82EE017C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE0180: 99610104  stb r11, 0x104(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[11].u8 ) };
	// 82EE0184: 48000110  b 0x82ee0294
	pc = 0x82EE0294; continue 'dispatch;
            }
            0x82EE0188 => {
    //   block [0x82EE0188..0x82EE01DC)
	// 82EE0188: 3BABAFB4  addi r29, r11, -0x504c
	ctx.r[29].s64 = ctx.r[11].s64 + -20556;
	// 82EE018C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EE0190: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EE0194: D3C10058  stfs f30, 0x58(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EE0198: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EE019C: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EE01A0: D3610060  stfs f27, 0x60(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EE01A4: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82EE01A8: 9BC10064  stb r30, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u8 ) };
	// 82EE01AC: 4BFFCCAD  bl 0x82edce58
	ctx.lr = 0x82EE01B0;
	sub_82EDCE58(ctx, base);
	// 82EE01B0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EE01B4: D3C10094  stfs f30, 0x94(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82EE01B8: D3E10098  stfs f31, 0x98(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82EE01BC: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82EE01C0: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EE01C4: D381009C  stfs f28, 0x9c(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82EE01C8: D36100A0  stfs f27, 0xa0(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82EE01CC: 93A10090  stw r29, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[29].u32 ) };
	// 82EE01D0: 9BC100A4  stb r30, 0xa4(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[30].u8 ) };
	// 82EE01D4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EE01D8: 480000B8  b 0x82ee0290
	pc = 0x82EE0290; continue 'dispatch;
            }
            0x82EE01DC => {
    //   block [0x82EE01DC..0x82EE020C)
	// 82EE01DC: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82EE01E0: 4198002C  blt cr6, 0x82ee020c
	if ctx.cr[6].lt {
	pc = 0x82EE020C; continue 'dispatch;
	}
	// 82EE01E4: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EE01E8: D00100B4  stfs f0, 0xb4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82EE01EC: D3E100B8  stfs f31, 0xb8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82EE01F0: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82EE01F4: D1A100BC  stfs f13, 0xbc(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82EE01F8: D36100C0  stfs f27, 0xc0(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82EE01FC: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82EE0200: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE0204: 996100C4  stb r11, 0xc4(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[11].u8 ) };
	// 82EE0208: 4800008C  b 0x82ee0294
	pc = 0x82EE0294; continue 'dispatch;
            }
            0x82EE020C => {
    //   block [0x82EE020C..0x82EE0268)
	// 82EE020C: 3BABAFB4  addi r29, r11, -0x504c
	ctx.r[29].s64 = ctx.r[11].s64 + -20556;
	// 82EE0210: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EE0214: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EE0218: D3A10078  stfs f29, 0x78(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EE021C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EE0220: D381007C  stfs f28, 0x7c(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82EE0224: D3610080  stfs f27, 0x80(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EE0228: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82EE022C: 9BC10084  stb r30, 0x84(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u8 ) };
	// 82EE0230: 4BFFCC29  bl 0x82edce58
	ctx.lr = 0x82EE0234;
	sub_82EDCE58(ctx, base);
	// 82EE0234: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EE0238: C01F0108  lfs f0, 0x108(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE023C: EC00D02A  fadds f0, f0, f26
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[26].f64) as f32) as f64;
	// 82EE0240: D3A100D4  stfs f29, 0xd4(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EE0244: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EE0248: D3E100D8  stfs f31, 0xd8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EE024C: D00100DC  stfs f0, 0xdc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EE0250: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 82EE0254: D36100E0  stfs f27, 0xe0(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EE0258: 93A100D0  stw r29, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[29].u32 ) };
	// 82EE025C: 9BC100E4  stb r30, 0xe4(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[30].u8 ) };
	// 82EE0260: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EE0264: 4800002C  b 0x82ee0290
	pc = 0x82EE0290; continue 'dispatch;
            }
            0x82EE0268 => {
    //   block [0x82EE0268..0x82EE0290)
	// 82EE0268: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE026C: D0010114  stfs f0, 0x114(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82EE0270: D3E10118  stfs f31, 0x118(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 82EE0274: 38810110  addi r4, r1, 0x110
	ctx.r[4].s64 = ctx.r[1].s64 + 272;
	// 82EE0278: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EE027C: D381011C  stfs f28, 0x11c(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 82EE0280: D3610120  stfs f27, 0x120(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82EE0284: 91610110  stw r11, 0x110(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82EE0288: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE028C: 99610124  stb r11, 0x124(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), ctx.r[11].u8 ) };
	pc = 0x82EE0290; continue 'dispatch;
            }
            0x82EE0290 => {
    //   block [0x82EE0290..0x82EE0294)
	// 82EE0290: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82EE0294; continue 'dispatch;
            }
            0x82EE0294 => {
    //   block [0x82EE0294..0x82EE0298)
	// 82EE0294: 4BFFCBC5  bl 0x82edce58
	ctx.lr = 0x82EE0298;
	sub_82EDCE58(ctx, base);
	pc = 0x82EE0298; continue 'dispatch;
            }
            0x82EE0298 => {
    //   block [0x82EE0298..0x82EE02A8)
	// 82EE0298: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 82EE029C: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82EE02A0: 4BDCDA7D  bl 0x82cadd1c
	ctx.lr = 0x82EE02A4;
	sub_82CADCEC(ctx, base);
	// 82EE02A4: 4BDC91B8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE02A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE02A8 size=1232
    let mut pc: u32 = 0x82EE02A8;
    'dispatch: loop {
        match pc {
            0x82EE02A8 => {
    //   block [0x82EE02A8..0x82EE0408)
	// 82EE02A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE02AC: 4BDC914D  bl 0x82ca93f8
	ctx.lr = 0x82EE02B0;
	sub_82CA93D0(ctx, base);
	// 82EE02B0: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 82EE02B4: 4BDCD9ED  bl 0x82cadca0
	ctx.lr = 0x82EE02B8;
	sub_82CADCA0(ctx, base);
	// 82EE02B8: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE02BC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EE02C0: C1850008  lfs f12, 8(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE02C4: C0050000  lfs f0, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE02C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE02CC: 396BDBFC  addi r11, r11, -0x2404
	ctx.r[11].s64 = ctx.r[11].s64 + -9220;
	// 82EE02D0: C1A50004  lfs f13, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE02D4: D06101FC  stfs f3, 0x1fc(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(508 as u32), tmp.u32 ) };
	// 82EE02D8: ECA000B2  fmuls f5, f0, f2
	ctx.f[5].f64 = (((ctx.f[0].f64 * ctx.f[2].f64) as f32) as f64);
	// 82EE02DC: EC6D00B2  fmuls f3, f13, f2
	ctx.f[3].f64 = (((ctx.f[13].f64 * ctx.f[2].f64) as f32) as f64);
	// 82EE02E0: C1040000  lfs f8, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE02E4: EC4C00B2  fmuls f2, f12, f2
	ctx.f[2].f64 = (((ctx.f[12].f64 * ctx.f[2].f64) as f32) as f64);
	// 82EE02E8: C0E40004  lfs f7, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EE02EC: C0C40008  lfs f6, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EE02F0: 3B9F00B4  addi r28, r31, 0xb4
	ctx.r[28].s64 = ctx.r[31].s64 + 180;
	// 82EE02F4: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE02F8: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 82EE02FC: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE0300: EFC002F2  fmuls f30, f0, f11
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE0304: C12B0004  lfs f9, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE0308: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE030C: EFEC0272  fmuls f31, f12, f9
	ctx.f[31].f64 = (((ctx.f[12].f64 * ctx.f[9].f64) as f32) as f64);
	// 82EE0310: C35F005C  lfs f26, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82EE0314: EFAD02B2  fmuls f29, f13, f10
	ctx.f[29].f64 = (((ctx.f[13].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EE0318: C33F0064  lfs f25, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82EE031C: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 82EE0320: C30B0BEC  lfs f24, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 82EE0324: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE0328: FC80C090  fmr f4, f24
	ctx.f[4].f64 = ctx.f[24].f64;
	// 82EE032C: FDE0C090  fmr f15, f24
	ctx.f[15].f64 = ctx.f[24].f64;
	// 82EE0330: ED4CF2B8  fmsubs f10, f12, f10, f30
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[10].f64 - ctx.f[30].f64) as f32) as f64);
	// 82EE0334: C2CB0C1C  lfs f22, 0xc1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3100 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 82EE0338: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE033C: ED6DFAF8  fmsubs f11, f13, f11, f31
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[11].f64 - ctx.f[31].f64) as f32) as f64);
	// 82EE0340: ED20EA78  fmsubs f9, f0, f9, f29
	ctx.f[9].f64 = (((ctx.f[0].f64 * ctx.f[9].f64 - ctx.f[29].f64) as f32) as f64);
	// 82EE0344: FF60B090  fmr f27, f22
	ctx.f[27].f64 = ctx.f[22].f64;
	// 82EE0348: C26B0C18  lfs f19, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[19].f64 = (tmp.f32 as f64);
	// 82EE034C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE0350: FDC09890  fmr f14, f19
	ctx.f[14].f64 = ctx.f[19].f64;
	// 82EE0354: C3EB0BFC  lfs f31, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EE0358: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE035C: EDA307F2  fmuls f13, f3, f31
	ctx.f[13].f64 = (((ctx.f[3].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EE0360: EC0507F2  fmuls f0, f5, f31
	ctx.f[0].f64 = (((ctx.f[5].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EE0364: EC6B0072  fmuls f3, f11, f1
	ctx.f[3].f64 = (((ctx.f[11].f64 * ctx.f[1].f64) as f32) as f64);
	// 82EE0368: ED8207F2  fmuls f12, f2, f31
	ctx.f[12].f64 = (((ctx.f[2].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EE036C: EC4A0072  fmuls f2, f10, f1
	ctx.f[2].f64 = (((ctx.f[10].f64 * ctx.f[1].f64) as f32) as f64);
	// 82EE0370: C16B0C4C  lfs f11, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE0374: EC290072  fmuls f1, f9, f1
	ctx.f[1].f64 = (((ctx.f[9].f64 * ctx.f[1].f64) as f32) as f64);
	// 82EE0378: ED276828  fsubs f9, f7, f13
	ctx.f[9].f64 = (((ctx.f[7].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE037C: ED480028  fsubs f10, f8, f0
	ctx.f[10].f64 = (((ctx.f[8].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE0380: EFC002F2  fmuls f30, f0, f11
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE0384: EC0307F2  fmuls f0, f3, f31
	ctx.f[0].f64 = (((ctx.f[3].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EE0388: EFAD02F2  fmuls f29, f13, f11
	ctx.f[29].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE038C: EDA207F2  fmuls f13, f2, f31
	ctx.f[13].f64 = (((ctx.f[2].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EE0390: EF8C02F2  fmuls f28, f12, f11
	ctx.f[28].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE0394: ECA66028  fsubs f5, f6, f12
	ctx.f[5].f64 = (((ctx.f[6].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE0398: ED8107F2  fmuls f12, f1, f31
	ctx.f[12].f64 = (((ctx.f[1].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EE039C: ED08F02A  fadds f8, f8, f30
	ctx.f[8].f64 = ((ctx.f[8].f64 + ctx.f[30].f64) as f32) as f64;
	// 82EE03A0: EC60502A  fadds f3, f0, f10
	ctx.f[3].f64 = ((ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64;
	// 82EE03A4: D06100BC  stfs f3, 0xbc(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82EE03A8: ED4A0028  fsubs f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE03AC: D14100C8  stfs f10, 0xc8(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EE03B0: ECE7E82A  fadds f7, f7, f29
	ctx.f[7].f64 = ((ctx.f[7].f64 + ctx.f[29].f64) as f32) as f64;
	// 82EE03B4: ED4D482A  fadds f10, f13, f9
	ctx.f[10].f64 = ((ctx.f[13].f64 + ctx.f[9].f64) as f32) as f64;
	// 82EE03B8: D14100C0  stfs f10, 0xc0(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82EE03BC: ECC6E02A  fadds f6, f6, f28
	ctx.f[6].f64 = ((ctx.f[6].f64 + ctx.f[28].f64) as f32) as f64;
	// 82EE03C0: ED496828  fsubs f10, f9, f13
	ctx.f[10].f64 = (((ctx.f[9].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE03C4: D14100CC  stfs f10, 0xcc(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EE03C8: ED4C282A  fadds f10, f12, f5
	ctx.f[10].f64 = ((ctx.f[12].f64 + ctx.f[5].f64) as f32) as f64;
	// 82EE03CC: D14100C4  stfs f10, 0xc4(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EE03D0: ED456028  fsubs f10, f5, f12
	ctx.f[10].f64 = (((ctx.f[5].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE03D4: D14100D0  stfs f10, 0xd0(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82EE03D8: ED40402A  fadds f10, f0, f8
	ctx.f[10].f64 = ((ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64;
	// 82EE03DC: D14100B0  stfs f10, 0xb0(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82EE03E0: EC080028  fsubs f0, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE03E4: D00100D4  stfs f0, 0xd4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EE03E8: ED4D382A  fadds f10, f13, f7
	ctx.f[10].f64 = ((ctx.f[13].f64 + ctx.f[7].f64) as f32) as f64;
	// 82EE03EC: D14100B4  stfs f10, 0xb4(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82EE03F0: EC076828  fsubs f0, f7, f13
	ctx.f[0].f64 = (((ctx.f[7].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE03F4: D00100D8  stfs f0, 0xd8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EE03F8: ED4C302A  fadds f10, f12, f6
	ctx.f[10].f64 = ((ctx.f[12].f64 + ctx.f[6].f64) as f32) as f64;
	// 82EE03FC: D14100B8  stfs f10, 0xb8(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82EE0400: EC066028  fsubs f0, f6, f12
	ctx.f[0].f64 = (((ctx.f[6].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE0404: D00100DC  stfs f0, 0xdc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	pc = 0x82EE0408; continue 'dispatch;
            }
            0x82EE0408 => {
    //   block [0x82EE0408..0x82EE0434)
	// 82EE0408: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE040C: EDA0D028  fsubs f13, f0, f26
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[26].f64) as f32) as f64);
	// 82EE0410: C18A0008  lfs f12, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE0414: C01C0008  lfs f0, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE0418: ED8CC828  fsubs f12, f12, f25
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[25].f64) as f32) as f64);
	// 82EE041C: C15C0000  lfs f10, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE0420: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE0424: EC0C02B8  fmsubs f0, f12, f10, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE0428: FF040000  fcmpu cr6, f4, f0
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[0].f64);
	// 82EE042C: 40990008  ble cr6, 0x82ee0434
	if !ctx.cr[6].gt {
	pc = 0x82EE0434; continue 'dispatch;
	}
	// 82EE0430: FC800090  fmr f4, f0
	ctx.f[4].f64 = ctx.f[0].f64;
	pc = 0x82EE0434; continue 'dispatch;
            }
            0x82EE0434 => {
    //   block [0x82EE0434..0x82EE0440)
	// 82EE0434: FF1B0000  fcmpu cr6, f27, f0
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[0].f64);
	// 82EE0438: 40980008  bge cr6, 0x82ee0440
	if !ctx.cr[6].lt {
	pc = 0x82EE0440; continue 'dispatch;
	}
	// 82EE043C: FF600090  fmr f27, f0
	ctx.f[27].f64 = ctx.f[0].f64;
	pc = 0x82EE0440; continue 'dispatch;
            }
            0x82EE0440 => {
    //   block [0x82EE0440..0x82EE0460)
	// 82EE0440: C15C0000  lfs f10, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE0444: EDAD02B2  fmuls f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EE0448: C15C0008  lfs f10, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE044C: EDAA6B3A  fmadds f13, f10, f12, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE0450: FF0D7800  fcmpu cr6, f13, f15
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[15].f64);
	// 82EE0454: 4098000C  bge cr6, 0x82ee0460
	if !ctx.cr[6].lt {
	pc = 0x82EE0460; continue 'dispatch;
	}
	// 82EE0458: FDE06890  fmr f15, f13
	ctx.f[15].f64 = ctx.f[13].f64;
	// 82EE045C: FDC00090  fmr f14, f0
	ctx.f[14].f64 = ctx.f[0].f64;
	pc = 0x82EE0460; continue 'dispatch;
            }
            0x82EE0460 => {
    //   block [0x82EE0460..0x82EE0480)
	// 82EE0460: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EE0464: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82EE0468: 4082FFA0  bne 0x82ee0408
	if !ctx.cr[0].eq {
	pc = 0x82EE0408; continue 'dispatch;
	}
	// 82EE046C: C01F0048  lfs f0, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE0470: FDA00050  fneg f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE0474: FF046800  fcmpu cr6, f4, f13
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[13].f64);
	// 82EE0478: 40980008  bge cr6, 0x82ee0480
	if !ctx.cr[6].lt {
	pc = 0x82EE0480; continue 'dispatch;
	}
	// 82EE047C: FC806890  fmr f4, f13
	ctx.f[4].f64 = ctx.f[13].f64;
	pc = 0x82EE0480; continue 'dispatch;
            }
            0x82EE0480 => {
    //   block [0x82EE0480..0x82EE048C)
	// 82EE0480: FF1B0000  fcmpu cr6, f27, f0
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[0].f64);
	// 82EE0484: 40990008  ble cr6, 0x82ee048c
	if !ctx.cr[6].gt {
	pc = 0x82EE048C; continue 'dispatch;
	}
	// 82EE0488: FF600090  fmr f27, f0
	ctx.f[27].f64 = ctx.f[0].f64;
	pc = 0x82EE048C; continue 'dispatch;
            }
            0x82EE048C => {
    //   block [0x82EE048C..0x82EE04B4)
	// 82EE048C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EE0490: C19F0074  lfs f12, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE0494: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EE0498: EE8CDFFA  fmadds f20, f12, f31, f27
	ctx.f[20].f64 = (((ctx.f[12].f64 * ctx.f[31].f64 + ctx.f[27].f64) as f32) as f64);
	// 82EE049C: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EE04A0: C1AA0C14  lfs f13, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE04A4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE04A8: 4182000C  beq 0x82ee04b4
	if ctx.cr[0].eq {
	pc = 0x82EE04B4; continue 'dispatch;
	}
	// 82EE04AC: C14B000C  lfs f10, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE04B0: 48000008  b 0x82ee04b8
	pc = 0x82EE04B8; continue 'dispatch;
            }
            0x82EE04B4 => {
    //   block [0x82EE04B4..0x82EE04B8)
	// 82EE04B4: FD406890  fmr f10, f13
	ctx.f[10].f64 = ctx.f[13].f64;
	pc = 0x82EE04B8; continue 'dispatch;
            }
            0x82EE04B8 => {
    //   block [0x82EE04B8..0x82EE04D0)
	// 82EE04B8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EE04BC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE04C0: C00A0A54  lfs f0, 0xa54(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE04C4: EFAA0032  fmuls f29, f10, f0
	ctx.f[29].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE04C8: 41820008  beq 0x82ee04d0
	if ctx.cr[0].eq {
	pc = 0x82EE04D0; continue 'dispatch;
	}
	// 82EE04CC: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82EE04D0; continue 'dispatch;
            }
            0x82EE04D0 => {
    //   block [0x82EE04D0..0x82EE04F8)
	// 82EE04D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE04D4: ED8C02F2  fmuls f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE04D8: C00B0AC8  lfs f0, 0xac8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2760 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE04DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EE04E0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE04E4: EDB42028  fsubs f13, f20, f4
	ctx.f[13].f64 = (((ctx.f[20].f64 - ctx.f[4].f64) as f32) as f64);
	// 82EE04E8: EEA0E82A  fadds f21, f0, f29
	ctx.f[21].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 82EE04EC: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EE04F0: 41990008  bgt cr6, 0x82ee04f8
	if ctx.cr[6].gt {
	pc = 0x82EE04F8; continue 'dispatch;
	}
	// 82EE04F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EE04F8; continue 'dispatch;
            }
            0x82EE04F8 => {
    //   block [0x82EE04F8..0x82EE0594)
	// 82EE04F8: C01C0000  lfs f0, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE04FC: 3B3F009C  addi r25, r31, 0x9c
	ctx.r[25].s64 = ctx.r[31].s64 + 156;
	// 82EE0500: C1BC0004  lfs f13, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE0504: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EE0508: C19C0008  lfs f12, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE050C: EDAD0772  fmuls f13, f13, f29
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EE0510: ED8C0772  fmuls f12, f12, f29
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EE0514: C11F005C  lfs f8, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE0518: C0FF0060  lfs f7, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EE051C: FF602090  fmr f27, f4
	ctx.f[27].f64 = ctx.f[4].f64;
	// 82EE0520: C0DF0064  lfs f6, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EE0524: FF04A000  fcmpu cr6, f4, f20
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[20].f64);
	// 82EE0528: C1790000  lfs f11, 0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE052C: 5578063E  clrlwi r24, r11, 0x18
	ctx.r[24].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EE0530: C1590004  lfs f10, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE0534: ED6B0132  fmuls f11, f11, f4
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[4].f64) as f32) as f64);
	// 82EE0538: C1390008  lfs f9, 8(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE053C: ED4A0132  fmuls f10, f10, f4
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[4].f64) as f32) as f64);
	// 82EE0540: ED290132  fmuls f9, f9, f4
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[4].f64) as f32) as f64);
	// 82EE0544: EC080028  fsubs f0, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE0548: EDA76828  fsubs f13, f7, f13
	ctx.f[13].f64 = (((ctx.f[7].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE054C: ED866028  fsubs f12, f6, f12
	ctx.f[12].f64 = (((ctx.f[6].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE0550: EF40582A  fadds f26, f0, f11
	ctx.f[26].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EE0554: D3410050  stfs f26, 0x50(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EE0558: EF2D502A  fadds f25, f13, f10
	ctx.f[25].f64 = ((ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64;
	// 82EE055C: D3210054  stfs f25, 0x54(r1)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EE0560: EEEC482A  fadds f23, f12, f9
	ctx.f[23].f64 = ((ctx.f[12].f64 + ctx.f[9].f64) as f32) as f64;
	// 82EE0564: D2E10058  stfs f23, 0x58(r1)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EE0568: 40980200  bge cr6, 0x82ee0768
	if !ctx.cr[6].lt {
	pc = 0x82EE0768; continue 'dispatch;
	}
	// 82EE056C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EE0570: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82EE0574: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EE0578: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EE057C: 3B6B9128  addi r27, r11, -0x6ed8
	ctx.r[27].s64 = ctx.r[11].s64 + -28376;
	// 82EE0580: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE0584: C208BAF4  lfs f16, -0x450c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-17676 as u32) ) };
	ctx.f[16].f64 = (tmp.f32 as f64);
	// 82EE0588: C229BDE8  lfs f17, -0x4218(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16920 as u32) ) };
	ctx.f[17].f64 = (tmp.f32 as f64);
	// 82EE058C: 3B4BAFB4  addi r26, r11, -0x504c
	ctx.r[26].s64 = ctx.r[11].s64 + -20556;
	// 82EE0590: C24A0BE8  lfs f18, 0xbe8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3048 as u32) ) };
	ctx.f[18].f64 = (tmp.f32 as f64);
	pc = 0x82EE0594; continue 'dispatch;
            }
            0x82EE0594 => {
    //   block [0x82EE0594..0x82EE05D4)
	// 82EE0594: C01C0000  lfs f0, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE0598: FFC0C090  fmr f30, f24
	ctx.f[30].f64 = ctx.f[24].f64;
	// 82EE059C: C1BC0004  lfs f13, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE05A0: EC000572  fmuls f0, f0, f21
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[21].f64) as f32) as f64);
	// 82EE05A4: C19C0008  lfs f12, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE05A8: EDAD0572  fmuls f13, f13, f21
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[21].f64) as f32) as f64);
	// 82EE05AC: ED8C0572  fmuls f12, f12, f21
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[21].f64) as f32) as f64);
	// 82EE05B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE05B4: FF80B090  fmr f28, f22
	ctx.f[28].f64 = ctx.f[22].f64;
	// 82EE05B8: 3BC100B0  addi r30, r1, 0xb0
	ctx.r[30].s64 = ctx.r[1].s64 + 176;
	// 82EE05BC: EC00D02A  fadds f0, f0, f26
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[26].f64) as f32) as f64;
	// 82EE05C0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EE05C4: EC0DC82A  fadds f0, f13, f25
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[25].f64) as f32) as f64;
	// 82EE05C8: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EE05CC: EC0CB82A  fadds f0, f12, f23
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[23].f64) as f32) as f64;
	// 82EE05D0: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	pc = 0x82EE05D4; continue 'dispatch;
            }
            0x82EE05D4 => {
    //   block [0x82EE05D4..0x82EE0610)
	// 82EE05D4: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	// 82EE05D8: FC20A890  fmr f1, f21
	ctx.f[1].f64 = ctx.f[21].f64;
	// 82EE05DC: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 82EE05E0: 57AB07BE  clrlwi r11, r29, 0x1e
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000003u64;
	// 82EE05E4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EE05E8: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EE05EC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EE05F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EE05F4: 7CEB5214  add r7, r11, r10
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EE05F8: 4BFFF871  bl 0x82edfe68
	ctx.lr = 0x82EE05FC;
	sub_82EDFE68(ctx, base);
	// 82EE05FC: FF01C000  fcmpu cr6, f1, f24
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[24].f64);
	// 82EE0600: 419A001C  beq cr6, 0x82ee061c
	if ctx.cr[6].eq {
	pc = 0x82EE061C; continue 'dispatch;
	}
	// 82EE0604: FF1C0800  fcmpu cr6, f28, f1
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[1].f64);
	// 82EE0608: 40980008  bge cr6, 0x82ee0610
	if !ctx.cr[6].lt {
	pc = 0x82EE0610; continue 'dispatch;
	}
	// 82EE060C: FF800890  fmr f28, f1
	ctx.f[28].f64 = ctx.f[1].f64;
	pc = 0x82EE0610; continue 'dispatch;
            }
            0x82EE0610 => {
    //   block [0x82EE0610..0x82EE061C)
	// 82EE0610: FF1E0800  fcmpu cr6, f30, f1
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[1].f64);
	// 82EE0614: 40990008  ble cr6, 0x82ee061c
	if !ctx.cr[6].gt {
	pc = 0x82EE061C; continue 'dispatch;
	}
	// 82EE0618: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	pc = 0x82EE061C; continue 'dispatch;
            }
            0x82EE061C => {
    //   block [0x82EE061C..0x82EE0640)
	// 82EE061C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EE0620: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 82EE0624: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82EE0628: 4198FFAC  blt cr6, 0x82ee05d4
	if ctx.cr[6].lt {
	pc = 0x82EE05D4; continue 'dispatch;
	}
	// 82EE062C: FF1CE800  fcmpu cr6, f28, f29
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[29].f64);
	// 82EE0630: 419800F4  blt cr6, 0x82ee0724
	if ctx.cr[6].lt {
	pc = 0x82EE0724; continue 'dispatch;
	}
	// 82EE0634: FF1EE800  fcmpu cr6, f30, f29
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[29].f64);
	// 82EE0638: 40980008  bge cr6, 0x82ee0640
	if !ctx.cr[6].lt {
	pc = 0x82EE0640; continue 'dispatch;
	}
	// 82EE063C: FFC0E890  fmr f30, f29
	ctx.f[30].f64 = ctx.f[29].f64;
	pc = 0x82EE0640; continue 'dispatch;
            }
            0x82EE0640 => {
    //   block [0x82EE0640..0x82EE066C)
	// 82EE0640: EDBEE828  fsubs f13, f30, f29
	ctx.f[13].f64 = (((ctx.f[30].f64 - ctx.f[29].f64) as f32) as f64);
	// 82EE0644: C17F0104  lfs f11, 0x104(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE0648: C01F0074  lfs f0, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE064C: C19F0048  lfs f12, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE0650: ED4D02F2  fmuls f10, f13, f11
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE0654: EDA0DFFC  fnmsubs f13, f0, f31, f27
	ctx.f[13].f64 = -(((ctx.f[0].f64 * ctx.f[31].f64 - ctx.f[27].f64) as f32) as f64);
	// 82EE0658: FD606050  fneg f11, f12
	ctx.f[11].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE065C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE0660: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82EE0664: 40980008  bge cr6, 0x82ee066c
	if !ctx.cr[6].lt {
	pc = 0x82EE066C; continue 'dispatch;
	}
	// 82EE0668: FDA05890  fmr f13, f11
	ctx.f[13].f64 = ctx.f[11].f64;
	pc = 0x82EE066C; continue 'dispatch;
            }
            0x82EE066C => {
    //   block [0x82EE066C..0x82EE0678)
	// 82EE066C: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EE0670: 40990008  ble cr6, 0x82ee0678
	if !ctx.cr[6].gt {
	pc = 0x82EE0678; continue 'dispatch;
	}
	// 82EE0674: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	pc = 0x82EE0678; continue 'dispatch;
            }
            0x82EE0678 => {
    //   block [0x82EE0678..0x82EE06AC)
	// 82EE0678: FF0F9800  fcmpu cr6, f15, f19
	ctx.cr[6].compare_f64(ctx.f[15].f64, ctx.f[19].f64);
	// 82EE067C: 4098007C  bge cr6, 0x82ee06f8
	if !ctx.cr[6].lt {
	pc = 0x82EE06F8; continue 'dispatch;
	}
	// 82EE0680: C19F0108  lfs f12, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE0684: ED8C902A  fadds f12, f12, f18
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[18].f64) as f32) as f64;
	// 82EE0688: FF0A6000  fcmpu cr6, f10, f12
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[12].f64);
	// 82EE068C: 4098006C  bge cr6, 0x82ee06f8
	if !ctx.cr[6].lt {
	pc = 0x82EE06F8; continue 'dispatch;
	}
	// 82EE0690: FF0E9800  fcmpu cr6, f14, f19
	ctx.cr[6].compare_f64(ctx.f[14].f64, ctx.f[19].f64);
	// 82EE0694: 41990018  bgt cr6, 0x82ee06ac
	if ctx.cr[6].gt {
	pc = 0x82EE06AC; continue 'dispatch;
	}
	// 82EE0698: C17F0074  lfs f11, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE069C: C13F0020  lfs f9, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE06A0: ED6B4C78  fmsubs f11, f11, f17, f9
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[17].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EE06A4: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EE06A8: 40980020  bge cr6, 0x82ee06c8
	if !ctx.cr[6].lt {
	pc = 0x82EE06C8; continue 'dispatch;
	}
	pc = 0x82EE06AC; continue 'dispatch;
            }
            0x82EE06AC => {
    //   block [0x82EE06AC..0x82EE06C8)
	// 82EE06AC: FF0E9800  fcmpu cr6, f14, f19
	ctx.cr[6].compare_f64(ctx.f[14].f64, ctx.f[19].f64);
	// 82EE06B0: 40990048  ble cr6, 0x82ee06f8
	if !ctx.cr[6].gt {
	pc = 0x82EE06F8; continue 'dispatch;
	}
	// 82EE06B4: C17F0074  lfs f11, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE06B8: C13F0020  lfs f9, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE06BC: ED6B4C3A  fmadds f11, f11, f16, f9
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[16].f64 + ctx.f[9].f64) as f32) as f64);
	// 82EE06C0: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82EE06C4: 41990034  bgt cr6, 0x82ee06f8
	if ctx.cr[6].gt {
	pc = 0x82EE06F8; continue 'dispatch;
	}
	pc = 0x82EE06C8; continue 'dispatch;
            }
            0x82EE06C8 => {
    //   block [0x82EE06C8..0x82EE06F8)
	// 82EE06C8: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EE06CC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EE06D0: C00101FC  lfs f0, 0x1fc(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(508 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE06D4: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EE06D8: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EE06DC: 93410070  stw r26, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[26].u32 ) };
	// 82EE06E0: D181007C  stfs f12, 0x7c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82EE06E4: 9B010084  stb r24, 0x84(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[24].u8 ) };
	// 82EE06E8: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EE06EC: 4BFFC76D  bl 0x82edce58
	ctx.lr = 0x82EE06F0;
	sub_82EDCE58(ctx, base);
	// 82EE06F0: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 82EE06F4: 48000030  b 0x82ee0724
	pc = 0x82EE0724; continue 'dispatch;
            }
            0x82EE06F8 => {
    //   block [0x82EE06F8..0x82EE0724)
	// 82EE06F8: D0010098  stfs f0, 0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82EE06FC: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82EE0700: C00101FC  lfs f0, 0x1fc(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(508 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE0704: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EE0708: D1A10094  stfs f13, 0x94(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82EE070C: 93410090  stw r26, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[26].u32 ) };
	// 82EE0710: D141009C  stfs f10, 0x9c(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82EE0714: 9B0100A4  stb r24, 0xa4(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[24].u8 ) };
	// 82EE0718: D00100A0  stfs f0, 0xa0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82EE071C: 4BFFC73D  bl 0x82edce58
	ctx.lr = 0x82EE0720;
	sub_82EDCE58(ctx, base);
	// 82EE0720: 93610090  stw r27, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[27].u32 ) };
	pc = 0x82EE0724; continue 'dispatch;
            }
            0x82EE0724 => {
    //   block [0x82EE0724..0x82EE0768)
	// 82EE0724: C01F0074  lfs f0, 0x74(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE0728: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EE072C: C1B90000  lfs f13, 0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE0730: C1990004  lfs f12, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE0734: C1790008  lfs f11, 8(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE0738: EF60D82A  fadds f27, f0, f27
	ctx.f[27].f64 = ((ctx.f[0].f64 + ctx.f[27].f64) as f32) as f64;
	// 82EE073C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE0740: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE0744: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE0748: FF1BA000  fcmpu cr6, f27, f20
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[20].f64);
	// 82EE074C: EF4DD02A  fadds f26, f13, f26
	ctx.f[26].f64 = ((ctx.f[13].f64 + ctx.f[26].f64) as f32) as f64;
	// 82EE0750: D3410050  stfs f26, 0x50(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EE0754: EF2CC82A  fadds f25, f12, f25
	ctx.f[25].f64 = ((ctx.f[12].f64 + ctx.f[25].f64) as f32) as f64;
	// 82EE0758: D3210054  stfs f25, 0x54(r1)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EE075C: EEE0B82A  fadds f23, f0, f23
	ctx.f[23].f64 = ((ctx.f[0].f64 + ctx.f[23].f64) as f32) as f64;
	// 82EE0760: D2E10058  stfs f23, 0x58(r1)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EE0764: 4198FE30  blt cr6, 0x82ee0594
	if ctx.cr[6].lt {
	pc = 0x82EE0594; continue 'dispatch;
	}
	pc = 0x82EE0768; continue 'dispatch;
            }
            0x82EE0768 => {
    //   block [0x82EE0768..0x82EE0778)
	// 82EE0768: 382101C0  addi r1, r1, 0x1c0
	ctx.r[1].s64 = ctx.r[1].s64 + 448;
	// 82EE076C: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 82EE0770: 4BDCD57D  bl 0x82cadcec
	ctx.lr = 0x82EE0774;
	sub_82CADCEC(ctx, base);
	// 82EE0774: 4BDC8CD4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE0778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE0778 size=1472
    let mut pc: u32 = 0x82EE0778;
    'dispatch: loop {
        match pc {
            0x82EE0778 => {
    //   block [0x82EE0778..0x82EE07EC)
	// 82EE0778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE077C: 4BDC8C91  bl 0x82ca940c
	ctx.lr = 0x82EE0780;
	sub_82CA93D0(ctx, base);
	// 82EE0780: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82EE0784: 4BDCD551  bl 0x82cadcd4
	ctx.lr = 0x82EE0788;
	sub_82CADCA0(ctx, base);
	// 82EE0788: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE078C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EE0790: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE0794: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EE0798: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EE079C: 814B8F20  lwz r10, -0x70e0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28896 as u32) ) } as u64;
	// 82EE07A0: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EE07A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EE07A8: 914B8F20  stw r10, -0x70e0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-28896 as u32), ctx.r[10].u32 ) };
	// 82EE07AC: 4BFAB52D  bl 0x82e8bcd8
	ctx.lr = 0x82EE07B0;
	sub_82E8BCD8(ctx, base);
	// 82EE07B0: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EE07B4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EE07B8: 388BC178  addi r4, r11, -0x3e88
	ctx.r[4].s64 = ctx.r[11].s64 + -16008;
	// 82EE07BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EE07C0: 4B307EB9  bl 0x821e8678
	ctx.lr = 0x82EE07C4;
	sub_821E8678(ctx, base);
	// 82EE07C4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EE07C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE07CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE07D0: 3FA08334  lis r29, -0x7ccc
	ctx.r[29].s64 = -2093744128;
	// 82EE07D4: C3EA0C14  lfs f31, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EE07D8: C3AB0BFC  lfs f29, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EE07DC: 41820010  beq 0x82ee07ec
	if ctx.cr[0].eq {
	pc = 0x82EE07EC; continue 'dispatch;
	}
	// 82EE07E0: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE07E4: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EE07E8: 4800001C  b 0x82ee0804
	pc = 0x82EE0804; continue 'dispatch;
            }
            0x82EE07EC => {
    //   block [0x82EE07EC..0x82EE0800)
	// 82EE07EC: 817D0718  lwz r11, 0x718(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EE07F0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE07F4: 4182000C  beq 0x82ee0800
	if ctx.cr[0].eq {
	pc = 0x82EE0800; continue 'dispatch;
	}
	// 82EE07F8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE07FC: 48000008  b 0x82ee0804
	pc = 0x82EE0804; continue 'dispatch;
            }
            0x82EE0800 => {
    //   block [0x82EE0800..0x82EE0804)
	// 82EE0800: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x82EE0804; continue 'dispatch;
            }
            0x82EE0804 => {
    //   block [0x82EE0804..0x82EE0890)
	// 82EE0804: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EE0808: C19F00C4  lfs f12, 0xc4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE080C: ED8C002A  fadds f12, f12, f0
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EE0810: C1BE003C  lfs f13, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE0814: C17E0038  lfs f11, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE0818: C15E0034  lfs f10, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE081C: C11F00AC  lfs f8, 0xac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE0820: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE0824: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE0828: C12B0038  lfs f9, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE082C: EDAB4828  fsubs f13, f11, f9
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EE0830: C13F00B0  lfs f9, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE0834: C16B0034  lfs f11, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE0838: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EE083C: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EE0840: C15F00A8  lfs f10, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE0844: FCE06050  fneg f7, f12
	ctx.f[7].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE0848: D1610050  stfs f11, 0x50(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EE084C: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EE0850: ED290032  fmuls f9, f9, f0
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE0854: EC084B7A  fmadds f0, f8, f13, f9
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[13].f64 + ctx.f[9].f64) as f32) as f64);
	// 82EE0858: EC0A02FA  fmadds f0, f10, f11, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE085C: FF003800  fcmpu cr6, f0, f7
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[7].f64);
	// 82EE0860: 419804C8  blt cr6, 0x82ee0d28
	if ctx.cr[6].lt {
	pc = 0x82EE0D28; continue 'dispatch;
	}
	// 82EE0864: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EE0868: 419904C0  bgt cr6, 0x82ee0d28
	if ctx.cr[6].gt {
	pc = 0x82EE0D28; continue 'dispatch;
	}
	// 82EE086C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EE0870: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EE0874: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82EE0878: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EE087C: 4B307DFD  bl 0x821e8678
	ctx.lr = 0x82EE0880;
	sub_821E8678(ctx, base);
	// 82EE0880: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE0884: 4182000C  beq 0x82ee0890
	if ctx.cr[0].eq {
	pc = 0x82EE0890; continue 'dispatch;
	}
	// 82EE0888: C3C30004  lfs f30, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EE088C: 4800001C  b 0x82ee08a8
	pc = 0x82EE08A8; continue 'dispatch;
            }
            0x82EE0890 => {
    //   block [0x82EE0890..0x82EE08A4)
	// 82EE0890: 817D0718  lwz r11, 0x718(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EE0894: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE0898: 4182000C  beq 0x82ee08a4
	if ctx.cr[0].eq {
	pc = 0x82EE08A4; continue 'dispatch;
	}
	// 82EE089C: C3CB000C  lfs f30, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EE08A0: 48000008  b 0x82ee08a8
	pc = 0x82EE08A8; continue 'dispatch;
            }
            0x82EE08A4 => {
    //   block [0x82EE08A4..0x82EE08A8)
	// 82EE08A4: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	pc = 0x82EE08A8; continue 'dispatch;
            }
            0x82EE08A8 => {
    //   block [0x82EE08A8..0x82EE08EC)
	// 82EE08A8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EE08AC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EE08B0: 388BDA4C  addi r4, r11, -0x25b4
	ctx.r[4].s64 = ctx.r[11].s64 + -9652;
	// 82EE08B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EE08B8: 4B307DC1  bl 0x821e8678
	ctx.lr = 0x82EE08BC;
	sub_821E8678(ctx, base);
	// 82EE08BC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE08C0: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82EE08C4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EE08C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EE08CC: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82EE08D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE08D4: 41820018  beq 0x82ee08ec
	if ctx.cr[0].eq {
	pc = 0x82EE08EC; continue 'dispatch;
	}
	// 82EE08D8: C05D0004  lfs f2, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EE08DC: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EE08E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE08E4: 4E800421  bctrl
	ctx.lr = 0x82EE08E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE08E8: 48000010  b 0x82ee08f8
	pc = 0x82EE08F8; continue 'dispatch;
            }
            0x82EE08EC => {
    //   block [0x82EE08EC..0x82EE08F8)
	// 82EE08EC: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EE08F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE08F4: 4E800421  bctrl
	ctx.lr = 0x82EE08F8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EE08F8 => {
    //   block [0x82EE08F8..0x82EE0970)
	// 82EE08F8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE08FC: C19F00B4  lfs f12, 0xb4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE0900: C15F00BC  lfs f10, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE0904: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EE0908: C1BE0058  lfs f13, 0x58(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE090C: C13E004C  lfs f9, 0x4c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE0910: C11E0054  lfs f8, 0x54(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE0914: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE0918: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE091C: C0FF00BC  lfs f7, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EE0920: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE0924: C1610058  lfs f11, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE0928: FCC03890  fmr f6, f7
	ctx.f[6].f64 = ctx.f[7].f64;
	// 82EE092C: ED8D6278  fmsubs f12, f13, f9, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE0930: C13F00B4  lfs f9, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE0934: EDAD5238  fmsubs f13, f13, f8, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[8].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EE0938: C1410050  lfs f10, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE093C: FD004890  fmr f8, f9
	ctx.f[8].f64 = ctx.f[9].f64;
	// 82EE0940: ED2902B2  fmuls f9, f9, f10
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EE0944: ED880332  fmuls f12, f8, f12
	ctx.f[12].f64 = (((ctx.f[8].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE0948: EFE74AFA  fmadds f31, f7, f11, f9
	ctx.f[31].f64 = (((ctx.f[7].f64 * ctx.f[11].f64 + ctx.f[9].f64) as f32) as f64);
	// 82EE094C: EF66637A  fmadds f27, f6, f13, f12
	ctx.f[27].f64 = (((ctx.f[6].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 82EE0950: 409A0124  bne cr6, 0x82ee0a74
	if !ctx.cr[6].eq {
	pc = 0x82EE0A74; continue 'dispatch;
	}
	// 82EE0954: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE0958: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE095C: FF1F6000  fcmpu cr6, f31, f12
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[12].f64);
	// 82EE0960: 41980094  blt cr6, 0x82ee09f4
	if ctx.cr[6].lt {
	pc = 0x82EE09F4; continue 'dispatch;
	}
	// 82EE0964: EDBE0772  fmuls f13, f30, f29
	ctx.f[13].f64 = (((ctx.f[30].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EE0968: FF1F6800  fcmpu cr6, f31, f13
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[13].f64);
	// 82EE096C: 4098000C  bge cr6, 0x82ee0978
	if !ctx.cr[6].lt {
	pc = 0x82EE0978; continue 'dispatch;
	}
	pc = 0x82EE0970; continue 'dispatch;
            }
            0x82EE0970 => {
    //   block [0x82EE0970..0x82EE0978)
	// 82EE0970: FC406090  fmr f2, f12
	ctx.f[2].f64 = ctx.f[12].f64;
	// 82EE0974: 480000C0  b 0x82ee0a34
	pc = 0x82EE0A34; continue 'dispatch;
            }
            0x82EE0978 => {
    //   block [0x82EE0978..0x82EE09F4)
	// 82EE0978: FDA00050  fneg f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE097C: FF1B6800  fcmpu cr6, f27, f13
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[13].f64);
	// 82EE0980: 40990074  ble cr6, 0x82ee09f4
	if !ctx.cr[6].gt {
	pc = 0x82EE09F4; continue 'dispatch;
	}
	// 82EE0984: C1BF0014  lfs f13, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE0988: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE098C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE0990: C13F0078  lfs f9, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE0994: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE0998: EC0D483A  fmadds f0, f13, f0, f9
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[9].f64) as f32) as f64);
	// 82EE099C: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82EE09A0: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82EE09A4: 41990050  bgt cr6, 0x82ee09f4
	if ctx.cr[6].gt {
	pc = 0x82EE09F4; continue 'dispatch;
	}
	// 82EE09A8: C01F0074  lfs f0, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE09AC: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82EE09B0: C1BF0020  lfs f13, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE09B4: EC006F7A  fmadds f0, f0, f29, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE09B8: C1BF009C  lfs f13, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE09BC: EDAD02B2  fmuls f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EE09C0: C15F00A4  lfs f10, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE09C4: EDAA6AFA  fmadds f13, f10, f11, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE09C8: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE09CC: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82EE09D0: 41980024  blt cr6, 0x82ee09f4
	if ctx.cr[6].lt {
	pc = 0x82EE09F4; continue 'dispatch;
	}
	// 82EE09D4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE09D8: 4199001C  bgt cr6, 0x82ee09f4
	if ctx.cr[6].gt {
	pc = 0x82EE09F4; continue 'dispatch;
	}
	// 82EE09DC: C01F0104  lfs f0, 0x104(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE09E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE09E4: EC4007F2  fmuls f2, f0, f31
	ctx.f[2].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EE09E8: C00B0BEC  lfs f0, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE09EC: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82EE09F0: 409A003C  bne cr6, 0x82ee0a2c
	if !ctx.cr[6].eq {
	pc = 0x82EE0A2C; continue 'dispatch;
	}
	pc = 0x82EE09F4; continue 'dispatch;
            }
            0x82EE09F4 => {
    //   block [0x82EE09F4..0x82EE0A2C)
	// 82EE09F4: C01F0078  lfs f0, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE09F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE09FC: EDA0F02A  fadds f13, f0, f30
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82EE0A00: C00B0C8C  lfs f0, 0xc8c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE0A04: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE0A08: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82EE0A0C: 4198031C  blt cr6, 0x82ee0d28
	if ctx.cr[6].lt {
	pc = 0x82EE0D28; continue 'dispatch;
	}
	// 82EE0A10: EC1E0772  fmuls f0, f30, f29
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EE0A14: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82EE0A18: 4198FF58  blt cr6, 0x82ee0970
	if ctx.cr[6].lt {
	pc = 0x82EE0970; continue 'dispatch;
	}
	// 82EE0A1C: FF1B6000  fcmpu cr6, f27, f12
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[12].f64);
	// 82EE0A20: 40980308  bge cr6, 0x82ee0d28
	if !ctx.cr[6].lt {
	pc = 0x82EE0D28; continue 'dispatch;
	}
	// 82EE0A24: EC1FD824  fdivs f0, f31, f27
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[27].f64) as f32) as f64;
	// 82EE0A28: FC400050  fneg f2, f0
	ctx.f[2].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x82EE0A2C; continue 'dispatch;
            }
            0x82EE0A2C => {
    //   block [0x82EE0A2C..0x82EE0A34)
	// 82EE0A2C: FF026000  fcmpu cr6, f2, f12
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[12].f64);
	// 82EE0A30: 419802F8  blt cr6, 0x82ee0d28
	if ctx.cr[6].lt {
	pc = 0x82EE0D28; continue 'dispatch;
	}
	pc = 0x82EE0A34; continue 'dispatch;
            }
            0x82EE0A34 => {
    //   block [0x82EE0A34..0x82EE0A54)
	// 82EE0A34: C01F00C0  lfs f0, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE0A38: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82EE0A3C: 40990018  ble cr6, 0x82ee0a54
	if !ctx.cr[6].gt {
	pc = 0x82EE0A54; continue 'dispatch;
	}
	// 82EE0A40: C1BF0104  lfs f13, 0x104(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE0A44: EDAD07B2  fmuls f13, f13, f30
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EE0A48: EC0D077A  fmadds f0, f13, f29, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[29].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE0A4C: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82EE0A50: 419902D8  bgt cr6, 0x82ee0d28
	if ctx.cr[6].gt {
	pc = 0x82EE0D28; continue 'dispatch;
	}
	pc = 0x82EE0A54; continue 'dispatch;
            }
            0x82EE0A54 => {
    //   block [0x82EE0A54..0x82EE0A74)
	// 82EE0A54: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE0A58: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82EE0A5C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EE0A60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE0A64: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EE0A68: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE0A6C: 4E800421  bctrl
	ctx.lr = 0x82EE0A70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE0A70: 480002B8  b 0x82ee0d28
	pc = 0x82EE0D28; continue 'dispatch;
            }
            0x82EE0A74 => {
    //   block [0x82EE0A74..0x82EE0AA0)
	// 82EE0A74: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EE0A78: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EE0A7C: 388BD2C0  addi r4, r11, -0x2d40
	ctx.r[4].s64 = ctx.r[11].s64 + -11584;
	// 82EE0A80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EE0A84: 4B307BF5  bl 0x821e8678
	ctx.lr = 0x82EE0A88;
	sub_821E8678(ctx, base);
	// 82EE0A88: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE0A8C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE0A90: C38B0C18  lfs f28, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EE0A94: 4182000C  beq 0x82ee0aa0
	if ctx.cr[0].eq {
	pc = 0x82EE0AA0; continue 'dispatch;
	}
	// 82EE0A98: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 82EE0A9C: 48000024  b 0x82ee0ac0
	pc = 0x82EE0AC0; continue 'dispatch;
            }
            0x82EE0AA0 => {
    //   block [0x82EE0AA0..0x82EE0AC0)
	// 82EE0AA0: C01E004C  lfs f0, 0x4c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE0AA4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EE0AA8: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EE0AAC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82EE0AB0: C01E0054  lfs f0, 0x54(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE0AB4: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EE0AB8: D3810064  stfs f28, 0x64(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EE0ABC: 4B39E7AD  bl 0x8227f268
	ctx.lr = 0x82EE0AC0;
	sub_8227F268(ctx, base);
	pc = 0x82EE0AC0; continue 'dispatch;
            }
            0x82EE0AC0 => {
    //   block [0x82EE0AC0..0x82EE0BB0)
	// 82EE0AC0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EE0AC4: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE0AC8: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82EE0ACC: 396BDBFC  addi r11, r11, -0x2404
	ctx.r[11].s64 = ctx.r[11].s64 + -9220;
	// 82EE0AD0: C1830004  lfs f12, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE0AD4: D1810074  stfs f12, 0x74(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EE0AD8: C1A30008  lfs f13, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE0ADC: C0E10050  lfs f7, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EE0AE0: ECA001F2  fmuls f5, f0, f7
	ctx.f[5].f64 = (((ctx.f[0].f64 * ctx.f[7].f64) as f32) as f64);
	// 82EE0AE4: C1010058  lfs f8, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE0AE8: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE0AEC: ECCD02F2  fmuls f6, f13, f11
	ctx.f[6].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE0AF0: C12B0000  lfs f9, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE0AF4: ED2C0272  fmuls f9, f12, f9
	ctx.f[9].f64 = (((ctx.f[12].f64 * ctx.f[9].f64) as f32) as f64);
	// 82EE0AF8: C14B0008  lfs f10, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE0AFC: C09F00BC  lfs f4, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82EE0B00: 897F007C  lbz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EE0B04: FC602090  fmr f3, f4
	ctx.f[3].f64 = ctx.f[4].f64;
	// 82EE0B08: D1A10078  stfs f13, 0x78(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EE0B0C: C05D0004  lfs f2, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EE0B10: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE0B14: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE0B18: ED8C32B8  fmsubs f12, f12, f10, f6
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[10].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EE0B1C: C0CB0BEC  lfs f6, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EE0B20: ED604AF8  fmsubs f11, f0, f11, f9
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[11].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EE0B24: C13F00B4  lfs f9, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE0B28: ED4D2A3A  fmadds f10, f13, f8, f5
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[8].f64 + ctx.f[5].f64) as f32) as f64);
	// 82EE0B2C: FCA04890  fmr f5, f9
	ctx.f[5].f64 = ctx.f[9].f64;
	// 82EE0B30: ED290332  fmuls f9, f9, f12
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE0B34: ECA00172  fmuls f5, f0, f5
	ctx.f[5].f64 = (((ctx.f[0].f64 * ctx.f[5].f64) as f32) as f64);
	// 82EE0B38: ED244AFA  fmadds f9, f4, f11, f9
	ctx.f[9].f64 = (((ctx.f[4].f64 * ctx.f[11].f64 + ctx.f[9].f64) as f32) as f64);
	// 82EE0B3C: C09F009C  lfs f4, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82EE0B40: EC040032  fmuls f0, f4, f0
	ctx.f[0].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE0B44: EC8C0132  fmuls f4, f12, f4
	ctx.f[4].f64 = (((ctx.f[12].f64 * ctx.f[4].f64) as f32) as f64);
	// 82EE0B48: ECA32B7A  fmadds f5, f3, f13, f5
	ctx.f[5].f64 = (((ctx.f[3].f64 * ctx.f[13].f64 + ctx.f[5].f64) as f32) as f64);
	// 82EE0B4C: C07F00A4  lfs f3, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82EE0B50: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 82EE0B54: FD204A10  fabs f9, f9
	ctx.f[9].u64 = ctx.f[9].u64 & !0x8000_0000_0000_0000u64;
	// 82EE0B58: EC03037A  fmadds f0, f3, f13, f0
	ctx.f[0].f64 = (((ctx.f[3].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE0B5C: FCA02A10  fabs f5, f5
	ctx.f[5].u64 = ctx.f[5].u64 & !0x8000_0000_0000_0000u64;
	// 82EE0B60: EDA122FA  fmadds f13, f1, f11, f4
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[11].f64 + ctx.f[4].f64) as f32) as f64);
	// 82EE0B64: ED2907B2  fmuls f9, f9, f30
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EE0B68: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82EE0B6C: FDA06A10  fabs f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 82EE0B70: ECA548BA  fmadds f5, f5, f2, f9
	ctx.f[5].f64 = (((ctx.f[5].f64 * ctx.f[2].f64 + ctx.f[9].f64) as f32) as f64);
	// 82EE0B74: EC0000B2  fmuls f0, f0, f2
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[2].f64) as f32) as f64);
	// 82EE0B78: EC8D07BA  fmadds f4, f13, f30, f0
	ctx.f[4].f64 = (((ctx.f[13].f64 * ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE0B7C: 4182003C  beq 0x82ee0bb8
	if ctx.cr[0].eq {
	pc = 0x82EE0BB8; continue 'dispatch;
	}
	// 82EE0B80: C01F0078  lfs f0, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE0B84: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE0B88: EC00282A  fadds f0, f0, f5
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[5].f64) as f32) as f64;
	// 82EE0B8C: C1AB0C8C  lfs f13, 0xc8c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE0B90: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE0B94: FF1F6800  fcmpu cr6, f31, f13
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[13].f64);
	// 82EE0B98: 41980190  blt cr6, 0x82ee0d28
	if ctx.cr[6].lt {
	pc = 0x82EE0D28; continue 'dispatch;
	}
	// 82EE0B9C: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EE0BA0: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82EE0BA4: 4098005C  bge cr6, 0x82ee0c00
	if !ctx.cr[6].lt {
	pc = 0x82EE0C00; continue 'dispatch;
	}
	// 82EE0BA8: FF1FE000  fcmpu cr6, f31, f28
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[28].f64);
	// 82EE0BAC: 4198017C  blt cr6, 0x82ee0d28
	if ctx.cr[6].lt {
	pc = 0x82EE0D28; continue 'dispatch;
	}
	pc = 0x82EE0BB0; continue 'dispatch;
            }
            0x82EE0BB0 => {
    //   block [0x82EE0BB0..0x82EE0BB8)
	// 82EE0BB0: FCC0E090  fmr f6, f28
	ctx.f[6].f64 = ctx.f[28].f64;
	// 82EE0BB4: 480000CC  b 0x82ee0c80
	pc = 0x82EE0C80; continue 'dispatch;
            }
            0x82EE0BB8 => {
    //   block [0x82EE0BB8..0x82EE0C00)
	// 82EE0BB8: C01F0074  lfs f0, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE0BBC: ED20102A  fadds f9, f0, f2
	ctx.f[9].f64 = ((ctx.f[0].f64 + ctx.f[2].f64) as f32) as f64;
	// 82EE0BC0: C1BF0020  lfs f13, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE0BC4: ED296F7A  fmadds f9, f9, f29, f13
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[29].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE0BC8: FC604850  fneg f3, f9
	ctx.f[3].u64 = ctx.f[9].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE0BCC: FF0A1800  fcmpu cr6, f10, f3
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[3].f64);
	// 82EE0BD0: 41980030  blt cr6, 0x82ee0c00
	if ctx.cr[6].lt {
	pc = 0x82EE0C00; continue 'dispatch;
	}
	// 82EE0BD4: FF0A4800  fcmpu cr6, f10, f9
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[9].f64);
	// 82EE0BD8: 41990028  bgt cr6, 0x82ee0c00
	if ctx.cr[6].gt {
	pc = 0x82EE0C00; continue 'dispatch;
	}
	// 82EE0BDC: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82EE0BE0: ED8C01F2  fmuls f12, f12, f7
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[7].f64) as f32) as f64);
	// 82EE0BE4: EC006F7A  fmadds f0, f0, f29, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE0BE8: EDAB623A  fmadds f13, f11, f8, f12
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[8].f64 + ctx.f[12].f64) as f32) as f64);
	// 82EE0BEC: FD800050  fneg f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE0BF0: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EE0BF4: 4198000C  blt cr6, 0x82ee0c00
	if ctx.cr[6].lt {
	pc = 0x82EE0C00; continue 'dispatch;
	}
	// 82EE0BF8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE0BFC: 4099FFB4  ble cr6, 0x82ee0bb0
	if !ctx.cr[6].gt {
	pc = 0x82EE0BB0; continue 'dispatch;
	}
	pc = 0x82EE0C00; continue 'dispatch;
            }
            0x82EE0C00 => {
    //   block [0x82EE0C00..0x82EE0C68)
	// 82EE0C00: EC050772  fmuls f0, f5, f29
	ctx.f[0].f64 = (((ctx.f[5].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EE0C04: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82EE0C08: 4198FFA8  blt cr6, 0x82ee0bb0
	if ctx.cr[6].lt {
	pc = 0x82EE0BB0; continue 'dispatch;
	}
	// 82EE0C0C: C01F0078  lfs f0, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE0C10: FF1BE000  fcmpu cr6, f27, f28
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[28].f64);
	// 82EE0C14: 41980054  blt cr6, 0x82ee0c68
	if ctx.cr[6].lt {
	pc = 0x82EE0C68; continue 'dispatch;
	}
	// 82EE0C18: EDA5002A  fadds f13, f5, f0
	ctx.f[13].f64 = ((ctx.f[5].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EE0C1C: EC0D077A  fmadds f0, f13, f29, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[29].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE0C20: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82EE0C24: 4098005C  bge cr6, 0x82ee0c80
	if !ctx.cr[6].lt {
	pc = 0x82EE0C80; continue 'dispatch;
	}
	// 82EE0C28: C1BF009C  lfs f13, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE0C2C: EDAD01F2  fmuls f13, f13, f7
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[7].f64) as f32) as f64);
	// 82EE0C30: C01F0074  lfs f0, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE0C34: C19F00A4  lfs f12, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE0C38: EC00202A  fadds f0, f0, f4
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[4].f64) as f32) as f64;
	// 82EE0C3C: EDAC6A3A  fmadds f13, f12, f8, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE0C40: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EE0C44: FDA06A10  fabs f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 82EE0C48: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE0C4C: 40980034  bge cr6, 0x82ee0c80
	if !ctx.cr[6].lt {
	pc = 0x82EE0C80; continue 'dispatch;
	}
	// 82EE0C50: C01F0078  lfs f0, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE0C54: EC00282A  fadds f0, f0, f5
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[5].f64) as f32) as f64;
	// 82EE0C58: C1BF0104  lfs f13, 0x104(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE0C5C: EC00FF7C  fnmsubs f0, f0, f29, f31
	ctx.f[0].f64 = -(((ctx.f[0].f64 * ctx.f[29].f64 - ctx.f[31].f64) as f32) as f64);
	// 82EE0C60: ECC00372  fmuls f6, f0, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE0C64: 48000014  b 0x82ee0c78
	pc = 0x82EE0C78; continue 'dispatch;
            }
            0x82EE0C68 => {
    //   block [0x82EE0C68..0x82EE0C78)
	// 82EE0C68: EC00282A  fadds f0, f0, f5
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[5].f64) as f32) as f64;
	// 82EE0C6C: EC00FF7C  fnmsubs f0, f0, f29, f31
	ctx.f[0].f64 = -(((ctx.f[0].f64 * ctx.f[29].f64 - ctx.f[31].f64) as f32) as f64);
	// 82EE0C70: EC00D824  fdivs f0, f0, f27
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[27].f64) as f32) as f64;
	// 82EE0C74: FCC00050  fneg f6, f0
	ctx.f[6].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x82EE0C78; continue 'dispatch;
            }
            0x82EE0C78 => {
    //   block [0x82EE0C78..0x82EE0C80)
	// 82EE0C78: FF06E000  fcmpu cr6, f6, f28
	ctx.cr[6].compare_f64(ctx.f[6].f64, ctx.f[28].f64);
	// 82EE0C7C: 419800AC  blt cr6, 0x82ee0d28
	if ctx.cr[6].lt {
	pc = 0x82EE0D28; continue 'dispatch;
	}
	pc = 0x82EE0C80; continue 'dispatch;
            }
            0x82EE0C80 => {
    //   block [0x82EE0C80..0x82EE0CC8)
	// 82EE0C80: C01F0104  lfs f0, 0x104(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE0C84: C1BF00C0  lfs f13, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE0C88: EC00697A  fmadds f0, f0, f5, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[5].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE0C8C: FF060000  fcmpu cr6, f6, f0
	ctx.cr[6].compare_f64(ctx.f[6].f64, ctx.f[0].f64);
	// 82EE0C90: 41990098  bgt cr6, 0x82ee0d28
	if ctx.cr[6].gt {
	pc = 0x82EE0D28; continue 'dispatch;
	}
	// 82EE0C94: C17E004C  lfs f11, 0x4c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE0C98: C19F00B4  lfs f12, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE0C9C: ED8B0332  fmuls f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE0CA0: C1BF0108  lfs f13, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE0CA4: C17E0054  lfs f11, 0x54(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE0CA8: EDA66828  fsubs f13, f6, f13
	ctx.f[13].f64 = (((ctx.f[6].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE0CAC: C15F00BC  lfs f10, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE0CB0: C01E0058  lfs f0, 0x58(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE0CB4: ED8B62BA  fmadds f12, f11, f10, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64);
	// 82EE0CB8: FF0DE000  fcmpu cr6, f13, f28
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[28].f64);
	// 82EE0CBC: EC6C0032  fmuls f3, f12, f0
	ctx.f[3].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE0CC0: 40980008  bge cr6, 0x82ee0cc8
	if !ctx.cr[6].lt {
	pc = 0x82EE0CC8; continue 'dispatch;
	}
	// 82EE0CC4: FDA0E090  fmr f13, f28
	ctx.f[13].f64 = ctx.f[28].f64;
	pc = 0x82EE0CC8; continue 'dispatch;
            }
            0x82EE0CC8 => {
    //   block [0x82EE0CC8..0x82EE0D28)
	// 82EE0CC8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE0CCC: C1BE004C  lfs f13, 0x4c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE0CD0: C19E0050  lfs f12, 0x50(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE0CD4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE0CD8: C17E0054  lfs f11, 0x54(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE0CDC: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82EE0CE0: C15E0038  lfs f10, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE0CE4: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82EE0CE8: C13E003C  lfs f9, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE0CEC: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82EE0CF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE0CF4: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EE0CF8: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE0CFC: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE0D00: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE0D04: C17E0034  lfs f11, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE0D08: EDAD582A  fadds f13, f13, f11
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EE0D0C: D1A10080  stfs f13, 0x80(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EE0D10: EDAA602A  fadds f13, f10, f12
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EE0D14: D1A10084  stfs f13, 0x84(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EE0D18: EC09002A  fadds f0, f9, f0
	ctx.f[0].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EE0D1C: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EE0D20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE0D24: 4E800421  bctrl
	ctx.lr = 0x82EE0D28;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EE0D28 => {
    //   block [0x82EE0D28..0x82EE0D38)
	// 82EE0D28: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82EE0D2C: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82EE0D30: 4BDCCFF1  bl 0x82cadd20
	ctx.lr = 0x82EE0D34;
	sub_82CADCEC(ctx, base);
	// 82EE0D34: 4BDC8728  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE0D38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE0D38 size=376
    let mut pc: u32 = 0x82EE0D38;
    'dispatch: loop {
        match pc {
            0x82EE0D38 => {
    //   block [0x82EE0D38..0x82EE0E10)
	// 82EE0D38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE0D3C: 4BDC86C1  bl 0x82ca93fc
	ctx.lr = 0x82EE0D40;
	sub_82CA93D0(ctx, base);
	// 82EE0D40: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE0D44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EE0D48: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EE0D4C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EE0D50: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82EE0D54: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82EE0D58: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE0D5C: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 82EE0D60: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EE0D64: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE0D68: 4E800421  bctrl
	ctx.lr = 0x82EE0D6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE0D6C: 835E0118  lwz r26, 0x118(r30)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(280 as u32) ) } as u64;
	// 82EE0D70: 281A0000  cmplwi r26, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE0D74: 418200CC  beq 0x82ee0e40
	if ctx.cr[0].eq {
	pc = 0x82EE0E40; continue 'dispatch;
	}
	// 82EE0D78: 817A0014  lwz r11, 0x14(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE0D7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE0D80: 419A00C0  beq cr6, 0x82ee0e40
	if ctx.cr[6].eq {
	pc = 0x82EE0E40; continue 'dispatch;
	}
	// 82EE0D84: C01E0074  lfs f0, 0x74(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE0D88: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE0D8C: ED800032  fmuls f12, f0, f0
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE0D90: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE0D94: C17D0008  lfs f11, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE0D98: C15D000C  lfs f10, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE0D9C: C00B0BE8  lfs f0, 0xbe8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3048 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE0DA0: ED2C0032  fmuls f9, f12, f0
	ctx.f[9].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE0DA4: C01F0034  lfs f0, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE0DA8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE0DAC: C19F0038  lfs f12, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE0DB0: EDAC5828  fsubs f13, f12, f11
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EE0DB4: C19F003C  lfs f12, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE0DB8: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EE0DBC: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE0DC0: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE0DC4: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE0DC8: FF004800  fcmpu cr6, f0, f9
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[9].f64);
	// 82EE0DCC: 41990074  bgt cr6, 0x82ee0e40
	if ctx.cr[6].gt {
	pc = 0x82EE0E40; continue 'dispatch;
	}
	// 82EE0DD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE0DD4: C1BF0034  lfs f13, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE0DD8: C01B0004  lfs f0, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE0DDC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EE0DE0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE0DE4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EE0DE8: C19B000C  lfs f12, 0xc(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE0DEC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EE0DF0: C17F003C  lfs f11, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE0DF4: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE0DF8: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EE0DFC: EC0C5828  fsubs f0, f12, f11
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EE0E00: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EE0E04: 4B39E465  bl 0x8227f268
	ctx.lr = 0x82EE0E08;
	sub_8227F268(ctx, base);
	// 82EE0E08: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE0E0C: 4800002C  b 0x82ee0e38
	pc = 0x82EE0E38; continue 'dispatch;
            }
            0x82EE0E10 => {
    //   block [0x82EE0E10..0x82EE0E38)
	// 82EE0E10: C1810060  lfs f12, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE0E14: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE0E18: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE0E1C: C1610068  lfs f11, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE0E20: C18B0010  lfs f12, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE0E24: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE0E28: EDAC6AFA  fmadds f13, f12, f11, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE0E2C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE0E30: 4199003C  bgt cr6, 0x82ee0e6c
	if ctx.cr[6].gt {
	pc = 0x82EE0E6C; continue 'dispatch;
	}
	// 82EE0E34: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	pc = 0x82EE0E38; continue 'dispatch;
            }
            0x82EE0E38 => {
    //   block [0x82EE0E38..0x82EE0E40)
	// 82EE0E38: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE0E3C: 4082FFD4  bne 0x82ee0e10
	if !ctx.cr[0].eq {
	pc = 0x82EE0E10; continue 'dispatch;
	}
	pc = 0x82EE0E40; continue 'dispatch;
            }
            0x82EE0E40 => {
    //   block [0x82EE0E40..0x82EE0E64)
	// 82EE0E40: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE0E44: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EE0E48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EE0E4C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EE0E50: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82EE0E54: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 82EE0E58: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE0E5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE0E60: 4E800421  bctrl
	ctx.lr = 0x82EE0E64;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EE0E64 => {
    //   block [0x82EE0E64..0x82EE0E6C)
	// 82EE0E64: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EE0E68: 4BDC85E4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82EE0E6C => {
    //   block [0x82EE0E6C..0x82EE0EB0)
	// 82EE0E6C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE0E70: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 82EE0E74: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82EE0E78: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82EE0E7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EE0E80: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82EE0E84: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE0E88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE0E8C: 4E800421  bctrl
	ctx.lr = 0x82EE0E90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE0E90: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE0E94: 4182FFD0  beq 0x82ee0e64
	if ctx.cr[0].eq {
	pc = 0x82EE0E64; continue 'dispatch;
	}
	// 82EE0E98: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82EE0E9C: C1B90000  lfs f13, 0(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE0EA0: C00B9404  lfs f0, -0x6bfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE0EA4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE0EA8: D0190000  stfs f0, 0(r25)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EE0EAC: 4BFFFFB8  b 0x82ee0e64
	pc = 0x82EE0E64; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE0EB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE0EB0 size=752
    let mut pc: u32 = 0x82EE0EB0;
    'dispatch: loop {
        match pc {
            0x82EE0EB0 => {
    //   block [0x82EE0EB0..0x82EE0F80)
	// 82EE0EB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE0EB4: 4BDC8555  bl 0x82ca9408
	ctx.lr = 0x82EE0EB8;
	sub_82CA93D0(ctx, base);
	// 82EE0EB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE0EBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE0EC0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EE0EC4: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE0EC8: 9BDF00F9  stb r30, 0xf9(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(249 as u32), ctx.r[30].u8 ) };
	// 82EE0ECC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE0ED0: 409A02C8  bne cr6, 0x82ee1198
	if !ctx.cr[6].eq {
	pc = 0x82EE1198; continue 'dispatch;
	}
	// 82EE0ED4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EE0ED8: C01F0074  lfs f0, 0x74(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE0EDC: 397F008C  addi r11, r31, 0x8c
	ctx.r[11].s64 = ctx.r[31].s64 + 140;
	// 82EE0EE0: 3B9F005C  addi r28, r31, 0x5c
	ctx.r[28].s64 = ctx.r[31].s64 + 92;
	// 82EE0EE4: C1AA0BFC  lfs f13, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE0EE8: ED400372  fmuls f10, f0, f13
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE0EEC: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE0EF0: C19C0000  lfs f12, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE0EF4: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE0EF8: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE0EFC: C19C0004  lfs f12, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE0F00: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE0F04: C13C0008  lfs f9, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE0F08: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE0F0C: ED6B4828  fsubs f11, f11, f9
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EE0F10: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE0F14: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE0F18: EDAB6AFA  fmadds f13, f11, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE0F1C: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 82EE0F20: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 82EE0F24: 4098005C  bge cr6, 0x82ee0f80
	if !ctx.cr[6].lt {
	pc = 0x82EE0F80; continue 'dispatch;
	}
	// 82EE0F28: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EE0F2C: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE0F30: C1BC0000  lfs f13, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE0F34: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE0F38: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE0F3C: C19C0004  lfs f12, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE0F40: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE0F44: C14B0008  lfs f10, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE0F48: FD604890  fmr f11, f9
	ctx.f[11].f64 = ctx.f[9].f64;
	// 82EE0F4C: C10B0008  lfs f8, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE0F50: C12B0004  lfs f9, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE0F54: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE0F58: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE0F5C: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EE0F60: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE0F64: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE0F68: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EE0F6C: EDA9602A  fadds f13, f9, f12
	ctx.f[13].f64 = ((ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EE0F70: D1AB0004  stfs f13, 4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EE0F74: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE0F78: EC08002A  fadds f0, f8, f0
	ctx.f[0].f64 = ((ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EE0F7C: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x82EE0F80; continue 'dispatch;
            }
            0x82EE0F80 => {
    //   block [0x82EE0F80..0x82EE0F9C)
	// 82EE0F80: 4B37FA39  bl 0x822609b8
	ctx.lr = 0x82EE0F84;
	sub_822609B8(ctx, base);
	// 82EE0F84: 897F00F8  lbz r11, 0xf8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 82EE0F88: C1A3004C  lfs f13, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE0F8C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE0F90: 4182000C  beq 0x82ee0f9c
	if ctx.cr[0].eq {
	pc = 0x82EE0F9C; continue 'dispatch;
	}
	// 82EE0F94: 9BDF00F8  stb r30, 0xf8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[30].u8 ) };
	// 82EE0F98: 48000010  b 0x82ee0fa8
	pc = 0x82EE0FA8; continue 'dispatch;
            }
            0x82EE0F9C => {
    //   block [0x82EE0F9C..0x82EE0FA8)
	// 82EE0F9C: C01F00CC  lfs f0, 0xcc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE0FA0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE0FA4: 419801F4  blt cr6, 0x82ee1198
	if ctx.cr[6].lt {
	pc = 0x82EE1198; continue 'dispatch;
	}
	pc = 0x82EE0FA8; continue 'dispatch;
            }
            0x82EE0FA8 => {
    //   block [0x82EE0FA8..0x82EE0FD4)
	// 82EE0FA8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE0FAC: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE0FB0: C17F00CC  lfs f11, 0xcc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE0FB4: C18B0A98  lfs f12, 0xa98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2712 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE0FB8: ED805B3A  fmadds f12, f0, f12, f11
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EE0FBC: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EE0FC0: 40980014  bge cr6, 0x82ee0fd4
	if !ctx.cr[6].lt {
	pc = 0x82EE0FD4; continue 'dispatch;
	}
	// 82EE0FC4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE0FC8: 896B0410  lbz r11, 0x410(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1040 as u32) ) } as u64;
	// 82EE0FCC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE0FD0: 418201C8  beq 0x82ee1198
	if ctx.cr[0].eq {
	pc = 0x82EE1198; continue 'dispatch;
	}
	pc = 0x82EE0FD4; continue 'dispatch;
            }
            0x82EE0FD4 => {
    //   block [0x82EE0FD4..0x82EE101C)
	// 82EE0FD4: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE0FD8: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EE0FDC: D01F00CC  stfs f0, 0xcc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EE0FE0: D01F00D0  stfs f0, 0xd0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82EE0FE4: 4B2E3305  bl 0x821c42e8
	ctx.lr = 0x82EE0FE8;
	sub_821C42E8(ctx, base);
	// 82EE0FE8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EE0FEC: 906BE1F8  stw r3, -0x1e08(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-7688 as u32), ctx.r[3].u32 ) };
	// 82EE0FF0: C01F0104  lfs f0, 0x104(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE0FF4: C1BF0018  lfs f13, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE0FF8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EE0FFC: C19F00C8  lfs f12, 0xc8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE1000: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE1004: C17F0108  lfs f11, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE1008: EC0C583A  fmadds f0, f12, f0, f11
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EE100C: 997F00F9  stb r11, 0xf9(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(249 as u32), ctx.r[11].u8 ) };
	// 82EE1010: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE1014: 41980008  blt cr6, 0x82ee101c
	if ctx.cr[6].lt {
	pc = 0x82EE101C; continue 'dispatch;
	}
	// 82EE1018: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EE101C; continue 'dispatch;
            }
            0x82EE101C => {
    //   block [0x82EE101C..0x82EE103C)
	// 82EE101C: C05F0048  lfs f2, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EE1020: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EE1024: D01F00C0  stfs f0, 0xc0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82EE1028: FC600090  fmr f3, f0
	ctx.f[3].f64 = ctx.f[0].f64;
	// 82EE102C: FC201050  fneg f1, f2
	ctx.f[1].u64 = ctx.f[2].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE1030: 4BFFBD39  bl 0x82edcd68
	ctx.lr = 0x82EE1034;
	sub_82EDCD68(ctx, base);
	// 82EE1034: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82EE1038: 48000028  b 0x82ee1060
	pc = 0x82EE1060; continue 'dispatch;
            }
            0x82EE103C => {
    //   block [0x82EE103C..0x82EE1060)
	// 82EE103C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE1040: 9BCA0020  stb r30, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82EE1044: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE1048: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EE104C: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE1050: 910A001C  stw r8, 0x1c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[8].u32 ) };
	// 82EE1054: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE1058: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82EE105C: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	pc = 0x82EE1060; continue 'dispatch;
            }
            0x82EE1060 => {
    //   block [0x82EE1060..0x82EE1090)
	// 82EE1060: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE1064: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EE1068: 409AFFD4  bne cr6, 0x82ee103c
	if !ctx.cr[6].eq {
	pc = 0x82EE103C; continue 'dispatch;
	}
	// 82EE106C: 93CB000C  stw r30, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82EE1070: 93CB0014  stw r30, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82EE1074: 807F004C  lwz r3, 0x4c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EE1078: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE107C: 41820070  beq 0x82ee10ec
	if ctx.cr[0].eq {
	pc = 0x82EE10EC; continue 'dispatch;
	}
	// 82EE1080: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EE1084: C03F0010  lfs f1, 0x10(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EE1088: 4BFA6C21  bl 0x82e87ca8
	ctx.lr = 0x82EE108C;
	sub_82E87CA8(ctx, base);
	// 82EE108C: 48000054  b 0x82ee10e0
	pc = 0x82EE10E0; continue 'dispatch;
            }
            0x82EE1090 => {
    //   block [0x82EE1090..0x82EE10C0)
	// 82EE1090: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EE1094: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EE1098: 419A0040  beq cr6, 0x82ee10d8
	if ctx.cr[6].eq {
	pc = 0x82EE10D8; continue 'dispatch;
	}
	// 82EE109C: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EE10A0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE10A4: 4182001C  beq 0x82ee10c0
	if ctx.cr[0].eq {
	pc = 0x82EE10C0; continue 'dispatch;
	}
	// 82EE10A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EE10AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE10B0: 4E800421  bctrl
	ctx.lr = 0x82EE10B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE10B4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EE10B8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EE10BC: 409A001C  bne cr6, 0x82ee10d8
	if !ctx.cr[6].eq {
	pc = 0x82EE10D8; continue 'dispatch;
	}
            }
            0x82EE10C0 => {
    //   block [0x82EE10C0..0x82EE10D8)
	// 82EE10C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE10C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EE10C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE10CC: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EE10D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE10D4: 4E800421  bctrl
	ctx.lr = 0x82EE10D8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EE10D8 => {
    //   block [0x82EE10D8..0x82EE10E0)
	// 82EE10D8: 807F004C  lwz r3, 0x4c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EE10DC: 4BFA6695  bl 0x82e87770
	ctx.lr = 0x82EE10E0;
	sub_82E87770(ctx, base);
	pc = 0x82EE10E0; continue 'dispatch;
            }
            0x82EE10E0 => {
    //   block [0x82EE10E0..0x82EE10EC)
	// 82EE10E0: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EE10E4: 4082FFAC  bne 0x82ee1090
	if !ctx.cr[0].eq {
	pc = 0x82EE1090; continue 'dispatch;
	}
	// 82EE10E8: 480000B0  b 0x82ee1198
	pc = 0x82EE1198; continue 'dispatch;
            }
            0x82EE10EC => {
    //   block [0x82EE10EC..0x82EE1100)
	// 82EE10EC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EE10F0: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EE10F4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE10F8: 83AB0008  lwz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE10FC: 48000094  b 0x82ee1190
	pc = 0x82EE1190; continue 'dispatch;
            }
            0x82EE1100 => {
    //   block [0x82EE1100..0x82EE1134)
	// 82EE1100: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE1104: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EE1108: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EE110C: 419A0080  beq cr6, 0x82ee118c
	if ctx.cr[6].eq {
	pc = 0x82EE118C; continue 'dispatch;
	}
	// 82EE1110: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EE1114: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE1118: 4182001C  beq 0x82ee1134
	if ctx.cr[0].eq {
	pc = 0x82EE1134; continue 'dispatch;
	}
	// 82EE111C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EE1120: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE1124: 4E800421  bctrl
	ctx.lr = 0x82EE1128;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE1128: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EE112C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EE1130: 409A005C  bne cr6, 0x82ee118c
	if !ctx.cr[6].eq {
	pc = 0x82EE118C; continue 'dispatch;
	}
            }
            0x82EE1134 => {
    //   block [0x82EE1134..0x82EE118C)
	// 82EE1134: C01F0010  lfs f0, 0x10(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE1138: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE113C: C1BC0000  lfs f13, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE1140: C01E0034  lfs f0, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE1144: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE1148: C19C0004  lfs f12, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE114C: C1BE0038  lfs f13, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE1150: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE1154: C15E003C  lfs f10, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE1158: C19C0008  lfs f12, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE115C: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EE1160: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE1164: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE1168: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE116C: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EE1170: 4098001C  bge cr6, 0x82ee118c
	if !ctx.cr[6].lt {
	pc = 0x82EE118C; continue 'dispatch;
	}
	// 82EE1174: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE1178: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EE117C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE1180: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EE1184: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE1188: 4E800421  bctrl
	ctx.lr = 0x82EE118C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EE118C => {
    //   block [0x82EE118C..0x82EE1190)
	// 82EE118C: 83BD000C  lwz r29, 0xc(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x82EE1190; continue 'dispatch;
            }
            0x82EE1190 => {
    //   block [0x82EE1190..0x82EE1198)
	// 82EE1190: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE1194: 4082FF6C  bne 0x82ee1100
	if !ctx.cr[0].eq {
	pc = 0x82EE1100; continue 'dispatch;
	}
	pc = 0x82EE1198; continue 'dispatch;
            }
            0x82EE1198 => {
    //   block [0x82EE1198..0x82EE11A0)
	// 82EE1198: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EE119C: 4BDC82BC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE11A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE11A0 size=1316
    let mut pc: u32 = 0x82EE11A0;
    'dispatch: loop {
        match pc {
            0x82EE11A0 => {
    //   block [0x82EE11A0..0x82EE11F8)
	// 82EE11A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE11A4: 4BDC8255  bl 0x82ca93f8
	ctx.lr = 0x82EE11A8;
	sub_82CA93D0(ctx, base);
	// 82EE11A8: DBA1FFA0  stfd f29, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[29].u64 ) };
	// 82EE11AC: DBC1FFA8  stfd f30, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 82EE11B0: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 82EE11B4: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE11B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE11BC: 4B37F7FD  bl 0x822609b8
	ctx.lr = 0x82EE11C0;
	sub_822609B8(ctx, base);
	// 82EE11C0: C17F00D0  lfs f11, 0xd0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE11C4: C1A3004C  lfs f13, 0x4c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE11C8: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82EE11CC: 419804E4  blt cr6, 0x82ee16b0
	if ctx.cr[6].lt {
	pc = 0x82EE16B0; continue 'dispatch;
	}
	// 82EE11D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE11D4: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE11D8: C18B0A98  lfs f12, 0xa98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2712 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE11DC: ED805B3A  fmadds f12, f0, f12, f11
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EE11E0: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EE11E4: 40980014  bge cr6, 0x82ee11f8
	if !ctx.cr[6].lt {
	pc = 0x82EE11F8; continue 'dispatch;
	}
	// 82EE11E8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE11EC: 896B0410  lbz r11, 0x410(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1040 as u32) ) } as u64;
	// 82EE11F0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE11F4: 418204BC  beq 0x82ee16b0
	if ctx.cr[0].eq {
	pc = 0x82EE16B0; continue 'dispatch;
	}
	pc = 0x82EE11F8; continue 'dispatch;
            }
            0x82EE11F8 => {
    //   block [0x82EE11F8..0x82EE120C)
	// 82EE11F8: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE11FC: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82EE1200: D01F00D0  stfs f0, 0xd0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82EE1204: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EE1208: 48000028  b 0x82ee1230
	pc = 0x82EE1230; continue 'dispatch;
            }
            0x82EE120C => {
    //   block [0x82EE120C..0x82EE1230)
	// 82EE120C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE1210: 992A0020  stb r9, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[9].u8 ) };
	// 82EE1214: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE1218: 80EB0010  lwz r7, 0x10(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EE121C: 810A001C  lwz r8, 0x1c(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE1220: 90EA001C  stw r7, 0x1c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[7].u32 ) };
	// 82EE1224: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE1228: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82EE122C: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	pc = 0x82EE1230; continue 'dispatch;
            }
            0x82EE1230 => {
    //   block [0x82EE1230..0x82EE1284)
	// 82EE1230: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE1234: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EE1238: 409AFFD4  bne cr6, 0x82ee120c
	if !ctx.cr[6].eq {
	pc = 0x82EE120C; continue 'dispatch;
	}
	// 82EE123C: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82EE1240: 3BBF005C  addi r29, r31, 0x5c
	ctx.r[29].s64 = ctx.r[31].s64 + 92;
	// 82EE1244: 912B0014  stw r9, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82EE1248: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EE124C: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EE1250: 3F008334  lis r24, -0x7ccc
	ctx.r[24].s64 = -2093744128;
	// 82EE1254: C3AA0C14  lfs f29, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EE1258: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE125C: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EE1260: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE1264: D01D0004  stfs f0, 4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EE1268: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE126C: D01D0008  stfs f0, 8(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EE1270: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82EE1274: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE1278: 4182000C  beq 0x82ee1284
	if ctx.cr[0].eq {
	pc = 0x82EE1284; continue 'dispatch;
	}
	// 82EE127C: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE1280: 4800001C  b 0x82ee129c
	pc = 0x82EE129C; continue 'dispatch;
            }
            0x82EE1284 => {
    //   block [0x82EE1284..0x82EE1298)
	// 82EE1284: 81780718  lwz r11, 0x718(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EE1288: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE128C: 4182000C  beq 0x82ee1298
	if ctx.cr[0].eq {
	pc = 0x82EE1298; continue 'dispatch;
	}
	// 82EE1290: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE1294: 48000008  b 0x82ee129c
	pc = 0x82EE129C; continue 'dispatch;
            }
            0x82EE1298 => {
    //   block [0x82EE1298..0x82EE129C)
	// 82EE1298: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	pc = 0x82EE129C; continue 'dispatch;
            }
            0x82EE129C => {
    //   block [0x82EE129C..0x82EE12C8)
	// 82EE129C: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82EE12A0: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EE12A4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE12A8: 41820034  beq 0x82ee12dc
	if ctx.cr[0].eq {
	pc = 0x82EE12DC; continue 'dispatch;
	}
	// 82EE12AC: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE12B0: C1BF0074  lfs f13, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE12B4: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EE12B8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE12BC: 4199000C  bgt cr6, 0x82ee12c8
	if ctx.cr[6].gt {
	pc = 0x82EE12C8; continue 'dispatch;
	}
	// 82EE12C0: D1BF0078  stfs f13, 0x78(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EE12C4: 48000020  b 0x82ee12e4
	pc = 0x82EE12E4; continue 'dispatch;
            }
            0x82EE12C8 => {
    //   block [0x82EE12C8..0x82EE12DC)
	// 82EE12C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EE12CC: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EE12D0: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EE12D4: 997F007C  stb r11, 0x7c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u8 ) };
	// 82EE12D8: 48000010  b 0x82ee12e8
	pc = 0x82EE12E8; continue 'dispatch;
            }
            0x82EE12DC => {
    //   block [0x82EE12DC..0x82EE12E4)
	// 82EE12DC: C01F0074  lfs f0, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE12E0: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	pc = 0x82EE12E4; continue 'dispatch;
            }
            0x82EE12E4 => {
    //   block [0x82EE12E4..0x82EE12E8)
	// 82EE12E4: 993F007C  stb r9, 0x7c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[9].u8 ) };
	pc = 0x82EE12E8; continue 'dispatch;
            }
            0x82EE12E8 => {
    //   block [0x82EE12E8..0x82EE1310)
	// 82EE12E8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EE12EC: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EE12F0: C1BF0020  lfs f13, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE12F4: D1BF00C4  stfs f13, 0xc4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EE12F8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE12FC: C3CA0BFC  lfs f30, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EE1300: 41820010  beq 0x82ee1310
	if ctx.cr[0].eq {
	pc = 0x82EE1310; continue 'dispatch;
	}
	// 82EE1304: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE1308: EC006FBA  fmadds f0, f0, f30, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE130C: 48000020  b 0x82ee132c
	pc = 0x82EE132C; continue 'dispatch;
            }
            0x82EE1310 => {
    //   block [0x82EE1310..0x82EE1324)
	// 82EE1310: 81780718  lwz r11, 0x718(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EE1314: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE1318: 4182000C  beq 0x82ee1324
	if ctx.cr[0].eq {
	pc = 0x82EE1324; continue 'dispatch;
	}
	// 82EE131C: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE1320: 48000008  b 0x82ee1328
	pc = 0x82EE1328; continue 'dispatch;
            }
            0x82EE1324 => {
    //   block [0x82EE1324..0x82EE1328)
	// 82EE1324: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	pc = 0x82EE1328; continue 'dispatch;
            }
            0x82EE1328 => {
    //   block [0x82EE1328..0x82EE132C)
	// 82EE1328: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	pc = 0x82EE132C; continue 'dispatch;
            }
            0x82EE132C => {
    //   block [0x82EE132C..0x82EE1368)
	// 82EE132C: 807F004C  lwz r3, 0x4c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EE1330: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EE1334: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE1338: 418201A0  beq 0x82ee14d8
	if ctx.cr[0].eq {
	pc = 0x82EE14D8; continue 'dispatch;
	}
	// 82EE133C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EE1340: C03F0010  lfs f1, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EE1344: 4BFA6965  bl 0x82e87ca8
	ctx.lr = 0x82EE1348;
	sub_82E87CA8(ctx, base);
	// 82EE1348: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EE134C: 41820364  beq 0x82ee16b0
	if ctx.cr[0].eq {
	pc = 0x82EE16B0; continue 'dispatch;
	}
	// 82EE1350: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EE1354: 3BABDA4C  addi r29, r11, -0x25b4
	ctx.r[29].s64 = ctx.r[11].s64 + -9652;
	// 82EE1358: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EE135C: 3B8BC5C8  addi r28, r11, -0x3a38
	ctx.r[28].s64 = ctx.r[11].s64 + -14904;
	// 82EE1360: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EE1364: 3B6BC178  addi r27, r11, -0x3e88
	ctx.r[27].s64 = ctx.r[11].s64 + -16008;
	pc = 0x82EE1368; continue 'dispatch;
            }
            0x82EE1368 => {
    //   block [0x82EE1368..0x82EE1398)
	// 82EE1368: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EE136C: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EE1370: 419A0154  beq cr6, 0x82ee14c4
	if ctx.cr[6].eq {
	pc = 0x82EE14C4; continue 'dispatch;
	}
	// 82EE1374: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EE1378: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE137C: 4182001C  beq 0x82ee1398
	if ctx.cr[0].eq {
	pc = 0x82EE1398; continue 'dispatch;
	}
	// 82EE1380: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EE1384: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE1388: 4E800421  bctrl
	ctx.lr = 0x82EE138C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE138C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EE1390: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EE1394: 409A0130  bne cr6, 0x82ee14c4
	if !ctx.cr[6].eq {
	pc = 0x82EE14C4; continue 'dispatch;
	}
            }
            0x82EE1398 => {
    //   block [0x82EE1398..0x82EE13BC)
	// 82EE1398: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EE139C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EE13A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EE13A4: 4B3072D5  bl 0x821e8678
	ctx.lr = 0x82EE13A8;
	sub_821E8678(ctx, base);
	// 82EE13A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE13AC: 41820010  beq 0x82ee13bc
	if ctx.cr[0].eq {
	pc = 0x82EE13BC; continue 'dispatch;
	}
	// 82EE13B0: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE13B4: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EE13B8: 4800001C  b 0x82ee13d4
	pc = 0x82EE13D4; continue 'dispatch;
            }
            0x82EE13BC => {
    //   block [0x82EE13BC..0x82EE13D0)
	// 82EE13BC: 81780718  lwz r11, 0x718(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EE13C0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE13C4: 4182000C  beq 0x82ee13d0
	if ctx.cr[0].eq {
	pc = 0x82EE13D0; continue 'dispatch;
	}
	// 82EE13C8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE13CC: 48000008  b 0x82ee13d4
	pc = 0x82EE13D4; continue 'dispatch;
            }
            0x82EE13D0 => {
    //   block [0x82EE13D0..0x82EE13D4)
	// 82EE13D0: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	pc = 0x82EE13D4; continue 'dispatch;
            }
            0x82EE13D4 => {
    //   block [0x82EE13D4..0x82EE145C)
	// 82EE13D4: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EE13D8: C19F00C4  lfs f12, 0xc4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE13DC: ED8C002A  fadds f12, f12, f0
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EE13E0: C1BE003C  lfs f13, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE13E4: C17E0038  lfs f11, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE13E8: C15E0034  lfs f10, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE13EC: C11F00AC  lfs f8, 0xac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE13F0: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE13F4: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE13F8: C12B0038  lfs f9, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE13FC: EDAB4828  fsubs f13, f11, f9
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EE1400: C13F00B0  lfs f9, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE1404: C16B0034  lfs f11, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE1408: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EE140C: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EE1410: C15F00A8  lfs f10, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE1414: FCE06050  fneg f7, f12
	ctx.f[7].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE1418: D1610050  stfs f11, 0x50(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EE141C: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EE1420: ED290032  fmuls f9, f9, f0
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE1424: EC084B7A  fmadds f0, f8, f13, f9
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[13].f64 + ctx.f[9].f64) as f32) as f64);
	// 82EE1428: EC0A02FA  fmadds f0, f10, f11, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE142C: FF003800  fcmpu cr6, f0, f7
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[7].f64);
	// 82EE1430: 41980094  blt cr6, 0x82ee14c4
	if ctx.cr[6].lt {
	pc = 0x82EE14C4; continue 'dispatch;
	}
	// 82EE1434: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EE1438: 4199008C  bgt cr6, 0x82ee14c4
	if ctx.cr[6].gt {
	pc = 0x82EE14C4; continue 'dispatch;
	}
	// 82EE143C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EE1440: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EE1444: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EE1448: 4B307231  bl 0x821e8678
	ctx.lr = 0x82EE144C;
	sub_821E8678(ctx, base);
	// 82EE144C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE1450: 4182000C  beq 0x82ee145c
	if ctx.cr[0].eq {
	pc = 0x82EE145C; continue 'dispatch;
	}
	// 82EE1454: C3E30004  lfs f31, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EE1458: 4800001C  b 0x82ee1474
	pc = 0x82EE1474; continue 'dispatch;
            }
            0x82EE145C => {
    //   block [0x82EE145C..0x82EE1470)
	// 82EE145C: 81780718  lwz r11, 0x718(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EE1460: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE1464: 4182000C  beq 0x82ee1470
	if ctx.cr[0].eq {
	pc = 0x82EE1470; continue 'dispatch;
	}
	// 82EE1468: C3EB000C  lfs f31, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EE146C: 48000008  b 0x82ee1474
	pc = 0x82EE1474; continue 'dispatch;
            }
            0x82EE1470 => {
    //   block [0x82EE1470..0x82EE1474)
	// 82EE1470: FFE0E890  fmr f31, f29
	ctx.f[31].f64 = ctx.f[29].f64;
	pc = 0x82EE1474; continue 'dispatch;
            }
            0x82EE1474 => {
    //   block [0x82EE1474..0x82EE14B4)
	// 82EE1474: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EE1478: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EE147C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EE1480: 4B3071F9  bl 0x821e8678
	ctx.lr = 0x82EE1484;
	sub_821E8678(ctx, base);
	// 82EE1484: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE1488: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE148C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EE1490: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82EE1494: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EE1498: 4182001C  beq 0x82ee14b4
	if ctx.cr[0].eq {
	pc = 0x82EE14B4; continue 'dispatch;
	}
	// 82EE149C: C0430004  lfs f2, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EE14A0: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EE14A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE14A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE14AC: 4E800421  bctrl
	ctx.lr = 0x82EE14B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE14B0: 48000014  b 0x82ee14c4
	pc = 0x82EE14C4; continue 'dispatch;
            }
            0x82EE14B4 => {
    //   block [0x82EE14B4..0x82EE14C4)
	// 82EE14B4: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EE14B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE14BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE14C0: 4E800421  bctrl
	ctx.lr = 0x82EE14C4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EE14C4 => {
    //   block [0x82EE14C4..0x82EE14D8)
	// 82EE14C4: 807F004C  lwz r3, 0x4c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EE14C8: 4BFA62A9  bl 0x82e87770
	ctx.lr = 0x82EE14CC;
	sub_82E87770(ctx, base);
	// 82EE14CC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EE14D0: 4082FE98  bne 0x82ee1368
	if !ctx.cr[0].eq {
	pc = 0x82EE1368; continue 'dispatch;
	}
	// 82EE14D4: 480001DC  b 0x82ee16b0
	pc = 0x82EE16B0; continue 'dispatch;
            }
            0x82EE14D8 => {
    //   block [0x82EE14D8..0x82EE1504)
	// 82EE14D8: 81780718  lwz r11, 0x718(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EE14DC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE14E0: 838B0008  lwz r28, 8(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE14E4: 281C0000  cmplwi r28, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE14E8: 418201C8  beq 0x82ee16b0
	if ctx.cr[0].eq {
	pc = 0x82EE16B0; continue 'dispatch;
	}
	// 82EE14EC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EE14F0: 3B6BDA4C  addi r27, r11, -0x25b4
	ctx.r[27].s64 = ctx.r[11].s64 + -9652;
	// 82EE14F4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EE14F8: 3B4BC5C8  addi r26, r11, -0x3a38
	ctx.r[26].s64 = ctx.r[11].s64 + -14904;
	// 82EE14FC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EE1500: 3B2BC178  addi r25, r11, -0x3e88
	ctx.r[25].s64 = ctx.r[11].s64 + -16008;
	pc = 0x82EE1504; continue 'dispatch;
            }
            0x82EE1504 => {
    //   block [0x82EE1504..0x82EE1538)
	// 82EE1504: 83DC0004  lwz r30, 4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE1508: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EE150C: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EE1510: 419A0194  beq cr6, 0x82ee16a4
	if ctx.cr[6].eq {
	pc = 0x82EE16A4; continue 'dispatch;
	}
	// 82EE1514: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EE1518: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE151C: 4182001C  beq 0x82ee1538
	if ctx.cr[0].eq {
	pc = 0x82EE1538; continue 'dispatch;
	}
	// 82EE1520: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EE1524: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE1528: 4E800421  bctrl
	ctx.lr = 0x82EE152C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE152C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EE1530: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EE1534: 409A0170  bne cr6, 0x82ee16a4
	if !ctx.cr[6].eq {
	pc = 0x82EE16A4; continue 'dispatch;
	}
            }
            0x82EE1538 => {
    //   block [0x82EE1538..0x82EE159C)
	// 82EE1538: C01F0010  lfs f0, 0x10(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE153C: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE1540: C15E0034  lfs f10, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE1544: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE1548: EC005028  fsubs f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EE154C: C1BD0004  lfs f13, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE1550: C13E0038  lfs f9, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE1554: EDAD4828  fsubs f13, f13, f9
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EE1558: C19D0008  lfs f12, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE155C: C15E003C  lfs f10, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE1560: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EE1564: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE1568: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE156C: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE1570: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EE1574: 40980130  bge cr6, 0x82ee16a4
	if !ctx.cr[6].lt {
	pc = 0x82EE16A4; continue 'dispatch;
	}
	// 82EE1578: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EE157C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82EE1580: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EE1584: 4B3070F5  bl 0x821e8678
	ctx.lr = 0x82EE1588;
	sub_821E8678(ctx, base);
	// 82EE1588: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE158C: 41820010  beq 0x82ee159c
	if ctx.cr[0].eq {
	pc = 0x82EE159C; continue 'dispatch;
	}
	// 82EE1590: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE1594: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EE1598: 4800001C  b 0x82ee15b4
	pc = 0x82EE15B4; continue 'dispatch;
            }
            0x82EE159C => {
    //   block [0x82EE159C..0x82EE15B0)
	// 82EE159C: 81780718  lwz r11, 0x718(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EE15A0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE15A4: 4182000C  beq 0x82ee15b0
	if ctx.cr[0].eq {
	pc = 0x82EE15B0; continue 'dispatch;
	}
	// 82EE15A8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE15AC: 48000008  b 0x82ee15b4
	pc = 0x82EE15B4; continue 'dispatch;
            }
            0x82EE15B0 => {
    //   block [0x82EE15B0..0x82EE15B4)
	// 82EE15B0: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	pc = 0x82EE15B4; continue 'dispatch;
            }
            0x82EE15B4 => {
    //   block [0x82EE15B4..0x82EE163C)
	// 82EE15B4: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EE15B8: C19F00C4  lfs f12, 0xc4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE15BC: ED8C002A  fadds f12, f12, f0
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EE15C0: C1BE003C  lfs f13, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE15C4: C17E0038  lfs f11, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE15C8: C15E0034  lfs f10, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE15CC: C11F00AC  lfs f8, 0xac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE15D0: C00B003C  lfs f0, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE15D4: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE15D8: C12B0038  lfs f9, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE15DC: EDAB4828  fsubs f13, f11, f9
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EE15E0: C13F00B0  lfs f9, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE15E4: C16B0034  lfs f11, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE15E8: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EE15EC: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EE15F0: C15F00A8  lfs f10, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE15F4: FCE06050  fneg f7, f12
	ctx.f[7].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE15F8: D1610060  stfs f11, 0x60(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EE15FC: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EE1600: ED290032  fmuls f9, f9, f0
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE1604: EC084B7A  fmadds f0, f8, f13, f9
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[13].f64 + ctx.f[9].f64) as f32) as f64);
	// 82EE1608: EC0A02FA  fmadds f0, f10, f11, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE160C: FF003800  fcmpu cr6, f0, f7
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[7].f64);
	// 82EE1610: 41980094  blt cr6, 0x82ee16a4
	if ctx.cr[6].lt {
	pc = 0x82EE16A4; continue 'dispatch;
	}
	// 82EE1614: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EE1618: 4199008C  bgt cr6, 0x82ee16a4
	if ctx.cr[6].gt {
	pc = 0x82EE16A4; continue 'dispatch;
	}
	// 82EE161C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EE1620: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82EE1624: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EE1628: 4B307051  bl 0x821e8678
	ctx.lr = 0x82EE162C;
	sub_821E8678(ctx, base);
	// 82EE162C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE1630: 4182000C  beq 0x82ee163c
	if ctx.cr[0].eq {
	pc = 0x82EE163C; continue 'dispatch;
	}
	// 82EE1634: C3E30004  lfs f31, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EE1638: 4800001C  b 0x82ee1654
	pc = 0x82EE1654; continue 'dispatch;
            }
            0x82EE163C => {
    //   block [0x82EE163C..0x82EE1650)
	// 82EE163C: 81780718  lwz r11, 0x718(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EE1640: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE1644: 4182000C  beq 0x82ee1650
	if ctx.cr[0].eq {
	pc = 0x82EE1650; continue 'dispatch;
	}
	// 82EE1648: C3EB000C  lfs f31, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EE164C: 48000008  b 0x82ee1654
	pc = 0x82EE1654; continue 'dispatch;
            }
            0x82EE1650 => {
    //   block [0x82EE1650..0x82EE1654)
	// 82EE1650: FFE0E890  fmr f31, f29
	ctx.f[31].f64 = ctx.f[29].f64;
	pc = 0x82EE1654; continue 'dispatch;
            }
            0x82EE1654 => {
    //   block [0x82EE1654..0x82EE1694)
	// 82EE1654: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EE1658: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EE165C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EE1660: 4B307019  bl 0x821e8678
	ctx.lr = 0x82EE1664;
	sub_821E8678(ctx, base);
	// 82EE1664: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE1668: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE166C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EE1670: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82EE1674: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EE1678: 4182001C  beq 0x82ee1694
	if ctx.cr[0].eq {
	pc = 0x82EE1694; continue 'dispatch;
	}
	// 82EE167C: C0430004  lfs f2, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EE1680: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EE1684: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE1688: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE168C: 4E800421  bctrl
	ctx.lr = 0x82EE1690;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE1690: 48000014  b 0x82ee16a4
	pc = 0x82EE16A4; continue 'dispatch;
            }
            0x82EE1694 => {
    //   block [0x82EE1694..0x82EE16A4)
	// 82EE1694: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EE1698: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE169C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE16A0: 4E800421  bctrl
	ctx.lr = 0x82EE16A4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EE16A4 => {
    //   block [0x82EE16A4..0x82EE16B0)
	// 82EE16A4: 839C000C  lwz r28, 0xc(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EE16A8: 281C0000  cmplwi r28, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE16AC: 4082FE58  bne 0x82ee1504
	if !ctx.cr[0].eq {
	pc = 0x82EE1504; continue 'dispatch;
	}
	pc = 0x82EE16B0; continue 'dispatch;
            }
            0x82EE16B0 => {
    //   block [0x82EE16B0..0x82EE16C4)
	// 82EE16B0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82EE16B4: CBA1FFA0  lfd f29, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 82EE16B8: CBC1FFA8  lfd f30, -0x58(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82EE16BC: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82EE16C0: 4BDC7D88  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE16C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE16C8 size=52
    let mut pc: u32 = 0x82EE16C8;
    'dispatch: loop {
        match pc {
            0x82EE16C8 => {
    //   block [0x82EE16C8..0x82EE16FC)
	// 82EE16C8: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EE16CC: 81260004  lwz r9, 4(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE16D0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE16D4: 40820028  bne 0x82ee16fc
	if !ctx.cr[0].eq {
		sub_82EE16FC(ctx, base);
		return;
	}
	// 82EE16D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE16DC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82EE16E0: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EE16E4: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 82EE16E8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EE16EC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EE16F0: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EE16F4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EE16F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE16FC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EE16FC size=220
    let mut pc: u32 = 0x82EE16FC;
    'dispatch: loop {
        match pc {
            0x82EE16FC => {
    //   block [0x82EE16FC..0x82EE1778)
	// 82EE16FC: 81040014  lwz r8, 0x14(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE1700: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82EE1704: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82EE1708: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82EE170C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EE1710: 91040014  stw r8, 0x14(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 82EE1714: 810B001C  lwz r8, 0x1c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE1718: 91040010  stw r8, 0x10(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 82EE171C: C0050004  lfs f0, 4(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE1720: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EE1724: C0050008  lfs f0, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE1728: D00A0008  stfs f0, 8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EE172C: C005000C  lfs f0, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE1730: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EE1734: C0050010  lfs f0, 0x10(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE1738: D00A0010  stfs f0, 0x10(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EE173C: 98EB0020  stb r7, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[7].u8 ) };
	// 82EE1740: 409A0054  bne cr6, 0x82ee1794
	if !ctx.cr[6].eq {
	pc = 0x82EE1794; continue 'dispatch;
	}
	// 82EE1744: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EE1748: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE174C: 4082002C  bne 0x82ee1778
	if !ctx.cr[0].eq {
	pc = 0x82EE1778; continue 'dispatch;
	}
	// 82EE1750: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EE1754: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EE1758: 914B001C  stw r10, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82EE175C: 81240008  lwz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE1760: 91490018  stw r10, 0x18(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82EE1764: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EE1768: 91490018  stw r10, 0x18(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82EE176C: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EE1770: 9149001C  stw r10, 0x1c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82EE1774: 48000044  b 0x82ee17b8
	pc = 0x82EE17B8; continue 'dispatch;
            }
            0x82EE1778 => {
    //   block [0x82EE1778..0x82EE1794)
	// 82EE1778: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EE177C: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82EE1780: 912B001C  stw r9, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 82EE1784: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EE1788: 916A001C  stw r11, 0x1c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82EE178C: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EE1790: 48000028  b 0x82ee17b8
	pc = 0x82EE17B8; continue 'dispatch;
            }
            0x82EE1794 => {
    //   block [0x82EE1794..0x82EE17B4)
	// 82EE1794: 81490018  lwz r10, 0x18(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EE1798: 912B001C  stw r9, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 82EE179C: 91690018  stw r11, 0x18(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82EE17A0: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE17A4: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82EE17A8: 4182000C  beq 0x82ee17b4
	if ctx.cr[0].eq {
	pc = 0x82EE17B4; continue 'dispatch;
	}
	// 82EE17AC: 916A001C  stw r11, 0x1c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82EE17B0: 48000008  b 0x82ee17b8
	pc = 0x82EE17B8; continue 'dispatch;
            }
            0x82EE17B4 => {
    //   block [0x82EE17B4..0x82EE17B8)
	// 82EE17B4: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE17B8; continue 'dispatch;
            }
            0x82EE17B8 => {
    //   block [0x82EE17B8..0x82EE17D8)
	// 82EE17B8: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EE17BC: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EE17C0: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82EE17C4: 394AAFB4  addi r10, r10, -0x504c
	ctx.r[10].s64 = ctx.r[10].s64 + -20556;
	// 82EE17C8: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	// 82EE17CC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EE17D0: 91260000  stw r9, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EE17D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE17D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE17D8 size=268
    let mut pc: u32 = 0x82EE17D8;
    'dispatch: loop {
        match pc {
            0x82EE17D8 => {
    //   block [0x82EE17D8..0x82EE18A0)
	// 82EE17D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE17DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EE17E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE17E4: 80830118  lwz r4, 0x118(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(280 as u32) ) } as u64;
	// 82EE17E8: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE17EC: 418200E8  beq 0x82ee18d4
	if ctx.cr[0].eq {
	pc = 0x82EE18D4; continue 'dispatch;
	}
	// 82EE17F0: 548B003E  slwi r11, r4, 0
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EE17F4: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE17F8: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EE17FC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EE1800: 419A00D4  beq cr6, 0x82ee18d4
	if ctx.cr[6].eq {
	pc = 0x82EE18D4; continue 'dispatch;
	}
	// 82EE1804: C0030074  lfs f0, 0x74(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE1808: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE180C: EC00082A  fadds f0, f0, f1
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 82EE1810: C1430020  lfs f10, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE1814: C1650008  lfs f11, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE1818: C1230078  lfs f9, 0x78(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE181C: C1850000  lfs f12, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE1820: C1AB0BFC  lfs f13, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE1824: EC00537A  fmadds f0, f0, f13, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64);
	// 82EE1828: ED4B02F2  fmuls f10, f11, f11
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE182C: ED69037A  fmadds f11, f9, f13, f0
	ctx.f[11].f64 = (((ctx.f[9].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE1830: EDAC533A  fmadds f13, f12, f12, f10
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[10].f64) as f32) as f64);
	// 82EE1834: ED6B02F2  fmuls f11, f11, f11
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE1838: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82EE183C: 41990098  bgt cr6, 0x82ee18d4
	if ctx.cr[6].gt {
	pc = 0x82EE18D4; continue 'dispatch;
	}
	// 82EE1840: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE1844: C10B0C18  lfs f8, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE1848: FF0D4000  fcmpu cr6, f13, f8
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[8].f64);
	// 82EE184C: 419A0088  beq cr6, 0x82ee18d4
	if ctx.cr[6].eq {
	pc = 0x82EE18D4; continue 'dispatch;
	}
	// 82EE1850: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE1854: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE1858: EC00682C  fsqrts f0, f13
	ctx.f[0].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 82EE185C: C1250004  lfs f9, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE1860: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EE1864: C0E50008  lfs f7, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EE1868: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82EE186C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EE1870: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE1874: C14B0C14  lfs f10, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE1878: EC0A0024  fdivs f0, f10, f0
	ctx.f[0].f64 = ((ctx.f[10].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EE187C: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE1880: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EE1884: ED290032  fmuls f9, f9, f0
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE1888: D1210068  stfs f9, 0x68(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EE188C: EC0001F2  fmuls f0, f0, f7
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[7].f64) as f32) as f64);
	// 82EE1890: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82EE1894: 4199000C  bgt cr6, 0x82ee18a0
	if ctx.cr[6].gt {
	pc = 0x82EE18A0; continue 'dispatch;
	}
	// 82EE1898: D1010070  stfs f8, 0x70(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82EE189C: 48000014  b 0x82ee18b0
	pc = 0x82EE18B0; continue 'dispatch;
            }
            0x82EE18A0 => {
    //   block [0x82EE18A0..0x82EE18B0)
	// 82EE18A0: EC0B6824  fdivs f0, f11, f13
	ctx.f[0].f64 = ((ctx.f[11].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EE18A4: EC0A0028  fsubs f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE18A8: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EE18AC: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	pc = 0x82EE18B0; continue 'dispatch;
            }
            0x82EE18B0 => {
    //   block [0x82EE18B0..0x82EE18D4)
	// 82EE18B0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE18B4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EE18B8: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EE18BC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82EE18C0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EE18C4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EE18C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE18CC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EE18D0: 4BFFFDF9  bl 0x82ee16c8
	ctx.lr = 0x82EE18D4;
	sub_82EE16C8(ctx, base);
	pc = 0x82EE18D4; continue 'dispatch;
            }
            0x82EE18D4 => {
    //   block [0x82EE18D4..0x82EE18E4)
	// 82EE18D4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EE18D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE18DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EE18E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE18E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE18E8 size=1472
    let mut pc: u32 = 0x82EE18E8;
    'dispatch: loop {
        match pc {
            0x82EE18E8 => {
    //   block [0x82EE18E8..0x82EE193C)
	// 82EE18E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE18EC: 4BDC7B21  bl 0x82ca940c
	ctx.lr = 0x82EE18F0;
	sub_82CA93D0(ctx, base);
	// 82EE18F0: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82EE18F4: 4BDCC3C9  bl 0x82cadcbc
	ctx.lr = 0x82EE18F8;
	sub_82CADCA0(ctx, base);
	// 82EE18F8: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE18FC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EE1900: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82EE1904: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EE1908: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 82EE190C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE1910: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82EE1914: 388BD2C0  addi r4, r11, -0x2d40
	ctx.r[4].s64 = ctx.r[11].s64 + -11584;
	// 82EE1918: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EE191C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EE1920: 4B306D59  bl 0x821e8678
	ctx.lr = 0x82EE1924;
	sub_821E8678(ctx, base);
	// 82EE1924: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE1928: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE192C: C36B0C18  lfs f27, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82EE1930: 4182000C  beq 0x82ee193c
	if ctx.cr[0].eq {
	pc = 0x82EE193C; continue 'dispatch;
	}
	// 82EE1934: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 82EE1938: 48000024  b 0x82ee195c
	pc = 0x82EE195C; continue 'dispatch;
            }
            0x82EE193C => {
    //   block [0x82EE193C..0x82EE195C)
	// 82EE193C: C01E004C  lfs f0, 0x4c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE1940: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EE1944: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EE1948: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EE194C: C01E0054  lfs f0, 0x54(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE1950: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EE1954: D3610064  stfs f27, 0x64(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EE1958: 4B39D911  bl 0x8227f268
	ctx.lr = 0x82EE195C;
	sub_8227F268(ctx, base);
	pc = 0x82EE195C; continue 'dispatch;
            }
            0x82EE195C => {
    //   block [0x82EE195C..0x82EE1A6C)
	// 82EE195C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE1960: C17F0078  lfs f11, 0x78(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE1964: C1830008  lfs f12, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE1968: EF8BF02A  fadds f28, f11, f30
	ctx.f[28].f64 = ((ctx.f[11].f64 + ctx.f[30].f64) as f32) as f64;
	// 82EE196C: C2BD0008  lfs f21, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[21].f64 = (tmp.f32 as f64);
	// 82EE1970: EF0BF82A  fadds f24, f11, f31
	ctx.f[24].f64 = ((ctx.f[11].f64 + ctx.f[31].f64) as f32) as f64;
	// 82EE1974: EFAC0572  fmuls f29, f12, f21
	ctx.f[29].f64 = (((ctx.f[12].f64 * ctx.f[21].f64) as f32) as f64);
	// 82EE1978: C0030000  lfs f0, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE197C: C0A30004  lfs f5, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82EE1980: C0CB0BFC  lfs f6, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EE1984: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EE1988: C05F0020  lfs f2, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EE198C: EC2B01B2  fmuls f1, f11, f6
	ctx.f[1].f64 = (((ctx.f[11].f64 * ctx.f[6].f64) as f32) as f64);
	// 82EE1990: 396BDBFC  addi r11, r11, -0x2404
	ctx.r[11].s64 = ctx.r[11].s64 + -9220;
	// 82EE1994: C09D0000  lfs f4, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82EE1998: ED5E01B2  fmuls f10, f30, f6
	ctx.f[10].f64 = (((ctx.f[30].f64 * ctx.f[6].f64) as f32) as f64);
	// 82EE199C: EDBF01B2  fmuls f13, f31, f6
	ctx.f[13].f64 = (((ctx.f[31].f64 * ctx.f[6].f64) as f32) as f64);
	// 82EE19A0: ED7C11BA  fmadds f11, f28, f6, f2
	ctx.f[11].f64 = (((ctx.f[28].f64 * ctx.f[6].f64 + ctx.f[2].f64) as f32) as f64);
	// 82EE19A4: C12B0008  lfs f9, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE19A8: C06B0004  lfs f3, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82EE19AC: EF400272  fmuls f26, f0, f9
	ctx.f[26].f64 = (((ctx.f[0].f64 * ctx.f[9].f64) as f32) as f64);
	// 82EE19B0: C0EB0000  lfs f7, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EE19B4: ED0C00F2  fmuls f8, f12, f3
	ctx.f[8].f64 = (((ctx.f[12].f64 * ctx.f[3].f64) as f32) as f64);
	// 82EE19B8: EF2501F2  fmuls f25, f5, f7
	ctx.f[25].f64 = (((ctx.f[5].f64 * ctx.f[7].f64) as f32) as f64);
	// 82EE19BC: EFC4E83A  fmadds f30, f4, f0, f29
	ctx.f[30].f64 = (((ctx.f[4].f64 * ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64);
	// 82EE19C0: EFECD1F8  fmsubs f31, f12, f7, f26
	ctx.f[31].f64 = (((ctx.f[12].f64 * ctx.f[7].f64 - ctx.f[26].f64) as f32) as f64);
	// 82EE19C4: ED054278  fmsubs f8, f5, f9, f8
	ctx.f[8].f64 = (((ctx.f[5].f64 * ctx.f[9].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EE19C8: ECE0C8F8  fmsubs f7, f0, f3, f25
	ctx.f[7].f64 = (((ctx.f[0].f64 * ctx.f[3].f64 - ctx.f[25].f64) as f32) as f64);
	// 82EE19CC: ED3811BA  fmadds f9, f24, f6, f2
	ctx.f[9].f64 = (((ctx.f[24].f64 * ctx.f[6].f64 + ctx.f[2].f64) as f32) as f64);
	// 82EE19D0: EC61582A  fadds f3, f1, f11
	ctx.f[3].f64 = ((ctx.f[1].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EE19D4: FC40F210  fabs f2, f30
	ctx.f[2].u64 = ctx.f[30].u64 & !0x8000_0000_0000_0000u64;
	// 82EE19D8: FF021800  fcmpu cr6, f2, f3
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[3].f64);
	// 82EE19DC: 419904BC  bgt cr6, 0x82ee1e98
	if ctx.cr[6].gt {
	pc = 0x82EE1E98; continue 'dispatch;
	}
	// 82EE19E0: EC670572  fmuls f3, f7, f21
	ctx.f[3].f64 = (((ctx.f[7].f64 * ctx.f[21].f64) as f32) as f64);
	// 82EE19E4: EC41482A  fadds f2, f1, f9
	ctx.f[2].f64 = ((ctx.f[1].f64 + ctx.f[9].f64) as f32) as f64;
	// 82EE19E8: EC641A3A  fmadds f3, f4, f8, f3
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[8].f64 + ctx.f[3].f64) as f32) as f64);
	// 82EE19EC: FC201A10  fabs f1, f3
	ctx.f[1].u64 = ctx.f[3].u64 & !0x8000_0000_0000_0000u64;
	// 82EE19F0: FF011000  fcmpu cr6, f1, f2
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[2].f64);
	// 82EE19F4: 419904A4  bgt cr6, 0x82ee1e98
	if ctx.cr[6].gt {
	pc = 0x82EE1E98; continue 'dispatch;
	}
	// 82EE19F8: FC40F210  fabs f2, f30
	ctx.f[2].u64 = ctx.f[30].u64 & !0x8000_0000_0000_0000u64;
	// 82EE19FC: FF025000  fcmpu cr6, f2, f10
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[10].f64);
	// 82EE1A00: 4199006C  bgt cr6, 0x82ee1a6c
	if ctx.cr[6].gt {
	pc = 0x82EE1A6C; continue 'dispatch;
	}
	// 82EE1A04: FC401A10  fabs f2, f3
	ctx.f[2].u64 = ctx.f[3].u64 & !0x8000_0000_0000_0000u64;
	// 82EE1A08: FF026800  fcmpu cr6, f2, f13
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[13].f64);
	// 82EE1A0C: 41990060  bgt cr6, 0x82ee1a6c
	if ctx.cr[6].gt {
	pc = 0x82EE1A6C; continue 'dispatch;
	}
	// 82EE1A10: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE1A14: D0810060  stfs f4, 0x60(r1)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EE1A18: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EE1A1C: D3610064  stfs f27, 0x64(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EE1A20: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EE1A24: D2A10068  stfs f21, 0x68(r1)
	tmp.f32 = (ctx.f[21].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EE1A28: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EE1A2C: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EE1A30: 4B39D839  bl 0x8227f268
	ctx.lr = 0x82EE1A34;
	sub_8227F268(ctx, base);
	// 82EE1A34: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EE1A38: D3610090  stfs f27, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82EE1A3C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EE1A40: 394AAFB4  addi r10, r10, -0x504c
	ctx.r[10].s64 = ctx.r[10].s64 + -20556;
	// 82EE1A44: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE1A48: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82EE1A4C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE1A50: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EE1A54: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE1A58: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EE1A5C: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE1A60: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EE1A64: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82EE1A68: 4800041C  b 0x82ee1e84
	pc = 0x82EE1E84; continue 'dispatch;
            }
            0x82EE1A6C => {
    //   block [0x82EE1A6C..0x82EE1ADC)
	// 82EE1A6C: FC40F210  fabs f2, f30
	ctx.f[2].u64 = ctx.f[30].u64 & !0x8000_0000_0000_0000u64;
	// 82EE1A70: FF025800  fcmpu cr6, f2, f11
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[11].f64);
	// 82EE1A74: 4199014C  bgt cr6, 0x82ee1bc0
	if ctx.cr[6].gt {
	pc = 0x82EE1BC0; continue 'dispatch;
	}
	// 82EE1A78: FC401A10  fabs f2, f3
	ctx.f[2].u64 = ctx.f[3].u64 & !0x8000_0000_0000_0000u64;
	// 82EE1A7C: FF024800  fcmpu cr6, f2, f9
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[9].f64);
	// 82EE1A80: 41990140  bgt cr6, 0x82ee1bc0
	if ctx.cr[6].gt {
	pc = 0x82EE1BC0; continue 'dispatch;
	}
	// 82EE1A84: FD601A10  fabs f11, f3
	ctx.f[11].u64 = ctx.f[3].u64 & !0x8000_0000_0000_0000u64;
	// 82EE1A88: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE1A8C: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EE1A90: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EE1A94: FF0B6800  fcmpu cr6, f11, f13
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[13].f64);
	// 82EE1A98: 419800A4  blt cr6, 0x82ee1b3c
	if ctx.cr[6].lt {
	pc = 0x82EE1B3C; continue 'dispatch;
	}
	// 82EE1A9C: FD60F210  fabs f11, f30
	ctx.f[11].u64 = ctx.f[30].u64 & !0x8000_0000_0000_0000u64;
	// 82EE1AA0: FF0B5000  fcmpu cr6, f11, f10
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[10].f64);
	// 82EE1AA4: 41980098  blt cr6, 0x82ee1b3c
	if ctx.cr[6].lt {
	pc = 0x82EE1B3C; continue 'dispatch;
	}
	// 82EE1AA8: EC0002B2  fmuls f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EE1AAC: C13E003C  lfs f9, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE1AB0: ED8C02B2  fmuls f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EE1AB4: C15E0034  lfs f10, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE1AB8: ED680372  fmuls f11, f8, f13
	ctx.f[11].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE1ABC: FF03D800  fcmpu cr6, f3, f27
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[27].f64);
	// 82EE1AC0: EDA70372  fmuls f13, f7, f13
	ctx.f[13].f64 = (((ctx.f[7].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE1AC4: 4099002C  ble cr6, 0x82ee1af0
	if !ctx.cr[6].gt {
	pc = 0x82EE1AF0; continue 'dispatch;
	}
	// 82EE1AC8: FF1ED800  fcmpu cr6, f30, f27
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[27].f64);
	// 82EE1ACC: 40990010  ble cr6, 0x82ee1adc
	if !ctx.cr[6].gt {
	pc = 0x82EE1ADC; continue 'dispatch;
	}
	// 82EE1AD0: EC00502A  fadds f0, f0, f10
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64;
	// 82EE1AD4: ED89602A  fadds f12, f9, f12
	ctx.f[12].f64 = ((ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EE1AD8: 4800000C  b 0x82ee1ae4
	pc = 0x82EE1AE4; continue 'dispatch;
            }
            0x82EE1ADC => {
    //   block [0x82EE1ADC..0x82EE1AE4)
	// 82EE1ADC: EC0A0028  fsubs f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE1AE0: ED896028  fsubs f12, f9, f12
	ctx.f[12].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	pc = 0x82EE1AE4; continue 'dispatch;
            }
            0x82EE1AE4 => {
    //   block [0x82EE1AE4..0x82EE1AF0)
	// 82EE1AE4: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EE1AE8: EDAC682A  fadds f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE1AEC: 48000028  b 0x82ee1b14
	pc = 0x82EE1B14; continue 'dispatch;
            }
            0x82EE1AF0 => {
    //   block [0x82EE1AF0..0x82EE1B04)
	// 82EE1AF0: FF1ED800  fcmpu cr6, f30, f27
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[27].f64);
	// 82EE1AF4: 40990010  ble cr6, 0x82ee1b04
	if !ctx.cr[6].gt {
	pc = 0x82EE1B04; continue 'dispatch;
	}
	// 82EE1AF8: EC00502A  fadds f0, f0, f10
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64;
	// 82EE1AFC: ED89602A  fadds f12, f9, f12
	ctx.f[12].f64 = ((ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EE1B00: 4800000C  b 0x82ee1b0c
	pc = 0x82EE1B0C; continue 'dispatch;
            }
            0x82EE1B04 => {
    //   block [0x82EE1B04..0x82EE1B0C)
	// 82EE1B04: EC0A0028  fsubs f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE1B08: ED896028  fsubs f12, f9, f12
	ctx.f[12].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	pc = 0x82EE1B0C; continue 'dispatch;
            }
            0x82EE1B0C => {
    //   block [0x82EE1B0C..0x82EE1B14)
	// 82EE1B0C: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE1B10: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	pc = 0x82EE1B14; continue 'dispatch;
            }
            0x82EE1B14 => {
    //   block [0x82EE1B14..0x82EE1B3C)
	// 82EE1B14: C19F005C  lfs f12, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE1B18: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EE1B1C: C17F0064  lfs f11, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE1B20: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE1B24: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EE1B28: EC0D5828  fsubs f0, f13, f11
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EE1B2C: D3610064  stfs f27, 0x64(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EE1B30: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EE1B34: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EE1B38: 4800003C  b 0x82ee1b74
	pc = 0x82EE1B74; continue 'dispatch;
            }
            0x82EE1B3C => {
    //   block [0x82EE1B3C..0x82EE1B64)
	// 82EE1B3C: FD601A10  fabs f11, f3
	ctx.f[11].u64 = ctx.f[3].u64 & !0x8000_0000_0000_0000u64;
	// 82EE1B40: D3610064  stfs f27, 0x64(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EE1B44: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EE1B48: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EE1B4C: FF0B6800  fcmpu cr6, f11, f13
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[13].f64);
	// 82EE1B50: 41980014  blt cr6, 0x82ee1b64
	if ctx.cr[6].lt {
	pc = 0x82EE1B64; continue 'dispatch;
	}
	// 82EE1B54: D1010060  stfs f8, 0x60(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EE1B58: FF03D800  fcmpu cr6, f3, f27
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[27].f64);
	// 82EE1B5C: D0E10068  stfs f7, 0x68(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EE1B60: 48000010  b 0x82ee1b70
	pc = 0x82EE1B70; continue 'dispatch;
            }
            0x82EE1B64 => {
    //   block [0x82EE1B64..0x82EE1B70)
	// 82EE1B64: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EE1B68: FF1ED800  fcmpu cr6, f30, f27
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[27].f64);
	// 82EE1B6C: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	pc = 0x82EE1B70; continue 'dispatch;
            }
            0x82EE1B70 => {
    //   block [0x82EE1B70..0x82EE1B74)
	// 82EE1B70: 40990024  ble cr6, 0x82ee1b94
	if !ctx.cr[6].gt {
	pc = 0x82EE1B94; continue 'dispatch;
	}
	pc = 0x82EE1B74; continue 'dispatch;
            }
            0x82EE1B74 => {
    //   block [0x82EE1B74..0x82EE1B94)
	// 82EE1B74: 4B39D6F5  bl 0x8227f268
	ctx.lr = 0x82EE1B78;
	sub_8227F268(ctx, base);
	// 82EE1B78: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE1B7C: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EE1B80: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE1B84: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EE1B88: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE1B8C: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EE1B90: 480002AC  b 0x82ee1e3c
	pc = 0x82EE1E3C; continue 'dispatch;
            }
            0x82EE1B94 => {
    //   block [0x82EE1B94..0x82EE1BC0)
	// 82EE1B94: 4B39D6D5  bl 0x8227f268
	ctx.lr = 0x82EE1B98;
	sub_8227F268(ctx, base);
	// 82EE1B98: C1830008  lfs f12, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE1B9C: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE1BA0: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE1BA4: C0030000  lfs f0, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE1BA8: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE1BAC: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE1BB0: D181008C  stfs f12, 0x8c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EE1BB4: D1A10088  stfs f13, 0x88(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EE1BB8: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EE1BBC: 48000280  b 0x82ee1e3c
	pc = 0x82EE1E3C; continue 'dispatch;
            }
            0x82EE1BC0 => {
    //   block [0x82EE1BC0..0x82EE1CC8)
	// 82EE1BC0: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE1BC4: C07E0038  lfs f3, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82EE1BC8: EDA502F2  fmuls f13, f5, f11
	ctx.f[13].f64 = (((ctx.f[5].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE1BCC: C0BE003C  lfs f5, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82EE1BD0: ED8C02F2  fmuls f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE1BD4: C05E003C  lfs f2, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EE1BD8: ED680272  fmuls f11, f8, f9
	ctx.f[11].f64 = (((ctx.f[8].f64 * ctx.f[9].f64) as f32) as f64);
	// 82EE1BDC: C11E0034  lfs f8, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE1BE0: ED5F0272  fmuls f10, f31, f9
	ctx.f[10].f64 = (((ctx.f[31].f64 * ctx.f[9].f64) as f32) as f64);
	// 82EE1BE4: C03E0034  lfs f1, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EE1BE8: ED270272  fmuls f9, f7, f9
	ctx.f[9].f64 = (((ctx.f[7].f64 * ctx.f[9].f64) as f32) as f64);
	// 82EE1BEC: C0FE0038  lfs f7, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EE1BF0: FF202050  fneg f25, f4
	ctx.f[25].u64 = ctx.f[4].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE1BF4: C09E0034  lfs f4, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82EE1BF8: C31E0034  lfs f24, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 82EE1BFC: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82EE1C00: C3FE0038  lfs f31, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EE1C04: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EE1C08: C2FE0038  lfs f23, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 82EE1C0C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE1C10: ED08002A  fadds f8, f8, f0
	ctx.f[8].f64 = ((ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EE1C14: C3DE003C  lfs f30, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EE1C18: ECE7682A  fadds f7, f7, f13
	ctx.f[7].f64 = ((ctx.f[7].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE1C1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE1C20: ECA5602A  fadds f5, f5, f12
	ctx.f[5].f64 = ((ctx.f[5].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EE1C24: C3A80C1C  lfs f29, 0xc1c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3100 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EE1C28: EC840028  fsubs f4, f4, f0
	ctx.f[4].f64 = (((ctx.f[4].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE1C2C: 38E100A0  addi r7, r1, 0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + 160;
	// 82EE1C30: EC636828  fsubs f3, f3, f13
	ctx.f[3].f64 = (((ctx.f[3].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE1C34: EC426028  fsubs f2, f2, f12
	ctx.f[2].f64 = (((ctx.f[2].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE1C38: EC210028  fsubs f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE1C3C: EC00C02A  fadds f0, f0, f24
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[24].f64) as f32) as f64;
	// 82EE1C40: C31E003C  lfs f24, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 82EE1C44: EFFF6828  fsubs f31, f31, f13
	ctx.f[31].f64 = (((ctx.f[31].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE1C48: EDB7682A  fadds f13, f23, f13
	ctx.f[13].f64 = ((ctx.f[23].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE1C4C: C2FF005C  lfs f23, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 82EE1C50: ED08582A  fadds f8, f8, f11
	ctx.f[8].f64 = ((ctx.f[8].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EE1C54: D10100A0  stfs f8, 0xa0(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82EE1C58: ED07502A  fadds f8, f7, f10
	ctx.f[8].f64 = ((ctx.f[7].f64 + ctx.f[10].f64) as f32) as f64;
	// 82EE1C5C: D10100A4  stfs f8, 0xa4(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82EE1C60: EFDE6028  fsubs f30, f30, f12
	ctx.f[30].f64 = (((ctx.f[30].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE1C64: ED05482A  fadds f8, f5, f9
	ctx.f[8].f64 = ((ctx.f[5].f64 + ctx.f[9].f64) as f32) as f64;
	// 82EE1C68: D10100A8  stfs f8, 0xa8(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82EE1C6C: ED98602A  fadds f12, f24, f12
	ctx.f[12].f64 = ((ctx.f[24].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EE1C70: C31F0064  lfs f24, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 82EE1C74: ED04582A  fadds f8, f4, f11
	ctx.f[8].f64 = ((ctx.f[4].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EE1C78: D10100AC  stfs f8, 0xac(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82EE1C7C: ED03502A  fadds f8, f3, f10
	ctx.f[8].f64 = ((ctx.f[3].f64 + ctx.f[10].f64) as f32) as f64;
	// 82EE1C80: D10100B0  stfs f8, 0xb0(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82EE1C84: ED02482A  fadds f8, f2, f9
	ctx.f[8].f64 = ((ctx.f[2].f64 + ctx.f[9].f64) as f32) as f64;
	// 82EE1C88: D10100B4  stfs f8, 0xb4(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82EE1C8C: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EE1C90: D00100C4  stfs f0, 0xc4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EE1C94: ED015828  fsubs f8, f1, f11
	ctx.f[8].f64 = (((ctx.f[1].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EE1C98: D10100B8  stfs f8, 0xb8(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82EE1C9C: ED1F5028  fsubs f8, f31, f10
	ctx.f[8].f64 = (((ctx.f[31].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EE1CA0: D10100BC  stfs f8, 0xbc(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82EE1CA4: EC0D5028  fsubs f0, f13, f10
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EE1CA8: D00100C8  stfs f0, 0xc8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EE1CAC: ED1E4828  fsubs f8, f30, f9
	ctx.f[8].f64 = (((ctx.f[30].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EE1CB0: D10100C0  stfs f8, 0xc0(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82EE1CB4: FEC0E890  fmr f22, f29
	ctx.f[22].f64 = ctx.f[29].f64;
	// 82EE1CB8: EC0C4828  fsubs f0, f12, f9
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EE1CBC: D00100CC  stfs f0, 0xcc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EE1CC0: FF80D890  fmr f28, f27
	ctx.f[28].f64 = ctx.f[27].f64;
	// 82EE1CC4: FF40D890  fmr f26, f27
	ctx.f[26].f64 = ctx.f[27].f64;
	pc = 0x82EE1CC8; continue 'dispatch;
            }
            0x82EE1CC8 => {
    //   block [0x82EE1CC8..0x82EE1D20)
	// 82EE1CC8: C0070000  lfs f0, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE1CCC: ED40B828  fsubs f10, f0, f23
	ctx.f[10].f64 = (((ctx.f[0].f64 - ctx.f[23].f64) as f32) as f64);
	// 82EE1CD0: C17F005C  lfs f11, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE1CD4: C1A70008  lfs f13, 8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE1CD8: ED605828  fsubs f11, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EE1CDC: C19F0064  lfs f12, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE1CE0: EC0DC028  fsubs f0, f13, f24
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[24].f64) as f32) as f64);
	// 82EE1CE4: ED8D6028  fsubs f12, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE1CE8: EDAA0572  fmuls f13, f10, f21
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[21].f64) as f32) as f64);
	// 82EE1CEC: EC006E7A  fmadds f0, f0, f25, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[25].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE1CF0: EDAB02F2  fmuls f13, f11, f11
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE1CF4: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EE1CF8: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE1CFC: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE1D00: 40980020  bge cr6, 0x82ee1d20
	if !ctx.cr[6].lt {
	pc = 0x82EE1D20; continue 'dispatch;
	}
	// 82EE1D04: ED8D0772  fmuls f12, f13, f29
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EE1D08: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EE1D0C: 4099002C  ble cr6, 0x82ee1d38
	if !ctx.cr[6].gt {
	pc = 0x82EE1D38; continue 'dispatch;
	}
	// 82EE1D10: EFA06824  fdivs f29, f0, f13
	ctx.f[29].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EE1D14: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82EE1D18: FF806890  fmr f28, f13
	ctx.f[28].f64 = ctx.f[13].f64;
	// 82EE1D1C: 4800001C  b 0x82ee1d38
	pc = 0x82EE1D38; continue 'dispatch;
            }
            0x82EE1D20 => {
    //   block [0x82EE1D20..0x82EE1D38)
	// 82EE1D20: ED8D05B2  fmuls f12, f13, f22
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[22].f64) as f32) as f64);
	// 82EE1D24: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EE1D28: 40990010  ble cr6, 0x82ee1d38
	if !ctx.cr[6].gt {
	pc = 0x82EE1D38; continue 'dispatch;
	}
	// 82EE1D2C: EEC06824  fdivs f22, f0, f13
	ctx.f[22].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EE1D30: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EE1D34: FF406890  fmr f26, f13
	ctx.f[26].f64 = ctx.f[13].f64;
	pc = 0x82EE1D38; continue 'dispatch;
            }
            0x82EE1D38 => {
    //   block [0x82EE1D38..0x82EE1E3C)
	// 82EE1D38: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EE1D3C: 38E7000C  addi r7, r7, 0xc
	ctx.r[7].s64 = ctx.r[7].s64 + 12;
	// 82EE1D40: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82EE1D44: 4198FF84  blt cr6, 0x82ee1cc8
	if ctx.cr[6].lt {
	pc = 0x82EE1CC8; continue 'dispatch;
	}
	// 82EE1D48: C13F005C  lfs f9, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE1D4C: 1D6A000C  mulli r11, r10, 0xc
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EE1D50: FDA04890  fmr f13, f9
	ctx.f[13].f64 = ctx.f[9].f64;
	// 82EE1D54: 390100A0  addi r8, r1, 0xa0
	ctx.r[8].s64 = ctx.r[1].s64 + 160;
	// 82EE1D58: C11F0064  lfs f8, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE1D5C: EC1CD024  fdivs f0, f28, f26
	ctx.f[0].f64 = ((ctx.f[28].f64 / ctx.f[26].f64) as f32) as f64;
	// 82EE1D60: FD604090  fmr f11, f8
	ctx.f[11].f64 = ctx.f[8].f64;
	// 82EE1D64: D3610064  stfs f27, 0x64(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EE1D68: FD404090  fmr f10, f8
	ctx.f[10].f64 = ctx.f[8].f64;
	// 82EE1D6C: FCE04890  fmr f7, f9
	ctx.f[7].f64 = ctx.f[9].f64;
	// 82EE1D70: FCA04090  fmr f5, f8
	ctx.f[5].f64 = ctx.f[8].f64;
	// 82EE1D74: 1D49000C  mulli r10, r9, 0xc
	ctx.r[10].s32 = ((ctx.r[9].s32 as i64 * 12 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82EE1D78: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EE1D7C: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82EE1D80: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 82EE1D84: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EE1D88: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EE1D8C: 7FCA4A14  add r30, r10, r9
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82EE1D90: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EE1D94: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE1D98: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE1D9C: 394AAFB4  addi r10, r10, -0x504c
	ctx.r[10].s64 = ctx.r[10].s64 + -20556;
	// 82EE1DA0: C09E0000  lfs f4, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82EE1DA4: C07E0008  lfs f3, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82EE1DA8: ED435028  fsubs f10, f3, f10
	ctx.f[10].f64 = (((ctx.f[3].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EE1DAC: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 82EE1DB0: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE1DB4: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EE1DB8: FD604890  fmr f11, f9
	ctx.f[11].f64 = ctx.f[9].f64;
	// 82EE1DBC: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE1DC0: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE1DC4: ED645828  fsubs f11, f4, f11
	ctx.f[11].f64 = (((ctx.f[4].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EE1DC8: EC00502A  fadds f0, f0, f10
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64;
	// 82EE1DCC: EDAD582A  fadds f13, f13, f11
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EE1DD0: EC0001B2  fmuls f0, f0, f6
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[6].f64) as f32) as f64);
	// 82EE1DD4: EDAD01B2  fmuls f13, f13, f6
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[6].f64) as f32) as f64);
	// 82EE1DD8: EC05002A  fadds f0, f5, f0
	ctx.f[0].f64 = ((ctx.f[5].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EE1DDC: EDAD382A  fadds f13, f13, f7
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[7].f64) as f32) as f64;
	// 82EE1DE0: EC004028  fsubs f0, f0, f8
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EE1DE4: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EE1DE8: EDAD4828  fsubs f13, f13, f9
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EE1DEC: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EE1DF0: 4B39D479  bl 0x8227f268
	ctx.lr = 0x82EE1DF4;
	sub_8227F268(ctx, base);
	// 82EE1DF4: C01F005C  lfs f0, 0x5c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE1DF8: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE1DFC: ED80E02C  fsqrts f12, f28
	ctx.f[12].f64 = ((ctx.f[28].f64).sqrt() as f32) as f64;
	// 82EE1E00: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE1E04: C1230004  lfs f9, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE1E08: D1210088  stfs f9, 0x88(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EE1E0C: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE1E10: C1BF0064  lfs f13, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE1E14: ED406828  fsubs f10, f0, f13
	ctx.f[10].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE1E18: C0030000  lfs f0, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE1E1C: C1A30008  lfs f13, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE1E20: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EE1E24: D1A1008C  stfs f13, 0x8c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EE1E28: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE1E2C: ED6A5B7A  fmadds f11, f10, f13, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EE1E30: ED8B6024  fdivs f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 / ctx.f[12].f64) as f32) as f64;
	// 82EE1E34: FF0CD800  fcmpu cr6, f12, f27
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[27].f64);
	// 82EE1E38: 4098000C  bge cr6, 0x82ee1e44
	if !ctx.cr[6].lt {
	pc = 0x82EE1E44; continue 'dispatch;
	}
	pc = 0x82EE1E3C; continue 'dispatch;
            }
            0x82EE1E3C => {
    //   block [0x82EE1E3C..0x82EE1E44)
	// 82EE1E3C: D3610090  stfs f27, 0x90(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82EE1E40: 48000030  b 0x82ee1e70
	pc = 0x82EE1E70; continue 'dispatch;
            }
            0x82EE1E44 => {
    //   block [0x82EE1E44..0x82EE1E70)
	// 82EE1E44: C15E0000  lfs f10, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE1E48: ED80E02C  fsqrts f12, f28
	ctx.f[12].f64 = ((ctx.f[28].f64).sqrt() as f32) as f64;
	// 82EE1E4C: C17F005C  lfs f11, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE1E50: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EE1E54: C13F0064  lfs f9, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE1E58: C15E0008  lfs f10, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE1E5C: ED4A4828  fsubs f10, f10, f9
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EE1E60: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE1E64: EC0A037A  fmadds f0, f10, f13, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE1E68: EC006024  fdivs f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 82EE1E6C: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	pc = 0x82EE1E70; continue 'dispatch;
            }
            0x82EE1E70 => {
    //   block [0x82EE1E70..0x82EE1E84)
	// 82EE1E70: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE1E74: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EE1E78: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EE1E7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE1E80: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE1E84; continue 'dispatch;
            }
            0x82EE1E84 => {
    //   block [0x82EE1E84..0x82EE1E98)
	// 82EE1E84: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EE1E88: 809F0118  lwz r4, 0x118(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82EE1E8C: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82EE1E90: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EE1E94: 4BFFF835  bl 0x82ee16c8
	ctx.lr = 0x82EE1E98;
	sub_82EE16C8(ctx, base);
	pc = 0x82EE1E98; continue 'dispatch;
            }
            0x82EE1E98 => {
    //   block [0x82EE1E98..0x82EE1EA8)
	// 82EE1E98: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 82EE1E9C: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82EE1EA0: 4BDCBE69  bl 0x82cadd08
	ctx.lr = 0x82EE1EA4;
	sub_82CADCEC(ctx, base);
	// 82EE1EA4: 4BDC75B8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE1EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EE1EA8 size=76
    let mut pc: u32 = 0x82EE1EA8;
    'dispatch: loop {
        match pc {
            0x82EE1EA8 => {
    //   block [0x82EE1EA8..0x82EE1EF4)
	// 82EE1EA8: C0030108  lfs f0, 0x108(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE1EAC: EC020028  fsubs f0, f2, f0
	ctx.f[0].f64 = (((ctx.f[2].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE1EB0: C1A300C0  lfs f13, 0xc0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE1EB4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE1EB8: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 82EE1EBC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE1EC0: C16B0C18  lfs f11, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE1EC4: FF035800  fcmpu cr6, f3, f11
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[11].f64);
	// 82EE1EC8: 4098004C  bge cr6, 0x82ee1f14
	if !ctx.cr[6].lt {
		sub_82EE1F14(ctx, base);
		return;
	}
	// 82EE1ECC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE1ED0: C1A3010C  lfs f13, 0x10c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE1ED4: C18B0C4C  lfs f12, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE1ED8: ED4D0332  fmuls f10, f13, f12
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE1EDC: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EE1EE0: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 82EE1EE4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE1EE8: 4199000C  bgt cr6, 0x82ee1ef4
	if ctx.cr[6].gt {
		sub_82EE1EF4(ctx, base);
		return;
	}
	// 82EE1EEC: FC205890  fmr f1, f11
	ctx.f[1].f64 = ctx.f[11].f64;
	// 82EE1EF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE1EF4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EE1EF4 size=32
    let mut pc: u32 = 0x82EE1EF4;
    'dispatch: loop {
        match pc {
            0x82EE1EF4 => {
    //   block [0x82EE1EF4..0x82EE1F14)
	// 82EE1EF4: EDA06824  fdivs f13, f0, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EE1EF8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE1EFC: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE1F00: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE1F04: EDAC0028  fsubs f13, f12, f0
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE1F08: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE1F0C: EC200072  fmuls f1, f0, f1
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 82EE1F10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE1F14(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EE1F14 size=60
    let mut pc: u32 = 0x82EE1F14;
    'dispatch: loop {
        match pc {
            0x82EE1F14 => {
    //   block [0x82EE1F14..0x82EE1F50)
	// 82EE1F14: FF030800  fcmpu cr6, f3, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[1].f64);
	// 82EE1F18: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 82EE1F1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE1F20: C1A3010C  lfs f13, 0x10c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE1F24: C18B0C4C  lfs f12, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE1F28: ED8D0332  fmuls f12, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE1F2C: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EE1F30: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 82EE1F34: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE1F38: 41990018  bgt cr6, 0x82ee1f50
	if ctx.cr[6].gt {
		sub_82EE1F50(ctx, base);
		return;
	}
	// 82EE1F3C: C0230028  lfs f1, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EE1F40: FF030800  fcmpu cr6, f3, f1
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[1].f64);
	// 82EE1F44: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 82EE1F48: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 82EE1F4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE1F50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EE1F50 size=32
    let mut pc: u32 = 0x82EE1F50;
    'dispatch: loop {
        match pc {
            0x82EE1F50 => {
    //   block [0x82EE1F50..0x82EE1F70)
	// 82EE1F50: EDA06824  fdivs f13, f0, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EE1F54: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE1F58: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE1F5C: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE1F60: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE1F64: EDAD0072  fmuls f13, f13, f1
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[1].f64) as f32) as f64);
	// 82EE1F68: EC2068FA  fmadds f1, f0, f3, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[3].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE1F6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE1F70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EE1F70 size=96
    let mut pc: u32 = 0x82EE1F70;
    'dispatch: loop {
        match pc {
            0x82EE1F70 => {
    //   block [0x82EE1F70..0x82EE1FB4)
	// 82EE1F70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE1F74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EE1F78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EE1F7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EE1F80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE1F84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE1F88: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EE1F8C: 809F0098  lwz r4, 0x98(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82EE1F90: 7F04F000  cmpw cr6, r4, r30
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[30].s32, &mut ctx.xer);
	// 82EE1F94: 419A0024  beq cr6, 0x82ee1fb8
	if ctx.cr[6].eq {
	pc = 0x82EE1FB8; continue 'dispatch;
	}
	// 82EE1F98: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 82EE1F9C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE1FA0: 41820014  beq 0x82ee1fb4
	if ctx.cr[0].eq {
	pc = 0x82EE1FB4; continue 'dispatch;
	}
	// 82EE1FA4: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EE1FA8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EE1FAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE1FB0: 4E800421  bctrl
	ctx.lr = 0x82EE1FB4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EE1FB4 => {
    //   block [0x82EE1FB4..0x82EE1FB8)
	// 82EE1FB4: 93DF0098  stw r30, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[30].u32 ) };
	pc = 0x82EE1FB8; continue 'dispatch;
            }
            0x82EE1FB8 => {
    //   block [0x82EE1FB8..0x82EE1FD0)
	// 82EE1FB8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EE1FBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE1FC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EE1FC4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EE1FC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EE1FCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE1FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE1FD0 size=336
    let mut pc: u32 = 0x82EE1FD0;
    'dispatch: loop {
        match pc {
            0x82EE1FD0 => {
    //   block [0x82EE1FD0..0x82EE2060)
	// 82EE1FD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE1FD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EE1FD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EE1FDC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE1FE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE1FE4: 817F00D4  lwz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EE1FE8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE1FEC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EE1FF0: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE1FF4: 419A00B8  beq cr6, 0x82ee20ac
	if ctx.cr[6].eq {
	pc = 0x82EE20AC; continue 'dispatch;
	}
	// 82EE1FF8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EE1FFC: C1AB0018  lfs f13, 0x18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE2000: C00A0C18  lfs f0, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2004: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE2008: 419A00A0  beq cr6, 0x82ee20a8
	if ctx.cr[6].eq {
	pc = 0x82EE20A8; continue 'dispatch;
	}
	// 82EE200C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE2010: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EE2014: 389F005C  addi r4, r31, 0x5c
	ctx.r[4].s64 = ctx.r[31].s64 + 92;
	// 82EE2018: 38AB0004  addi r5, r11, 4
	ctx.r[5].s64 = ctx.r[11].s64 + 4;
	// 82EE201C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE2020: 816A0050  lwz r11, 0x50(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EE2024: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE2028: 4E800421  bctrl
	ctx.lr = 0x82EE202C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE202C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE2030: 41820030  beq 0x82ee2060
	if ctx.cr[0].eq {
	pc = 0x82EE2060; continue 'dispatch;
	}
	// 82EE2034: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE2038: 38BF0080  addi r5, r31, 0x80
	ctx.r[5].s64 = ctx.r[31].s64 + 128;
	// 82EE203C: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE2040: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EE2044: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE2048: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82EE204C: 816A0050  lwz r11, 0x50(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EE2050: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE2054: 4E800421  bctrl
	ctx.lr = 0x82EE2058;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE2058: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE205C: 4082004C  bne 0x82ee20a8
	if !ctx.cr[0].eq {
	pc = 0x82EE20A8; continue 'dispatch;
	}
            }
            0x82EE2060 => {
    //   block [0x82EE2060..0x82EE207C)
	// 82EE2060: 817F0110  lwz r11, 0x110(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EE2064: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82EE2068: 419A0014  beq cr6, 0x82ee207c
	if ctx.cr[6].eq {
	pc = 0x82EE207C; continue 'dispatch;
	}
	// 82EE206C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82EE2070: 419A000C  beq cr6, 0x82ee207c
	if ctx.cr[6].eq {
	pc = 0x82EE207C; continue 'dispatch;
	}
	// 82EE2074: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82EE2078: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE207C; continue 'dispatch;
            }
            0x82EE207C => {
    //   block [0x82EE207C..0x82EE20A8)
	// 82EE207C: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE2080: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EE2084: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 82EE2088: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EE208C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE2090: 409A007C  bne cr6, 0x82ee210c
	if !ctx.cr[6].eq {
	pc = 0x82EE210C; continue 'dispatch;
	}
	// 82EE2094: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82EE2098: C01F0038  lfs f0, 0x38(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE209C: D01F00FC  stfs f0, 0xfc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82EE20A0: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82EE20A4: 48000068  b 0x82ee210c
	pc = 0x82EE210C; continue 'dispatch;
            }
            0x82EE20A8 => {
    //   block [0x82EE20A8..0x82EE20AC)
	// 82EE20A8: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	pc = 0x82EE20AC; continue 'dispatch;
            }
            0x82EE20AC => {
    //   block [0x82EE20AC..0x82EE210C)
	// 82EE20AC: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE20B0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE20B4: D01F008C  stfs f0, 0x8c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EE20B8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE20BC: D01F0090  stfs f0, 0x90(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82EE20C0: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE20C4: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82EE20C8: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE20CC: C00B0018  lfs f0, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE20D0: D01F00D8  stfs f0, 0xd8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EE20D4: D01F00DC  stfs f0, 0xdc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EE20D8: C00B0020  lfs f0, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE20DC: D01F00E4  stfs f0, 0xe4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EE20E0: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE20E4: D01F00E0  stfs f0, 0xe0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EE20E8: C00B001C  lfs f0, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE20EC: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EE20F0: C00B0024  lfs f0, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE20F4: D01F00EC  stfs f0, 0xec(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82EE20F8: 915F00F4  stw r10, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[10].u32 ) };
	// 82EE20FC: 817F0110  lwz r11, 0x110(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EE2100: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82EE2104: 419A0008  beq cr6, 0x82ee210c
	if ctx.cr[6].eq {
	pc = 0x82EE210C; continue 'dispatch;
	}
	// 82EE2108: 915F0110  stw r10, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[10].u32 ) };
	pc = 0x82EE210C; continue 'dispatch;
            }
            0x82EE210C => {
    //   block [0x82EE210C..0x82EE2120)
	// 82EE210C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EE2110: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE2114: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EE2118: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EE211C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE2120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE2120 size=372
    let mut pc: u32 = 0x82EE2120;
    'dispatch: loop {
        match pc {
            0x82EE2120 => {
    //   block [0x82EE2120..0x82EE2168)
	// 82EE2120: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE2124: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EE2128: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EE212C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE2130: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE2134: 817F0110  lwz r11, 0x110(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 82EE2138: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82EE213C: 41980050  blt cr6, 0x82ee218c
	if ctx.cr[6].lt {
	pc = 0x82EE218C; continue 'dispatch;
	}
	// 82EE2140: 419A0044  beq cr6, 0x82ee2184
	if ctx.cr[6].eq {
	pc = 0x82EE2184; continue 'dispatch;
	}
	// 82EE2144: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82EE2148: 419A0020  beq cr6, 0x82ee2168
	if ctx.cr[6].eq {
	pc = 0x82EE2168; continue 'dispatch;
	}
	// 82EE214C: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82EE2150: 409A0130  bne cr6, 0x82ee2280
	if !ctx.cr[6].eq {
	pc = 0x82EE2280; continue 'dispatch;
	}
	// 82EE2154: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82EE2158: 4BFFFE19  bl 0x82ee1f70
	ctx.lr = 0x82EE215C;
	sub_82EE1F70(ctx, base);
	// 82EE215C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE2160: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2164: 48000018  b 0x82ee217c
	pc = 0x82EE217C; continue 'dispatch;
            }
            0x82EE2168 => {
    //   block [0x82EE2168..0x82EE217C)
	// 82EE2168: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EE216C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE2170: 4BFFFE01  bl 0x82ee1f70
	ctx.lr = 0x82EE2174;
	sub_82EE1F70(ctx, base);
	// 82EE2174: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE2178: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82EE217C; continue 'dispatch;
            }
            0x82EE217C => {
    //   block [0x82EE217C..0x82EE2184)
	// 82EE217C: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EE2180: 48000100  b 0x82ee2280
	pc = 0x82EE2280; continue 'dispatch;
            }
            0x82EE2184 => {
    //   block [0x82EE2184..0x82EE218C)
	// 82EE2184: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82EE2188: 480000F0  b 0x82ee2278
	pc = 0x82EE2278; continue 'dispatch;
            }
            0x82EE218C => {
    //   block [0x82EE218C..0x82EE21C0)
	// 82EE218C: C1BF0108  lfs f13, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE2190: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE2194: C01F010C  lfs f0, 0x10c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2198: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE219C: C1BF00E4  lfs f13, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE21A0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE21A4: 4098002C  bge cr6, 0x82ee21d0
	if !ctx.cr[6].lt {
	pc = 0x82EE21D0; continue 'dispatch;
	}
	// 82EE21A8: C01F00EC  lfs f0, 0xec(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE21AC: C1BF0028  lfs f13, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE21B0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE21B4: 4098000C  bge cr6, 0x82ee21c0
	if !ctx.cr[6].lt {
	pc = 0x82EE21C0; continue 'dispatch;
	}
	// 82EE21B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EE21BC: 48000014  b 0x82ee21d0
	pc = 0x82EE21D0; continue 'dispatch;
            }
            0x82EE21C0 => {
    //   block [0x82EE21C0..0x82EE21D0)
	// 82EE21C0: C1BF00E8  lfs f13, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE21C4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE21C8: 40980008  bge cr6, 0x82ee21d0
	if !ctx.cr[6].lt {
	pc = 0x82EE21D0; continue 'dispatch;
	}
	// 82EE21CC: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	pc = 0x82EE21D0; continue 'dispatch;
            }
            0x82EE21D0 => {
    //   block [0x82EE21D0..0x82EE2200)
	// 82EE21D0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE21D4: 41820064  beq 0x82ee2238
	if ctx.cr[0].eq {
	pc = 0x82EE2238; continue 'dispatch;
	}
	// 82EE21D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE21DC: C1BF0030  lfs f13, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE21E0: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE21E4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE21E8: 40990020  ble cr6, 0x82ee2208
	if !ctx.cr[6].gt {
	pc = 0x82EE2208; continue 'dispatch;
	}
	// 82EE21EC: 817F0098  lwz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82EE21F0: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EE21F4: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82EE21F8: 419A0008  beq cr6, 0x82ee2200
	if ctx.cr[6].eq {
	pc = 0x82EE2200; continue 'dispatch;
	}
	// 82EE21FC: D1BF00FC  stfs f13, 0xfc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	pc = 0x82EE2200; continue 'dispatch;
            }
            0x82EE2200 => {
    //   block [0x82EE2200..0x82EE2208)
	// 82EE2200: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82EE2204: 48000074  b 0x82ee2278
	pc = 0x82EE2278; continue 'dispatch;
            }
            0x82EE2208 => {
    //   block [0x82EE2208..0x82EE2230)
	// 82EE2208: C1BF0034  lfs f13, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE220C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE2210: 40990064  ble cr6, 0x82ee2274
	if !ctx.cr[6].gt {
	pc = 0x82EE2274; continue 'dispatch;
	}
	// 82EE2214: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE2218: 815F0098  lwz r10, 0x98(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82EE221C: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 82EE2220: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2224: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EE2228: 419A0008  beq cr6, 0x82ee2230
	if ctx.cr[6].eq {
	pc = 0x82EE2230; continue 'dispatch;
	}
	// 82EE222C: D1BF00FC  stfs f13, 0xfc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	pc = 0x82EE2230; continue 'dispatch;
            }
            0x82EE2230 => {
    //   block [0x82EE2230..0x82EE2238)
	// 82EE2230: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EE2234: 48000044  b 0x82ee2278
	pc = 0x82EE2278; continue 'dispatch;
            }
            0x82EE2238 => {
    //   block [0x82EE2238..0x82EE2268)
	// 82EE2238: 897F0024  lbz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EE223C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE2240: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE2244: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2248: 41820028  beq 0x82ee2270
	if ctx.cr[0].eq {
	pc = 0x82EE2270; continue 'dispatch;
	}
	// 82EE224C: C1BF00E8  lfs f13, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE2250: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE2254: 40980020  bge cr6, 0x82ee2274
	if !ctx.cr[6].lt {
	pc = 0x82EE2274; continue 'dispatch;
	}
	// 82EE2258: C01F0028  lfs f0, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE225C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE2260: 40980008  bge cr6, 0x82ee2268
	if !ctx.cr[6].lt {
	pc = 0x82EE2268; continue 'dispatch;
	}
	// 82EE2264: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	pc = 0x82EE2268; continue 'dispatch;
            }
            0x82EE2268 => {
    //   block [0x82EE2268..0x82EE2270)
	// 82EE2268: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EE226C: 4800000C  b 0x82ee2278
	pc = 0x82EE2278; continue 'dispatch;
            }
            0x82EE2270 => {
    //   block [0x82EE2270..0x82EE2274)
	// 82EE2270: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	pc = 0x82EE2274; continue 'dispatch;
            }
            0x82EE2274 => {
    //   block [0x82EE2274..0x82EE2278)
	// 82EE2274: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x82EE2278; continue 'dispatch;
            }
            0x82EE2278 => {
    //   block [0x82EE2278..0x82EE2280)
	// 82EE2278: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE227C: 4BFFFCF5  bl 0x82ee1f70
	ctx.lr = 0x82EE2280;
	sub_82EE1F70(ctx, base);
	pc = 0x82EE2280; continue 'dispatch;
            }
            0x82EE2280 => {
    //   block [0x82EE2280..0x82EE2294)
	// 82EE2280: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EE2284: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE2288: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EE228C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EE2290: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE2298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE2298 size=148
    let mut pc: u32 = 0x82EE2298;
    'dispatch: loop {
        match pc {
            0x82EE2298 => {
    //   block [0x82EE2298..0x82EE22E8)
	// 82EE2298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE229C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EE22A0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE22A4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EE22A8: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 82EE22AC: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 82EE22B0: 39089128  addi r8, r8, -0x6ed8
	ctx.r[8].s64 = ctx.r[8].s64 + -28376;
	// 82EE22B4: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82EE22B8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE22BC: C00B008C  lfs f0, 0x8c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE22C0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EE22C4: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 82EE22C8: 806A0264  lwz r3, 0x264(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(612 as u32) ) } as u64;
	// 82EE22CC: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EE22D0: C00B0090  lfs f0, 0x90(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE22D4: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82EE22D8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EE22DC: C00B0094  lfs f0, 0x94(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE22E0: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EE22E4: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	pc = 0x82EE22E8; continue 'dispatch;
            }
            0x82EE22E8 => {
    //   block [0x82EE22E8..0x82EE232C)
	// 82EE22E8: 90A60000  stw r5, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82EE22EC: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82EE22F0: 4200FFF8  bdnz 0x82ee22e8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EE22E8; continue 'dispatch;
	}
	// 82EE22F4: 98A100A8  stb r5, 0xa8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[5].u8 ) };
	// 82EE22F8: C02A0010  lfs f1, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EE22FC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE2300: C04B00E8  lfs f2, 0xe8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(232 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EE2304: 808B0058  lwz r4, 0x58(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EE2308: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EE230C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EE2310: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE2314: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE2318: 4E800421  bctrl
	ctx.lr = 0x82EE231C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE231C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82EE2320: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE2324: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EE2328: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE2330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE2330 size=2056
    let mut pc: u32 = 0x82EE2330;
    'dispatch: loop {
        match pc {
            0x82EE2330 => {
    //   block [0x82EE2330..0x82EE23CC)
	// 82EE2330: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE2334: 4BDC70D5  bl 0x82ca9408
	ctx.lr = 0x82EE2338;
	sub_82CA93D0(ctx, base);
	// 82EE2338: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82EE233C: 4BDCB965  bl 0x82cadca0
	ctx.lr = 0x82EE2340;
	sub_82CADCA0(ctx, base);
	// 82EE2340: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE2344: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE2348: FF600890  fmr f27, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[27].f64 = ctx.f[1].f64;
	// 82EE234C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EE2350: FDE01090  fmr f15, f2
	ctx.f[15].f64 = ctx.f[2].f64;
	// 82EE2354: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EE2358: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EE235C: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 82EE2360: C22B0C18  lfs f17, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[17].f64 = (tmp.f32 as f64);
	// 82EE2364: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE2368: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EE236C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EE2370: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE2374: D23E0004  stfs f17, 4(r30)
	tmp.f32 = (ctx.f[17].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EE2378: D23E0008  stfs f17, 8(r30)
	tmp.f32 = (ctx.f[17].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EE237C: D23E000C  stfs f17, 0xc(r30)
	tmp.f32 = (ctx.f[17].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EE2380: D23E0010  stfs f17, 0x10(r30)
	tmp.f32 = (ctx.f[17].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EE2384: C1AB0BFC  lfs f13, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE2388: D23E0014  stfs f17, 0x14(r30)
	tmp.f32 = (ctx.f[17].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EE238C: D23E0018  stfs f17, 0x18(r30)
	tmp.f32 = (ctx.f[17].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EE2390: D23E001C  stfs f17, 0x1c(r30)
	tmp.f32 = (ctx.f[17].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EE2394: D23E0020  stfs f17, 0x20(r30)
	tmp.f32 = (ctx.f[17].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EE2398: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE239C: C19F0074  lfs f12, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE23A0: C01F0028  lfs f0, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE23A4: C17F0020  lfs f11, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE23A8: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EE23AC: EEAC5B7A  fmadds f21, f12, f13, f11
	ctx.f[21].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EE23B0: C24B0010  lfs f18, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[18].f64 = (tmp.f32 as f64);
	// 82EE23B4: FF009000  fcmpu cr6, f0, f18
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[18].f64);
	// 82EE23B8: 40980014  bge cr6, 0x82ee23cc
	if !ctx.cr[6].lt {
	pc = 0x82EE23CC; continue 'dispatch;
	}
	// 82EE23BC: EC00902A  fadds f0, f0, f18
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[18].f64) as f32) as f64;
	// 82EE23C0: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE23C4: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EE23C8: 48000008  b 0x82ee23d0
	pc = 0x82EE23D0; continue 'dispatch;
            }
            0x82EE23CC => {
    //   block [0x82EE23CC..0x82EE23D0)
	// 82EE23CC: D2410054  stfs f18, 0x54(r1)
	tmp.f32 = (ctx.f[18].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	pc = 0x82EE23D0; continue 'dispatch;
            }
            0x82EE23D0 => {
    //   block [0x82EE23D0..0x82EE23EC)
	// 82EE23D0: FF1B8800  fcmpu cr6, f27, f17
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[17].f64);
	// 82EE23D4: 409A0018  bne cr6, 0x82ee23ec
	if !ctx.cr[6].eq {
	pc = 0x82EE23EC; continue 'dispatch;
	}
	// 82EE23D8: C01F00C8  lfs f0, 0xc8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE23DC: C1BF0104  lfs f13, 0x104(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE23E0: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE23E4: FF0F6800  fcmpu cr6, f15, f13
	ctx.cr[6].compare_f64(ctx.f[15].f64, ctx.f[13].f64);
	// 82EE23E8: 41990008  bgt cr6, 0x82ee23f0
	if ctx.cr[6].gt {
	pc = 0x82EE23F0; continue 'dispatch;
	}
	pc = 0x82EE23EC; continue 'dispatch;
            }
            0x82EE23EC => {
    //   block [0x82EE23EC..0x82EE23F0)
	// 82EE23EC: EC12ABF8  fmsubs f0, f18, f15, f21
	ctx.f[0].f64 = (((ctx.f[18].f64 * ctx.f[15].f64 - ctx.f[21].f64) as f32) as f64);
	pc = 0x82EE23F0; continue 'dispatch;
            }
            0x82EE23F0 => {
    //   block [0x82EE23F0..0x82EE2408)
	// 82EE23F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE23F4: C1AB0A7C  lfs f13, 0xa7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2684 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE23F8: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE23FC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE2400: 40980008  bge cr6, 0x82ee2408
	if !ctx.cr[6].lt {
	pc = 0x82EE2408; continue 'dispatch;
	}
	// 82EE2404: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EE2408; continue 'dispatch;
            }
            0x82EE2408 => {
    //   block [0x82EE2408..0x82EE24EC)
	// 82EE2408: C1BF00A4  lfs f13, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE240C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EE2410: C17F00BC  lfs f11, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE2414: EDAD06F2  fmuls f13, f13, f27
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EE2418: C19F00A0  lfs f12, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE241C: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE2420: C15F00B8  lfs f10, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE2424: ED8C06F2  fmuls f12, f12, f27
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EE2428: C13F009C  lfs f9, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE242C: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE2430: C11F00B4  lfs f8, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE2434: ED2906F2  fmuls f9, f9, f27
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EE2438: ED080032  fmuls f8, f8, f0
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE243C: C0FF0064  lfs f7, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EE2440: C0DF0060  lfs f6, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EE2444: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EE2448: C0BF005C  lfs f5, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82EE244C: EC0B682A  fadds f0, f11, f13
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE2450: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EE2454: EDAA602A  fadds f13, f10, f12
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EE2458: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EE245C: ED88482A  fadds f12, f8, f9
	ctx.f[12].f64 = ((ctx.f[8].f64 + ctx.f[9].f64) as f32) as f64;
	// 82EE2460: D1810060  stfs f12, 0x60(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EE2464: ED67002A  fadds f11, f7, f0
	ctx.f[11].f64 = ((ctx.f[7].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EE2468: D17E000C  stfs f11, 0xc(r30)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EE246C: ED46682A  fadds f10, f6, f13
	ctx.f[10].f64 = ((ctx.f[6].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE2470: D15E0008  stfs f10, 8(r30)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EE2474: ED85602A  fadds f12, f5, f12
	ctx.f[12].f64 = ((ctx.f[5].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EE2478: D19E0004  stfs f12, 4(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EE247C: D37E0014  stfs f27, 0x14(r30)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EE2480: 4B39CDE9  bl 0x8227f268
	ctx.lr = 0x82EE2484;
	sub_8227F268(ctx, base);
	// 82EE2484: 815F0058  lwz r10, 0x58(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EE2488: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE248C: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE2490: C01F00C0  lfs f0, 0xc0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2494: C1830008  lfs f12, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE2498: FCC00090  fmr f6, f0
	ctx.f[6].f64 = ctx.f[0].f64;
	// 82EE249C: FEE00090  fmr f23, f0
	ctx.f[23].f64 = ctx.f[0].f64;
	// 82EE24A0: C1BF0048  lfs f13, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE24A4: FEC00090  fmr f22, f0
	ctx.f[22].f64 = ctx.f[0].f64;
	// 82EE24A8: C1630000  lfs f11, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE24AC: C14A0054  lfs f10, 0x54(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(84 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE24B0: ECF5D82A  fadds f7, f21, f27
	ctx.f[7].f64 = ((ctx.f[21].f64 + ctx.f[27].f64) as f32) as f64;
	// 82EE24B4: EC0C02B2  fmuls f0, f12, f10
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EE24B8: C34B0BEC  lfs f26, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82EE24BC: C12A004C  lfs f9, 0x4c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(76 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE24C0: EDDBA828  fsubs f14, f27, f21
	ctx.f[14].f64 = (((ctx.f[27].f64 - ctx.f[21].f64) as f32) as f64);
	// 82EE24C4: D0E1005C  stfs f7, 0x5c(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EE24C8: FD008890  fmr f8, f17
	ctx.f[8].f64 = ctx.f[17].f64;
	// 82EE24CC: D0C10050  stfs f6, 0x50(r1)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EE24D0: FE80D090  fmr f20, f26
	ctx.f[20].f64 = ctx.f[26].f64;
	// 82EE24D4: FE60D090  fmr f19, f26
	ctx.f[19].f64 = ctx.f[26].f64;
	// 82EE24D8: FF806850  fneg f28, f13
	ctx.f[28].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE24DC: FFC06890  fmr f30, f13
	ctx.f[30].f64 = ctx.f[13].f64;
	// 82EE24E0: EE0B027A  fmadds f16, f11, f9, f0
	ctx.f[16].f64 = (((ctx.f[11].f64 * ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE24E4: 7D2B4B79  or. r11, r9, r9
	ctx.r[11].u64 = ctx.r[9].u64 | ctx.r[9].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE24E8: 418200E4  beq 0x82ee25cc
	if ctx.cr[0].eq {
	pc = 0x82EE25CC; continue 'dispatch;
	}
	pc = 0x82EE24EC; continue 'dispatch;
            }
            0x82EE24EC => {
    //   block [0x82EE24EC..0x82EE2520)
	// 82EE24EC: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE24F0: FF0D3800  fcmpu cr6, f13, f7
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[7].f64);
	// 82EE24F4: 419900D8  bgt cr6, 0x82ee25cc
	if ctx.cr[6].gt {
	pc = 0x82EE25CC; continue 'dispatch;
	}
	// 82EE24F8: FF0DD800  fcmpu cr6, f13, f27
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[27].f64);
	// 82EE24FC: 40980034  bge cr6, 0x82ee2530
	if !ctx.cr[6].lt {
	pc = 0x82EE2530; continue 'dispatch;
	}
	// 82EE2500: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2504: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EE2508: 40990028  ble cr6, 0x82ee2530
	if !ctx.cr[6].gt {
	pc = 0x82EE2530; continue 'dispatch;
	}
	// 82EE250C: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2510: FF003000  fcmpu cr6, f0, f6
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[6].f64);
	// 82EE2514: 4098000C  bge cr6, 0x82ee2520
	if !ctx.cr[6].lt {
	pc = 0x82EE2520; continue 'dispatch;
	}
	// 82EE2518: FCC00090  fmr f6, f0
	ctx.f[6].f64 = ctx.f[0].f64;
	// 82EE251C: D0C10050  stfs f6, 0x50(r1)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	pc = 0x82EE2520; continue 'dispatch;
            }
            0x82EE2520 => {
    //   block [0x82EE2520..0x82EE2530)
	// 82EE2520: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2524: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82EE2528: 40980008  bge cr6, 0x82ee2530
	if !ctx.cr[6].lt {
	pc = 0x82EE2530; continue 'dispatch;
	}
	// 82EE252C: FF400090  fmr f26, f0
	ctx.f[26].f64 = ctx.f[0].f64;
	pc = 0x82EE2530; continue 'dispatch;
            }
            0x82EE2530 => {
    //   block [0x82EE2530..0x82EE254C)
	// 82EE2530: FF0DD800  fcmpu cr6, f13, f27
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[27].f64);
	// 82EE2534: 4099002C  ble cr6, 0x82ee2560
	if !ctx.cr[6].gt {
	pc = 0x82EE2560; continue 'dispatch;
	}
	// 82EE2538: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE253C: FF00B000  fcmpu cr6, f0, f22
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[22].f64);
	// 82EE2540: 4098000C  bge cr6, 0x82ee254c
	if !ctx.cr[6].lt {
	pc = 0x82EE254C; continue 'dispatch;
	}
	// 82EE2544: FEC00090  fmr f22, f0
	ctx.f[22].f64 = ctx.f[0].f64;
	// 82EE2548: FFC06890  fmr f30, f13
	ctx.f[30].f64 = ctx.f[13].f64;
	pc = 0x82EE254C; continue 'dispatch;
            }
            0x82EE254C => {
    //   block [0x82EE254C..0x82EE2560)
	// 82EE254C: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2550: FF009800  fcmpu cr6, f0, f19
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[19].f64);
	// 82EE2554: 4098003C  bge cr6, 0x82ee2590
	if !ctx.cr[6].lt {
	pc = 0x82EE2590; continue 'dispatch;
	}
	// 82EE2558: FE600090  fmr f19, f0
	ctx.f[19].f64 = ctx.f[0].f64;
	// 82EE255C: 48000034  b 0x82ee2590
	pc = 0x82EE2590; continue 'dispatch;
            }
            0x82EE2560 => {
    //   block [0x82EE2560..0x82EE2580)
	// 82EE2560: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE2564: FF0CD800  fcmpu cr6, f12, f27
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[27].f64);
	// 82EE2568: 40980028  bge cr6, 0x82ee2590
	if !ctx.cr[6].lt {
	pc = 0x82EE2590; continue 'dispatch;
	}
	// 82EE256C: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2570: FF00B800  fcmpu cr6, f0, f23
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[23].f64);
	// 82EE2574: 4098000C  bge cr6, 0x82ee2580
	if !ctx.cr[6].lt {
	pc = 0x82EE2580; continue 'dispatch;
	}
	// 82EE2578: FEE00090  fmr f23, f0
	ctx.f[23].f64 = ctx.f[0].f64;
	// 82EE257C: FF806090  fmr f28, f12
	ctx.f[28].f64 = ctx.f[12].f64;
	pc = 0x82EE2580; continue 'dispatch;
            }
            0x82EE2580 => {
    //   block [0x82EE2580..0x82EE2590)
	// 82EE2580: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2584: FF00A000  fcmpu cr6, f0, f20
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[20].f64);
	// 82EE2588: 40980008  bge cr6, 0x82ee2590
	if !ctx.cr[6].lt {
	pc = 0x82EE2590; continue 'dispatch;
	}
	// 82EE258C: FE800090  fmr f20, f0
	ctx.f[20].f64 = ctx.f[0].f64;
	pc = 0x82EE2590; continue 'dispatch;
            }
            0x82EE2590 => {
    //   block [0x82EE2590..0x82EE25A4)
	// 82EE2590: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2594: FF003800  fcmpu cr6, f0, f7
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[7].f64);
	// 82EE2598: 4098000C  bge cr6, 0x82ee25a4
	if !ctx.cr[6].lt {
	pc = 0x82EE25A4; continue 'dispatch;
	}
	// 82EE259C: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	// 82EE25A0: 48000008  b 0x82ee25a8
	pc = 0x82EE25A8; continue 'dispatch;
            }
            0x82EE25A4 => {
    //   block [0x82EE25A4..0x82EE25A8)
	// 82EE25A4: FD803890  fmr f12, f7
	ctx.f[12].f64 = ctx.f[7].f64;
	pc = 0x82EE25A8; continue 'dispatch;
            }
            0x82EE25A8 => {
    //   block [0x82EE25A8..0x82EE25B4)
	// 82EE25A8: FF0D7000  fcmpu cr6, f13, f14
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[14].f64);
	// 82EE25AC: 41990008  bgt cr6, 0x82ee25b4
	if ctx.cr[6].gt {
	pc = 0x82EE25B4; continue 'dispatch;
	}
	// 82EE25B0: FDA07090  fmr f13, f14
	ctx.f[13].f64 = ctx.f[14].f64;
	pc = 0x82EE25B4; continue 'dispatch;
            }
            0x82EE25B4 => {
    //   block [0x82EE25B4..0x82EE25CC)
	// 82EE25B4: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE25B8: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE25BC: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EE25C0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE25C4: ED0D403A  fmadds f8, f13, f0, f8
	ctx.f[8].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 82EE25C8: 4082FF24  bne 0x82ee24ec
	if !ctx.cr[0].eq {
	pc = 0x82EE24EC; continue 'dispatch;
	}
	pc = 0x82EE25CC; continue 'dispatch;
            }
            0x82EE25CC => {
    //   block [0x82EE25CC..0x82EE25D4)
	// 82EE25CC: 8169001C  lwz r11, 0x1c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE25D0: 480000CC  b 0x82ee269c
	pc = 0x82EE269C; continue 'dispatch;
            }
            0x82EE25D4 => {
    //   block [0x82EE25D4..0x82EE2608)
	// 82EE25D4: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE25D8: FF0C7000  fcmpu cr6, f12, f14
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[14].f64);
	// 82EE25DC: 419800C8  blt cr6, 0x82ee26a4
	if ctx.cr[6].lt {
	pc = 0x82EE26A4; continue 'dispatch;
	}
	// 82EE25E0: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE25E4: FF0DD800  fcmpu cr6, f13, f27
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[27].f64);
	// 82EE25E8: 40980030  bge cr6, 0x82ee2618
	if !ctx.cr[6].lt {
	pc = 0x82EE2618; continue 'dispatch;
	}
	// 82EE25EC: FF0CD800  fcmpu cr6, f12, f27
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[27].f64);
	// 82EE25F0: 40990028  ble cr6, 0x82ee2618
	if !ctx.cr[6].gt {
	pc = 0x82EE2618; continue 'dispatch;
	}
	// 82EE25F4: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE25F8: FF003000  fcmpu cr6, f0, f6
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[6].f64);
	// 82EE25FC: 4098000C  bge cr6, 0x82ee2608
	if !ctx.cr[6].lt {
	pc = 0x82EE2608; continue 'dispatch;
	}
	// 82EE2600: FCC00090  fmr f6, f0
	ctx.f[6].f64 = ctx.f[0].f64;
	// 82EE2604: D0C10050  stfs f6, 0x50(r1)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	pc = 0x82EE2608; continue 'dispatch;
            }
            0x82EE2608 => {
    //   block [0x82EE2608..0x82EE2618)
	// 82EE2608: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE260C: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82EE2610: 40980008  bge cr6, 0x82ee2618
	if !ctx.cr[6].lt {
	pc = 0x82EE2618; continue 'dispatch;
	}
	// 82EE2614: FF400090  fmr f26, f0
	ctx.f[26].f64 = ctx.f[0].f64;
	pc = 0x82EE2618; continue 'dispatch;
            }
            0x82EE2618 => {
    //   block [0x82EE2618..0x82EE2634)
	// 82EE2618: FF0DD800  fcmpu cr6, f13, f27
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[27].f64);
	// 82EE261C: 4099002C  ble cr6, 0x82ee2648
	if !ctx.cr[6].gt {
	pc = 0x82EE2648; continue 'dispatch;
	}
	// 82EE2620: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2624: FF00B000  fcmpu cr6, f0, f22
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[22].f64);
	// 82EE2628: 4098000C  bge cr6, 0x82ee2634
	if !ctx.cr[6].lt {
	pc = 0x82EE2634; continue 'dispatch;
	}
	// 82EE262C: FEC00090  fmr f22, f0
	ctx.f[22].f64 = ctx.f[0].f64;
	// 82EE2630: FFC06890  fmr f30, f13
	ctx.f[30].f64 = ctx.f[13].f64;
	pc = 0x82EE2634; continue 'dispatch;
            }
            0x82EE2634 => {
    //   block [0x82EE2634..0x82EE2648)
	// 82EE2634: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2638: FF009800  fcmpu cr6, f0, f19
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[19].f64);
	// 82EE263C: 40980038  bge cr6, 0x82ee2674
	if !ctx.cr[6].lt {
	pc = 0x82EE2674; continue 'dispatch;
	}
	// 82EE2640: FE600090  fmr f19, f0
	ctx.f[19].f64 = ctx.f[0].f64;
	// 82EE2644: 48000030  b 0x82ee2674
	pc = 0x82EE2674; continue 'dispatch;
            }
            0x82EE2648 => {
    //   block [0x82EE2648..0x82EE2664)
	// 82EE2648: FF0CD800  fcmpu cr6, f12, f27
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[27].f64);
	// 82EE264C: 40980028  bge cr6, 0x82ee2674
	if !ctx.cr[6].lt {
	pc = 0x82EE2674; continue 'dispatch;
	}
	// 82EE2650: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2654: FF00B800  fcmpu cr6, f0, f23
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[23].f64);
	// 82EE2658: 4098000C  bge cr6, 0x82ee2664
	if !ctx.cr[6].lt {
	pc = 0x82EE2664; continue 'dispatch;
	}
	// 82EE265C: FEE00090  fmr f23, f0
	ctx.f[23].f64 = ctx.f[0].f64;
	// 82EE2660: FF806090  fmr f28, f12
	ctx.f[28].f64 = ctx.f[12].f64;
	pc = 0x82EE2664; continue 'dispatch;
            }
            0x82EE2664 => {
    //   block [0x82EE2664..0x82EE2674)
	// 82EE2664: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2668: FF00A000  fcmpu cr6, f0, f20
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[20].f64);
	// 82EE266C: 40980008  bge cr6, 0x82ee2674
	if !ctx.cr[6].lt {
	pc = 0x82EE2674; continue 'dispatch;
	}
	// 82EE2670: FE800090  fmr f20, f0
	ctx.f[20].f64 = ctx.f[0].f64;
	pc = 0x82EE2674; continue 'dispatch;
            }
            0x82EE2674 => {
    //   block [0x82EE2674..0x82EE2680)
	// 82EE2674: FF0C3800  fcmpu cr6, f12, f7
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[7].f64);
	// 82EE2678: 41980008  blt cr6, 0x82ee2680
	if ctx.cr[6].lt {
	pc = 0x82EE2680; continue 'dispatch;
	}
	// 82EE267C: FD803890  fmr f12, f7
	ctx.f[12].f64 = ctx.f[7].f64;
	pc = 0x82EE2680; continue 'dispatch;
            }
            0x82EE2680 => {
    //   block [0x82EE2680..0x82EE268C)
	// 82EE2680: FF0D7000  fcmpu cr6, f13, f14
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[14].f64);
	// 82EE2684: 41990008  bgt cr6, 0x82ee268c
	if ctx.cr[6].gt {
	pc = 0x82EE268C; continue 'dispatch;
	}
	// 82EE2688: FDA07090  fmr f13, f14
	ctx.f[13].f64 = ctx.f[14].f64;
	pc = 0x82EE268C; continue 'dispatch;
            }
            0x82EE268C => {
    //   block [0x82EE268C..0x82EE269C)
	// 82EE268C: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE2690: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2694: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE2698: ED0D403A  fmadds f8, f13, f0, f8
	ctx.f[8].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	pc = 0x82EE269C; continue 'dispatch;
            }
            0x82EE269C => {
    //   block [0x82EE269C..0x82EE26A4)
	// 82EE269C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE26A0: 4082FF34  bne 0x82ee25d4
	if !ctx.cr[0].eq {
	pc = 0x82EE25D4; continue 'dispatch;
	}
	pc = 0x82EE26A4; continue 'dispatch;
            }
            0x82EE26A4 => {
    //   block [0x82EE26A4..0x82EE26B4)
	// 82EE26A4: C01F0108  lfs f0, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE26A8: FF060000  fcmpu cr6, f6, f0
	ctx.cr[6].compare_f64(ctx.f[6].f64, ctx.f[0].f64);
	// 82EE26AC: 40980008  bge cr6, 0x82ee26b4
	if !ctx.cr[6].lt {
	pc = 0x82EE26B4; continue 'dispatch;
	}
	// 82EE26B0: D2210050  stfs f17, 0x50(r1)
	tmp.f32 = (ctx.f[17].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	pc = 0x82EE26B4; continue 'dispatch;
            }
            0x82EE26B4 => {
    //   block [0x82EE26B4..0x82EE26C0)
	// 82EE26B4: FF160000  fcmpu cr6, f22, f0
	ctx.cr[6].compare_f64(ctx.f[22].f64, ctx.f[0].f64);
	// 82EE26B8: 40980008  bge cr6, 0x82ee26c0
	if !ctx.cr[6].lt {
	pc = 0x82EE26C0; continue 'dispatch;
	}
	// 82EE26BC: FEC08890  fmr f22, f17
	ctx.f[22].f64 = ctx.f[17].f64;
	pc = 0x82EE26C0; continue 'dispatch;
            }
            0x82EE26C0 => {
    //   block [0x82EE26C0..0x82EE26CC)
	// 82EE26C0: FF170000  fcmpu cr6, f23, f0
	ctx.cr[6].compare_f64(ctx.f[23].f64, ctx.f[0].f64);
	// 82EE26C4: 40980008  bge cr6, 0x82ee26cc
	if !ctx.cr[6].lt {
	pc = 0x82EE26CC; continue 'dispatch;
	}
	// 82EE26C8: FEE08890  fmr f23, f17
	ctx.f[23].f64 = ctx.f[17].f64;
	pc = 0x82EE26CC; continue 'dispatch;
            }
            0x82EE26CC => {
    //   block [0x82EE26CC..0x82EE2734)
	// 82EE26CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE26D0: C0410050  lfs f2, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EE26D4: FC60D090  fmr f3, f26
	ctx.f[3].f64 = ctx.f[26].f64;
	// 82EE26D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE26DC: FC209090  fmr f1, f18
	ctx.f[1].f64 = ctx.f[18].f64;
	// 82EE26E0: C32B0C4C  lfs f25, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82EE26E4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE26E8: EC150672  fmuls f0, f21, f25
	ctx.f[0].f64 = (((ctx.f[21].f64 * ctx.f[25].f64) as f32) as f64);
	// 82EE26EC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EE26F0: EF080024  fdivs f24, f8, f0
	ctx.f[24].f64 = ((ctx.f[8].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EE26F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE26F8: 4E800421  bctrl
	ctx.lr = 0x82EE26FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE26FC: EFBED828  fsubs f29, f30, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = (((ctx.f[30].f64 - ctx.f[27].f64) as f32) as f64);
	// 82EE2700: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82EE2704: FF1DA800  fcmpu cr6, f29, f21
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[21].f64);
	// 82EE2708: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 82EE270C: 40980028  bge cr6, 0x82ee2734
	if !ctx.cr[6].lt {
	pc = 0x82EE2734; continue 'dispatch;
	}
	// 82EE2710: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE2714: FC609890  fmr f3, f19
	ctx.f[3].f64 = ctx.f[19].f64;
	// 82EE2718: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE271C: FC40B090  fmr f2, f22
	ctx.f[2].f64 = ctx.f[22].f64;
	// 82EE2720: FC209090  fmr f1, f18
	ctx.f[1].f64 = ctx.f[18].f64;
	// 82EE2724: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EE2728: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE272C: 4E800421  bctrl
	ctx.lr = 0x82EE2730;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE2730: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
            }
            0x82EE2734 => {
    //   block [0x82EE2734..0x82EE2764)
	// 82EE2734: EF9BE028  fsubs f28, f27, f28
	ctx.f[28].f64 = (((ctx.f[27].f64 - ctx.f[28].f64) as f32) as f64);
	// 82EE2738: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EE273C: FF1CA800  fcmpu cr6, f28, f21
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[21].f64);
	// 82EE2740: 40980024  bge cr6, 0x82ee2764
	if !ctx.cr[6].lt {
	pc = 0x82EE2764; continue 'dispatch;
	}
	// 82EE2744: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE2748: FC60A090  fmr f3, f20
	ctx.f[3].f64 = ctx.f[20].f64;
	// 82EE274C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE2750: FC40B890  fmr f2, f23
	ctx.f[2].f64 = ctx.f[23].f64;
	// 82EE2754: FC209090  fmr f1, f18
	ctx.f[1].f64 = ctx.f[18].f64;
	// 82EE2758: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EE275C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE2760: 4E800421  bctrl
	ctx.lr = 0x82EE2764;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EE2764 => {
    //   block [0x82EE2764..0x82EE2784)
	// 82EE2764: FF1EF800  fcmpu cr6, f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 82EE2768: 40980038  bge cr6, 0x82ee27a0
	if !ctx.cr[6].lt {
	pc = 0x82EE27A0; continue 'dispatch;
	}
	// 82EE276C: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 82EE2770: 40980018  bge cr6, 0x82ee2788
	if !ctx.cr[6].lt {
	pc = 0x82EE2788; continue 'dispatch;
	}
	// 82EE2774: FF1E0800  fcmpu cr6, f30, f1
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[1].f64);
	// 82EE2778: 4099000C  ble cr6, 0x82ee2784
	if !ctx.cr[6].gt {
	pc = 0x82EE2784; continue 'dispatch;
	}
	// 82EE277C: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	// 82EE2780: 48000008  b 0x82ee2788
	pc = 0x82EE2788; continue 'dispatch;
            }
            0x82EE2784 => {
    //   block [0x82EE2784..0x82EE2788)
	// 82EE2784: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	pc = 0x82EE2788; continue 'dispatch;
            }
            0x82EE2788 => {
    //   block [0x82EE2788..0x82EE27A0)
	// 82EE2788: FF1EF800  fcmpu cr6, f30, f31
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 82EE278C: 40980014  bge cr6, 0x82ee27a0
	if !ctx.cr[6].lt {
	pc = 0x82EE27A0; continue 'dispatch;
	}
	// 82EE2790: EC1FF028  fsubs f0, f31, f30
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[30].f64) as f32) as f64);
	// 82EE2794: EC00A824  fdivs f0, f0, f21
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[21].f64) as f32) as f64;
	// 82EE2798: EC00F77A  fmadds f0, f0, f29, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64 + ctx.f[30].f64) as f32) as f64);
	// 82EE279C: 48000008  b 0x82ee27a4
	pc = 0x82EE27A4; continue 'dispatch;
            }
            0x82EE27A0 => {
    //   block [0x82EE27A0..0x82EE27A4)
	// 82EE27A0: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x82EE27A4; continue 'dispatch;
            }
            0x82EE27A4 => {
    //   block [0x82EE27A4..0x82EE27B8)
	// 82EE27A4: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 82EE27A8: 40980010  bge cr6, 0x82ee27b8
	if !ctx.cr[6].lt {
	pc = 0x82EE27B8; continue 'dispatch;
	}
	// 82EE27AC: EDBF0828  fsubs f13, f31, f1
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 82EE27B0: EDADA824  fdivs f13, f13, f21
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[21].f64) as f32) as f64;
	// 82EE27B4: EFED0F3A  fmadds f31, f13, f28, f1
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[28].f64 + ctx.f[1].f64) as f32) as f64);
	pc = 0x82EE27B8; continue 'dispatch;
            }
            0x82EE27B8 => {
    //   block [0x82EE27B8..0x82EE27C4)
	// 82EE27B8: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82EE27BC: 41980008  blt cr6, 0x82ee27c4
	if ctx.cr[6].lt {
	pc = 0x82EE27C4; continue 'dispatch;
	}
	// 82EE27C0: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	pc = 0x82EE27C4; continue 'dispatch;
            }
            0x82EE27C4 => {
    //   block [0x82EE27C4..0x82EE281C)
	// 82EE27C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE27C8: D3FE0018  stfs f31, 0x18(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EE27CC: C01F00C0  lfs f0, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE27D0: C0210058  lfs f1, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EE27D4: FF0F0000  fcmpu cr6, f15, f0
	ctx.cr[6].compare_f64(ctx.f[15].f64, ctx.f[0].f64);
	// 82EE27D8: C0410054  lfs f2, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EE27DC: C06B0C14  lfs f3, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82EE27E0: 40980054  bge cr6, 0x82ee2834
	if !ctx.cr[6].lt {
	pc = 0x82EE2834; continue 'dispatch;
	}
	// 82EE27E4: EC10182A  fadds f0, f16, f3
	ctx.f[0].f64 = ((ctx.f[16].f64 + ctx.f[3].f64) as f32) as f64;
	// 82EE27E8: C1BF0108  lfs f13, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE27EC: EDB26BF8  fmsubs f13, f18, f15, f13
	ctx.f[13].f64 = (((ctx.f[18].f64 * ctx.f[15].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE27F0: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 82EE27F4: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE27F8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE27FC: FF008800  fcmpu cr6, f0, f17
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[17].f64);
	// 82EE2800: 4099001C  ble cr6, 0x82ee281c
	if !ctx.cr[6].gt {
	pc = 0x82EE281C; continue 'dispatch;
	}
	// 82EE2804: C1BF0040  lfs f13, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE2808: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EE280C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE2810: C00BE258  lfs f0, -0x1da8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7592 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2814: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE2818: 48000010  b 0x82ee2828
	pc = 0x82EE2828; continue 'dispatch;
            }
            0x82EE281C => {
    //   block [0x82EE281C..0x82EE2828)
	// 82EE281C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE2820: C00B0BF8  lfs f0, 0xbf8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3064 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2824: EC020032  fmuls f0, f2, f0
	ctx.f[0].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x82EE2828; continue 'dispatch;
            }
            0x82EE2828 => {
    //   block [0x82EE2828..0x82EE2834)
	// 82EE2828: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EE282C: 40980008  bge cr6, 0x82ee2834
	if !ctx.cr[6].lt {
	pc = 0x82EE2834; continue 'dispatch;
	}
	// 82EE2830: D01E0018  stfs f0, 0x18(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), tmp.u32 ) };
	pc = 0x82EE2834; continue 'dispatch;
            }
            0x82EE2834 => {
    //   block [0x82EE2834..0x82EE2844)
	// 82EE2834: FF17B000  fcmpu cr6, f23, f22
	ctx.cr[6].compare_f64(ctx.f[23].f64, ctx.f[22].f64);
	// 82EE2838: 4098000C  bge cr6, 0x82ee2844
	if !ctx.cr[6].lt {
	pc = 0x82EE2844; continue 'dispatch;
	}
	// 82EE283C: FC00B890  fmr f0, f23
	ctx.f[0].f64 = ctx.f[23].f64;
	// 82EE2840: 48000008  b 0x82ee2848
	pc = 0x82EE2848; continue 'dispatch;
            }
            0x82EE2844 => {
    //   block [0x82EE2844..0x82EE2848)
	// 82EE2844: FC00B090  fmr f0, f22
	ctx.f[0].f64 = ctx.f[22].f64;
	pc = 0x82EE2848; continue 'dispatch;
            }
            0x82EE2848 => {
    //   block [0x82EE2848..0x82EE285C)
	// 82EE2848: C3E10050  lfs f31, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EE284C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82EE2850: 4098000C  bge cr6, 0x82ee285c
	if !ctx.cr[6].lt {
	pc = 0x82EE285C; continue 'dispatch;
	}
	// 82EE2854: FC80F890  fmr f4, f31
	ctx.f[4].f64 = ctx.f[31].f64;
	// 82EE2858: 48000018  b 0x82ee2870
	pc = 0x82EE2870; continue 'dispatch;
            }
            0x82EE285C => {
    //   block [0x82EE285C..0x82EE286C)
	// 82EE285C: FF17B000  fcmpu cr6, f23, f22
	ctx.cr[6].compare_f64(ctx.f[23].f64, ctx.f[22].f64);
	// 82EE2860: 4098000C  bge cr6, 0x82ee286c
	if !ctx.cr[6].lt {
	pc = 0x82EE286C; continue 'dispatch;
	}
	// 82EE2864: FC80B890  fmr f4, f23
	ctx.f[4].f64 = ctx.f[23].f64;
	// 82EE2868: 48000008  b 0x82ee2870
	pc = 0x82EE2870; continue 'dispatch;
            }
            0x82EE286C => {
    //   block [0x82EE286C..0x82EE2870)
	// 82EE286C: FC80B090  fmr f4, f22
	ctx.f[4].f64 = ctx.f[22].f64;
	pc = 0x82EE2870; continue 'dispatch;
            }
            0x82EE2870 => {
    //   block [0x82EE2870..0x82EE2880)
	// 82EE2870: FF149800  fcmpu cr6, f20, f19
	ctx.cr[6].compare_f64(ctx.f[20].f64, ctx.f[19].f64);
	// 82EE2874: 4098000C  bge cr6, 0x82ee2880
	if !ctx.cr[6].lt {
	pc = 0x82EE2880; continue 'dispatch;
	}
	// 82EE2878: FC00A090  fmr f0, f20
	ctx.f[0].f64 = ctx.f[20].f64;
	// 82EE287C: 48000008  b 0x82ee2884
	pc = 0x82EE2884; continue 'dispatch;
            }
            0x82EE2880 => {
    //   block [0x82EE2880..0x82EE2884)
	// 82EE2880: FC009890  fmr f0, f19
	ctx.f[0].f64 = ctx.f[19].f64;
	pc = 0x82EE2884; continue 'dispatch;
            }
            0x82EE2884 => {
    //   block [0x82EE2884..0x82EE2894)
	// 82EE2884: FF1A0000  fcmpu cr6, f26, f0
	ctx.cr[6].compare_f64(ctx.f[26].f64, ctx.f[0].f64);
	// 82EE2888: 4098000C  bge cr6, 0x82ee2894
	if !ctx.cr[6].lt {
	pc = 0x82EE2894; continue 'dispatch;
	}
	// 82EE288C: FCA0D090  fmr f5, f26
	ctx.f[5].f64 = ctx.f[26].f64;
	// 82EE2890: 48000018  b 0x82ee28a8
	pc = 0x82EE28A8; continue 'dispatch;
            }
            0x82EE2894 => {
    //   block [0x82EE2894..0x82EE28A4)
	// 82EE2894: FF149800  fcmpu cr6, f20, f19
	ctx.cr[6].compare_f64(ctx.f[20].f64, ctx.f[19].f64);
	// 82EE2898: 4098000C  bge cr6, 0x82ee28a4
	if !ctx.cr[6].lt {
	pc = 0x82EE28A4; continue 'dispatch;
	}
	// 82EE289C: FCA0A090  fmr f5, f20
	ctx.f[5].f64 = ctx.f[20].f64;
	// 82EE28A0: 48000008  b 0x82ee28a8
	pc = 0x82EE28A8; continue 'dispatch;
            }
            0x82EE28A4 => {
    //   block [0x82EE28A4..0x82EE28A8)
	// 82EE28A4: FCA09890  fmr f5, f19
	ctx.f[5].f64 = ctx.f[19].f64;
	pc = 0x82EE28A8; continue 'dispatch;
            }
            0x82EE28A8 => {
    //   block [0x82EE28A8..0x82EE28D8)
	// 82EE28A8: EC04C02A  fadds f0, f4, f24
	ctx.f[0].f64 = ((ctx.f[4].f64 + ctx.f[24].f64) as f32) as f64;
	// 82EE28AC: D0BE0020  stfs f5, 0x20(r30)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EE28B0: FF1B8800  fcmpu cr6, f27, f17
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[17].f64);
	// 82EE28B4: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 82EE28B8: D01E001C  stfs f0, 0x1c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EE28BC: 409A0020  bne cr6, 0x82ee28dc
	if !ctx.cr[6].eq {
	pc = 0x82EE28DC; continue 'dispatch;
	}
	// 82EE28C0: 897F0024  lbz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EE28C4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE28C8: 41820010  beq 0x82ee28d8
	if ctx.cr[0].eq {
	pc = 0x82EE28D8; continue 'dispatch;
	}
	// 82EE28CC: C01E0018  lfs f0, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE28D0: FF001000  fcmpu cr6, f0, f2
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[2].f64);
	// 82EE28D4: 40980008  bge cr6, 0x82ee28dc
	if !ctx.cr[6].lt {
	pc = 0x82EE28DC; continue 'dispatch;
	}
	pc = 0x82EE28D8; continue 'dispatch;
            }
            0x82EE28D8 => {
    //   block [0x82EE28D8..0x82EE28DC)
	// 82EE28D8: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	pc = 0x82EE28DC; continue 'dispatch;
            }
            0x82EE28DC => {
    //   block [0x82EE28DC..0x82EE28F4)
	// 82EE28DC: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE28E0: 41820014  beq 0x82ee28f4
	if ctx.cr[0].eq {
	pc = 0x82EE28F4; continue 'dispatch;
	}
	// 82EE28E4: C01F0020  lfs f0, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE28E8: C1BF0074  lfs f13, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE28EC: EC006E7A  fmadds f0, f0, f25, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[25].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE28F0: 48000008  b 0x82ee28f8
	pc = 0x82EE28F8; continue 'dispatch;
            }
            0x82EE28F4 => {
    //   block [0x82EE28F4..0x82EE28F8)
	// 82EE28F4: FC008890  fmr f0, f17
	ctx.f[0].f64 = ctx.f[17].f64;
	pc = 0x82EE28F8; continue 'dispatch;
            }
            0x82EE28F8 => {
    //   block [0x82EE28F8..0x82EE2908)
	// 82EE28F8: FF1B0000  fcmpu cr6, f27, f0
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[0].f64);
	// 82EE28FC: 4099000C  ble cr6, 0x82ee2908
	if !ctx.cr[6].gt {
	pc = 0x82EE2908; continue 'dispatch;
	}
	// 82EE2900: EC1B0028  fsubs f0, f27, f0
	ctx.f[0].f64 = (((ctx.f[27].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE2904: 48000008  b 0x82ee290c
	pc = 0x82EE290C; continue 'dispatch;
            }
            0x82EE2908 => {
    //   block [0x82EE2908..0x82EE290C)
	// 82EE2908: EC00D828  fsubs f0, f0, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[27].f64) as f32) as f64);
	pc = 0x82EE290C; continue 'dispatch;
            }
            0x82EE290C => {
    //   block [0x82EE290C..0x82EE2930)
	// 82EE290C: EDA38028  fsubs f13, f3, f16
	ctx.f[13].f64 = (((ctx.f[3].f64 - ctx.f[16].f64) as f32) as f64);
	// 82EE2910: C15F0108  lfs f10, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE2914: C19F0100  lfs f12, 0x100(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE2918: FF185000  fcmpu cr6, f24, f10
	ctx.cr[6].compare_f64(ctx.f[24].f64, ctx.f[10].f64);
	// 82EE291C: ECEC0032  fmuls f7, f12, f0
	ctx.f[7].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE2920: ECCD0072  fmuls f6, f13, f1
	ctx.f[6].f64 = (((ctx.f[13].f64 * ctx.f[1].f64) as f32) as f64);
	// 82EE2924: 4099000C  ble cr6, 0x82ee2930
	if !ctx.cr[6].gt {
	pc = 0x82EE2930; continue 'dispatch;
	}
	// 82EE2928: EDB85028  fsubs f13, f24, f10
	ctx.f[13].f64 = (((ctx.f[24].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EE292C: 48000008  b 0x82ee2934
	pc = 0x82EE2934; continue 'dispatch;
            }
            0x82EE2930 => {
    //   block [0x82EE2930..0x82EE2934)
	// 82EE2930: FDA08890  fmr f13, f17
	ctx.f[13].f64 = ctx.f[17].f64;
	pc = 0x82EE2934; continue 'dispatch;
            }
            0x82EE2934 => {
    //   block [0x82EE2934..0x82EE2958)
	// 82EE2934: C13F00C0  lfs f9, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE2938: FF0D4800  fcmpu cr6, f13, f9
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[9].f64);
	// 82EE293C: 4098001C  bge cr6, 0x82ee2958
	if !ctx.cr[6].lt {
	pc = 0x82EE2958; continue 'dispatch;
	}
	// 82EE2940: FF058800  fcmpu cr6, f5, f17
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[17].f64);
	// 82EE2944: 41990014  bgt cr6, 0x82ee2958
	if ctx.cr[6].gt {
	pc = 0x82EE2958; continue 'dispatch;
	}
	// 82EE2948: FC004890  fmr f0, f9
	ctx.f[0].f64 = ctx.f[9].f64;
	// 82EE294C: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE2950: ED0D0024  fdivs f8, f13, f0
	ctx.f[8].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EE2954: 48000008  b 0x82ee295c
	pc = 0x82EE295C; continue 'dispatch;
            }
            0x82EE2958 => {
    //   block [0x82EE2958..0x82EE295C)
	// 82EE2958: FD008890  fmr f8, f17
	ctx.f[8].f64 = ctx.f[17].f64;
	pc = 0x82EE295C; continue 'dispatch;
            }
            0x82EE295C => {
    //   block [0x82EE295C..0x82EE2978)
	// 82EE295C: FDA0A850  fneg f13, f21
	ctx.f[13].u64 = ctx.f[21].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE2960: FC004890  fmr f0, f9
	ctx.f[0].f64 = ctx.f[9].f64;
	// 82EE2964: FF1B8800  fcmpu cr6, f27, f17
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[17].f64);
	// 82EE2968: FDBB736E  fsel f13, f27, f13, f14
	ctx.f[13].f64 = if ctx.f[27].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[14].f64 };
	// 82EE296C: 4099000C  ble cr6, 0x82ee2978
	if !ctx.cr[6].gt {
	pc = 0x82EE2978; continue 'dispatch;
	}
	// 82EE2970: C161005C  lfs f11, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE2974: 48000008  b 0x82ee297c
	pc = 0x82EE297C; continue 'dispatch;
            }
            0x82EE2978 => {
    //   block [0x82EE2978..0x82EE297C)
	// 82EE2978: FD60A890  fmr f11, f21
	ctx.f[11].f64 = ctx.f[21].f64;
	pc = 0x82EE297C; continue 'dispatch;
            }
            0x82EE297C => {
    //   block [0x82EE297C..0x82EE2990)
	// 82EE297C: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EE2980: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE2984: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE2988: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE298C: 4182004C  beq 0x82ee29d8
	if ctx.cr[0].eq {
	pc = 0x82EE29D8; continue 'dispatch;
	}
	pc = 0x82EE2990; continue 'dispatch;
            }
            0x82EE2990 => {
    //   block [0x82EE2990..0x82EE29A8)
	// 82EE2990: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE2994: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82EE2998: 41990010  bgt cr6, 0x82ee29a8
	if ctx.cr[6].gt {
	pc = 0x82EE29A8; continue 'dispatch;
	}
	// 82EE299C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EE29A0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE29A4: 4082FFEC  bne 0x82ee2990
	if !ctx.cr[0].eq {
	pc = 0x82EE2990; continue 'dispatch;
	}
	pc = 0x82EE29A8; continue 'dispatch;
            }
            0x82EE29A8 => {
    //   block [0x82EE29A8..0x82EE29B0)
	// 82EE29A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE29AC: 419A002C  beq cr6, 0x82ee29d8
	if ctx.cr[6].eq {
	pc = 0x82EE29D8; continue 'dispatch;
	}
	pc = 0x82EE29B0; continue 'dispatch;
            }
            0x82EE29B0 => {
    //   block [0x82EE29B0..0x82EE29CC)
	// 82EE29B0: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE29B4: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82EE29B8: 41990020  bgt cr6, 0x82ee29d8
	if ctx.cr[6].gt {
	pc = 0x82EE29D8; continue 'dispatch;
	}
	// 82EE29BC: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE29C0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE29C4: 40980008  bge cr6, 0x82ee29cc
	if !ctx.cr[6].lt {
	pc = 0x82EE29CC; continue 'dispatch;
	}
	// 82EE29C8: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EE29CC; continue 'dispatch;
            }
            0x82EE29CC => {
    //   block [0x82EE29CC..0x82EE29D8)
	// 82EE29CC: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EE29D0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE29D4: 4082FFDC  bne 0x82ee29b0
	if !ctx.cr[0].eq {
	pc = 0x82EE29B0; continue 'dispatch;
	}
	pc = 0x82EE29D8; continue 'dispatch;
            }
            0x82EE29D8 => {
    //   block [0x82EE29D8..0x82EE29E8)
	// 82EE29D8: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EE29DC: 4099000C  ble cr6, 0x82ee29e8
	if !ctx.cr[6].gt {
	pc = 0x82EE29E8; continue 'dispatch;
	}
	// 82EE29E0: EC005028  fsubs f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EE29E4: 48000008  b 0x82ee29ec
	pc = 0x82EE29EC; continue 'dispatch;
            }
            0x82EE29E8 => {
    //   block [0x82EE29E8..0x82EE29EC)
	// 82EE29E8: FC008890  fmr f0, f17
	ctx.f[0].f64 = ctx.f[17].f64;
	pc = 0x82EE29EC; continue 'dispatch;
            }
            0x82EE29EC => {
    //   block [0x82EE29EC..0x82EE2A00)
	// 82EE29EC: FF004800  fcmpu cr6, f0, f9
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[9].f64);
	// 82EE29F0: 40980010  bge cr6, 0x82ee2a00
	if !ctx.cr[6].lt {
	pc = 0x82EE2A00; continue 'dispatch;
	}
	// 82EE29F4: EC004824  fdivs f0, f0, f9
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[9].f64) as f32) as f64;
	// 82EE29F8: EDA30028  fsubs f13, f3, f0
	ctx.f[13].f64 = (((ctx.f[3].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE29FC: 48000008  b 0x82ee2a04
	pc = 0x82EE2A04; continue 'dispatch;
            }
            0x82EE2A00 => {
    //   block [0x82EE2A00..0x82EE2A04)
	// 82EE2A00: FDA08890  fmr f13, f17
	ctx.f[13].f64 = ctx.f[17].f64;
	pc = 0x82EE2A04; continue 'dispatch;
            }
            0x82EE2A04 => {
    //   block [0x82EE2A04..0x82EE2A14)
	// 82EE2A04: FF058800  fcmpu cr6, f5, f17
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[17].f64);
	// 82EE2A08: 4199000C  bgt cr6, 0x82ee2a14
	if ctx.cr[6].gt {
	pc = 0x82EE2A14; continue 'dispatch;
	}
	// 82EE2A0C: FC001890  fmr f0, f3
	ctx.f[0].f64 = ctx.f[3].f64;
	// 82EE2A10: 4800001C  b 0x82ee2a2c
	pc = 0x82EE2A2C; continue 'dispatch;
            }
            0x82EE2A14 => {
    //   block [0x82EE2A14..0x82EE2A28)
	// 82EE2A14: FF051000  fcmpu cr6, f5, f2
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[2].f64);
	// 82EE2A18: 40980010  bge cr6, 0x82ee2a28
	if !ctx.cr[6].lt {
	pc = 0x82EE2A28; continue 'dispatch;
	}
	// 82EE2A1C: EC051024  fdivs f0, f5, f2
	ctx.f[0].f64 = ((ctx.f[5].f64 / ctx.f[2].f64) as f32) as f64;
	// 82EE2A20: EC030028  fsubs f0, f3, f0
	ctx.f[0].f64 = (((ctx.f[3].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE2A24: 48000008  b 0x82ee2a2c
	pc = 0x82EE2A2C; continue 'dispatch;
            }
            0x82EE2A28 => {
    //   block [0x82EE2A28..0x82EE2A2C)
	// 82EE2A28: FC008890  fmr f0, f17
	ctx.f[0].f64 = ctx.f[17].f64;
	pc = 0x82EE2A2C; continue 'dispatch;
            }
            0x82EE2A2C => {
    //   block [0x82EE2A2C..0x82EE2A58)
	// 82EE2A2C: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82EE2A30: 816A8F28  lwz r11, -0x70d8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28888 as u32) ) } as u64;
	// 82EE2A34: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EE2A38: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 82EE2A3C: 4082001C  bne 0x82ee2a58
	if !ctx.cr[0].eq {
	pc = 0x82EE2A58; continue 'dispatch;
	}
	// 82EE2A40: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EE2A44: 916A8F28  stw r11, -0x70d8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-28888 as u32), ctx.r[11].u32 ) };
	// 82EE2A48: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82EE2A4C: C18B0FF8  lfs f12, 0xff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4088 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE2A50: D1898F24  stfs f12, -0x70dc(r9)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-28892 as u32), tmp.u32 ) };
	// 82EE2A54: 48000008  b 0x82ee2a5c
	pc = 0x82EE2A5C; continue 'dispatch;
            }
            0x82EE2A58 => {
    //   block [0x82EE2A58..0x82EE2A5C)
	// 82EE2A58: C1898F24  lfs f12, -0x70dc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-28892 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EE2A5C; continue 'dispatch;
            }
            0x82EE2A5C => {
    //   block [0x82EE2A5C..0x82EE2AB4)
	// 82EE2A5C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE2A60: ED60682A  fadds f11, f0, f13
	ctx.f[11].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE2A64: C00BBE10  lfs f0, -0x41f0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2A68: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE2A6C: C1ABBDF8  lfs f13, -0x4208(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16904 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE2A70: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE2A74: ED480372  fmuls f10, f8, f13
	ctx.f[10].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE2A78: C1ABBDF4  lfs f13, -0x420c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16908 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE2A7C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE2A80: EC0B503A  fmadds f0, f11, f0, f10
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 82EE2A84: EC06037A  fmadds f0, f6, f13, f0
	ctx.f[0].f64 = (((ctx.f[6].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE2A88: C1AB0C80  lfs f13, 0xc80(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3200 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE2A8C: EC00382A  fadds f0, f0, f7
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64;
	// 82EE2A90: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE2A94: D19E0010  stfs f12, 0x10(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EE2A98: C17F001C  lfs f11, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE2A9C: EDAB0372  fmuls f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE2AA0: C01F00D8  lfs f0, 0xd8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2AA4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE2AA8: 4099000C  ble cr6, 0x82ee2ab4
	if !ctx.cr[6].gt {
	pc = 0x82EE2AB4; continue 'dispatch;
	}
	// 82EE2AAC: FF1B8800  fcmpu cr6, f27, f17
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[17].f64);
	// 82EE2AB0: 41980018  blt cr6, 0x82ee2ac8
	if ctx.cr[6].lt {
	pc = 0x82EE2AC8; continue 'dispatch;
	}
	pc = 0x82EE2AB4; continue 'dispatch;
            }
            0x82EE2AB4 => {
    //   block [0x82EE2AB4..0x82EE2AC8)
	// 82EE2AB4: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE2AB8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE2ABC: 40980020  bge cr6, 0x82ee2adc
	if !ctx.cr[6].lt {
	pc = 0x82EE2ADC; continue 'dispatch;
	}
	// 82EE2AC0: FF1B8800  fcmpu cr6, f27, f17
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[17].f64);
	// 82EE2AC4: 40990018  ble cr6, 0x82ee2adc
	if !ctx.cr[6].gt {
	pc = 0x82EE2ADC; continue 'dispatch;
	}
	pc = 0x82EE2AC8; continue 'dispatch;
            }
            0x82EE2AC8 => {
    //   block [0x82EE2AC8..0x82EE2ADC)
	// 82EE2AC8: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EE2ACC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE2AD0: 4082000C  bne 0x82ee2adc
	if !ctx.cr[0].eq {
	pc = 0x82EE2ADC; continue 'dispatch;
	}
	// 82EE2AD4: EC0C082A  fadds f0, f12, f1
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[1].f64) as f32) as f64;
	// 82EE2AD8: D01E0010  stfs f0, 0x10(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	pc = 0x82EE2ADC; continue 'dispatch;
            }
            0x82EE2ADC => {
    //   block [0x82EE2ADC..0x82EE2B14)
	// 82EE2ADC: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EE2AE0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE2AE4: 41820040  beq 0x82ee2b24
	if ctx.cr[0].eq {
	pc = 0x82EE2B24; continue 'dispatch;
	}
	// 82EE2AE8: FF058800  fcmpu cr6, f5, f17
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[17].f64);
	// 82EE2AEC: 40980038  bge cr6, 0x82ee2b24
	if !ctx.cr[6].lt {
	pc = 0x82EE2B24; continue 'dispatch;
	}
	// 82EE2AF0: C01F010C  lfs f0, 0x10c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2AF4: C1BF0108  lfs f13, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE2AF8: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE2AFC: FF040000  fcmpu cr6, f4, f0
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[0].f64);
	// 82EE2B00: 40980024  bge cr6, 0x82ee2b24
	if !ctx.cr[6].lt {
	pc = 0x82EE2B24; continue 'dispatch;
	}
	// 82EE2B04: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82EE2B08: 4098000C  bge cr6, 0x82ee2b14
	if !ctx.cr[6].lt {
	pc = 0x82EE2B14; continue 'dispatch;
	}
	// 82EE2B0C: FC001890  fmr f0, f3
	ctx.f[0].f64 = ctx.f[3].f64;
	// 82EE2B10: 48000008  b 0x82ee2b18
	pc = 0x82EE2B18; continue 'dispatch;
            }
            0x82EE2B14 => {
    //   block [0x82EE2B14..0x82EE2B18)
	// 82EE2B14: FC000890  fmr f0, f1
	ctx.f[0].f64 = ctx.f[1].f64;
	pc = 0x82EE2B18; continue 'dispatch;
            }
            0x82EE2B18 => {
    //   block [0x82EE2B18..0x82EE2B24)
	// 82EE2B18: C1BE0010  lfs f13, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE2B1C: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EE2B20: D01E0010  stfs f0, 0x10(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	pc = 0x82EE2B24; continue 'dispatch;
            }
            0x82EE2B24 => {
    //   block [0x82EE2B24..0x82EE2B38)
	// 82EE2B24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EE2B28: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 82EE2B2C: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82EE2B30: 4BDCB1BD  bl 0x82cadcec
	ctx.lr = 0x82EE2B34;
	sub_82CADCEC(ctx, base);
	// 82EE2B34: 4BDC6924  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE2B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE2B38 size=1216
    let mut pc: u32 = 0x82EE2B38;
    'dispatch: loop {
        match pc {
            0x82EE2B38 => {
    //   block [0x82EE2B38..0x82EE2B78)
	// 82EE2B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE2B3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EE2B40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EE2B44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EE2B48: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 82EE2B4C: 4BDCB181  bl 0x82cadccc
	ctx.lr = 0x82EE2B50;
	sub_82CADCA0(ctx, base);
	// 82EE2B50: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE2B54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE2B58: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EE2B5C: 897F00FA  lbz r11, 0xfa(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(250 as u32) ) } as u64;
	// 82EE2B60: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82EE2B64: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE2B68: 41820010  beq 0x82ee2b78
	if ctx.cr[0].eq {
	pc = 0x82EE2B78; continue 'dispatch;
	}
	// 82EE2B6C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EE2B70: 9BDF00FA  stb r30, 0xfa(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(250 as u32), ctx.r[30].u8 ) };
	// 82EE2B74: 48000464  b 0x82ee2fd8
	pc = 0x82EE2FD8; continue 'dispatch;
            }
            0x82EE2B78 => {
    //   block [0x82EE2B78..0x82EE2B88)
	// 82EE2B78: 80BF00D4  lwz r5, 0xd4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EE2B7C: 81650014  lwz r11, 0x14(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE2B80: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EE2B84: 4098000C  bge cr6, 0x82ee2b90
	if !ctx.cr[6].lt {
	pc = 0x82EE2B90; continue 'dispatch;
	}
	pc = 0x82EE2B88; continue 'dispatch;
            }
            0x82EE2B88 => {
    //   block [0x82EE2B88..0x82EE2B90)
	// 82EE2B88: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EE2B8C: 4800044C  b 0x82ee2fd8
	pc = 0x82EE2FD8; continue 'dispatch;
            }
            0x82EE2B90 => {
    //   block [0x82EE2B90..0x82EE2BD4)
	// 82EE2B90: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EE2B94: C01F005C  lfs f0, 0x5c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2B98: C1BF008C  lfs f13, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE2B9C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EE2BA0: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE2BA4: C01F0060  lfs f0, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2BA8: C19F0090  lfs f12, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE2BAC: ED6C0028  fsubs f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE2BB0: C15F0094  lfs f10, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE2BB4: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EE2BB8: C01F0064  lfs f0, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2BBC: C32A0C14  lfs f25, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82EE2BC0: EC0A0028  fsubs f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE2BC4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE2BC8: 4182000C  beq 0x82ee2bd4
	if ctx.cr[0].eq {
	pc = 0x82EE2BD4; continue 'dispatch;
	}
	// 82EE2BCC: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE2BD0: 48000008  b 0x82ee2bd8
	pc = 0x82EE2BD8; continue 'dispatch;
            }
            0x82EE2BD4 => {
    //   block [0x82EE2BD4..0x82EE2BD8)
	// 82EE2BD4: FD80C890  fmr f12, f25
	ctx.f[12].f64 = ctx.f[25].f64;
	pc = 0x82EE2BD8; continue 'dispatch;
            }
            0x82EE2BD8 => {
    //   block [0x82EE2BD8..0x82EE2CB8)
	// 82EE2BD8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE2BDC: C15F0078  lfs f10, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE2BE0: C35F002C  lfs f26, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82EE2BE4: C36B0BFC  lfs f27, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82EE2BE8: ED2A06F2  fmuls f9, f10, f27
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EE2BEC: ED4D0372  fmuls f10, f13, f13
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE2BF0: ED9A4B3A  fmadds f12, f26, f12, f9
	ctx.f[12].f64 = (((ctx.f[26].f64 * ctx.f[12].f64 + ctx.f[9].f64) as f32) as f64);
	// 82EE2BF4: ED20503A  fmadds f9, f0, f0, f10
	ctx.f[9].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 82EE2BF8: ED8C0332  fmuls f12, f12, f12
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE2BFC: FF096000  fcmpu cr6, f9, f12
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[12].f64);
	// 82EE2C00: 4198FF88  blt cr6, 0x82ee2b88
	if ctx.cr[6].lt {
	pc = 0x82EE2B88; continue 'dispatch;
	}
	// 82EE2C04: C19F00B8  lfs f12, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE2C08: ED8C02F2  fmuls f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE2C0C: C13F00BC  lfs f9, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE2C10: C11F00B4  lfs f8, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE2C14: C3BF0104  lfs f29, 0x104(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EE2C18: C39F0108  lfs f28, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EE2C1C: FCE0E050  fneg f7, f28
	ctx.f[7].u64 = ctx.f[28].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE2C20: ED89603A  fmadds f12, f9, f0, f12
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 82EE2C24: EC8D623A  fmadds f4, f13, f8, f12
	ctx.f[4].f64 = (((ctx.f[13].f64 * ctx.f[8].f64 + ctx.f[12].f64) as f32) as f64);
	// 82EE2C28: EFFD0132  fmuls f31, f29, f4
	ctx.f[31].f64 = (((ctx.f[29].f64 * ctx.f[4].f64) as f32) as f64);
	// 82EE2C2C: FF1F3800  fcmpu cr6, f31, f7
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[7].f64);
	// 82EE2C30: 4198FF58  blt cr6, 0x82ee2b88
	if ctx.cr[6].lt {
	pc = 0x82EE2B88; continue 'dispatch;
	}
	// 82EE2C34: C13F00A0  lfs f9, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE2C38: ED2902F2  fmuls f9, f9, f11
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE2C3C: C11F00A4  lfs f8, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE2C40: C0FF009C  lfs f7, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EE2C44: C19F0048  lfs f12, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE2C48: ED28483A  fmadds f9, f8, f0, f9
	ctx.f[9].f64 = (((ctx.f[8].f64 * ctx.f[0].f64 + ctx.f[9].f64) as f32) as f64);
	// 82EE2C4C: EC2D49FA  fmadds f1, f13, f7, f9
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[7].f64 + ctx.f[9].f64) as f32) as f64);
	// 82EE2C50: FDA00A10  fabs f13, f1
	ctx.f[13].u64 = ctx.f[1].u64 & !0x8000_0000_0000_0000u64;
	// 82EE2C54: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EE2C58: 4199FF30  bgt cr6, 0x82ee2b88
	if ctx.cr[6].gt {
	pc = 0x82EE2B88; continue 'dispatch;
	}
	// 82EE2C5C: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82EE2C60: 811F0050  lwz r8, 0x50(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EE2C64: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE2C68: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE2C6C: C1BF0074  lfs f13, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE2C70: 38EBAFB4  addi r7, r11, -0x504c
	ctx.r[7].s64 = ctx.r[11].s64 + -20556;
	// 82EE2C74: C19F0020  lfs f12, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE2C78: ECAD66FA  fmadds f5, f13, f27, f12
	ctx.f[5].f64 = (((ctx.f[13].f64 * ctx.f[27].f64 + ctx.f[12].f64) as f32) as f64);
	// 82EE2C7C: 816A8F30  lwz r11, -0x70d0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28880 as u32) ) } as u64;
	// 82EE2C80: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EE2C84: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE2C88: 81290008  lwz r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE2C8C: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 82EE2C90: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82EE2C94: C3C60010  lfs f30, 0x10(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EE2C98: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 82EE2C9C: 4082001C  bne 0x82ee2cb8
	if !ctx.cr[0].eq {
	pc = 0x82EE2CB8; continue 'dispatch;
	}
	// 82EE2CA0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EE2CA4: 916A8F30  stw r11, -0x70d0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-28880 as u32), ctx.r[11].u32 ) };
	// 82EE2CA8: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82EE2CAC: C18B5224  lfs f12, 0x5224(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(21028 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE2CB0: D1898F2C  stfs f12, -0x70d4(r9)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-28884 as u32), tmp.u32 ) };
	// 82EE2CB4: 48000008  b 0x82ee2cbc
	pc = 0x82EE2CBC; continue 'dispatch;
            }
            0x82EE2CB8 => {
    //   block [0x82EE2CB8..0x82EE2CBC)
	// 82EE2CB8: C1898F2C  lfs f12, -0x70d4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-28884 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EE2CBC; continue 'dispatch;
            }
            0x82EE2CBC => {
    //   block [0x82EE2CBC..0x82EE2CE4)
	// 82EE2CBC: ED6B02F2  fmuls f11, f11, f11
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE2CC0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE2CC4: C1ABBE14  lfs f13, -0x41ec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16876 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE2CC8: FF046800  fcmpu cr6, f4, f13
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[13].f64);
	// 82EE2CCC: EC00583A  fmadds f0, f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EE2CD0: EC00502A  fadds f0, f0, f10
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64;
	// 82EE2CD4: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EE2CD8: 4099000C  ble cr6, 0x82ee2ce4
	if !ctx.cr[6].gt {
	pc = 0x82EE2CE4; continue 'dispatch;
	}
	// 82EE2CDC: EC412024  fdivs f2, f1, f4
	ctx.f[2].f64 = ((ctx.f[1].f64 / ctx.f[4].f64) as f32) as f64;
	// 82EE2CE0: 48000008  b 0x82ee2ce8
	pc = 0x82EE2CE8; continue 'dispatch;
            }
            0x82EE2CE4 => {
    //   block [0x82EE2CE4..0x82EE2CE8)
	// 82EE2CE4: EC4C0072  fmuls f2, f12, f1
	ctx.f[2].f64 = (((ctx.f[12].f64 * ctx.f[1].f64) as f32) as f64);
	pc = 0x82EE2CE8; continue 'dispatch;
            }
            0x82EE2CE8 => {
    //   block [0x82EE2CE8..0x82EE2D00)
	// 82EE2CE8: FF046800  fcmpu cr6, f4, f13
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[13].f64);
	// 82EE2CEC: 40990014  ble cr6, 0x82ee2d00
	if !ctx.cr[6].gt {
	pc = 0x82EE2D00; continue 'dispatch;
	}
	// 82EE2CF0: ED850024  fdivs f12, f5, f0
	ctx.f[12].f64 = ((ctx.f[5].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EE2CF4: FD600A10  fabs f11, f1
	ctx.f[11].u64 = ctx.f[1].u64 & !0x8000_0000_0000_0000u64;
	// 82EE2CF8: ED4B0332  fmuls f10, f11, f12
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE2CFC: 48000008  b 0x82ee2d04
	pc = 0x82EE2D04; continue 'dispatch;
            }
            0x82EE2D00 => {
    //   block [0x82EE2D00..0x82EE2D04)
	// 82EE2D00: FD402890  fmr f10, f5
	ctx.f[10].f64 = ctx.f[5].f64;
	pc = 0x82EE2D04; continue 'dispatch;
            }
            0x82EE2D04 => {
    //   block [0x82EE2D04..0x82EE2D28)
	// 82EE2D04: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE2D08: FF046800  fcmpu cr6, f4, f13
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[13].f64);
	// 82EE2D0C: C10B0C18  lfs f8, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE2D10: 40990018  ble cr6, 0x82ee2d28
	if !ctx.cr[6].gt {
	pc = 0x82EE2D28; continue 'dispatch;
	}
	// 82EE2D14: FDA02050  fneg f13, f4
	ctx.f[13].u64 = ctx.f[4].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE2D18: FDA1236E  fsel f13, f1, f13, f4
	ctx.f[13].f64 = if ctx.f[1].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[4].f64 };
	// 82EE2D1C: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EE2D20: ED600172  fmuls f11, f0, f5
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[5].f64) as f32) as f64);
	// 82EE2D24: 48000008  b 0x82ee2d2c
	pc = 0x82EE2D2C; continue 'dispatch;
            }
            0x82EE2D28 => {
    //   block [0x82EE2D28..0x82EE2D2C)
	// 82EE2D28: FD604090  fmr f11, f8
	ctx.f[11].f64 = ctx.f[8].f64;
	pc = 0x82EE2D2C; continue 'dispatch;
            }
            0x82EE2D2C => {
    //   block [0x82EE2D2C..0x82EE2D3C)
	// 82EE2D2C: FF014000  fcmpu cr6, f1, f8
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[8].f64);
	// 82EE2D30: 4199000C  bgt cr6, 0x82ee2d3c
	if ctx.cr[6].gt {
	pc = 0x82EE2D3C; continue 'dispatch;
	}
	// 82EE2D34: EC612828  fsubs f3, f1, f5
	ctx.f[3].f64 = (((ctx.f[1].f64 - ctx.f[5].f64) as f32) as f64);
	// 82EE2D38: 48000008  b 0x82ee2d40
	pc = 0x82EE2D40; continue 'dispatch;
            }
            0x82EE2D3C => {
    //   block [0x82EE2D3C..0x82EE2D40)
	// 82EE2D3C: FC605890  fmr f3, f11
	ctx.f[3].f64 = ctx.f[11].f64;
	pc = 0x82EE2D40; continue 'dispatch;
            }
            0x82EE2D40 => {
    //   block [0x82EE2D40..0x82EE2D6C)
	// 82EE2D40: EC05082A  fadds f0, f5, f1
	ctx.f[0].f64 = ((ctx.f[5].f64 + ctx.f[1].f64) as f32) as f64;
	// 82EE2D44: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE2D48: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EE2D4C: FF014000  fcmpu cr6, f1, f8
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[8].f64);
	// 82EE2D50: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 82EE2D54: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 82EE2D58: FCE1582E  fsel f7, f1, f0, f11
	ctx.f[7].f64 = if ctx.f[1].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[11].f64 };
	// 82EE2D5C: 41980010  blt cr6, 0x82ee2d6c
	if ctx.cr[6].lt {
	pc = 0x82EE2D6C; continue 'dispatch;
	}
	// 82EE2D60: 81290008  lwz r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE2D64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EE2D68: 4800000C  b 0x82ee2d74
	pc = 0x82EE2D74; continue 'dispatch;
            }
            0x82EE2D6C => {
    //   block [0x82EE2D6C..0x82EE2D74)
	// 82EE2D6C: 8129000C  lwz r9, 0xc(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EE2D70: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	pc = 0x82EE2D74; continue 'dispatch;
            }
            0x82EE2D74 => {
    //   block [0x82EE2D74..0x82EE2D88)
	// 82EE2D74: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 82EE2D78: 556907BD  rlwinm. r9, r11, 0, 0x1e, 0x1e
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EE2D7C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE2D80: 41820008  beq 0x82ee2d88
	if ctx.cr[0].eq {
	pc = 0x82EE2D88; continue 'dispatch;
	}
	// 82EE2D84: 556B07FA  rlwinm r11, r11, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	pc = 0x82EE2D88; continue 'dispatch;
            }
            0x82EE2D88 => {
    //   block [0x82EE2D88..0x82EE2D94)
	// 82EE2D88: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EE2D8C: 41820008  beq 0x82ee2d94
	if ctx.cr[0].eq {
	pc = 0x82EE2D94; continue 'dispatch;
	}
	// 82EE2D90: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	pc = 0x82EE2D94; continue 'dispatch;
            }
            0x82EE2D94 => {
    //   block [0x82EE2D94..0x82EE2DAC)
	// 82EE2D94: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EE2D98: 419A01B4  beq cr6, 0x82ee2f4c
	if ctx.cr[6].eq {
	pc = 0x82EE2F4C; continue 'dispatch;
	}
	// 82EE2D9C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82EE2DA0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EE2DA4: C0C80A98  lfs f6, 0xa98(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2712 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EE2DA8: C1290C4C  lfs f9, 0xc4c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3148 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	pc = 0x82EE2DAC; continue 'dispatch;
            }
            0x82EE2DAC => {
    //   block [0x82EE2DAC..0x82EE2DD0)
	// 82EE2DAC: FF014000  fcmpu cr6, f1, f8
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[8].f64);
	// 82EE2DB0: 41980020  blt cr6, 0x82ee2dd0
	if ctx.cr[6].lt {
	pc = 0x82EE2DD0; continue 'dispatch;
	}
	// 82EE2DB4: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE2DB8: FF0D1800  fcmpu cr6, f13, f3
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[3].f64);
	// 82EE2DBC: 4198012C  blt cr6, 0x82ee2ee8
	if ctx.cr[6].lt {
	pc = 0x82EE2EE8; continue 'dispatch;
	}
	// 82EE2DC0: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2DC4: FF003800  fcmpu cr6, f0, f7
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[7].f64);
	// 82EE2DC8: 41990184  bgt cr6, 0x82ee2f4c
	if ctx.cr[6].gt {
	pc = 0x82EE2F4C; continue 'dispatch;
	}
	// 82EE2DCC: 4800001C  b 0x82ee2de8
	pc = 0x82EE2DE8; continue 'dispatch;
            }
            0x82EE2DD0 => {
    //   block [0x82EE2DD0..0x82EE2DE8)
	// 82EE2DD0: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2DD4: FF003800  fcmpu cr6, f0, f7
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[7].f64);
	// 82EE2DD8: 41990110  bgt cr6, 0x82ee2ee8
	if ctx.cr[6].gt {
	pc = 0x82EE2EE8; continue 'dispatch;
	}
	// 82EE2DDC: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE2DE0: FF0D1800  fcmpu cr6, f13, f3
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[3].f64);
	// 82EE2DE4: 41980168  blt cr6, 0x82ee2f4c
	if ctx.cr[6].lt {
	pc = 0x82EE2F4C; continue 'dispatch;
	}
	pc = 0x82EE2DE8; continue 'dispatch;
            }
            0x82EE2DE8 => {
    //   block [0x82EE2DE8..0x82EE2E10)
	// 82EE2DE8: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82EE2DEC: 40980024  bge cr6, 0x82ee2e10
	if !ctx.cr[6].lt {
	pc = 0x82EE2E10; continue 'dispatch;
	}
	// 82EE2DF0: FF0D0800  fcmpu cr6, f13, f1
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[1].f64);
	// 82EE2DF4: 4099001C  ble cr6, 0x82ee2e10
	if !ctx.cr[6].gt {
	pc = 0x82EE2E10; continue 'dispatch;
	}
	// 82EE2DF8: EDBACA7A  fmadds f13, f26, f9, f25
	ctx.f[13].f64 = (((ctx.f[26].f64 * ctx.f[9].f64 + ctx.f[25].f64) as f32) as f64);
	// 82EE2DFC: C00A0010  lfs f0, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2E00: EDAD0732  fmuls f13, f13, f28
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EE2E04: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE2E08: 4198FD80  blt cr6, 0x82ee2b88
	if ctx.cr[6].lt {
	pc = 0x82EE2B88; continue 'dispatch;
	}
	// 82EE2E0C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82EE2E10; continue 'dispatch;
            }
            0x82EE2E10 => {
    //   block [0x82EE2E10..0x82EE2E4C)
	// 82EE2E10: EC1D0172  fmuls f0, f29, f5
	ctx.f[0].f64 = (((ctx.f[29].f64 * ctx.f[5].f64) as f32) as f64);
	// 82EE2E14: C18A0010  lfs f12, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE2E18: EDA0F82A  fadds f13, f0, f31
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82EE2E1C: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82EE2E20: 41990094  bgt cr6, 0x82ee2eb4
	if ctx.cr[6].gt {
	pc = 0x82EE2EB4; continue 'dispatch;
	}
	// 82EE2E24: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EE2E28: FF014000  fcmpu cr6, f1, f8
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[8].f64);
	// 82EE2E2C: 40990044  ble cr6, 0x82ee2e70
	if !ctx.cr[6].gt {
	pc = 0x82EE2E70; continue 'dispatch;
	}
	// 82EE2E30: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2E34: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EE2E38: 409900B0  ble cr6, 0x82ee2ee8
	if !ctx.cr[6].gt {
	pc = 0x82EE2EE8; continue 'dispatch;
	}
	// 82EE2E3C: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82EE2E40: 4098000C  bge cr6, 0x82ee2e4c
	if !ctx.cr[6].lt {
	pc = 0x82EE2E4C; continue 'dispatch;
	}
	// 82EE2E44: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82EE2E48: 48000008  b 0x82ee2e50
	pc = 0x82EE2E50; continue 'dispatch;
            }
            0x82EE2E4C => {
    //   block [0x82EE2E4C..0x82EE2E50)
	// 82EE2E4C: EDAB082A  fadds f13, f11, f1
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[1].f64) as f32) as f64;
	pc = 0x82EE2E50; continue 'dispatch;
            }
            0x82EE2E50 => {
    //   block [0x82EE2E50..0x82EE2E70)
	// 82EE2E50: EC0C07B2  fmuls f0, f12, f30
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EE2E54: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EE2E58: 4198FD30  blt cr6, 0x82ee2b88
	if ctx.cr[6].lt {
	pc = 0x82EE2B88; continue 'dispatch;
	}
	// 82EE2E5C: EDAD5828  fsubs f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EE2E60: EC005028  fsubs f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EE2E64: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EE2E68: FF001000  fcmpu cr6, f0, f2
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[2].f64);
	// 82EE2E6C: 48000078  b 0x82ee2ee4
	pc = 0x82EE2EE4; continue 'dispatch;
            }
            0x82EE2E70 => {
    //   block [0x82EE2E70..0x82EE2E8C)
	// 82EE2E70: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2E74: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EE2E78: 40980070  bge cr6, 0x82ee2ee8
	if !ctx.cr[6].lt {
	pc = 0x82EE2EE8; continue 'dispatch;
	}
	// 82EE2E7C: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82EE2E80: 4099000C  ble cr6, 0x82ee2e8c
	if !ctx.cr[6].gt {
	pc = 0x82EE2E8C; continue 'dispatch;
	}
	// 82EE2E84: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82EE2E88: 48000008  b 0x82ee2e90
	pc = 0x82EE2E90; continue 'dispatch;
            }
            0x82EE2E8C => {
    //   block [0x82EE2E8C..0x82EE2E90)
	// 82EE2E8C: EDAB082A  fadds f13, f11, f1
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[1].f64) as f32) as f64;
	pc = 0x82EE2E90; continue 'dispatch;
            }
            0x82EE2E90 => {
    //   block [0x82EE2E90..0x82EE2EB4)
	// 82EE2E90: EC0C07B2  fmuls f0, f12, f30
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EE2E94: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EE2E98: 4198FCF0  blt cr6, 0x82ee2b88
	if ctx.cr[6].lt {
	pc = 0x82EE2B88; continue 'dispatch;
	}
	// 82EE2E9C: EDAD5828  fsubs f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EE2EA0: EC005028  fsubs f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EE2EA4: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EE2EA8: FF001000  fcmpu cr6, f0, f2
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[2].f64);
	// 82EE2EAC: 4198FCDC  blt cr6, 0x82ee2b88
	if ctx.cr[6].lt {
	pc = 0x82EE2B88; continue 'dispatch;
	}
	// 82EE2EB0: 48000038  b 0x82ee2ee8
	pc = 0x82EE2EE8; continue 'dispatch;
            }
            0x82EE2EB4 => {
    //   block [0x82EE2EB4..0x82EE2EC8)
	// 82EE2EB4: EC00F9BA  fmadds f0, f0, f6, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[6].f64 + ctx.f[31].f64) as f32) as f64);
	// 82EE2EB8: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82EE2EBC: 4098000C  bge cr6, 0x82ee2ec8
	if !ctx.cr[6].lt {
	pc = 0x82EE2EC8; continue 'dispatch;
	}
	// 82EE2EC0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EE2EC4: 48000024  b 0x82ee2ee8
	pc = 0x82EE2EE8; continue 'dispatch;
            }
            0x82EE2EC8 => {
    //   block [0x82EE2EC8..0x82EE2EE4)
	// 82EE2EC8: 54C9063F  clrlwi. r9, r6, 0x18
	ctx.r[9].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EE2ECC: 4182001C  beq 0x82ee2ee8
	if ctx.cr[0].eq {
	pc = 0x82EE2EE8; continue 'dispatch;
	}
	// 82EE2ED0: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2ED4: ED850272  fmuls f12, f5, f9
	ctx.f[12].f64 = (((ctx.f[5].f64 * ctx.f[9].f64) as f32) as f64);
	// 82EE2ED8: C1AA0008  lfs f13, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE2EDC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE2EE0: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	pc = 0x82EE2EE4; continue 'dispatch;
            }
            0x82EE2EE4 => {
    //   block [0x82EE2EE4..0x82EE2EE8)
	// 82EE2EE4: 4199FCA4  bgt cr6, 0x82ee2b88
	if ctx.cr[6].gt {
	pc = 0x82EE2B88; continue 'dispatch;
	}
	pc = 0x82EE2EE8; continue 'dispatch;
            }
            0x82EE2EE8 => {
    //   block [0x82EE2EE8..0x82EE2EFC)
	// 82EE2EE8: FF014000  fcmpu cr6, f1, f8
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[8].f64);
	// 82EE2EEC: 41980010  blt cr6, 0x82ee2efc
	if ctx.cr[6].lt {
	pc = 0x82EE2EFC; continue 'dispatch;
	}
	// 82EE2EF0: 814A0020  lwz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EE2EF4: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82EE2EF8: 4800000C  b 0x82ee2f04
	pc = 0x82EE2F04; continue 'dispatch;
            }
            0x82EE2EFC => {
    //   block [0x82EE2EFC..0x82EE2F04)
	// 82EE2EFC: 814A001C  lwz r10, 0x1c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE2F00: 616B0008  ori r11, r11, 8
	ctx.r[11].u64 = ctx.r[11].u64 | 8;
	pc = 0x82EE2F04; continue 'dispatch;
            }
            0x82EE2F04 => {
    //   block [0x82EE2F04..0x82EE2F10)
	// 82EE2F04: 55690739  rlwinm. r9, r11, 0, 0x1c, 0x1c
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EE2F08: 41820008  beq 0x82ee2f10
	if ctx.cr[0].eq {
	pc = 0x82EE2F10; continue 'dispatch;
	}
	// 82EE2F0C: 556B0776  rlwinm r11, r11, 0, 0x1d, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	pc = 0x82EE2F10; continue 'dispatch;
            }
            0x82EE2F10 => {
    //   block [0x82EE2F10..0x82EE2F1C)
	// 82EE2F10: 5569077B  rlwinm. r9, r11, 0, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EE2F14: 41820008  beq 0x82ee2f1c
	if ctx.cr[0].eq {
	pc = 0x82EE2F1C; continue 'dispatch;
	}
	// 82EE2F18: 556B07B8  rlwinm r11, r11, 0, 0x1e, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	pc = 0x82EE2F1C; continue 'dispatch;
            }
            0x82EE2F1C => {
    //   block [0x82EE2F1C..0x82EE2F28)
	// 82EE2F1C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EE2F20: 409AFE8C  bne cr6, 0x82ee2dac
	if !ctx.cr[6].eq {
	pc = 0x82EE2DAC; continue 'dispatch;
	}
	// 82EE2F24: 48000028  b 0x82ee2f4c
	pc = 0x82EE2F4C; continue 'dispatch;
            }
            0x82EE2F28 => {
    //   block [0x82EE2F28..0x82EE2F4C)
	// 82EE2F28: 81650008  lwz r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE2F2C: 9BCB0030  stb r30, 0x30(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[30].u8 ) };
	// 82EE2F30: 81650008  lwz r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE2F34: 81250010  lwz r9, 0x10(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EE2F38: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EE2F3C: 912B002C  stw r9, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 82EE2F40: 81650008  lwz r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE2F44: 91450008  stw r10, 8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EE2F48: 91650010  stw r11, 0x10(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE2F4C; continue 'dispatch;
            }
            0x82EE2F4C => {
    //   block [0x82EE2F4C..0x82EE2FD8)
	// 82EE2F4C: 81650008  lwz r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE2F50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE2F54: 409AFFD4  bne cr6, 0x82ee2f28
	if !ctx.cr[6].eq {
	pc = 0x82EE2F28; continue 'dispatch;
	}
	// 82EE2F58: 93C5000C  stw r30, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82EE2F5C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EE2F60: 93C50014  stw r30, 0x14(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82EE2F64: C01F0074  lfs f0, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE2F68: EC0026FA  fmadds f0, f0, f27, f4
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[27].f64 + ctx.f[4].f64) as f32) as f64);
	// 82EE2F6C: C1BF0020  lfs f13, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE2F70: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE2F74: C19F0104  lfs f12, 0x104(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE2F78: C3FF00C0  lfs f31, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EE2F7C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EE2F80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EE2F84: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EE2F88: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EE2F8C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE2F90: EC400332  fmuls f2, f0, f12
	ctx.f[2].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE2F94: D05F00C0  stfs f2, 0xc0(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82EE2F98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE2F9C: 4E800421  bctrl
	ctx.lr = 0x82EE2FA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE2FA0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE2FA4: 809F00D4  lwz r4, 0xd4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EE2FA8: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82EE2FAC: D3FF00C0  stfs f31, 0xc0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82EE2FB0: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EE2FB4: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82EE2FB8: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82EE2FBC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EE2FC0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EE2FC4: 4800483D  bl 0x82ee7800
	ctx.lr = 0x82EE2FC8;
	sub_82EE7800(ctx, base);
	// 82EE2FC8: 817F00D4  lwz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EE2FCC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EE2FD0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE2FD4: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
            }
            0x82EE2FD8 => {
    //   block [0x82EE2FD8..0x82EE2FF8)
	// 82EE2FD8: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82EE2FDC: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 82EE2FE0: 4BDCAD39  bl 0x82cadd18
	ctx.lr = 0x82EE2FE4;
	sub_82CADCEC(ctx, base);
	// 82EE2FE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE2FE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EE2FEC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EE2FF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EE2FF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE2FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE2FF8 size=1132
    let mut pc: u32 = 0x82EE2FF8;
    'dispatch: loop {
        match pc {
            0x82EE2FF8 => {
    //   block [0x82EE2FF8..0x82EE301C)
	// 82EE2FF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE2FFC: 4BDC63FD  bl 0x82ca93f8
	ctx.lr = 0x82EE3000;
	sub_82CA93D0(ctx, base);
	// 82EE3000: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 82EE3004: 4BDCACC5  bl 0x82cadcc8
	ctx.lr = 0x82EE3008;
	sub_82CADCA0(ctx, base);
	// 82EE3008: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE300C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE3010: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EE3014: 817F00D4  lwz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EE3018: 48000028  b 0x82ee3040
	pc = 0x82EE3040; continue 'dispatch;
            }
            0x82EE301C => {
    //   block [0x82EE301C..0x82EE3040)
	// 82EE301C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE3020: 9B8A0030  stb r28, 0x30(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(48 as u32), ctx.r[28].u8 ) };
	// 82EE3024: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE3028: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EE302C: 812A002C  lwz r9, 0x2c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EE3030: 910A002C  stw r8, 0x2c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(44 as u32), ctx.r[8].u32 ) };
	// 82EE3034: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE3038: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82EE303C: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	pc = 0x82EE3040; continue 'dispatch;
            }
            0x82EE3040 => {
    //   block [0x82EE3040..0x82EE30A0)
	// 82EE3040: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE3044: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EE3048: 409AFFD4  bne cr6, 0x82ee301c
	if !ctx.cr[6].eq {
	pc = 0x82EE301C; continue 'dispatch;
	}
	// 82EE304C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EE3050: 938B000C  stw r28, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82EE3054: 938B0014  stw r28, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[28].u32 ) };
	// 82EE3058: 3F008200  lis r24, -0x7e00
	ctx.r[24].s64 = -2113929216;
	// 82EE305C: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EE3060: C01F0074  lfs f0, 0x74(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE3064: C1BF0020  lfs f13, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE3068: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 82EE306C: C37F00C0  lfs f27, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82EE3070: 7F9BE378  mr r27, r28
	ctx.r[27].u64 = ctx.r[28].u64;
	// 82EE3074: C30A0BFC  lfs f24, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 82EE3078: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EE307C: C0380C18  lfs f1, 0xc18(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(3096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EE3080: EDA06E3A  fmadds f13, f0, f24, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[24].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE3084: 3BCAAFB4  addi r30, r10, -0x504c
	ctx.r[30].s64 = ctx.r[10].s64 + -20556;
	// 82EE3088: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE308C: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82EE3090: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 82EE3094: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82EE3098: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE309C: 48000064  b 0x82ee3100
	pc = 0x82EE3100; continue 'dispatch;
            }
            0x82EE30A0 => {
    //   block [0x82EE30A0..0x82EE30B8)
	// 82EE30A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EE30A4: 409A0014  bne cr6, 0x82ee30b8
	if !ctx.cr[6].eq {
	pc = 0x82EE30B8; continue 'dispatch;
	}
	// 82EE30A8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE30AC: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82EE30B0: 41980008  blt cr6, 0x82ee30b8
	if ctx.cr[6].lt {
	pc = 0x82EE30B8; continue 'dispatch;
	}
	// 82EE30B4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	pc = 0x82EE30B8; continue 'dispatch;
            }
            0x82EE30B8 => {
    //   block [0x82EE30B8..0x82EE30E0)
	// 82EE30B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EE30BC: 409A0024  bne cr6, 0x82ee30e0
	if !ctx.cr[6].eq {
	pc = 0x82EE30E0; continue 'dispatch;
	}
	// 82EE30C0: FC006850  fneg f0, f13
	ctx.f[0].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE30C4: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE30C8: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82EE30CC: 40990030  ble cr6, 0x82ee30fc
	if !ctx.cr[6].gt {
	pc = 0x82EE30FC; continue 'dispatch;
	}
	// 82EE30D0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EE30D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE30D8: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82EE30DC: 419A0020  beq cr6, 0x82ee30fc
	if ctx.cr[6].eq {
	pc = 0x82EE30FC; continue 'dispatch;
	}
	pc = 0x82EE30E0; continue 'dispatch;
            }
            0x82EE30E0 => {
    //   block [0x82EE30E0..0x82EE30F0)
	// 82EE30E0: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE30E4: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EE30E8: 40980008  bge cr6, 0x82ee30f0
	if !ctx.cr[6].lt {
	pc = 0x82EE30F0; continue 'dispatch;
	}
	// 82EE30EC: FF600090  fmr f27, f0
	ctx.f[27].f64 = ctx.f[0].f64;
	pc = 0x82EE30F0; continue 'dispatch;
            }
            0x82EE30F0 => {
    //   block [0x82EE30F0..0x82EE30FC)
	// 82EE30F0: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE30F4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE30F8: 41990014  bgt cr6, 0x82ee310c
	if ctx.cr[6].gt {
	pc = 0x82EE310C; continue 'dispatch;
	}
	pc = 0x82EE30FC; continue 'dispatch;
            }
            0x82EE30FC => {
    //   block [0x82EE30FC..0x82EE3100)
	// 82EE30FC: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	pc = 0x82EE3100; continue 'dispatch;
            }
            0x82EE3100 => {
    //   block [0x82EE3100..0x82EE310C)
	// 82EE3100: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE3104: 4082FF9C  bne 0x82ee30a0
	if !ctx.cr[0].eq {
	pc = 0x82EE30A0; continue 'dispatch;
	}
	// 82EE3108: 48000008  b 0x82ee3110
	pc = 0x82EE3110; continue 'dispatch;
            }
            0x82EE310C => {
    //   block [0x82EE310C..0x82EE3110)
	// 82EE310C: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	pc = 0x82EE3110; continue 'dispatch;
            }
            0x82EE3110 => {
    //   block [0x82EE3110..0x82EE31C0)
	// 82EE3110: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE3114: 7F99E378  mr r25, r28
	ctx.r[25].u64 = ctx.r[28].u64;
	// 82EE3118: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EE311C: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 82EE3120: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82EE3124: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EE3128: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82EE312C: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EE3130: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE3134: 4E800421  bctrl
	ctx.lr = 0x82EE3138;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE3138: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE313C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EE3140: 809F00D4  lwz r4, 0xd4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EE3144: 3B4BAFB4  addi r26, r11, -0x504c
	ctx.r[26].s64 = ctx.r[11].s64 + -20556;
	// 82EE3148: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 82EE314C: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 82EE3150: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EE3154: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82EE3158: 480046A9  bl 0x82ee7800
	ctx.lr = 0x82EE315C;
	sub_82EE7800(ctx, base);
	// 82EE315C: C01F00C0  lfs f0, 0xc0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE3160: FF1B0000  fcmpu cr6, f27, f0
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[0].f64);
	// 82EE3164: 419A02F0  beq cr6, 0x82ee3454
	if ctx.cr[6].eq {
	pc = 0x82EE3454; continue 'dispatch;
	}
	// 82EE3168: C01F0104  lfs f0, 0x104(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE316C: C1BF00C8  lfs f13, 0xc8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE3170: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE3174: FF1B0000  fcmpu cr6, f27, f0
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[0].f64);
	// 82EE3178: 419902DC  bgt cr6, 0x82ee3454
	if ctx.cr[6].gt {
	pc = 0x82EE3454; continue 'dispatch;
	}
	// 82EE317C: 897F0024  lbz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EE3180: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE3184: 41820044  beq 0x82ee31c8
	if ctx.cr[0].eq {
	pc = 0x82EE31C8; continue 'dispatch;
	}
	// 82EE3188: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE318C: C01F0028  lfs f0, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE3190: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE3194: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE3198: 40980030  bge cr6, 0x82ee31c8
	if !ctx.cr[6].lt {
	pc = 0x82EE31C8; continue 'dispatch;
	}
	// 82EE319C: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EE31A0: 817F00D4  lwz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EE31A4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE31A8: EC000632  fmuls f0, f0, f24
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[24].f64) as f32) as f64);
	// 82EE31AC: C1AB001C  lfs f13, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE31B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EE31B4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE31B8: 41980008  blt cr6, 0x82ee31c0
	if ctx.cr[6].lt {
	pc = 0x82EE31C0; continue 'dispatch;
	}
	// 82EE31BC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
            }
            0x82EE31C0 => {
    //   block [0x82EE31C0..0x82EE31C8)
	// 82EE31C0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE31C4: 41820008  beq 0x82ee31cc
	if ctx.cr[0].eq {
	pc = 0x82EE31CC; continue 'dispatch;
	}
	pc = 0x82EE31C8; continue 'dispatch;
            }
            0x82EE31C8 => {
    //   block [0x82EE31C8..0x82EE31CC)
	// 82EE31C8: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	pc = 0x82EE31CC; continue 'dispatch;
            }
            0x82EE31CC => {
    //   block [0x82EE31CC..0x82EE321C)
	// 82EE31CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EE31D0: C01F0074  lfs f0, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE31D4: C1BF0048  lfs f13, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE31D8: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EE31DC: 3BAB9128  addi r29, r11, -0x6ed8
	ctx.r[29].s64 = ctx.r[11].s64 + -28376;
	// 82EE31E0: EFA06E3C  fnmsubs f29, f0, f24, f13
	ctx.f[29].f64 = -(((ctx.f[0].f64 * ctx.f[24].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE31E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE31E8: C3FF001C  lfs f31, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EE31EC: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82EE31F0: FFC0D890  fmr f30, f27
	ctx.f[30].f64 = ctx.f[27].f64;
	// 82EE31F4: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EE31F8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82EE31FC: 93A100D0  stw r29, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[29].u32 ) };
	// 82EE3200: C34B0C14  lfs f26, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82EE3204: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE3208: FF80D090  fmr f28, f26
	ctx.f[28].f64 = ctx.f[26].f64;
	// 82EE320C: FF1FE800  fcmpu cr6, f31, f29
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[29].f64);
	// 82EE3210: C32B0C80  lfs f25, 0xc80(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3200 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82EE3214: 4098010C  bge cr6, 0x82ee3320
	if !ctx.cr[6].lt {
	pc = 0x82EE3320; continue 'dispatch;
	}
	// 82EE3218: 48000008  b 0x82ee3220
	pc = 0x82EE3220; continue 'dispatch;
            }
            0x82EE321C => {
    //   block [0x82EE321C..0x82EE3220)
	// 82EE321C: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	pc = 0x82EE3220; continue 'dispatch;
            }
            0x82EE3220 => {
    //   block [0x82EE3220..0x82EE3238)
	// 82EE3220: C01F0074  lfs f0, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE3224: EDA0FE3A  fmadds f13, f0, f24, f31
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[24].f64 + ctx.f[31].f64) as f32) as f64);
	// 82EE3228: C18A000C  lfs f12, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE322C: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EE3230: C1980C18  lfs f12, 0xc18(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE3234: 4099004C  ble cr6, 0x82ee3280
	if !ctx.cr[6].gt {
	pc = 0x82EE3280; continue 'dispatch;
	}
	pc = 0x82EE3238; continue 'dispatch;
            }
            0x82EE3238 => {
    //   block [0x82EE3238..0x82EE3274)
	// 82EE3238: 814A0020  lwz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EE323C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82EE3240: C00A0010  lfs f0, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE3244: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82EE3248: 4098002C  bge cr6, 0x82ee3274
	if !ctx.cr[6].lt {
	pc = 0x82EE3274; continue 'dispatch;
	}
	// 82EE324C: FFC00090  fmr f30, f0
	ctx.f[30].f64 = ctx.f[0].f64;
	// 82EE3250: FF1E6000  fcmpu cr6, f30, f12
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[12].f64);
	// 82EE3254: 419A002C  beq cr6, 0x82ee3280
	if ctx.cr[6].eq {
	pc = 0x82EE3280; continue 'dispatch;
	}
	// 82EE3258: 896A0018  lbz r11, 0x18(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EE325C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE3260: 40820014  bne 0x82ee3274
	if !ctx.cr[0].eq {
	pc = 0x82EE3274; continue 'dispatch;
	}
	// 82EE3264: C01F0108  lfs f0, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE3268: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 82EE326C: 40980008  bge cr6, 0x82ee3274
	if !ctx.cr[6].lt {
	pc = 0x82EE3274; continue 'dispatch;
	}
	// 82EE3270: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	pc = 0x82EE3274; continue 'dispatch;
            }
            0x82EE3274 => {
    //   block [0x82EE3274..0x82EE3280)
	// 82EE3274: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE3278: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE327C: 4199FFBC  bgt cr6, 0x82ee3238
	if ctx.cr[6].gt {
	pc = 0x82EE3238; continue 'dispatch;
	}
	pc = 0x82EE3280; continue 'dispatch;
            }
            0x82EE3280 => {
    //   block [0x82EE3280..0x82EE32C4)
	// 82EE3280: FF1E6000  fcmpu cr6, f30, f12
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[12].f64);
	// 82EE3284: 409900A0  ble cr6, 0x82ee3324
	if !ctx.cr[6].gt {
	pc = 0x82EE3324; continue 'dispatch;
	}
	// 82EE3288: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE328C: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 82EE3290: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82EE3294: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82EE3298: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EE329C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EE32A0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82EE32A4: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EE32A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE32AC: 4E800421  bctrl
	ctx.lr = 0x82EE32B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE32B0: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE32B4: 41820010  beq 0x82ee32c4
	if ctx.cr[0].eq {
	pc = 0x82EE32C4; continue 'dispatch;
	}
	// 82EE32B8: C00100B0  lfs f0, 0xb0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE32BC: EC00D02A  fadds f0, f0, f26
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[26].f64) as f32) as f64;
	// 82EE32C0: D00100B0  stfs f0, 0xb0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
            }
            0x82EE32C4 => {
    //   block [0x82EE32C4..0x82EE32D0)
	// 82EE32C4: 809F00D4  lwz r4, 0xd4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EE32C8: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE32CC: 48000018  b 0x82ee32e4
	pc = 0x82EE32E4; continue 'dispatch;
            }
            0x82EE32D0 => {
    //   block [0x82EE32D0..0x82EE32E4)
	// 82EE32D0: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE32D4: C1A100B0  lfs f13, 0xb0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE32D8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE32DC: 40980010  bge cr6, 0x82ee32ec
	if !ctx.cr[6].lt {
	pc = 0x82EE32EC; continue 'dispatch;
	}
	// 82EE32E0: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	pc = 0x82EE32E4; continue 'dispatch;
            }
            0x82EE32E4 => {
    //   block [0x82EE32E4..0x82EE32EC)
	// 82EE32E4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE32E8: 4082FFE8  bne 0x82ee32d0
	if !ctx.cr[0].eq {
	pc = 0x82EE32D0; continue 'dispatch;
	}
	pc = 0x82EE32EC; continue 'dispatch;
            }
            0x82EE32EC => {
    //   block [0x82EE32EC..0x82EE3320)
	// 82EE32EC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EE32F0: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82EE32F4: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 82EE32F8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EE32FC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EE3300: 48004501  bl 0x82ee7800
	ctx.lr = 0x82EE3304;
	sub_82EE7800(ctx, base);
	// 82EE3304: FC00E090  fmr f0, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[28].f64;
	// 82EE3308: C1BF001C  lfs f13, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE330C: EF9C0672  fmuls f28, f28, f25
	ctx.f[28].f64 = (((ctx.f[28].f64 * ctx.f[25].f64) as f32) as f64);
	// 82EE3310: 93A100A0  stw r29, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[29].u32 ) };
	// 82EE3314: EFEDF83A  fmadds f31, f13, f0, f31
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64);
	// 82EE3318: FF1FE800  fcmpu cr6, f31, f29
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[29].f64);
	// 82EE331C: 4198FF00  blt cr6, 0x82ee321c
	if ctx.cr[6].lt {
	pc = 0x82EE321C; continue 'dispatch;
	}
	pc = 0x82EE3320; continue 'dispatch;
            }
            0x82EE3320 => {
    //   block [0x82EE3320..0x82EE3324)
	// 82EE3320: C1980C18  lfs f12, 0xc18(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EE3324; continue 'dispatch;
            }
            0x82EE3324 => {
    //   block [0x82EE3324..0x82EE3350)
	// 82EE3324: C01F001C  lfs f0, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE3328: FF80E850  fneg f28, f29
	ctx.f[28].u64 = ctx.f[29].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE332C: FFE00050  fneg f31, f0
	ctx.f[31].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE3330: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82EE3334: FFC0D890  fmr f30, f27
	ctx.f[30].f64 = ctx.f[27].f64;
	// 82EE3338: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EE333C: FFA0D090  fmr f29, f26
	ctx.f[29].f64 = ctx.f[26].f64;
	// 82EE3340: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EE3344: FF1FE000  fcmpu cr6, f31, f28
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[28].f64);
	// 82EE3348: 4099010C  ble cr6, 0x82ee3454
	if !ctx.cr[6].gt {
	pc = 0x82EE3454; continue 'dispatch;
	}
	// 82EE334C: 4800000C  b 0x82ee3358
	pc = 0x82EE3358; continue 'dispatch;
            }
            0x82EE3350 => {
    //   block [0x82EE3350..0x82EE3358)
	// 82EE3350: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EE3354: C1980C18  lfs f12, 0xc18(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EE3358; continue 'dispatch;
            }
            0x82EE3358 => {
    //   block [0x82EE3358..0x82EE336C)
	// 82EE3358: C01F0074  lfs f0, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE335C: EDA0FE3C  fnmsubs f13, f0, f24, f31
	ctx.f[13].f64 = -(((ctx.f[0].f64 * ctx.f[24].f64 - ctx.f[31].f64) as f32) as f64);
	// 82EE3360: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE3364: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82EE3368: 4098004C  bge cr6, 0x82ee33b4
	if !ctx.cr[6].lt {
	pc = 0x82EE33B4; continue 'dispatch;
	}
	pc = 0x82EE336C; continue 'dispatch;
            }
            0x82EE336C => {
    //   block [0x82EE336C..0x82EE33A8)
	// 82EE336C: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE3370: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EE3374: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE3378: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82EE337C: 4098002C  bge cr6, 0x82ee33a8
	if !ctx.cr[6].lt {
	pc = 0x82EE33A8; continue 'dispatch;
	}
	// 82EE3380: FFC00090  fmr f30, f0
	ctx.f[30].f64 = ctx.f[0].f64;
	// 82EE3384: FF1E6000  fcmpu cr6, f30, f12
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[12].f64);
	// 82EE3388: 419A002C  beq cr6, 0x82ee33b4
	if ctx.cr[6].eq {
	pc = 0x82EE33B4; continue 'dispatch;
	}
	// 82EE338C: 894B0018  lbz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EE3390: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE3394: 40820014  bne 0x82ee33a8
	if !ctx.cr[0].eq {
	pc = 0x82EE33A8; continue 'dispatch;
	}
	// 82EE3398: C01F0108  lfs f0, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE339C: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 82EE33A0: 40980008  bge cr6, 0x82ee33a8
	if !ctx.cr[6].lt {
	pc = 0x82EE33A8; continue 'dispatch;
	}
	// 82EE33A4: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	pc = 0x82EE33A8; continue 'dispatch;
            }
            0x82EE33A8 => {
    //   block [0x82EE33A8..0x82EE33B4)
	// 82EE33A8: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE33AC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE33B0: 4198FFBC  blt cr6, 0x82ee336c
	if ctx.cr[6].lt {
	pc = 0x82EE336C; continue 'dispatch;
	}
	pc = 0x82EE33B4; continue 'dispatch;
            }
            0x82EE33B4 => {
    //   block [0x82EE33B4..0x82EE33F8)
	// 82EE33B4: FF1E6000  fcmpu cr6, f30, f12
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[12].f64);
	// 82EE33B8: 4099009C  ble cr6, 0x82ee3454
	if !ctx.cr[6].gt {
	pc = 0x82EE3454; continue 'dispatch;
	}
	// 82EE33BC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE33C0: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 82EE33C4: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82EE33C8: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82EE33CC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EE33D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EE33D4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EE33D8: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EE33DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE33E0: 4E800421  bctrl
	ctx.lr = 0x82EE33E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE33E4: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE33E8: 41820010  beq 0x82ee33f8
	if ctx.cr[0].eq {
	pc = 0x82EE33F8; continue 'dispatch;
	}
	// 82EE33EC: C0010080  lfs f0, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE33F0: EC00D02A  fadds f0, f0, f26
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[26].f64) as f32) as f64;
	// 82EE33F4: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
            }
            0x82EE33F8 => {
    //   block [0x82EE33F8..0x82EE3404)
	// 82EE33F8: 809F00D4  lwz r4, 0xd4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EE33FC: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE3400: 48000018  b 0x82ee3418
	pc = 0x82EE3418; continue 'dispatch;
            }
            0x82EE3404 => {
    //   block [0x82EE3404..0x82EE3418)
	// 82EE3404: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE3408: C1A10080  lfs f13, 0x80(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE340C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE3410: 40980010  bge cr6, 0x82ee3420
	if !ctx.cr[6].lt {
	pc = 0x82EE3420; continue 'dispatch;
	}
	// 82EE3414: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	pc = 0x82EE3418; continue 'dispatch;
            }
            0x82EE3418 => {
    //   block [0x82EE3418..0x82EE3420)
	// 82EE3418: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE341C: 4082FFE8  bne 0x82ee3404
	if !ctx.cr[0].eq {
	pc = 0x82EE3404; continue 'dispatch;
	}
	pc = 0x82EE3420; continue 'dispatch;
            }
            0x82EE3420 => {
    //   block [0x82EE3420..0x82EE3454)
	// 82EE3420: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EE3424: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82EE3428: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82EE342C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EE3430: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EE3434: 480043CD  bl 0x82ee7800
	ctx.lr = 0x82EE3438;
	sub_82EE7800(ctx, base);
	// 82EE3438: FC00E890  fmr f0, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[29].f64;
	// 82EE343C: C1BF001C  lfs f13, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE3440: EFBD0672  fmuls f29, f29, f25
	ctx.f[29].f64 = (((ctx.f[29].f64 * ctx.f[25].f64) as f32) as f64);
	// 82EE3444: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82EE3448: EFEDF83C  fnmsubs f31, f13, f0, f31
	ctx.f[31].f64 = -(((ctx.f[13].f64 * ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82EE344C: FF1FE000  fcmpu cr6, f31, f28
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[28].f64);
	// 82EE3450: 4199FF00  bgt cr6, 0x82ee3350
	if ctx.cr[6].gt {
	pc = 0x82EE3350; continue 'dispatch;
	}
	pc = 0x82EE3454; continue 'dispatch;
            }
            0x82EE3454 => {
    //   block [0x82EE3454..0x82EE3464)
	// 82EE3454: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 82EE3458: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 82EE345C: 4BDCA8B9  bl 0x82cadd14
	ctx.lr = 0x82EE3460;
	sub_82CADCEC(ctx, base);
	// 82EE3460: 4BDC5FE8  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE3468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE3468 size=200
    let mut pc: u32 = 0x82EE3468;
    'dispatch: loop {
        match pc {
            0x82EE3468 => {
    //   block [0x82EE3468..0x82EE34B8)
	// 82EE3468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE346C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EE3470: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EE3474: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EE3478: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE347C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE3480: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EE3484: 897F00F9  lbz r11, 0xf9(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(249 as u32) ) } as u64;
	// 82EE3488: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE348C: 41820080  beq 0x82ee350c
	if ctx.cr[0].eq {
	pc = 0x82EE350C; continue 'dispatch;
	}
	// 82EE3490: 9BDF00F9  stb r30, 0xf9(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(249 as u32), ctx.r[30].u8 ) };
	// 82EE3494: 4BFFF6A5  bl 0x82ee2b38
	ctx.lr = 0x82EE3498;
	sub_82EE2B38(ctx, base);
	// 82EE3498: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE349C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE34A0: 41820018  beq 0x82ee34b8
	if ctx.cr[0].eq {
	pc = 0x82EE34B8; continue 'dispatch;
	}
	// 82EE34A4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE34A8: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EE34AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE34B0: 4E800421  bctrl
	ctx.lr = 0x82EE34B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE34B4: 48000064  b 0x82ee3518
	pc = 0x82EE3518; continue 'dispatch;
            }
            0x82EE34B8 => {
    //   block [0x82EE34B8..0x82EE34E8)
	// 82EE34B8: 4BFFFB41  bl 0x82ee2ff8
	ctx.lr = 0x82EE34BC;
	sub_82EE2FF8(ctx, base);
	// 82EE34BC: 817F00D4  lwz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EE34C0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE34C4: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 82EE34C8: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EE34CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE34D0: 409A003C  bne cr6, 0x82ee350c
	if !ctx.cr[6].eq {
	pc = 0x82EE350C; continue 'dispatch;
	}
	// 82EE34D4: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82EE34D8: C01F0038  lfs f0, 0x38(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE34DC: D01F00FC  stfs f0, 0xfc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82EE34E0: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82EE34E4: 48000028  b 0x82ee350c
	pc = 0x82EE350C; continue 'dispatch;
            }
            0x82EE34E8 => {
    //   block [0x82EE34E8..0x82EE350C)
	// 82EE34E8: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EE34EC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EE34F0: 40980028  bge cr6, 0x82ee3518
	if !ctx.cr[6].lt {
	pc = 0x82EE3518; continue 'dispatch;
	}
	// 82EE34F4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE34F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE34FC: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EE3500: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE3504: 4E800421  bctrl
	ctx.lr = 0x82EE3508;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE3508: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
            }
            0x82EE350C => {
    //   block [0x82EE350C..0x82EE3518)
	// 82EE350C: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE3510: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE3514: 409AFFD4  bne cr6, 0x82ee34e8
	if !ctx.cr[6].eq {
	pc = 0x82EE34E8; continue 'dispatch;
	}
	pc = 0x82EE3518; continue 'dispatch;
            }
            0x82EE3518 => {
    //   block [0x82EE3518..0x82EE3530)
	// 82EE3518: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EE351C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE3520: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EE3524: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EE3528: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EE352C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE3530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE3530 size=628
    let mut pc: u32 = 0x82EE3530;
    'dispatch: loop {
        match pc {
            0x82EE3530 => {
    //   block [0x82EE3530..0x82EE35B4)
	// 82EE3530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE3534: 4BDC5ED9  bl 0x82ca940c
	ctx.lr = 0x82EE3538;
	sub_82CA93D0(ctx, base);
	// 82EE3538: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82EE353C: 4BDCA795  bl 0x82cadcd0
	ctx.lr = 0x82EE3540;
	sub_82CADCA0(ctx, base);
	// 82EE3540: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE3544: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE3548: C0040058  lfs f0, 0x58(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE354C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE3550: C1240054  lfs f9, 0x54(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE3554: C0A40054  lfs f5, 0x54(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82EE3558: C0E40034  lfs f7, 0x34(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EE355C: C0C4003C  lfs f6, 0x3c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EE3560: C1BF0100  lfs f13, 0x100(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE3564: ED6D0072  fmuls f11, f13, f1
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[1].f64) as f32) as f64);
	// 82EE3568: C18B0BFC  lfs f12, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE356C: EDA000B2  fmuls f13, f0, f2
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[2].f64) as f32) as f64);
	// 82EE3570: C15F00B0  lfs f10, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE3574: C11F00B8  lfs f8, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE3578: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE357C: EF6B133C  fnmsubs f27, f11, f12, f2
	ctx.f[27].f64 = -(((ctx.f[11].f64 * ctx.f[12].f64 - ctx.f[2].f64) as f32) as f64);
	// 82EE3580: C164004C  lfs f11, 0x4c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE3584: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE3588: EDA90372  fmuls f13, f9, f13
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE358C: C124004C  lfs f9, 0x4c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE3590: ED4A0272  fmuls f10, f10, f9
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[9].f64) as f32) as f64);
	// 82EE3594: C12B0C18  lfs f9, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE3598: FF1B4800  fcmpu cr6, f27, f9
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[9].f64);
	// 82EE359C: ED45523A  fmadds f10, f5, f8, f10
	ctx.f[10].f64 = (((ctx.f[5].f64 * ctx.f[8].f64 + ctx.f[10].f64) as f32) as f64);
	// 82EE35A0: EF4A0032  fmuls f26, f10, f0
	ctx.f[26].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE35A4: EC07582A  fadds f0, f7, f11
	ctx.f[0].f64 = ((ctx.f[7].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EE35A8: ED46682A  fadds f10, f6, f13
	ctx.f[10].f64 = ((ctx.f[6].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE35AC: 40980008  bge cr6, 0x82ee35b4
	if !ctx.cr[6].lt {
	pc = 0x82EE35B4; continue 'dispatch;
	}
	// 82EE35B0: FF604890  fmr f27, f9
	ctx.f[27].f64 = ctx.f[9].f64;
	pc = 0x82EE35B4; continue 'dispatch;
            }
            0x82EE35B4 => {
    //   block [0x82EE35B4..0x82EE3604)
	// 82EE35B4: EDA10332  fmuls f13, f1, f12
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE35B8: C19F0064  lfs f12, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE35BC: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE35C0: C11F006C  lfs f8, 0x6c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE35C4: ED8A4028  fsubs f12, f10, f8
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EE35C8: C15F0098  lfs f10, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE35CC: C11F00A0  lfs f8, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE35D0: C17F004C  lfs f11, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE35D4: EC0A0032  fmuls f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE35D8: ED88033A  fmadds f12, f8, f12, f0
	ctx.f[12].f64 = (((ctx.f[8].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE35DC: EC0C6828  fsubs f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE35E0: EFED602A  fadds f31, f13, f12
	ctx.f[31].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EE35E4: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EE35E8: 419901AC  bgt cr6, 0x82ee3794
	if ctx.cr[6].gt {
	pc = 0x82EE3794; continue 'dispatch;
	}
	// 82EE35EC: FDA05850  fneg f13, f11
	ctx.f[13].u64 = ctx.f[11].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE35F0: FF1F6800  fcmpu cr6, f31, f13
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[13].f64);
	// 82EE35F4: 419801A0  blt cr6, 0x82ee3794
	if ctx.cr[6].lt {
	pc = 0x82EE3794; continue 'dispatch;
	}
	// 82EE35F8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE35FC: 40980008  bge cr6, 0x82ee3604
	if !ctx.cr[6].lt {
	pc = 0x82EE3604; continue 'dispatch;
	}
	// 82EE3600: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EE3604; continue 'dispatch;
            }
            0x82EE3604 => {
    //   block [0x82EE3604..0x82EE3610)
	// 82EE3604: FF1F5800  fcmpu cr6, f31, f11
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[11].f64);
	// 82EE3608: 40990008  ble cr6, 0x82ee3610
	if !ctx.cr[6].gt {
	pc = 0x82EE3610; continue 'dispatch;
	}
	// 82EE360C: FFE05890  fmr f31, f11
	ctx.f[31].f64 = ctx.f[11].f64;
	pc = 0x82EE3610; continue 'dispatch;
            }
            0x82EE3610 => {
    //   block [0x82EE3610..0x82EE368C)
	// 82EE3610: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE3614: C38B0BE8  lfs f28, 0xbe8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3048 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EE3618: FF1BE000  fcmpu cr6, f27, f28
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[28].f64);
	// 82EE361C: 40980148  bge cr6, 0x82ee3764
	if !ctx.cr[6].lt {
	pc = 0x82EE3764; continue 'dispatch;
	}
	// 82EE3620: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE3624: C19F0078  lfs f12, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE3628: C17F001C  lfs f11, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE362C: C1ABBAF4  lfs f13, -0x450c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17676 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE3630: EFCC5B7A  fmadds f30, f12, f13, f11
	ctx.f[30].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EE3634: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82EE3638: 4199012C  bgt cr6, 0x82ee3764
	if ctx.cr[6].gt {
	pc = 0x82EE3764; continue 'dispatch;
	}
	// 82EE363C: FFA0F050  fneg f29, f30
	ctx.f[29].u64 = ctx.f[30].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE3640: FF1FE800  fcmpu cr6, f31, f29
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[29].f64);
	// 82EE3644: 41980120  blt cr6, 0x82ee3764
	if ctx.cr[6].lt {
	pc = 0x82EE3764; continue 'dispatch;
	}
	// 82EE3648: EDBF002A  fadds f13, f31, f0
	ctx.f[13].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EE364C: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EE3650: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE3654: FF0D4800  fcmpu cr6, f13, f9
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[9].f64);
	// 82EE3658: 40990088  ble cr6, 0x82ee36e0
	if !ctx.cr[6].gt {
	pc = 0x82EE36E0; continue 'dispatch;
	}
	// 82EE365C: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 82EE3660: 4199002C  bgt cr6, 0x82ee368c
	if ctx.cr[6].gt {
	pc = 0x82EE368C; continue 'dispatch;
	}
	// 82EE3664: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EE3668: D00100F4  stfs f0, 0xf4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82EE366C: D3E100F8  stfs f31, 0xf8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82EE3670: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 82EE3674: D38100FC  stfs f28, 0xfc(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82EE3678: D3410100  stfs f26, 0x100(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82EE367C: 916100F0  stw r11, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 82EE3680: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE3684: 99610104  stb r11, 0x104(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[11].u8 ) };
	// 82EE3688: 48000108  b 0x82ee3790
	pc = 0x82EE3790; continue 'dispatch;
            }
            0x82EE368C => {
    //   block [0x82EE368C..0x82EE36E0)
	// 82EE368C: 3BABAFB4  addi r29, r11, -0x504c
	ctx.r[29].s64 = ctx.r[11].s64 + -20556;
	// 82EE3690: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EE3694: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EE3698: D3C10058  stfs f30, 0x58(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EE369C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EE36A0: D381005C  stfs f28, 0x5c(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EE36A4: D3410060  stfs f26, 0x60(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EE36A8: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82EE36AC: 9BC10064  stb r30, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u8 ) };
	// 82EE36B0: 4BFF97A9  bl 0x82edce58
	ctx.lr = 0x82EE36B4;
	sub_82EDCE58(ctx, base);
	// 82EE36B4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EE36B8: D3C10094  stfs f30, 0x94(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82EE36BC: D3E10098  stfs f31, 0x98(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82EE36C0: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82EE36C4: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EE36C8: D361009C  stfs f27, 0x9c(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82EE36CC: D34100A0  stfs f26, 0xa0(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82EE36D0: 93A10090  stw r29, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[29].u32 ) };
	// 82EE36D4: 9BC100A4  stb r30, 0xa4(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[30].u8 ) };
	// 82EE36D8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EE36DC: 480000B0  b 0x82ee378c
	pc = 0x82EE378C; continue 'dispatch;
            }
            0x82EE36E0 => {
    //   block [0x82EE36E0..0x82EE3710)
	// 82EE36E0: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82EE36E4: 4198002C  blt cr6, 0x82ee3710
	if ctx.cr[6].lt {
	pc = 0x82EE3710; continue 'dispatch;
	}
	// 82EE36E8: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EE36EC: D00100B4  stfs f0, 0xb4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82EE36F0: D3E100B8  stfs f31, 0xb8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82EE36F4: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82EE36F8: D38100BC  stfs f28, 0xbc(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82EE36FC: D34100C0  stfs f26, 0xc0(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82EE3700: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82EE3704: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE3708: 996100C4  stb r11, 0xc4(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[11].u8 ) };
	// 82EE370C: 48000084  b 0x82ee3790
	pc = 0x82EE3790; continue 'dispatch;
            }
            0x82EE3710 => {
    //   block [0x82EE3710..0x82EE3764)
	// 82EE3710: 3BABAFB4  addi r29, r11, -0x504c
	ctx.r[29].s64 = ctx.r[11].s64 + -20556;
	// 82EE3714: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EE3718: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EE371C: D3A10078  stfs f29, 0x78(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EE3720: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EE3724: D361007C  stfs f27, 0x7c(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82EE3728: D3410080  stfs f26, 0x80(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EE372C: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82EE3730: 9BC10084  stb r30, 0x84(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u8 ) };
	// 82EE3734: 4BFF9725  bl 0x82edce58
	ctx.lr = 0x82EE3738;
	sub_82EDCE58(ctx, base);
	// 82EE3738: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EE373C: D3A100D4  stfs f29, 0xd4(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EE3740: D3E100D8  stfs f31, 0xd8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EE3744: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 82EE3748: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EE374C: D38100DC  stfs f28, 0xdc(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EE3750: D34100E0  stfs f26, 0xe0(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EE3754: 93A100D0  stw r29, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[29].u32 ) };
	// 82EE3758: 9BC100E4  stb r30, 0xe4(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[30].u8 ) };
	// 82EE375C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EE3760: 4800002C  b 0x82ee378c
	pc = 0x82EE378C; continue 'dispatch;
            }
            0x82EE3764 => {
    //   block [0x82EE3764..0x82EE378C)
	// 82EE3764: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE3768: D0010114  stfs f0, 0x114(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82EE376C: D3E10118  stfs f31, 0x118(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 82EE3770: 38810110  addi r4, r1, 0x110
	ctx.r[4].s64 = ctx.r[1].s64 + 272;
	// 82EE3774: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EE3778: D361011C  stfs f27, 0x11c(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 82EE377C: D3410120  stfs f26, 0x120(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82EE3780: 91610110  stw r11, 0x110(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82EE3784: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE3788: 99610124  stb r11, 0x124(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), ctx.r[11].u8 ) };
	pc = 0x82EE378C; continue 'dispatch;
            }
            0x82EE378C => {
    //   block [0x82EE378C..0x82EE3790)
	// 82EE378C: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	pc = 0x82EE3790; continue 'dispatch;
            }
            0x82EE3790 => {
    //   block [0x82EE3790..0x82EE3794)
	// 82EE3790: 4BFF96C9  bl 0x82edce58
	ctx.lr = 0x82EE3794;
	sub_82EDCE58(ctx, base);
	pc = 0x82EE3794; continue 'dispatch;
            }
            0x82EE3794 => {
    //   block [0x82EE3794..0x82EE37A4)
	// 82EE3794: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 82EE3798: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82EE379C: 4BDCA581  bl 0x82cadd1c
	ctx.lr = 0x82EE37A0;
	sub_82CADCEC(ctx, base);
	// 82EE37A0: 4BDC5CBC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE37A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE37A8 size=1196
    let mut pc: u32 = 0x82EE37A8;
    'dispatch: loop {
        match pc {
            0x82EE37A8 => {
    //   block [0x82EE37A8..0x82EE38F4)
	// 82EE37A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE37AC: 4BDC5C4D  bl 0x82ca93f8
	ctx.lr = 0x82EE37B0;
	sub_82CA93D0(ctx, base);
	// 82EE37B0: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 82EE37B4: 4BDCA4ED  bl 0x82cadca0
	ctx.lr = 0x82EE37B8;
	sub_82CADCA0(ctx, base);
	// 82EE37B8: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE37BC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EE37C0: C1850008  lfs f12, 8(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE37C4: C0050000  lfs f0, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE37C8: FDC01890  fmr f14, f3
	ctx.f[14].f64 = ctx.f[3].f64;
	// 82EE37CC: 396BDBFC  addi r11, r11, -0x2404
	ctx.r[11].s64 = ctx.r[11].s64 + -9220;
	// 82EE37D0: C1A50004  lfs f13, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE37D4: EC8000B2  fmuls f4, f0, f2
	ctx.f[4].f64 = (((ctx.f[0].f64 * ctx.f[2].f64) as f32) as f64);
	// 82EE37D8: C1040000  lfs f8, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE37DC: EC6D00B2  fmuls f3, f13, f2
	ctx.f[3].f64 = (((ctx.f[13].f64 * ctx.f[2].f64) as f32) as f64);
	// 82EE37E0: C0E40004  lfs f7, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EE37E4: EC4C00B2  fmuls f2, f12, f2
	ctx.f[2].f64 = (((ctx.f[12].f64 * ctx.f[2].f64) as f32) as f64);
	// 82EE37E8: C0C40008  lfs f6, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EE37EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE37F0: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE37F4: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 82EE37F8: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE37FC: EFE002F2  fmuls f31, f0, f11
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE3800: C12B0004  lfs f9, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE3804: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE3808: EFAC0272  fmuls f29, f12, f9
	ctx.f[29].f64 = (((ctx.f[12].f64 * ctx.f[9].f64) as f32) as f64);
	// 82EE380C: 3B9F00B0  addi r28, r31, 0xb0
	ctx.r[28].s64 = ctx.r[31].s64 + 176;
	// 82EE3810: EF8D02B2  fmuls f28, f13, f10
	ctx.f[28].f64 = (((ctx.f[13].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EE3814: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 82EE3818: C36B0BEC  lfs f27, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82EE381C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE3820: FCA0D890  fmr f5, f27
	ctx.f[5].f64 = ctx.f[27].f64;
	// 82EE3824: FE00D890  fmr f16, f27
	ctx.f[16].f64 = ctx.f[27].f64;
	// 82EE3828: ED4CFAB8  fmsubs f10, f12, f10, f31
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[10].f64 - ctx.f[31].f64) as f32) as f64);
	// 82EE382C: C28B0C1C  lfs f20, 0xc1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3100 as u32) ) };
	ctx.f[20].f64 = (tmp.f32 as f64);
	// 82EE3830: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE3834: ED6DEAF8  fmsubs f11, f13, f11, f29
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[11].f64 - ctx.f[29].f64) as f32) as f64);
	// 82EE3838: C3BF0064  lfs f29, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EE383C: ED20E278  fmsubs f9, f0, f9, f28
	ctx.f[9].f64 = (((ctx.f[0].f64 * ctx.f[9].f64 - ctx.f[28].f64) as f32) as f64);
	// 82EE3840: C39F006C  lfs f28, 0x6c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EE3844: FFC0A090  fmr f30, f20
	ctx.f[30].f64 = ctx.f[20].f64;
	// 82EE3848: C26B0C18  lfs f19, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[19].f64 = (tmp.f32 as f64);
	// 82EE384C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE3850: FDE09890  fmr f15, f19
	ctx.f[15].f64 = ctx.f[19].f64;
	// 82EE3854: C3EB0BFC  lfs f31, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EE3858: EC0407F2  fmuls f0, f4, f31
	ctx.f[0].f64 = (((ctx.f[4].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EE385C: EDA307F2  fmuls f13, f3, f31
	ctx.f[13].f64 = (((ctx.f[3].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EE3860: EC8B0072  fmuls f4, f11, f1
	ctx.f[4].f64 = (((ctx.f[11].f64 * ctx.f[1].f64) as f32) as f64);
	// 82EE3864: EC6A0072  fmuls f3, f10, f1
	ctx.f[3].f64 = (((ctx.f[10].f64 * ctx.f[1].f64) as f32) as f64);
	// 82EE3868: ED8207F2  fmuls f12, f2, f31
	ctx.f[12].f64 = (((ctx.f[2].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EE386C: EC490072  fmuls f2, f9, f1
	ctx.f[2].f64 = (((ctx.f[9].f64 * ctx.f[1].f64) as f32) as f64);
	// 82EE3870: ED68002A  fadds f11, f8, f0
	ctx.f[11].f64 = ((ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EE3874: ED080028  fsubs f8, f8, f0
	ctx.f[8].f64 = (((ctx.f[8].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE3878: EC0407F2  fmuls f0, f4, f31
	ctx.f[0].f64 = (((ctx.f[4].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EE387C: ED47682A  fadds f10, f7, f13
	ctx.f[10].f64 = ((ctx.f[7].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE3880: ECE76828  fsubs f7, f7, f13
	ctx.f[7].f64 = (((ctx.f[7].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE3884: EDA307F2  fmuls f13, f3, f31
	ctx.f[13].f64 = (((ctx.f[3].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EE3888: ED26602A  fadds f9, f6, f12
	ctx.f[9].f64 = ((ctx.f[6].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EE388C: ECC66028  fsubs f6, f6, f12
	ctx.f[6].f64 = (((ctx.f[6].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE3890: ED8207F2  fmuls f12, f2, f31
	ctx.f[12].f64 = (((ctx.f[2].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EE3894: EC80582A  fadds f4, f0, f11
	ctx.f[4].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EE3898: D08100B0  stfs f4, 0xb0(r1)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82EE389C: EC8D502A  fadds f4, f13, f10
	ctx.f[4].f64 = ((ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64;
	// 82EE38A0: D08100B4  stfs f4, 0xb4(r1)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82EE38A4: EC80402A  fadds f4, f0, f8
	ctx.f[4].f64 = ((ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64;
	// 82EE38A8: D08100BC  stfs f4, 0xbc(r1)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82EE38AC: ED080028  fsubs f8, f8, f0
	ctx.f[8].f64 = (((ctx.f[8].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE38B0: D10100C8  stfs f8, 0xc8(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EE38B4: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE38B8: D00100D4  stfs f0, 0xd4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EE38BC: EC8C482A  fadds f4, f12, f9
	ctx.f[4].f64 = ((ctx.f[12].f64 + ctx.f[9].f64) as f32) as f64;
	// 82EE38C0: D08100B8  stfs f4, 0xb8(r1)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82EE38C4: EC8D382A  fadds f4, f13, f7
	ctx.f[4].f64 = ((ctx.f[13].f64 + ctx.f[7].f64) as f32) as f64;
	// 82EE38C8: D08100C0  stfs f4, 0xc0(r1)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82EE38CC: ED076828  fsubs f8, f7, f13
	ctx.f[8].f64 = (((ctx.f[7].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE38D0: D10100CC  stfs f8, 0xcc(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EE38D4: EC0A6828  fsubs f0, f10, f13
	ctx.f[0].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE38D8: D00100D8  stfs f0, 0xd8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EE38DC: EC8C302A  fadds f4, f12, f6
	ctx.f[4].f64 = ((ctx.f[12].f64 + ctx.f[6].f64) as f32) as f64;
	// 82EE38E0: D08100C4  stfs f4, 0xc4(r1)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EE38E4: ED066028  fsubs f8, f6, f12
	ctx.f[8].f64 = (((ctx.f[6].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE38E8: D10100D0  stfs f8, 0xd0(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82EE38EC: EC096028  fsubs f0, f9, f12
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE38F0: D00100DC  stfs f0, 0xdc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	pc = 0x82EE38F4; continue 'dispatch;
            }
            0x82EE38F4 => {
    //   block [0x82EE38F4..0x82EE3920)
	// 82EE38F4: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE38F8: EDA0E828  fsubs f13, f0, f29
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[29].f64) as f32) as f64);
	// 82EE38FC: C18A0008  lfs f12, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE3900: C01C0008  lfs f0, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE3904: ED8CE028  fsubs f12, f12, f28
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[28].f64) as f32) as f64);
	// 82EE3908: C17C0000  lfs f11, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE390C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE3910: EC0C02F8  fmsubs f0, f12, f11, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE3914: FF050000  fcmpu cr6, f5, f0
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[0].f64);
	// 82EE3918: 40990008  ble cr6, 0x82ee3920
	if !ctx.cr[6].gt {
	pc = 0x82EE3920; continue 'dispatch;
	}
	// 82EE391C: FCA00090  fmr f5, f0
	ctx.f[5].f64 = ctx.f[0].f64;
	pc = 0x82EE3920; continue 'dispatch;
            }
            0x82EE3920 => {
    //   block [0x82EE3920..0x82EE392C)
	// 82EE3920: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 82EE3924: 40980008  bge cr6, 0x82ee392c
	if !ctx.cr[6].lt {
	pc = 0x82EE392C; continue 'dispatch;
	}
	// 82EE3928: FFC00090  fmr f30, f0
	ctx.f[30].f64 = ctx.f[0].f64;
	pc = 0x82EE392C; continue 'dispatch;
            }
            0x82EE392C => {
    //   block [0x82EE392C..0x82EE394C)
	// 82EE392C: C17C0000  lfs f11, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE3930: EDAB0372  fmuls f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE3934: C17C0008  lfs f11, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE3938: EDAB6B3A  fmadds f13, f11, f12, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE393C: FF0D8000  fcmpu cr6, f13, f16
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[16].f64);
	// 82EE3940: 4098000C  bge cr6, 0x82ee394c
	if !ctx.cr[6].lt {
	pc = 0x82EE394C; continue 'dispatch;
	}
	// 82EE3944: FE006890  fmr f16, f13
	ctx.f[16].f64 = ctx.f[13].f64;
	// 82EE3948: FDE00090  fmr f15, f0
	ctx.f[15].f64 = ctx.f[0].f64;
	pc = 0x82EE394C; continue 'dispatch;
            }
            0x82EE394C => {
    //   block [0x82EE394C..0x82EE396C)
	// 82EE394C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EE3950: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82EE3954: 4082FFA0  bne 0x82ee38f4
	if !ctx.cr[0].eq {
	pc = 0x82EE38F4; continue 'dispatch;
	}
	// 82EE3958: C01F004C  lfs f0, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE395C: FDA00050  fneg f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE3960: FF056800  fcmpu cr6, f5, f13
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[13].f64);
	// 82EE3964: 40980008  bge cr6, 0x82ee396c
	if !ctx.cr[6].lt {
	pc = 0x82EE396C; continue 'dispatch;
	}
	// 82EE3968: FCA06890  fmr f5, f13
	ctx.f[5].f64 = ctx.f[13].f64;
	pc = 0x82EE396C; continue 'dispatch;
            }
            0x82EE396C => {
    //   block [0x82EE396C..0x82EE3978)
	// 82EE396C: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 82EE3970: 40990008  ble cr6, 0x82ee3978
	if !ctx.cr[6].gt {
	pc = 0x82EE3978; continue 'dispatch;
	}
	// 82EE3974: FFC00090  fmr f30, f0
	ctx.f[30].f64 = ctx.f[0].f64;
	pc = 0x82EE3978; continue 'dispatch;
            }
            0x82EE3978 => {
    //   block [0x82EE3978..0x82EE39A0)
	// 82EE3978: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EE397C: C19F0078  lfs f12, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE3980: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EE3984: EEACF7FA  fmadds f21, f12, f31, f30
	ctx.f[21].f64 = (((ctx.f[12].f64 * ctx.f[31].f64 + ctx.f[30].f64) as f32) as f64);
	// 82EE3988: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EE398C: C1AA0C14  lfs f13, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE3990: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE3994: 4182000C  beq 0x82ee39a0
	if ctx.cr[0].eq {
	pc = 0x82EE39A0; continue 'dispatch;
	}
	// 82EE3998: C16B000C  lfs f11, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE399C: 48000008  b 0x82ee39a4
	pc = 0x82EE39A4; continue 'dispatch;
            }
            0x82EE39A0 => {
    //   block [0x82EE39A0..0x82EE39A4)
	// 82EE39A0: FD606890  fmr f11, f13
	ctx.f[11].f64 = ctx.f[13].f64;
	pc = 0x82EE39A4; continue 'dispatch;
            }
            0x82EE39A4 => {
    //   block [0x82EE39A4..0x82EE39BC)
	// 82EE39A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EE39A8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE39AC: C00A0A54  lfs f0, 0xa54(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE39B0: EFAB0032  fmuls f29, f11, f0
	ctx.f[29].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE39B4: 41820008  beq 0x82ee39bc
	if ctx.cr[0].eq {
	pc = 0x82EE39BC; continue 'dispatch;
	}
	// 82EE39B8: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82EE39BC; continue 'dispatch;
            }
            0x82EE39BC => {
    //   block [0x82EE39BC..0x82EE39EC)
	// 82EE39BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE39C0: ED752828  fsubs f11, f21, f5
	ctx.f[11].f64 = (((ctx.f[21].f64 - ctx.f[5].f64) as f32) as f64);
	// 82EE39C4: C00B0AC8  lfs f0, 0xac8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2760 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE39C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE39CC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE39D0: C1AB0C4C  lfs f13, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE39D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EE39D8: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE39DC: EEC0E82A  fadds f22, f0, f29
	ctx.f[22].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 82EE39E0: FF0B6800  fcmpu cr6, f11, f13
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[13].f64);
	// 82EE39E4: 41990008  bgt cr6, 0x82ee39ec
	if ctx.cr[6].gt {
	pc = 0x82EE39EC; continue 'dispatch;
	}
	// 82EE39E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EE39EC; continue 'dispatch;
            }
            0x82EE39EC => {
    //   block [0x82EE39EC..0x82EE3A80)
	// 82EE39EC: C01C0000  lfs f0, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE39F0: 3B3F0098  addi r25, r31, 0x98
	ctx.r[25].s64 = ctx.r[31].s64 + 152;
	// 82EE39F4: C1BC0004  lfs f13, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE39F8: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EE39FC: C19C0008  lfs f12, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE3A00: EDAD0772  fmuls f13, f13, f29
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EE3A04: ED8C0772  fmuls f12, f12, f29
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EE3A08: C11F0064  lfs f8, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE3A0C: C0FF0068  lfs f7, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EE3A10: FF402890  fmr f26, f5
	ctx.f[26].f64 = ctx.f[5].f64;
	// 82EE3A14: C0DF006C  lfs f6, 0x6c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EE3A18: FF05A800  fcmpu cr6, f5, f21
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[21].f64);
	// 82EE3A1C: C1790000  lfs f11, 0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE3A20: 5578063E  clrlwi r24, r11, 0x18
	ctx.r[24].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EE3A24: C1590004  lfs f10, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE3A28: ED6B0172  fmuls f11, f11, f5
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[5].f64) as f32) as f64);
	// 82EE3A2C: C1390008  lfs f9, 8(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE3A30: ED4A0172  fmuls f10, f10, f5
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[5].f64) as f32) as f64);
	// 82EE3A34: ED290172  fmuls f9, f9, f5
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[5].f64) as f32) as f64);
	// 82EE3A38: EC080028  fsubs f0, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE3A3C: EDA76828  fsubs f13, f7, f13
	ctx.f[13].f64 = (((ctx.f[7].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE3A40: ED866028  fsubs f12, f6, f12
	ctx.f[12].f64 = (((ctx.f[6].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE3A44: EF20582A  fadds f25, f0, f11
	ctx.f[25].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EE3A48: D3210050  stfs f25, 0x50(r1)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EE3A4C: EF0D502A  fadds f24, f13, f10
	ctx.f[24].f64 = ((ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64;
	// 82EE3A50: D3010054  stfs f24, 0x54(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EE3A54: EEEC482A  fadds f23, f12, f9
	ctx.f[23].f64 = ((ctx.f[12].f64 + ctx.f[9].f64) as f32) as f64;
	// 82EE3A58: D2E10058  stfs f23, 0x58(r1)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EE3A5C: 409801E8  bge cr6, 0x82ee3c44
	if !ctx.cr[6].lt {
	pc = 0x82EE3C44; continue 'dispatch;
	}
	// 82EE3A60: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EE3A64: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EE3A68: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EE3A6C: 3B6B9128  addi r27, r11, -0x6ed8
	ctx.r[27].s64 = ctx.r[11].s64 + -28376;
	// 82EE3A70: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE3A74: C2290C8C  lfs f17, 0xc8c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3212 as u32) ) };
	ctx.f[17].f64 = (tmp.f32 as f64);
	// 82EE3A78: 3B4BAFB4  addi r26, r11, -0x504c
	ctx.r[26].s64 = ctx.r[11].s64 + -20556;
	// 82EE3A7C: C24A0BE8  lfs f18, 0xbe8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3048 as u32) ) };
	ctx.f[18].f64 = (tmp.f32 as f64);
	pc = 0x82EE3A80; continue 'dispatch;
            }
            0x82EE3A80 => {
    //   block [0x82EE3A80..0x82EE3AC0)
	// 82EE3A80: C01C0000  lfs f0, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE3A84: FFC0D890  fmr f30, f27
	ctx.f[30].f64 = ctx.f[27].f64;
	// 82EE3A88: C1BC0004  lfs f13, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE3A8C: EC0005B2  fmuls f0, f0, f22
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[22].f64) as f32) as f64);
	// 82EE3A90: C19C0008  lfs f12, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE3A94: EDB60372  fmuls f13, f22, f13
	ctx.f[13].f64 = (((ctx.f[22].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE3A98: ED960332  fmuls f12, f22, f12
	ctx.f[12].f64 = (((ctx.f[22].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE3A9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE3AA0: FF80A090  fmr f28, f20
	ctx.f[28].f64 = ctx.f[20].f64;
	// 82EE3AA4: 3BC100B0  addi r30, r1, 0xb0
	ctx.r[30].s64 = ctx.r[1].s64 + 176;
	// 82EE3AA8: EC00C82A  fadds f0, f0, f25
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[25].f64) as f32) as f64;
	// 82EE3AAC: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EE3AB0: EC0DC02A  fadds f0, f13, f24
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[24].f64) as f32) as f64;
	// 82EE3AB4: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EE3AB8: EC0CB82A  fadds f0, f12, f23
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[23].f64) as f32) as f64;
	// 82EE3ABC: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	pc = 0x82EE3AC0; continue 'dispatch;
            }
            0x82EE3AC0 => {
    //   block [0x82EE3AC0..0x82EE3AFC)
	// 82EE3AC0: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	// 82EE3AC4: FC20B090  fmr f1, f22
	ctx.f[1].f64 = ctx.f[22].f64;
	// 82EE3AC8: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 82EE3ACC: 57AB07BE  clrlwi r11, r29, 0x1e
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000003u64;
	// 82EE3AD0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EE3AD4: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EE3AD8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EE3ADC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EE3AE0: 7CEB5214  add r7, r11, r10
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EE3AE4: 4BFFC385  bl 0x82edfe68
	ctx.lr = 0x82EE3AE8;
	sub_82EDFE68(ctx, base);
	// 82EE3AE8: FF01D800  fcmpu cr6, f1, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[27].f64);
	// 82EE3AEC: 419A001C  beq cr6, 0x82ee3b08
	if ctx.cr[6].eq {
	pc = 0x82EE3B08; continue 'dispatch;
	}
	// 82EE3AF0: FF1C0800  fcmpu cr6, f28, f1
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[1].f64);
	// 82EE3AF4: 40980008  bge cr6, 0x82ee3afc
	if !ctx.cr[6].lt {
	pc = 0x82EE3AFC; continue 'dispatch;
	}
	// 82EE3AF8: FF800890  fmr f28, f1
	ctx.f[28].f64 = ctx.f[1].f64;
	pc = 0x82EE3AFC; continue 'dispatch;
            }
            0x82EE3AFC => {
    //   block [0x82EE3AFC..0x82EE3B08)
	// 82EE3AFC: FF1E0800  fcmpu cr6, f30, f1
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[1].f64);
	// 82EE3B00: 40990008  ble cr6, 0x82ee3b08
	if !ctx.cr[6].gt {
	pc = 0x82EE3B08; continue 'dispatch;
	}
	// 82EE3B04: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	pc = 0x82EE3B08; continue 'dispatch;
            }
            0x82EE3B08 => {
    //   block [0x82EE3B08..0x82EE3B2C)
	// 82EE3B08: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EE3B0C: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 82EE3B10: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82EE3B14: 4198FFAC  blt cr6, 0x82ee3ac0
	if ctx.cr[6].lt {
	pc = 0x82EE3AC0; continue 'dispatch;
	}
	// 82EE3B18: FF1CE800  fcmpu cr6, f28, f29
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[29].f64);
	// 82EE3B1C: 419800E4  blt cr6, 0x82ee3c00
	if ctx.cr[6].lt {
	pc = 0x82EE3C00; continue 'dispatch;
	}
	// 82EE3B20: FF1EE800  fcmpu cr6, f30, f29
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[29].f64);
	// 82EE3B24: 40980008  bge cr6, 0x82ee3b2c
	if !ctx.cr[6].lt {
	pc = 0x82EE3B2C; continue 'dispatch;
	}
	// 82EE3B28: FFC0E890  fmr f30, f29
	ctx.f[30].f64 = ctx.f[29].f64;
	pc = 0x82EE3B2C; continue 'dispatch;
            }
            0x82EE3B2C => {
    //   block [0x82EE3B2C..0x82EE3B58)
	// 82EE3B2C: EDBEE828  fsubs f13, f30, f29
	ctx.f[13].f64 = (((ctx.f[30].f64 - ctx.f[29].f64) as f32) as f64);
	// 82EE3B30: C17F0100  lfs f11, 0x100(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE3B34: C01F0078  lfs f0, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE3B38: C19F004C  lfs f12, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE3B3C: ED4D02F2  fmuls f10, f13, f11
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE3B40: EDA0D7FC  fnmsubs f13, f0, f31, f26
	ctx.f[13].f64 = -(((ctx.f[0].f64 * ctx.f[31].f64 - ctx.f[26].f64) as f32) as f64);
	// 82EE3B44: FD606050  fneg f11, f12
	ctx.f[11].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE3B48: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE3B4C: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82EE3B50: 40980008  bge cr6, 0x82ee3b58
	if !ctx.cr[6].lt {
	pc = 0x82EE3B58; continue 'dispatch;
	}
	// 82EE3B54: FDA05890  fmr f13, f11
	ctx.f[13].f64 = ctx.f[11].f64;
	pc = 0x82EE3B58; continue 'dispatch;
            }
            0x82EE3B58 => {
    //   block [0x82EE3B58..0x82EE3B64)
	// 82EE3B58: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EE3B5C: 40990008  ble cr6, 0x82ee3b64
	if !ctx.cr[6].gt {
	pc = 0x82EE3B64; continue 'dispatch;
	}
	// 82EE3B60: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	pc = 0x82EE3B64; continue 'dispatch;
            }
            0x82EE3B64 => {
    //   block [0x82EE3B64..0x82EE3B90)
	// 82EE3B64: FF109800  fcmpu cr6, f16, f19
	ctx.cr[6].compare_f64(ctx.f[16].f64, ctx.f[19].f64);
	// 82EE3B68: 40980070  bge cr6, 0x82ee3bd8
	if !ctx.cr[6].lt {
	pc = 0x82EE3BD8; continue 'dispatch;
	}
	// 82EE3B6C: FF0A9000  fcmpu cr6, f10, f18
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[18].f64);
	// 82EE3B70: 40980068  bge cr6, 0x82ee3bd8
	if !ctx.cr[6].lt {
	pc = 0x82EE3BD8; continue 'dispatch;
	}
	// 82EE3B74: FF0F9800  fcmpu cr6, f15, f19
	ctx.cr[6].compare_f64(ctx.f[15].f64, ctx.f[19].f64);
	// 82EE3B78: 41990018  bgt cr6, 0x82ee3b90
	if ctx.cr[6].gt {
	pc = 0x82EE3B90; continue 'dispatch;
	}
	// 82EE3B7C: C19F0078  lfs f12, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE3B80: C17F001C  lfs f11, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE3B84: ED8C5C78  fmsubs f12, f12, f17, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[17].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EE3B88: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EE3B8C: 40980020  bge cr6, 0x82ee3bac
	if !ctx.cr[6].lt {
	pc = 0x82EE3BAC; continue 'dispatch;
	}
	pc = 0x82EE3B90; continue 'dispatch;
            }
            0x82EE3B90 => {
    //   block [0x82EE3B90..0x82EE3BAC)
	// 82EE3B90: FF0F9800  fcmpu cr6, f15, f19
	ctx.cr[6].compare_f64(ctx.f[15].f64, ctx.f[19].f64);
	// 82EE3B94: 40990044  ble cr6, 0x82ee3bd8
	if !ctx.cr[6].gt {
	pc = 0x82EE3BD8; continue 'dispatch;
	}
	// 82EE3B98: C19F0078  lfs f12, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE3B9C: C17F001C  lfs f11, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE3BA0: ED8C5FFA  fmadds f12, f12, f31, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[31].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EE3BA4: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EE3BA8: 41990030  bgt cr6, 0x82ee3bd8
	if ctx.cr[6].gt {
	pc = 0x82EE3BD8; continue 'dispatch;
	}
	pc = 0x82EE3BAC; continue 'dispatch;
            }
            0x82EE3BAC => {
    //   block [0x82EE3BAC..0x82EE3BD8)
	// 82EE3BAC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EE3BB0: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EE3BB4: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EE3BB8: 93410070  stw r26, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[26].u32 ) };
	// 82EE3BBC: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EE3BC0: 9B010084  stb r24, 0x84(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[24].u8 ) };
	// 82EE3BC4: D241007C  stfs f18, 0x7c(r1)
	tmp.f32 = (ctx.f[18].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82EE3BC8: D1C10080  stfs f14, 0x80(r1)
	tmp.f32 = (ctx.f[14].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EE3BCC: 4BFF928D  bl 0x82edce58
	ctx.lr = 0x82EE3BD0;
	sub_82EDCE58(ctx, base);
	// 82EE3BD0: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 82EE3BD4: 4800002C  b 0x82ee3c00
	pc = 0x82EE3C00; continue 'dispatch;
            }
            0x82EE3BD8 => {
    //   block [0x82EE3BD8..0x82EE3C00)
	// 82EE3BD8: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82EE3BDC: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EE3BE0: D1A10094  stfs f13, 0x94(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82EE3BE4: 93410090  stw r26, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[26].u32 ) };
	// 82EE3BE8: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82EE3BEC: 9B0100A4  stb r24, 0xa4(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[24].u8 ) };
	// 82EE3BF0: D141009C  stfs f10, 0x9c(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82EE3BF4: D1C100A0  stfs f14, 0xa0(r1)
	tmp.f32 = (ctx.f[14].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82EE3BF8: 4BFF9261  bl 0x82edce58
	ctx.lr = 0x82EE3BFC;
	sub_82EDCE58(ctx, base);
	// 82EE3BFC: 93610090  stw r27, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[27].u32 ) };
	pc = 0x82EE3C00; continue 'dispatch;
            }
            0x82EE3C00 => {
    //   block [0x82EE3C00..0x82EE3C44)
	// 82EE3C00: C01F0078  lfs f0, 0x78(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE3C04: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EE3C08: C1B90000  lfs f13, 0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE3C0C: C1990004  lfs f12, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE3C10: C1790008  lfs f11, 8(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE3C14: EF40D02A  fadds f26, f0, f26
	ctx.f[26].f64 = ((ctx.f[0].f64 + ctx.f[26].f64) as f32) as f64;
	// 82EE3C18: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE3C1C: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE3C20: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE3C24: FF1AA800  fcmpu cr6, f26, f21
	ctx.cr[6].compare_f64(ctx.f[26].f64, ctx.f[21].f64);
	// 82EE3C28: EF2DC82A  fadds f25, f13, f25
	ctx.f[25].f64 = ((ctx.f[13].f64 + ctx.f[25].f64) as f32) as f64;
	// 82EE3C2C: D3210050  stfs f25, 0x50(r1)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EE3C30: EF0CC02A  fadds f24, f12, f24
	ctx.f[24].f64 = ((ctx.f[12].f64 + ctx.f[24].f64) as f32) as f64;
	// 82EE3C34: D3010054  stfs f24, 0x54(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EE3C38: EEE0B82A  fadds f23, f0, f23
	ctx.f[23].f64 = ((ctx.f[0].f64 + ctx.f[23].f64) as f32) as f64;
	// 82EE3C3C: D2E10058  stfs f23, 0x58(r1)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EE3C40: 4198FE40  blt cr6, 0x82ee3a80
	if ctx.cr[6].lt {
	pc = 0x82EE3A80; continue 'dispatch;
	}
	pc = 0x82EE3C44; continue 'dispatch;
            }
            0x82EE3C44 => {
    //   block [0x82EE3C44..0x82EE3C54)
	// 82EE3C44: 382101C0  addi r1, r1, 0x1c0
	ctx.r[1].s64 = ctx.r[1].s64 + 448;
	// 82EE3C48: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 82EE3C4C: 4BDCA0A1  bl 0x82cadcec
	ctx.lr = 0x82EE3C50;
	sub_82CADCEC(ctx, base);
	// 82EE3C50: 4BDC57F8  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE3C58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE3C58 size=1164
    let mut pc: u32 = 0x82EE3C58;
    'dispatch: loop {
        match pc {
            0x82EE3C58 => {
    //   block [0x82EE3C58..0x82EE3CCC)
	// 82EE3C58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE3C5C: 4BDC57AD  bl 0x82ca9408
	ctx.lr = 0x82EE3C60;
	sub_82CA93D0(ctx, base);
	// 82EE3C60: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82EE3C64: 4BDCA069  bl 0x82cadccc
	ctx.lr = 0x82EE3C68;
	sub_82CADCA0(ctx, base);
	// 82EE3C68: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE3C6C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EE3C70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE3C74: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EE3C78: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EE3C7C: 814B8F34  lwz r10, -0x70cc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28876 as u32) ) } as u64;
	// 82EE3C80: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EE3C84: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EE3C88: 914B8F34  stw r10, -0x70cc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-28876 as u32), ctx.r[10].u32 ) };
	// 82EE3C8C: 4BFA804D  bl 0x82e8bcd8
	ctx.lr = 0x82EE3C90;
	sub_82E8BCD8(ctx, base);
	// 82EE3C90: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EE3C94: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EE3C98: 388BC178  addi r4, r11, -0x3e88
	ctx.r[4].s64 = ctx.r[11].s64 + -16008;
	// 82EE3C9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EE3CA0: 4B3049D9  bl 0x821e8678
	ctx.lr = 0x82EE3CA4;
	sub_821E8678(ctx, base);
	// 82EE3CA4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EE3CA8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE3CAC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE3CB0: 3F808334  lis r28, -0x7ccc
	ctx.r[28].s64 = -2093744128;
	// 82EE3CB4: C3AA0C14  lfs f29, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EE3CB8: C36B0BFC  lfs f27, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82EE3CBC: 41820010  beq 0x82ee3ccc
	if ctx.cr[0].eq {
	pc = 0x82EE3CCC; continue 'dispatch;
	}
	// 82EE3CC0: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE3CC4: EC0006F2  fmuls f0, f0, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EE3CC8: 4800001C  b 0x82ee3ce4
	pc = 0x82EE3CE4; continue 'dispatch;
            }
            0x82EE3CCC => {
    //   block [0x82EE3CCC..0x82EE3CE0)
	// 82EE3CCC: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EE3CD0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE3CD4: 4182000C  beq 0x82ee3ce0
	if ctx.cr[0].eq {
	pc = 0x82EE3CE0; continue 'dispatch;
	}
	// 82EE3CD8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE3CDC: 48000008  b 0x82ee3ce4
	pc = 0x82EE3CE4; continue 'dispatch;
            }
            0x82EE3CE0 => {
    //   block [0x82EE3CE0..0x82EE3CE4)
	// 82EE3CE0: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	pc = 0x82EE3CE4; continue 'dispatch;
            }
            0x82EE3CE4 => {
    //   block [0x82EE3CE4..0x82EE3D64)
	// 82EE3CE4: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EE3CE8: C15F00C0  lfs f10, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE3CEC: EC0A002A  fadds f0, f10, f0
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EE3CF0: C1BE0038  lfs f13, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE3CF4: C19E003C  lfs f12, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE3CF8: C17E0034  lfs f11, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE3CFC: C14B0038  lfs f10, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE3D00: EDAD5028  fsubs f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EE3D04: C12B003C  lfs f9, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE3D08: EFEC4828  fsubs f31, f12, f9
	ctx.f[31].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EE3D0C: C18B0034  lfs f12, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE3D10: EFCB6028  fsubs f30, f11, f12
	ctx.f[30].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE3D14: C19F00A8  lfs f12, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE3D18: C17F00AC  lfs f11, 0xac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE3D1C: C13F00A4  lfs f9, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE3D20: FD400050  fneg f10, f0
	ctx.f[10].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE3D24: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE3D28: EDAB6FFA  fmadds f13, f11, f31, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[31].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE3D2C: EDBE6A7A  fmadds f13, f30, f9, f13
	ctx.f[13].f64 = (((ctx.f[30].f64 * ctx.f[9].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE3D30: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 82EE3D34: 419803A0  blt cr6, 0x82ee40d4
	if ctx.cr[6].lt {
	pc = 0x82EE40D4; continue 'dispatch;
	}
	// 82EE3D38: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE3D3C: 41990398  bgt cr6, 0x82ee40d4
	if ctx.cr[6].gt {
	pc = 0x82EE40D4; continue 'dispatch;
	}
	// 82EE3D40: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EE3D44: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EE3D48: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82EE3D4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EE3D50: 4B304929  bl 0x821e8678
	ctx.lr = 0x82EE3D54;
	sub_821E8678(ctx, base);
	// 82EE3D54: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE3D58: 4182000C  beq 0x82ee3d64
	if ctx.cr[0].eq {
	pc = 0x82EE3D64; continue 'dispatch;
	}
	// 82EE3D5C: C3230004  lfs f25, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82EE3D60: 4800001C  b 0x82ee3d7c
	pc = 0x82EE3D7C; continue 'dispatch;
            }
            0x82EE3D64 => {
    //   block [0x82EE3D64..0x82EE3D78)
	// 82EE3D64: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EE3D68: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE3D6C: 4182000C  beq 0x82ee3d78
	if ctx.cr[0].eq {
	pc = 0x82EE3D78; continue 'dispatch;
	}
	// 82EE3D70: C32B000C  lfs f25, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82EE3D74: 48000008  b 0x82ee3d7c
	pc = 0x82EE3D7C; continue 'dispatch;
            }
            0x82EE3D78 => {
    //   block [0x82EE3D78..0x82EE3D7C)
	// 82EE3D78: FF20E890  fmr f25, f29
	ctx.f[25].f64 = ctx.f[29].f64;
	pc = 0x82EE3D7C; continue 'dispatch;
            }
            0x82EE3D7C => {
    //   block [0x82EE3D7C..0x82EE3DAC)
	// 82EE3D7C: C01F0078  lfs f0, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE3D80: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EE3D84: EC00C82A  fadds f0, f0, f25
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[25].f64) as f32) as f64;
	// 82EE3D88: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EE3D8C: 388BDA4C  addi r4, r11, -0x25b4
	ctx.r[4].s64 = ctx.r[11].s64 + -9652;
	// 82EE3D90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EE3D94: EF8006F2  fmuls f28, f0, f27
	ctx.f[28].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EE3D98: 4B3048E1  bl 0x821e8678
	ctx.lr = 0x82EE3D9C;
	sub_821E8678(ctx, base);
	// 82EE3D9C: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82EE3DA0: 4182000C  beq 0x82ee3dac
	if ctx.cr[0].eq {
	pc = 0x82EE3DAC; continue 'dispatch;
	}
	// 82EE3DA4: C3BD0004  lfs f29, 4(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EE3DA8: 48000014  b 0x82ee3dbc
	pc = 0x82EE3DBC; continue 'dispatch;
            }
            0x82EE3DAC => {
    //   block [0x82EE3DAC..0x82EE3DBC)
	// 82EE3DAC: 817C0718  lwz r11, 0x718(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EE3DB0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE3DB4: 41820008  beq 0x82ee3dbc
	if ctx.cr[0].eq {
	pc = 0x82EE3DBC; continue 'dispatch;
	}
	// 82EE3DB8: C3AB000C  lfs f29, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	pc = 0x82EE3DBC; continue 'dispatch;
            }
            0x82EE3DBC => {
    //   block [0x82EE3DBC..0x82EE3DE8)
	// 82EE3DBC: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EE3DC0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EE3DC4: 388BD2C0  addi r4, r11, -0x2d40
	ctx.r[4].s64 = ctx.r[11].s64 + -11584;
	// 82EE3DC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EE3DCC: 4B3048AD  bl 0x821e8678
	ctx.lr = 0x82EE3DD0;
	sub_821E8678(ctx, base);
	// 82EE3DD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE3DD4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE3DD8: C34B0C18  lfs f26, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82EE3DDC: 4182000C  beq 0x82ee3de8
	if ctx.cr[0].eq {
	pc = 0x82EE3DE8; continue 'dispatch;
	}
	// 82EE3DE0: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 82EE3DE4: 48000024  b 0x82ee3e08
	pc = 0x82EE3E08; continue 'dispatch;
            }
            0x82EE3DE8 => {
    //   block [0x82EE3DE8..0x82EE3E08)
	// 82EE3DE8: C01E004C  lfs f0, 0x4c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE3DEC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EE3DF0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EE3DF4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EE3DF8: C01E0054  lfs f0, 0x54(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE3DFC: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EE3E00: D3410054  stfs f26, 0x54(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EE3E04: 4B39B465  bl 0x8227f268
	ctx.lr = 0x82EE3E08;
	sub_8227F268(ctx, base);
	pc = 0x82EE3E08; continue 'dispatch;
            }
            0x82EE3E08 => {
    //   block [0x82EE3E08..0x82EE3EB4)
	// 82EE3E08: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EE3E0C: C1430000  lfs f10, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE3E10: D1410060  stfs f10, 0x60(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EE3E14: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE3E18: 396BDBFC  addi r11, r11, -0x2404
	ctx.r[11].s64 = ctx.r[11].s64 + -9220;
	// 82EE3E1C: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE3E20: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EE3E24: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82EE3E28: C1230008  lfs f9, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE3E2C: D1210068  stfs f9, 0x68(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EE3E30: C0DF00B0  lfs f6, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EE3E34: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE3E38: C0EB0000  lfs f7, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EE3E3C: ECA902F2  fmuls f5, f9, f11
	ctx.f[5].f64 = (((ctx.f[9].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE3E40: ECED01F2  fmuls f7, f13, f7
	ctx.f[7].f64 = (((ctx.f[13].f64 * ctx.f[7].f64) as f32) as f64);
	// 82EE3E44: C10B0008  lfs f8, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE3E48: C00A0010  lfs f0, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE3E4C: C09F00B8  lfs f4, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82EE3E50: C19E0058  lfs f12, 0x58(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE3E54: C07E004C  lfs f3, 0x4c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82EE3E58: C05E0054  lfs f2, 0x54(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EE3E5C: ED0D2A38  fmsubs f8, f13, f8, f5
	ctx.f[8].f64 = (((ctx.f[13].f64 * ctx.f[8].f64 - ctx.f[5].f64) as f32) as f64);
	// 82EE3E60: ED6A3AF8  fmsubs f11, f10, f11, f7
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[11].f64 - ctx.f[7].f64) as f32) as f64);
	// 82EE3E64: EDA001B2  fmuls f13, f0, f6
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[6].f64) as f32) as f64);
	// 82EE3E68: ECE40032  fmuls f7, f4, f0
	ctx.f[7].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE3E6C: FCA03090  fmr f5, f6
	ctx.f[5].f64 = ctx.f[6].f64;
	// 82EE3E70: EDAC68F8  fmsubs f13, f12, f3, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[3].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE3E74: ED823B38  fmsubs f12, f2, f12, f7
	ctx.f[12].f64 = (((ctx.f[2].f64 * ctx.f[12].f64 - ctx.f[7].f64) as f32) as f64);
	// 82EE3E78: FCE03090  fmr f7, f6
	ctx.f[7].f64 = ctx.f[6].f64;
	// 82EE3E7C: FCC02090  fmr f6, f4
	ctx.f[6].f64 = ctx.f[4].f64;
	// 82EE3E80: EDAD0172  fmuls f13, f13, f5
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[5].f64) as f32) as f64);
	// 82EE3E84: ECE707B2  fmuls f7, f7, f30
	ctx.f[7].f64 = (((ctx.f[7].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EE3E88: ECA46B3A  fmadds f5, f4, f12, f13
	ctx.f[5].f64 = (((ctx.f[4].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE3E8C: ECC63FFA  fmadds f6, f6, f31, f7
	ctx.f[6].f64 = (((ctx.f[6].f64 * ctx.f[31].f64 + ctx.f[7].f64) as f32) as f64);
	// 82EE3E90: 409A0104  bne cr6, 0x82ee3f94
	if !ctx.cr[6].eq {
	pc = 0x82EE3F94; continue 'dispatch;
	}
	// 82EE3E94: FF06D000  fcmpu cr6, f6, f26
	ctx.cr[6].compare_f64(ctx.f[6].f64, ctx.f[26].f64);
	// 82EE3E98: 4198023C  blt cr6, 0x82ee40d4
	if ctx.cr[6].lt {
	pc = 0x82EE40D4; continue 'dispatch;
	}
	// 82EE3E9C: C17F001C  lfs f11, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE3EA0: EDABE02A  fadds f13, f11, f28
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[28].f64) as f32) as f64;
	// 82EE3EA4: FF066800  fcmpu cr6, f6, f13
	ctx.cr[6].compare_f64(ctx.f[6].f64, ctx.f[13].f64);
	// 82EE3EA8: 4098000C  bge cr6, 0x82ee3eb4
	if !ctx.cr[6].lt {
	pc = 0x82EE3EB4; continue 'dispatch;
	}
	// 82EE3EAC: FC00D090  fmr f0, f26
	ctx.f[0].f64 = ctx.f[26].f64;
	// 82EE3EB0: 48000090  b 0x82ee3f40
	pc = 0x82EE3F40; continue 'dispatch;
            }
            0x82EE3EB4 => {
    //   block [0x82EE3EB4..0x82EE3F28)
	// 82EE3EB4: FD800050  fneg f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE3EB8: FF056000  fcmpu cr6, f5, f12
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[12].f64);
	// 82EE3EBC: 4099006C  ble cr6, 0x82ee3f28
	if !ctx.cr[6].gt {
	pc = 0x82EE3F28; continue 'dispatch;
	}
	// 82EE3EC0: C19F0014  lfs f12, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE3EC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE3EC8: EC0C583A  fmadds f0, f12, f0, f11
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EE3ECC: C18B0C4C  lfs f12, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE3ED0: EC00E02A  fadds f0, f0, f28
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[28].f64) as f32) as f64;
	// 82EE3ED4: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE3ED8: FF060000  fcmpu cr6, f6, f0
	ctx.cr[6].compare_f64(ctx.f[6].f64, ctx.f[0].f64);
	// 82EE3EDC: 4199004C  bgt cr6, 0x82ee3f28
	if ctx.cr[6].gt {
	pc = 0x82EE3F28; continue 'dispatch;
	}
	// 82EE3EE0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE3EE4: C13F00A0  lfs f9, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE3EE8: C00B0C68  lfs f0, 0xc68(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE3EEC: ED4D0032  fmuls f10, f13, f0
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE3EF0: C01F0098  lfs f0, 0x98(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE3EF4: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EE3EF8: EC0907FA  fmadds f0, f9, f31, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE3EFC: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EE3F00: 41980028  blt cr6, 0x82ee3f28
	if ctx.cr[6].lt {
	pc = 0x82EE3F28; continue 'dispatch;
	}
	// 82EE3F04: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE3F08: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE3F0C: 4199001C  bgt cr6, 0x82ee3f28
	if ctx.cr[6].gt {
	pc = 0x82EE3F28; continue 'dispatch;
	}
	// 82EE3F10: C01F0100  lfs f0, 0x100(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE3F14: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE3F18: EC0001B2  fmuls f0, f0, f6
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[6].f64) as f32) as f64);
	// 82EE3F1C: C1AB0BEC  lfs f13, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE3F20: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE3F24: 409A0014  bne cr6, 0x82ee3f38
	if !ctx.cr[6].eq {
	pc = 0x82EE3F38; continue 'dispatch;
	}
	pc = 0x82EE3F28; continue 'dispatch;
            }
            0x82EE3F28 => {
    //   block [0x82EE3F28..0x82EE3F38)
	// 82EE3F28: FF05D000  fcmpu cr6, f5, f26
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[26].f64);
	// 82EE3F2C: 409801A8  bge cr6, 0x82ee40d4
	if !ctx.cr[6].lt {
	pc = 0x82EE40D4; continue 'dispatch;
	}
	// 82EE3F30: EC062824  fdivs f0, f6, f5
	ctx.f[0].f64 = ((ctx.f[6].f64 / ctx.f[5].f64) as f32) as f64;
	// 82EE3F34: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x82EE3F38; continue 'dispatch;
            }
            0x82EE3F38 => {
    //   block [0x82EE3F38..0x82EE3F40)
	// 82EE3F38: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82EE3F3C: 41980198  blt cr6, 0x82ee40d4
	if ctx.cr[6].lt {
	pc = 0x82EE40D4; continue 'dispatch;
	}
	pc = 0x82EE3F40; continue 'dispatch;
            }
            0x82EE3F40 => {
    //   block [0x82EE3F40..0x82EE3F60)
	// 82EE3F40: C1BF00BC  lfs f13, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE3F44: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE3F48: 40990018  ble cr6, 0x82ee3f60
	if !ctx.cr[6].gt {
	pc = 0x82EE3F60; continue 'dispatch;
	}
	// 82EE3F4C: C19F0100  lfs f12, 0x100(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE3F50: ED8C0672  fmuls f12, f12, f25
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[25].f64) as f32) as f64);
	// 82EE3F54: EDAC6EFA  fmadds f13, f12, f27, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[27].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE3F58: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE3F5C: 41990178  bgt cr6, 0x82ee40d4
	if ctx.cr[6].gt {
	pc = 0x82EE40D4; continue 'dispatch;
	}
	pc = 0x82EE3F60; continue 'dispatch;
            }
            0x82EE3F60 => {
    //   block [0x82EE3F60..0x82EE3F74)
	// 82EE3F60: C1BF0100  lfs f13, 0x100(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE3F64: EC4D02FC  fnmsubs f2, f13, f11, f0
	ctx.f[2].f64 = -(((ctx.f[13].f64 * ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE3F68: FF02D000  fcmpu cr6, f2, f26
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[26].f64);
	// 82EE3F6C: 40980008  bge cr6, 0x82ee3f74
	if !ctx.cr[6].lt {
	pc = 0x82EE3F74; continue 'dispatch;
	}
	// 82EE3F70: FC40D090  fmr f2, f26
	ctx.f[2].f64 = ctx.f[26].f64;
	pc = 0x82EE3F74; continue 'dispatch;
            }
            0x82EE3F74 => {
    //   block [0x82EE3F74..0x82EE3F94)
	// 82EE3F74: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE3F78: FC20C890  fmr f1, f25
	ctx.f[1].f64 = ctx.f[25].f64;
	// 82EE3F7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EE3F80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE3F84: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EE3F88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE3F8C: 4E800421  bctrl
	ctx.lr = 0x82EE3F90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE3F90: 48000144  b 0x82ee40d4
	pc = 0x82EE40D4; continue 'dispatch;
            }
            0x82EE3F94 => {
    //   block [0x82EE3F94..0x82EE3FD8)
	// 82EE3F94: C0FF001C  lfs f7, 0x1c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EE3F98: EC0A07B2  fmuls f0, f10, f30
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EE3F9C: EDBD3EFA  fmadds f13, f29, f27, f7
	ctx.f[13].f64 = (((ctx.f[29].f64 * ctx.f[27].f64 + ctx.f[7].f64) as f32) as f64);
	// 82EE3FA0: EC0907FA  fmadds f0, f9, f31, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE3FA4: FD806850  fneg f12, f13
	ctx.f[12].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE3FA8: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EE3FAC: 41980034  blt cr6, 0x82ee3fe0
	if ctx.cr[6].lt {
	pc = 0x82EE3FE0; continue 'dispatch;
	}
	// 82EE3FB0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE3FB4: 4199002C  bgt cr6, 0x82ee3fe0
	if ctx.cr[6].gt {
	pc = 0x82EE3FE0; continue 'dispatch;
	}
	// 82EE3FB8: EDA807B2  fmuls f13, f8, f30
	ctx.f[13].f64 = (((ctx.f[8].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EE3FBC: EC193EFA  fmadds f0, f25, f27, f7
	ctx.f[0].f64 = (((ctx.f[25].f64 * ctx.f[27].f64 + ctx.f[7].f64) as f32) as f64);
	// 82EE3FC0: EDAB6FFA  fmadds f13, f11, f31, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[31].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE3FC4: FD800050  fneg f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE3FC8: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EE3FCC: 41980014  blt cr6, 0x82ee3fe0
	if ctx.cr[6].lt {
	pc = 0x82EE3FE0; continue 'dispatch;
	}
	// 82EE3FD0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE3FD4: 4199000C  bgt cr6, 0x82ee3fe0
	if ctx.cr[6].gt {
	pc = 0x82EE3FE0; continue 'dispatch;
	}
	pc = 0x82EE3FD8; continue 'dispatch;
            }
            0x82EE3FD8 => {
    //   block [0x82EE3FD8..0x82EE3FE0)
	// 82EE3FD8: FC00D090  fmr f0, f26
	ctx.f[0].f64 = ctx.f[26].f64;
	// 82EE3FDC: 48000024  b 0x82ee4000
	pc = 0x82EE4000; continue 'dispatch;
            }
            0x82EE3FE0 => {
    //   block [0x82EE3FE0..0x82EE4000)
	// 82EE3FE0: FF06D000  fcmpu cr6, f6, f26
	ctx.cr[6].compare_f64(ctx.f[6].f64, ctx.f[26].f64);
	// 82EE3FE4: 4198FFF4  blt cr6, 0x82ee3fd8
	if ctx.cr[6].lt {
	pc = 0x82EE3FD8; continue 'dispatch;
	}
	// 82EE3FE8: FF05D000  fcmpu cr6, f5, f26
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[26].f64);
	// 82EE3FEC: 409800E8  bge cr6, 0x82ee40d4
	if !ctx.cr[6].lt {
	pc = 0x82EE40D4; continue 'dispatch;
	}
	// 82EE3FF0: EC062824  fdivs f0, f6, f5
	ctx.f[0].f64 = ((ctx.f[6].f64 / ctx.f[5].f64) as f32) as f64;
	// 82EE3FF4: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE3FF8: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82EE3FFC: 419800D8  blt cr6, 0x82ee40d4
	if ctx.cr[6].lt {
	pc = 0x82EE40D4; continue 'dispatch;
	}
	pc = 0x82EE4000; continue 'dispatch;
            }
            0x82EE4000 => {
    //   block [0x82EE4000..0x82EE401C)
	// 82EE4000: C17F00BC  lfs f11, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE4004: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EE4008: 40990034  ble cr6, 0x82ee403c
	if !ctx.cr[6].gt {
	pc = 0x82EE403C; continue 'dispatch;
	}
	// 82EE400C: FF19E800  fcmpu cr6, f25, f29
	ctx.cr[6].compare_f64(ctx.f[25].f64, ctx.f[29].f64);
	// 82EE4010: 4099000C  ble cr6, 0x82ee401c
	if !ctx.cr[6].gt {
	pc = 0x82EE401C; continue 'dispatch;
	}
	// 82EE4014: FD80C890  fmr f12, f25
	ctx.f[12].f64 = ctx.f[25].f64;
	// 82EE4018: 48000008  b 0x82ee4020
	pc = 0x82EE4020; continue 'dispatch;
            }
            0x82EE401C => {
    //   block [0x82EE401C..0x82EE4020)
	// 82EE401C: FD80E890  fmr f12, f29
	ctx.f[12].f64 = ctx.f[29].f64;
	pc = 0x82EE4020; continue 'dispatch;
            }
            0x82EE4020 => {
    //   block [0x82EE4020..0x82EE403C)
	// 82EE4020: C15F0100  lfs f10, 0x100(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE4024: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82EE4028: ED8A0332  fmuls f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE402C: C1AB11D0  lfs f13, 0x11d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4560 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE4030: EDAC5B7A  fmadds f13, f12, f13, f11
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EE4034: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE4038: 4199009C  bgt cr6, 0x82ee40d4
	if ctx.cr[6].gt {
	pc = 0x82EE40D4; continue 'dispatch;
	}
	pc = 0x82EE403C; continue 'dispatch;
            }
            0x82EE403C => {
    //   block [0x82EE403C..0x82EE4050)
	// 82EE403C: C1BF0100  lfs f13, 0x100(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE4040: EC0D01FC  fnmsubs f0, f13, f7, f0
	ctx.f[0].f64 = -(((ctx.f[13].f64 * ctx.f[7].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE4044: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82EE4048: 40980008  bge cr6, 0x82ee4050
	if !ctx.cr[6].lt {
	pc = 0x82EE4050; continue 'dispatch;
	}
	// 82EE404C: FC00D090  fmr f0, f26
	ctx.f[0].f64 = ctx.f[26].f64;
	pc = 0x82EE4050; continue 'dispatch;
            }
            0x82EE4050 => {
    //   block [0x82EE4050..0x82EE40D4)
	// 82EE4050: C19E004C  lfs f12, 0x4c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE4054: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE4058: FD006090  fmr f8, f12
	ctx.f[8].f64 = ctx.f[12].f64;
	// 82EE405C: C13F00B0  lfs f9, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE4060: C15E0054  lfs f10, 0x54(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE4064: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82EE4068: C0FF00B8  lfs f7, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EE406C: FC20C890  fmr f1, f25
	ctx.f[1].f64 = ctx.f[25].f64;
	// 82EE4070: C1BE0058  lfs f13, 0x58(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE4074: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82EE4078: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE407C: C17E0050  lfs f11, 0x50(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE4080: C0DE0034  lfs f6, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EE4084: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EE4088: C0BE0038  lfs f5, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82EE408C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EE4090: C09E003C  lfs f4, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82EE4094: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE4098: ED290232  fmuls f9, f9, f8
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[8].f64) as f32) as f64);
	// 82EE409C: FD005090  fmr f8, f10
	ctx.f[8].f64 = ctx.f[10].f64;
	// 82EE40A0: ED2849FA  fmadds f9, f8, f7, f9
	ctx.f[9].f64 = (((ctx.f[8].f64 * ctx.f[7].f64 + ctx.f[9].f64) as f32) as f64);
	// 82EE40A4: EC690372  fmuls f3, f9, f13
	ctx.f[3].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE40A8: EDAC0032  fmuls f13, f12, f0
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE40AC: ED8B0032  fmuls f12, f11, f0
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE40B0: EC0A0032  fmuls f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE40B4: EDA6682A  fadds f13, f6, f13
	ctx.f[13].f64 = ((ctx.f[6].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE40B8: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82EE40BC: EDA5602A  fadds f13, f5, f12
	ctx.f[13].f64 = ((ctx.f[5].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EE40C0: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EE40C4: EC04002A  fadds f0, f4, f0
	ctx.f[0].f64 = ((ctx.f[4].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EE40C8: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EE40CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE40D0: 4E800421  bctrl
	ctx.lr = 0x82EE40D4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EE40D4 => {
    //   block [0x82EE40D4..0x82EE40E4)
	// 82EE40D4: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82EE40D8: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82EE40DC: 4BDC9C3D  bl 0x82cadd18
	ctx.lr = 0x82EE40E0;
	sub_82CADCEC(ctx, base);
	// 82EE40E0: 4BDC5378  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE40E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE40E8 size=612
    let mut pc: u32 = 0x82EE40E8;
    'dispatch: loop {
        match pc {
            0x82EE40E8 => {
    //   block [0x82EE40E8..0x82EE4170)
	// 82EE40E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE40EC: 4BDC531D  bl 0x82ca9408
	ctx.lr = 0x82EE40F0;
	sub_82CA93D0(ctx, base);
	// 82EE40F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE40F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE40F8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EE40FC: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82EE4100: 9BDF00ED  stb r30, 0xed(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(237 as u32), ctx.r[30].u8 ) };
	// 82EE4104: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE4108: 409A023C  bne cr6, 0x82ee4344
	if !ctx.cr[6].eq {
	pc = 0x82EE4344; continue 'dispatch;
	}
	// 82EE410C: 3B9F0064  addi r28, r31, 0x64
	ctx.r[28].s64 = ctx.r[31].s64 + 100;
	// 82EE4110: C01F0088  lfs f0, 0x88(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4114: C19F008C  lfs f12, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE4118: C17F0100  lfs f11, 0x100(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE411C: C15F0014  lfs f10, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE4120: C1BC0000  lfs f13, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE4124: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE4128: C1BC0004  lfs f13, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE412C: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE4130: C13C0008  lfs f9, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE4134: C19F0090  lfs f12, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE4138: ED8C4828  fsubs f12, f12, f9
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EE413C: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE4140: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE4144: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE4148: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EE414C: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE4150: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EE4154: 4098001C  bge cr6, 0x82ee4170
	if !ctx.cr[6].lt {
	pc = 0x82EE4170; continue 'dispatch;
	}
	// 82EE4158: C01F007C  lfs f0, 0x7c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE415C: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EE4160: C01F0080  lfs f0, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4164: D01F008C  stfs f0, 0x8c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EE4168: C01F0084  lfs f0, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE416C: D01F0090  stfs f0, 0x90(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	pc = 0x82EE4170; continue 'dispatch;
            }
            0x82EE4170 => {
    //   block [0x82EE4170..0x82EE418C)
	// 82EE4170: 4B37C849  bl 0x822609b8
	ctx.lr = 0x82EE4174;
	sub_822609B8(ctx, base);
	// 82EE4174: 897F00EC  lbz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82EE4178: C1A3004C  lfs f13, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE417C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE4180: 4182000C  beq 0x82ee418c
	if ctx.cr[0].eq {
	pc = 0x82EE418C; continue 'dispatch;
	}
	// 82EE4184: 9BDF00EC  stb r30, 0xec(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[30].u8 ) };
	// 82EE4188: 48000010  b 0x82ee4198
	pc = 0x82EE4198; continue 'dispatch;
            }
            0x82EE418C => {
    //   block [0x82EE418C..0x82EE4198)
	// 82EE418C: C01F00C8  lfs f0, 0xc8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4190: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE4194: 419801B0  blt cr6, 0x82ee4344
	if ctx.cr[6].lt {
	pc = 0x82EE4344; continue 'dispatch;
	}
	pc = 0x82EE4198; continue 'dispatch;
            }
            0x82EE4198 => {
    //   block [0x82EE4198..0x82EE41C4)
	// 82EE4198: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE419C: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE41A0: C17F00C8  lfs f11, 0xc8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE41A4: C18B0A98  lfs f12, 0xa98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2712 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE41A8: ED805B3A  fmadds f12, f0, f12, f11
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EE41AC: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EE41B0: 40980014  bge cr6, 0x82ee41c4
	if !ctx.cr[6].lt {
	pc = 0x82EE41C4; continue 'dispatch;
	}
	// 82EE41B4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE41B8: 896B0410  lbz r11, 0x410(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1040 as u32) ) } as u64;
	// 82EE41BC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE41C0: 41820184  beq 0x82ee4344
	if ctx.cr[0].eq {
	pc = 0x82EE4344; continue 'dispatch;
	}
	pc = 0x82EE41C4; continue 'dispatch;
            }
            0x82EE41C4 => {
    //   block [0x82EE41C4..0x82EE4208)
	// 82EE41C4: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE41C8: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EE41CC: D01F00C8  stfs f0, 0xc8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EE41D0: 4B2E0119  bl 0x821c42e8
	ctx.lr = 0x82EE41D4;
	sub_821C42E8(ctx, base);
	// 82EE41D4: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EE41D8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EE41DC: 906BE260  stw r3, -0x1da0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-7584 as u32), ctx.r[3].u32 ) };
	// 82EE41E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE41E4: C19F00C4  lfs f12, 0xc4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE41E8: 995F00ED  stb r10, 0xed(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(237 as u32), ctx.r[10].u8 ) };
	// 82EE41EC: C17F0100  lfs f11, 0x100(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE41F0: C01F0048  lfs f0, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE41F4: C1AB0BFC  lfs f13, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE41F8: EDAC6AFA  fmadds f13, f12, f11, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE41FC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE4200: 41980008  blt cr6, 0x82ee4208
	if ctx.cr[6].lt {
	pc = 0x82EE4208; continue 'dispatch;
	}
	// 82EE4204: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EE4208; continue 'dispatch;
            }
            0x82EE4208 => {
    //   block [0x82EE4208..0x82EE423C)
	// 82EE4208: C05F004C  lfs f2, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EE420C: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EE4210: D01F00BC  stfs f0, 0xbc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82EE4214: FC600090  fmr f3, f0
	ctx.f[3].f64 = ctx.f[0].f64;
	// 82EE4218: FC201050  fneg f1, f2
	ctx.f[1].u64 = ctx.f[2].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE421C: 4BFF8B4D  bl 0x82edcd68
	ctx.lr = 0x82EE4220;
	sub_82EDCD68(ctx, base);
	// 82EE4220: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EE4224: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE4228: 41820070  beq 0x82ee4298
	if ctx.cr[0].eq {
	pc = 0x82EE4298; continue 'dispatch;
	}
	// 82EE422C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EE4230: C03F0010  lfs f1, 0x10(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EE4234: 4BFA3A75  bl 0x82e87ca8
	ctx.lr = 0x82EE4238;
	sub_82E87CA8(ctx, base);
	// 82EE4238: 48000054  b 0x82ee428c
	pc = 0x82EE428C; continue 'dispatch;
            }
            0x82EE423C => {
    //   block [0x82EE423C..0x82EE426C)
	// 82EE423C: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EE4240: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EE4244: 419A0040  beq cr6, 0x82ee4284
	if ctx.cr[6].eq {
	pc = 0x82EE4284; continue 'dispatch;
	}
	// 82EE4248: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EE424C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE4250: 4182001C  beq 0x82ee426c
	if ctx.cr[0].eq {
	pc = 0x82EE426C; continue 'dispatch;
	}
	// 82EE4254: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EE4258: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE425C: 4E800421  bctrl
	ctx.lr = 0x82EE4260;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE4260: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EE4264: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EE4268: 409A001C  bne cr6, 0x82ee4284
	if !ctx.cr[6].eq {
	pc = 0x82EE4284; continue 'dispatch;
	}
            }
            0x82EE426C => {
    //   block [0x82EE426C..0x82EE4284)
	// 82EE426C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE4270: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EE4274: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE4278: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EE427C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE4280: 4E800421  bctrl
	ctx.lr = 0x82EE4284;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EE4284 => {
    //   block [0x82EE4284..0x82EE428C)
	// 82EE4284: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EE4288: 4BFA34E9  bl 0x82e87770
	ctx.lr = 0x82EE428C;
	sub_82E87770(ctx, base);
	pc = 0x82EE428C; continue 'dispatch;
            }
            0x82EE428C => {
    //   block [0x82EE428C..0x82EE4298)
	// 82EE428C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EE4290: 4082FFAC  bne 0x82ee423c
	if !ctx.cr[0].eq {
	pc = 0x82EE423C; continue 'dispatch;
	}
	// 82EE4294: 480000B0  b 0x82ee4344
	pc = 0x82EE4344; continue 'dispatch;
            }
            0x82EE4298 => {
    //   block [0x82EE4298..0x82EE42AC)
	// 82EE4298: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EE429C: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EE42A0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE42A4: 83AB0008  lwz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE42A8: 48000094  b 0x82ee433c
	pc = 0x82EE433C; continue 'dispatch;
            }
            0x82EE42AC => {
    //   block [0x82EE42AC..0x82EE42E0)
	// 82EE42AC: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE42B0: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EE42B4: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EE42B8: 419A0080  beq cr6, 0x82ee4338
	if ctx.cr[6].eq {
	pc = 0x82EE4338; continue 'dispatch;
	}
	// 82EE42BC: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EE42C0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE42C4: 4182001C  beq 0x82ee42e0
	if ctx.cr[0].eq {
	pc = 0x82EE42E0; continue 'dispatch;
	}
	// 82EE42C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EE42CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE42D0: 4E800421  bctrl
	ctx.lr = 0x82EE42D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE42D4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EE42D8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EE42DC: 409A005C  bne cr6, 0x82ee4338
	if !ctx.cr[6].eq {
	pc = 0x82EE4338; continue 'dispatch;
	}
            }
            0x82EE42E0 => {
    //   block [0x82EE42E0..0x82EE4338)
	// 82EE42E0: C01F0010  lfs f0, 0x10(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE42E4: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE42E8: C1BC0000  lfs f13, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE42EC: C01E0034  lfs f0, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE42F0: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE42F4: C19C0004  lfs f12, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE42F8: C1BE0038  lfs f13, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE42FC: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE4300: C15E003C  lfs f10, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE4304: C19C0008  lfs f12, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE4308: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EE430C: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE4310: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE4314: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE4318: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EE431C: 4098001C  bge cr6, 0x82ee4338
	if !ctx.cr[6].lt {
	pc = 0x82EE4338; continue 'dispatch;
	}
	// 82EE4320: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE4324: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EE4328: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE432C: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EE4330: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE4334: 4E800421  bctrl
	ctx.lr = 0x82EE4338;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EE4338 => {
    //   block [0x82EE4338..0x82EE433C)
	// 82EE4338: 83BD000C  lwz r29, 0xc(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x82EE433C; continue 'dispatch;
            }
            0x82EE433C => {
    //   block [0x82EE433C..0x82EE4344)
	// 82EE433C: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE4340: 4082FF6C  bne 0x82ee42ac
	if !ctx.cr[0].eq {
	pc = 0x82EE42AC; continue 'dispatch;
	}
	pc = 0x82EE4344; continue 'dispatch;
            }
            0x82EE4344 => {
    //   block [0x82EE4344..0x82EE434C)
	// 82EE4344: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EE4348: 4BDC5110  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE4350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EE4350 size=96
    let mut pc: u32 = 0x82EE4350;
    'dispatch: loop {
        match pc {
            0x82EE4350 => {
    //   block [0x82EE4350..0x82EE4394)
	// 82EE4350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE4354: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EE4358: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EE435C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EE4360: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE4364: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE4368: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EE436C: 809F0094  lwz r4, 0x94(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EE4370: 7F04F000  cmpw cr6, r4, r30
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[30].s32, &mut ctx.xer);
	// 82EE4374: 419A0024  beq cr6, 0x82ee4398
	if ctx.cr[6].eq {
	pc = 0x82EE4398; continue 'dispatch;
	}
	// 82EE4378: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 82EE437C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE4380: 41820014  beq 0x82ee4394
	if ctx.cr[0].eq {
	pc = 0x82EE4394; continue 'dispatch;
	}
	// 82EE4384: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EE4388: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EE438C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE4390: 4E800421  bctrl
	ctx.lr = 0x82EE4394;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EE4394 => {
    //   block [0x82EE4394..0x82EE4398)
	// 82EE4394: 93DF0094  stw r30, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[30].u32 ) };
	pc = 0x82EE4398; continue 'dispatch;
            }
            0x82EE4398 => {
    //   block [0x82EE4398..0x82EE43B0)
	// 82EE4398: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EE439C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE43A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EE43A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EE43A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EE43AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE43B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE43B0 size=328
    let mut pc: u32 = 0x82EE43B0;
    'dispatch: loop {
        match pc {
            0x82EE43B0 => {
    //   block [0x82EE43B0..0x82EE4440)
	// 82EE43B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE43B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EE43B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EE43BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE43C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE43C4: 817F00CC  lwz r11, 0xcc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82EE43C8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE43CC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EE43D0: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82EE43D4: 419A00B8  beq cr6, 0x82ee448c
	if ctx.cr[6].eq {
	pc = 0x82EE448C; continue 'dispatch;
	}
	// 82EE43D8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EE43DC: C1AB0018  lfs f13, 0x18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE43E0: C00A0C18  lfs f0, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE43E4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE43E8: 419A00A0  beq cr6, 0x82ee4488
	if ctx.cr[6].eq {
	pc = 0x82EE4488; continue 'dispatch;
	}
	// 82EE43EC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE43F0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EE43F4: 389F0064  addi r4, r31, 0x64
	ctx.r[4].s64 = ctx.r[31].s64 + 100;
	// 82EE43F8: 38AB0004  addi r5, r11, 4
	ctx.r[5].s64 = ctx.r[11].s64 + 4;
	// 82EE43FC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE4400: 816A0050  lwz r11, 0x50(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EE4404: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE4408: 4E800421  bctrl
	ctx.lr = 0x82EE440C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE440C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE4410: 41820030  beq 0x82ee4440
	if ctx.cr[0].eq {
	pc = 0x82EE4440; continue 'dispatch;
	}
	// 82EE4414: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE4418: 38BF007C  addi r5, r31, 0x7c
	ctx.r[5].s64 = ctx.r[31].s64 + 124;
	// 82EE441C: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82EE4420: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EE4424: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE4428: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82EE442C: 816A0050  lwz r11, 0x50(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EE4430: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE4434: 4E800421  bctrl
	ctx.lr = 0x82EE4438;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE4438: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE443C: 4082004C  bne 0x82ee4488
	if !ctx.cr[0].eq {
	pc = 0x82EE4488; continue 'dispatch;
	}
            }
            0x82EE4440 => {
    //   block [0x82EE4440..0x82EE445C)
	// 82EE4440: 817F0104  lwz r11, 0x104(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 82EE4444: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82EE4448: 419A0014  beq cr6, 0x82ee445c
	if ctx.cr[6].eq {
	pc = 0x82EE445C; continue 'dispatch;
	}
	// 82EE444C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82EE4450: 419A000C  beq cr6, 0x82ee445c
	if ctx.cr[6].eq {
	pc = 0x82EE445C; continue 'dispatch;
	}
	// 82EE4454: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82EE4458: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE445C; continue 'dispatch;
            }
            0x82EE445C => {
    //   block [0x82EE445C..0x82EE4488)
	// 82EE445C: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82EE4460: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EE4464: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 82EE4468: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EE446C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE4470: 409A0074  bne cr6, 0x82ee44e4
	if !ctx.cr[6].eq {
	pc = 0x82EE44E4; continue 'dispatch;
	}
	// 82EE4474: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82EE4478: C01F0030  lfs f0, 0x30(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE447C: D01F00F0  stfs f0, 0xf0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82EE4480: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 82EE4484: 48000060  b 0x82ee44e4
	pc = 0x82EE44E4; continue 'dispatch;
            }
            0x82EE4488 => {
    //   block [0x82EE4488..0x82EE448C)
	// 82EE4488: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	pc = 0x82EE448C; continue 'dispatch;
            }
            0x82EE448C => {
    //   block [0x82EE448C..0x82EE44E4)
	// 82EE448C: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4490: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE4494: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EE4498: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE449C: D01F008C  stfs f0, 0x8c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EE44A0: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE44A4: D01F0090  stfs f0, 0x90(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82EE44A8: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82EE44AC: C00B0018  lfs f0, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE44B0: D01F00D0  stfs f0, 0xd0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82EE44B4: D01F00D4  stfs f0, 0xd4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EE44B8: C00B001C  lfs f0, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE44BC: D01F00DC  stfs f0, 0xdc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EE44C0: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE44C4: D01F00D8  stfs f0, 0xd8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EE44C8: C00B0020  lfs f0, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE44CC: D01F00E0  stfs f0, 0xe0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EE44D0: 915F00E8  stw r10, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[10].u32 ) };
	// 82EE44D4: 817F0104  lwz r11, 0x104(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 82EE44D8: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82EE44DC: 419A0008  beq cr6, 0x82ee44e4
	if ctx.cr[6].eq {
	pc = 0x82EE44E4; continue 'dispatch;
	}
	// 82EE44E0: 915F0104  stw r10, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[10].u32 ) };
	pc = 0x82EE44E4; continue 'dispatch;
            }
            0x82EE44E4 => {
    //   block [0x82EE44E4..0x82EE44F8)
	// 82EE44E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EE44E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE44EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EE44F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EE44F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE44F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE44F8 size=492
    let mut pc: u32 = 0x82EE44F8;
    'dispatch: loop {
        match pc {
            0x82EE44F8 => {
    //   block [0x82EE44F8..0x82EE4534)
	// 82EE44F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE44FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EE4500: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EE4504: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE4508: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE450C: 817F0104  lwz r11, 0x104(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 82EE4510: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82EE4514: 41980044  blt cr6, 0x82ee4558
	if ctx.cr[6].lt {
	pc = 0x82EE4558; continue 'dispatch;
	}
	// 82EE4518: 419A0038  beq cr6, 0x82ee4550
	if ctx.cr[6].eq {
	pc = 0x82EE4550; continue 'dispatch;
	}
	// 82EE451C: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82EE4520: 419A0014  beq cr6, 0x82ee4534
	if ctx.cr[6].eq {
	pc = 0x82EE4534; continue 'dispatch;
	}
	// 82EE4524: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82EE4528: 409A01A8  bne cr6, 0x82ee46d0
	if !ctx.cr[6].eq {
	pc = 0x82EE46D0; continue 'dispatch;
	}
	// 82EE452C: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82EE4530: 48000198  b 0x82ee46c8
	pc = 0x82EE46C8; continue 'dispatch;
            }
            0x82EE4534 => {
    //   block [0x82EE4534..0x82EE4538)
	// 82EE4534: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	pc = 0x82EE4538; continue 'dispatch;
            }
            0x82EE4538 => {
    //   block [0x82EE4538..0x82EE4550)
	// 82EE4538: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE453C: 4BFFFE15  bl 0x82ee4350
	ctx.lr = 0x82EE4540;
	sub_82EE4350(ctx, base);
	// 82EE4540: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE4544: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4548: D01F00E0  stfs f0, 0xe0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EE454C: 48000184  b 0x82ee46d0
	pc = 0x82EE46D0; continue 'dispatch;
            }
            0x82EE4550 => {
    //   block [0x82EE4550..0x82EE4558)
	// 82EE4550: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82EE4554: 4BFFFFE4  b 0x82ee4538
	pc = 0x82EE4538; continue 'dispatch;
            }
            0x82EE4558 => {
    //   block [0x82EE4558..0x82EE45A8)
	// 82EE4558: 897F0020  lbz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EE455C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE4560: 418200E8  beq 0x82ee4648
	if ctx.cr[0].eq {
	pc = 0x82EE4648; continue 'dispatch;
	}
	// 82EE4564: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE4568: C1BF0050  lfs f13, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE456C: C16B0C18  lfs f11, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE4570: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82EE4574: 419A00B4  beq cr6, 0x82ee4628
	if ctx.cr[6].eq {
	pc = 0x82EE4628; continue 'dispatch;
	}
	// 82EE4578: C19F00DC  lfs f12, 0xdc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE457C: C01F00BC  lfs f0, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4580: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82EE4584: 409800A4  bge cr6, 0x82ee4628
	if !ctx.cr[6].lt {
	pc = 0x82EE4628; continue 'dispatch;
	}
	// 82EE4588: C01F0100  lfs f0, 0x100(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE458C: C15F00C4  lfs f10, 0xc4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE4590: C13F0048  lfs f9, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE4594: EC0002B2  fmuls f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EE4598: EDA90372  fmuls f13, f9, f13
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE459C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE45A0: 41980008  blt cr6, 0x82ee45a8
	if ctx.cr[6].lt {
	pc = 0x82EE45A8; continue 'dispatch;
	}
	// 82EE45A4: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EE45A8; continue 'dispatch;
            }
            0x82EE45A8 => {
    //   block [0x82EE45A8..0x82EE4600)
	// 82EE45A8: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82EE45AC: 4199007C  bgt cr6, 0x82ee4628
	if ctx.cr[6].gt {
	pc = 0x82EE4628; continue 'dispatch;
	}
	// 82EE45B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE45B4: C1BF0024  lfs f13, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE45B8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE45BC: C19F00E0  lfs f12, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE45C0: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE45C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE45C8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE45CC: C1AA0010  lfs f13, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE45D0: ED400372  fmuls f10, f0, f13
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE45D4: C00B0A7C  lfs f0, 0xa7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE45D8: EC0A0032  fmuls f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE45DC: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82EE45E0: 41990048  bgt cr6, 0x82ee4628
	if ctx.cr[6].gt {
	pc = 0x82EE4628; continue 'dispatch;
	}
	// 82EE45E4: C01F0028  lfs f0, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE45E8: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EE45EC: 40990014  ble cr6, 0x82ee4600
	if !ctx.cr[6].gt {
	pc = 0x82EE4600; continue 'dispatch;
	}
	// 82EE45F0: D17F00E0  stfs f11, 0xe0(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EE45F4: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82EE45F8: D01F00F0  stfs f0, 0xf0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82EE45FC: 480000CC  b 0x82ee46c8
	pc = 0x82EE46C8; continue 'dispatch;
            }
            0x82EE4600 => {
    //   block [0x82EE4600..0x82EE4620)
	// 82EE4600: C01F002C  lfs f0, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4604: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE4608: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EE460C: 40990014  ble cr6, 0x82ee4620
	if !ctx.cr[6].gt {
	pc = 0x82EE4620; continue 'dispatch;
	}
	// 82EE4610: D1BF00E0  stfs f13, 0xe0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EE4614: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EE4618: D01F00F0  stfs f0, 0xf0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82EE461C: 480000B0  b 0x82ee46cc
	pc = 0x82EE46CC; continue 'dispatch;
            }
            0x82EE4620 => {
    //   block [0x82EE4620..0x82EE4628)
	// 82EE4620: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EE4624: 480000A8  b 0x82ee46cc
	pc = 0x82EE46CC; continue 'dispatch;
            }
            0x82EE4628 => {
    //   block [0x82EE4628..0x82EE4648)
	// 82EE4628: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE462C: C01F00E0  lfs f0, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4630: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE4634: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE4638: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE463C: 4098FFE4  bge cr6, 0x82ee4620
	if !ctx.cr[6].lt {
	pc = 0x82EE4620; continue 'dispatch;
	}
	// 82EE4640: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EE4644: 48000088  b 0x82ee46cc
	pc = 0x82EE46CC; continue 'dispatch;
            }
            0x82EE4648 => {
    //   block [0x82EE4648..0x82EE466C)
	// 82EE4648: C1BF00C4  lfs f13, 0xc4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE464C: C01F0100  lfs f0, 0x100(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4650: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE4654: C19F0050  lfs f12, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE4658: C1BF0048  lfs f13, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE465C: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE4660: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE4664: 41980008  blt cr6, 0x82ee466c
	if ctx.cr[6].lt {
	pc = 0x82EE466C; continue 'dispatch;
	}
	// 82EE4668: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EE466C; continue 'dispatch;
            }
            0x82EE466C => {
    //   block [0x82EE466C..0x82EE469C)
	// 82EE466C: C1BF00DC  lfs f13, 0xdc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE4670: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE4674: 40980050  bge cr6, 0x82ee46c4
	if !ctx.cr[6].lt {
	pc = 0x82EE46C4; continue 'dispatch;
	}
	// 82EE4678: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE467C: C1BF0028  lfs f13, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE4680: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4684: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE4688: 40990014  ble cr6, 0x82ee469c
	if !ctx.cr[6].gt {
	pc = 0x82EE469C; continue 'dispatch;
	}
	// 82EE468C: D01F00E0  stfs f0, 0xe0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EE4690: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82EE4694: D1BF00F0  stfs f13, 0xf0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82EE4698: 48000030  b 0x82ee46c8
	pc = 0x82EE46C8; continue 'dispatch;
            }
            0x82EE469C => {
    //   block [0x82EE469C..0x82EE46C4)
	// 82EE469C: C1BF002C  lfs f13, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE46A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE46A4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE46A8: 4099FF78  ble cr6, 0x82ee4620
	if !ctx.cr[6].gt {
	pc = 0x82EE4620; continue 'dispatch;
	}
	// 82EE46AC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE46B0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EE46B4: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE46B8: D01F00E0  stfs f0, 0xe0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EE46BC: D1BF00F0  stfs f13, 0xf0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82EE46C0: 4800000C  b 0x82ee46cc
	pc = 0x82EE46CC; continue 'dispatch;
            }
            0x82EE46C4 => {
    //   block [0x82EE46C4..0x82EE46C8)
	// 82EE46C4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x82EE46C8; continue 'dispatch;
            }
            0x82EE46C8 => {
    //   block [0x82EE46C8..0x82EE46CC)
	// 82EE46C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82EE46CC; continue 'dispatch;
            }
            0x82EE46CC => {
    //   block [0x82EE46CC..0x82EE46D0)
	// 82EE46CC: 4BFFFC85  bl 0x82ee4350
	ctx.lr = 0x82EE46D0;
	sub_82EE4350(ctx, base);
	pc = 0x82EE46D0; continue 'dispatch;
            }
            0x82EE46D0 => {
    //   block [0x82EE46D0..0x82EE46E4)
	// 82EE46D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EE46D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE46D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EE46DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EE46E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE46E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE46E8 size=672
    let mut pc: u32 = 0x82EE46E8;
    'dispatch: loop {
        match pc {
            0x82EE46E8 => {
    //   block [0x82EE46E8..0x82EE4744)
	// 82EE46E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE46EC: 4BDC4D19  bl 0x82ca9404
	ctx.lr = 0x82EE46F0;
	sub_82CA93D0(ctx, base);
	// 82EE46F0: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82EE46F4: 4BDC95C9  bl 0x82cadcbc
	ctx.lr = 0x82EE46F8;
	sub_82CADCA0(ctx, base);
	// 82EE46F8: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE46FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE4700: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE4704: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82EE4708: C01F0088  lfs f0, 0x88(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE470C: C1BF0064  lfs f13, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE4710: EF206828  fsubs f25, f0, f13
	ctx.f[25].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE4714: C01F0090  lfs f0, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4718: C1BF006C  lfs f13, 0x6c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE471C: FEC00090  fmr f22, f0
	ctx.f[22].f64 = ctx.f[0].f64;
	// 82EE4720: C38B0C18  lfs f28, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EE4724: EF006828  fsubs f24, f0, f13
	ctx.f[24].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE4728: C2BF00E0  lfs f21, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[21].f64 = (tmp.f32 as f64);
	// 82EE472C: C2FF0088  lfs f23, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 82EE4730: C37F008C  lfs f27, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82EE4734: FF19E000  fcmpu cr6, f25, f28
	ctx.cr[6].compare_f64(ctx.f[25].f64, ctx.f[28].f64);
	// 82EE4738: 409A000C  bne cr6, 0x82ee4744
	if !ctx.cr[6].eq {
	pc = 0x82EE4744; continue 'dispatch;
	}
	// 82EE473C: FF18E000  fcmpu cr6, f24, f28
	ctx.cr[6].compare_f64(ctx.f[24].f64, ctx.f[28].f64);
	// 82EE4740: 419A0124  beq cr6, 0x82ee4864
	if ctx.cr[6].eq {
	pc = 0x82EE4864; continue 'dispatch;
	}
	pc = 0x82EE4744; continue 'dispatch;
            }
            0x82EE4744 => {
    //   block [0x82EE4744..0x82EE4798)
	// 82EE4744: 897F0038  lbz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EE4748: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE474C: 41820118  beq 0x82ee4864
	if ctx.cr[0].eq {
	pc = 0x82EE4864; continue 'dispatch;
	}
	// 82EE4750: EC190672  fmuls f0, f25, f25
	ctx.f[0].f64 = (((ctx.f[25].f64 * ctx.f[25].f64) as f32) as f64);
	// 82EE4754: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EE4758: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EE475C: C1AB004C  lfs f13, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE4760: EDAD0672  fmuls f13, f13, f25
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[25].f64) as f32) as f64);
	// 82EE4764: C18B0054  lfs f12, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE4768: C3EA0C14  lfs f31, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EE476C: C16B0050  lfs f11, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE4770: EC18063A  fmadds f0, f24, f24, f0
	ctx.f[0].f64 = (((ctx.f[24].f64 * ctx.f[24].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE4774: EDAC6E3A  fmadds f13, f12, f24, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[24].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE4778: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EE477C: EC1F0024  fdivs f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EE4780: EDAB6F3A  fmadds f13, f11, f28, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[28].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE4784: EFC00372  fmuls f30, f0, f13
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE4788: FF1EE000  fcmpu cr6, f30, f28
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[28].f64);
	// 82EE478C: 4098000C  bge cr6, 0x82ee4798
	if !ctx.cr[6].lt {
	pc = 0x82EE4798; continue 'dispatch;
	}
	// 82EE4790: FFC0E090  fmr f30, f28
	ctx.f[30].f64 = ctx.f[28].f64;
	// 82EE4794: 48000010  b 0x82ee47a4
	pc = 0x82EE47A4; continue 'dispatch;
            }
            0x82EE4798 => {
    //   block [0x82EE4798..0x82EE47A4)
	// 82EE4798: FF1EF800  fcmpu cr6, f30, f31
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 82EE479C: 40990008  ble cr6, 0x82ee47a4
	if !ctx.cr[6].gt {
	pc = 0x82EE47A4; continue 'dispatch;
	}
	// 82EE47A0: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	pc = 0x82EE47A4; continue 'dispatch;
            }
            0x82EE47A4 => {
    //   block [0x82EE47A4..0x82EE47B8)
	// 82EE47A4: 4B37C215  bl 0x822609b8
	ctx.lr = 0x82EE47A8;
	sub_822609B8(ctx, base);
	// 82EE47A8: C0030058  lfs f0, 0x58(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE47AC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EE47B0: 40990008  ble cr6, 0x82ee47b8
	if !ctx.cr[6].gt {
	pc = 0x82EE47B8; continue 'dispatch;
	}
	// 82EE47B4: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x82EE47B8; continue 'dispatch;
            }
            0x82EE47B8 => {
    //   block [0x82EE47B8..0x82EE47E0)
	// 82EE47B8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EE47BC: C19F003C  lfs f12, 0x3c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE47C0: C1ABE274  lfs f13, -0x1d8c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7564 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE47C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE47C8: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE47CC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE47D0: C1ABBE00  lfs f13, -0x4200(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16896 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE47D4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE47D8: 40990008  ble cr6, 0x82ee47e0
	if !ctx.cr[6].gt {
	pc = 0x82EE47E0; continue 'dispatch;
	}
	// 82EE47DC: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EE47E0; continue 'dispatch;
            }
            0x82EE47E0 => {
    //   block [0x82EE47E0..0x82EE4830)
	// 82EE47E0: FF400090  fmr f26, f0
	ctx.f[26].f64 = ctx.f[0].f64;
	// 82EE47E4: FC20D090  fmr f1, f26
	ctx.f[1].f64 = ctx.f[26].f64;
	// 82EE47E8: 4B3556C9  bl 0x82239eb0
	ctx.lr = 0x82EE47EC;
	sub_82239EB0(ctx, base);
	// 82EE47EC: FFA00818  frsp f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EE47F0: FF1EE800  fcmpu cr6, f30, f29
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[29].f64);
	// 82EE47F4: 41990070  bgt cr6, 0x82ee4864
	if ctx.cr[6].gt {
	pc = 0x82EE4864; continue 'dispatch;
	}
	// 82EE47F8: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EE47FC: FC20D090  fmr f1, f26
	ctx.f[1].f64 = ctx.f[26].f64;
	// 82EE4800: C3CB0054  lfs f30, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EE4804: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 82EE4808: C3EB004C  lfs f31, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EE480C: FDA0F890  fmr f13, f31
	ctx.f[13].f64 = ctx.f[31].f64;
	// 82EE4810: C36B0050  lfs f27, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82EE4814: EC000672  fmuls f0, f0, f25
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[25].f64) as f32) as f64);
	// 82EE4818: EC0D0638  fmsubs f0, f13, f24, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[24].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE481C: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 82EE4820: 41980010  blt cr6, 0x82ee4830
	if ctx.cr[6].lt {
	pc = 0x82EE4830; continue 'dispatch;
	}
	// 82EE4824: 4B35576D  bl 0x82239f90
	ctx.lr = 0x82EE4828;
	sub_82239F90(ctx, base);
	// 82EE4828: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EE482C: 48000010  b 0x82ee483c
	pc = 0x82EE483C; continue 'dispatch;
            }
            0x82EE4830 => {
    //   block [0x82EE4830..0x82EE483C)
	// 82EE4830: 4B355761  bl 0x82239f90
	ctx.lr = 0x82EE4834;
	sub_82239F90(ctx, base);
	// 82EE4834: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82EE4838: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x82EE483C; continue 'dispatch;
            }
            0x82EE483C => {
    //   block [0x82EE483C..0x82EE4864)
	// 82EE483C: EDA007B2  fmuls f13, f0, f30
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EE4840: C17F0064  lfs f11, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE4844: ED9E0772  fmuls f12, f30, f29
	ctx.f[12].f64 = (((ctx.f[30].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EE4848: C15F006C  lfs f10, 0x6c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE484C: EDBF6F78  fmsubs f13, f31, f29, f13
	ctx.f[13].f64 = (((ctx.f[31].f64 * ctx.f[29].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE4850: EC0067FA  fmadds f0, f0, f31, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[12].f64) as f32) as f64);
	// 82EE4854: C19F0068  lfs f12, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE4858: EF6CD82A  fadds f27, f12, f27
	ctx.f[27].f64 = ((ctx.f[12].f64 + ctx.f[27].f64) as f32) as f64;
	// 82EE485C: EEED582A  fadds f23, f13, f11
	ctx.f[23].f64 = ((ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EE4860: EECA002A  fadds f22, f10, f0
	ctx.f[22].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	pc = 0x82EE4864; continue 'dispatch;
            }
            0x82EE4864 => {
    //   block [0x82EE4864..0x82EE48B8)
	// 82EE4864: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EE4868: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EE486C: 388BC904  addi r4, r11, -0x36fc
	ctx.r[4].s64 = ctx.r[11].s64 + -14076;
	// 82EE4870: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82EE4874: 4BF98E4D  bl 0x82e7d6c0
	ctx.lr = 0x82EE4878;
	sub_82E7D6C0(ctx, base);
	// 82EE4878: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EE487C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EE4880: 4182008C  beq 0x82ee490c
	if ctx.cr[0].eq {
	pc = 0x82EE490C; continue 'dispatch;
	}
	// 82EE4884: 389F00B0  addi r4, r31, 0xb0
	ctx.r[4].s64 = ctx.r[31].s64 + 176;
	// 82EE4888: 895F00F4  lbz r10, 0xf4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE488C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE4890: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE4894: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4898: EC180032  fmuls f0, f24, f0
	ctx.f[0].f64 = (((ctx.f[24].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE489C: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE48A0: EC0D0678  fmsubs f0, f13, f25, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[25].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE48A4: C1BF0040  lfs f13, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE48A8: FD800210  fabs f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82EE48AC: C00B0B6C  lfs f0, 0xb6c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2924 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE48B0: 41820008  beq 0x82ee48b8
	if ctx.cr[0].eq {
	pc = 0x82EE48B8; continue 'dispatch;
	}
	// 82EE48B4: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x82EE48B8; continue 'dispatch;
            }
            0x82EE48B8 => {
    //   block [0x82EE48B8..0x82EE48C8)
	// 82EE48B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EE48BC: 419A000C  beq cr6, 0x82ee48c8
	if ctx.cr[6].eq {
	pc = 0x82EE48C8; continue 'dispatch;
	}
	// 82EE48C0: C01F0044  lfs f0, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE48C4: 4800000C  b 0x82ee48d0
	pc = 0x82EE48D0; continue 'dispatch;
            }
            0x82EE48C8 => {
    //   block [0x82EE48C8..0x82EE48D0)
	// 82EE48C8: C17F0044  lfs f11, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE48CC: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x82EE48D0; continue 'dispatch;
            }
            0x82EE48D0 => {
    //   block [0x82EE48D0..0x82EE490C)
	// 82EE48D0: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82EE48D4: 40990038  ble cr6, 0x82ee490c
	if !ctx.cr[6].gt {
	pc = 0x82EE490C; continue 'dispatch;
	}
	// 82EE48D8: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82EE48DC: 40980030  bge cr6, 0x82ee490c
	if !ctx.cr[6].lt {
	pc = 0x82EE490C; continue 'dispatch;
	}
	// 82EE48E0: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82EE48E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EE48E8: 9BBF00F4  stb r29, 0xf4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[29].u8 ) };
	// 82EE48EC: 4BFA147D  bl 0x82e85d68
	ctx.lr = 0x82EE48F0;
	sub_82E85D68(ctx, base);
	// 82EE48F0: C0010054  lfs f0, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE48F4: 9BBE0004  stb r29, 4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u8 ) };
	// 82EE48F8: D01E000C  stfs f0, 0xc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EE48FC: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4900: 9BBE0004  stb r29, 4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u8 ) };
	// 82EE4904: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EE4908: 48000008  b 0x82ee4910
	pc = 0x82EE4910; continue 'dispatch;
            }
            0x82EE490C => {
    //   block [0x82EE490C..0x82EE4910)
	// 82EE490C: 9B9F00F4  stb r28, 0xf4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[28].u8 ) };
	pc = 0x82EE4910; continue 'dispatch;
            }
            0x82EE4910 => {
    //   block [0x82EE4910..0x82EE4940)
	// 82EE4910: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82EE4914: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE4918: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 82EE491C: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 82EE4920: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82EE4924: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82EE4928: 806B0264  lwz r3, 0x264(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(612 as u32) ) } as u64;
	// 82EE492C: D2E10064  stfs f23, 0x64(r1)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EE4930: D3610068  stfs f27, 0x68(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EE4934: D2C1006C  stfs f22, 0x6c(r1)
	tmp.f32 = (ctx.f[22].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82EE4938: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82EE493C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82EE4940; continue 'dispatch;
            }
            0x82EE4940 => {
    //   block [0x82EE4940..0x82EE4988)
	// 82EE4940: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82EE4944: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82EE4948: 4200FFF8  bdnz 0x82ee4940
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82EE4940; continue 'dispatch;
	}
	// 82EE494C: 9B8100B8  stb r28, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[28].u8 ) };
	// 82EE4950: C02B0010  lfs f1, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EE4954: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE4958: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 82EE495C: 809F0060  lwz r4, 0x60(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EE4960: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EE4964: FC40A890  fmr f2, f21
	ctx.f[2].f64 = ctx.f[21].f64;
	// 82EE4968: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82EE496C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE4970: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE4974: 4E800421  bctrl
	ctx.lr = 0x82EE4978;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE4978: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 82EE497C: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82EE4980: 4BDC9389  bl 0x82cadd08
	ctx.lr = 0x82EE4984;
	sub_82CADCEC(ctx, base);
	// 82EE4984: 4BDC4AD0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE4988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EE4988 size=1152
    let mut pc: u32 = 0x82EE4988;
    'dispatch: loop {
        match pc {
            0x82EE4988 => {
    //   block [0x82EE4988..0x82EE49DC)
	// 82EE4988: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE498C: C0CB0C18  lfs f6, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EE4990: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE4994: FF013000  fcmpu cr6, f1, f6
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[6].f64);
	// 82EE4998: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EE499C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EE49A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE49A4: D0C30004  stfs f6, 4(r3)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EE49A8: D0C30008  stfs f6, 8(r3)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EE49AC: D0C3000C  stfs f6, 0xc(r3)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EE49B0: D0C30010  stfs f6, 0x10(r3)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EE49B4: C0AB0BFC  lfs f5, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82EE49B8: D0C30014  stfs f6, 0x14(r3)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EE49BC: D0C30018  stfs f6, 0x18(r3)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EE49C0: D0C3001C  stfs f6, 0x1c(r3)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EE49C4: 409A0018  bne cr6, 0x82ee49dc
	if !ctx.cr[6].eq {
	pc = 0x82EE49DC; continue 'dispatch;
	}
	// 82EE49C8: C00400C4  lfs f0, 0xc4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE49CC: C1A40100  lfs f13, 0x100(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(256 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE49D0: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE49D4: FF026800  fcmpu cr6, f2, f13
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[13].f64);
	// 82EE49D8: 41990018  bgt cr6, 0x82ee49f0
	if ctx.cr[6].gt {
	pc = 0x82EE49F0; continue 'dispatch;
	}
	pc = 0x82EE49DC; continue 'dispatch;
            }
            0x82EE49DC => {
    //   block [0x82EE49DC..0x82EE49F0)
	// 82EE49DC: C0040078  lfs f0, 0x78(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE49E0: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE49E4: EDA00172  fmuls f13, f0, f5
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[5].f64) as f32) as f64);
	// 82EE49E8: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE49EC: EC0068B8  fmsubs f0, f0, f2, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[2].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x82EE49F0; continue 'dispatch;
            }
            0x82EE49F0 => {
    //   block [0x82EE49F0..0x82EE4A18)
	// 82EE49F0: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE49F4: C1840014  lfs f12, 0x14(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE49F8: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE49FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE4A00: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE4A04: C08B0C4C  lfs f4, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82EE4A08: EDAD0132  fmuls f13, f13, f4
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[4].f64) as f32) as f64);
	// 82EE4A0C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE4A10: 40980008  bge cr6, 0x82ee4a18
	if !ctx.cr[6].lt {
	pc = 0x82EE4A18; continue 'dispatch;
	}
	// 82EE4A14: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EE4A18; continue 'dispatch;
            }
            0x82EE4A18 => {
    //   block [0x82EE4A18..0x82EE4AA8)
	// 82EE4A18: C14400B8  lfs f10, 0xb8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(184 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE4A1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE4A20: C12400B4  lfs f9, 0xb4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(180 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE4A24: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE4A28: C0E400B0  lfs f7, 0xb0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(176 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EE4A2C: ED290032  fmuls f9, f9, f0
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE4A30: C1A400A0  lfs f13, 0xa0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE4A34: EC070032  fmuls f0, f7, f0
	ctx.f[0].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE4A38: C184009C  lfs f12, 0x9c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(156 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE4A3C: EDAD0072  fmuls f13, f13, f1
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[1].f64) as f32) as f64);
	// 82EE4A40: C1640098  lfs f11, 0x98(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(152 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE4A44: ED8C0072  fmuls f12, f12, f1
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[1].f64) as f32) as f64);
	// 82EE4A48: ED6B0072  fmuls f11, f11, f1
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[1].f64) as f32) as f64);
	// 82EE4A4C: C0E4006C  lfs f7, 0x6c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(108 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EE4A50: C0640068  lfs f3, 0x68(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(104 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82EE4A54: C0440064  lfs f2, 0x64(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(100 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EE4A58: C10B0BEC  lfs f8, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE4A5C: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE4A60: ED89602A  fadds f12, f9, f12
	ctx.f[12].f64 = ((ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EE4A64: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EE4A68: EDA7682A  fadds f13, f7, f13
	ctx.f[13].f64 = ((ctx.f[7].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE4A6C: D1A3000C  stfs f13, 0xc(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EE4A70: ED83602A  fadds f12, f3, f12
	ctx.f[12].f64 = ((ctx.f[3].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EE4A74: D1830008  stfs f12, 8(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EE4A78: EC02002A  fadds f0, f2, f0
	ctx.f[0].f64 = ((ctx.f[2].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EE4A7C: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EE4A80: D0230014  stfs f1, 0x14(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EE4A84: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE4A88: C1A4001C  lfs f13, 0x1c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE4A8C: C0040078  lfs f0, 0x78(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4A90: EC00697A  fmadds f0, f0, f5, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[5].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE4A94: C1A400BC  lfs f13, 0xbc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(188 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE4A98: ED610028  fsubs f11, f1, f0
	ctx.f[11].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE4A9C: EC00082A  fadds f0, f0, f1
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 82EE4AA0: 7D4B5379  or. r11, r10, r10
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE4AA4: 4182003C  beq 0x82ee4ae0
	if ctx.cr[0].eq {
	pc = 0x82EE4AE0; continue 'dispatch;
	}
	pc = 0x82EE4AA8; continue 'dispatch;
            }
            0x82EE4AA8 => {
    //   block [0x82EE4AA8..0x82EE4AC4)
	// 82EE4AA8: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE4AAC: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82EE4AB0: 41990030  bgt cr6, 0x82ee4ae0
	if ctx.cr[6].gt {
	pc = 0x82EE4AE0; continue 'dispatch;
	}
	// 82EE4AB4: C18B0010  lfs f12, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE4AB8: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82EE4ABC: 40980008  bge cr6, 0x82ee4ac4
	if !ctx.cr[6].lt {
	pc = 0x82EE4AC4; continue 'dispatch;
	}
	// 82EE4AC0: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	pc = 0x82EE4AC4; continue 'dispatch;
            }
            0x82EE4AC4 => {
    //   block [0x82EE4AC4..0x82EE4AD4)
	// 82EE4AC4: C18B0014  lfs f12, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE4AC8: FF0C4000  fcmpu cr6, f12, f8
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[8].f64);
	// 82EE4ACC: 40980008  bge cr6, 0x82ee4ad4
	if !ctx.cr[6].lt {
	pc = 0x82EE4AD4; continue 'dispatch;
	}
	// 82EE4AD0: FD006090  fmr f8, f12
	ctx.f[8].f64 = ctx.f[12].f64;
	pc = 0x82EE4AD4; continue 'dispatch;
            }
            0x82EE4AD4 => {
    //   block [0x82EE4AD4..0x82EE4AE0)
	// 82EE4AD4: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EE4AD8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE4ADC: 4082FFCC  bne 0x82ee4aa8
	if !ctx.cr[0].eq {
	pc = 0x82EE4AA8; continue 'dispatch;
	}
	pc = 0x82EE4AE0; continue 'dispatch;
            }
            0x82EE4AE0 => {
    //   block [0x82EE4AE0..0x82EE4AE8)
	// 82EE4AE0: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE4AE4: 48000034  b 0x82ee4b18
	pc = 0x82EE4B18; continue 'dispatch;
            }
            0x82EE4AE8 => {
    //   block [0x82EE4AE8..0x82EE4B04)
	// 82EE4AE8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4AEC: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EE4AF0: 41980030  blt cr6, 0x82ee4b20
	if ctx.cr[6].lt {
	pc = 0x82EE4B20; continue 'dispatch;
	}
	// 82EE4AF4: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4AF8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE4AFC: 40980008  bge cr6, 0x82ee4b04
	if !ctx.cr[6].lt {
	pc = 0x82EE4B04; continue 'dispatch;
	}
	// 82EE4B00: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	pc = 0x82EE4B04; continue 'dispatch;
            }
            0x82EE4B04 => {
    //   block [0x82EE4B04..0x82EE4B14)
	// 82EE4B04: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4B08: FF004000  fcmpu cr6, f0, f8
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[8].f64);
	// 82EE4B0C: 40980008  bge cr6, 0x82ee4b14
	if !ctx.cr[6].lt {
	pc = 0x82EE4B14; continue 'dispatch;
	}
	// 82EE4B10: FD000090  fmr f8, f0
	ctx.f[8].f64 = ctx.f[0].f64;
	pc = 0x82EE4B14; continue 'dispatch;
            }
            0x82EE4B14 => {
    //   block [0x82EE4B14..0x82EE4B18)
	// 82EE4B14: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	pc = 0x82EE4B18; continue 'dispatch;
            }
            0x82EE4B18 => {
    //   block [0x82EE4B18..0x82EE4B20)
	// 82EE4B18: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE4B1C: 4082FFCC  bne 0x82ee4ae8
	if !ctx.cr[0].eq {
	pc = 0x82EE4AE8; continue 'dispatch;
	}
	pc = 0x82EE4B20; continue 'dispatch;
            }
            0x82EE4B20 => {
    //   block [0x82EE4B20..0x82EE4B64)
	// 82EE4B20: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE4B24: C0040050  lfs f0, 0x50(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4B28: FF003000  fcmpu cr6, f0, f6
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[6].f64);
	// 82EE4B2C: C16B0010  lfs f11, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE4B30: 419A0058  beq cr6, 0x82ee4b88
	if ctx.cr[6].eq {
	pc = 0x82EE4B88; continue 'dispatch;
	}
	// 82EE4B34: C1840048  lfs f12, 0x48(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE4B38: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE4B3C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE4B40: 40980048  bge cr6, 0x82ee4b88
	if !ctx.cr[6].lt {
	pc = 0x82EE4B88; continue 'dispatch;
	}
	// 82EE4B44: FF083000  fcmpu cr6, f8, f6
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[6].f64);
	// 82EE4B48: 4199001C  bgt cr6, 0x82ee4b64
	if ctx.cr[6].gt {
	pc = 0x82EE4B64; continue 'dispatch;
	}
	// 82EE4B4C: C00400FC  lfs f0, 0xfc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4B50: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE4B54: ED840028  fsubs f12, f4, f0
	ctx.f[12].f64 = (((ctx.f[4].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE4B58: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE4B5C: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE4B60: 48000020  b 0x82ee4b80
	pc = 0x82EE4B80; continue 'dispatch;
            }
            0x82EE4B64 => {
    //   block [0x82EE4B64..0x82EE4B80)
	// 82EE4B64: FF085800  fcmpu cr6, f8, f11
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[11].f64);
	// 82EE4B68: 40980020  bge cr6, 0x82ee4b88
	if !ctx.cr[6].lt {
	pc = 0x82EE4B88; continue 'dispatch;
	}
	// 82EE4B6C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE4B70: C18400FC  lfs f12, 0xfc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(252 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE4B74: ED4B0372  fmuls f10, f11, f13
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE4B78: EC00523A  fmadds f0, f0, f8, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[10].f64) as f32) as f64);
	// 82EE4B7C: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	pc = 0x82EE4B80; continue 'dispatch;
            }
            0x82EE4B80 => {
    //   block [0x82EE4B80..0x82EE4B88)
	// 82EE4B80: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EE4B84: 48000008  b 0x82ee4b8c
	pc = 0x82EE4B8C; continue 'dispatch;
            }
            0x82EE4B88 => {
    //   block [0x82EE4B88..0x82EE4B8C)
	// 82EE4B88: D163001C  stfs f11, 0x1c(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	pc = 0x82EE4B8C; continue 'dispatch;
            }
            0x82EE4B8C => {
    //   block [0x82EE4B8C..0x82EE4BC8)
	// 82EE4B8C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE4B90: FF013000  fcmpu cr6, f1, f6
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[6].f64);
	// 82EE4B94: C0EB0C14  lfs f7, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EE4B98: 409A0034  bne cr6, 0x82ee4bcc
	if !ctx.cr[6].eq {
	pc = 0x82EE4BCC; continue 'dispatch;
	}
	// 82EE4B9C: 89640020  lbz r11, 0x20(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EE4BA0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE4BA4: 41820024  beq 0x82ee4bc8
	if ctx.cr[0].eq {
	pc = 0x82EE4BC8; continue 'dispatch;
	}
	// 82EE4BA8: C0040024  lfs f0, 0x24(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4BAC: FF003000  fcmpu cr6, f0, f6
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[6].f64);
	// 82EE4BB0: 40990018  ble cr6, 0x82ee4bc8
	if !ctx.cr[6].gt {
	pc = 0x82EE4BC8; continue 'dispatch;
	}
	// 82EE4BB4: EC070028  fsubs f0, f7, f0
	ctx.f[0].f64 = (((ctx.f[7].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE4BB8: C183001C  lfs f12, 0x1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE4BBC: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE4BC0: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82EE4BC4: 40980008  bge cr6, 0x82ee4bcc
	if !ctx.cr[6].lt {
	pc = 0x82EE4BCC; continue 'dispatch;
	}
	pc = 0x82EE4BC8; continue 'dispatch;
            }
            0x82EE4BC8 => {
    //   block [0x82EE4BC8..0x82EE4BCC)
	// 82EE4BC8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	pc = 0x82EE4BCC; continue 'dispatch;
            }
            0x82EE4BCC => {
    //   block [0x82EE4BCC..0x82EE4BE8)
	// 82EE4BCC: D1A30018  stfs f13, 0x18(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EE4BD0: 550B063F  clrlwi. r11, r8, 0x18
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE4BD4: 41820014  beq 0x82ee4be8
	if ctx.cr[0].eq {
	pc = 0x82EE4BE8; continue 'dispatch;
	}
	// 82EE4BD8: C004001C  lfs f0, 0x1c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4BDC: C1A40078  lfs f13, 0x78(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE4BE0: EC00693A  fmadds f0, f0, f4, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[4].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE4BE4: 48000008  b 0x82ee4bec
	pc = 0x82EE4BEC; continue 'dispatch;
            }
            0x82EE4BE8 => {
    //   block [0x82EE4BE8..0x82EE4BEC)
	// 82EE4BE8: FC003090  fmr f0, f6
	ctx.f[0].f64 = ctx.f[6].f64;
	pc = 0x82EE4BEC; continue 'dispatch;
            }
            0x82EE4BEC => {
    //   block [0x82EE4BEC..0x82EE4BFC)
	// 82EE4BEC: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82EE4BF0: 4099000C  ble cr6, 0x82ee4bfc
	if !ctx.cr[6].gt {
	pc = 0x82EE4BFC; continue 'dispatch;
	}
	// 82EE4BF4: ED810028  fsubs f12, f1, f0
	ctx.f[12].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE4BF8: 48000008  b 0x82ee4c00
	pc = 0x82EE4C00; continue 'dispatch;
            }
            0x82EE4BFC => {
    //   block [0x82EE4BFC..0x82EE4C00)
	// 82EE4BFC: ED800828  fsubs f12, f0, f1
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	pc = 0x82EE4C00; continue 'dispatch;
            }
            0x82EE4C00 => {
    //   block [0x82EE4C00..0x82EE4C1C)
	// 82EE4C00: C00400F8  lfs f0, 0xf8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4C04: C1A400D0  lfs f13, 0xd0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(208 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE4C08: ED000332  fmuls f8, f0, f12
	ctx.f[8].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE4C0C: FF016800  fcmpu cr6, f1, f13
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[13].f64);
	// 82EE4C10: 4098000C  bge cr6, 0x82ee4c1c
	if !ctx.cr[6].lt {
	pc = 0x82EE4C1C; continue 'dispatch;
	}
	// 82EE4C14: EDAD0828  fsubs f13, f13, f1
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[1].f64) as f32) as f64);
	// 82EE4C18: 48000008  b 0x82ee4c20
	pc = 0x82EE4C20; continue 'dispatch;
            }
            0x82EE4C1C => {
    //   block [0x82EE4C1C..0x82EE4C20)
	// 82EE4C1C: EDA16828  fsubs f13, f1, f13
	ctx.f[13].f64 = (((ctx.f[1].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x82EE4C20; continue 'dispatch;
            }
            0x82EE4C20 => {
    //   block [0x82EE4C20..0x82EE4C40)
	// 82EE4C20: 89640020  lbz r11, 0x20(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EE4C24: ED2D0032  fmuls f9, f13, f0
	ctx.f[9].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE4C28: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE4C2C: 41820014  beq 0x82ee4c40
	if ctx.cr[0].eq {
	pc = 0x82EE4C40; continue 'dispatch;
	}
	// 82EE4C30: C0040024  lfs f0, 0x24(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4C34: EC070028  fsubs f0, f7, f0
	ctx.f[0].f64 = (((ctx.f[7].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE4C38: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE4C3C: 48000008  b 0x82ee4c44
	pc = 0x82EE4C44; continue 'dispatch;
            }
            0x82EE4C40 => {
    //   block [0x82EE4C40..0x82EE4C44)
	// 82EE4C40: FC005890  fmr f0, f11
	ctx.f[0].f64 = ctx.f[11].f64;
	pc = 0x82EE4C44; continue 'dispatch;
            }
            0x82EE4C44 => {
    //   block [0x82EE4C44..0x82EE4C58)
	// 82EE4C44: C1A3001C  lfs f13, 0x1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE4C48: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE4C4C: 4198000C  blt cr6, 0x82ee4c58
	if ctx.cr[6].lt {
	pc = 0x82EE4C58; continue 'dispatch;
	}
	// 82EE4C50: FD403090  fmr f10, f6
	ctx.f[10].f64 = ctx.f[6].f64;
	// 82EE4C54: 4800000C  b 0x82ee4c60
	pc = 0x82EE4C60; continue 'dispatch;
            }
            0x82EE4C58 => {
    //   block [0x82EE4C58..0x82EE4C60)
	// 82EE4C58: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EE4C5C: ED470028  fsubs f10, f7, f0
	ctx.f[10].f64 = (((ctx.f[7].f64 - ctx.f[0].f64) as f32) as f64);
	pc = 0x82EE4C60; continue 'dispatch;
            }
            0x82EE4C60 => {
    //   block [0x82EE4C60..0x82EE4C84)
	// 82EE4C60: 81640058  lwz r11, 0x58(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EE4C64: C16400BC  lfs f11, 0xbc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(188 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE4C68: FF013000  fcmpu cr6, f1, f6
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[6].f64);
	// 82EE4C6C: FD805890  fmr f12, f11
	ctx.f[12].f64 = ctx.f[11].f64;
	// 82EE4C70: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE4C74: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE4C78: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE4C7C: 40990070  ble cr6, 0x82ee4cec
	if !ctx.cr[6].gt {
	pc = 0x82EE4CEC; continue 'dispatch;
	}
	// 82EE4C80: 41820100  beq 0x82ee4d80
	if ctx.cr[0].eq {
	pc = 0x82EE4D80; continue 'dispatch;
	}
	pc = 0x82EE4C84; continue 'dispatch;
            }
            0x82EE4C84 => {
    //   block [0x82EE4C84..0x82EE4C9C)
	// 82EE4C84: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4C88: FF003000  fcmpu cr6, f0, f6
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[6].f64);
	// 82EE4C8C: 41990010  bgt cr6, 0x82ee4c9c
	if ctx.cr[6].gt {
	pc = 0x82EE4C9C; continue 'dispatch;
	}
	// 82EE4C90: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EE4C94: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE4C98: 4082FFEC  bne 0x82ee4c84
	if !ctx.cr[0].eq {
	pc = 0x82EE4C84; continue 'dispatch;
	}
	pc = 0x82EE4C9C; continue 'dispatch;
            }
            0x82EE4C9C => {
    //   block [0x82EE4C9C..0x82EE4CA4)
	// 82EE4C9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE4CA0: 419A00E0  beq cr6, 0x82ee4d80
	if ctx.cr[6].eq {
	pc = 0x82EE4D80; continue 'dispatch;
	}
	pc = 0x82EE4CA4; continue 'dispatch;
            }
            0x82EE4CA4 => {
    //   block [0x82EE4CA4..0x82EE4CCC)
	// 82EE4CA4: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE4CA8: FF0D0800  fcmpu cr6, f13, f1
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[1].f64);
	// 82EE4CAC: 419900D4  bgt cr6, 0x82ee4d80
	if ctx.cr[6].gt {
	pc = 0x82EE4D80; continue 'dispatch;
	}
	// 82EE4CB0: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4CB4: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82EE4CB8: 40990014  ble cr6, 0x82ee4ccc
	if !ctx.cr[6].gt {
	pc = 0x82EE4CCC; continue 'dispatch;
	}
	// 82EE4CBC: EC610132  fmuls f3, f1, f4
	ctx.f[3].f64 = (((ctx.f[1].f64 * ctx.f[4].f64) as f32) as f64);
	// 82EE4CC0: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE4CC4: FF001800  fcmpu cr6, f0, f3
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[3].f64);
	// 82EE4CC8: 419900B8  bgt cr6, 0x82ee4d80
	if ctx.cr[6].gt {
	pc = 0x82EE4D80; continue 'dispatch;
	}
	pc = 0x82EE4CCC; continue 'dispatch;
            }
            0x82EE4CCC => {
    //   block [0x82EE4CCC..0x82EE4CDC)
	// 82EE4CCC: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4CD0: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EE4CD4: 40980008  bge cr6, 0x82ee4cdc
	if !ctx.cr[6].lt {
	pc = 0x82EE4CDC; continue 'dispatch;
	}
	// 82EE4CD8: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	pc = 0x82EE4CDC; continue 'dispatch;
            }
            0x82EE4CDC => {
    //   block [0x82EE4CDC..0x82EE4CEC)
	// 82EE4CDC: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EE4CE0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE4CE4: 4082FFC0  bne 0x82ee4ca4
	if !ctx.cr[0].eq {
	pc = 0x82EE4CA4; continue 'dispatch;
	}
	// 82EE4CE8: 48000098  b 0x82ee4d80
	pc = 0x82EE4D80; continue 'dispatch;
            }
            0x82EE4CEC => {
    //   block [0x82EE4CEC..0x82EE4CF8)
	// 82EE4CEC: FF013000  fcmpu cr6, f1, f6
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[6].f64);
	// 82EE4CF0: 40980070  bge cr6, 0x82ee4d60
	if !ctx.cr[6].lt {
	pc = 0x82EE4D60; continue 'dispatch;
	}
	// 82EE4CF4: 4182008C  beq 0x82ee4d80
	if ctx.cr[0].eq {
	pc = 0x82EE4D80; continue 'dispatch;
	}
	pc = 0x82EE4CF8; continue 'dispatch;
            }
            0x82EE4CF8 => {
    //   block [0x82EE4CF8..0x82EE4D10)
	// 82EE4CF8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4CFC: FF003000  fcmpu cr6, f0, f6
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[6].f64);
	// 82EE4D00: 41990010  bgt cr6, 0x82ee4d10
	if ctx.cr[6].gt {
	pc = 0x82EE4D10; continue 'dispatch;
	}
	// 82EE4D04: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EE4D08: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE4D0C: 4082FFEC  bne 0x82ee4cf8
	if !ctx.cr[0].eq {
	pc = 0x82EE4CF8; continue 'dispatch;
	}
	pc = 0x82EE4D10; continue 'dispatch;
            }
            0x82EE4D10 => {
    //   block [0x82EE4D10..0x82EE4D18)
	// 82EE4D10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE4D14: 419A006C  beq cr6, 0x82ee4d80
	if ctx.cr[6].eq {
	pc = 0x82EE4D80; continue 'dispatch;
	}
	pc = 0x82EE4D18; continue 'dispatch;
            }
            0x82EE4D18 => {
    //   block [0x82EE4D18..0x82EE4D40)
	// 82EE4D18: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE4D1C: FF0D0800  fcmpu cr6, f13, f1
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[1].f64);
	// 82EE4D20: 41980060  blt cr6, 0x82ee4d80
	if ctx.cr[6].lt {
	pc = 0x82EE4D80; continue 'dispatch;
	}
	// 82EE4D24: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4D28: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82EE4D2C: 40980014  bge cr6, 0x82ee4d40
	if !ctx.cr[6].lt {
	pc = 0x82EE4D40; continue 'dispatch;
	}
	// 82EE4D30: EC610132  fmuls f3, f1, f4
	ctx.f[3].f64 = (((ctx.f[1].f64 * ctx.f[4].f64) as f32) as f64);
	// 82EE4D34: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EE4D38: FF001800  fcmpu cr6, f0, f3
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[3].f64);
	// 82EE4D3C: 41980044  blt cr6, 0x82ee4d80
	if ctx.cr[6].lt {
	pc = 0x82EE4D80; continue 'dispatch;
	}
	pc = 0x82EE4D40; continue 'dispatch;
            }
            0x82EE4D40 => {
    //   block [0x82EE4D40..0x82EE4D50)
	// 82EE4D40: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4D44: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EE4D48: 40980008  bge cr6, 0x82ee4d50
	if !ctx.cr[6].lt {
	pc = 0x82EE4D50; continue 'dispatch;
	}
	// 82EE4D4C: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	pc = 0x82EE4D50; continue 'dispatch;
            }
            0x82EE4D50 => {
    //   block [0x82EE4D50..0x82EE4D60)
	// 82EE4D50: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE4D54: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE4D58: 4082FFC0  bne 0x82ee4d18
	if !ctx.cr[0].eq {
	pc = 0x82EE4D18; continue 'dispatch;
	}
	// 82EE4D5C: 48000024  b 0x82ee4d80
	pc = 0x82EE4D80; continue 'dispatch;
            }
            0x82EE4D60 => {
    //   block [0x82EE4D60..0x82EE4D64)
	// 82EE4D60: 4182001C  beq 0x82ee4d7c
	if ctx.cr[0].eq {
	pc = 0x82EE4D7C; continue 'dispatch;
	}
	pc = 0x82EE4D64; continue 'dispatch;
            }
            0x82EE4D64 => {
    //   block [0x82EE4D64..0x82EE4D7C)
	// 82EE4D64: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4D68: FF003000  fcmpu cr6, f0, f6
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[6].f64);
	// 82EE4D6C: 41990010  bgt cr6, 0x82ee4d7c
	if ctx.cr[6].gt {
	pc = 0x82EE4D7C; continue 'dispatch;
	}
	// 82EE4D70: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EE4D74: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE4D78: 4082FFEC  bne 0x82ee4d64
	if !ctx.cr[0].eq {
	pc = 0x82EE4D64; continue 'dispatch;
	}
	pc = 0x82EE4D7C; continue 'dispatch;
            }
            0x82EE4D7C => {
    //   block [0x82EE4D7C..0x82EE4D80)
	// 82EE4D7C: C18B0010  lfs f12, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EE4D80; continue 'dispatch;
            }
            0x82EE4D80 => {
    //   block [0x82EE4D80..0x82EE4DA0)
	// 82EE4D80: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 82EE4D84: 4098001C  bge cr6, 0x82ee4da0
	if !ctx.cr[6].lt {
	pc = 0x82EE4DA0; continue 'dispatch;
	}
	// 82EE4D88: C00400BC  lfs f0, 0xbc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4D8C: EDA0602A  fadds f13, f0, f12
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EE4D90: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EE4D94: EC002828  fsubs f0, f0, f5
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[5].f64) as f32) as f64);
	// 82EE4D98: EC000132  fmuls f0, f0, f4
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[4].f64) as f32) as f64);
	// 82EE4D9C: 48000008  b 0x82ee4da4
	pc = 0x82EE4DA4; continue 'dispatch;
            }
            0x82EE4DA0 => {
    //   block [0x82EE4DA0..0x82EE4DA4)
	// 82EE4DA0: FC003090  fmr f0, f6
	ctx.f[0].f64 = ctx.f[6].f64;
	pc = 0x82EE4DA4; continue 'dispatch;
            }
            0x82EE4DA4 => {
    //   block [0x82EE4DA4..0x82EE4DE8)
	// 82EE4DA4: EDA0502A  fadds f13, f0, f10
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64;
	// 82EE4DA8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE4DAC: C00BBE10  lfs f0, -0x41f0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4DB0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE4DB4: EC0D483A  fmadds f0, f13, f0, f9
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[9].f64) as f32) as f64);
	// 82EE4DB8: EDA0402A  fadds f13, f0, f8
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64;
	// 82EE4DBC: C00B0C7C  lfs f0, 0xc7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4DC0: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE4DC4: D1830010  stfs f12, 0x10(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EE4DC8: C1A40078  lfs f13, 0x78(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE4DCC: C164001C  lfs f11, 0x1c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE4DD0: EDAD597A  fmadds f13, f13, f5, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[5].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EE4DD4: C00400D0  lfs f0, 0xd0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(208 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4DD8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE4DDC: 4099000C  ble cr6, 0x82ee4de8
	if !ctx.cr[6].gt {
	pc = 0x82EE4DE8; continue 'dispatch;
	}
	// 82EE4DE0: FF013000  fcmpu cr6, f1, f6
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[6].f64);
	// 82EE4DE4: 41980018  blt cr6, 0x82ee4dfc
	if ctx.cr[6].lt {
	pc = 0x82EE4DFC; continue 'dispatch;
	}
	pc = 0x82EE4DE8; continue 'dispatch;
            }
            0x82EE4DE8 => {
    //   block [0x82EE4DE8..0x82EE4DFC)
	// 82EE4DE8: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE4DEC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE4DF0: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 82EE4DF4: FF013000  fcmpu cr6, f1, f6
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[6].f64);
	// 82EE4DF8: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	pc = 0x82EE4DFC; continue 'dispatch;
            }
            0x82EE4DFC => {
    //   block [0x82EE4DFC..0x82EE4E08)
	// 82EE4DFC: EC0C382A  fadds f0, f12, f7
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[7].f64) as f32) as f64;
	// 82EE4E00: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EE4E04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE4E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE4E08 size=52
    let mut pc: u32 = 0x82EE4E08;
    'dispatch: loop {
        match pc {
            0x82EE4E08 => {
    //   block [0x82EE4E08..0x82EE4E3C)
	// 82EE4E08: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EE4E0C: 81260004  lwz r9, 4(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE4E10: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE4E14: 40820028  bne 0x82ee4e3c
	if !ctx.cr[0].eq {
		sub_82EE4E3C(ctx, base);
		return;
	}
	// 82EE4E18: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE4E1C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82EE4E20: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EE4E24: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 82EE4E28: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EE4E2C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EE4E30: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EE4E34: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EE4E38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE4E3C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EE4E3C size=244
    let mut pc: u32 = 0x82EE4E3C;
    'dispatch: loop {
        match pc {
            0x82EE4E3C => {
    //   block [0x82EE4E3C..0x82EE4ED0)
	// 82EE4E3C: 81040014  lwz r8, 0x14(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE4E40: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82EE4E44: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82EE4E48: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82EE4E4C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EE4E50: 91040014  stw r8, 0x14(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 82EE4E54: 810B0028  lwz r8, 0x28(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EE4E58: 91040010  stw r8, 0x10(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 82EE4E5C: C0050004  lfs f0, 4(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4E60: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EE4E64: C0050008  lfs f0, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4E68: D00A0008  stfs f0, 8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EE4E6C: C005000C  lfs f0, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4E70: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EE4E74: C0050010  lfs f0, 0x10(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4E78: D00A0010  stfs f0, 0x10(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EE4E7C: C0050014  lfs f0, 0x14(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4E80: D00A0014  stfs f0, 0x14(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EE4E84: C0050018  lfs f0, 0x18(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4E88: D00A0018  stfs f0, 0x18(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EE4E8C: C005001C  lfs f0, 0x1c(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4E90: D00A001C  stfs f0, 0x1c(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EE4E94: 98EB002C  stb r7, 0x2c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[7].u8 ) };
	// 82EE4E98: 409A0054  bne cr6, 0x82ee4eec
	if !ctx.cr[6].eq {
	pc = 0x82EE4EEC; continue 'dispatch;
	}
	// 82EE4E9C: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EE4EA0: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE4EA4: 4082002C  bne 0x82ee4ed0
	if !ctx.cr[0].eq {
	pc = 0x82EE4ED0; continue 'dispatch;
	}
	// 82EE4EA8: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EE4EAC: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EE4EB0: 914B0028  stw r10, 0x28(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82EE4EB4: 81240008  lwz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE4EB8: 91490024  stw r10, 0x24(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 82EE4EBC: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EE4EC0: 91490024  stw r10, 0x24(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 82EE4EC4: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EE4EC8: 91490028  stw r10, 0x28(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82EE4ECC: 48000044  b 0x82ee4f10
	pc = 0x82EE4F10; continue 'dispatch;
            }
            0x82EE4ED0 => {
    //   block [0x82EE4ED0..0x82EE4EEC)
	// 82EE4ED0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EE4ED4: 914B0024  stw r10, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 82EE4ED8: 912B0028  stw r9, 0x28(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 82EE4EDC: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EE4EE0: 916A0028  stw r11, 0x28(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82EE4EE4: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EE4EE8: 48000028  b 0x82ee4f10
	pc = 0x82EE4F10; continue 'dispatch;
            }
            0x82EE4EEC => {
    //   block [0x82EE4EEC..0x82EE4F0C)
	// 82EE4EEC: 81490024  lwz r10, 0x24(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EE4EF0: 912B0028  stw r9, 0x28(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 82EE4EF4: 91690024  stw r11, 0x24(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82EE4EF8: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE4EFC: 914B0024  stw r10, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 82EE4F00: 4182000C  beq 0x82ee4f0c
	if ctx.cr[0].eq {
	pc = 0x82EE4F0C; continue 'dispatch;
	}
	// 82EE4F04: 916A0028  stw r11, 0x28(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82EE4F08: 48000008  b 0x82ee4f10
	pc = 0x82EE4F10; continue 'dispatch;
            }
            0x82EE4F0C => {
    //   block [0x82EE4F0C..0x82EE4F10)
	// 82EE4F0C: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE4F10; continue 'dispatch;
            }
            0x82EE4F10 => {
    //   block [0x82EE4F10..0x82EE4F30)
	// 82EE4F10: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EE4F14: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EE4F18: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82EE4F1C: 394AAFB4  addi r10, r10, -0x504c
	ctx.r[10].s64 = ctx.r[10].s64 + -20556;
	// 82EE4F20: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	// 82EE4F24: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EE4F28: 91260000  stw r9, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EE4F2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE4F30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE4F30 size=888
    let mut pc: u32 = 0x82EE4F30;
    'dispatch: loop {
        match pc {
            0x82EE4F30 => {
    //   block [0x82EE4F30..0x82EE4F6C)
	// 82EE4F30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE4F34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EE4F38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EE4F3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EE4F40: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 82EE4F44: 4BDC8D91  bl 0x82cadcd4
	ctx.lr = 0x82EE4F48;
	sub_82CADCA0(ctx, base);
	// 82EE4F48: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE4F4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE4F50: 897F00EE  lbz r11, 0xee(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(238 as u32) ) } as u64;
	// 82EE4F54: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE4F58: 41820014  beq 0x82ee4f6c
	if ctx.cr[0].eq {
	pc = 0x82EE4F6C; continue 'dispatch;
	}
	// 82EE4F5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE4F60: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EE4F64: 997F00EE  stb r11, 0xee(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(238 as u32), ctx.r[11].u8 ) };
	// 82EE4F68: 48000320  b 0x82ee5288
	pc = 0x82EE5288; continue 'dispatch;
            }
            0x82EE4F6C => {
    //   block [0x82EE4F6C..0x82EE4F7C)
	// 82EE4F6C: 817F00CC  lwz r11, 0xcc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82EE4F70: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE4F74: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EE4F78: 4098000C  bge cr6, 0x82ee4f84
	if !ctx.cr[6].lt {
	pc = 0x82EE4F84; continue 'dispatch;
	}
	pc = 0x82EE4F7C; continue 'dispatch;
            }
            0x82EE4F7C => {
    //   block [0x82EE4F7C..0x82EE4F84)
	// 82EE4F7C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EE4F80: 48000308  b 0x82ee5288
	pc = 0x82EE5288; continue 'dispatch;
            }
            0x82EE4F84 => {
    //   block [0x82EE4F84..0x82EE5038)
	// 82EE4F84: 389F0064  addi r4, r31, 0x64
	ctx.r[4].s64 = ctx.r[31].s64 + 100;
	// 82EE4F88: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE4F8C: 3BDF0088  addi r30, r31, 0x88
	ctx.r[30].s64 = ctx.r[31].s64 + 136;
	// 82EE4F90: C17F0014  lfs f11, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE4F94: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE4F98: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE4F9C: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE4FA0: EF8C6828  fsubs f28, f12, f13
	ctx.f[28].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE4FA4: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE4FA8: C0030010  lfs f0, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4FAC: C1840000  lfs f12, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE4FB0: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE4FB4: EF6D6028  fsubs f27, f13, f12
	ctx.f[27].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE4FB8: C12B0C4C  lfs f9, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE4FBC: EC000272  fmuls f0, f0, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[9].f64) as f32) as f64);
	// 82EE4FC0: EDBB06F2  fmuls f13, f27, f27
	ctx.f[13].f64 = (((ctx.f[27].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EE4FC4: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE4FC8: EDBC6F3A  fmadds f13, f28, f28, f13
	ctx.f[13].f64 = (((ctx.f[28].f64 * ctx.f[28].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE4FCC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE4FD0: 4198FFAC  blt cr6, 0x82ee4f7c
	if ctx.cr[6].lt {
	pc = 0x82EE4F7C; continue 'dispatch;
	}
	// 82EE4FD4: C01F00B0  lfs f0, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4FD8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE4FDC: EC1B0032  fmuls f0, f27, f0
	ctx.f[0].f64 = (((ctx.f[27].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE4FE0: C1BF00B8  lfs f13, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE4FE4: C0DF0100  lfs f6, 0x100(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EE4FE8: EC0D073A  fmadds f0, f13, f28, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[28].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE4FEC: ECA001B2  fmuls f5, f0, f6
	ctx.f[5].f64 = (((ctx.f[0].f64 * ctx.f[6].f64) as f32) as f64);
	// 82EE4FF0: C00B0EE0  lfs f0, 0xee0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE4FF4: FF050000  fcmpu cr6, f5, f0
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[0].f64);
	// 82EE4FF8: 4198FF84  blt cr6, 0x82ee4f7c
	if ctx.cr[6].lt {
	pc = 0x82EE4F7C; continue 'dispatch;
	}
	// 82EE4FFC: C15F00D0  lfs f10, 0xd0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE5000: FDA05210  fabs f13, f10
	ctx.f[13].u64 = ctx.f[10].u64 & !0x8000_0000_0000_0000u64;
	// 82EE5004: C01F004C  lfs f0, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE5008: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE500C: 4199FF70  bgt cr6, 0x82ee4f7c
	if ctx.cr[6].gt {
	pc = 0x82EE4F7C; continue 'dispatch;
	}
	// 82EE5010: 897F0020  lbz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EE5014: C1A30010  lfs f13, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE5018: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE501C: 4182001C  beq 0x82ee5038
	if ctx.cr[0].eq {
	pc = 0x82EE5038; continue 'dispatch;
	}
	// 82EE5020: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE5024: C19F0024  lfs f12, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE5028: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE502C: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE5030: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE5034: 48000008  b 0x82ee503c
	pc = 0x82EE503C; continue 'dispatch;
            }
            0x82EE5038 => {
    //   block [0x82EE5038..0x82EE503C)
	// 82EE5038: FD806890  fmr f12, f13
	ctx.f[12].f64 = ctx.f[13].f64;
	pc = 0x82EE503C; continue 'dispatch;
            }
            0x82EE503C => {
    //   block [0x82EE503C..0x82EE5068)
	// 82EE503C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE5040: 815F0058  lwz r10, 0x58(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EE5044: C00B0BE8  lfs f0, 0xbe8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3048 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE5048: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE504C: C3CB0C18  lfs f30, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EE5050: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE5054: FC0AF02E  fsel f0, f10, f0, f30
	ctx.f[0].f64 = if ctx.f[10].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[30].f64 };
	// 82EE5058: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE505C: EC00502A  fadds f0, f0, f10
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64;
	// 82EE5060: 7D4B5379  or. r11, r10, r10
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE5064: 4182FF18  beq 0x82ee4f7c
	if ctx.cr[0].eq {
	pc = 0x82EE4F7C; continue 'dispatch;
	}
	pc = 0x82EE5068; continue 'dispatch;
            }
            0x82EE5068 => {
    //   block [0x82EE5068..0x82EE5080)
	// 82EE5068: C10B000C  lfs f8, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE506C: FF080000  fcmpu cr6, f8, f0
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[0].f64);
	// 82EE5070: 41990010  bgt cr6, 0x82ee5080
	if ctx.cr[6].gt {
	pc = 0x82EE5080; continue 'dispatch;
	}
	// 82EE5074: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EE5078: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE507C: 4082FFEC  bne 0x82ee5068
	if !ctx.cr[0].eq {
	pc = 0x82EE5068; continue 'dispatch;
	}
	pc = 0x82EE5080; continue 'dispatch;
            }
            0x82EE5080 => {
    //   block [0x82EE5080..0x82EE50A4)
	// 82EE5080: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE5084: 419AFEF8  beq cr6, 0x82ee4f7c
	if ctx.cr[6].eq {
	pc = 0x82EE4F7C; continue 'dispatch;
	}
	// 82EE5088: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE508C: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EE5090: 4198FEEC  blt cr6, 0x82ee4f7c
	if ctx.cr[6].lt {
	pc = 0x82EE4F7C; continue 'dispatch;
	}
	// 82EE5094: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE5098: 4099000C  ble cr6, 0x82ee50a4
	if !ctx.cr[6].gt {
	pc = 0x82EE50A4; continue 'dispatch;
	}
	// 82EE509C: FFA06890  fmr f29, f13
	ctx.f[29].f64 = ctx.f[13].f64;
	// 82EE50A0: 48000008  b 0x82ee50a8
	pc = 0x82EE50A8; continue 'dispatch;
            }
            0x82EE50A4 => {
    //   block [0x82EE50A4..0x82EE50A8)
	// 82EE50A4: FFA00090  fmr f29, f0
	ctx.f[29].f64 = ctx.f[0].f64;
	pc = 0x82EE50A8; continue 'dispatch;
            }
            0x82EE50A8 => {
    //   block [0x82EE50A8..0x82EE50D4)
	// 82EE50A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE50AC: C19F0078  lfs f12, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE50B0: C11F001C  lfs f8, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE50B4: FDAA57AE  fsel f13, f10, f30, f10
	ctx.f[13].f64 = if ctx.f[10].f64 >= 0.0 { ctx.f[30].f64 } else { ctx.f[10].f64 };
	// 82EE50B8: FF0AF000  fcmpu cr6, f10, f30
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[30].f64);
	// 82EE50BC: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE50C0: EC0C403A  fmadds f0, f12, f0, f8
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 82EE50C4: EC8D0028  fsubs f4, f13, f0
	ctx.f[4].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE50C8: 4099000C  ble cr6, 0x82ee50d4
	if !ctx.cr[6].gt {
	pc = 0x82EE50D4; continue 'dispatch;
	}
	// 82EE50CC: FDA05090  fmr f13, f10
	ctx.f[13].f64 = ctx.f[10].f64;
	// 82EE50D0: 48000008  b 0x82ee50d8
	pc = 0x82EE50D8; continue 'dispatch;
            }
            0x82EE50D4 => {
    //   block [0x82EE50D4..0x82EE50D8)
	// 82EE50D4: FDA0F090  fmr f13, f30
	ctx.f[13].f64 = ctx.f[30].f64;
	pc = 0x82EE50D8; continue 'dispatch;
            }
            0x82EE50D8 => {
    //   block [0x82EE50D8..0x82EE50F8)
	// 82EE50D8: ED6B0272  fmuls f11, f11, f9
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[9].f64) as f32) as f64);
	// 82EE50DC: C19F00BC  lfs f12, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE50E0: ECED002A  fadds f7, f13, f0
	ctx.f[7].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EE50E4: EDA059BA  fmadds f13, f0, f6, f11
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[6].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EE50E8: EDAD282A  fadds f13, f13, f5
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[5].f64) as f32) as f64;
	// 82EE50EC: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EE50F0: 41980008  blt cr6, 0x82ee50f8
	if ctx.cr[6].lt {
	pc = 0x82EE50F8; continue 'dispatch;
	}
	// 82EE50F4: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	pc = 0x82EE50F8; continue 'dispatch;
            }
            0x82EE50F8 => {
    //   block [0x82EE50F8..0x82EE5108)
	// 82EE50F8: C3FF0048  lfs f31, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EE50FC: 7D4B5379  or. r11, r10, r10
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE5100: FD20F890  fmr f9, f31
	ctx.f[9].f64 = ctx.f[31].f64;
	// 82EE5104: 41820044  beq 0x82ee5148
	if ctx.cr[0].eq {
	pc = 0x82EE5148; continue 'dispatch;
	}
	pc = 0x82EE5108; continue 'dispatch;
            }
            0x82EE5108 => {
    //   block [0x82EE5108..0x82EE513C)
	// 82EE5108: C10B000C  lfs f8, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE510C: FF082000  fcmpu cr6, f8, f4
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[4].f64);
	// 82EE5110: 4198002C  blt cr6, 0x82ee513c
	if ctx.cr[6].lt {
	pc = 0x82EE513C; continue 'dispatch;
	}
	// 82EE5114: C10B0008  lfs f8, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE5118: FF083800  fcmpu cr6, f8, f7
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[7].f64);
	// 82EE511C: 4199002C  bgt cr6, 0x82ee5148
	if ctx.cr[6].gt {
	pc = 0x82EE5148; continue 'dispatch;
	}
	// 82EE5120: 892B0018  lbz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EE5124: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE5128: 40820014  bne 0x82ee513c
	if !ctx.cr[0].eq {
	pc = 0x82EE513C; continue 'dispatch;
	}
	// 82EE512C: C10B0010  lfs f8, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE5130: FF084800  fcmpu cr6, f8, f9
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[9].f64);
	// 82EE5134: 40980008  bge cr6, 0x82ee513c
	if !ctx.cr[6].lt {
	pc = 0x82EE513C; continue 'dispatch;
	}
	// 82EE5138: FD204090  fmr f9, f8
	ctx.f[9].f64 = ctx.f[8].f64;
	pc = 0x82EE513C; continue 'dispatch;
            }
            0x82EE513C => {
    //   block [0x82EE513C..0x82EE5148)
	// 82EE513C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EE5140: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE5144: 4082FFC4  bne 0x82ee5108
	if !ctx.cr[0].eq {
	pc = 0x82EE5108; continue 'dispatch;
	}
	pc = 0x82EE5148; continue 'dispatch;
            }
            0x82EE5148 => {
    //   block [0x82EE5148..0x82EE516C)
	// 82EE5148: FF096800  fcmpu cr6, f9, f13
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[13].f64);
	// 82EE514C: 4198FE30  blt cr6, 0x82ee4f7c
	if ctx.cr[6].lt {
	pc = 0x82EE4F7C; continue 'dispatch;
	}
	// 82EE5150: EDA059BA  fmadds f13, f0, f6, f11
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[6].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EE5154: ED6A0028  fsubs f11, f10, f0
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE5158: ED4A002A  fadds f10, f10, f0
	ctx.f[10].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EE515C: EDAD282A  fadds f13, f13, f5
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[5].f64) as f32) as f64;
	// 82EE5160: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EE5164: 41980008  blt cr6, 0x82ee516c
	if ctx.cr[6].lt {
	pc = 0x82EE516C; continue 'dispatch;
	}
	// 82EE5168: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	pc = 0x82EE516C; continue 'dispatch;
            }
            0x82EE516C => {
    //   block [0x82EE516C..0x82EE5174)
	// 82EE516C: 7D4B5379  or. r11, r10, r10
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE5170: 41820038  beq 0x82ee51a8
	if ctx.cr[0].eq {
	pc = 0x82EE51A8; continue 'dispatch;
	}
	pc = 0x82EE5174; continue 'dispatch;
            }
            0x82EE5174 => {
    //   block [0x82EE5174..0x82EE519C)
	// 82EE5174: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE5178: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EE517C: 41980020  blt cr6, 0x82ee519c
	if ctx.cr[6].lt {
	pc = 0x82EE519C; continue 'dispatch;
	}
	// 82EE5180: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE5184: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EE5188: 41990020  bgt cr6, 0x82ee51a8
	if ctx.cr[6].gt {
	pc = 0x82EE51A8; continue 'dispatch;
	}
	// 82EE518C: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE5190: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EE5194: 40980008  bge cr6, 0x82ee519c
	if !ctx.cr[6].lt {
	pc = 0x82EE519C; continue 'dispatch;
	}
	// 82EE5198: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	pc = 0x82EE519C; continue 'dispatch;
            }
            0x82EE519C => {
    //   block [0x82EE519C..0x82EE51A8)
	// 82EE519C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EE51A0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE51A4: 4082FFD0  bne 0x82ee5174
	if !ctx.cr[0].eq {
	pc = 0x82EE5174; continue 'dispatch;
	}
	pc = 0x82EE51A8; continue 'dispatch;
            }
            0x82EE51A8 => {
    //   block [0x82EE51A8..0x82EE51D8)
	// 82EE51A8: FF1F6800  fcmpu cr6, f31, f13
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[13].f64);
	// 82EE51AC: 4198FDD0  blt cr6, 0x82ee4f7c
	if ctx.cr[6].lt {
	pc = 0x82EE4F7C; continue 'dispatch;
	}
	// 82EE51B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE51B4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EE51B8: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EE51BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE51C0: 4E800421  bctrl
	ctx.lr = 0x82EE51C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE51C4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE51C8: 4182FDB4  beq 0x82ee4f7c
	if ctx.cr[0].eq {
	pc = 0x82EE4F7C; continue 'dispatch;
	}
	// 82EE51CC: 817F00CC  lwz r11, 0xcc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82EE51D0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE51D4: 48000028  b 0x82ee51fc
	pc = 0x82EE51FC; continue 'dispatch;
            }
            0x82EE51D8 => {
    //   block [0x82EE51D8..0x82EE51FC)
	// 82EE51D8: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE51DC: 9949002C  stb r10, 0x2c(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(44 as u32), ctx.r[10].u8 ) };
	// 82EE51E0: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE51E4: 80EB0010  lwz r7, 0x10(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EE51E8: 81090028  lwz r8, 0x28(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EE51EC: 90E90028  stw r7, 0x28(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(40 as u32), ctx.r[7].u32 ) };
	// 82EE51F0: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE51F4: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82EE51F8: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	pc = 0x82EE51FC; continue 'dispatch;
            }
            0x82EE51FC => {
    //   block [0x82EE51FC..0x82EE5288)
	// 82EE51FC: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE5200: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EE5204: 409AFFD4  bne cr6, 0x82ee51d8
	if !ctx.cr[6].eq {
	pc = 0x82EE51D8; continue 'dispatch;
	}
	// 82EE5208: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82EE520C: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EE5210: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82EE5214: C01F0098  lfs f0, 0x98(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE5218: EC0006F2  fmuls f0, f0, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EE521C: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82EE5220: 3929AFB4  addi r9, r9, -0x504c
	ctx.r[9].s64 = ctx.r[9].s64 + -20556;
	// 82EE5224: C19E0000  lfs f12, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE5228: 3908AFB4  addi r8, r8, -0x504c
	ctx.r[8].s64 = ctx.r[8].s64 + -20556;
	// 82EE522C: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EE5230: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE5234: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EE5238: C1BF00A0  lfs f13, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE523C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82EE5240: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EE5244: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EE5248: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE524C: 809F00CC  lwz r4, 0xcc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82EE5250: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EE5254: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 82EE5258: D3C10070  stfs f30, 0x70(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82EE525C: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82EE5260: D3A1007C  stfs f29, 0x7c(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82EE5264: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82EE5268: EC0D073A  fmadds f0, f13, f28, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[28].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE526C: D181006C  stfs f12, 0x6c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82EE5270: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EE5274: 4BFFFB95  bl 0x82ee4e08
	ctx.lr = 0x82EE5278;
	sub_82EE4E08(ctx, base);
	// 82EE5278: 817F00CC  lwz r11, 0xcc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82EE527C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EE5280: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE5284: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE5288; continue 'dispatch;
            }
            0x82EE5288 => {
    //   block [0x82EE5288..0x82EE52A8)
	// 82EE5288: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82EE528C: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 82EE5290: 4BDC8A91  bl 0x82cadd20
	ctx.lr = 0x82EE5294;
	sub_82CADCEC(ctx, base);
	// 82EE5294: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE5298: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EE529C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EE52A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EE52A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE52A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE52A8 size=1024
    let mut pc: u32 = 0x82EE52A8;
    'dispatch: loop {
        match pc {
            0x82EE52A8 => {
    //   block [0x82EE52A8..0x82EE52CC)
	// 82EE52A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE52AC: 4BDC4151  bl 0x82ca93fc
	ctx.lr = 0x82EE52B0;
	sub_82CA93D0(ctx, base);
	// 82EE52B0: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 82EE52B4: 4BDC8A1D  bl 0x82cadcd0
	ctx.lr = 0x82EE52B8;
	sub_82CADCA0(ctx, base);
	// 82EE52B8: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE52BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE52C0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EE52C4: 817F00CC  lwz r11, 0xcc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82EE52C8: 48000028  b 0x82ee52f0
	pc = 0x82EE52F0; continue 'dispatch;
            }
            0x82EE52CC => {
    //   block [0x82EE52CC..0x82EE52F0)
	// 82EE52CC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE52D0: 9BCA002C  stb r30, 0x2c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(44 as u32), ctx.r[30].u8 ) };
	// 82EE52D4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE52D8: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EE52DC: 812A0028  lwz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EE52E0: 910A0028  stw r8, 0x28(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(40 as u32), ctx.r[8].u32 ) };
	// 82EE52E4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE52E8: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82EE52EC: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	pc = 0x82EE52F0; continue 'dispatch;
            }
            0x82EE52F0 => {
    //   block [0x82EE52F0..0x82EE5350)
	// 82EE52F0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE52F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EE52F8: 409AFFD4  bne cr6, 0x82ee52cc
	if !ctx.cr[6].eq {
	pc = 0x82EE52CC; continue 'dispatch;
	}
	// 82EE52FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EE5300: 93CB000C  stw r30, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82EE5304: 93CB0014  stw r30, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82EE5308: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82EE530C: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EE5310: C01F0078  lfs f0, 0x78(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE5314: C1BF001C  lfs f13, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE5318: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82EE531C: C3DF00BC  lfs f30, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EE5320: 7FD9F378  mr r25, r30
	ctx.r[25].u64 = ctx.r[30].u64;
	// 82EE5324: C34A0BFC  lfs f26, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82EE5328: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EE532C: EDA06EBA  fmadds f13, f0, f26, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[26].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE5330: 3BAAAFB4  addi r29, r10, -0x504c
	ctx.r[29].s64 = ctx.r[10].s64 + -20556;
	// 82EE5334: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE5338: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EE533C: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 82EE5340: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82EE5344: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE5348: C36A0C18  lfs f27, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82EE534C: 48000064  b 0x82ee53b0
	pc = 0x82EE53B0; continue 'dispatch;
            }
            0x82EE5350 => {
    //   block [0x82EE5350..0x82EE5368)
	// 82EE5350: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EE5354: 409A0014  bne cr6, 0x82ee5368
	if !ctx.cr[6].eq {
	pc = 0x82EE5368; continue 'dispatch;
	}
	// 82EE5358: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE535C: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EE5360: 41980008  blt cr6, 0x82ee5368
	if ctx.cr[6].lt {
	pc = 0x82EE5368; continue 'dispatch;
	}
	// 82EE5364: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	pc = 0x82EE5368; continue 'dispatch;
            }
            0x82EE5368 => {
    //   block [0x82EE5368..0x82EE5390)
	// 82EE5368: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82EE536C: 409A0024  bne cr6, 0x82ee5390
	if !ctx.cr[6].eq {
	pc = 0x82EE5390; continue 'dispatch;
	}
	// 82EE5370: FC006850  fneg f0, f13
	ctx.f[0].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE5374: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE5378: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82EE537C: 40990030  ble cr6, 0x82ee53ac
	if !ctx.cr[6].gt {
	pc = 0x82EE53AC; continue 'dispatch;
	}
	// 82EE5380: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82EE5384: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE5388: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 82EE538C: 419A0020  beq cr6, 0x82ee53ac
	if ctx.cr[6].eq {
	pc = 0x82EE53AC; continue 'dispatch;
	}
	pc = 0x82EE5390; continue 'dispatch;
            }
            0x82EE5390 => {
    //   block [0x82EE5390..0x82EE53A0)
	// 82EE5390: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE5394: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82EE5398: 40980008  bge cr6, 0x82ee53a0
	if !ctx.cr[6].lt {
	pc = 0x82EE53A0; continue 'dispatch;
	}
	// 82EE539C: FFC00090  fmr f30, f0
	ctx.f[30].f64 = ctx.f[0].f64;
	pc = 0x82EE53A0; continue 'dispatch;
            }
            0x82EE53A0 => {
    //   block [0x82EE53A0..0x82EE53AC)
	// 82EE53A0: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE53A4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE53A8: 41990014  bgt cr6, 0x82ee53bc
	if ctx.cr[6].gt {
	pc = 0x82EE53BC; continue 'dispatch;
	}
	pc = 0x82EE53AC; continue 'dispatch;
            }
            0x82EE53AC => {
    //   block [0x82EE53AC..0x82EE53B0)
	// 82EE53AC: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	pc = 0x82EE53B0; continue 'dispatch;
            }
            0x82EE53B0 => {
    //   block [0x82EE53B0..0x82EE53BC)
	// 82EE53B0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE53B4: 4082FF9C  bne 0x82ee5350
	if !ctx.cr[0].eq {
	pc = 0x82EE5350; continue 'dispatch;
	}
	// 82EE53B8: 48000008  b 0x82ee53c0
	pc = 0x82EE53C0; continue 'dispatch;
            }
            0x82EE53BC => {
    //   block [0x82EE53BC..0x82EE53C0)
	// 82EE53BC: 7D795B78  mr r25, r11
	ctx.r[25].u64 = ctx.r[11].u64;
	pc = 0x82EE53C0; continue 'dispatch;
            }
            0x82EE53C0 => {
    //   block [0x82EE53C0..0x82EE53F4)
	// 82EE53C0: 89690018  lbz r11, 0x18(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EE53C4: 7FDAF378  mr r26, r30
	ctx.r[26].u64 = ctx.r[30].u64;
	// 82EE53C8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE53CC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE53D0: 3B8BAFB4  addi r28, r11, -0x504c
	ctx.r[28].s64 = ctx.r[11].s64 + -20556;
	// 82EE53D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EE53D8: 3B6B9128  addi r27, r11, -0x6ed8
	ctx.r[27].s64 = ctx.r[11].s64 + -28376;
	// 82EE53DC: 41820018  beq 0x82ee53f4
	if ctx.cr[0].eq {
	pc = 0x82EE53F4; continue 'dispatch;
	}
	// 82EE53E0: C01F0100  lfs f0, 0x100(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE53E4: C1BF00C4  lfs f13, 0xc4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE53E8: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE53EC: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 82EE53F0: 409900C4  ble cr6, 0x82ee54b4
	if !ctx.cr[6].gt {
	pc = 0x82EE54B4; continue 'dispatch;
	}
	pc = 0x82EE53F4; continue 'dispatch;
            }
            0x82EE53F4 => {
    //   block [0x82EE53F4..0x82EE54A0)
	// 82EE53F4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE53F8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EE53FC: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82EE5400: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82EE5404: FC20D890  fmr f1, f27
	ctx.f[1].f64 = ctx.f[27].f64;
	// 82EE5408: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EE540C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82EE5410: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EE5414: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE5418: 4E800421  bctrl
	ctx.lr = 0x82EE541C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE541C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82EE5420: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 82EE5424: 809F00CC  lwz r4, 0xcc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82EE5428: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EE542C: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82EE5430: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82EE5434: 4BFFF9D5  bl 0x82ee4e08
	ctx.lr = 0x82EE5438;
	sub_82EE4E08(ctx, base);
	// 82EE5438: C01F00BC  lfs f0, 0xbc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE543C: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 82EE5440: 419A0258  beq cr6, 0x82ee5698
	if ctx.cr[6].eq {
	pc = 0x82EE5698; continue 'dispatch;
	}
	// 82EE5444: C01F0100  lfs f0, 0x100(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE5448: C1BF00C4  lfs f13, 0xc4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE544C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE5450: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 82EE5454: 41990244  bgt cr6, 0x82ee5698
	if ctx.cr[6].gt {
	pc = 0x82EE5698; continue 'dispatch;
	}
	// 82EE5458: 897F0020  lbz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EE545C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE5460: 41820048  beq 0x82ee54a8
	if ctx.cr[0].eq {
	pc = 0x82EE54A8; continue 'dispatch;
	}
	// 82EE5464: C01F0024  lfs f0, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE5468: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EE546C: 4099003C  ble cr6, 0x82ee54a8
	if !ctx.cr[6].gt {
	pc = 0x82EE54A8; continue 'dispatch;
	}
	// 82EE5470: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE5474: 815F00CC  lwz r10, 0xcc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82EE5478: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE547C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE5480: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE5484: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE5488: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE548C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE5490: C1AB0020  lfs f13, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE5494: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE5498: 40980008  bge cr6, 0x82ee54a0
	if !ctx.cr[6].lt {
	pc = 0x82EE54A0; continue 'dispatch;
	}
	// 82EE549C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
            }
            0x82EE54A0 => {
    //   block [0x82EE54A0..0x82EE54A8)
	// 82EE54A0: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE54A4: 41820008  beq 0x82ee54ac
	if ctx.cr[0].eq {
	pc = 0x82EE54AC; continue 'dispatch;
	}
	pc = 0x82EE54A8; continue 'dispatch;
            }
            0x82EE54A8 => {
    //   block [0x82EE54A8..0x82EE54AC)
	// 82EE54A8: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	pc = 0x82EE54AC; continue 'dispatch;
            }
            0x82EE54AC => {
    //   block [0x82EE54AC..0x82EE54B4)
	// 82EE54AC: 8101005C  lwz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EE54B0: 936100B0  stw r27, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[27].u32 ) };
	pc = 0x82EE54B4; continue 'dispatch;
            }
            0x82EE54B4 => {
    //   block [0x82EE54B4..0x82EE54D8)
	// 82EE54B4: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 82EE54B8: C01F0078  lfs f0, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE54BC: C1BF004C  lfs f13, 0x4c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE54C0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82EE54C4: C3FF0018  lfs f31, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EE54C8: FFA0F090  fmr f29, f30
	ctx.f[29].f64 = ctx.f[30].f64;
	// 82EE54CC: EF806EBC  fnmsubs f28, f0, f26, f13
	ctx.f[28].f64 = -(((ctx.f[0].f64 * ctx.f[26].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE54D0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EE54D4: 480000D0  b 0x82ee55a4
	pc = 0x82EE55A4; continue 'dispatch;
            }
            0x82EE54D8 => {
    //   block [0x82EE54D8..0x82EE54EC)
	// 82EE54D8: C01F0078  lfs f0, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE54DC: EDA0FEBA  fmadds f13, f0, f26, f31
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[26].f64 + ctx.f[31].f64) as f32) as f64);
	// 82EE54E0: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE54E4: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EE54E8: 40990030  ble cr6, 0x82ee5518
	if !ctx.cr[6].gt {
	pc = 0x82EE5518; continue 'dispatch;
	}
	pc = 0x82EE54EC; continue 'dispatch;
            }
            0x82EE54EC => {
    //   block [0x82EE54EC..0x82EE550C)
	// 82EE54EC: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EE54F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EE54F4: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE54F8: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82EE54FC: 40980010  bge cr6, 0x82ee550c
	if !ctx.cr[6].lt {
	pc = 0x82EE550C; continue 'dispatch;
	}
	// 82EE5500: FFA00090  fmr f29, f0
	ctx.f[29].f64 = ctx.f[0].f64;
	// 82EE5504: FF1DD800  fcmpu cr6, f29, f27
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[27].f64);
	// 82EE5508: 419A00A4  beq cr6, 0x82ee55ac
	if ctx.cr[6].eq {
	pc = 0x82EE55AC; continue 'dispatch;
	}
	pc = 0x82EE550C; continue 'dispatch;
            }
            0x82EE550C => {
    //   block [0x82EE550C..0x82EE5518)
	// 82EE550C: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE5510: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE5514: 4199FFD8  bgt cr6, 0x82ee54ec
	if ctx.cr[6].gt {
	pc = 0x82EE54EC; continue 'dispatch;
	}
	pc = 0x82EE5518; continue 'dispatch;
            }
            0x82EE5518 => {
    //   block [0x82EE5518..0x82EE5560)
	// 82EE5518: FF1DD800  fcmpu cr6, f29, f27
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[27].f64);
	// 82EE551C: 419A0090  beq cr6, 0x82ee55ac
	if ctx.cr[6].eq {
	pc = 0x82EE55AC; continue 'dispatch;
	}
	// 82EE5520: 894B0018  lbz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EE5524: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE5528: 40820074  bne 0x82ee559c
	if !ctx.cr[0].eq {
	pc = 0x82EE559C; continue 'dispatch;
	}
	// 82EE552C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE5530: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82EE5534: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82EE5538: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EE553C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EE5540: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EE5544: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EE5548: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EE554C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE5550: 4E800421  bctrl
	ctx.lr = 0x82EE5554;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE5554: 809F00CC  lwz r4, 0xcc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82EE5558: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE555C: 48000018  b 0x82ee5574
	pc = 0x82EE5574; continue 'dispatch;
            }
            0x82EE5560 => {
    //   block [0x82EE5560..0x82EE5574)
	// 82EE5560: C00B0014  lfs f0, 0x14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE5564: C1A10080  lfs f13, 0x80(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE5568: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE556C: 40980010  bge cr6, 0x82ee557c
	if !ctx.cr[6].lt {
	pc = 0x82EE557C; continue 'dispatch;
	}
	// 82EE5570: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	pc = 0x82EE5574; continue 'dispatch;
            }
            0x82EE5574 => {
    //   block [0x82EE5574..0x82EE557C)
	// 82EE5574: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE5578: 4082FFE8  bne 0x82ee5560
	if !ctx.cr[0].eq {
	pc = 0x82EE5560; continue 'dispatch;
	}
	pc = 0x82EE557C; continue 'dispatch;
            }
            0x82EE557C => {
    //   block [0x82EE557C..0x82EE559C)
	// 82EE557C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82EE5580: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82EE5584: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82EE5588: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EE558C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EE5590: 4BFFF879  bl 0x82ee4e08
	ctx.lr = 0x82EE5594;
	sub_82EE4E08(ctx, base);
	// 82EE5594: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EE5598: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	pc = 0x82EE559C; continue 'dispatch;
            }
            0x82EE559C => {
    //   block [0x82EE559C..0x82EE55A4)
	// 82EE559C: C01F0018  lfs f0, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE55A0: EFFF002A  fadds f31, f31, f0
	ctx.f[31].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	pc = 0x82EE55A4; continue 'dispatch;
            }
            0x82EE55A4 => {
    //   block [0x82EE55A4..0x82EE55AC)
	// 82EE55A4: FF1FE000  fcmpu cr6, f31, f28
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[28].f64);
	// 82EE55A8: 4198FF30  blt cr6, 0x82ee54d8
	if ctx.cr[6].lt {
	pc = 0x82EE54D8; continue 'dispatch;
	}
	pc = 0x82EE55AC; continue 'dispatch;
            }
            0x82EE55AC => {
    //   block [0x82EE55AC..0x82EE55C4)
	// 82EE55AC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82EE55B0: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE55B4: FFA0E050  fneg f29, f28
	ctx.f[29].u64 = ctx.f[28].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE55B8: FFE00050  fneg f31, f0
	ctx.f[31].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE55BC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EE55C0: 480000D0  b 0x82ee5690
	pc = 0x82EE5690; continue 'dispatch;
            }
            0x82EE55C4 => {
    //   block [0x82EE55C4..0x82EE55D8)
	// 82EE55C4: C01F0078  lfs f0, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE55C8: EDA0FEBC  fnmsubs f13, f0, f26, f31
	ctx.f[13].f64 = -(((ctx.f[0].f64 * ctx.f[26].f64 - ctx.f[31].f64) as f32) as f64);
	// 82EE55CC: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE55D0: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EE55D4: 40980030  bge cr6, 0x82ee5604
	if !ctx.cr[6].lt {
	pc = 0x82EE5604; continue 'dispatch;
	}
	pc = 0x82EE55D8; continue 'dispatch;
            }
            0x82EE55D8 => {
    //   block [0x82EE55D8..0x82EE55F8)
	// 82EE55D8: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE55DC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EE55E0: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE55E4: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82EE55E8: 40980010  bge cr6, 0x82ee55f8
	if !ctx.cr[6].lt {
	pc = 0x82EE55F8; continue 'dispatch;
	}
	// 82EE55EC: FFC00090  fmr f30, f0
	ctx.f[30].f64 = ctx.f[0].f64;
	// 82EE55F0: FF1ED800  fcmpu cr6, f30, f27
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[27].f64);
	// 82EE55F4: 419A00A4  beq cr6, 0x82ee5698
	if ctx.cr[6].eq {
	pc = 0x82EE5698; continue 'dispatch;
	}
	pc = 0x82EE55F8; continue 'dispatch;
            }
            0x82EE55F8 => {
    //   block [0x82EE55F8..0x82EE5604)
	// 82EE55F8: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE55FC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE5600: 4198FFD8  blt cr6, 0x82ee55d8
	if ctx.cr[6].lt {
	pc = 0x82EE55D8; continue 'dispatch;
	}
	pc = 0x82EE5604; continue 'dispatch;
            }
            0x82EE5604 => {
    //   block [0x82EE5604..0x82EE564C)
	// 82EE5604: FF1ED800  fcmpu cr6, f30, f27
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[27].f64);
	// 82EE5608: 419A0090  beq cr6, 0x82ee5698
	if ctx.cr[6].eq {
	pc = 0x82EE5698; continue 'dispatch;
	}
	// 82EE560C: 894B0018  lbz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EE5610: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE5614: 40820074  bne 0x82ee5688
	if !ctx.cr[0].eq {
	pc = 0x82EE5688; continue 'dispatch;
	}
	// 82EE5618: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE561C: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82EE5620: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82EE5624: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EE5628: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EE562C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EE5630: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82EE5634: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EE5638: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE563C: 4E800421  bctrl
	ctx.lr = 0x82EE5640;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE5640: 809F00CC  lwz r4, 0xcc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82EE5644: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE5648: 48000018  b 0x82ee5660
	pc = 0x82EE5660; continue 'dispatch;
            }
            0x82EE564C => {
    //   block [0x82EE564C..0x82EE5660)
	// 82EE564C: C00B0014  lfs f0, 0x14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE5650: C1A100A0  lfs f13, 0xa0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE5654: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE5658: 40980010  bge cr6, 0x82ee5668
	if !ctx.cr[6].lt {
	pc = 0x82EE5668; continue 'dispatch;
	}
	// 82EE565C: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	pc = 0x82EE5660; continue 'dispatch;
            }
            0x82EE5660 => {
    //   block [0x82EE5660..0x82EE5668)
	// 82EE5660: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE5664: 4082FFE8  bne 0x82ee564c
	if !ctx.cr[0].eq {
	pc = 0x82EE564C; continue 'dispatch;
	}
	pc = 0x82EE5668; continue 'dispatch;
            }
            0x82EE5668 => {
    //   block [0x82EE5668..0x82EE5688)
	// 82EE5668: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82EE566C: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82EE5670: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82EE5674: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EE5678: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EE567C: 4BFFF78D  bl 0x82ee4e08
	ctx.lr = 0x82EE5680;
	sub_82EE4E08(ctx, base);
	// 82EE5680: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EE5684: 93610090  stw r27, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[27].u32 ) };
	pc = 0x82EE5688; continue 'dispatch;
            }
            0x82EE5688 => {
    //   block [0x82EE5688..0x82EE5690)
	// 82EE5688: C01F0018  lfs f0, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE568C: EFFF0028  fsubs f31, f31, f0
	ctx.f[31].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	pc = 0x82EE5690; continue 'dispatch;
            }
            0x82EE5690 => {
    //   block [0x82EE5690..0x82EE5698)
	// 82EE5690: FF1FE800  fcmpu cr6, f31, f29
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[29].f64);
	// 82EE5694: 4199FF30  bgt cr6, 0x82ee55c4
	if ctx.cr[6].gt {
	pc = 0x82EE55C4; continue 'dispatch;
	}
	pc = 0x82EE5698; continue 'dispatch;
            }
            0x82EE5698 => {
    //   block [0x82EE5698..0x82EE56A8)
	// 82EE5698: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 82EE569C: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 82EE56A0: 4BDC867D  bl 0x82cadd1c
	ctx.lr = 0x82EE56A4;
	sub_82CADCEC(ctx, base);
	// 82EE56A4: 4BDC3DA8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE56A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE56A8 size=180
    let mut pc: u32 = 0x82EE56A8;
    'dispatch: loop {
        match pc {
            0x82EE56A8 => {
    //   block [0x82EE56A8..0x82EE5714)
	// 82EE56A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE56AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EE56B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EE56B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EE56B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE56BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE56C0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EE56C4: 897F00ED  lbz r11, 0xed(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(237 as u32) ) } as u64;
	// 82EE56C8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE56CC: 4182006C  beq 0x82ee5738
	if ctx.cr[0].eq {
	pc = 0x82EE5738; continue 'dispatch;
	}
	// 82EE56D0: 9BDF00ED  stb r30, 0xed(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(237 as u32), ctx.r[30].u8 ) };
	// 82EE56D4: 4BFFF85D  bl 0x82ee4f30
	ctx.lr = 0x82EE56D8;
	sub_82EE4F30(ctx, base);
	// 82EE56D8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE56DC: 40820068  bne 0x82ee5744
	if !ctx.cr[0].eq {
	pc = 0x82EE5744; continue 'dispatch;
	}
	// 82EE56E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE56E4: 4BFFFBC5  bl 0x82ee52a8
	ctx.lr = 0x82EE56E8;
	sub_82EE52A8(ctx, base);
	// 82EE56E8: 817F00CC  lwz r11, 0xcc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82EE56EC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE56F0: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 82EE56F4: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EE56F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE56FC: 409A003C  bne cr6, 0x82ee5738
	if !ctx.cr[6].eq {
	pc = 0x82EE5738; continue 'dispatch;
	}
	// 82EE5700: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82EE5704: C01F0030  lfs f0, 0x30(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE5708: D01F00F0  stfs f0, 0xf0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82EE570C: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 82EE5710: 48000028  b 0x82ee5738
	pc = 0x82EE5738; continue 'dispatch;
            }
            0x82EE5714 => {
    //   block [0x82EE5714..0x82EE5738)
	// 82EE5714: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EE5718: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EE571C: 40980028  bge cr6, 0x82ee5744
	if !ctx.cr[6].lt {
	pc = 0x82EE5744; continue 'dispatch;
	}
	// 82EE5720: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE5724: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE5728: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82EE572C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE5730: 4E800421  bctrl
	ctx.lr = 0x82EE5734;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE5734: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
            }
            0x82EE5738 => {
    //   block [0x82EE5738..0x82EE5744)
	// 82EE5738: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82EE573C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE5740: 409AFFD4  bne cr6, 0x82ee5714
	if !ctx.cr[6].eq {
	pc = 0x82EE5714; continue 'dispatch;
	}
	pc = 0x82EE5744; continue 'dispatch;
            }
            0x82EE5744 => {
    //   block [0x82EE5744..0x82EE575C)
	// 82EE5744: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EE5748: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE574C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EE5750: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EE5754: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EE5758: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE5760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE5760 size=792
    let mut pc: u32 = 0x82EE5760;
    'dispatch: loop {
        match pc {
            0x82EE5760 => {
    //   block [0x82EE5760..0x82EE5798)
	// 82EE5760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE5764: 4BDC3CA9  bl 0x82ca940c
	ctx.lr = 0x82EE5768;
	sub_82CA93D0(ctx, base);
	// 82EE5768: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82EE576C: 4BDC8565  bl 0x82cadcd0
	ctx.lr = 0x82EE5770;
	sub_82CADCA0(ctx, base);
	// 82EE5770: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE5774: FF801090  fmr f28, f2
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[2].f64;
	// 82EE5778: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE577C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE5780: C13F010C  lfs f9, 0x10c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE5784: C14B0C18  lfs f10, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE5788: EDBC4828  fsubs f13, f28, f9
	ctx.f[13].f64 = (((ctx.f[28].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EE578C: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 82EE5790: 40980008  bge cr6, 0x82ee5798
	if !ctx.cr[6].lt {
	pc = 0x82EE5798; continue 'dispatch;
	}
	// 82EE5794: FDA05090  fmr f13, f10
	ctx.f[13].f64 = ctx.f[10].f64;
	pc = 0x82EE5798; continue 'dispatch;
            }
            0x82EE5798 => {
    //   block [0x82EE5798..0x82EE5850)
	// 82EE5798: C044004C  lfs f2, 0x4c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EE579C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE57A0: C07F00B4  lfs f3, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82EE57A4: FF1C5000  fcmpu cr6, f28, f10
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[10].f64);
	// 82EE57A8: C0040058  lfs f0, 0x58(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE57AC: EC6300B2  fmuls f3, f3, f2
	ctx.f[3].f64 = (((ctx.f[3].f64 * ctx.f[2].f64) as f32) as f64);
	// 82EE57B0: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE57B4: C0440054  lfs f2, 0x54(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EE57B8: C3FF00BC  lfs f31, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EE57BC: C184004C  lfs f12, 0x4c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE57C0: C0A40054  lfs f5, 0x54(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82EE57C4: C1640034  lfs f11, 0x34(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE57C8: C104003C  lfs f8, 0x3c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE57CC: C0FF009C  lfs f7, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EE57D0: C09F0064  lfs f4, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82EE57D4: C0DF00A4  lfs f6, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EE57D8: EC621FFA  fmadds f3, f2, f31, f3
	ctx.f[3].f64 = (((ctx.f[2].f64 * ctx.f[31].f64 + ctx.f[3].f64) as f32) as f64);
	// 82EE57DC: C34B0BE8  lfs f26, 0xbe8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3048 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82EE57E0: ED8D0332  fmuls f12, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE57E4: EDA50372  fmuls f13, f5, f13
	ctx.f[13].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE57E8: C0BF005C  lfs f5, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82EE57EC: EF630032  fmuls f27, f3, f0
	ctx.f[27].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE57F0: EC0B602A  fadds f0, f11, f12
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EE57F4: ED88682A  fadds f12, f8, f13
	ctx.f[12].f64 = ((ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE57F8: EDA02828  fsubs f13, f0, f5
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[5].f64) as f32) as f64);
	// 82EE57FC: ED6C2028  fsubs f11, f12, f4
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[4].f64) as f32) as f64);
	// 82EE5800: EDA70372  fmuls f13, f7, f13
	ctx.f[13].f64 = (((ctx.f[7].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE5804: EDA66AFA  fmadds f13, f6, f11, f13
	ctx.f[13].f64 = (((ctx.f[6].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE5808: 409A007C  bne cr6, 0x82ee5884
	if !ctx.cr[6].eq {
	pc = 0x82EE5884; continue 'dispatch;
	}
	// 82EE580C: FD602890  fmr f11, f5
	ctx.f[11].f64 = ctx.f[5].f64;
	// 82EE5810: FD002090  fmr f8, f4
	ctx.f[8].f64 = ctx.f[4].f64;
	// 82EE5814: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EE5818: C17F00B4  lfs f11, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE581C: ED8C4028  fsubs f12, f12, f8
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[8].f64) as f32) as f64);
	// 82EE5820: FD00F890  fmr f8, f31
	ctx.f[8].f64 = ctx.f[31].f64;
	// 82EE5824: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE5828: EC08033A  fmadds f0, f8, f12, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE582C: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EE5830: 4098003C  bge cr6, 0x82ee586c
	if !ctx.cr[6].lt {
	pc = 0x82EE586C; continue 'dispatch;
	}
	// 82EE5834: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE5838: C18B0C8C  lfs f12, 0xc8c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE583C: ED810332  fmuls f12, f1, f12
	ctx.f[12].f64 = (((ctx.f[1].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE5840: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EE5844: 4199000C  bgt cr6, 0x82ee5850
	if ctx.cr[6].gt {
	pc = 0x82EE5850; continue 'dispatch;
	}
	// 82EE5848: FD80D090  fmr f12, f26
	ctx.f[12].f64 = ctx.f[26].f64;
	// 82EE584C: 4800002C  b 0x82ee5878
	pc = 0x82EE5878; continue 'dispatch;
            }
            0x82EE5850 => {
    //   block [0x82EE5850..0x82EE586C)
	// 82EE5850: ED610072  fmuls f11, f1, f1
	ctx.f[11].f64 = (((ctx.f[1].f64 * ctx.f[1].f64) as f32) as f64);
	// 82EE5854: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE5858: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE585C: C18B0A7C  lfs f12, 0xa7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2684 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE5860: EC0B0338  fmsubs f0, f11, f12, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE5864: ED80002C  fsqrts f12, f0
	ctx.f[12].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EE5868: 48000010  b 0x82ee5878
	pc = 0x82EE5878; continue 'dispatch;
            }
            0x82EE586C => {
    //   block [0x82EE586C..0x82EE5878)
	// 82EE586C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE5870: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE5874: ED810032  fmuls f12, f1, f0
	ctx.f[12].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x82EE5878; continue 'dispatch;
            }
            0x82EE5878 => {
    //   block [0x82EE5878..0x82EE5884)
	// 82EE5878: EC0D6028  fsubs f0, f13, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE587C: EFEC682A  fadds f31, f12, f13
	ctx.f[31].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE5880: 48000030  b 0x82ee58b0
	pc = 0x82EE58B0; continue 'dispatch;
            }
            0x82EE5884 => {
    //   block [0x82EE5884..0x82EE58B0)
	// 82EE5884: C19F0108  lfs f12, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE5888: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE588C: ED6C0072  fmuls f11, f12, f1
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[1].f64) as f32) as f64);
	// 82EE5890: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE5894: ED810032  fmuls f12, f1, f0
	ctx.f[12].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE5898: EF8BE03C  fnmsubs f28, f11, f0, f28
	ctx.f[28].f64 = -(((ctx.f[11].f64 * ctx.f[0].f64 - ctx.f[28].f64) as f32) as f64);
	// 82EE589C: EC0D6028  fsubs f0, f13, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE58A0: EFEC682A  fadds f31, f12, f13
	ctx.f[31].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE58A4: FF1C5000  fcmpu cr6, f28, f10
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[10].f64);
	// 82EE58A8: 40980008  bge cr6, 0x82ee58b0
	if !ctx.cr[6].lt {
	pc = 0x82EE58B0; continue 'dispatch;
	}
	// 82EE58AC: FF805090  fmr f28, f10
	ctx.f[28].f64 = ctx.f[10].f64;
	pc = 0x82EE58B0; continue 'dispatch;
            }
            0x82EE58B0 => {
    //   block [0x82EE58B0..0x82EE58D4)
	// 82EE58B0: C19F0040  lfs f12, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE58B4: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EE58B8: 419901B0  bgt cr6, 0x82ee5a68
	if ctx.cr[6].gt {
	pc = 0x82EE5A68; continue 'dispatch;
	}
	// 82EE58BC: FDA06050  fneg f13, f12
	ctx.f[13].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE58C0: FF1F6800  fcmpu cr6, f31, f13
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[13].f64);
	// 82EE58C4: 419801A4  blt cr6, 0x82ee5a68
	if ctx.cr[6].lt {
	pc = 0x82EE5A68; continue 'dispatch;
	}
	// 82EE58C8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE58CC: 40980008  bge cr6, 0x82ee58d4
	if !ctx.cr[6].lt {
	pc = 0x82EE58D4; continue 'dispatch;
	}
	// 82EE58D0: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EE58D4; continue 'dispatch;
            }
            0x82EE58D4 => {
    //   block [0x82EE58D4..0x82EE58E0)
	// 82EE58D4: FF1F6000  fcmpu cr6, f31, f12
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[12].f64);
	// 82EE58D8: 40990008  ble cr6, 0x82ee58e0
	if !ctx.cr[6].gt {
	pc = 0x82EE58E0; continue 'dispatch;
	}
	// 82EE58DC: FFE06090  fmr f31, f12
	ctx.f[31].f64 = ctx.f[12].f64;
	pc = 0x82EE58E0; continue 'dispatch;
            }
            0x82EE58E0 => {
    //   block [0x82EE58E0..0x82EE5958)
	// 82EE58E0: EDA9D02A  fadds f13, f9, f26
	ctx.f[13].f64 = ((ctx.f[9].f64 + ctx.f[26].f64) as f32) as f64;
	// 82EE58E4: FF1C6800  fcmpu cr6, f28, f13
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[13].f64);
	// 82EE58E8: 40980150  bge cr6, 0x82ee5a38
	if !ctx.cr[6].lt {
	pc = 0x82EE5A38; continue 'dispatch;
	}
	// 82EE58EC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE58F0: C17F0074  lfs f11, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE58F4: C13F0014  lfs f9, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE58F8: C18BBAF4  lfs f12, -0x450c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17676 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE58FC: EFCB4B3A  fmadds f30, f11, f12, f9
	ctx.f[30].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 + ctx.f[9].f64) as f32) as f64);
	// 82EE5900: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82EE5904: 41990134  bgt cr6, 0x82ee5a38
	if ctx.cr[6].gt {
	pc = 0x82EE5A38; continue 'dispatch;
	}
	// 82EE5908: FFA0F050  fneg f29, f30
	ctx.f[29].u64 = ctx.f[30].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE590C: FF1FE800  fcmpu cr6, f31, f29
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[29].f64);
	// 82EE5910: 41980128  blt cr6, 0x82ee5a38
	if ctx.cr[6].lt {
	pc = 0x82EE5A38; continue 'dispatch;
	}
	// 82EE5914: ED9F002A  fadds f12, f31, f0
	ctx.f[12].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EE5918: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EE591C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE5920: FF0C5000  fcmpu cr6, f12, f10
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[10].f64);
	// 82EE5924: 40990088  ble cr6, 0x82ee59ac
	if !ctx.cr[6].gt {
	pc = 0x82EE59AC; continue 'dispatch;
	}
	// 82EE5928: FF1FF000  fcmpu cr6, f31, f30
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[30].f64);
	// 82EE592C: 4199002C  bgt cr6, 0x82ee5958
	if ctx.cr[6].gt {
	pc = 0x82EE5958; continue 'dispatch;
	}
	// 82EE5930: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EE5934: D00100F4  stfs f0, 0xf4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82EE5938: D3E100F8  stfs f31, 0xf8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82EE593C: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 82EE5940: D1A100FC  stfs f13, 0xfc(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82EE5944: D3610100  stfs f27, 0x100(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82EE5948: 916100F0  stw r11, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 82EE594C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE5950: 99610104  stb r11, 0x104(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[11].u8 ) };
	// 82EE5954: 48000110  b 0x82ee5a64
	pc = 0x82EE5A64; continue 'dispatch;
            }
            0x82EE5958 => {
    //   block [0x82EE5958..0x82EE59AC)
	// 82EE5958: 3BABAFB4  addi r29, r11, -0x504c
	ctx.r[29].s64 = ctx.r[11].s64 + -20556;
	// 82EE595C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EE5960: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EE5964: D3C10058  stfs f30, 0x58(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EE5968: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EE596C: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EE5970: D3610060  stfs f27, 0x60(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EE5974: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82EE5978: 9BC10064  stb r30, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u8 ) };
	// 82EE597C: 4BFF74DD  bl 0x82edce58
	ctx.lr = 0x82EE5980;
	sub_82EDCE58(ctx, base);
	// 82EE5980: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EE5984: D3C10094  stfs f30, 0x94(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82EE5988: D3E10098  stfs f31, 0x98(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82EE598C: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82EE5990: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EE5994: D381009C  stfs f28, 0x9c(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82EE5998: D36100A0  stfs f27, 0xa0(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82EE599C: 93A10090  stw r29, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[29].u32 ) };
	// 82EE59A0: 9BC100A4  stb r30, 0xa4(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[30].u8 ) };
	// 82EE59A4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EE59A8: 480000B8  b 0x82ee5a60
	pc = 0x82EE5A60; continue 'dispatch;
            }
            0x82EE59AC => {
    //   block [0x82EE59AC..0x82EE59DC)
	// 82EE59AC: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82EE59B0: 4198002C  blt cr6, 0x82ee59dc
	if ctx.cr[6].lt {
	pc = 0x82EE59DC; continue 'dispatch;
	}
	// 82EE59B4: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EE59B8: D00100B4  stfs f0, 0xb4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82EE59BC: D3E100B8  stfs f31, 0xb8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82EE59C0: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82EE59C4: D1A100BC  stfs f13, 0xbc(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82EE59C8: D36100C0  stfs f27, 0xc0(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82EE59CC: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82EE59D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE59D4: 996100C4  stb r11, 0xc4(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[11].u8 ) };
	// 82EE59D8: 4800008C  b 0x82ee5a64
	pc = 0x82EE5A64; continue 'dispatch;
            }
            0x82EE59DC => {
    //   block [0x82EE59DC..0x82EE5A38)
	// 82EE59DC: 3BABAFB4  addi r29, r11, -0x504c
	ctx.r[29].s64 = ctx.r[11].s64 + -20556;
	// 82EE59E0: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EE59E4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EE59E8: D3A10078  stfs f29, 0x78(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EE59EC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EE59F0: D381007C  stfs f28, 0x7c(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82EE59F4: D3610080  stfs f27, 0x80(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EE59F8: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82EE59FC: 9BC10084  stb r30, 0x84(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u8 ) };
	// 82EE5A00: 4BFF7459  bl 0x82edce58
	ctx.lr = 0x82EE5A04;
	sub_82EDCE58(ctx, base);
	// 82EE5A04: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EE5A08: C01F010C  lfs f0, 0x10c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE5A0C: EC00D02A  fadds f0, f0, f26
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[26].f64) as f32) as f64;
	// 82EE5A10: D3A100D4  stfs f29, 0xd4(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EE5A14: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 82EE5A18: D3E100D8  stfs f31, 0xd8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EE5A1C: D00100DC  stfs f0, 0xdc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EE5A20: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 82EE5A24: D36100E0  stfs f27, 0xe0(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EE5A28: 93A100D0  stw r29, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[29].u32 ) };
	// 82EE5A2C: 9BC100E4  stb r30, 0xe4(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[30].u8 ) };
	// 82EE5A30: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82EE5A34: 4800002C  b 0x82ee5a60
	pc = 0x82EE5A60; continue 'dispatch;
            }
            0x82EE5A38 => {
    //   block [0x82EE5A38..0x82EE5A60)
	// 82EE5A38: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE5A3C: D0010114  stfs f0, 0x114(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82EE5A40: D3E10118  stfs f31, 0x118(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 82EE5A44: 38810110  addi r4, r1, 0x110
	ctx.r[4].s64 = ctx.r[1].s64 + 272;
	// 82EE5A48: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EE5A4C: D381011C  stfs f28, 0x11c(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 82EE5A50: D3610120  stfs f27, 0x120(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82EE5A54: 91610110  stw r11, 0x110(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82EE5A58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE5A5C: 99610124  stb r11, 0x124(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), ctx.r[11].u8 ) };
	pc = 0x82EE5A60; continue 'dispatch;
            }
            0x82EE5A60 => {
    //   block [0x82EE5A60..0x82EE5A64)
	// 82EE5A60: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82EE5A64; continue 'dispatch;
            }
            0x82EE5A64 => {
    //   block [0x82EE5A64..0x82EE5A68)
	// 82EE5A64: 4BFF73F5  bl 0x82edce58
	ctx.lr = 0x82EE5A68;
	sub_82EDCE58(ctx, base);
	pc = 0x82EE5A68; continue 'dispatch;
            }
            0x82EE5A68 => {
    //   block [0x82EE5A68..0x82EE5A78)
	// 82EE5A68: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 82EE5A6C: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82EE5A70: 4BDC82AD  bl 0x82cadd1c
	ctx.lr = 0x82EE5A74;
	sub_82CADCEC(ctx, base);
	// 82EE5A74: 4BDC39E8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE5A78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE5A78 size=1232
    let mut pc: u32 = 0x82EE5A78;
    'dispatch: loop {
        match pc {
            0x82EE5A78 => {
    //   block [0x82EE5A78..0x82EE5BD8)
	// 82EE5A78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE5A7C: 4BDC397D  bl 0x82ca93f8
	ctx.lr = 0x82EE5A80;
	sub_82CA93D0(ctx, base);
	// 82EE5A80: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 82EE5A84: 4BDC821D  bl 0x82cadca0
	ctx.lr = 0x82EE5A88;
	sub_82CADCA0(ctx, base);
	// 82EE5A88: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE5A8C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EE5A90: C1850008  lfs f12, 8(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE5A94: C0050000  lfs f0, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE5A98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE5A9C: 396BDBFC  addi r11, r11, -0x2404
	ctx.r[11].s64 = ctx.r[11].s64 + -9220;
	// 82EE5AA0: C1A50004  lfs f13, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE5AA4: D06101FC  stfs f3, 0x1fc(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(508 as u32), tmp.u32 ) };
	// 82EE5AA8: ECA000B2  fmuls f5, f0, f2
	ctx.f[5].f64 = (((ctx.f[0].f64 * ctx.f[2].f64) as f32) as f64);
	// 82EE5AAC: EC6D00B2  fmuls f3, f13, f2
	ctx.f[3].f64 = (((ctx.f[13].f64 * ctx.f[2].f64) as f32) as f64);
	// 82EE5AB0: C1040000  lfs f8, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE5AB4: EC4C00B2  fmuls f2, f12, f2
	ctx.f[2].f64 = (((ctx.f[12].f64 * ctx.f[2].f64) as f32) as f64);
	// 82EE5AB8: C0E40004  lfs f7, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EE5ABC: C0C40008  lfs f6, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EE5AC0: 3B9F00B4  addi r28, r31, 0xb4
	ctx.r[28].s64 = ctx.r[31].s64 + 180;
	// 82EE5AC4: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE5AC8: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 82EE5ACC: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE5AD0: EFC002F2  fmuls f30, f0, f11
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE5AD4: C12B0004  lfs f9, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE5AD8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE5ADC: EFEC0272  fmuls f31, f12, f9
	ctx.f[31].f64 = (((ctx.f[12].f64 * ctx.f[9].f64) as f32) as f64);
	// 82EE5AE0: C35F005C  lfs f26, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82EE5AE4: EFAD02B2  fmuls f29, f13, f10
	ctx.f[29].f64 = (((ctx.f[13].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EE5AE8: C33F0064  lfs f25, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82EE5AEC: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 82EE5AF0: C30B0BEC  lfs f24, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 82EE5AF4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE5AF8: FC80C090  fmr f4, f24
	ctx.f[4].f64 = ctx.f[24].f64;
	// 82EE5AFC: FDE0C090  fmr f15, f24
	ctx.f[15].f64 = ctx.f[24].f64;
	// 82EE5B00: ED4CF2B8  fmsubs f10, f12, f10, f30
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[10].f64 - ctx.f[30].f64) as f32) as f64);
	// 82EE5B04: C2CB0C1C  lfs f22, 0xc1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3100 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 82EE5B08: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE5B0C: ED6DFAF8  fmsubs f11, f13, f11, f31
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[11].f64 - ctx.f[31].f64) as f32) as f64);
	// 82EE5B10: ED20EA78  fmsubs f9, f0, f9, f29
	ctx.f[9].f64 = (((ctx.f[0].f64 * ctx.f[9].f64 - ctx.f[29].f64) as f32) as f64);
	// 82EE5B14: FF60B090  fmr f27, f22
	ctx.f[27].f64 = ctx.f[22].f64;
	// 82EE5B18: C26B0C18  lfs f19, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[19].f64 = (tmp.f32 as f64);
	// 82EE5B1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE5B20: FDC09890  fmr f14, f19
	ctx.f[14].f64 = ctx.f[19].f64;
	// 82EE5B24: C3EB0BFC  lfs f31, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EE5B28: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE5B2C: EDA307F2  fmuls f13, f3, f31
	ctx.f[13].f64 = (((ctx.f[3].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EE5B30: EC0507F2  fmuls f0, f5, f31
	ctx.f[0].f64 = (((ctx.f[5].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EE5B34: EC6B0072  fmuls f3, f11, f1
	ctx.f[3].f64 = (((ctx.f[11].f64 * ctx.f[1].f64) as f32) as f64);
	// 82EE5B38: ED8207F2  fmuls f12, f2, f31
	ctx.f[12].f64 = (((ctx.f[2].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EE5B3C: EC4A0072  fmuls f2, f10, f1
	ctx.f[2].f64 = (((ctx.f[10].f64 * ctx.f[1].f64) as f32) as f64);
	// 82EE5B40: C16B0C4C  lfs f11, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE5B44: EC290072  fmuls f1, f9, f1
	ctx.f[1].f64 = (((ctx.f[9].f64 * ctx.f[1].f64) as f32) as f64);
	// 82EE5B48: ED276828  fsubs f9, f7, f13
	ctx.f[9].f64 = (((ctx.f[7].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE5B4C: ED480028  fsubs f10, f8, f0
	ctx.f[10].f64 = (((ctx.f[8].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE5B50: EFC002F2  fmuls f30, f0, f11
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE5B54: EC0307F2  fmuls f0, f3, f31
	ctx.f[0].f64 = (((ctx.f[3].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EE5B58: EFAD02F2  fmuls f29, f13, f11
	ctx.f[29].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE5B5C: EDA207F2  fmuls f13, f2, f31
	ctx.f[13].f64 = (((ctx.f[2].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EE5B60: EF8C02F2  fmuls f28, f12, f11
	ctx.f[28].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE5B64: ECA66028  fsubs f5, f6, f12
	ctx.f[5].f64 = (((ctx.f[6].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE5B68: ED8107F2  fmuls f12, f1, f31
	ctx.f[12].f64 = (((ctx.f[1].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EE5B6C: ED08F02A  fadds f8, f8, f30
	ctx.f[8].f64 = ((ctx.f[8].f64 + ctx.f[30].f64) as f32) as f64;
	// 82EE5B70: EC60502A  fadds f3, f0, f10
	ctx.f[3].f64 = ((ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64;
	// 82EE5B74: D06100BC  stfs f3, 0xbc(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82EE5B78: ED4A0028  fsubs f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE5B7C: D14100C8  stfs f10, 0xc8(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EE5B80: ECE7E82A  fadds f7, f7, f29
	ctx.f[7].f64 = ((ctx.f[7].f64 + ctx.f[29].f64) as f32) as f64;
	// 82EE5B84: ED4D482A  fadds f10, f13, f9
	ctx.f[10].f64 = ((ctx.f[13].f64 + ctx.f[9].f64) as f32) as f64;
	// 82EE5B88: D14100C0  stfs f10, 0xc0(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82EE5B8C: ECC6E02A  fadds f6, f6, f28
	ctx.f[6].f64 = ((ctx.f[6].f64 + ctx.f[28].f64) as f32) as f64;
	// 82EE5B90: ED496828  fsubs f10, f9, f13
	ctx.f[10].f64 = (((ctx.f[9].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE5B94: D14100CC  stfs f10, 0xcc(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EE5B98: ED4C282A  fadds f10, f12, f5
	ctx.f[10].f64 = ((ctx.f[12].f64 + ctx.f[5].f64) as f32) as f64;
	// 82EE5B9C: D14100C4  stfs f10, 0xc4(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82EE5BA0: ED456028  fsubs f10, f5, f12
	ctx.f[10].f64 = (((ctx.f[5].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE5BA4: D14100D0  stfs f10, 0xd0(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82EE5BA8: ED40402A  fadds f10, f0, f8
	ctx.f[10].f64 = ((ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64;
	// 82EE5BAC: D14100B0  stfs f10, 0xb0(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82EE5BB0: EC080028  fsubs f0, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE5BB4: D00100D4  stfs f0, 0xd4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82EE5BB8: ED4D382A  fadds f10, f13, f7
	ctx.f[10].f64 = ((ctx.f[13].f64 + ctx.f[7].f64) as f32) as f64;
	// 82EE5BBC: D14100B4  stfs f10, 0xb4(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82EE5BC0: EC076828  fsubs f0, f7, f13
	ctx.f[0].f64 = (((ctx.f[7].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE5BC4: D00100D8  stfs f0, 0xd8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EE5BC8: ED4C302A  fadds f10, f12, f6
	ctx.f[10].f64 = ((ctx.f[12].f64 + ctx.f[6].f64) as f32) as f64;
	// 82EE5BCC: D14100B8  stfs f10, 0xb8(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82EE5BD0: EC066028  fsubs f0, f6, f12
	ctx.f[0].f64 = (((ctx.f[6].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE5BD4: D00100DC  stfs f0, 0xdc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	pc = 0x82EE5BD8; continue 'dispatch;
            }
            0x82EE5BD8 => {
    //   block [0x82EE5BD8..0x82EE5C04)
	// 82EE5BD8: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE5BDC: EDA0D028  fsubs f13, f0, f26
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[26].f64) as f32) as f64);
	// 82EE5BE0: C18A0008  lfs f12, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE5BE4: C01C0008  lfs f0, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE5BE8: ED8CC828  fsubs f12, f12, f25
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[25].f64) as f32) as f64);
	// 82EE5BEC: C15C0000  lfs f10, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE5BF0: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE5BF4: EC0C02B8  fmsubs f0, f12, f10, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE5BF8: FF040000  fcmpu cr6, f4, f0
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[0].f64);
	// 82EE5BFC: 40990008  ble cr6, 0x82ee5c04
	if !ctx.cr[6].gt {
	pc = 0x82EE5C04; continue 'dispatch;
	}
	// 82EE5C00: FC800090  fmr f4, f0
	ctx.f[4].f64 = ctx.f[0].f64;
	pc = 0x82EE5C04; continue 'dispatch;
            }
            0x82EE5C04 => {
    //   block [0x82EE5C04..0x82EE5C10)
	// 82EE5C04: FF1B0000  fcmpu cr6, f27, f0
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[0].f64);
	// 82EE5C08: 40980008  bge cr6, 0x82ee5c10
	if !ctx.cr[6].lt {
	pc = 0x82EE5C10; continue 'dispatch;
	}
	// 82EE5C0C: FF600090  fmr f27, f0
	ctx.f[27].f64 = ctx.f[0].f64;
	pc = 0x82EE5C10; continue 'dispatch;
            }
            0x82EE5C10 => {
    //   block [0x82EE5C10..0x82EE5C30)
	// 82EE5C10: C15C0000  lfs f10, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE5C14: EDAD02B2  fmuls f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EE5C18: C15C0008  lfs f10, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE5C1C: EDAA6B3A  fmadds f13, f10, f12, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE5C20: FF0D7800  fcmpu cr6, f13, f15
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[15].f64);
	// 82EE5C24: 4098000C  bge cr6, 0x82ee5c30
	if !ctx.cr[6].lt {
	pc = 0x82EE5C30; continue 'dispatch;
	}
	// 82EE5C28: FDE06890  fmr f15, f13
	ctx.f[15].f64 = ctx.f[13].f64;
	// 82EE5C2C: FDC00090  fmr f14, f0
	ctx.f[14].f64 = ctx.f[0].f64;
	pc = 0x82EE5C30; continue 'dispatch;
            }
            0x82EE5C30 => {
    //   block [0x82EE5C30..0x82EE5C50)
	// 82EE5C30: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EE5C34: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82EE5C38: 4082FFA0  bne 0x82ee5bd8
	if !ctx.cr[0].eq {
	pc = 0x82EE5BD8; continue 'dispatch;
	}
	// 82EE5C3C: C01F0040  lfs f0, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE5C40: FDA00050  fneg f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE5C44: FF046800  fcmpu cr6, f4, f13
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[13].f64);
	// 82EE5C48: 40980008  bge cr6, 0x82ee5c50
	if !ctx.cr[6].lt {
	pc = 0x82EE5C50; continue 'dispatch;
	}
	// 82EE5C4C: FC806890  fmr f4, f13
	ctx.f[4].f64 = ctx.f[13].f64;
	pc = 0x82EE5C50; continue 'dispatch;
            }
            0x82EE5C50 => {
    //   block [0x82EE5C50..0x82EE5C5C)
	// 82EE5C50: FF1B0000  fcmpu cr6, f27, f0
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[0].f64);
	// 82EE5C54: 40990008  ble cr6, 0x82ee5c5c
	if !ctx.cr[6].gt {
	pc = 0x82EE5C5C; continue 'dispatch;
	}
	// 82EE5C58: FF600090  fmr f27, f0
	ctx.f[27].f64 = ctx.f[0].f64;
	pc = 0x82EE5C5C; continue 'dispatch;
            }
            0x82EE5C5C => {
    //   block [0x82EE5C5C..0x82EE5C84)
	// 82EE5C5C: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EE5C60: C19F0074  lfs f12, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE5C64: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EE5C68: EE8CDFFA  fmadds f20, f12, f31, f27
	ctx.f[20].f64 = (((ctx.f[12].f64 * ctx.f[31].f64 + ctx.f[27].f64) as f32) as f64);
	// 82EE5C6C: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EE5C70: C1AA0C14  lfs f13, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE5C74: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE5C78: 4182000C  beq 0x82ee5c84
	if ctx.cr[0].eq {
	pc = 0x82EE5C84; continue 'dispatch;
	}
	// 82EE5C7C: C14B000C  lfs f10, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE5C80: 48000008  b 0x82ee5c88
	pc = 0x82EE5C88; continue 'dispatch;
            }
            0x82EE5C84 => {
    //   block [0x82EE5C84..0x82EE5C88)
	// 82EE5C84: FD406890  fmr f10, f13
	ctx.f[10].f64 = ctx.f[13].f64;
	pc = 0x82EE5C88; continue 'dispatch;
            }
            0x82EE5C88 => {
    //   block [0x82EE5C88..0x82EE5CA0)
	// 82EE5C88: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EE5C8C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE5C90: C00A0A54  lfs f0, 0xa54(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE5C94: EFAA0032  fmuls f29, f10, f0
	ctx.f[29].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE5C98: 41820008  beq 0x82ee5ca0
	if ctx.cr[0].eq {
	pc = 0x82EE5CA0; continue 'dispatch;
	}
	// 82EE5C9C: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82EE5CA0; continue 'dispatch;
            }
            0x82EE5CA0 => {
    //   block [0x82EE5CA0..0x82EE5CC8)
	// 82EE5CA0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE5CA4: ED8C02F2  fmuls f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE5CA8: C00B0AC8  lfs f0, 0xac8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2760 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE5CAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EE5CB0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE5CB4: EDB42028  fsubs f13, f20, f4
	ctx.f[13].f64 = (((ctx.f[20].f64 - ctx.f[4].f64) as f32) as f64);
	// 82EE5CB8: EEA0E82A  fadds f21, f0, f29
	ctx.f[21].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 82EE5CBC: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EE5CC0: 41990008  bgt cr6, 0x82ee5cc8
	if ctx.cr[6].gt {
	pc = 0x82EE5CC8; continue 'dispatch;
	}
	// 82EE5CC4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82EE5CC8; continue 'dispatch;
            }
            0x82EE5CC8 => {
    //   block [0x82EE5CC8..0x82EE5D64)
	// 82EE5CC8: C01C0000  lfs f0, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE5CCC: 3B3F009C  addi r25, r31, 0x9c
	ctx.r[25].s64 = ctx.r[31].s64 + 156;
	// 82EE5CD0: C1BC0004  lfs f13, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE5CD4: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EE5CD8: C19C0008  lfs f12, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE5CDC: EDAD0772  fmuls f13, f13, f29
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EE5CE0: ED8C0772  fmuls f12, f12, f29
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EE5CE4: C11F005C  lfs f8, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE5CE8: C0FF0060  lfs f7, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EE5CEC: FF602090  fmr f27, f4
	ctx.f[27].f64 = ctx.f[4].f64;
	// 82EE5CF0: C0DF0064  lfs f6, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EE5CF4: FF04A000  fcmpu cr6, f4, f20
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[20].f64);
	// 82EE5CF8: C1790000  lfs f11, 0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE5CFC: 5578063E  clrlwi r24, r11, 0x18
	ctx.r[24].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EE5D00: C1590004  lfs f10, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE5D04: ED6B0132  fmuls f11, f11, f4
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[4].f64) as f32) as f64);
	// 82EE5D08: C1390008  lfs f9, 8(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE5D0C: ED4A0132  fmuls f10, f10, f4
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[4].f64) as f32) as f64);
	// 82EE5D10: ED290132  fmuls f9, f9, f4
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[4].f64) as f32) as f64);
	// 82EE5D14: EC080028  fsubs f0, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE5D18: EDA76828  fsubs f13, f7, f13
	ctx.f[13].f64 = (((ctx.f[7].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE5D1C: ED866028  fsubs f12, f6, f12
	ctx.f[12].f64 = (((ctx.f[6].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE5D20: EF40582A  fadds f26, f0, f11
	ctx.f[26].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EE5D24: D3410050  stfs f26, 0x50(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EE5D28: EF2D502A  fadds f25, f13, f10
	ctx.f[25].f64 = ((ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64;
	// 82EE5D2C: D3210054  stfs f25, 0x54(r1)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EE5D30: EEEC482A  fadds f23, f12, f9
	ctx.f[23].f64 = ((ctx.f[12].f64 + ctx.f[9].f64) as f32) as f64;
	// 82EE5D34: D2E10058  stfs f23, 0x58(r1)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EE5D38: 40980200  bge cr6, 0x82ee5f38
	if !ctx.cr[6].lt {
	pc = 0x82EE5F38; continue 'dispatch;
	}
	// 82EE5D3C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EE5D40: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82EE5D44: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EE5D48: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EE5D4C: 3B6B9128  addi r27, r11, -0x6ed8
	ctx.r[27].s64 = ctx.r[11].s64 + -28376;
	// 82EE5D50: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE5D54: C208BAF4  lfs f16, -0x450c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-17676 as u32) ) };
	ctx.f[16].f64 = (tmp.f32 as f64);
	// 82EE5D58: C229BDE8  lfs f17, -0x4218(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16920 as u32) ) };
	ctx.f[17].f64 = (tmp.f32 as f64);
	// 82EE5D5C: 3B4BAFB4  addi r26, r11, -0x504c
	ctx.r[26].s64 = ctx.r[11].s64 + -20556;
	// 82EE5D60: C24A0BE8  lfs f18, 0xbe8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3048 as u32) ) };
	ctx.f[18].f64 = (tmp.f32 as f64);
	pc = 0x82EE5D64; continue 'dispatch;
            }
            0x82EE5D64 => {
    //   block [0x82EE5D64..0x82EE5DA4)
	// 82EE5D64: C01C0000  lfs f0, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE5D68: FFC0C090  fmr f30, f24
	ctx.f[30].f64 = ctx.f[24].f64;
	// 82EE5D6C: C1BC0004  lfs f13, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE5D70: EC000572  fmuls f0, f0, f21
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[21].f64) as f32) as f64);
	// 82EE5D74: C19C0008  lfs f12, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE5D78: EDAD0572  fmuls f13, f13, f21
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[21].f64) as f32) as f64);
	// 82EE5D7C: ED8C0572  fmuls f12, f12, f21
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[21].f64) as f32) as f64);
	// 82EE5D80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE5D84: FF80B090  fmr f28, f22
	ctx.f[28].f64 = ctx.f[22].f64;
	// 82EE5D88: 3BC100B0  addi r30, r1, 0xb0
	ctx.r[30].s64 = ctx.r[1].s64 + 176;
	// 82EE5D8C: EC00D02A  fadds f0, f0, f26
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[26].f64) as f32) as f64;
	// 82EE5D90: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EE5D94: EC0DC82A  fadds f0, f13, f25
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[25].f64) as f32) as f64;
	// 82EE5D98: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EE5D9C: EC0CB82A  fadds f0, f12, f23
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[23].f64) as f32) as f64;
	// 82EE5DA0: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	pc = 0x82EE5DA4; continue 'dispatch;
            }
            0x82EE5DA4 => {
    //   block [0x82EE5DA4..0x82EE5DE0)
	// 82EE5DA4: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	// 82EE5DA8: FC20A890  fmr f1, f21
	ctx.f[1].f64 = ctx.f[21].f64;
	// 82EE5DAC: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 82EE5DB0: 57AB07BE  clrlwi r11, r29, 0x1e
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000003u64;
	// 82EE5DB4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EE5DB8: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EE5DBC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EE5DC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EE5DC4: 7CEB5214  add r7, r11, r10
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EE5DC8: 4BFFA0A1  bl 0x82edfe68
	ctx.lr = 0x82EE5DCC;
	sub_82EDFE68(ctx, base);
	// 82EE5DCC: FF01C000  fcmpu cr6, f1, f24
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[24].f64);
	// 82EE5DD0: 419A001C  beq cr6, 0x82ee5dec
	if ctx.cr[6].eq {
	pc = 0x82EE5DEC; continue 'dispatch;
	}
	// 82EE5DD4: FF1C0800  fcmpu cr6, f28, f1
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[1].f64);
	// 82EE5DD8: 40980008  bge cr6, 0x82ee5de0
	if !ctx.cr[6].lt {
	pc = 0x82EE5DE0; continue 'dispatch;
	}
	// 82EE5DDC: FF800890  fmr f28, f1
	ctx.f[28].f64 = ctx.f[1].f64;
	pc = 0x82EE5DE0; continue 'dispatch;
            }
            0x82EE5DE0 => {
    //   block [0x82EE5DE0..0x82EE5DEC)
	// 82EE5DE0: FF1E0800  fcmpu cr6, f30, f1
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[1].f64);
	// 82EE5DE4: 40990008  ble cr6, 0x82ee5dec
	if !ctx.cr[6].gt {
	pc = 0x82EE5DEC; continue 'dispatch;
	}
	// 82EE5DE8: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	pc = 0x82EE5DEC; continue 'dispatch;
            }
            0x82EE5DEC => {
    //   block [0x82EE5DEC..0x82EE5E10)
	// 82EE5DEC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82EE5DF0: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 82EE5DF4: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82EE5DF8: 4198FFAC  blt cr6, 0x82ee5da4
	if ctx.cr[6].lt {
	pc = 0x82EE5DA4; continue 'dispatch;
	}
	// 82EE5DFC: FF1CE800  fcmpu cr6, f28, f29
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[29].f64);
	// 82EE5E00: 419800F4  blt cr6, 0x82ee5ef4
	if ctx.cr[6].lt {
	pc = 0x82EE5EF4; continue 'dispatch;
	}
	// 82EE5E04: FF1EE800  fcmpu cr6, f30, f29
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[29].f64);
	// 82EE5E08: 40980008  bge cr6, 0x82ee5e10
	if !ctx.cr[6].lt {
	pc = 0x82EE5E10; continue 'dispatch;
	}
	// 82EE5E0C: FFC0E890  fmr f30, f29
	ctx.f[30].f64 = ctx.f[29].f64;
	pc = 0x82EE5E10; continue 'dispatch;
            }
            0x82EE5E10 => {
    //   block [0x82EE5E10..0x82EE5E3C)
	// 82EE5E10: EDBEE828  fsubs f13, f30, f29
	ctx.f[13].f64 = (((ctx.f[30].f64 - ctx.f[29].f64) as f32) as f64);
	// 82EE5E14: C17F0108  lfs f11, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE5E18: C01F0074  lfs f0, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE5E1C: C19F0040  lfs f12, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE5E20: ED4D02F2  fmuls f10, f13, f11
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE5E24: EDA0DFFC  fnmsubs f13, f0, f31, f27
	ctx.f[13].f64 = -(((ctx.f[0].f64 * ctx.f[31].f64 - ctx.f[27].f64) as f32) as f64);
	// 82EE5E28: FD606050  fneg f11, f12
	ctx.f[11].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE5E2C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE5E30: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82EE5E34: 40980008  bge cr6, 0x82ee5e3c
	if !ctx.cr[6].lt {
	pc = 0x82EE5E3C; continue 'dispatch;
	}
	// 82EE5E38: FDA05890  fmr f13, f11
	ctx.f[13].f64 = ctx.f[11].f64;
	pc = 0x82EE5E3C; continue 'dispatch;
            }
            0x82EE5E3C => {
    //   block [0x82EE5E3C..0x82EE5E48)
	// 82EE5E3C: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EE5E40: 40990008  ble cr6, 0x82ee5e48
	if !ctx.cr[6].gt {
	pc = 0x82EE5E48; continue 'dispatch;
	}
	// 82EE5E44: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	pc = 0x82EE5E48; continue 'dispatch;
            }
            0x82EE5E48 => {
    //   block [0x82EE5E48..0x82EE5E7C)
	// 82EE5E48: FF0F9800  fcmpu cr6, f15, f19
	ctx.cr[6].compare_f64(ctx.f[15].f64, ctx.f[19].f64);
	// 82EE5E4C: 4098007C  bge cr6, 0x82ee5ec8
	if !ctx.cr[6].lt {
	pc = 0x82EE5EC8; continue 'dispatch;
	}
	// 82EE5E50: C19F010C  lfs f12, 0x10c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE5E54: ED8C902A  fadds f12, f12, f18
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[18].f64) as f32) as f64;
	// 82EE5E58: FF0A6000  fcmpu cr6, f10, f12
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[12].f64);
	// 82EE5E5C: 4098006C  bge cr6, 0x82ee5ec8
	if !ctx.cr[6].lt {
	pc = 0x82EE5EC8; continue 'dispatch;
	}
	// 82EE5E60: FF0E9800  fcmpu cr6, f14, f19
	ctx.cr[6].compare_f64(ctx.f[14].f64, ctx.f[19].f64);
	// 82EE5E64: 41990018  bgt cr6, 0x82ee5e7c
	if ctx.cr[6].gt {
	pc = 0x82EE5E7C; continue 'dispatch;
	}
	// 82EE5E68: C17F0074  lfs f11, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE5E6C: C13F0014  lfs f9, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE5E70: ED6B4C78  fmsubs f11, f11, f17, f9
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[17].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EE5E74: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EE5E78: 40980020  bge cr6, 0x82ee5e98
	if !ctx.cr[6].lt {
	pc = 0x82EE5E98; continue 'dispatch;
	}
	pc = 0x82EE5E7C; continue 'dispatch;
            }
            0x82EE5E7C => {
    //   block [0x82EE5E7C..0x82EE5E98)
	// 82EE5E7C: FF0E9800  fcmpu cr6, f14, f19
	ctx.cr[6].compare_f64(ctx.f[14].f64, ctx.f[19].f64);
	// 82EE5E80: 40990048  ble cr6, 0x82ee5ec8
	if !ctx.cr[6].gt {
	pc = 0x82EE5EC8; continue 'dispatch;
	}
	// 82EE5E84: C17F0074  lfs f11, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE5E88: C13F0014  lfs f9, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE5E8C: ED6B4C3A  fmadds f11, f11, f16, f9
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[16].f64 + ctx.f[9].f64) as f32) as f64);
	// 82EE5E90: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82EE5E94: 41990034  bgt cr6, 0x82ee5ec8
	if ctx.cr[6].gt {
	pc = 0x82EE5EC8; continue 'dispatch;
	}
	pc = 0x82EE5E98; continue 'dispatch;
            }
            0x82EE5E98 => {
    //   block [0x82EE5E98..0x82EE5EC8)
	// 82EE5E98: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EE5E9C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EE5EA0: C00101FC  lfs f0, 0x1fc(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(508 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE5EA4: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EE5EA8: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EE5EAC: 93410070  stw r26, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[26].u32 ) };
	// 82EE5EB0: D181007C  stfs f12, 0x7c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82EE5EB4: 9B010084  stb r24, 0x84(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[24].u8 ) };
	// 82EE5EB8: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EE5EBC: 4BFF6F9D  bl 0x82edce58
	ctx.lr = 0x82EE5EC0;
	sub_82EDCE58(ctx, base);
	// 82EE5EC0: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 82EE5EC4: 48000030  b 0x82ee5ef4
	pc = 0x82EE5EF4; continue 'dispatch;
            }
            0x82EE5EC8 => {
    //   block [0x82EE5EC8..0x82EE5EF4)
	// 82EE5EC8: D0010098  stfs f0, 0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82EE5ECC: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82EE5ED0: C00101FC  lfs f0, 0x1fc(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(508 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE5ED4: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EE5ED8: D1A10094  stfs f13, 0x94(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82EE5EDC: 93410090  stw r26, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[26].u32 ) };
	// 82EE5EE0: D141009C  stfs f10, 0x9c(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82EE5EE4: 9B0100A4  stb r24, 0xa4(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[24].u8 ) };
	// 82EE5EE8: D00100A0  stfs f0, 0xa0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82EE5EEC: 4BFF6F6D  bl 0x82edce58
	ctx.lr = 0x82EE5EF0;
	sub_82EDCE58(ctx, base);
	// 82EE5EF0: 93610090  stw r27, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[27].u32 ) };
	pc = 0x82EE5EF4; continue 'dispatch;
            }
            0x82EE5EF4 => {
    //   block [0x82EE5EF4..0x82EE5F38)
	// 82EE5EF4: C01F0074  lfs f0, 0x74(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE5EF8: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EE5EFC: C1B90000  lfs f13, 0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE5F00: C1990004  lfs f12, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE5F04: C1790008  lfs f11, 8(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE5F08: EF60D82A  fadds f27, f0, f27
	ctx.f[27].f64 = ((ctx.f[0].f64 + ctx.f[27].f64) as f32) as f64;
	// 82EE5F0C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE5F10: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE5F14: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE5F18: FF1BA000  fcmpu cr6, f27, f20
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[20].f64);
	// 82EE5F1C: EF4DD02A  fadds f26, f13, f26
	ctx.f[26].f64 = ((ctx.f[13].f64 + ctx.f[26].f64) as f32) as f64;
	// 82EE5F20: D3410050  stfs f26, 0x50(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EE5F24: EF2CC82A  fadds f25, f12, f25
	ctx.f[25].f64 = ((ctx.f[12].f64 + ctx.f[25].f64) as f32) as f64;
	// 82EE5F28: D3210054  stfs f25, 0x54(r1)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EE5F2C: EEE0B82A  fadds f23, f0, f23
	ctx.f[23].f64 = ((ctx.f[0].f64 + ctx.f[23].f64) as f32) as f64;
	// 82EE5F30: D2E10058  stfs f23, 0x58(r1)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EE5F34: 4198FE30  blt cr6, 0x82ee5d64
	if ctx.cr[6].lt {
	pc = 0x82EE5D64; continue 'dispatch;
	}
	pc = 0x82EE5F38; continue 'dispatch;
            }
            0x82EE5F38 => {
    //   block [0x82EE5F38..0x82EE5F48)
	// 82EE5F38: 382101C0  addi r1, r1, 0x1c0
	ctx.r[1].s64 = ctx.r[1].s64 + 448;
	// 82EE5F3C: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 82EE5F40: 4BDC7DAD  bl 0x82cadcec
	ctx.lr = 0x82EE5F44;
	sub_82CADCEC(ctx, base);
	// 82EE5F44: 4BDC3504  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE5F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE5F48 size=1360
    let mut pc: u32 = 0x82EE5F48;
    'dispatch: loop {
        match pc {
            0x82EE5F48 => {
    //   block [0x82EE5F48..0x82EE5FA0)
	// 82EE5F48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE5F4C: 4BDC34C1  bl 0x82ca940c
	ctx.lr = 0x82EE5F50;
	sub_82CA93D0(ctx, base);
	// 82EE5F50: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82EE5F54: 4BDC7D79  bl 0x82cadccc
	ctx.lr = 0x82EE5F58;
	sub_82CADCA0(ctx, base);
	// 82EE5F58: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE5F5C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EE5F60: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EE5F64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE5F68: 388BC178  addi r4, r11, -0x3e88
	ctx.r[4].s64 = ctx.r[11].s64 + -16008;
	// 82EE5F6C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EE5F70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EE5F74: 4B302705  bl 0x821e8678
	ctx.lr = 0x82EE5F78;
	sub_821E8678(ctx, base);
	// 82EE5F78: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EE5F7C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE5F80: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE5F84: 3FA08334  lis r29, -0x7ccc
	ctx.r[29].s64 = -2093744128;
	// 82EE5F88: C3AA0C14  lfs f29, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EE5F8C: C36B0BFC  lfs f27, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82EE5F90: 41820010  beq 0x82ee5fa0
	if ctx.cr[0].eq {
	pc = 0x82EE5FA0; continue 'dispatch;
	}
	// 82EE5F94: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE5F98: EC0006F2  fmuls f0, f0, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EE5F9C: 4800001C  b 0x82ee5fb8
	pc = 0x82EE5FB8; continue 'dispatch;
            }
            0x82EE5FA0 => {
    //   block [0x82EE5FA0..0x82EE5FB4)
	// 82EE5FA0: 817D0718  lwz r11, 0x718(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EE5FA4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE5FA8: 4182000C  beq 0x82ee5fb4
	if ctx.cr[0].eq {
	pc = 0x82EE5FB4; continue 'dispatch;
	}
	// 82EE5FAC: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE5FB0: 48000008  b 0x82ee5fb8
	pc = 0x82EE5FB8; continue 'dispatch;
            }
            0x82EE5FB4 => {
    //   block [0x82EE5FB4..0x82EE5FB8)
	// 82EE5FB4: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	pc = 0x82EE5FB8; continue 'dispatch;
            }
            0x82EE5FB8 => {
    //   block [0x82EE5FB8..0x82EE6038)
	// 82EE5FB8: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EE5FBC: C15F00C4  lfs f10, 0xc4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE5FC0: EC0A002A  fadds f0, f10, f0
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EE5FC4: C1BE0038  lfs f13, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE5FC8: C19E003C  lfs f12, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE5FCC: C17E0034  lfs f11, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE5FD0: C14B0038  lfs f10, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE5FD4: EDAD5028  fsubs f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EE5FD8: C12B003C  lfs f9, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE5FDC: EFEC4828  fsubs f31, f12, f9
	ctx.f[31].f64 = (((ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EE5FE0: C18B0034  lfs f12, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE5FE4: EFCB6028  fsubs f30, f11, f12
	ctx.f[30].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE5FE8: C19F00AC  lfs f12, 0xac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE5FEC: C17F00B0  lfs f11, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE5FF0: C13F00A8  lfs f9, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE5FF4: FD400050  fneg f10, f0
	ctx.f[10].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE5FF8: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE5FFC: EDAB6FFA  fmadds f13, f11, f31, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[31].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE6000: EDA96FBA  fmadds f13, f9, f30, f13
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[30].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE6004: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 82EE6008: 41980480  blt cr6, 0x82ee6488
	if ctx.cr[6].lt {
	pc = 0x82EE6488; continue 'dispatch;
	}
	// 82EE600C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE6010: 41990478  bgt cr6, 0x82ee6488
	if ctx.cr[6].gt {
	pc = 0x82EE6488; continue 'dispatch;
	}
	// 82EE6014: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EE6018: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EE601C: 388BC5C8  addi r4, r11, -0x3a38
	ctx.r[4].s64 = ctx.r[11].s64 + -14904;
	// 82EE6020: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EE6024: 4B302655  bl 0x821e8678
	ctx.lr = 0x82EE6028;
	sub_821E8678(ctx, base);
	// 82EE6028: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE602C: 4182000C  beq 0x82ee6038
	if ctx.cr[0].eq {
	pc = 0x82EE6038; continue 'dispatch;
	}
	// 82EE6030: C3830004  lfs f28, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EE6034: 4800001C  b 0x82ee6050
	pc = 0x82EE6050; continue 'dispatch;
            }
            0x82EE6038 => {
    //   block [0x82EE6038..0x82EE604C)
	// 82EE6038: 817D0718  lwz r11, 0x718(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EE603C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE6040: 4182000C  beq 0x82ee604c
	if ctx.cr[0].eq {
	pc = 0x82EE604C; continue 'dispatch;
	}
	// 82EE6044: C38B000C  lfs f28, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EE6048: 48000008  b 0x82ee6050
	pc = 0x82EE6050; continue 'dispatch;
            }
            0x82EE604C => {
    //   block [0x82EE604C..0x82EE6050)
	// 82EE604C: FF80E890  fmr f28, f29
	ctx.f[28].f64 = ctx.f[29].f64;
	pc = 0x82EE6050; continue 'dispatch;
            }
            0x82EE6050 => {
    //   block [0x82EE6050..0x82EE60D4)
	// 82EE6050: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EE6054: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EE6058: 388BDA4C  addi r4, r11, -0x25b4
	ctx.r[4].s64 = ctx.r[11].s64 + -9652;
	// 82EE605C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EE6060: 4B302619  bl 0x821e8678
	ctx.lr = 0x82EE6064;
	sub_821E8678(ctx, base);
	// 82EE6064: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EE6068: C19F00B4  lfs f12, 0xb4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE606C: C17F00BC  lfs f11, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE6070: C1BE0058  lfs f13, 0x58(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6074: C15E004C  lfs f10, 0x4c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE6078: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE607C: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE6080: C13E0054  lfs f9, 0x54(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE6084: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE6088: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82EE608C: ED8D62B8  fmsubs f12, f13, f10, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE6090: EDAD5A78  fmsubs f13, f13, f9, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[9].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EE6094: C17F00B4  lfs f11, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE6098: FD405890  fmr f10, f11
	ctx.f[10].f64 = ctx.f[11].f64;
	// 82EE609C: C13F00BC  lfs f9, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE60A0: ED6B07B2  fmuls f11, f11, f30
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EE60A4: FD004890  fmr f8, f9
	ctx.f[8].f64 = ctx.f[9].f64;
	// 82EE60A8: ED8A0332  fmuls f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE60AC: EFA95FFA  fmadds f29, f9, f31, f11
	ctx.f[29].f64 = (((ctx.f[9].f64 * ctx.f[31].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EE60B0: EF28637A  fmadds f25, f8, f13, f12
	ctx.f[25].f64 = (((ctx.f[8].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 82EE60B4: 40820124  bne 0x82ee61d8
	if !ctx.cr[0].eq {
	pc = 0x82EE61D8; continue 'dispatch;
	}
	// 82EE60B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE60BC: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE60C0: FF1D6000  fcmpu cr6, f29, f12
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[12].f64);
	// 82EE60C4: 41980094  blt cr6, 0x82ee6158
	if ctx.cr[6].lt {
	pc = 0x82EE6158; continue 'dispatch;
	}
	// 82EE60C8: EDBC06F2  fmuls f13, f28, f27
	ctx.f[13].f64 = (((ctx.f[28].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EE60CC: FF1D6800  fcmpu cr6, f29, f13
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[13].f64);
	// 82EE60D0: 4098000C  bge cr6, 0x82ee60dc
	if !ctx.cr[6].lt {
	pc = 0x82EE60DC; continue 'dispatch;
	}
	pc = 0x82EE60D4; continue 'dispatch;
            }
            0x82EE60D4 => {
    //   block [0x82EE60D4..0x82EE60DC)
	// 82EE60D4: FC406090  fmr f2, f12
	ctx.f[2].f64 = ctx.f[12].f64;
	// 82EE60D8: 480000C0  b 0x82ee6198
	pc = 0x82EE6198; continue 'dispatch;
            }
            0x82EE60DC => {
    //   block [0x82EE60DC..0x82EE6158)
	// 82EE60DC: FDA00050  fneg f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE60E0: FF196800  fcmpu cr6, f25, f13
	ctx.cr[6].compare_f64(ctx.f[25].f64, ctx.f[13].f64);
	// 82EE60E4: 40990074  ble cr6, 0x82ee6158
	if !ctx.cr[6].gt {
	pc = 0x82EE6158; continue 'dispatch;
	}
	// 82EE60E8: C1BF0008  lfs f13, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE60EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE60F0: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE60F4: C17F0078  lfs f11, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE60F8: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE60FC: EC0D583A  fmadds f0, f13, f0, f11
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EE6100: EC00E02A  fadds f0, f0, f28
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[28].f64) as f32) as f64;
	// 82EE6104: FF1D0000  fcmpu cr6, f29, f0
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[0].f64);
	// 82EE6108: 41990050  bgt cr6, 0x82ee6158
	if ctx.cr[6].gt {
	pc = 0x82EE6158; continue 'dispatch;
	}
	// 82EE610C: C01F0074  lfs f0, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6110: EC00E02A  fadds f0, f0, f28
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[28].f64) as f32) as f64;
	// 82EE6114: C1BF0014  lfs f13, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6118: C17F00A4  lfs f11, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE611C: EC006EFA  fmadds f0, f0, f27, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[27].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE6120: C1BF009C  lfs f13, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6124: EDAD07B2  fmuls f13, f13, f30
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EE6128: EDAB6FFA  fmadds f13, f11, f31, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[31].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE612C: FD600050  fneg f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE6130: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82EE6134: 41980024  blt cr6, 0x82ee6158
	if ctx.cr[6].lt {
	pc = 0x82EE6158; continue 'dispatch;
	}
	// 82EE6138: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE613C: 4199001C  bgt cr6, 0x82ee6158
	if ctx.cr[6].gt {
	pc = 0x82EE6158; continue 'dispatch;
	}
	// 82EE6140: C01F0108  lfs f0, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6144: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE6148: EC400772  fmuls f2, f0, f29
	ctx.f[2].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EE614C: C00B0BEC  lfs f0, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6150: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82EE6154: 409A003C  bne cr6, 0x82ee6190
	if !ctx.cr[6].eq {
	pc = 0x82EE6190; continue 'dispatch;
	}
	pc = 0x82EE6158; continue 'dispatch;
            }
            0x82EE6158 => {
    //   block [0x82EE6158..0x82EE6190)
	// 82EE6158: C01F0078  lfs f0, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE615C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE6160: EDA0E02A  fadds f13, f0, f28
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[28].f64) as f32) as f64;
	// 82EE6164: C00B0C8C  lfs f0, 0xc8c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6168: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE616C: FF1D0000  fcmpu cr6, f29, f0
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[0].f64);
	// 82EE6170: 41980318  blt cr6, 0x82ee6488
	if ctx.cr[6].lt {
	pc = 0x82EE6488; continue 'dispatch;
	}
	// 82EE6174: EC1C06F2  fmuls f0, f28, f27
	ctx.f[0].f64 = (((ctx.f[28].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EE6178: FF1D0000  fcmpu cr6, f29, f0
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[0].f64);
	// 82EE617C: 4198FF58  blt cr6, 0x82ee60d4
	if ctx.cr[6].lt {
	pc = 0x82EE60D4; continue 'dispatch;
	}
	// 82EE6180: FF196000  fcmpu cr6, f25, f12
	ctx.cr[6].compare_f64(ctx.f[25].f64, ctx.f[12].f64);
	// 82EE6184: 40980304  bge cr6, 0x82ee6488
	if !ctx.cr[6].lt {
	pc = 0x82EE6488; continue 'dispatch;
	}
	// 82EE6188: EC1DC824  fdivs f0, f29, f25
	ctx.f[0].f64 = ((ctx.f[29].f64 / ctx.f[25].f64) as f32) as f64;
	// 82EE618C: FC400050  fneg f2, f0
	ctx.f[2].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x82EE6190; continue 'dispatch;
            }
            0x82EE6190 => {
    //   block [0x82EE6190..0x82EE6198)
	// 82EE6190: FF026000  fcmpu cr6, f2, f12
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[12].f64);
	// 82EE6194: 419802F4  blt cr6, 0x82ee6488
	if ctx.cr[6].lt {
	pc = 0x82EE6488; continue 'dispatch;
	}
	pc = 0x82EE6198; continue 'dispatch;
            }
            0x82EE6198 => {
    //   block [0x82EE6198..0x82EE61B8)
	// 82EE6198: C01F00C0  lfs f0, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE619C: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82EE61A0: 40990018  ble cr6, 0x82ee61b8
	if !ctx.cr[6].gt {
	pc = 0x82EE61B8; continue 'dispatch;
	}
	// 82EE61A4: C1BF0108  lfs f13, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE61A8: EDAD0732  fmuls f13, f13, f28
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EE61AC: EC0D06FA  fmadds f0, f13, f27, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[27].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE61B0: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82EE61B4: 419902D4  bgt cr6, 0x82ee6488
	if ctx.cr[6].gt {
	pc = 0x82EE6488; continue 'dispatch;
	}
	pc = 0x82EE61B8; continue 'dispatch;
            }
            0x82EE61B8 => {
    //   block [0x82EE61B8..0x82EE61D8)
	// 82EE61B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE61BC: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 82EE61C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EE61C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE61C8: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EE61CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE61D0: 4E800421  bctrl
	ctx.lr = 0x82EE61D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE61D4: 480002B4  b 0x82ee6488
	pc = 0x82EE6488; continue 'dispatch;
            }
            0x82EE61D8 => {
    //   block [0x82EE61D8..0x82EE6204)
	// 82EE61D8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EE61DC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EE61E0: 388BD2C0  addi r4, r11, -0x2d40
	ctx.r[4].s64 = ctx.r[11].s64 + -11584;
	// 82EE61E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EE61E8: 4B302491  bl 0x821e8678
	ctx.lr = 0x82EE61EC;
	sub_821E8678(ctx, base);
	// 82EE61EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE61F0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE61F4: C34B0C18  lfs f26, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82EE61F8: 4182000C  beq 0x82ee6204
	if ctx.cr[0].eq {
	pc = 0x82EE6204; continue 'dispatch;
	}
	// 82EE61FC: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 82EE6200: 48000024  b 0x82ee6224
	pc = 0x82EE6224; continue 'dispatch;
            }
            0x82EE6204 => {
    //   block [0x82EE6204..0x82EE6224)
	// 82EE6204: C01E004C  lfs f0, 0x4c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6208: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EE620C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EE6210: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EE6214: C01E0054  lfs f0, 0x54(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6218: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EE621C: D3410054  stfs f26, 0x54(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EE6220: 4B399049  bl 0x8227f268
	ctx.lr = 0x82EE6224;
	sub_8227F268(ctx, base);
	pc = 0x82EE6224; continue 'dispatch;
            }
            0x82EE6224 => {
    //   block [0x82EE6224..0x82EE6310)
	// 82EE6224: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EE6228: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE622C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EE6230: ECC007B2  fmuls f6, f0, f30
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EE6234: 396BDBFC  addi r11, r11, -0x2404
	ctx.r[11].s64 = ctx.r[11].s64 + -9220;
	// 82EE6238: C1830004  lfs f12, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE623C: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EE6240: C1A30008  lfs f13, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6244: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EE6248: C05D0004  lfs f2, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EE624C: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE6250: ECED02F2  fmuls f7, f13, f11
	ctx.f[7].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE6254: C12B0000  lfs f9, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE6258: ED2C0272  fmuls f9, f12, f9
	ctx.f[9].f64 = (((ctx.f[12].f64 * ctx.f[9].f64) as f32) as f64);
	// 82EE625C: C14B0008  lfs f10, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE6260: C09F00A4  lfs f4, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82EE6264: 897F007C  lbz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EE6268: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE626C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE6270: ED8C3AB8  fmsubs f12, f12, f10, f7
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[10].f64 - ctx.f[7].f64) as f32) as f64);
	// 82EE6274: C10B0BEC  lfs f8, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE6278: ED604AF8  fmsubs f11, f0, f11, f9
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[11].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EE627C: C13F00B4  lfs f9, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE6280: FCE04890  fmr f7, f9
	ctx.f[7].f64 = ctx.f[9].f64;
	// 82EE6284: ED4D37FA  fmadds f10, f13, f31, f6
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[31].f64 + ctx.f[6].f64) as f32) as f64);
	// 82EE6288: C0DF00BC  lfs f6, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EE628C: FCA03090  fmr f5, f6
	ctx.f[5].f64 = ctx.f[6].f64;
	// 82EE6290: ED290332  fmuls f9, f9, f12
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE6294: ECE001F2  fmuls f7, f0, f7
	ctx.f[7].f64 = (((ctx.f[0].f64 * ctx.f[7].f64) as f32) as f64);
	// 82EE6298: ED264AFA  fmadds f9, f6, f11, f9
	ctx.f[9].f64 = (((ctx.f[6].f64 * ctx.f[11].f64 + ctx.f[9].f64) as f32) as f64);
	// 82EE629C: C0DF009C  lfs f6, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EE62A0: ECCC01B2  fmuls f6, f12, f6
	ctx.f[6].f64 = (((ctx.f[12].f64 * ctx.f[6].f64) as f32) as f64);
	// 82EE62A4: ECE53B7A  fmadds f7, f5, f13, f7
	ctx.f[7].f64 = (((ctx.f[5].f64 * ctx.f[13].f64 + ctx.f[7].f64) as f32) as f64);
	// 82EE62A8: C0BF009C  lfs f5, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82EE62AC: EC050032  fmuls f0, f5, f0
	ctx.f[0].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE62B0: FCA02090  fmr f5, f4
	ctx.f[5].f64 = ctx.f[4].f64;
	// 82EE62B4: FD204A10  fabs f9, f9
	ctx.f[9].u64 = ctx.f[9].u64 & !0x8000_0000_0000_0000u64;
	// 82EE62B8: FCE03A10  fabs f7, f7
	ctx.f[7].u64 = ctx.f[7].u64 & !0x8000_0000_0000_0000u64;
	// 82EE62BC: EC05037A  fmadds f0, f5, f13, f0
	ctx.f[0].f64 = (((ctx.f[5].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE62C0: ED290732  fmuls f9, f9, f28
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EE62C4: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82EE62C8: ECE748BA  fmadds f7, f7, f2, f9
	ctx.f[7].f64 = (((ctx.f[7].f64 * ctx.f[2].f64 + ctx.f[9].f64) as f32) as f64);
	// 82EE62CC: ED2432FA  fmadds f9, f4, f11, f6
	ctx.f[9].f64 = (((ctx.f[4].f64 * ctx.f[11].f64 + ctx.f[6].f64) as f32) as f64);
	// 82EE62D0: FDA04A10  fabs f13, f9
	ctx.f[13].u64 = ctx.f[9].u64 & !0x8000_0000_0000_0000u64;
	// 82EE62D4: EDAD0732  fmuls f13, f13, f28
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EE62D8: ECC068BA  fmadds f6, f0, f2, f13
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[2].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE62DC: 4182003C  beq 0x82ee6318
	if ctx.cr[0].eq {
	pc = 0x82EE6318; continue 'dispatch;
	}
	// 82EE62E0: C01F0078  lfs f0, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE62E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE62E8: EC00382A  fadds f0, f0, f7
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64;
	// 82EE62EC: C1AB0C8C  lfs f13, 0xc8c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE62F0: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE62F4: FF1D6800  fcmpu cr6, f29, f13
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[13].f64);
	// 82EE62F8: 41980190  blt cr6, 0x82ee6488
	if ctx.cr[6].lt {
	pc = 0x82EE6488; continue 'dispatch;
	}
	// 82EE62FC: EC0006F2  fmuls f0, f0, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EE6300: FF1D0000  fcmpu cr6, f29, f0
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[0].f64);
	// 82EE6304: 4098005C  bge cr6, 0x82ee6360
	if !ctx.cr[6].lt {
	pc = 0x82EE6360; continue 'dispatch;
	}
	// 82EE6308: FF1DD000  fcmpu cr6, f29, f26
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[26].f64);
	// 82EE630C: 4198017C  blt cr6, 0x82ee6488
	if ctx.cr[6].lt {
	pc = 0x82EE6488; continue 'dispatch;
	}
	pc = 0x82EE6310; continue 'dispatch;
            }
            0x82EE6310 => {
    //   block [0x82EE6310..0x82EE6318)
	// 82EE6310: FD00D090  fmr f8, f26
	ctx.f[8].f64 = ctx.f[26].f64;
	// 82EE6314: 480000CC  b 0x82ee63e0
	pc = 0x82EE63E0; continue 'dispatch;
            }
            0x82EE6318 => {
    //   block [0x82EE6318..0x82EE6360)
	// 82EE6318: C01F0074  lfs f0, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE631C: ED20102A  fadds f9, f0, f2
	ctx.f[9].f64 = ((ctx.f[0].f64 + ctx.f[2].f64) as f32) as f64;
	// 82EE6320: C1BF0014  lfs f13, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6324: ED296EFA  fmadds f9, f9, f27, f13
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[27].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE6328: FCA04850  fneg f5, f9
	ctx.f[5].u64 = ctx.f[9].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE632C: FF0A2800  fcmpu cr6, f10, f5
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[5].f64);
	// 82EE6330: 41980030  blt cr6, 0x82ee6360
	if ctx.cr[6].lt {
	pc = 0x82EE6360; continue 'dispatch;
	}
	// 82EE6334: FF0A4800  fcmpu cr6, f10, f9
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[9].f64);
	// 82EE6338: 41990028  bgt cr6, 0x82ee6360
	if ctx.cr[6].gt {
	pc = 0x82EE6360; continue 'dispatch;
	}
	// 82EE633C: EC00E02A  fadds f0, f0, f28
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[28].f64) as f32) as f64;
	// 82EE6340: ED8C07B2  fmuls f12, f12, f30
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EE6344: EC006EFA  fmadds f0, f0, f27, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[27].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE6348: EDAB67FA  fmadds f13, f11, f31, f12
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[31].f64 + ctx.f[12].f64) as f32) as f64);
	// 82EE634C: FD800050  fneg f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE6350: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EE6354: 4198000C  blt cr6, 0x82ee6360
	if ctx.cr[6].lt {
	pc = 0x82EE6360; continue 'dispatch;
	}
	// 82EE6358: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE635C: 4099FFB4  ble cr6, 0x82ee6310
	if !ctx.cr[6].gt {
	pc = 0x82EE6310; continue 'dispatch;
	}
	pc = 0x82EE6360; continue 'dispatch;
            }
            0x82EE6360 => {
    //   block [0x82EE6360..0x82EE63C8)
	// 82EE6360: EC0706F2  fmuls f0, f7, f27
	ctx.f[0].f64 = (((ctx.f[7].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EE6364: FF1D0000  fcmpu cr6, f29, f0
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[0].f64);
	// 82EE6368: 4198FFA8  blt cr6, 0x82ee6310
	if ctx.cr[6].lt {
	pc = 0x82EE6310; continue 'dispatch;
	}
	// 82EE636C: C01F0078  lfs f0, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6370: FF19D000  fcmpu cr6, f25, f26
	ctx.cr[6].compare_f64(ctx.f[25].f64, ctx.f[26].f64);
	// 82EE6374: 41980054  blt cr6, 0x82ee63c8
	if ctx.cr[6].lt {
	pc = 0x82EE63C8; continue 'dispatch;
	}
	// 82EE6378: EDA7002A  fadds f13, f7, f0
	ctx.f[13].f64 = ((ctx.f[7].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EE637C: EC0D06FA  fmadds f0, f13, f27, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[27].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE6380: FF1D0000  fcmpu cr6, f29, f0
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[0].f64);
	// 82EE6384: 4098005C  bge cr6, 0x82ee63e0
	if !ctx.cr[6].lt {
	pc = 0x82EE63E0; continue 'dispatch;
	}
	// 82EE6388: C1BF009C  lfs f13, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE638C: EDAD07B2  fmuls f13, f13, f30
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EE6390: C01F0074  lfs f0, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6394: C19F00A4  lfs f12, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE6398: EC00302A  fadds f0, f0, f6
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[6].f64) as f32) as f64;
	// 82EE639C: EDAC6FFA  fmadds f13, f12, f31, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[31].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE63A0: EC0006F2  fmuls f0, f0, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EE63A4: FDA06A10  fabs f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 82EE63A8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE63AC: 40980034  bge cr6, 0x82ee63e0
	if !ctx.cr[6].lt {
	pc = 0x82EE63E0; continue 'dispatch;
	}
	// 82EE63B0: C01F0078  lfs f0, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE63B4: EC00382A  fadds f0, f0, f7
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64;
	// 82EE63B8: C1BF0108  lfs f13, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE63BC: EC00EEFC  fnmsubs f0, f0, f27, f29
	ctx.f[0].f64 = -(((ctx.f[0].f64 * ctx.f[27].f64 - ctx.f[29].f64) as f32) as f64);
	// 82EE63C0: ED000372  fmuls f8, f0, f13
	ctx.f[8].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE63C4: 48000014  b 0x82ee63d8
	pc = 0x82EE63D8; continue 'dispatch;
            }
            0x82EE63C8 => {
    //   block [0x82EE63C8..0x82EE63D8)
	// 82EE63C8: EC00382A  fadds f0, f0, f7
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64;
	// 82EE63CC: EC00EEFC  fnmsubs f0, f0, f27, f29
	ctx.f[0].f64 = -(((ctx.f[0].f64 * ctx.f[27].f64 - ctx.f[29].f64) as f32) as f64);
	// 82EE63D0: EC00C824  fdivs f0, f0, f25
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[25].f64) as f32) as f64;
	// 82EE63D4: FD000050  fneg f8, f0
	ctx.f[8].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x82EE63D8; continue 'dispatch;
            }
            0x82EE63D8 => {
    //   block [0x82EE63D8..0x82EE63E0)
	// 82EE63D8: FF08D000  fcmpu cr6, f8, f26
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[26].f64);
	// 82EE63DC: 419800AC  blt cr6, 0x82ee6488
	if ctx.cr[6].lt {
	pc = 0x82EE6488; continue 'dispatch;
	}
	pc = 0x82EE63E0; continue 'dispatch;
            }
            0x82EE63E0 => {
    //   block [0x82EE63E0..0x82EE6428)
	// 82EE63E0: C01F0108  lfs f0, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE63E4: C1BF00C0  lfs f13, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE63E8: EC0069FA  fmadds f0, f0, f7, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[7].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE63EC: FF080000  fcmpu cr6, f8, f0
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[0].f64);
	// 82EE63F0: 41990098  bgt cr6, 0x82ee6488
	if ctx.cr[6].gt {
	pc = 0x82EE6488; continue 'dispatch;
	}
	// 82EE63F4: C17E004C  lfs f11, 0x4c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE63F8: C19F00B4  lfs f12, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE63FC: ED8C02F2  fmuls f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE6400: C1BF010C  lfs f13, 0x10c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6404: C17E0054  lfs f11, 0x54(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE6408: EDA86828  fsubs f13, f8, f13
	ctx.f[13].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE640C: C15F00BC  lfs f10, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE6410: C01E0058  lfs f0, 0x58(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6414: ED8B62BA  fmadds f12, f11, f10, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64);
	// 82EE6418: FF0DD000  fcmpu cr6, f13, f26
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[26].f64);
	// 82EE641C: EC6C0032  fmuls f3, f12, f0
	ctx.f[3].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE6420: 40980008  bge cr6, 0x82ee6428
	if !ctx.cr[6].lt {
	pc = 0x82EE6428; continue 'dispatch;
	}
	// 82EE6424: FDA0D090  fmr f13, f26
	ctx.f[13].f64 = ctx.f[26].f64;
	pc = 0x82EE6428; continue 'dispatch;
            }
            0x82EE6428 => {
    //   block [0x82EE6428..0x82EE6488)
	// 82EE6428: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE642C: C1BE004C  lfs f13, 0x4c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6430: C19E0050  lfs f12, 0x50(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE6434: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE6438: C17E0054  lfs f11, 0x54(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE643C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82EE6440: C15E0038  lfs f10, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE6444: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EE6448: C13E003C  lfs f9, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE644C: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 82EE6450: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE6454: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82EE6458: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE645C: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE6460: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE6464: C17E0034  lfs f11, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE6468: EDAD582A  fadds f13, f13, f11
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64;
	// 82EE646C: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82EE6470: EDAA602A  fadds f13, f10, f12
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EE6474: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82EE6478: EC09002A  fadds f0, f9, f0
	ctx.f[0].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EE647C: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82EE6480: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE6484: 4E800421  bctrl
	ctx.lr = 0x82EE6488;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EE6488 => {
    //   block [0x82EE6488..0x82EE6498)
	// 82EE6488: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82EE648C: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82EE6490: 4BDC7889  bl 0x82cadd18
	ctx.lr = 0x82EE6494;
	sub_82CADCEC(ctx, base);
	// 82EE6494: 4BDC2FC8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE6498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE6498 size=908
    let mut pc: u32 = 0x82EE6498;
    'dispatch: loop {
        match pc {
            0x82EE6498 => {
    //   block [0x82EE6498..0x82EE6508)
	// 82EE6498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE649C: 4BDC2F6D  bl 0x82ca9408
	ctx.lr = 0x82EE64A0;
	sub_82CA93D0(ctx, base);
	// 82EE64A0: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82EE64A4: 4BDC7809  bl 0x82cadcac
	ctx.lr = 0x82EE64A8;
	sub_82CADCA0(ctx, base);
	// 82EE64A8: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE64AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE64B0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE64B4: 3BDF005C  addi r30, r31, 0x5c
	ctx.r[30].s64 = ctx.r[31].s64 + 92;
	// 82EE64B8: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EE64BC: C19F0084  lfs f12, 0x84(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE64C0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82EE64C4: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE64C8: C15E0008  lfs f10, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE64CC: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE64D0: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE64D4: C01F0080  lfs f0, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE64D8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE64DC: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE64E0: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE64E4: C19F0088  lfs f12, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE64E8: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EE64EC: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE64F0: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE64F4: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE64F8: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EE64FC: 4098000C  bge cr6, 0x82ee6508
	if !ctx.cr[6].lt {
	pc = 0x82EE6508; continue 'dispatch;
	}
	// 82EE6500: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EE6504: 48000310  b 0x82ee6814
	pc = 0x82EE6814; continue 'dispatch;
            }
            0x82EE6508 => {
    //   block [0x82EE6508..0x82EE6688)
	// 82EE6508: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE650C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE6510: C39F0080  lfs f28, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EE6514: C37F0084  lfs f27, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82EE6518: C35F0088  lfs f26, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82EE651C: C33F00B4  lfs f25, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82EE6520: C31F00B8  lfs f24, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 82EE6524: C2FF00BC  lfs f23, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 82EE6528: C2DF009C  lfs f22, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 82EE652C: C2BF00A0  lfs f21, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[21].f64 = (tmp.f32 as f64);
	// 82EE6530: C29F00A4  lfs f20, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[20].f64 = (tmp.f32 as f64);
	// 82EE6534: C27F00A8  lfs f19, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[19].f64 = (tmp.f32 as f64);
	// 82EE6538: C25F00AC  lfs f18, 0xac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[18].f64 = (tmp.f32 as f64);
	// 82EE653C: C23F00B0  lfs f17, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[17].f64 = (tmp.f32 as f64);
	// 82EE6540: C3FF00C8  lfs f31, 0xc8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EE6544: C3DF0040  lfs f30, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EE6548: C3BF00C0  lfs f29, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EE654C: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EE6550: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6554: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EE6558: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE655C: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EE6560: C1BF0080  lfs f13, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6564: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6568: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE656C: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE6570: C1BF0084  lfs f13, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6574: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE6578: C15F0088  lfs f10, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE657C: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE6580: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EE6584: C16B0C18  lfs f11, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE6588: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE658C: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE6590: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE6594: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE6598: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EE659C: D01F00C8  stfs f0, 0xc8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EE65A0: C19E0000  lfs f12, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE65A4: C1BF0080  lfs f13, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE65A8: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE65AC: C15F0084  lfs f10, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE65B0: C13F0088  lfs f9, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE65B4: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE65B8: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE65BC: C15E0008  lfs f10, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE65C0: ED495028  fsubs f10, f9, f10
	ctx.f[10].f64 = (((ctx.f[9].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EE65C4: C12B0C14  lfs f9, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE65C8: EC090024  fdivs f0, f9, f0
	ctx.f[0].f64 = ((ctx.f[9].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EE65CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE65D0: C10B0BFC  lfs f8, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE65D4: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE65D8: D1BF00B4  stfs f13, 0xb4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82EE65DC: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE65E0: D19F00B8  stfs f12, 0xb8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82EE65E4: EC0002B2  fmuls f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EE65E8: D01F00BC  stfs f0, 0xbc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82EE65EC: FDA05890  fmr f13, f11
	ctx.f[13].f64 = ctx.f[11].f64;
	// 82EE65F0: D17F00A0  stfs f11, 0xa0(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82EE65F4: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE65F8: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82EE65FC: C01F00B4  lfs f0, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6600: D01F00A4  stfs f0, 0xa4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82EE6604: C19F00A4  lfs f12, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE6608: C17F00B8  lfs f11, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE660C: C01F00BC  lfs f0, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6610: ECEB0332  fmuls f7, f11, f12
	ctx.f[7].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE6614: C13F009C  lfs f9, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE6618: C15F00B4  lfs f10, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE661C: ECC90032  fmuls f6, f9, f0
	ctx.f[6].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE6620: ECAA0372  fmuls f5, f10, f13
	ctx.f[5].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE6624: EC003B78  fmsubs f0, f0, f13, f7
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 - ctx.f[7].f64) as f32) as f64);
	// 82EE6628: D01F00A8  stfs f0, 0xa8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82EE662C: EDAA3338  fmsubs f13, f10, f12, f6
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[12].f64 - ctx.f[6].f64) as f32) as f64);
	// 82EE6630: D1BF00AC  stfs f13, 0xac(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82EE6634: ED892AF8  fmsubs f12, f9, f11, f5
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[11].f64 - ctx.f[5].f64) as f32) as f64);
	// 82EE6638: D19F00B0  stfs f12, 0xb0(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82EE663C: C01F0074  lfs f0, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6640: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EE6644: C1BF0014  lfs f13, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6648: C19F010C  lfs f12, 0x10c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE664C: EC406A3A  fmadds f2, f0, f8, f13
	ctx.f[2].f64 = (((ctx.f[0].f64 * ctx.f[8].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE6650: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE6654: D05F0040  stfs f2, 0x40(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82EE6658: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE665C: EC6C0032  fmuls f3, f12, f0
	ctx.f[3].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE6660: D07F00C0  stfs f3, 0xc0(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82EE6664: FC201050  fneg f1, f2
	ctx.f[1].u64 = ctx.f[2].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE6668: 4BFF6701  bl 0x82edcd68
	ctx.lr = 0x82EE666C;
	sub_82EDCD68(ctx, base);
	// 82EE666C: 807F004C  lwz r3, 0x4c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EE6670: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE6674: 41820070  beq 0x82ee66e4
	if ctx.cr[0].eq {
	pc = 0x82EE66E4; continue 'dispatch;
	}
	// 82EE6678: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EE667C: C03F0004  lfs f1, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EE6680: 4BFA1629  bl 0x82e87ca8
	ctx.lr = 0x82EE6684;
	sub_82E87CA8(ctx, base);
	// 82EE6684: 48000054  b 0x82ee66d8
	pc = 0x82EE66D8; continue 'dispatch;
            }
            0x82EE6688 => {
    //   block [0x82EE6688..0x82EE66B8)
	// 82EE6688: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EE668C: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EE6690: 419A0040  beq cr6, 0x82ee66d0
	if ctx.cr[6].eq {
	pc = 0x82EE66D0; continue 'dispatch;
	}
	// 82EE6694: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EE6698: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE669C: 4182001C  beq 0x82ee66b8
	if ctx.cr[0].eq {
	pc = 0x82EE66B8; continue 'dispatch;
	}
	// 82EE66A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EE66A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE66A8: 4E800421  bctrl
	ctx.lr = 0x82EE66AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE66AC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EE66B0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EE66B4: 409A001C  bne cr6, 0x82ee66d0
	if !ctx.cr[6].eq {
	pc = 0x82EE66D0; continue 'dispatch;
	}
            }
            0x82EE66B8 => {
    //   block [0x82EE66B8..0x82EE66D0)
	// 82EE66B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE66BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EE66C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE66C4: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EE66C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE66CC: 4E800421  bctrl
	ctx.lr = 0x82EE66D0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EE66D0 => {
    //   block [0x82EE66D0..0x82EE66D8)
	// 82EE66D0: 807F004C  lwz r3, 0x4c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EE66D4: 4BFA109D  bl 0x82e87770
	ctx.lr = 0x82EE66D8;
	sub_82E87770(ctx, base);
	pc = 0x82EE66D8; continue 'dispatch;
            }
            0x82EE66D8 => {
    //   block [0x82EE66D8..0x82EE66E4)
	// 82EE66D8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EE66DC: 4082FFAC  bne 0x82ee6688
	if !ctx.cr[0].eq {
	pc = 0x82EE6688; continue 'dispatch;
	}
	// 82EE66E0: 480000B0  b 0x82ee6790
	pc = 0x82EE6790; continue 'dispatch;
            }
            0x82EE66E4 => {
    //   block [0x82EE66E4..0x82EE66F8)
	// 82EE66E4: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EE66E8: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EE66EC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE66F0: 838B0008  lwz r28, 8(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE66F4: 48000094  b 0x82ee6788
	pc = 0x82EE6788; continue 'dispatch;
            }
            0x82EE66F8 => {
    //   block [0x82EE66F8..0x82EE672C)
	// 82EE66F8: 83BC0004  lwz r29, 4(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE66FC: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EE6700: 7F1D1840  cmplw cr6, r29, r3
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EE6704: 419A0080  beq cr6, 0x82ee6784
	if ctx.cr[6].eq {
	pc = 0x82EE6784; continue 'dispatch;
	}
	// 82EE6708: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EE670C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE6710: 4182001C  beq 0x82ee672c
	if ctx.cr[0].eq {
	pc = 0x82EE672C; continue 'dispatch;
	}
	// 82EE6714: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EE6718: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE671C: 4E800421  bctrl
	ctx.lr = 0x82EE6720;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE6720: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EE6724: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EE6728: 409A005C  bne cr6, 0x82ee6784
	if !ctx.cr[6].eq {
	pc = 0x82EE6784; continue 'dispatch;
	}
            }
            0x82EE672C => {
    //   block [0x82EE672C..0x82EE6784)
	// 82EE672C: C01F0004  lfs f0, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6730: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE6734: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6738: C01D0034  lfs f0, 0x34(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE673C: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE6740: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE6744: C1BD0038  lfs f13, 0x38(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6748: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE674C: C15D003C  lfs f10, 0x3c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE6750: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE6754: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EE6758: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE675C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE6760: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE6764: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EE6768: 4098001C  bge cr6, 0x82ee6784
	if !ctx.cr[6].lt {
	pc = 0x82EE6784; continue 'dispatch;
	}
	// 82EE676C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE6770: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EE6774: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE6778: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EE677C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE6780: 4E800421  bctrl
	ctx.lr = 0x82EE6784;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EE6784 => {
    //   block [0x82EE6784..0x82EE6788)
	// 82EE6784: 839C000C  lwz r28, 0xc(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x82EE6788; continue 'dispatch;
            }
            0x82EE6788 => {
    //   block [0x82EE6788..0x82EE6790)
	// 82EE6788: 281C0000  cmplwi r28, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE678C: 4082FF6C  bne 0x82ee66f8
	if !ctx.cr[0].eq {
	pc = 0x82EE66F8; continue 'dispatch;
	}
	pc = 0x82EE6790; continue 'dispatch;
            }
            0x82EE6790 => {
    //   block [0x82EE6790..0x82EE6804)
	// 82EE6790: 3D408330  lis r10, -0x7cd0
	ctx.r[10].s64 = -2094006272;
	// 82EE6794: D3FF00C8  stfs f31, 0xc8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82EE6798: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82EE679C: D3DF0040  stfs f30, 0x40(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82EE67A0: D3BF00C0  stfs f29, 0xc0(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82EE67A4: D39F0080  stfs f28, 0x80(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82EE67A8: D37F0084  stfs f27, 0x84(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82EE67AC: D35F0088  stfs f26, 0x88(r31)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82EE67B0: D33F00B4  stfs f25, 0xb4(r31)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82EE67B4: D31F00B8  stfs f24, 0xb8(r31)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82EE67B8: D2FF00BC  stfs f23, 0xbc(r31)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82EE67BC: D2DF009C  stfs f22, 0x9c(r31)
	tmp.f32 = (ctx.f[22].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82EE67C0: D2BF00A0  stfs f21, 0xa0(r31)
	tmp.f32 = (ctx.f[21].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82EE67C4: D29F00A4  stfs f20, 0xa4(r31)
	tmp.f32 = (ctx.f[20].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82EE67C8: D27F00A8  stfs f19, 0xa8(r31)
	tmp.f32 = (ctx.f[19].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82EE67CC: D25F00AC  stfs f18, 0xac(r31)
	tmp.f32 = (ctx.f[18].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82EE67D0: D23F00B0  stfs f17, 0xb0(r31)
	tmp.f32 = (ctx.f[17].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82EE67D4: 916AE220  stw r11, -0x1de0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-7648 as u32), ctx.r[11].u32 ) };
	// 82EE67D8: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EE67DC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE67E0: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE67E4: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82EE67E8: 4199001C  bgt cr6, 0x82ee6804
	if ctx.cr[6].gt {
	pc = 0x82EE6804; continue 'dispatch;
	}
	// 82EE67EC: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE67F0: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE67F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE67F8: C1AA0010  lfs f13, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE67FC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE6800: 40980008  bge cr6, 0x82ee6808
	if !ctx.cr[6].lt {
	pc = 0x82EE6808; continue 'dispatch;
	}
	pc = 0x82EE6804; continue 'dispatch;
            }
            0x82EE6804 => {
    //   block [0x82EE6804..0x82EE6808)
	// 82EE6804: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82EE6808; continue 'dispatch;
            }
            0x82EE6808 => {
    //   block [0x82EE6808..0x82EE6814)
	// 82EE6808: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EE680C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EE6810: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	pc = 0x82EE6814; continue 'dispatch;
            }
            0x82EE6814 => {
    //   block [0x82EE6814..0x82EE6824)
	// 82EE6814: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82EE6818: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82EE681C: 4BDC74DD  bl 0x82cadcf8
	ctx.lr = 0x82EE6820;
	sub_82CADCEC(ctx, base);
	// 82EE6820: 4BDC2C38  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE6828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE6828 size=644
    let mut pc: u32 = 0x82EE6828;
    'dispatch: loop {
        match pc {
            0x82EE6828 => {
    //   block [0x82EE6828..0x82EE68F8)
	// 82EE6828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE682C: 4BDC2BDD  bl 0x82ca9408
	ctx.lr = 0x82EE6830;
	sub_82CA93D0(ctx, base);
	// 82EE6830: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE6834: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE6838: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EE683C: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE6840: 9BDF00F9  stb r30, 0xf9(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(249 as u32), ctx.r[30].u8 ) };
	// 82EE6844: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE6848: 409A025C  bne cr6, 0x82ee6aa4
	if !ctx.cr[6].eq {
	pc = 0x82EE6AA4; continue 'dispatch;
	}
	// 82EE684C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EE6850: C01F0074  lfs f0, 0x74(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6854: 397F008C  addi r11, r31, 0x8c
	ctx.r[11].s64 = ctx.r[31].s64 + 140;
	// 82EE6858: 3BBF005C  addi r29, r31, 0x5c
	ctx.r[29].s64 = ctx.r[31].s64 + 92;
	// 82EE685C: C1AA0BFC  lfs f13, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6860: ED400372  fmuls f10, f0, f13
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE6864: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6868: C19D0000  lfs f12, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE686C: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE6870: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE6874: C19D0004  lfs f12, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE6878: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE687C: C13D0008  lfs f9, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE6880: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE6884: ED6B4828  fsubs f11, f11, f9
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[9].f64) as f32) as f64);
	// 82EE6888: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE688C: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE6890: EDAB6AFA  fmadds f13, f11, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE6894: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 82EE6898: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 82EE689C: 4098005C  bge cr6, 0x82ee68f8
	if !ctx.cr[6].lt {
	pc = 0x82EE68F8; continue 'dispatch;
	}
	// 82EE68A0: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EE68A4: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE68A8: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE68AC: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE68B0: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE68B4: C19D0004  lfs f12, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE68B8: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82EE68BC: C14B0008  lfs f10, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE68C0: FD604890  fmr f11, f9
	ctx.f[11].f64 = ctx.f[9].f64;
	// 82EE68C4: C10B0008  lfs f8, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE68C8: C12B0004  lfs f9, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE68CC: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE68D0: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE68D4: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EE68D8: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE68DC: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE68E0: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EE68E4: EDA9602A  fadds f13, f9, f12
	ctx.f[13].f64 = ((ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EE68E8: D1AB0004  stfs f13, 4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EE68EC: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE68F0: EC08002A  fadds f0, f8, f0
	ctx.f[0].f64 = ((ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EE68F4: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x82EE68F8; continue 'dispatch;
            }
            0x82EE68F8 => {
    //   block [0x82EE68F8..0x82EE6914)
	// 82EE68F8: 4B37A0C1  bl 0x822609b8
	ctx.lr = 0x82EE68FC;
	sub_822609B8(ctx, base);
	// 82EE68FC: 897F00F8  lbz r11, 0xf8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 82EE6900: C003004C  lfs f0, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6904: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE6908: 4182000C  beq 0x82ee6914
	if ctx.cr[0].eq {
	pc = 0x82EE6914; continue 'dispatch;
	}
	// 82EE690C: 9BDF00F8  stb r30, 0xf8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[30].u8 ) };
	// 82EE6910: 48000010  b 0x82ee6920
	pc = 0x82EE6920; continue 'dispatch;
            }
            0x82EE6914 => {
    //   block [0x82EE6914..0x82EE6920)
	// 82EE6914: C1BF00CC  lfs f13, 0xcc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6918: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE691C: 41980188  blt cr6, 0x82ee6aa4
	if ctx.cr[6].lt {
	pc = 0x82EE6AA4; continue 'dispatch;
	}
	pc = 0x82EE6920; continue 'dispatch;
            }
            0x82EE6920 => {
    //   block [0x82EE6920..0x82EE6968)
	// 82EE6920: C1BF0008  lfs f13, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6924: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EE6928: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EE692C: D01F00CC  stfs f0, 0xcc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82EE6930: 4B2DD9B9  bl 0x821c42e8
	ctx.lr = 0x82EE6934;
	sub_821C42E8(ctx, base);
	// 82EE6934: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EE6938: 906BE220  stw r3, -0x1de0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-7648 as u32), ctx.r[3].u32 ) };
	// 82EE693C: C01F0108  lfs f0, 0x108(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6940: C1BF000C  lfs f13, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6944: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EE6948: C19F00C8  lfs f12, 0xc8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE694C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE6950: C17F010C  lfs f11, 0x10c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE6954: EC0C583A  fmadds f0, f12, f0, f11
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EE6958: 997F00F9  stb r11, 0xf9(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(249 as u32), ctx.r[11].u8 ) };
	// 82EE695C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE6960: 41980008  blt cr6, 0x82ee6968
	if ctx.cr[6].lt {
	pc = 0x82EE6968; continue 'dispatch;
	}
	// 82EE6964: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EE6968; continue 'dispatch;
            }
            0x82EE6968 => {
    //   block [0x82EE6968..0x82EE699C)
	// 82EE6968: C05F0040  lfs f2, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EE696C: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EE6970: D01F00C0  stfs f0, 0xc0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82EE6974: FC600090  fmr f3, f0
	ctx.f[3].f64 = ctx.f[0].f64;
	// 82EE6978: FC201050  fneg f1, f2
	ctx.f[1].u64 = ctx.f[2].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE697C: 4BFF63ED  bl 0x82edcd68
	ctx.lr = 0x82EE6980;
	sub_82EDCD68(ctx, base);
	// 82EE6980: 807F004C  lwz r3, 0x4c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EE6984: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE6988: 41820070  beq 0x82ee69f8
	if ctx.cr[0].eq {
	pc = 0x82EE69F8; continue 'dispatch;
	}
	// 82EE698C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EE6990: C03F0004  lfs f1, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EE6994: 4BFA1315  bl 0x82e87ca8
	ctx.lr = 0x82EE6998;
	sub_82E87CA8(ctx, base);
	// 82EE6998: 48000054  b 0x82ee69ec
	pc = 0x82EE69EC; continue 'dispatch;
            }
            0x82EE699C => {
    //   block [0x82EE699C..0x82EE69CC)
	// 82EE699C: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EE69A0: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EE69A4: 419A0040  beq cr6, 0x82ee69e4
	if ctx.cr[6].eq {
	pc = 0x82EE69E4; continue 'dispatch;
	}
	// 82EE69A8: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EE69AC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE69B0: 4182001C  beq 0x82ee69cc
	if ctx.cr[0].eq {
	pc = 0x82EE69CC; continue 'dispatch;
	}
	// 82EE69B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EE69B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE69BC: 4E800421  bctrl
	ctx.lr = 0x82EE69C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE69C0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EE69C4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EE69C8: 409A001C  bne cr6, 0x82ee69e4
	if !ctx.cr[6].eq {
	pc = 0x82EE69E4; continue 'dispatch;
	}
            }
            0x82EE69CC => {
    //   block [0x82EE69CC..0x82EE69E4)
	// 82EE69CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE69D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EE69D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE69D8: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EE69DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE69E0: 4E800421  bctrl
	ctx.lr = 0x82EE69E4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EE69E4 => {
    //   block [0x82EE69E4..0x82EE69EC)
	// 82EE69E4: 807F004C  lwz r3, 0x4c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82EE69E8: 4BFA0D89  bl 0x82e87770
	ctx.lr = 0x82EE69EC;
	sub_82E87770(ctx, base);
	pc = 0x82EE69EC; continue 'dispatch;
            }
            0x82EE69EC => {
    //   block [0x82EE69EC..0x82EE69F8)
	// 82EE69EC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82EE69F0: 4082FFAC  bne 0x82ee699c
	if !ctx.cr[0].eq {
	pc = 0x82EE699C; continue 'dispatch;
	}
	// 82EE69F4: 480000B0  b 0x82ee6aa4
	pc = 0x82EE6AA4; continue 'dispatch;
            }
            0x82EE69F8 => {
    //   block [0x82EE69F8..0x82EE6A0C)
	// 82EE69F8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EE69FC: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EE6A00: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE6A04: 838B0008  lwz r28, 8(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE6A08: 48000094  b 0x82ee6a9c
	pc = 0x82EE6A9C; continue 'dispatch;
            }
            0x82EE6A0C => {
    //   block [0x82EE6A0C..0x82EE6A40)
	// 82EE6A0C: 83DC0004  lwz r30, 4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE6A10: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EE6A14: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82EE6A18: 419A0080  beq cr6, 0x82ee6a98
	if ctx.cr[6].eq {
	pc = 0x82EE6A98; continue 'dispatch;
	}
	// 82EE6A1C: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EE6A20: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE6A24: 4182001C  beq 0x82ee6a40
	if ctx.cr[0].eq {
	pc = 0x82EE6A40; continue 'dispatch;
	}
	// 82EE6A28: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EE6A2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE6A30: 4E800421  bctrl
	ctx.lr = 0x82EE6A34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE6A34: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EE6A38: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EE6A3C: 409A005C  bne cr6, 0x82ee6a98
	if !ctx.cr[6].eq {
	pc = 0x82EE6A98; continue 'dispatch;
	}
            }
            0x82EE6A40 => {
    //   block [0x82EE6A40..0x82EE6A98)
	// 82EE6A40: C01F0004  lfs f0, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6A44: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE6A48: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6A4C: C01E0034  lfs f0, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6A50: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE6A54: C19D0004  lfs f12, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE6A58: C1BE0038  lfs f13, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6A5C: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE6A60: C15E003C  lfs f10, 0x3c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE6A64: C19D0008  lfs f12, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE6A68: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EE6A6C: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE6A70: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE6A74: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE6A78: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EE6A7C: 4098001C  bge cr6, 0x82ee6a98
	if !ctx.cr[6].lt {
	pc = 0x82EE6A98; continue 'dispatch;
	}
	// 82EE6A80: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE6A84: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EE6A88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE6A8C: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EE6A90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE6A94: 4E800421  bctrl
	ctx.lr = 0x82EE6A98;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EE6A98 => {
    //   block [0x82EE6A98..0x82EE6A9C)
	// 82EE6A98: 839C000C  lwz r28, 0xc(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x82EE6A9C; continue 'dispatch;
            }
            0x82EE6A9C => {
    //   block [0x82EE6A9C..0x82EE6AA4)
	// 82EE6A9C: 281C0000  cmplwi r28, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE6AA0: 4082FF6C  bne 0x82ee6a0c
	if !ctx.cr[0].eq {
	pc = 0x82EE6A0C; continue 'dispatch;
	}
	pc = 0x82EE6AA4; continue 'dispatch;
            }
            0x82EE6AA4 => {
    //   block [0x82EE6AA4..0x82EE6AAC)
	// 82EE6AA4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82EE6AA8: 4BDC29B0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE6AB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EE6AB0 size=76
    let mut pc: u32 = 0x82EE6AB0;
    'dispatch: loop {
        match pc {
            0x82EE6AB0 => {
    //   block [0x82EE6AB0..0x82EE6AFC)
	// 82EE6AB0: C003010C  lfs f0, 0x10c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6AB4: EC020028  fsubs f0, f2, f0
	ctx.f[0].f64 = (((ctx.f[2].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE6AB8: C1A300C0  lfs f13, 0xc0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6ABC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE6AC0: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 82EE6AC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE6AC8: C16B0C18  lfs f11, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE6ACC: FF035800  fcmpu cr6, f3, f11
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[11].f64);
	// 82EE6AD0: 4098004C  bge cr6, 0x82ee6b1c
	if !ctx.cr[6].lt {
		sub_82EE6B1C(ctx, base);
		return;
	}
	// 82EE6AD4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE6AD8: C1A30110  lfs f13, 0x110(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6ADC: C18B0C4C  lfs f12, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE6AE0: ED4D0332  fmuls f10, f13, f12
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE6AE4: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EE6AE8: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 82EE6AEC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE6AF0: 4199000C  bgt cr6, 0x82ee6afc
	if ctx.cr[6].gt {
		sub_82EE6AFC(ctx, base);
		return;
	}
	// 82EE6AF4: FC205890  fmr f1, f11
	ctx.f[1].f64 = ctx.f[11].f64;
	// 82EE6AF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE6AFC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EE6AFC size=32
    let mut pc: u32 = 0x82EE6AFC;
    'dispatch: loop {
        match pc {
            0x82EE6AFC => {
    //   block [0x82EE6AFC..0x82EE6B1C)
	// 82EE6AFC: EDA06824  fdivs f13, f0, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EE6B00: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE6B04: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6B08: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE6B0C: EDAC0028  fsubs f13, f12, f0
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE6B10: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE6B14: EC200072  fmuls f1, f0, f1
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 82EE6B18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE6B1C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EE6B1C size=60
    let mut pc: u32 = 0x82EE6B1C;
    'dispatch: loop {
        match pc {
            0x82EE6B1C => {
    //   block [0x82EE6B1C..0x82EE6B58)
	// 82EE6B1C: FF030800  fcmpu cr6, f3, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[1].f64);
	// 82EE6B20: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 82EE6B24: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE6B28: C1A30110  lfs f13, 0x110(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6B2C: C18B0C4C  lfs f12, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE6B30: ED8D0332  fmuls f12, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE6B34: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EE6B38: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 82EE6B3C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE6B40: 41990018  bgt cr6, 0x82ee6b58
	if ctx.cr[6].gt {
		sub_82EE6B58(ctx, base);
		return;
	}
	// 82EE6B44: C023001C  lfs f1, 0x1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EE6B48: FF030800  fcmpu cr6, f3, f1
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[1].f64);
	// 82EE6B4C: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 82EE6B50: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 82EE6B54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE6B58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EE6B58 size=32
    let mut pc: u32 = 0x82EE6B58;
    'dispatch: loop {
        match pc {
            0x82EE6B58 => {
    //   block [0x82EE6B58..0x82EE6B78)
	// 82EE6B58: EDA06824  fdivs f13, f0, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82EE6B5C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE6B60: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6B64: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE6B68: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE6B6C: EDAD0072  fmuls f13, f13, f1
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[1].f64) as f32) as f64);
	// 82EE6B70: EC2068FA  fmadds f1, f0, f3, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[3].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE6B74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE6B78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EE6B78 size=96
    let mut pc: u32 = 0x82EE6B78;
    'dispatch: loop {
        match pc {
            0x82EE6B78 => {
    //   block [0x82EE6B78..0x82EE6BBC)
	// 82EE6B78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE6B7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EE6B80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EE6B84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EE6B88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE6B8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE6B90: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EE6B94: 809F0098  lwz r4, 0x98(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82EE6B98: 7F04F000  cmpw cr6, r4, r30
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[30].s32, &mut ctx.xer);
	// 82EE6B9C: 419A0024  beq cr6, 0x82ee6bc0
	if ctx.cr[6].eq {
	pc = 0x82EE6BC0; continue 'dispatch;
	}
	// 82EE6BA0: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82EE6BA4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE6BA8: 41820014  beq 0x82ee6bbc
	if ctx.cr[0].eq {
	pc = 0x82EE6BBC; continue 'dispatch;
	}
	// 82EE6BAC: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EE6BB0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EE6BB4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE6BB8: 4E800421  bctrl
	ctx.lr = 0x82EE6BBC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EE6BBC => {
    //   block [0x82EE6BBC..0x82EE6BC0)
	// 82EE6BBC: 93DF0098  stw r30, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[30].u32 ) };
	pc = 0x82EE6BC0; continue 'dispatch;
            }
            0x82EE6BC0 => {
    //   block [0x82EE6BC0..0x82EE6BD8)
	// 82EE6BC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EE6BC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE6BC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EE6BCC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EE6BD0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EE6BD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE6BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE6BD8 size=336
    let mut pc: u32 = 0x82EE6BD8;
    'dispatch: loop {
        match pc {
            0x82EE6BD8 => {
    //   block [0x82EE6BD8..0x82EE6C68)
	// 82EE6BD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE6BDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EE6BE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EE6BE4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE6BE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE6BEC: 817F00D4  lwz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EE6BF0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE6BF4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EE6BF8: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE6BFC: 419A00B8  beq cr6, 0x82ee6cb4
	if ctx.cr[6].eq {
	pc = 0x82EE6CB4; continue 'dispatch;
	}
	// 82EE6C00: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EE6C04: C1AB0018  lfs f13, 0x18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6C08: C00A0C18  lfs f0, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6C0C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE6C10: 419A00A0  beq cr6, 0x82ee6cb0
	if ctx.cr[6].eq {
	pc = 0x82EE6CB0; continue 'dispatch;
	}
	// 82EE6C14: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EE6C18: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EE6C1C: 389F005C  addi r4, r31, 0x5c
	ctx.r[4].s64 = ctx.r[31].s64 + 92;
	// 82EE6C20: 38AB0004  addi r5, r11, 4
	ctx.r[5].s64 = ctx.r[11].s64 + 4;
	// 82EE6C24: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE6C28: 816A0050  lwz r11, 0x50(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EE6C2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE6C30: 4E800421  bctrl
	ctx.lr = 0x82EE6C34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE6C34: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE6C38: 41820030  beq 0x82ee6c68
	if ctx.cr[0].eq {
	pc = 0x82EE6C68; continue 'dispatch;
	}
	// 82EE6C3C: 807F0048  lwz r3, 0x48(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EE6C40: 38BF0080  addi r5, r31, 0x80
	ctx.r[5].s64 = ctx.r[31].s64 + 128;
	// 82EE6C44: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE6C48: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82EE6C4C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE6C50: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82EE6C54: 816A0050  lwz r11, 0x50(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EE6C58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE6C5C: 4E800421  bctrl
	ctx.lr = 0x82EE6C60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE6C60: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE6C64: 4082004C  bne 0x82ee6cb0
	if !ctx.cr[0].eq {
	pc = 0x82EE6CB0; continue 'dispatch;
	}
            }
            0x82EE6C68 => {
    //   block [0x82EE6C68..0x82EE6C84)
	// 82EE6C68: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 82EE6C6C: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 82EE6C70: 419A0014  beq cr6, 0x82ee6c84
	if ctx.cr[6].eq {
	pc = 0x82EE6C84; continue 'dispatch;
	}
	// 82EE6C74: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82EE6C78: 419A000C  beq cr6, 0x82ee6c84
	if ctx.cr[6].eq {
	pc = 0x82EE6C84; continue 'dispatch;
	}
	// 82EE6C7C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82EE6C80: 917F0114  stw r11, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE6C84; continue 'dispatch;
            }
            0x82EE6C84 => {
    //   block [0x82EE6C84..0x82EE6CB0)
	// 82EE6C84: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE6C88: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EE6C8C: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 82EE6C90: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EE6C94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE6C98: 409A007C  bne cr6, 0x82ee6d14
	if !ctx.cr[6].eq {
	pc = 0x82EE6D14; continue 'dispatch;
	}
	// 82EE6C9C: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82EE6CA0: C01F002C  lfs f0, 0x2c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6CA4: D01F00FC  stfs f0, 0xfc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82EE6CA8: 917F0114  stw r11, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 82EE6CAC: 48000068  b 0x82ee6d14
	pc = 0x82EE6D14; continue 'dispatch;
            }
            0x82EE6CB0 => {
    //   block [0x82EE6CB0..0x82EE6CB4)
	// 82EE6CB0: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	pc = 0x82EE6CB4; continue 'dispatch;
            }
            0x82EE6CB4 => {
    //   block [0x82EE6CB4..0x82EE6D14)
	// 82EE6CB4: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6CB8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE6CBC: D01F008C  stfs f0, 0x8c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82EE6CC0: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6CC4: D01F0090  stfs f0, 0x90(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82EE6CC8: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6CCC: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82EE6CD0: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE6CD4: C00B0018  lfs f0, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6CD8: D01F00D8  stfs f0, 0xd8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82EE6CDC: D01F00DC  stfs f0, 0xdc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82EE6CE0: C00B0020  lfs f0, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6CE4: D01F00E4  stfs f0, 0xe4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82EE6CE8: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6CEC: D01F00E0  stfs f0, 0xe0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82EE6CF0: C00B001C  lfs f0, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6CF4: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EE6CF8: C00B0024  lfs f0, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6CFC: D01F00EC  stfs f0, 0xec(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82EE6D00: 915F00F4  stw r10, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[10].u32 ) };
	// 82EE6D04: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 82EE6D08: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82EE6D0C: 419A0008  beq cr6, 0x82ee6d14
	if ctx.cr[6].eq {
	pc = 0x82EE6D14; continue 'dispatch;
	}
	// 82EE6D10: 915F0114  stw r10, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[10].u32 ) };
	pc = 0x82EE6D14; continue 'dispatch;
            }
            0x82EE6D14 => {
    //   block [0x82EE6D14..0x82EE6D28)
	// 82EE6D14: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EE6D18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE6D1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EE6D20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EE6D24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE6D28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE6D28 size=372
    let mut pc: u32 = 0x82EE6D28;
    'dispatch: loop {
        match pc {
            0x82EE6D28 => {
    //   block [0x82EE6D28..0x82EE6D70)
	// 82EE6D28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE6D2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EE6D30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EE6D34: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE6D38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE6D3C: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 82EE6D40: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82EE6D44: 41980050  blt cr6, 0x82ee6d94
	if ctx.cr[6].lt {
	pc = 0x82EE6D94; continue 'dispatch;
	}
	// 82EE6D48: 419A0044  beq cr6, 0x82ee6d8c
	if ctx.cr[6].eq {
	pc = 0x82EE6D8C; continue 'dispatch;
	}
	// 82EE6D4C: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82EE6D50: 419A0020  beq cr6, 0x82ee6d70
	if ctx.cr[6].eq {
	pc = 0x82EE6D70; continue 'dispatch;
	}
	// 82EE6D54: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82EE6D58: 409A0130  bne cr6, 0x82ee6e88
	if !ctx.cr[6].eq {
	pc = 0x82EE6E88; continue 'dispatch;
	}
	// 82EE6D5C: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82EE6D60: 4BFFFE19  bl 0x82ee6b78
	ctx.lr = 0x82EE6D64;
	sub_82EE6B78(ctx, base);
	// 82EE6D64: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE6D68: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6D6C: 48000018  b 0x82ee6d84
	pc = 0x82EE6D84; continue 'dispatch;
            }
            0x82EE6D70 => {
    //   block [0x82EE6D70..0x82EE6D84)
	// 82EE6D70: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EE6D74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE6D78: 4BFFFE01  bl 0x82ee6b78
	ctx.lr = 0x82EE6D7C;
	sub_82EE6B78(ctx, base);
	// 82EE6D7C: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EE6D80: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82EE6D84; continue 'dispatch;
            }
            0x82EE6D84 => {
    //   block [0x82EE6D84..0x82EE6D8C)
	// 82EE6D84: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EE6D88: 48000100  b 0x82ee6e88
	pc = 0x82EE6E88; continue 'dispatch;
            }
            0x82EE6D8C => {
    //   block [0x82EE6D8C..0x82EE6D94)
	// 82EE6D8C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82EE6D90: 480000F0  b 0x82ee6e80
	pc = 0x82EE6E80; continue 'dispatch;
            }
            0x82EE6D94 => {
    //   block [0x82EE6D94..0x82EE6DC8)
	// 82EE6D94: C1BF010C  lfs f13, 0x10c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6D98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE6D9C: C01F0110  lfs f0, 0x110(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6DA0: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE6DA4: C1BF00E4  lfs f13, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6DA8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE6DAC: 4098002C  bge cr6, 0x82ee6dd8
	if !ctx.cr[6].lt {
	pc = 0x82EE6DD8; continue 'dispatch;
	}
	// 82EE6DB0: C01F00EC  lfs f0, 0xec(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6DB4: C1BF001C  lfs f13, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6DB8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE6DBC: 4098000C  bge cr6, 0x82ee6dc8
	if !ctx.cr[6].lt {
	pc = 0x82EE6DC8; continue 'dispatch;
	}
	// 82EE6DC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EE6DC4: 48000014  b 0x82ee6dd8
	pc = 0x82EE6DD8; continue 'dispatch;
            }
            0x82EE6DC8 => {
    //   block [0x82EE6DC8..0x82EE6DD8)
	// 82EE6DC8: C1BF00E8  lfs f13, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6DCC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE6DD0: 40980008  bge cr6, 0x82ee6dd8
	if !ctx.cr[6].lt {
	pc = 0x82EE6DD8; continue 'dispatch;
	}
	// 82EE6DD4: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	pc = 0x82EE6DD8; continue 'dispatch;
            }
            0x82EE6DD8 => {
    //   block [0x82EE6DD8..0x82EE6E08)
	// 82EE6DD8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE6DDC: 41820064  beq 0x82ee6e40
	if ctx.cr[0].eq {
	pc = 0x82EE6E40; continue 'dispatch;
	}
	// 82EE6DE0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE6DE4: C1BF0024  lfs f13, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6DE8: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6DEC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE6DF0: 40990020  ble cr6, 0x82ee6e10
	if !ctx.cr[6].gt {
	pc = 0x82EE6E10; continue 'dispatch;
	}
	// 82EE6DF4: 817F0098  lwz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82EE6DF8: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EE6DFC: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82EE6E00: 419A0008  beq cr6, 0x82ee6e08
	if ctx.cr[6].eq {
	pc = 0x82EE6E08; continue 'dispatch;
	}
	// 82EE6E04: D1BF00FC  stfs f13, 0xfc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	pc = 0x82EE6E08; continue 'dispatch;
            }
            0x82EE6E08 => {
    //   block [0x82EE6E08..0x82EE6E10)
	// 82EE6E08: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82EE6E0C: 48000074  b 0x82ee6e80
	pc = 0x82EE6E80; continue 'dispatch;
            }
            0x82EE6E10 => {
    //   block [0x82EE6E10..0x82EE6E38)
	// 82EE6E10: C1BF0028  lfs f13, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6E14: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE6E18: 40990064  ble cr6, 0x82ee6e7c
	if !ctx.cr[6].gt {
	pc = 0x82EE6E7C; continue 'dispatch;
	}
	// 82EE6E1C: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EE6E20: 815F0098  lwz r10, 0x98(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82EE6E24: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 82EE6E28: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6E2C: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82EE6E30: 419A0008  beq cr6, 0x82ee6e38
	if ctx.cr[6].eq {
	pc = 0x82EE6E38; continue 'dispatch;
	}
	// 82EE6E34: D1BF00FC  stfs f13, 0xfc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	pc = 0x82EE6E38; continue 'dispatch;
            }
            0x82EE6E38 => {
    //   block [0x82EE6E38..0x82EE6E40)
	// 82EE6E38: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EE6E3C: 48000044  b 0x82ee6e80
	pc = 0x82EE6E80; continue 'dispatch;
            }
            0x82EE6E40 => {
    //   block [0x82EE6E40..0x82EE6E70)
	// 82EE6E40: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EE6E44: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE6E48: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EE6E4C: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6E50: 41820028  beq 0x82ee6e78
	if ctx.cr[0].eq {
	pc = 0x82EE6E78; continue 'dispatch;
	}
	// 82EE6E54: C1BF00E8  lfs f13, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6E58: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE6E5C: 40980020  bge cr6, 0x82ee6e7c
	if !ctx.cr[6].lt {
	pc = 0x82EE6E7C; continue 'dispatch;
	}
	// 82EE6E60: C01F001C  lfs f0, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6E64: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE6E68: 40980008  bge cr6, 0x82ee6e70
	if !ctx.cr[6].lt {
	pc = 0x82EE6E70; continue 'dispatch;
	}
	// 82EE6E6C: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	pc = 0x82EE6E70; continue 'dispatch;
            }
            0x82EE6E70 => {
    //   block [0x82EE6E70..0x82EE6E78)
	// 82EE6E70: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82EE6E74: 4800000C  b 0x82ee6e80
	pc = 0x82EE6E80; continue 'dispatch;
            }
            0x82EE6E78 => {
    //   block [0x82EE6E78..0x82EE6E7C)
	// 82EE6E78: D01F00E8  stfs f0, 0xe8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	pc = 0x82EE6E7C; continue 'dispatch;
            }
            0x82EE6E7C => {
    //   block [0x82EE6E7C..0x82EE6E80)
	// 82EE6E7C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x82EE6E80; continue 'dispatch;
            }
            0x82EE6E80 => {
    //   block [0x82EE6E80..0x82EE6E88)
	// 82EE6E80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE6E84: 4BFFFCF5  bl 0x82ee6b78
	ctx.lr = 0x82EE6E88;
	sub_82EE6B78(ctx, base);
	pc = 0x82EE6E88; continue 'dispatch;
            }
            0x82EE6E88 => {
    //   block [0x82EE6E88..0x82EE6E9C)
	// 82EE6E88: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EE6E8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE6E90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EE6E94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EE6E98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE6EA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE6EA0 size=344
    let mut pc: u32 = 0x82EE6EA0;
    'dispatch: loop {
        match pc {
            0x82EE6EA0 => {
    //   block [0x82EE6EA0..0x82EE6F1C)
	// 82EE6EA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE6EA4: 4BDC2569  bl 0x82ca940c
	ctx.lr = 0x82EE6EA8;
	sub_82CA93D0(ctx, base);
	// 82EE6EA8: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82EE6EAC: 4BDC6E2D  bl 0x82cadcd8
	ctx.lr = 0x82EE6EB0;
	sub_82CADCA0(ctx, base);
	// 82EE6EB0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE6EB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE6EB8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82EE6EBC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE6EC0: C01F00E8  lfs f0, 0xe8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6EC4: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82EE6EC8: C01F0094  lfs f0, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6ECC: C1BF0064  lfs f13, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6ED0: EFC06828  fsubs f30, f0, f13
	ctx.f[30].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE6ED4: C01F008C  lfs f0, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6ED8: C1BF005C  lfs f13, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6EDC: EFA06828  fsubs f29, f0, f13
	ctx.f[29].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE6EE0: C16B0C18  lfs f11, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE6EE4: EC1D0772  fmuls f0, f29, f29
	ctx.f[0].f64 = (((ctx.f[29].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EE6EE8: EC1E07BA  fmadds f0, f30, f30, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE6EEC: EFE0002C  fsqrts f31, f0
	ctx.f[31].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EE6EF0: FF1F5800  fcmpu cr6, f31, f11
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[11].f64);
	// 82EE6EF4: 40990028  ble cr6, 0x82ee6f1c
	if !ctx.cr[6].gt {
	pc = 0x82EE6F1C; continue 'dispatch;
	}
	// 82EE6EF8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE6EFC: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6F00: EC00F824  fdivs f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[31].f64) as f32) as f64;
	// 82EE6F04: EDA00772  fmuls f13, f0, f29
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EE6F08: D1BE0004  stfs f13, 4(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EE6F0C: ED8002F2  fmuls f12, f0, f11
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE6F10: D19E0008  stfs f12, 8(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EE6F14: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EE6F18: 4800001C  b 0x82ee6f34
	pc = 0x82EE6F34; continue 'dispatch;
            }
            0x82EE6F1C => {
    //   block [0x82EE6F1C..0x82EE6F34)
	// 82EE6F1C: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EE6F20: C00B004C  lfs f0, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6F24: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EE6F28: C00B0050  lfs f0, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6F2C: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EE6F30: C00B0054  lfs f0, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82EE6F34; continue 'dispatch;
            }
            0x82EE6F34 => {
    //   block [0x82EE6F34..0x82EE6F88)
	// 82EE6F34: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82EE6F38: D01E000C  stfs f0, 0xc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EE6F3C: 9BBE001C  stb r29, 0x1c(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[29].u8 ) };
	// 82EE6F40: C01F0038  lfs f0, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6F44: 897F0100  lbz r11, 0x100(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 82EE6F48: C39F0044  lfs f28, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EE6F4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE6F50: FF1F5800  fcmpu cr6, f31, f11
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[11].f64);
	// 82EE6F54: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE6F58: 40990088  ble cr6, 0x82ee6fe0
	if !ctx.cr[6].gt {
	pc = 0x82EE6FE0; continue 'dispatch;
	}
	// 82EE6F5C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82EE6F60: 40980080  bge cr6, 0x82ee6fe0
	if !ctx.cr[6].lt {
	pc = 0x82EE6FE0; continue 'dispatch;
	}
	// 82EE6F64: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EE6F68: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EE6F6C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EE6F70: 388BD2C0  addi r4, r11, -0x2d40
	ctx.r[4].s64 = ctx.r[11].s64 + -11584;
	// 82EE6F74: 4B301705  bl 0x821e8678
	ctx.lr = 0x82EE6F78;
	sub_821E8678(ctx, base);
	// 82EE6F78: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE6F7C: 4182000C  beq 0x82ee6f88
	if ctx.cr[0].eq {
	pc = 0x82EE6F88; continue 'dispatch;
	}
	// 82EE6F80: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 82EE6F84: 4800000C  b 0x82ee6f90
	pc = 0x82EE6F90; continue 'dispatch;
            }
            0x82EE6F88 => {
    //   block [0x82EE6F88..0x82EE6F90)
	// 82EE6F88: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EE6F8C: 396B004C  addi r11, r11, 0x4c
	ctx.r[11].s64 = ctx.r[11].s64 + 76;
	pc = 0x82EE6F90; continue 'dispatch;
            }
            0x82EE6F90 => {
    //   block [0x82EE6F90..0x82EE6FE0)
	// 82EE6F90: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6F94: ED9C07F2  fmuls f12, f28, f31
	ctx.f[12].f64 = (((ctx.f[28].f64 * ctx.f[31].f64) as f32) as f64);
	// 82EE6F98: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82EE6F9C: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE6FA0: EC0D07BA  fmadds f0, f13, f30, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE6FA4: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82EE6FA8: 40980038  bge cr6, 0x82ee6fe0
	if !ctx.cr[6].lt {
	pc = 0x82EE6FE0; continue 'dispatch;
	}
	// 82EE6FAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EE6FB0: 389F00B4  addi r4, r31, 0xb4
	ctx.r[4].s64 = ctx.r[31].s64 + 180;
	// 82EE6FB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EE6FB8: 997E001C  stb r11, 0x1c(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 82EE6FBC: 997F0100  stb r11, 0x100(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u8 ) };
	// 82EE6FC0: 4BF9EDA9  bl 0x82e85d68
	ctx.lr = 0x82EE6FC4;
	sub_82E85D68(ctx, base);
	// 82EE6FC4: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6FC8: D01E0010  stfs f0, 0x10(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EE6FCC: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6FD0: D01E0014  stfs f0, 0x14(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EE6FD4: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE6FD8: D01E0018  stfs f0, 0x18(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EE6FDC: 48000008  b 0x82ee6fe4
	pc = 0x82EE6FE4; continue 'dispatch;
            }
            0x82EE6FE0 => {
    //   block [0x82EE6FE0..0x82EE6FE4)
	// 82EE6FE0: 9BBF0100  stb r29, 0x100(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[29].u8 ) };
	pc = 0x82EE6FE4; continue 'dispatch;
            }
            0x82EE6FE4 => {
    //   block [0x82EE6FE4..0x82EE6FF8)
	// 82EE6FE4: 9BBE001D  stb r29, 0x1d(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(29 as u32), ctx.r[29].u8 ) };
	// 82EE6FE8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82EE6FEC: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82EE6FF0: 4BDC6D35  bl 0x82cadd24
	ctx.lr = 0x82EE6FF4;
	sub_82CADCEC(ctx, base);
	// 82EE6FF4: 4BDC2468  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE6FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE6FF8 size=2056
    let mut pc: u32 = 0x82EE6FF8;
    'dispatch: loop {
        match pc {
            0x82EE6FF8 => {
    //   block [0x82EE6FF8..0x82EE7094)
	// 82EE6FF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE6FFC: 4BDC240D  bl 0x82ca9408
	ctx.lr = 0x82EE7000;
	sub_82CA93D0(ctx, base);
	// 82EE7000: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82EE7004: 4BDC6C9D  bl 0x82cadca0
	ctx.lr = 0x82EE7008;
	sub_82CADCA0(ctx, base);
	// 82EE7008: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE700C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE7010: FF600890  fmr f27, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[27].f64 = ctx.f[1].f64;
	// 82EE7014: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82EE7018: FDE01090  fmr f15, f2
	ctx.f[15].f64 = ctx.f[2].f64;
	// 82EE701C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82EE7020: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82EE7024: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 82EE7028: C22B0C18  lfs f17, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[17].f64 = (tmp.f32 as f64);
	// 82EE702C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE7030: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EE7034: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EE7038: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE703C: D23E0004  stfs f17, 4(r30)
	tmp.f32 = (ctx.f[17].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EE7040: D23E0008  stfs f17, 8(r30)
	tmp.f32 = (ctx.f[17].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EE7044: D23E000C  stfs f17, 0xc(r30)
	tmp.f32 = (ctx.f[17].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EE7048: D23E0010  stfs f17, 0x10(r30)
	tmp.f32 = (ctx.f[17].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EE704C: C1AB0BFC  lfs f13, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE7050: D23E0014  stfs f17, 0x14(r30)
	tmp.f32 = (ctx.f[17].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EE7054: D23E0018  stfs f17, 0x18(r30)
	tmp.f32 = (ctx.f[17].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EE7058: D23E001C  stfs f17, 0x1c(r30)
	tmp.f32 = (ctx.f[17].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EE705C: D23E0020  stfs f17, 0x20(r30)
	tmp.f32 = (ctx.f[17].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EE7060: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EE7064: C19F0074  lfs f12, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE7068: C01F001C  lfs f0, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE706C: C17F0014  lfs f11, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE7070: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82EE7074: EEAC5B7A  fmadds f21, f12, f13, f11
	ctx.f[21].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EE7078: C24B0010  lfs f18, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[18].f64 = (tmp.f32 as f64);
	// 82EE707C: FF009000  fcmpu cr6, f0, f18
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[18].f64);
	// 82EE7080: 40980014  bge cr6, 0x82ee7094
	if !ctx.cr[6].lt {
	pc = 0x82EE7094; continue 'dispatch;
	}
	// 82EE7084: EC00902A  fadds f0, f0, f18
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[18].f64) as f32) as f64;
	// 82EE7088: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE708C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82EE7090: 48000008  b 0x82ee7098
	pc = 0x82EE7098; continue 'dispatch;
            }
            0x82EE7094 => {
    //   block [0x82EE7094..0x82EE7098)
	// 82EE7094: D2410054  stfs f18, 0x54(r1)
	tmp.f32 = (ctx.f[18].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	pc = 0x82EE7098; continue 'dispatch;
            }
            0x82EE7098 => {
    //   block [0x82EE7098..0x82EE70B4)
	// 82EE7098: FF1B8800  fcmpu cr6, f27, f17
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[17].f64);
	// 82EE709C: 409A0018  bne cr6, 0x82ee70b4
	if !ctx.cr[6].eq {
	pc = 0x82EE70B4; continue 'dispatch;
	}
	// 82EE70A0: C01F00C8  lfs f0, 0xc8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE70A4: C1BF0108  lfs f13, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE70A8: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE70AC: FF0F6800  fcmpu cr6, f15, f13
	ctx.cr[6].compare_f64(ctx.f[15].f64, ctx.f[13].f64);
	// 82EE70B0: 41990008  bgt cr6, 0x82ee70b8
	if ctx.cr[6].gt {
	pc = 0x82EE70B8; continue 'dispatch;
	}
	pc = 0x82EE70B4; continue 'dispatch;
            }
            0x82EE70B4 => {
    //   block [0x82EE70B4..0x82EE70B8)
	// 82EE70B4: EC12ABF8  fmsubs f0, f18, f15, f21
	ctx.f[0].f64 = (((ctx.f[18].f64 * ctx.f[15].f64 - ctx.f[21].f64) as f32) as f64);
	pc = 0x82EE70B8; continue 'dispatch;
            }
            0x82EE70B8 => {
    //   block [0x82EE70B8..0x82EE70D0)
	// 82EE70B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE70BC: C1AB0A7C  lfs f13, 0xa7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2684 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE70C0: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE70C4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE70C8: 40980008  bge cr6, 0x82ee70d0
	if !ctx.cr[6].lt {
	pc = 0x82EE70D0; continue 'dispatch;
	}
	// 82EE70CC: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EE70D0; continue 'dispatch;
            }
            0x82EE70D0 => {
    //   block [0x82EE70D0..0x82EE71B4)
	// 82EE70D0: C1BF00A4  lfs f13, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE70D4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82EE70D8: C17F00BC  lfs f11, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE70DC: EDAD06F2  fmuls f13, f13, f27
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EE70E0: C19F00A0  lfs f12, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE70E4: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE70E8: C15F00B8  lfs f10, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE70EC: ED8C06F2  fmuls f12, f12, f27
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EE70F0: C13F009C  lfs f9, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE70F4: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE70F8: C11F00B4  lfs f8, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE70FC: ED2906F2  fmuls f9, f9, f27
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EE7100: ED080032  fmuls f8, f8, f0
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE7104: C0FF0064  lfs f7, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EE7108: C0DF0060  lfs f6, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EE710C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EE7110: C0BF005C  lfs f5, 0x5c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82EE7114: EC0B682A  fadds f0, f11, f13
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE7118: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82EE711C: EDAA602A  fadds f13, f10, f12
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EE7120: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82EE7124: ED88482A  fadds f12, f8, f9
	ctx.f[12].f64 = ((ctx.f[8].f64 + ctx.f[9].f64) as f32) as f64;
	// 82EE7128: D1810060  stfs f12, 0x60(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82EE712C: ED67002A  fadds f11, f7, f0
	ctx.f[11].f64 = ((ctx.f[7].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EE7130: D17E000C  stfs f11, 0xc(r30)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EE7134: ED46682A  fadds f10, f6, f13
	ctx.f[10].f64 = ((ctx.f[6].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE7138: D15E0008  stfs f10, 8(r30)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EE713C: ED85602A  fadds f12, f5, f12
	ctx.f[12].f64 = ((ctx.f[5].f64 + ctx.f[12].f64) as f32) as f64;
	// 82EE7140: D19E0004  stfs f12, 4(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EE7144: D37E0014  stfs f27, 0x14(r30)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EE7148: 4B398121  bl 0x8227f268
	ctx.lr = 0x82EE714C;
	sub_8227F268(ctx, base);
	// 82EE714C: 815F0058  lwz r10, 0x58(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EE7150: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE7154: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE7158: C01F00C0  lfs f0, 0xc0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE715C: C1830008  lfs f12, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE7160: FCC00090  fmr f6, f0
	ctx.f[6].f64 = ctx.f[0].f64;
	// 82EE7164: FEE00090  fmr f23, f0
	ctx.f[23].f64 = ctx.f[0].f64;
	// 82EE7168: C1BF0040  lfs f13, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE716C: FEC00090  fmr f22, f0
	ctx.f[22].f64 = ctx.f[0].f64;
	// 82EE7170: C1630000  lfs f11, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE7174: C14A0054  lfs f10, 0x54(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(84 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE7178: ECF5D82A  fadds f7, f21, f27
	ctx.f[7].f64 = ((ctx.f[21].f64 + ctx.f[27].f64) as f32) as f64;
	// 82EE717C: EC0C02B2  fmuls f0, f12, f10
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[10].f64) as f32) as f64);
	// 82EE7180: C34B0BEC  lfs f26, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82EE7184: C12A004C  lfs f9, 0x4c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(76 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE7188: EDDBA828  fsubs f14, f27, f21
	ctx.f[14].f64 = (((ctx.f[27].f64 - ctx.f[21].f64) as f32) as f64);
	// 82EE718C: D0E1005C  stfs f7, 0x5c(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82EE7190: FD008890  fmr f8, f17
	ctx.f[8].f64 = ctx.f[17].f64;
	// 82EE7194: D0C10050  stfs f6, 0x50(r1)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82EE7198: FE80D090  fmr f20, f26
	ctx.f[20].f64 = ctx.f[26].f64;
	// 82EE719C: FE60D090  fmr f19, f26
	ctx.f[19].f64 = ctx.f[26].f64;
	// 82EE71A0: FF806850  fneg f28, f13
	ctx.f[28].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE71A4: FFC06890  fmr f30, f13
	ctx.f[30].f64 = ctx.f[13].f64;
	// 82EE71A8: EE0B027A  fmadds f16, f11, f9, f0
	ctx.f[16].f64 = (((ctx.f[11].f64 * ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE71AC: 7D2B4B79  or. r11, r9, r9
	ctx.r[11].u64 = ctx.r[9].u64 | ctx.r[9].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE71B0: 418200E4  beq 0x82ee7294
	if ctx.cr[0].eq {
	pc = 0x82EE7294; continue 'dispatch;
	}
	pc = 0x82EE71B4; continue 'dispatch;
            }
            0x82EE71B4 => {
    //   block [0x82EE71B4..0x82EE71E8)
	// 82EE71B4: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE71B8: FF0D3800  fcmpu cr6, f13, f7
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[7].f64);
	// 82EE71BC: 419900D8  bgt cr6, 0x82ee7294
	if ctx.cr[6].gt {
	pc = 0x82EE7294; continue 'dispatch;
	}
	// 82EE71C0: FF0DD800  fcmpu cr6, f13, f27
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[27].f64);
	// 82EE71C4: 40980034  bge cr6, 0x82ee71f8
	if !ctx.cr[6].lt {
	pc = 0x82EE71F8; continue 'dispatch;
	}
	// 82EE71C8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE71CC: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EE71D0: 40990028  ble cr6, 0x82ee71f8
	if !ctx.cr[6].gt {
	pc = 0x82EE71F8; continue 'dispatch;
	}
	// 82EE71D4: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE71D8: FF003000  fcmpu cr6, f0, f6
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[6].f64);
	// 82EE71DC: 4098000C  bge cr6, 0x82ee71e8
	if !ctx.cr[6].lt {
	pc = 0x82EE71E8; continue 'dispatch;
	}
	// 82EE71E0: FCC00090  fmr f6, f0
	ctx.f[6].f64 = ctx.f[0].f64;
	// 82EE71E4: D0C10050  stfs f6, 0x50(r1)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	pc = 0x82EE71E8; continue 'dispatch;
            }
            0x82EE71E8 => {
    //   block [0x82EE71E8..0x82EE71F8)
	// 82EE71E8: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE71EC: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82EE71F0: 40980008  bge cr6, 0x82ee71f8
	if !ctx.cr[6].lt {
	pc = 0x82EE71F8; continue 'dispatch;
	}
	// 82EE71F4: FF400090  fmr f26, f0
	ctx.f[26].f64 = ctx.f[0].f64;
	pc = 0x82EE71F8; continue 'dispatch;
            }
            0x82EE71F8 => {
    //   block [0x82EE71F8..0x82EE7214)
	// 82EE71F8: FF0DD800  fcmpu cr6, f13, f27
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[27].f64);
	// 82EE71FC: 4099002C  ble cr6, 0x82ee7228
	if !ctx.cr[6].gt {
	pc = 0x82EE7228; continue 'dispatch;
	}
	// 82EE7200: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7204: FF00B000  fcmpu cr6, f0, f22
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[22].f64);
	// 82EE7208: 4098000C  bge cr6, 0x82ee7214
	if !ctx.cr[6].lt {
	pc = 0x82EE7214; continue 'dispatch;
	}
	// 82EE720C: FEC00090  fmr f22, f0
	ctx.f[22].f64 = ctx.f[0].f64;
	// 82EE7210: FFC06890  fmr f30, f13
	ctx.f[30].f64 = ctx.f[13].f64;
	pc = 0x82EE7214; continue 'dispatch;
            }
            0x82EE7214 => {
    //   block [0x82EE7214..0x82EE7228)
	// 82EE7214: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7218: FF009800  fcmpu cr6, f0, f19
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[19].f64);
	// 82EE721C: 4098003C  bge cr6, 0x82ee7258
	if !ctx.cr[6].lt {
	pc = 0x82EE7258; continue 'dispatch;
	}
	// 82EE7220: FE600090  fmr f19, f0
	ctx.f[19].f64 = ctx.f[0].f64;
	// 82EE7224: 48000034  b 0x82ee7258
	pc = 0x82EE7258; continue 'dispatch;
            }
            0x82EE7228 => {
    //   block [0x82EE7228..0x82EE7248)
	// 82EE7228: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE722C: FF0CD800  fcmpu cr6, f12, f27
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[27].f64);
	// 82EE7230: 40980028  bge cr6, 0x82ee7258
	if !ctx.cr[6].lt {
	pc = 0x82EE7258; continue 'dispatch;
	}
	// 82EE7234: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7238: FF00B800  fcmpu cr6, f0, f23
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[23].f64);
	// 82EE723C: 4098000C  bge cr6, 0x82ee7248
	if !ctx.cr[6].lt {
	pc = 0x82EE7248; continue 'dispatch;
	}
	// 82EE7240: FEE00090  fmr f23, f0
	ctx.f[23].f64 = ctx.f[0].f64;
	// 82EE7244: FF806090  fmr f28, f12
	ctx.f[28].f64 = ctx.f[12].f64;
	pc = 0x82EE7248; continue 'dispatch;
            }
            0x82EE7248 => {
    //   block [0x82EE7248..0x82EE7258)
	// 82EE7248: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE724C: FF00A000  fcmpu cr6, f0, f20
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[20].f64);
	// 82EE7250: 40980008  bge cr6, 0x82ee7258
	if !ctx.cr[6].lt {
	pc = 0x82EE7258; continue 'dispatch;
	}
	// 82EE7254: FE800090  fmr f20, f0
	ctx.f[20].f64 = ctx.f[0].f64;
	pc = 0x82EE7258; continue 'dispatch;
            }
            0x82EE7258 => {
    //   block [0x82EE7258..0x82EE726C)
	// 82EE7258: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE725C: FF003800  fcmpu cr6, f0, f7
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[7].f64);
	// 82EE7260: 4098000C  bge cr6, 0x82ee726c
	if !ctx.cr[6].lt {
	pc = 0x82EE726C; continue 'dispatch;
	}
	// 82EE7264: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	// 82EE7268: 48000008  b 0x82ee7270
	pc = 0x82EE7270; continue 'dispatch;
            }
            0x82EE726C => {
    //   block [0x82EE726C..0x82EE7270)
	// 82EE726C: FD803890  fmr f12, f7
	ctx.f[12].f64 = ctx.f[7].f64;
	pc = 0x82EE7270; continue 'dispatch;
            }
            0x82EE7270 => {
    //   block [0x82EE7270..0x82EE727C)
	// 82EE7270: FF0D7000  fcmpu cr6, f13, f14
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[14].f64);
	// 82EE7274: 41990008  bgt cr6, 0x82ee727c
	if ctx.cr[6].gt {
	pc = 0x82EE727C; continue 'dispatch;
	}
	// 82EE7278: FDA07090  fmr f13, f14
	ctx.f[13].f64 = ctx.f[14].f64;
	pc = 0x82EE727C; continue 'dispatch;
            }
            0x82EE727C => {
    //   block [0x82EE727C..0x82EE7294)
	// 82EE727C: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE7280: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7284: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EE7288: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE728C: ED0D403A  fmadds f8, f13, f0, f8
	ctx.f[8].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 82EE7290: 4082FF24  bne 0x82ee71b4
	if !ctx.cr[0].eq {
	pc = 0x82EE71B4; continue 'dispatch;
	}
	pc = 0x82EE7294; continue 'dispatch;
            }
            0x82EE7294 => {
    //   block [0x82EE7294..0x82EE729C)
	// 82EE7294: 8169001C  lwz r11, 0x1c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE7298: 480000CC  b 0x82ee7364
	pc = 0x82EE7364; continue 'dispatch;
            }
            0x82EE729C => {
    //   block [0x82EE729C..0x82EE72D0)
	// 82EE729C: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE72A0: FF0C7000  fcmpu cr6, f12, f14
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[14].f64);
	// 82EE72A4: 419800C8  blt cr6, 0x82ee736c
	if ctx.cr[6].lt {
	pc = 0x82EE736C; continue 'dispatch;
	}
	// 82EE72A8: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE72AC: FF0DD800  fcmpu cr6, f13, f27
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[27].f64);
	// 82EE72B0: 40980030  bge cr6, 0x82ee72e0
	if !ctx.cr[6].lt {
	pc = 0x82EE72E0; continue 'dispatch;
	}
	// 82EE72B4: FF0CD800  fcmpu cr6, f12, f27
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[27].f64);
	// 82EE72B8: 40990028  ble cr6, 0x82ee72e0
	if !ctx.cr[6].gt {
	pc = 0x82EE72E0; continue 'dispatch;
	}
	// 82EE72BC: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE72C0: FF003000  fcmpu cr6, f0, f6
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[6].f64);
	// 82EE72C4: 4098000C  bge cr6, 0x82ee72d0
	if !ctx.cr[6].lt {
	pc = 0x82EE72D0; continue 'dispatch;
	}
	// 82EE72C8: FCC00090  fmr f6, f0
	ctx.f[6].f64 = ctx.f[0].f64;
	// 82EE72CC: D0C10050  stfs f6, 0x50(r1)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	pc = 0x82EE72D0; continue 'dispatch;
            }
            0x82EE72D0 => {
    //   block [0x82EE72D0..0x82EE72E0)
	// 82EE72D0: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE72D4: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82EE72D8: 40980008  bge cr6, 0x82ee72e0
	if !ctx.cr[6].lt {
	pc = 0x82EE72E0; continue 'dispatch;
	}
	// 82EE72DC: FF400090  fmr f26, f0
	ctx.f[26].f64 = ctx.f[0].f64;
	pc = 0x82EE72E0; continue 'dispatch;
            }
            0x82EE72E0 => {
    //   block [0x82EE72E0..0x82EE72FC)
	// 82EE72E0: FF0DD800  fcmpu cr6, f13, f27
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[27].f64);
	// 82EE72E4: 4099002C  ble cr6, 0x82ee7310
	if !ctx.cr[6].gt {
	pc = 0x82EE7310; continue 'dispatch;
	}
	// 82EE72E8: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE72EC: FF00B000  fcmpu cr6, f0, f22
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[22].f64);
	// 82EE72F0: 4098000C  bge cr6, 0x82ee72fc
	if !ctx.cr[6].lt {
	pc = 0x82EE72FC; continue 'dispatch;
	}
	// 82EE72F4: FEC00090  fmr f22, f0
	ctx.f[22].f64 = ctx.f[0].f64;
	// 82EE72F8: FFC06890  fmr f30, f13
	ctx.f[30].f64 = ctx.f[13].f64;
	pc = 0x82EE72FC; continue 'dispatch;
            }
            0x82EE72FC => {
    //   block [0x82EE72FC..0x82EE7310)
	// 82EE72FC: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7300: FF009800  fcmpu cr6, f0, f19
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[19].f64);
	// 82EE7304: 40980038  bge cr6, 0x82ee733c
	if !ctx.cr[6].lt {
	pc = 0x82EE733C; continue 'dispatch;
	}
	// 82EE7308: FE600090  fmr f19, f0
	ctx.f[19].f64 = ctx.f[0].f64;
	// 82EE730C: 48000030  b 0x82ee733c
	pc = 0x82EE733C; continue 'dispatch;
            }
            0x82EE7310 => {
    //   block [0x82EE7310..0x82EE732C)
	// 82EE7310: FF0CD800  fcmpu cr6, f12, f27
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[27].f64);
	// 82EE7314: 40980028  bge cr6, 0x82ee733c
	if !ctx.cr[6].lt {
	pc = 0x82EE733C; continue 'dispatch;
	}
	// 82EE7318: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE731C: FF00B800  fcmpu cr6, f0, f23
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[23].f64);
	// 82EE7320: 4098000C  bge cr6, 0x82ee732c
	if !ctx.cr[6].lt {
	pc = 0x82EE732C; continue 'dispatch;
	}
	// 82EE7324: FEE00090  fmr f23, f0
	ctx.f[23].f64 = ctx.f[0].f64;
	// 82EE7328: FF806090  fmr f28, f12
	ctx.f[28].f64 = ctx.f[12].f64;
	pc = 0x82EE732C; continue 'dispatch;
            }
            0x82EE732C => {
    //   block [0x82EE732C..0x82EE733C)
	// 82EE732C: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7330: FF00A000  fcmpu cr6, f0, f20
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[20].f64);
	// 82EE7334: 40980008  bge cr6, 0x82ee733c
	if !ctx.cr[6].lt {
	pc = 0x82EE733C; continue 'dispatch;
	}
	// 82EE7338: FE800090  fmr f20, f0
	ctx.f[20].f64 = ctx.f[0].f64;
	pc = 0x82EE733C; continue 'dispatch;
            }
            0x82EE733C => {
    //   block [0x82EE733C..0x82EE7348)
	// 82EE733C: FF0C3800  fcmpu cr6, f12, f7
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[7].f64);
	// 82EE7340: 41980008  blt cr6, 0x82ee7348
	if ctx.cr[6].lt {
	pc = 0x82EE7348; continue 'dispatch;
	}
	// 82EE7344: FD803890  fmr f12, f7
	ctx.f[12].f64 = ctx.f[7].f64;
	pc = 0x82EE7348; continue 'dispatch;
            }
            0x82EE7348 => {
    //   block [0x82EE7348..0x82EE7354)
	// 82EE7348: FF0D7000  fcmpu cr6, f13, f14
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[14].f64);
	// 82EE734C: 41990008  bgt cr6, 0x82ee7354
	if ctx.cr[6].gt {
	pc = 0x82EE7354; continue 'dispatch;
	}
	// 82EE7350: FDA07090  fmr f13, f14
	ctx.f[13].f64 = ctx.f[14].f64;
	pc = 0x82EE7354; continue 'dispatch;
            }
            0x82EE7354 => {
    //   block [0x82EE7354..0x82EE7364)
	// 82EE7354: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE7358: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE735C: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE7360: ED0D403A  fmadds f8, f13, f0, f8
	ctx.f[8].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	pc = 0x82EE7364; continue 'dispatch;
            }
            0x82EE7364 => {
    //   block [0x82EE7364..0x82EE736C)
	// 82EE7364: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE7368: 4082FF34  bne 0x82ee729c
	if !ctx.cr[0].eq {
	pc = 0x82EE729C; continue 'dispatch;
	}
	pc = 0x82EE736C; continue 'dispatch;
            }
            0x82EE736C => {
    //   block [0x82EE736C..0x82EE737C)
	// 82EE736C: C01F010C  lfs f0, 0x10c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7370: FF060000  fcmpu cr6, f6, f0
	ctx.cr[6].compare_f64(ctx.f[6].f64, ctx.f[0].f64);
	// 82EE7374: 40980008  bge cr6, 0x82ee737c
	if !ctx.cr[6].lt {
	pc = 0x82EE737C; continue 'dispatch;
	}
	// 82EE7378: D2210050  stfs f17, 0x50(r1)
	tmp.f32 = (ctx.f[17].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	pc = 0x82EE737C; continue 'dispatch;
            }
            0x82EE737C => {
    //   block [0x82EE737C..0x82EE7388)
	// 82EE737C: FF160000  fcmpu cr6, f22, f0
	ctx.cr[6].compare_f64(ctx.f[22].f64, ctx.f[0].f64);
	// 82EE7380: 40980008  bge cr6, 0x82ee7388
	if !ctx.cr[6].lt {
	pc = 0x82EE7388; continue 'dispatch;
	}
	// 82EE7384: FEC08890  fmr f22, f17
	ctx.f[22].f64 = ctx.f[17].f64;
	pc = 0x82EE7388; continue 'dispatch;
            }
            0x82EE7388 => {
    //   block [0x82EE7388..0x82EE7394)
	// 82EE7388: FF170000  fcmpu cr6, f23, f0
	ctx.cr[6].compare_f64(ctx.f[23].f64, ctx.f[0].f64);
	// 82EE738C: 40980008  bge cr6, 0x82ee7394
	if !ctx.cr[6].lt {
	pc = 0x82EE7394; continue 'dispatch;
	}
	// 82EE7390: FEE08890  fmr f23, f17
	ctx.f[23].f64 = ctx.f[17].f64;
	pc = 0x82EE7394; continue 'dispatch;
            }
            0x82EE7394 => {
    //   block [0x82EE7394..0x82EE73FC)
	// 82EE7394: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE7398: C0410050  lfs f2, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EE739C: FC60D090  fmr f3, f26
	ctx.f[3].f64 = ctx.f[26].f64;
	// 82EE73A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE73A4: FC209090  fmr f1, f18
	ctx.f[1].f64 = ctx.f[18].f64;
	// 82EE73A8: C32B0C4C  lfs f25, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82EE73AC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE73B0: EC150672  fmuls f0, f21, f25
	ctx.f[0].f64 = (((ctx.f[21].f64 * ctx.f[25].f64) as f32) as f64);
	// 82EE73B4: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EE73B8: EF080024  fdivs f24, f8, f0
	ctx.f[24].f64 = ((ctx.f[8].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EE73BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE73C0: 4E800421  bctrl
	ctx.lr = 0x82EE73C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE73C4: EFBED828  fsubs f29, f30, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = (((ctx.f[30].f64 - ctx.f[27].f64) as f32) as f64);
	// 82EE73C8: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82EE73CC: FF1DA800  fcmpu cr6, f29, f21
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[21].f64);
	// 82EE73D0: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 82EE73D4: 40980028  bge cr6, 0x82ee73fc
	if !ctx.cr[6].lt {
	pc = 0x82EE73FC; continue 'dispatch;
	}
	// 82EE73D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE73DC: FC609890  fmr f3, f19
	ctx.f[3].f64 = ctx.f[19].f64;
	// 82EE73E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE73E4: FC40B090  fmr f2, f22
	ctx.f[2].f64 = ctx.f[22].f64;
	// 82EE73E8: FC209090  fmr f1, f18
	ctx.f[1].f64 = ctx.f[18].f64;
	// 82EE73EC: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EE73F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE73F4: 4E800421  bctrl
	ctx.lr = 0x82EE73F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE73F8: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
            }
            0x82EE73FC => {
    //   block [0x82EE73FC..0x82EE742C)
	// 82EE73FC: EF9BE028  fsubs f28, f27, f28
	ctx.f[28].f64 = (((ctx.f[27].f64 - ctx.f[28].f64) as f32) as f64);
	// 82EE7400: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EE7404: FF1CA800  fcmpu cr6, f28, f21
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[21].f64);
	// 82EE7408: 40980024  bge cr6, 0x82ee742c
	if !ctx.cr[6].lt {
	pc = 0x82EE742C; continue 'dispatch;
	}
	// 82EE740C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE7410: FC60A090  fmr f3, f20
	ctx.f[3].f64 = ctx.f[20].f64;
	// 82EE7414: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE7418: FC40B890  fmr f2, f23
	ctx.f[2].f64 = ctx.f[23].f64;
	// 82EE741C: FC209090  fmr f1, f18
	ctx.f[1].f64 = ctx.f[18].f64;
	// 82EE7420: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82EE7424: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE7428: 4E800421  bctrl
	ctx.lr = 0x82EE742C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82EE742C => {
    //   block [0x82EE742C..0x82EE744C)
	// 82EE742C: FF1EF800  fcmpu cr6, f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 82EE7430: 40980038  bge cr6, 0x82ee7468
	if !ctx.cr[6].lt {
	pc = 0x82EE7468; continue 'dispatch;
	}
	// 82EE7434: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 82EE7438: 40980018  bge cr6, 0x82ee7450
	if !ctx.cr[6].lt {
	pc = 0x82EE7450; continue 'dispatch;
	}
	// 82EE743C: FF1E0800  fcmpu cr6, f30, f1
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[1].f64);
	// 82EE7440: 4099000C  ble cr6, 0x82ee744c
	if !ctx.cr[6].gt {
	pc = 0x82EE744C; continue 'dispatch;
	}
	// 82EE7444: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	// 82EE7448: 48000008  b 0x82ee7450
	pc = 0x82EE7450; continue 'dispatch;
            }
            0x82EE744C => {
    //   block [0x82EE744C..0x82EE7450)
	// 82EE744C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	pc = 0x82EE7450; continue 'dispatch;
            }
            0x82EE7450 => {
    //   block [0x82EE7450..0x82EE7468)
	// 82EE7450: FF1EF800  fcmpu cr6, f30, f31
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 82EE7454: 40980014  bge cr6, 0x82ee7468
	if !ctx.cr[6].lt {
	pc = 0x82EE7468; continue 'dispatch;
	}
	// 82EE7458: EC1FF028  fsubs f0, f31, f30
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[30].f64) as f32) as f64);
	// 82EE745C: EC00A824  fdivs f0, f0, f21
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[21].f64) as f32) as f64;
	// 82EE7460: EC00F77A  fmadds f0, f0, f29, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64 + ctx.f[30].f64) as f32) as f64);
	// 82EE7464: 48000008  b 0x82ee746c
	pc = 0x82EE746C; continue 'dispatch;
            }
            0x82EE7468 => {
    //   block [0x82EE7468..0x82EE746C)
	// 82EE7468: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x82EE746C; continue 'dispatch;
            }
            0x82EE746C => {
    //   block [0x82EE746C..0x82EE7480)
	// 82EE746C: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 82EE7470: 40980010  bge cr6, 0x82ee7480
	if !ctx.cr[6].lt {
	pc = 0x82EE7480; continue 'dispatch;
	}
	// 82EE7474: EDBF0828  fsubs f13, f31, f1
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 82EE7478: EDADA824  fdivs f13, f13, f21
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[21].f64) as f32) as f64;
	// 82EE747C: EFED0F3A  fmadds f31, f13, f28, f1
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[28].f64 + ctx.f[1].f64) as f32) as f64);
	pc = 0x82EE7480; continue 'dispatch;
            }
            0x82EE7480 => {
    //   block [0x82EE7480..0x82EE748C)
	// 82EE7480: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82EE7484: 41980008  blt cr6, 0x82ee748c
	if ctx.cr[6].lt {
	pc = 0x82EE748C; continue 'dispatch;
	}
	// 82EE7488: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	pc = 0x82EE748C; continue 'dispatch;
            }
            0x82EE748C => {
    //   block [0x82EE748C..0x82EE74E4)
	// 82EE748C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE7490: D3FE0018  stfs f31, 0x18(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EE7494: C01F00C0  lfs f0, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7498: C0210058  lfs f1, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EE749C: FF0F0000  fcmpu cr6, f15, f0
	ctx.cr[6].compare_f64(ctx.f[15].f64, ctx.f[0].f64);
	// 82EE74A0: C0410054  lfs f2, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82EE74A4: C06B0C14  lfs f3, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82EE74A8: 40980054  bge cr6, 0x82ee74fc
	if !ctx.cr[6].lt {
	pc = 0x82EE74FC; continue 'dispatch;
	}
	// 82EE74AC: EC10182A  fadds f0, f16, f3
	ctx.f[0].f64 = ((ctx.f[16].f64 + ctx.f[3].f64) as f32) as f64;
	// 82EE74B0: C1BF010C  lfs f13, 0x10c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE74B4: EDB26BF8  fmsubs f13, f18, f15, f13
	ctx.f[13].f64 = (((ctx.f[18].f64 * ctx.f[15].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE74B8: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 82EE74BC: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE74C0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE74C4: FF008800  fcmpu cr6, f0, f17
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[17].f64);
	// 82EE74C8: 4099001C  ble cr6, 0x82ee74e4
	if !ctx.cr[6].gt {
	pc = 0x82EE74E4; continue 'dispatch;
	}
	// 82EE74CC: C1BF0034  lfs f13, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE74D0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82EE74D4: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE74D8: C00BE28C  lfs f0, -0x1d74(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7540 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE74DC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE74E0: 48000010  b 0x82ee74f0
	pc = 0x82EE74F0; continue 'dispatch;
            }
            0x82EE74E4 => {
    //   block [0x82EE74E4..0x82EE74F0)
	// 82EE74E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE74E8: C00B0BF8  lfs f0, 0xbf8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3064 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE74EC: EC020032  fmuls f0, f2, f0
	ctx.f[0].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x82EE74F0; continue 'dispatch;
            }
            0x82EE74F0 => {
    //   block [0x82EE74F0..0x82EE74FC)
	// 82EE74F0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82EE74F4: 40980008  bge cr6, 0x82ee74fc
	if !ctx.cr[6].lt {
	pc = 0x82EE74FC; continue 'dispatch;
	}
	// 82EE74F8: D01E0018  stfs f0, 0x18(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), tmp.u32 ) };
	pc = 0x82EE74FC; continue 'dispatch;
            }
            0x82EE74FC => {
    //   block [0x82EE74FC..0x82EE750C)
	// 82EE74FC: FF17B000  fcmpu cr6, f23, f22
	ctx.cr[6].compare_f64(ctx.f[23].f64, ctx.f[22].f64);
	// 82EE7500: 4098000C  bge cr6, 0x82ee750c
	if !ctx.cr[6].lt {
	pc = 0x82EE750C; continue 'dispatch;
	}
	// 82EE7504: FC00B890  fmr f0, f23
	ctx.f[0].f64 = ctx.f[23].f64;
	// 82EE7508: 48000008  b 0x82ee7510
	pc = 0x82EE7510; continue 'dispatch;
            }
            0x82EE750C => {
    //   block [0x82EE750C..0x82EE7510)
	// 82EE750C: FC00B090  fmr f0, f22
	ctx.f[0].f64 = ctx.f[22].f64;
	pc = 0x82EE7510; continue 'dispatch;
            }
            0x82EE7510 => {
    //   block [0x82EE7510..0x82EE7524)
	// 82EE7510: C3E10050  lfs f31, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EE7514: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82EE7518: 4098000C  bge cr6, 0x82ee7524
	if !ctx.cr[6].lt {
	pc = 0x82EE7524; continue 'dispatch;
	}
	// 82EE751C: FC80F890  fmr f4, f31
	ctx.f[4].f64 = ctx.f[31].f64;
	// 82EE7520: 48000018  b 0x82ee7538
	pc = 0x82EE7538; continue 'dispatch;
            }
            0x82EE7524 => {
    //   block [0x82EE7524..0x82EE7534)
	// 82EE7524: FF17B000  fcmpu cr6, f23, f22
	ctx.cr[6].compare_f64(ctx.f[23].f64, ctx.f[22].f64);
	// 82EE7528: 4098000C  bge cr6, 0x82ee7534
	if !ctx.cr[6].lt {
	pc = 0x82EE7534; continue 'dispatch;
	}
	// 82EE752C: FC80B890  fmr f4, f23
	ctx.f[4].f64 = ctx.f[23].f64;
	// 82EE7530: 48000008  b 0x82ee7538
	pc = 0x82EE7538; continue 'dispatch;
            }
            0x82EE7534 => {
    //   block [0x82EE7534..0x82EE7538)
	// 82EE7534: FC80B090  fmr f4, f22
	ctx.f[4].f64 = ctx.f[22].f64;
	pc = 0x82EE7538; continue 'dispatch;
            }
            0x82EE7538 => {
    //   block [0x82EE7538..0x82EE7548)
	// 82EE7538: FF149800  fcmpu cr6, f20, f19
	ctx.cr[6].compare_f64(ctx.f[20].f64, ctx.f[19].f64);
	// 82EE753C: 4098000C  bge cr6, 0x82ee7548
	if !ctx.cr[6].lt {
	pc = 0x82EE7548; continue 'dispatch;
	}
	// 82EE7540: FC00A090  fmr f0, f20
	ctx.f[0].f64 = ctx.f[20].f64;
	// 82EE7544: 48000008  b 0x82ee754c
	pc = 0x82EE754C; continue 'dispatch;
            }
            0x82EE7548 => {
    //   block [0x82EE7548..0x82EE754C)
	// 82EE7548: FC009890  fmr f0, f19
	ctx.f[0].f64 = ctx.f[19].f64;
	pc = 0x82EE754C; continue 'dispatch;
            }
            0x82EE754C => {
    //   block [0x82EE754C..0x82EE755C)
	// 82EE754C: FF1A0000  fcmpu cr6, f26, f0
	ctx.cr[6].compare_f64(ctx.f[26].f64, ctx.f[0].f64);
	// 82EE7550: 4098000C  bge cr6, 0x82ee755c
	if !ctx.cr[6].lt {
	pc = 0x82EE755C; continue 'dispatch;
	}
	// 82EE7554: FCA0D090  fmr f5, f26
	ctx.f[5].f64 = ctx.f[26].f64;
	// 82EE7558: 48000018  b 0x82ee7570
	pc = 0x82EE7570; continue 'dispatch;
            }
            0x82EE755C => {
    //   block [0x82EE755C..0x82EE756C)
	// 82EE755C: FF149800  fcmpu cr6, f20, f19
	ctx.cr[6].compare_f64(ctx.f[20].f64, ctx.f[19].f64);
	// 82EE7560: 4098000C  bge cr6, 0x82ee756c
	if !ctx.cr[6].lt {
	pc = 0x82EE756C; continue 'dispatch;
	}
	// 82EE7564: FCA0A090  fmr f5, f20
	ctx.f[5].f64 = ctx.f[20].f64;
	// 82EE7568: 48000008  b 0x82ee7570
	pc = 0x82EE7570; continue 'dispatch;
            }
            0x82EE756C => {
    //   block [0x82EE756C..0x82EE7570)
	// 82EE756C: FCA09890  fmr f5, f19
	ctx.f[5].f64 = ctx.f[19].f64;
	pc = 0x82EE7570; continue 'dispatch;
            }
            0x82EE7570 => {
    //   block [0x82EE7570..0x82EE75A0)
	// 82EE7570: EC04C02A  fadds f0, f4, f24
	ctx.f[0].f64 = ((ctx.f[4].f64 + ctx.f[24].f64) as f32) as f64;
	// 82EE7574: D0BE0020  stfs f5, 0x20(r30)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EE7578: FF1B8800  fcmpu cr6, f27, f17
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[17].f64);
	// 82EE757C: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 82EE7580: D01E001C  stfs f0, 0x1c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EE7584: 409A0020  bne cr6, 0x82ee75a4
	if !ctx.cr[6].eq {
	pc = 0x82EE75A4; continue 'dispatch;
	}
	// 82EE7588: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EE758C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE7590: 41820010  beq 0x82ee75a0
	if ctx.cr[0].eq {
	pc = 0x82EE75A0; continue 'dispatch;
	}
	// 82EE7594: C01E0018  lfs f0, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7598: FF001000  fcmpu cr6, f0, f2
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[2].f64);
	// 82EE759C: 40980008  bge cr6, 0x82ee75a4
	if !ctx.cr[6].lt {
	pc = 0x82EE75A4; continue 'dispatch;
	}
	pc = 0x82EE75A0; continue 'dispatch;
            }
            0x82EE75A0 => {
    //   block [0x82EE75A0..0x82EE75A4)
	// 82EE75A0: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	pc = 0x82EE75A4; continue 'dispatch;
            }
            0x82EE75A4 => {
    //   block [0x82EE75A4..0x82EE75BC)
	// 82EE75A4: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE75A8: 41820014  beq 0x82ee75bc
	if ctx.cr[0].eq {
	pc = 0x82EE75BC; continue 'dispatch;
	}
	// 82EE75AC: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE75B0: C1BF0074  lfs f13, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE75B4: EC006E7A  fmadds f0, f0, f25, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[25].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE75B8: 48000008  b 0x82ee75c0
	pc = 0x82EE75C0; continue 'dispatch;
            }
            0x82EE75BC => {
    //   block [0x82EE75BC..0x82EE75C0)
	// 82EE75BC: FC008890  fmr f0, f17
	ctx.f[0].f64 = ctx.f[17].f64;
	pc = 0x82EE75C0; continue 'dispatch;
            }
            0x82EE75C0 => {
    //   block [0x82EE75C0..0x82EE75D0)
	// 82EE75C0: FF1B0000  fcmpu cr6, f27, f0
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[0].f64);
	// 82EE75C4: 4099000C  ble cr6, 0x82ee75d0
	if !ctx.cr[6].gt {
	pc = 0x82EE75D0; continue 'dispatch;
	}
	// 82EE75C8: EC1B0028  fsubs f0, f27, f0
	ctx.f[0].f64 = (((ctx.f[27].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE75CC: 48000008  b 0x82ee75d4
	pc = 0x82EE75D4; continue 'dispatch;
            }
            0x82EE75D0 => {
    //   block [0x82EE75D0..0x82EE75D4)
	// 82EE75D0: EC00D828  fsubs f0, f0, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[27].f64) as f32) as f64);
	pc = 0x82EE75D4; continue 'dispatch;
            }
            0x82EE75D4 => {
    //   block [0x82EE75D4..0x82EE75F8)
	// 82EE75D4: EDA38028  fsubs f13, f3, f16
	ctx.f[13].f64 = (((ctx.f[3].f64 - ctx.f[16].f64) as f32) as f64);
	// 82EE75D8: C15F010C  lfs f10, 0x10c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE75DC: C19F0104  lfs f12, 0x104(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE75E0: FF185000  fcmpu cr6, f24, f10
	ctx.cr[6].compare_f64(ctx.f[24].f64, ctx.f[10].f64);
	// 82EE75E4: ECEC0032  fmuls f7, f12, f0
	ctx.f[7].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82EE75E8: ECCD0072  fmuls f6, f13, f1
	ctx.f[6].f64 = (((ctx.f[13].f64 * ctx.f[1].f64) as f32) as f64);
	// 82EE75EC: 4099000C  ble cr6, 0x82ee75f8
	if !ctx.cr[6].gt {
	pc = 0x82EE75F8; continue 'dispatch;
	}
	// 82EE75F0: EDB85028  fsubs f13, f24, f10
	ctx.f[13].f64 = (((ctx.f[24].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EE75F4: 48000008  b 0x82ee75fc
	pc = 0x82EE75FC; continue 'dispatch;
            }
            0x82EE75F8 => {
    //   block [0x82EE75F8..0x82EE75FC)
	// 82EE75F8: FDA08890  fmr f13, f17
	ctx.f[13].f64 = ctx.f[17].f64;
	pc = 0x82EE75FC; continue 'dispatch;
            }
            0x82EE75FC => {
    //   block [0x82EE75FC..0x82EE7620)
	// 82EE75FC: C13F00C0  lfs f9, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE7600: FF0D4800  fcmpu cr6, f13, f9
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[9].f64);
	// 82EE7604: 4098001C  bge cr6, 0x82ee7620
	if !ctx.cr[6].lt {
	pc = 0x82EE7620; continue 'dispatch;
	}
	// 82EE7608: FF058800  fcmpu cr6, f5, f17
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[17].f64);
	// 82EE760C: 41990014  bgt cr6, 0x82ee7620
	if ctx.cr[6].gt {
	pc = 0x82EE7620; continue 'dispatch;
	}
	// 82EE7610: FC004890  fmr f0, f9
	ctx.f[0].f64 = ctx.f[9].f64;
	// 82EE7614: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE7618: ED0D0024  fdivs f8, f13, f0
	ctx.f[8].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EE761C: 48000008  b 0x82ee7624
	pc = 0x82EE7624; continue 'dispatch;
            }
            0x82EE7620 => {
    //   block [0x82EE7620..0x82EE7624)
	// 82EE7620: FD008890  fmr f8, f17
	ctx.f[8].f64 = ctx.f[17].f64;
	pc = 0x82EE7624; continue 'dispatch;
            }
            0x82EE7624 => {
    //   block [0x82EE7624..0x82EE7640)
	// 82EE7624: FDA0A850  fneg f13, f21
	ctx.f[13].u64 = ctx.f[21].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE7628: FC004890  fmr f0, f9
	ctx.f[0].f64 = ctx.f[9].f64;
	// 82EE762C: FF1B8800  fcmpu cr6, f27, f17
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[17].f64);
	// 82EE7630: FDBB736E  fsel f13, f27, f13, f14
	ctx.f[13].f64 = if ctx.f[27].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[14].f64 };
	// 82EE7634: 4099000C  ble cr6, 0x82ee7640
	if !ctx.cr[6].gt {
	pc = 0x82EE7640; continue 'dispatch;
	}
	// 82EE7638: C161005C  lfs f11, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE763C: 48000008  b 0x82ee7644
	pc = 0x82EE7644; continue 'dispatch;
            }
            0x82EE7640 => {
    //   block [0x82EE7640..0x82EE7644)
	// 82EE7640: FD60A890  fmr f11, f21
	ctx.f[11].f64 = ctx.f[21].f64;
	pc = 0x82EE7644; continue 'dispatch;
            }
            0x82EE7644 => {
    //   block [0x82EE7644..0x82EE7658)
	// 82EE7644: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EE7648: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE764C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE7650: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE7654: 4182004C  beq 0x82ee76a0
	if ctx.cr[0].eq {
	pc = 0x82EE76A0; continue 'dispatch;
	}
	pc = 0x82EE7658; continue 'dispatch;
            }
            0x82EE7658 => {
    //   block [0x82EE7658..0x82EE7670)
	// 82EE7658: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE765C: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82EE7660: 41990010  bgt cr6, 0x82ee7670
	if ctx.cr[6].gt {
	pc = 0x82EE7670; continue 'dispatch;
	}
	// 82EE7664: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EE7668: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE766C: 4082FFEC  bne 0x82ee7658
	if !ctx.cr[0].eq {
	pc = 0x82EE7658; continue 'dispatch;
	}
	pc = 0x82EE7670; continue 'dispatch;
            }
            0x82EE7670 => {
    //   block [0x82EE7670..0x82EE7678)
	// 82EE7670: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE7674: 419A002C  beq cr6, 0x82ee76a0
	if ctx.cr[6].eq {
	pc = 0x82EE76A0; continue 'dispatch;
	}
	pc = 0x82EE7678; continue 'dispatch;
            }
            0x82EE7678 => {
    //   block [0x82EE7678..0x82EE7694)
	// 82EE7678: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE767C: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82EE7680: 41990020  bgt cr6, 0x82ee76a0
	if ctx.cr[6].gt {
	pc = 0x82EE76A0; continue 'dispatch;
	}
	// 82EE7684: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE7688: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE768C: 40980008  bge cr6, 0x82ee7694
	if !ctx.cr[6].lt {
	pc = 0x82EE7694; continue 'dispatch;
	}
	// 82EE7690: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82EE7694; continue 'dispatch;
            }
            0x82EE7694 => {
    //   block [0x82EE7694..0x82EE76A0)
	// 82EE7694: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EE7698: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE769C: 4082FFDC  bne 0x82ee7678
	if !ctx.cr[0].eq {
	pc = 0x82EE7678; continue 'dispatch;
	}
	pc = 0x82EE76A0; continue 'dispatch;
            }
            0x82EE76A0 => {
    //   block [0x82EE76A0..0x82EE76B0)
	// 82EE76A0: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EE76A4: 4099000C  ble cr6, 0x82ee76b0
	if !ctx.cr[6].gt {
	pc = 0x82EE76B0; continue 'dispatch;
	}
	// 82EE76A8: EC005028  fsubs f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EE76AC: 48000008  b 0x82ee76b4
	pc = 0x82EE76B4; continue 'dispatch;
            }
            0x82EE76B0 => {
    //   block [0x82EE76B0..0x82EE76B4)
	// 82EE76B0: FC008890  fmr f0, f17
	ctx.f[0].f64 = ctx.f[17].f64;
	pc = 0x82EE76B4; continue 'dispatch;
            }
            0x82EE76B4 => {
    //   block [0x82EE76B4..0x82EE76C8)
	// 82EE76B4: FF004800  fcmpu cr6, f0, f9
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[9].f64);
	// 82EE76B8: 40980010  bge cr6, 0x82ee76c8
	if !ctx.cr[6].lt {
	pc = 0x82EE76C8; continue 'dispatch;
	}
	// 82EE76BC: EC004824  fdivs f0, f0, f9
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[9].f64) as f32) as f64;
	// 82EE76C0: EDA30028  fsubs f13, f3, f0
	ctx.f[13].f64 = (((ctx.f[3].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE76C4: 48000008  b 0x82ee76cc
	pc = 0x82EE76CC; continue 'dispatch;
            }
            0x82EE76C8 => {
    //   block [0x82EE76C8..0x82EE76CC)
	// 82EE76C8: FDA08890  fmr f13, f17
	ctx.f[13].f64 = ctx.f[17].f64;
	pc = 0x82EE76CC; continue 'dispatch;
            }
            0x82EE76CC => {
    //   block [0x82EE76CC..0x82EE76DC)
	// 82EE76CC: FF058800  fcmpu cr6, f5, f17
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[17].f64);
	// 82EE76D0: 4199000C  bgt cr6, 0x82ee76dc
	if ctx.cr[6].gt {
	pc = 0x82EE76DC; continue 'dispatch;
	}
	// 82EE76D4: FC001890  fmr f0, f3
	ctx.f[0].f64 = ctx.f[3].f64;
	// 82EE76D8: 4800001C  b 0x82ee76f4
	pc = 0x82EE76F4; continue 'dispatch;
            }
            0x82EE76DC => {
    //   block [0x82EE76DC..0x82EE76F0)
	// 82EE76DC: FF051000  fcmpu cr6, f5, f2
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[2].f64);
	// 82EE76E0: 40980010  bge cr6, 0x82ee76f0
	if !ctx.cr[6].lt {
	pc = 0x82EE76F0; continue 'dispatch;
	}
	// 82EE76E4: EC051024  fdivs f0, f5, f2
	ctx.f[0].f64 = ((ctx.f[5].f64 / ctx.f[2].f64) as f32) as f64;
	// 82EE76E8: EC030028  fsubs f0, f3, f0
	ctx.f[0].f64 = (((ctx.f[3].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE76EC: 48000008  b 0x82ee76f4
	pc = 0x82EE76F4; continue 'dispatch;
            }
            0x82EE76F0 => {
    //   block [0x82EE76F0..0x82EE76F4)
	// 82EE76F0: FC008890  fmr f0, f17
	ctx.f[0].f64 = ctx.f[17].f64;
	pc = 0x82EE76F4; continue 'dispatch;
            }
            0x82EE76F4 => {
    //   block [0x82EE76F4..0x82EE7720)
	// 82EE76F4: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82EE76F8: 816A8F3C  lwz r11, -0x70c4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28868 as u32) ) } as u64;
	// 82EE76FC: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EE7700: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 82EE7704: 4082001C  bne 0x82ee7720
	if !ctx.cr[0].eq {
	pc = 0x82EE7720; continue 'dispatch;
	}
	// 82EE7708: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EE770C: 916A8F3C  stw r11, -0x70c4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-28868 as u32), ctx.r[11].u32 ) };
	// 82EE7710: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82EE7714: C18B0FF8  lfs f12, 0xff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4088 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE7718: D1898F38  stfs f12, -0x70c8(r9)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-28872 as u32), tmp.u32 ) };
	// 82EE771C: 48000008  b 0x82ee7724
	pc = 0x82EE7724; continue 'dispatch;
            }
            0x82EE7720 => {
    //   block [0x82EE7720..0x82EE7724)
	// 82EE7720: C1898F38  lfs f12, -0x70c8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-28872 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EE7724; continue 'dispatch;
            }
            0x82EE7724 => {
    //   block [0x82EE7724..0x82EE777C)
	// 82EE7724: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE7728: ED60682A  fadds f11, f0, f13
	ctx.f[11].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE772C: C00BBE10  lfs f0, -0x41f0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7730: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE7734: C1ABBDF8  lfs f13, -0x4208(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16904 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE7738: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE773C: ED480372  fmuls f10, f8, f13
	ctx.f[10].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE7740: C1ABBDF4  lfs f13, -0x420c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16908 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE7744: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE7748: EC0B503A  fmadds f0, f11, f0, f10
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 82EE774C: EC06037A  fmadds f0, f6, f13, f0
	ctx.f[0].f64 = (((ctx.f[6].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82EE7750: C1AB0C80  lfs f13, 0xc80(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3200 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE7754: EC00382A  fadds f0, f0, f7
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64;
	// 82EE7758: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE775C: D19E0010  stfs f12, 0x10(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EE7760: C17F0010  lfs f11, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE7764: EDAB0372  fmuls f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE7768: C01F00D8  lfs f0, 0xd8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE776C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE7770: 4099000C  ble cr6, 0x82ee777c
	if !ctx.cr[6].gt {
	pc = 0x82EE777C; continue 'dispatch;
	}
	// 82EE7774: FF1B8800  fcmpu cr6, f27, f17
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[17].f64);
	// 82EE7778: 41980018  blt cr6, 0x82ee7790
	if ctx.cr[6].lt {
	pc = 0x82EE7790; continue 'dispatch;
	}
	pc = 0x82EE777C; continue 'dispatch;
            }
            0x82EE777C => {
    //   block [0x82EE777C..0x82EE7790)
	// 82EE777C: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE7780: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE7784: 40980020  bge cr6, 0x82ee77a4
	if !ctx.cr[6].lt {
	pc = 0x82EE77A4; continue 'dispatch;
	}
	// 82EE7788: FF1B8800  fcmpu cr6, f27, f17
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[17].f64);
	// 82EE778C: 40990018  ble cr6, 0x82ee77a4
	if !ctx.cr[6].gt {
	pc = 0x82EE77A4; continue 'dispatch;
	}
	pc = 0x82EE7790; continue 'dispatch;
            }
            0x82EE7790 => {
    //   block [0x82EE7790..0x82EE77A4)
	// 82EE7790: 897F003C  lbz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EE7794: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE7798: 4082000C  bne 0x82ee77a4
	if !ctx.cr[0].eq {
	pc = 0x82EE77A4; continue 'dispatch;
	}
	// 82EE779C: EC0C082A  fadds f0, f12, f1
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[1].f64) as f32) as f64;
	// 82EE77A0: D01E0010  stfs f0, 0x10(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	pc = 0x82EE77A4; continue 'dispatch;
            }
            0x82EE77A4 => {
    //   block [0x82EE77A4..0x82EE77DC)
	// 82EE77A4: 897F003C  lbz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EE77A8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE77AC: 41820040  beq 0x82ee77ec
	if ctx.cr[0].eq {
	pc = 0x82EE77EC; continue 'dispatch;
	}
	// 82EE77B0: FF058800  fcmpu cr6, f5, f17
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[17].f64);
	// 82EE77B4: 40980038  bge cr6, 0x82ee77ec
	if !ctx.cr[6].lt {
	pc = 0x82EE77EC; continue 'dispatch;
	}
	// 82EE77B8: C01F0110  lfs f0, 0x110(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE77BC: C1BF010C  lfs f13, 0x10c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE77C0: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE77C4: FF040000  fcmpu cr6, f4, f0
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[0].f64);
	// 82EE77C8: 40980024  bge cr6, 0x82ee77ec
	if !ctx.cr[6].lt {
	pc = 0x82EE77EC; continue 'dispatch;
	}
	// 82EE77CC: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82EE77D0: 4098000C  bge cr6, 0x82ee77dc
	if !ctx.cr[6].lt {
	pc = 0x82EE77DC; continue 'dispatch;
	}
	// 82EE77D4: FC001890  fmr f0, f3
	ctx.f[0].f64 = ctx.f[3].f64;
	// 82EE77D8: 48000008  b 0x82ee77e0
	pc = 0x82EE77E0; continue 'dispatch;
            }
            0x82EE77DC => {
    //   block [0x82EE77DC..0x82EE77E0)
	// 82EE77DC: FC000890  fmr f0, f1
	ctx.f[0].f64 = ctx.f[1].f64;
	pc = 0x82EE77E0; continue 'dispatch;
            }
            0x82EE77E0 => {
    //   block [0x82EE77E0..0x82EE77EC)
	// 82EE77E0: C1BE0010  lfs f13, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE77E4: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EE77E8: D01E0010  stfs f0, 0x10(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	pc = 0x82EE77EC; continue 'dispatch;
            }
            0x82EE77EC => {
    //   block [0x82EE77EC..0x82EE7800)
	// 82EE77EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82EE77F0: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 82EE77F4: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82EE77F8: 4BDC64F5  bl 0x82cadcec
	ctx.lr = 0x82EE77FC;
	sub_82CADCEC(ctx, base);
	// 82EE77FC: 4BDC1C5C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE7800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE7800 size=52
    let mut pc: u32 = 0x82EE7800;
    'dispatch: loop {
        match pc {
            0x82EE7800 => {
    //   block [0x82EE7800..0x82EE7834)
	// 82EE7800: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EE7804: 81260004  lwz r9, 4(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE7808: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE780C: 40820028  bne 0x82ee7834
	if !ctx.cr[0].eq {
		sub_82EE7834(ctx, base);
		return;
	}
	// 82EE7810: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE7814: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82EE7818: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EE781C: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 82EE7820: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EE7824: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EE7828: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EE782C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82EE7830: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE7834(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82EE7834 size=252
    let mut pc: u32 = 0x82EE7834;
    'dispatch: loop {
        match pc {
            0x82EE7834 => {
    //   block [0x82EE7834..0x82EE78D0)
	// 82EE7834: 81040014  lwz r8, 0x14(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE7838: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82EE783C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82EE7840: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82EE7844: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EE7848: 91040014  stw r8, 0x14(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 82EE784C: 810B002C  lwz r8, 0x2c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EE7850: 91040010  stw r8, 0x10(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 82EE7854: C0050004  lfs f0, 4(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7858: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82EE785C: C0050008  lfs f0, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7860: D00A0008  stfs f0, 8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82EE7864: C005000C  lfs f0, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7868: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82EE786C: C0050010  lfs f0, 0x10(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7870: D00A0010  stfs f0, 0x10(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82EE7874: C0050014  lfs f0, 0x14(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7878: D00A0014  stfs f0, 0x14(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82EE787C: C0050018  lfs f0, 0x18(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7880: D00A0018  stfs f0, 0x18(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82EE7884: C005001C  lfs f0, 0x1c(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7888: D00A001C  stfs f0, 0x1c(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82EE788C: C0050020  lfs f0, 0x20(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7890: D00A0020  stfs f0, 0x20(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82EE7894: 98EB0030  stb r7, 0x30(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[7].u8 ) };
	// 82EE7898: 409A0054  bne cr6, 0x82ee78ec
	if !ctx.cr[6].eq {
	pc = 0x82EE78EC; continue 'dispatch;
	}
	// 82EE789C: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EE78A0: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE78A4: 4082002C  bne 0x82ee78d0
	if !ctx.cr[0].eq {
	pc = 0x82EE78D0; continue 'dispatch;
	}
	// 82EE78A8: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EE78AC: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82EE78B0: 914B002C  stw r10, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 82EE78B4: 81240008  lwz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE78B8: 91490028  stw r10, 0x28(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82EE78BC: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EE78C0: 91490028  stw r10, 0x28(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82EE78C4: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EE78C8: 9149002C  stw r10, 0x2c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 82EE78CC: 48000044  b 0x82ee7910
	pc = 0x82EE7910; continue 'dispatch;
            }
            0x82EE78D0 => {
    //   block [0x82EE78D0..0x82EE78EC)
	// 82EE78D0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EE78D4: 914B0028  stw r10, 0x28(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82EE78D8: 912B002C  stw r9, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 82EE78DC: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EE78E0: 916A002C  stw r11, 0x2c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82EE78E4: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82EE78E8: 48000028  b 0x82ee7910
	pc = 0x82EE7910; continue 'dispatch;
            }
            0x82EE78EC => {
    //   block [0x82EE78EC..0x82EE790C)
	// 82EE78EC: 81490028  lwz r10, 0x28(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(40 as u32) ) } as u64;
	// 82EE78F0: 912B002C  stw r9, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 82EE78F4: 91690028  stw r11, 0x28(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82EE78F8: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE78FC: 914B0028  stw r10, 0x28(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82EE7900: 4182000C  beq 0x82ee790c
	if ctx.cr[0].eq {
	pc = 0x82EE790C; continue 'dispatch;
	}
	// 82EE7904: 916A002C  stw r11, 0x2c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82EE7908: 48000008  b 0x82ee7910
	pc = 0x82EE7910; continue 'dispatch;
            }
            0x82EE790C => {
    //   block [0x82EE790C..0x82EE7910)
	// 82EE790C: 91640008  stw r11, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE7910; continue 'dispatch;
            }
            0x82EE7910 => {
    //   block [0x82EE7910..0x82EE7930)
	// 82EE7910: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EE7914: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82EE7918: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82EE791C: 394AAFB4  addi r10, r10, -0x504c
	ctx.r[10].s64 = ctx.r[10].s64 + -20556;
	// 82EE7920: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	// 82EE7924: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EE7928: 91260000  stw r9, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82EE792C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE7930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE7930 size=1216
    let mut pc: u32 = 0x82EE7930;
    'dispatch: loop {
        match pc {
            0x82EE7930 => {
    //   block [0x82EE7930..0x82EE7970)
	// 82EE7930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE7934: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EE7938: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EE793C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EE7940: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 82EE7944: 4BDC6389  bl 0x82cadccc
	ctx.lr = 0x82EE7948;
	sub_82CADCA0(ctx, base);
	// 82EE7948: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE794C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE7950: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EE7954: 897F00FA  lbz r11, 0xfa(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(250 as u32) ) } as u64;
	// 82EE7958: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82EE795C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE7960: 41820010  beq 0x82ee7970
	if ctx.cr[0].eq {
	pc = 0x82EE7970; continue 'dispatch;
	}
	// 82EE7964: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EE7968: 9BDF00FA  stb r30, 0xfa(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(250 as u32), ctx.r[30].u8 ) };
	// 82EE796C: 48000464  b 0x82ee7dd0
	pc = 0x82EE7DD0; continue 'dispatch;
            }
            0x82EE7970 => {
    //   block [0x82EE7970..0x82EE7980)
	// 82EE7970: 80BF00D4  lwz r5, 0xd4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EE7974: 81650014  lwz r11, 0x14(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE7978: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82EE797C: 4098000C  bge cr6, 0x82ee7988
	if !ctx.cr[6].lt {
	pc = 0x82EE7988; continue 'dispatch;
	}
	pc = 0x82EE7980; continue 'dispatch;
            }
            0x82EE7980 => {
    //   block [0x82EE7980..0x82EE7988)
	// 82EE7980: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EE7984: 4800044C  b 0x82ee7dd0
	pc = 0x82EE7DD0; continue 'dispatch;
            }
            0x82EE7988 => {
    //   block [0x82EE7988..0x82EE79CC)
	// 82EE7988: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 82EE798C: C01F005C  lfs f0, 0x5c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7990: C1BF008C  lfs f13, 0x8c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE7994: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EE7998: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE799C: C01F0060  lfs f0, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE79A0: C19F0090  lfs f12, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE79A4: ED6C0028  fsubs f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE79A8: C15F0094  lfs f10, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE79AC: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 82EE79B0: C01F0064  lfs f0, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE79B4: C32A0C14  lfs f25, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82EE79B8: EC0A0028  fsubs f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	// 82EE79BC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE79C0: 4182000C  beq 0x82ee79cc
	if ctx.cr[0].eq {
	pc = 0x82EE79CC; continue 'dispatch;
	}
	// 82EE79C4: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE79C8: 48000008  b 0x82ee79d0
	pc = 0x82EE79D0; continue 'dispatch;
            }
            0x82EE79CC => {
    //   block [0x82EE79CC..0x82EE79D0)
	// 82EE79CC: FD80C890  fmr f12, f25
	ctx.f[12].f64 = ctx.f[25].f64;
	pc = 0x82EE79D0; continue 'dispatch;
            }
            0x82EE79D0 => {
    //   block [0x82EE79D0..0x82EE7AB0)
	// 82EE79D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE79D4: C15F0078  lfs f10, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82EE79D8: C35F0020  lfs f26, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82EE79DC: C36B0BFC  lfs f27, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82EE79E0: ED2A06F2  fmuls f9, f10, f27
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[27].f64) as f32) as f64);
	// 82EE79E4: ED4D0372  fmuls f10, f13, f13
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE79E8: ED9A4B3A  fmadds f12, f26, f12, f9
	ctx.f[12].f64 = (((ctx.f[26].f64 * ctx.f[12].f64 + ctx.f[9].f64) as f32) as f64);
	// 82EE79EC: ED20503A  fmadds f9, f0, f0, f10
	ctx.f[9].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 82EE79F0: ED8C0332  fmuls f12, f12, f12
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE79F4: FF096000  fcmpu cr6, f9, f12
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[12].f64);
	// 82EE79F8: 4198FF88  blt cr6, 0x82ee7980
	if ctx.cr[6].lt {
	pc = 0x82EE7980; continue 'dispatch;
	}
	// 82EE79FC: C19F00B8  lfs f12, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE7A00: ED8C02F2  fmuls f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE7A04: C13F00BC  lfs f9, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE7A08: C11F00B4  lfs f8, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE7A0C: C3BF0108  lfs f29, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82EE7A10: C39F010C  lfs f28, 0x10c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82EE7A14: FCE0E050  fneg f7, f28
	ctx.f[7].u64 = ctx.f[28].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE7A18: ED89603A  fmadds f12, f9, f0, f12
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 82EE7A1C: EC8D623A  fmadds f4, f13, f8, f12
	ctx.f[4].f64 = (((ctx.f[13].f64 * ctx.f[8].f64 + ctx.f[12].f64) as f32) as f64);
	// 82EE7A20: EFFD0132  fmuls f31, f29, f4
	ctx.f[31].f64 = (((ctx.f[29].f64 * ctx.f[4].f64) as f32) as f64);
	// 82EE7A24: FF1F3800  fcmpu cr6, f31, f7
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[7].f64);
	// 82EE7A28: 4198FF58  blt cr6, 0x82ee7980
	if ctx.cr[6].lt {
	pc = 0x82EE7980; continue 'dispatch;
	}
	// 82EE7A2C: C13F00A0  lfs f9, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82EE7A30: ED2902F2  fmuls f9, f9, f11
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE7A34: C11F00A4  lfs f8, 0xa4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE7A38: C0FF009C  lfs f7, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82EE7A3C: C19F0040  lfs f12, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE7A40: ED28483A  fmadds f9, f8, f0, f9
	ctx.f[9].f64 = (((ctx.f[8].f64 * ctx.f[0].f64 + ctx.f[9].f64) as f32) as f64);
	// 82EE7A44: EC2D49FA  fmadds f1, f13, f7, f9
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[7].f64 + ctx.f[9].f64) as f32) as f64);
	// 82EE7A48: FDA00A10  fabs f13, f1
	ctx.f[13].u64 = ctx.f[1].u64 & !0x8000_0000_0000_0000u64;
	// 82EE7A4C: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EE7A50: 4199FF30  bgt cr6, 0x82ee7980
	if ctx.cr[6].gt {
	pc = 0x82EE7980; continue 'dispatch;
	}
	// 82EE7A54: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82EE7A58: 811F0050  lwz r8, 0x50(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EE7A5C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE7A60: 80DF0048  lwz r6, 0x48(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EE7A64: C1BF0074  lfs f13, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE7A68: 38EBAFB4  addi r7, r11, -0x504c
	ctx.r[7].s64 = ctx.r[11].s64 + -20556;
	// 82EE7A6C: C19F0014  lfs f12, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE7A70: ECAD66FA  fmadds f5, f13, f27, f12
	ctx.f[5].f64 = (((ctx.f[13].f64 * ctx.f[27].f64 + ctx.f[12].f64) as f32) as f64);
	// 82EE7A74: 816A8F44  lwz r11, -0x70bc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28860 as u32) ) } as u64;
	// 82EE7A78: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EE7A7C: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE7A80: 81290008  lwz r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE7A84: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 82EE7A88: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82EE7A8C: C3C60010  lfs f30, 0x10(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82EE7A90: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 82EE7A94: 4082001C  bne 0x82ee7ab0
	if !ctx.cr[0].eq {
	pc = 0x82EE7AB0; continue 'dispatch;
	}
	// 82EE7A98: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EE7A9C: 916A8F44  stw r11, -0x70bc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-28860 as u32), ctx.r[11].u32 ) };
	// 82EE7AA0: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82EE7AA4: C18B5224  lfs f12, 0x5224(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(21028 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE7AA8: D1898F40  stfs f12, -0x70c0(r9)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-28864 as u32), tmp.u32 ) };
	// 82EE7AAC: 48000008  b 0x82ee7ab4
	pc = 0x82EE7AB4; continue 'dispatch;
            }
            0x82EE7AB0 => {
    //   block [0x82EE7AB0..0x82EE7AB4)
	// 82EE7AB0: C1898F40  lfs f12, -0x70c0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-28864 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EE7AB4; continue 'dispatch;
            }
            0x82EE7AB4 => {
    //   block [0x82EE7AB4..0x82EE7ADC)
	// 82EE7AB4: ED6B02F2  fmuls f11, f11, f11
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 82EE7AB8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE7ABC: C1ABBE14  lfs f13, -0x41ec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16876 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE7AC0: FF046800  fcmpu cr6, f4, f13
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[13].f64);
	// 82EE7AC4: EC00583A  fmadds f0, f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82EE7AC8: EC00502A  fadds f0, f0, f10
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64;
	// 82EE7ACC: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82EE7AD0: 4099000C  ble cr6, 0x82ee7adc
	if !ctx.cr[6].gt {
	pc = 0x82EE7ADC; continue 'dispatch;
	}
	// 82EE7AD4: EC412024  fdivs f2, f1, f4
	ctx.f[2].f64 = ((ctx.f[1].f64 / ctx.f[4].f64) as f32) as f64;
	// 82EE7AD8: 48000008  b 0x82ee7ae0
	pc = 0x82EE7AE0; continue 'dispatch;
            }
            0x82EE7ADC => {
    //   block [0x82EE7ADC..0x82EE7AE0)
	// 82EE7ADC: EC4C0072  fmuls f2, f12, f1
	ctx.f[2].f64 = (((ctx.f[12].f64 * ctx.f[1].f64) as f32) as f64);
	pc = 0x82EE7AE0; continue 'dispatch;
            }
            0x82EE7AE0 => {
    //   block [0x82EE7AE0..0x82EE7AF8)
	// 82EE7AE0: FF046800  fcmpu cr6, f4, f13
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[13].f64);
	// 82EE7AE4: 40990014  ble cr6, 0x82ee7af8
	if !ctx.cr[6].gt {
	pc = 0x82EE7AF8; continue 'dispatch;
	}
	// 82EE7AE8: ED850024  fdivs f12, f5, f0
	ctx.f[12].f64 = ((ctx.f[5].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EE7AEC: FD600A10  fabs f11, f1
	ctx.f[11].u64 = ctx.f[1].u64 & !0x8000_0000_0000_0000u64;
	// 82EE7AF0: ED4B0332  fmuls f10, f11, f12
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE7AF4: 48000008  b 0x82ee7afc
	pc = 0x82EE7AFC; continue 'dispatch;
            }
            0x82EE7AF8 => {
    //   block [0x82EE7AF8..0x82EE7AFC)
	// 82EE7AF8: FD402890  fmr f10, f5
	ctx.f[10].f64 = ctx.f[5].f64;
	pc = 0x82EE7AFC; continue 'dispatch;
            }
            0x82EE7AFC => {
    //   block [0x82EE7AFC..0x82EE7B20)
	// 82EE7AFC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE7B00: FF046800  fcmpu cr6, f4, f13
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[13].f64);
	// 82EE7B04: C10B0C18  lfs f8, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82EE7B08: 40990018  ble cr6, 0x82ee7b20
	if !ctx.cr[6].gt {
	pc = 0x82EE7B20; continue 'dispatch;
	}
	// 82EE7B0C: FDA02050  fneg f13, f4
	ctx.f[13].u64 = ctx.f[4].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE7B10: FDA1236E  fsel f13, f1, f13, f4
	ctx.f[13].f64 = if ctx.f[1].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[4].f64 };
	// 82EE7B14: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EE7B18: ED600172  fmuls f11, f0, f5
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[5].f64) as f32) as f64);
	// 82EE7B1C: 48000008  b 0x82ee7b24
	pc = 0x82EE7B24; continue 'dispatch;
            }
            0x82EE7B20 => {
    //   block [0x82EE7B20..0x82EE7B24)
	// 82EE7B20: FD604090  fmr f11, f8
	ctx.f[11].f64 = ctx.f[8].f64;
	pc = 0x82EE7B24; continue 'dispatch;
            }
            0x82EE7B24 => {
    //   block [0x82EE7B24..0x82EE7B34)
	// 82EE7B24: FF014000  fcmpu cr6, f1, f8
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[8].f64);
	// 82EE7B28: 4199000C  bgt cr6, 0x82ee7b34
	if ctx.cr[6].gt {
	pc = 0x82EE7B34; continue 'dispatch;
	}
	// 82EE7B2C: EC612828  fsubs f3, f1, f5
	ctx.f[3].f64 = (((ctx.f[1].f64 - ctx.f[5].f64) as f32) as f64);
	// 82EE7B30: 48000008  b 0x82ee7b38
	pc = 0x82EE7B38; continue 'dispatch;
            }
            0x82EE7B34 => {
    //   block [0x82EE7B34..0x82EE7B38)
	// 82EE7B34: FC605890  fmr f3, f11
	ctx.f[3].f64 = ctx.f[11].f64;
	pc = 0x82EE7B38; continue 'dispatch;
            }
            0x82EE7B38 => {
    //   block [0x82EE7B38..0x82EE7B64)
	// 82EE7B38: EC05082A  fadds f0, f5, f1
	ctx.f[0].f64 = ((ctx.f[5].f64 + ctx.f[1].f64) as f32) as f64;
	// 82EE7B3C: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE7B40: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82EE7B44: FF014000  fcmpu cr6, f1, f8
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[8].f64);
	// 82EE7B48: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 82EE7B4C: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 82EE7B50: FCE1582E  fsel f7, f1, f0, f11
	ctx.f[7].f64 = if ctx.f[1].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[11].f64 };
	// 82EE7B54: 41980010  blt cr6, 0x82ee7b64
	if ctx.cr[6].lt {
	pc = 0x82EE7B64; continue 'dispatch;
	}
	// 82EE7B58: 81290008  lwz r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE7B5C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EE7B60: 4800000C  b 0x82ee7b6c
	pc = 0x82EE7B6C; continue 'dispatch;
            }
            0x82EE7B64 => {
    //   block [0x82EE7B64..0x82EE7B6C)
	// 82EE7B64: 8129000C  lwz r9, 0xc(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EE7B68: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	pc = 0x82EE7B6C; continue 'dispatch;
            }
            0x82EE7B6C => {
    //   block [0x82EE7B6C..0x82EE7B80)
	// 82EE7B6C: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 82EE7B70: 556907BD  rlwinm. r9, r11, 0, 0x1e, 0x1e
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EE7B74: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE7B78: 41820008  beq 0x82ee7b80
	if ctx.cr[0].eq {
	pc = 0x82EE7B80; continue 'dispatch;
	}
	// 82EE7B7C: 556B07FA  rlwinm r11, r11, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	pc = 0x82EE7B80; continue 'dispatch;
            }
            0x82EE7B80 => {
    //   block [0x82EE7B80..0x82EE7B8C)
	// 82EE7B80: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EE7B84: 41820008  beq 0x82ee7b8c
	if ctx.cr[0].eq {
	pc = 0x82EE7B8C; continue 'dispatch;
	}
	// 82EE7B88: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	pc = 0x82EE7B8C; continue 'dispatch;
            }
            0x82EE7B8C => {
    //   block [0x82EE7B8C..0x82EE7BA4)
	// 82EE7B8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EE7B90: 419A01B4  beq cr6, 0x82ee7d44
	if ctx.cr[6].eq {
	pc = 0x82EE7D44; continue 'dispatch;
	}
	// 82EE7B94: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82EE7B98: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82EE7B9C: C0C80A98  lfs f6, 0xa98(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2712 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82EE7BA0: C1290C4C  lfs f9, 0xc4c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3148 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	pc = 0x82EE7BA4; continue 'dispatch;
            }
            0x82EE7BA4 => {
    //   block [0x82EE7BA4..0x82EE7BC8)
	// 82EE7BA4: FF014000  fcmpu cr6, f1, f8
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[8].f64);
	// 82EE7BA8: 41980020  blt cr6, 0x82ee7bc8
	if ctx.cr[6].lt {
	pc = 0x82EE7BC8; continue 'dispatch;
	}
	// 82EE7BAC: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE7BB0: FF0D1800  fcmpu cr6, f13, f3
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[3].f64);
	// 82EE7BB4: 4198012C  blt cr6, 0x82ee7ce0
	if ctx.cr[6].lt {
	pc = 0x82EE7CE0; continue 'dispatch;
	}
	// 82EE7BB8: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7BBC: FF003800  fcmpu cr6, f0, f7
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[7].f64);
	// 82EE7BC0: 41990184  bgt cr6, 0x82ee7d44
	if ctx.cr[6].gt {
	pc = 0x82EE7D44; continue 'dispatch;
	}
	// 82EE7BC4: 4800001C  b 0x82ee7be0
	pc = 0x82EE7BE0; continue 'dispatch;
            }
            0x82EE7BC8 => {
    //   block [0x82EE7BC8..0x82EE7BE0)
	// 82EE7BC8: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7BCC: FF003800  fcmpu cr6, f0, f7
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[7].f64);
	// 82EE7BD0: 41990110  bgt cr6, 0x82ee7ce0
	if ctx.cr[6].gt {
	pc = 0x82EE7CE0; continue 'dispatch;
	}
	// 82EE7BD4: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE7BD8: FF0D1800  fcmpu cr6, f13, f3
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[3].f64);
	// 82EE7BDC: 41980168  blt cr6, 0x82ee7d44
	if ctx.cr[6].lt {
	pc = 0x82EE7D44; continue 'dispatch;
	}
	pc = 0x82EE7BE0; continue 'dispatch;
            }
            0x82EE7BE0 => {
    //   block [0x82EE7BE0..0x82EE7C08)
	// 82EE7BE0: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82EE7BE4: 40980024  bge cr6, 0x82ee7c08
	if !ctx.cr[6].lt {
	pc = 0x82EE7C08; continue 'dispatch;
	}
	// 82EE7BE8: FF0D0800  fcmpu cr6, f13, f1
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[1].f64);
	// 82EE7BEC: 4099001C  ble cr6, 0x82ee7c08
	if !ctx.cr[6].gt {
	pc = 0x82EE7C08; continue 'dispatch;
	}
	// 82EE7BF0: EDBACA7A  fmadds f13, f26, f9, f25
	ctx.f[13].f64 = (((ctx.f[26].f64 * ctx.f[9].f64 + ctx.f[25].f64) as f32) as f64);
	// 82EE7BF4: C00A0010  lfs f0, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7BF8: EDAD0732  fmuls f13, f13, f28
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[28].f64) as f32) as f64);
	// 82EE7BFC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE7C00: 4198FD80  blt cr6, 0x82ee7980
	if ctx.cr[6].lt {
	pc = 0x82EE7980; continue 'dispatch;
	}
	// 82EE7C04: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82EE7C08; continue 'dispatch;
            }
            0x82EE7C08 => {
    //   block [0x82EE7C08..0x82EE7C44)
	// 82EE7C08: EC1D0172  fmuls f0, f29, f5
	ctx.f[0].f64 = (((ctx.f[29].f64 * ctx.f[5].f64) as f32) as f64);
	// 82EE7C0C: C18A0010  lfs f12, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE7C10: EDA0F82A  fadds f13, f0, f31
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82EE7C14: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82EE7C18: 41990094  bgt cr6, 0x82ee7cac
	if ctx.cr[6].gt {
	pc = 0x82EE7CAC; continue 'dispatch;
	}
	// 82EE7C1C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EE7C20: FF014000  fcmpu cr6, f1, f8
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[8].f64);
	// 82EE7C24: 40990044  ble cr6, 0x82ee7c68
	if !ctx.cr[6].gt {
	pc = 0x82EE7C68; continue 'dispatch;
	}
	// 82EE7C28: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7C2C: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EE7C30: 409900B0  ble cr6, 0x82ee7ce0
	if !ctx.cr[6].gt {
	pc = 0x82EE7CE0; continue 'dispatch;
	}
	// 82EE7C34: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82EE7C38: 4098000C  bge cr6, 0x82ee7c44
	if !ctx.cr[6].lt {
	pc = 0x82EE7C44; continue 'dispatch;
	}
	// 82EE7C3C: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82EE7C40: 48000008  b 0x82ee7c48
	pc = 0x82EE7C48; continue 'dispatch;
            }
            0x82EE7C44 => {
    //   block [0x82EE7C44..0x82EE7C48)
	// 82EE7C44: EDAB082A  fadds f13, f11, f1
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[1].f64) as f32) as f64;
	pc = 0x82EE7C48; continue 'dispatch;
            }
            0x82EE7C48 => {
    //   block [0x82EE7C48..0x82EE7C68)
	// 82EE7C48: EC0C07B2  fmuls f0, f12, f30
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EE7C4C: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EE7C50: 4198FD30  blt cr6, 0x82ee7980
	if ctx.cr[6].lt {
	pc = 0x82EE7980; continue 'dispatch;
	}
	// 82EE7C54: EDAD5828  fsubs f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EE7C58: EC005028  fsubs f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EE7C5C: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EE7C60: FF001000  fcmpu cr6, f0, f2
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[2].f64);
	// 82EE7C64: 48000078  b 0x82ee7cdc
	pc = 0x82EE7CDC; continue 'dispatch;
            }
            0x82EE7C68 => {
    //   block [0x82EE7C68..0x82EE7C84)
	// 82EE7C68: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7C6C: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82EE7C70: 40980070  bge cr6, 0x82ee7ce0
	if !ctx.cr[6].lt {
	pc = 0x82EE7CE0; continue 'dispatch;
	}
	// 82EE7C74: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82EE7C78: 4099000C  ble cr6, 0x82ee7c84
	if !ctx.cr[6].gt {
	pc = 0x82EE7C84; continue 'dispatch;
	}
	// 82EE7C7C: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82EE7C80: 48000008  b 0x82ee7c88
	pc = 0x82EE7C88; continue 'dispatch;
            }
            0x82EE7C84 => {
    //   block [0x82EE7C84..0x82EE7C88)
	// 82EE7C84: EDAB082A  fadds f13, f11, f1
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[1].f64) as f32) as f64;
	pc = 0x82EE7C88; continue 'dispatch;
            }
            0x82EE7C88 => {
    //   block [0x82EE7C88..0x82EE7CAC)
	// 82EE7C88: EC0C07B2  fmuls f0, f12, f30
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[30].f64) as f32) as f64);
	// 82EE7C8C: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82EE7C90: 4198FCF0  blt cr6, 0x82ee7980
	if ctx.cr[6].lt {
	pc = 0x82EE7980; continue 'dispatch;
	}
	// 82EE7C94: EDAD5828  fsubs f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82EE7C98: EC005028  fsubs f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 82EE7C9C: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82EE7CA0: FF001000  fcmpu cr6, f0, f2
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[2].f64);
	// 82EE7CA4: 4198FCDC  blt cr6, 0x82ee7980
	if ctx.cr[6].lt {
	pc = 0x82EE7980; continue 'dispatch;
	}
	// 82EE7CA8: 48000038  b 0x82ee7ce0
	pc = 0x82EE7CE0; continue 'dispatch;
            }
            0x82EE7CAC => {
    //   block [0x82EE7CAC..0x82EE7CC0)
	// 82EE7CAC: EC00F9BA  fmadds f0, f0, f6, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[6].f64 + ctx.f[31].f64) as f32) as f64);
	// 82EE7CB0: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82EE7CB4: 4098000C  bge cr6, 0x82ee7cc0
	if !ctx.cr[6].lt {
	pc = 0x82EE7CC0; continue 'dispatch;
	}
	// 82EE7CB8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82EE7CBC: 48000024  b 0x82ee7ce0
	pc = 0x82EE7CE0; continue 'dispatch;
            }
            0x82EE7CC0 => {
    //   block [0x82EE7CC0..0x82EE7CDC)
	// 82EE7CC0: 54C9063F  clrlwi. r9, r6, 0x18
	ctx.r[9].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EE7CC4: 4182001C  beq 0x82ee7ce0
	if ctx.cr[0].eq {
	pc = 0x82EE7CE0; continue 'dispatch;
	}
	// 82EE7CC8: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7CCC: ED850272  fmuls f12, f5, f9
	ctx.f[12].f64 = (((ctx.f[5].f64 * ctx.f[9].f64) as f32) as f64);
	// 82EE7CD0: C1AA0008  lfs f13, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE7CD4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE7CD8: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	pc = 0x82EE7CDC; continue 'dispatch;
            }
            0x82EE7CDC => {
    //   block [0x82EE7CDC..0x82EE7CE0)
	// 82EE7CDC: 4199FCA4  bgt cr6, 0x82ee7980
	if ctx.cr[6].gt {
	pc = 0x82EE7980; continue 'dispatch;
	}
	pc = 0x82EE7CE0; continue 'dispatch;
            }
            0x82EE7CE0 => {
    //   block [0x82EE7CE0..0x82EE7CF4)
	// 82EE7CE0: FF014000  fcmpu cr6, f1, f8
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[8].f64);
	// 82EE7CE4: 41980010  blt cr6, 0x82ee7cf4
	if ctx.cr[6].lt {
	pc = 0x82EE7CF4; continue 'dispatch;
	}
	// 82EE7CE8: 814A0020  lwz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EE7CEC: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82EE7CF0: 4800000C  b 0x82ee7cfc
	pc = 0x82EE7CFC; continue 'dispatch;
            }
            0x82EE7CF4 => {
    //   block [0x82EE7CF4..0x82EE7CFC)
	// 82EE7CF4: 814A001C  lwz r10, 0x1c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE7CF8: 616B0008  ori r11, r11, 8
	ctx.r[11].u64 = ctx.r[11].u64 | 8;
	pc = 0x82EE7CFC; continue 'dispatch;
            }
            0x82EE7CFC => {
    //   block [0x82EE7CFC..0x82EE7D08)
	// 82EE7CFC: 55690739  rlwinm. r9, r11, 0, 0x1c, 0x1c
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EE7D00: 41820008  beq 0x82ee7d08
	if ctx.cr[0].eq {
	pc = 0x82EE7D08; continue 'dispatch;
	}
	// 82EE7D04: 556B0776  rlwinm r11, r11, 0, 0x1d, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	pc = 0x82EE7D08; continue 'dispatch;
            }
            0x82EE7D08 => {
    //   block [0x82EE7D08..0x82EE7D14)
	// 82EE7D08: 5569077B  rlwinm. r9, r11, 0, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82EE7D0C: 41820008  beq 0x82ee7d14
	if ctx.cr[0].eq {
	pc = 0x82EE7D14; continue 'dispatch;
	}
	// 82EE7D10: 556B07B8  rlwinm r11, r11, 0, 0x1e, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	pc = 0x82EE7D14; continue 'dispatch;
            }
            0x82EE7D14 => {
    //   block [0x82EE7D14..0x82EE7D20)
	// 82EE7D14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EE7D18: 409AFE8C  bne cr6, 0x82ee7ba4
	if !ctx.cr[6].eq {
	pc = 0x82EE7BA4; continue 'dispatch;
	}
	// 82EE7D1C: 48000028  b 0x82ee7d44
	pc = 0x82EE7D44; continue 'dispatch;
            }
            0x82EE7D20 => {
    //   block [0x82EE7D20..0x82EE7D44)
	// 82EE7D20: 81650008  lwz r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE7D24: 9BCB0030  stb r30, 0x30(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[30].u8 ) };
	// 82EE7D28: 81650008  lwz r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE7D2C: 81250010  lwz r9, 0x10(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EE7D30: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EE7D34: 912B002C  stw r9, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 82EE7D38: 81650008  lwz r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE7D3C: 91450008  stw r10, 8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EE7D40: 91650010  stw r11, 0x10(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE7D44; continue 'dispatch;
            }
            0x82EE7D44 => {
    //   block [0x82EE7D44..0x82EE7DD0)
	// 82EE7D44: 81650008  lwz r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE7D48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE7D4C: 409AFFD4  bne cr6, 0x82ee7d20
	if !ctx.cr[6].eq {
	pc = 0x82EE7D20; continue 'dispatch;
	}
	// 82EE7D50: 93C5000C  stw r30, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82EE7D54: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EE7D58: 93C50014  stw r30, 0x14(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82EE7D5C: C01F0074  lfs f0, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7D60: EC0026FA  fmadds f0, f0, f27, f4
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[27].f64 + ctx.f[4].f64) as f32) as f64);
	// 82EE7D64: C1BF0014  lfs f13, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE7D68: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE7D6C: C19F0108  lfs f12, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE7D70: C3FF00C0  lfs f31, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EE7D74: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EE7D78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EE7D7C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EE7D80: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EE7D84: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82EE7D88: EC400332  fmuls f2, f0, f12
	ctx.f[2].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82EE7D8C: D05F00C0  stfs f2, 0xc0(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82EE7D90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE7D94: 4E800421  bctrl
	ctx.lr = 0x82EE7D98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE7D98: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE7D9C: 809F00D4  lwz r4, 0xd4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EE7DA0: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82EE7DA4: D3FF00C0  stfs f31, 0xc0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82EE7DA8: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 82EE7DAC: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82EE7DB0: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82EE7DB4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EE7DB8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EE7DBC: 4BFFFA45  bl 0x82ee7800
	ctx.lr = 0x82EE7DC0;
	sub_82EE7800(ctx, base);
	// 82EE7DC0: 817F00D4  lwz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EE7DC4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EE7DC8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE7DCC: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
            }
            0x82EE7DD0 => {
    //   block [0x82EE7DD0..0x82EE7DF0)
	// 82EE7DD0: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82EE7DD4: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 82EE7DD8: 4BDC5F41  bl 0x82cadd18
	ctx.lr = 0x82EE7DDC;
	sub_82CADCEC(ctx, base);
	// 82EE7DDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE7DE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EE7DE4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EE7DE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EE7DEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE7DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE7DF0 size=1132
    let mut pc: u32 = 0x82EE7DF0;
    'dispatch: loop {
        match pc {
            0x82EE7DF0 => {
    //   block [0x82EE7DF0..0x82EE7E14)
	// 82EE7DF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE7DF4: 4BDC1605  bl 0x82ca93f8
	ctx.lr = 0x82EE7DF8;
	sub_82CA93D0(ctx, base);
	// 82EE7DF8: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 82EE7DFC: 4BDC5ECD  bl 0x82cadcc8
	ctx.lr = 0x82EE7E00;
	sub_82CADCA0(ctx, base);
	// 82EE7E00: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE7E04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE7E08: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82EE7E0C: 817F00D4  lwz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EE7E10: 48000028  b 0x82ee7e38
	pc = 0x82EE7E38; continue 'dispatch;
            }
            0x82EE7E14 => {
    //   block [0x82EE7E14..0x82EE7E38)
	// 82EE7E14: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE7E18: 9B8A0030  stb r28, 0x30(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(48 as u32), ctx.r[28].u8 ) };
	// 82EE7E1C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE7E20: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EE7E24: 812A002C  lwz r9, 0x2c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 82EE7E28: 910A002C  stw r8, 0x2c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(44 as u32), ctx.r[8].u32 ) };
	// 82EE7E2C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE7E30: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82EE7E34: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	pc = 0x82EE7E38; continue 'dispatch;
            }
            0x82EE7E38 => {
    //   block [0x82EE7E38..0x82EE7E98)
	// 82EE7E38: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE7E3C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EE7E40: 409AFFD4  bne cr6, 0x82ee7e14
	if !ctx.cr[6].eq {
	pc = 0x82EE7E14; continue 'dispatch;
	}
	// 82EE7E44: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82EE7E48: 938B000C  stw r28, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82EE7E4C: 938B0014  stw r28, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[28].u32 ) };
	// 82EE7E50: 3F008200  lis r24, -0x7e00
	ctx.r[24].s64 = -2113929216;
	// 82EE7E54: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EE7E58: C01F0074  lfs f0, 0x74(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7E5C: C1BF0014  lfs f13, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE7E60: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 82EE7E64: C37F00C0  lfs f27, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82EE7E68: 7F9BE378  mr r27, r28
	ctx.r[27].u64 = ctx.r[28].u64;
	// 82EE7E6C: C30A0BFC  lfs f24, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 82EE7E70: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EE7E74: C0380C18  lfs f1, 0xc18(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(3096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82EE7E78: EDA06E3A  fmadds f13, f0, f24, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[24].f64 + ctx.f[13].f64) as f32) as f64);
	// 82EE7E7C: 3BCAAFB4  addi r30, r10, -0x504c
	ctx.r[30].s64 = ctx.r[10].s64 + -20556;
	// 82EE7E80: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE7E84: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82EE7E88: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 82EE7E8C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82EE7E90: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE7E94: 48000064  b 0x82ee7ef8
	pc = 0x82EE7EF8; continue 'dispatch;
            }
            0x82EE7E98 => {
    //   block [0x82EE7E98..0x82EE7EB0)
	// 82EE7E98: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82EE7E9C: 409A0014  bne cr6, 0x82ee7eb0
	if !ctx.cr[6].eq {
	pc = 0x82EE7EB0; continue 'dispatch;
	}
	// 82EE7EA0: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7EA4: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82EE7EA8: 41980008  blt cr6, 0x82ee7eb0
	if ctx.cr[6].lt {
	pc = 0x82EE7EB0; continue 'dispatch;
	}
	// 82EE7EAC: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	pc = 0x82EE7EB0; continue 'dispatch;
            }
            0x82EE7EB0 => {
    //   block [0x82EE7EB0..0x82EE7ED8)
	// 82EE7EB0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82EE7EB4: 409A0024  bne cr6, 0x82ee7ed8
	if !ctx.cr[6].eq {
	pc = 0x82EE7ED8; continue 'dispatch;
	}
	// 82EE7EB8: FC006850  fneg f0, f13
	ctx.f[0].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE7EBC: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE7EC0: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82EE7EC4: 40990030  ble cr6, 0x82ee7ef4
	if !ctx.cr[6].gt {
	pc = 0x82EE7EF4; continue 'dispatch;
	}
	// 82EE7EC8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82EE7ECC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE7ED0: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82EE7ED4: 419A0020  beq cr6, 0x82ee7ef4
	if ctx.cr[6].eq {
	pc = 0x82EE7EF4; continue 'dispatch;
	}
	pc = 0x82EE7ED8; continue 'dispatch;
            }
            0x82EE7ED8 => {
    //   block [0x82EE7ED8..0x82EE7EE8)
	// 82EE7ED8: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7EDC: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82EE7EE0: 40980008  bge cr6, 0x82ee7ee8
	if !ctx.cr[6].lt {
	pc = 0x82EE7EE8; continue 'dispatch;
	}
	// 82EE7EE4: FF600090  fmr f27, f0
	ctx.f[27].f64 = ctx.f[0].f64;
	pc = 0x82EE7EE8; continue 'dispatch;
            }
            0x82EE7EE8 => {
    //   block [0x82EE7EE8..0x82EE7EF4)
	// 82EE7EE8: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7EEC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE7EF0: 41990014  bgt cr6, 0x82ee7f04
	if ctx.cr[6].gt {
	pc = 0x82EE7F04; continue 'dispatch;
	}
	pc = 0x82EE7EF4; continue 'dispatch;
            }
            0x82EE7EF4 => {
    //   block [0x82EE7EF4..0x82EE7EF8)
	// 82EE7EF4: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	pc = 0x82EE7EF8; continue 'dispatch;
            }
            0x82EE7EF8 => {
    //   block [0x82EE7EF8..0x82EE7F04)
	// 82EE7EF8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE7EFC: 4082FF9C  bne 0x82ee7e98
	if !ctx.cr[0].eq {
	pc = 0x82EE7E98; continue 'dispatch;
	}
	// 82EE7F00: 48000008  b 0x82ee7f08
	pc = 0x82EE7F08; continue 'dispatch;
            }
            0x82EE7F04 => {
    //   block [0x82EE7F04..0x82EE7F08)
	// 82EE7F04: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	pc = 0x82EE7F08; continue 'dispatch;
            }
            0x82EE7F08 => {
    //   block [0x82EE7F08..0x82EE7FB8)
	// 82EE7F08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE7F0C: 7F99E378  mr r25, r28
	ctx.r[25].u64 = ctx.r[28].u64;
	// 82EE7F10: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EE7F14: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 82EE7F18: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82EE7F1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EE7F20: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82EE7F24: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EE7F28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE7F2C: 4E800421  bctrl
	ctx.lr = 0x82EE7F30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE7F30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE7F34: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EE7F38: 809F00D4  lwz r4, 0xd4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EE7F3C: 3B4BAFB4  addi r26, r11, -0x504c
	ctx.r[26].s64 = ctx.r[11].s64 + -20556;
	// 82EE7F40: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 82EE7F44: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 82EE7F48: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EE7F4C: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82EE7F50: 4BFFF8B1  bl 0x82ee7800
	ctx.lr = 0x82EE7F54;
	sub_82EE7800(ctx, base);
	// 82EE7F54: C01F00C0  lfs f0, 0xc0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7F58: FF1B0000  fcmpu cr6, f27, f0
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[0].f64);
	// 82EE7F5C: 419A02F0  beq cr6, 0x82ee824c
	if ctx.cr[6].eq {
	pc = 0x82EE824C; continue 'dispatch;
	}
	// 82EE7F60: C01F0108  lfs f0, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7F64: C1BF00C8  lfs f13, 0xc8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE7F68: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82EE7F6C: FF1B0000  fcmpu cr6, f27, f0
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[0].f64);
	// 82EE7F70: 419902DC  bgt cr6, 0x82ee824c
	if ctx.cr[6].gt {
	pc = 0x82EE824C; continue 'dispatch;
	}
	// 82EE7F74: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EE7F78: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE7F7C: 41820044  beq 0x82ee7fc0
	if ctx.cr[0].eq {
	pc = 0x82EE7FC0; continue 'dispatch;
	}
	// 82EE7F80: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82EE7F84: C01F001C  lfs f0, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7F88: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE7F8C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE7F90: 40980030  bge cr6, 0x82ee7fc0
	if !ctx.cr[6].lt {
	pc = 0x82EE7FC0; continue 'dispatch;
	}
	// 82EE7F94: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82EE7F98: 817F00D4  lwz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EE7F9C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE7FA0: EC000632  fmuls f0, f0, f24
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[24].f64) as f32) as f64);
	// 82EE7FA4: C1AB001C  lfs f13, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE7FA8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EE7FAC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE7FB0: 41980008  blt cr6, 0x82ee7fb8
	if ctx.cr[6].lt {
	pc = 0x82EE7FB8; continue 'dispatch;
	}
	// 82EE7FB4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
            }
            0x82EE7FB8 => {
    //   block [0x82EE7FB8..0x82EE7FC0)
	// 82EE7FB8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE7FBC: 41820008  beq 0x82ee7fc4
	if ctx.cr[0].eq {
	pc = 0x82EE7FC4; continue 'dispatch;
	}
	pc = 0x82EE7FC0; continue 'dispatch;
            }
            0x82EE7FC0 => {
    //   block [0x82EE7FC0..0x82EE7FC4)
	// 82EE7FC0: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	pc = 0x82EE7FC4; continue 'dispatch;
            }
            0x82EE7FC4 => {
    //   block [0x82EE7FC4..0x82EE8014)
	// 82EE7FC4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82EE7FC8: C01F0074  lfs f0, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE7FCC: C1BF0040  lfs f13, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE7FD0: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EE7FD4: 3BAB9128  addi r29, r11, -0x6ed8
	ctx.r[29].s64 = ctx.r[11].s64 + -28376;
	// 82EE7FD8: EFA06E3C  fnmsubs f29, f0, f24, f13
	ctx.f[29].f64 = -(((ctx.f[0].f64 * ctx.f[24].f64 - ctx.f[13].f64) as f32) as f64);
	// 82EE7FDC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE7FE0: C3FF0010  lfs f31, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82EE7FE4: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82EE7FE8: FFC0D890  fmr f30, f27
	ctx.f[30].f64 = ctx.f[27].f64;
	// 82EE7FEC: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EE7FF0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82EE7FF4: 93A100D0  stw r29, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[29].u32 ) };
	// 82EE7FF8: C34B0C14  lfs f26, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82EE7FFC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82EE8000: FF80D090  fmr f28, f26
	ctx.f[28].f64 = ctx.f[26].f64;
	// 82EE8004: FF1FE800  fcmpu cr6, f31, f29
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[29].f64);
	// 82EE8008: C32B0C80  lfs f25, 0xc80(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3200 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82EE800C: 4098010C  bge cr6, 0x82ee8118
	if !ctx.cr[6].lt {
	pc = 0x82EE8118; continue 'dispatch;
	}
	// 82EE8010: 48000008  b 0x82ee8018
	pc = 0x82EE8018; continue 'dispatch;
            }
            0x82EE8014 => {
    //   block [0x82EE8014..0x82EE8018)
	// 82EE8014: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	pc = 0x82EE8018; continue 'dispatch;
            }
            0x82EE8018 => {
    //   block [0x82EE8018..0x82EE8030)
	// 82EE8018: C01F0074  lfs f0, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE801C: EDA0FE3A  fmadds f13, f0, f24, f31
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[24].f64 + ctx.f[31].f64) as f32) as f64);
	// 82EE8020: C18A000C  lfs f12, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE8024: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82EE8028: C1980C18  lfs f12, 0xc18(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82EE802C: 4099004C  ble cr6, 0x82ee8078
	if !ctx.cr[6].gt {
	pc = 0x82EE8078; continue 'dispatch;
	}
	pc = 0x82EE8030; continue 'dispatch;
            }
            0x82EE8030 => {
    //   block [0x82EE8030..0x82EE806C)
	// 82EE8030: 814A0020  lwz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82EE8034: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82EE8038: C00A0010  lfs f0, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE803C: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82EE8040: 4098002C  bge cr6, 0x82ee806c
	if !ctx.cr[6].lt {
	pc = 0x82EE806C; continue 'dispatch;
	}
	// 82EE8044: FFC00090  fmr f30, f0
	ctx.f[30].f64 = ctx.f[0].f64;
	// 82EE8048: FF1E6000  fcmpu cr6, f30, f12
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[12].f64);
	// 82EE804C: 419A002C  beq cr6, 0x82ee8078
	if ctx.cr[6].eq {
	pc = 0x82EE8078; continue 'dispatch;
	}
	// 82EE8050: 896A0018  lbz r11, 0x18(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EE8054: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE8058: 40820014  bne 0x82ee806c
	if !ctx.cr[0].eq {
	pc = 0x82EE806C; continue 'dispatch;
	}
	// 82EE805C: C01F010C  lfs f0, 0x10c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE8060: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 82EE8064: 40980008  bge cr6, 0x82ee806c
	if !ctx.cr[6].lt {
	pc = 0x82EE806C; continue 'dispatch;
	}
	// 82EE8068: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	pc = 0x82EE806C; continue 'dispatch;
            }
            0x82EE806C => {
    //   block [0x82EE806C..0x82EE8078)
	// 82EE806C: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE8070: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE8074: 4199FFBC  bgt cr6, 0x82ee8030
	if ctx.cr[6].gt {
	pc = 0x82EE8030; continue 'dispatch;
	}
	pc = 0x82EE8078; continue 'dispatch;
            }
            0x82EE8078 => {
    //   block [0x82EE8078..0x82EE80BC)
	// 82EE8078: FF1E6000  fcmpu cr6, f30, f12
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[12].f64);
	// 82EE807C: 409900A0  ble cr6, 0x82ee811c
	if !ctx.cr[6].gt {
	pc = 0x82EE811C; continue 'dispatch;
	}
	// 82EE8080: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE8084: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 82EE8088: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82EE808C: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82EE8090: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EE8094: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EE8098: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82EE809C: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EE80A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE80A4: 4E800421  bctrl
	ctx.lr = 0x82EE80A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE80A8: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE80AC: 41820010  beq 0x82ee80bc
	if ctx.cr[0].eq {
	pc = 0x82EE80BC; continue 'dispatch;
	}
	// 82EE80B0: C00100B0  lfs f0, 0xb0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE80B4: EC00D02A  fadds f0, f0, f26
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[26].f64) as f32) as f64;
	// 82EE80B8: D00100B0  stfs f0, 0xb0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
            }
            0x82EE80BC => {
    //   block [0x82EE80BC..0x82EE80C8)
	// 82EE80BC: 809F00D4  lwz r4, 0xd4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EE80C0: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE80C4: 48000018  b 0x82ee80dc
	pc = 0x82EE80DC; continue 'dispatch;
            }
            0x82EE80C8 => {
    //   block [0x82EE80C8..0x82EE80DC)
	// 82EE80C8: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE80CC: C1A100B0  lfs f13, 0xb0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE80D0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE80D4: 40980010  bge cr6, 0x82ee80e4
	if !ctx.cr[6].lt {
	pc = 0x82EE80E4; continue 'dispatch;
	}
	// 82EE80D8: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	pc = 0x82EE80DC; continue 'dispatch;
            }
            0x82EE80DC => {
    //   block [0x82EE80DC..0x82EE80E4)
	// 82EE80DC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE80E0: 4082FFE8  bne 0x82ee80c8
	if !ctx.cr[0].eq {
	pc = 0x82EE80C8; continue 'dispatch;
	}
	pc = 0x82EE80E4; continue 'dispatch;
            }
            0x82EE80E4 => {
    //   block [0x82EE80E4..0x82EE8118)
	// 82EE80E4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EE80E8: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82EE80EC: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 82EE80F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EE80F4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EE80F8: 4BFFF709  bl 0x82ee7800
	ctx.lr = 0x82EE80FC;
	sub_82EE7800(ctx, base);
	// 82EE80FC: FC00E090  fmr f0, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[28].f64;
	// 82EE8100: C1BF0010  lfs f13, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE8104: EF9C0672  fmuls f28, f28, f25
	ctx.f[28].f64 = (((ctx.f[28].f64 * ctx.f[25].f64) as f32) as f64);
	// 82EE8108: 93A100A0  stw r29, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[29].u32 ) };
	// 82EE810C: EFEDF83A  fmadds f31, f13, f0, f31
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64);
	// 82EE8110: FF1FE800  fcmpu cr6, f31, f29
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[29].f64);
	// 82EE8114: 4198FF00  blt cr6, 0x82ee8014
	if ctx.cr[6].lt {
	pc = 0x82EE8014; continue 'dispatch;
	}
	pc = 0x82EE8118; continue 'dispatch;
            }
            0x82EE8118 => {
    //   block [0x82EE8118..0x82EE811C)
	// 82EE8118: C1980C18  lfs f12, 0xc18(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EE811C; continue 'dispatch;
            }
            0x82EE811C => {
    //   block [0x82EE811C..0x82EE8148)
	// 82EE811C: C01F0010  lfs f0, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE8120: FF80E850  fneg f28, f29
	ctx.f[28].u64 = ctx.f[29].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE8124: FFE00050  fneg f31, f0
	ctx.f[31].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82EE8128: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82EE812C: FFC0D890  fmr f30, f27
	ctx.f[30].f64 = ctx.f[27].f64;
	// 82EE8130: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82EE8134: FFA0D090  fmr f29, f26
	ctx.f[29].f64 = ctx.f[26].f64;
	// 82EE8138: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EE813C: FF1FE000  fcmpu cr6, f31, f28
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[28].f64);
	// 82EE8140: 4099010C  ble cr6, 0x82ee824c
	if !ctx.cr[6].gt {
	pc = 0x82EE824C; continue 'dispatch;
	}
	// 82EE8144: 4800000C  b 0x82ee8150
	pc = 0x82EE8150; continue 'dispatch;
            }
            0x82EE8148 => {
    //   block [0x82EE8148..0x82EE8150)
	// 82EE8148: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82EE814C: C1980C18  lfs f12, 0xc18(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82EE8150; continue 'dispatch;
            }
            0x82EE8150 => {
    //   block [0x82EE8150..0x82EE8164)
	// 82EE8150: C01F0074  lfs f0, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE8154: EDA0FE3C  fnmsubs f13, f0, f24, f31
	ctx.f[13].f64 = -(((ctx.f[0].f64 * ctx.f[24].f64 - ctx.f[31].f64) as f32) as f64);
	// 82EE8158: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82EE815C: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82EE8160: 4098004C  bge cr6, 0x82ee81ac
	if !ctx.cr[6].lt {
	pc = 0x82EE81AC; continue 'dispatch;
	}
	pc = 0x82EE8164; continue 'dispatch;
            }
            0x82EE8164 => {
    //   block [0x82EE8164..0x82EE81A0)
	// 82EE8164: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE8168: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82EE816C: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE8170: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82EE8174: 4098002C  bge cr6, 0x82ee81a0
	if !ctx.cr[6].lt {
	pc = 0x82EE81A0; continue 'dispatch;
	}
	// 82EE8178: FFC00090  fmr f30, f0
	ctx.f[30].f64 = ctx.f[0].f64;
	// 82EE817C: FF1E6000  fcmpu cr6, f30, f12
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[12].f64);
	// 82EE8180: 419A002C  beq cr6, 0x82ee81ac
	if ctx.cr[6].eq {
	pc = 0x82EE81AC; continue 'dispatch;
	}
	// 82EE8184: 894B0018  lbz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82EE8188: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE818C: 40820014  bne 0x82ee81a0
	if !ctx.cr[0].eq {
	pc = 0x82EE81A0; continue 'dispatch;
	}
	// 82EE8190: C01F010C  lfs f0, 0x10c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE8194: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 82EE8198: 40980008  bge cr6, 0x82ee81a0
	if !ctx.cr[6].lt {
	pc = 0x82EE81A0; continue 'dispatch;
	}
	// 82EE819C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	pc = 0x82EE81A0; continue 'dispatch;
            }
            0x82EE81A0 => {
    //   block [0x82EE81A0..0x82EE81AC)
	// 82EE81A0: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE81A4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82EE81A8: 4198FFBC  blt cr6, 0x82ee8164
	if ctx.cr[6].lt {
	pc = 0x82EE8164; continue 'dispatch;
	}
	pc = 0x82EE81AC; continue 'dispatch;
            }
            0x82EE81AC => {
    //   block [0x82EE81AC..0x82EE81F0)
	// 82EE81AC: FF1E6000  fcmpu cr6, f30, f12
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[12].f64);
	// 82EE81B0: 4099009C  ble cr6, 0x82ee824c
	if !ctx.cr[6].gt {
	pc = 0x82EE824C; continue 'dispatch;
	}
	// 82EE81B4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE81B8: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 82EE81BC: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82EE81C0: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82EE81C4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82EE81C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EE81CC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EE81D0: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82EE81D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE81D8: 4E800421  bctrl
	ctx.lr = 0x82EE81DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE81DC: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE81E0: 41820010  beq 0x82ee81f0
	if ctx.cr[0].eq {
	pc = 0x82EE81F0; continue 'dispatch;
	}
	// 82EE81E4: C0010080  lfs f0, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE81E8: EC00D02A  fadds f0, f0, f26
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[26].f64) as f32) as f64;
	// 82EE81EC: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
            }
            0x82EE81F0 => {
    //   block [0x82EE81F0..0x82EE81FC)
	// 82EE81F0: 809F00D4  lwz r4, 0xd4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EE81F4: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE81F8: 48000018  b 0x82ee8210
	pc = 0x82EE8210; continue 'dispatch;
            }
            0x82EE81FC => {
    //   block [0x82EE81FC..0x82EE8210)
	// 82EE81FC: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE8200: C1A10080  lfs f13, 0x80(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE8204: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82EE8208: 40980010  bge cr6, 0x82ee8218
	if !ctx.cr[6].lt {
	pc = 0x82EE8218; continue 'dispatch;
	}
	// 82EE820C: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	pc = 0x82EE8210; continue 'dispatch;
            }
            0x82EE8210 => {
    //   block [0x82EE8210..0x82EE8218)
	// 82EE8210: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE8214: 4082FFE8  bne 0x82ee81fc
	if !ctx.cr[0].eq {
	pc = 0x82EE81FC; continue 'dispatch;
	}
	pc = 0x82EE8218; continue 'dispatch;
            }
            0x82EE8218 => {
    //   block [0x82EE8218..0x82EE824C)
	// 82EE8218: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82EE821C: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82EE8220: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82EE8224: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EE8228: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EE822C: 4BFFF5D5  bl 0x82ee7800
	ctx.lr = 0x82EE8230;
	sub_82EE7800(ctx, base);
	// 82EE8230: FC00E890  fmr f0, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[29].f64;
	// 82EE8234: C1BF0010  lfs f13, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82EE8238: EFBD0672  fmuls f29, f29, f25
	ctx.f[29].f64 = (((ctx.f[29].f64 * ctx.f[25].f64) as f32) as f64);
	// 82EE823C: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82EE8240: EFEDF83C  fnmsubs f31, f13, f0, f31
	ctx.f[31].f64 = -(((ctx.f[13].f64 * ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82EE8244: FF1FE000  fcmpu cr6, f31, f28
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[28].f64);
	// 82EE8248: 4199FF00  bgt cr6, 0x82ee8148
	if ctx.cr[6].gt {
	pc = 0x82EE8148; continue 'dispatch;
	}
	pc = 0x82EE824C; continue 'dispatch;
            }
            0x82EE824C => {
    //   block [0x82EE824C..0x82EE825C)
	// 82EE824C: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 82EE8250: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 82EE8254: 4BDC5AC1  bl 0x82cadd14
	ctx.lr = 0x82EE8258;
	sub_82CADCEC(ctx, base);
	// 82EE8258: 4BDC11F0  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82EE8260 size=200
    let mut pc: u32 = 0x82EE8260;
    'dispatch: loop {
        match pc {
            0x82EE8260 => {
    //   block [0x82EE8260..0x82EE82B0)
	// 82EE8260: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE8264: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EE8268: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82EE826C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EE8270: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE8274: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EE8278: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82EE827C: 897F00F9  lbz r11, 0xf9(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(249 as u32) ) } as u64;
	// 82EE8280: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EE8284: 41820080  beq 0x82ee8304
	if ctx.cr[0].eq {
	pc = 0x82EE8304; continue 'dispatch;
	}
	// 82EE8288: 9BDF00F9  stb r30, 0xf9(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(249 as u32), ctx.r[30].u8 ) };
	// 82EE828C: 4BFFF6A5  bl 0x82ee7930
	ctx.lr = 0x82EE8290;
	sub_82EE7930(ctx, base);
	// 82EE8290: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE8294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE8298: 41820018  beq 0x82ee82b0
	if ctx.cr[0].eq {
	pc = 0x82EE82B0; continue 'dispatch;
	}
	// 82EE829C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE82A0: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EE82A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE82A8: 4E800421  bctrl
	ctx.lr = 0x82EE82AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE82AC: 48000064  b 0x82ee8310
	pc = 0x82EE8310; continue 'dispatch;
            }
            0x82EE82B0 => {
    //   block [0x82EE82B0..0x82EE82E0)
	// 82EE82B0: 4BFFFB41  bl 0x82ee7df0
	ctx.lr = 0x82EE82B4;
	sub_82EE7DF0(ctx, base);
	// 82EE82B4: 817F00D4  lwz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EE82B8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE82BC: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 82EE82C0: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EE82C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE82C8: 409A003C  bne cr6, 0x82ee8304
	if !ctx.cr[6].eq {
	pc = 0x82EE8304; continue 'dispatch;
	}
	// 82EE82CC: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82EE82D0: C01F002C  lfs f0, 0x2c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82EE82D4: D01F00FC  stfs f0, 0xfc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82EE82D8: 917F0114  stw r11, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 82EE82DC: 48000028  b 0x82ee8304
	pc = 0x82EE8304; continue 'dispatch;
            }
            0x82EE82E0 => {
    //   block [0x82EE82E0..0x82EE8304)
	// 82EE82E0: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82EE82E4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82EE82E8: 40980028  bge cr6, 0x82ee8310
	if !ctx.cr[6].lt {
	pc = 0x82EE8310; continue 'dispatch;
	}
	// 82EE82EC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE82F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82EE82F4: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82EE82F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE82FC: 4E800421  bctrl
	ctx.lr = 0x82EE8300;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE8300: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
            }
            0x82EE8304 => {
    //   block [0x82EE8304..0x82EE8310)
	// 82EE8304: 817F00F4  lwz r11, 0xf4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE8308: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE830C: 409AFFD4  bne cr6, 0x82ee82e0
	if !ctx.cr[6].eq {
	pc = 0x82EE82E0; continue 'dispatch;
	}
	pc = 0x82EE8310; continue 'dispatch;
            }
            0x82EE8310 => {
    //   block [0x82EE8310..0x82EE8328)
	// 82EE8310: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EE8314: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE8318: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EE831C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EE8320: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EE8324: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EE8328 size=348
    let mut pc: u32 = 0x82EE8328;
    'dispatch: loop {
        match pc {
            0x82EE8328 => {
    //   block [0x82EE8328..0x82EE8384)
	// 82EE8328: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE832C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EE8330: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE8334: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EE8338: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE833C: 396BBE18  addi r11, r11, -0x41e8
	ctx.r[11].s64 = ctx.r[11].s64 + -16872;
	// 82EE8340: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EE8344: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EE8348: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EE834C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE8350: 914B0360  stw r10, 0x360(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(864 as u32), ctx.r[10].u32 ) };
	// 82EE8354: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EE8358: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE835C: B14B0008  sth r10, 8(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u16 ) };
	// 82EE8360: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EE8364: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE8368: F94B0108  std r10, 0x108(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(264 as u32), ctx.r[10].u64 ) };
	// 82EE836C: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EE8370: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE8374: F94B0358  std r10, 0x358(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(856 as u32), ctx.r[10].u64 ) };
	// 82EE8378: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE837C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EE8380: 48000010  b 0x82ee8390
	pc = 0x82EE8390; continue 'dispatch;
            }
            0x82EE8384 => {
    //   block [0x82EE8384..0x82EE8390)
	// 82EE8384: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EE8388: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EE838C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE8390; continue 'dispatch;
            }
            0x82EE8390 => {
    //   block [0x82EE8390..0x82EE83B8)
	// 82EE8390: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EE8394: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82EE8398: 40980020  bge cr6, 0x82ee83b8
	if !ctx.cr[6].lt {
	pc = 0x82EE83B8; continue 'dispatch;
	}
	// 82EE839C: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EE83A0: 396B0118  addi r11, r11, 0x118
	ctx.r[11].s64 = ctx.r[11].s64 + 280;
	// 82EE83A4: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EE83A8: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EE83AC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EE83B0: 7D2B512A  stdx r9, r11, r10
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u64) };
	// 82EE83B4: 4BFFFFD0  b 0x82ee8384
	pc = 0x82EE8384; continue 'dispatch;
            }
            0x82EE83B8 => {
    //   block [0x82EE83B8..0x82EE840C)
	// 82EE83B8: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EE83BC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE83C0: F94B0130  std r10, 0x130(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(304 as u32), ctx.r[10].u64 ) };
	// 82EE83C4: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EE83C8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EE83CC: F94B0110  std r10, 0x110(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(272 as u32), ctx.r[10].u64 ) };
	// 82EE83D0: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EE83D4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE83D8: 994B0364  stb r10, 0x364(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(868 as u32), ctx.r[10].u8 ) };
	// 82EE83DC: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EE83E0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE83E4: 994B0365  stb r10, 0x365(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(869 as u32), ctx.r[10].u8 ) };
	// 82EE83E8: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EE83EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE83F0: B14B0148  sth r10, 0x148(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(328 as u32), ctx.r[10].u16 ) };
	// 82EE83F4: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EE83F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE83FC: B14B0248  sth r10, 0x248(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(584 as u32), ctx.r[10].u16 ) };
	// 82EE8400: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE8404: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EE8408: 48000010  b 0x82ee8418
	pc = 0x82EE8418; continue 'dispatch;
            }
            0x82EE840C => {
    //   block [0x82EE840C..0x82EE8418)
	// 82EE840C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EE8410: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EE8414: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE8418; continue 'dispatch;
            }
            0x82EE8418 => {
    //   block [0x82EE8418..0x82EE843C)
	// 82EE8418: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EE841C: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 82EE8420: 4098001C  bge cr6, 0x82ee843c
	if !ctx.cr[6].lt {
	pc = 0x82EE843C; continue 'dispatch;
	}
	// 82EE8424: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EE8428: 396B0348  addi r11, r11, 0x348
	ctx.r[11].s64 = ctx.r[11].s64 + 840;
	// 82EE842C: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EE8430: 392000FF  li r9, 0xff
	ctx.r[9].s64 = 255;
	// 82EE8434: 7D2B51AE  stbx r9, r11, r10
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u8) };
	// 82EE8438: 4BFFFFD4  b 0x82ee840c
	pc = 0x82EE840C; continue 'dispatch;
            }
            0x82EE843C => {
    //   block [0x82EE843C..0x82EE8484)
	// 82EE843C: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EE8440: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE8444: 994B013C  stb r10, 0x13c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(316 as u32), ctx.r[10].u8 ) };
	// 82EE8448: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EE844C: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EE8450: 48000039  bl 0x82ee8488
	ctx.lr = 0x82EE8454;
	sub_82EE8488(ctx, base);
	// 82EE8454: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EE8458: 4B3365D1  bl 0x8221ea28
	ctx.lr = 0x82EE845C;
	sub_8221EA28(ctx, base);
	// 82EE845C: 4BDC1D75  bl 0x82caa1d0
	ctx.lr = 0x82EE8460;
	sub_82CAA1D0(ctx, base);
	// 82EE8460: 7C6B07B4  extsw r11, r3
	ctx.r[11].s64 = ctx.r[3].s32 as i64;
	// 82EE8464: E9410058  ld r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82EE8468: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EE846C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82EE8470: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EE8474: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EE8478: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE847C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EE8480: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8488 size=24
    let mut pc: u32 = 0x82EE8488;
    'dispatch: loop {
        match pc {
            0x82EE8488 => {
    //   block [0x82EE8488..0x82EE84A0)
	// 82EE8488: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE848C: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EE8490: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8494: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE8498: 914B0138  stw r10, 0x138(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(312 as u32), ctx.r[10].u32 ) };
	// 82EE849C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE84A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EE84A0 size=68
    let mut pc: u32 = 0x82EE84A0;
    'dispatch: loop {
        match pc {
            0x82EE84A0 => {
    //   block [0x82EE84A0..0x82EE84D0)
	// 82EE84A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE84A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EE84A8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE84AC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EE84B0: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EE84B4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EE84B8: 48000031  bl 0x82ee84e8
	ctx.lr = 0x82EE84BC;
	sub_82EE84E8(ctx, base);
	// 82EE84BC: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EE84C0: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE84C4: 4182000C  beq 0x82ee84d0
	if ctx.cr[0].eq {
	pc = 0x82EE84D0; continue 'dispatch;
	}
	// 82EE84C8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EE84CC: 4B95D2E5  bl 0x828457b0
	ctx.lr = 0x82EE84D0;
	sub_828457B0(ctx, base);
	pc = 0x82EE84D0; continue 'dispatch;
            }
            0x82EE84D0 => {
    //   block [0x82EE84D0..0x82EE84E4)
	// 82EE84D0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EE84D4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EE84D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE84DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EE84E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE84E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EE84E8 size=76
    let mut pc: u32 = 0x82EE84E8;
    'dispatch: loop {
        match pc {
            0x82EE84E8 => {
    //   block [0x82EE84E8..0x82EE8524)
	// 82EE84E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE84EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EE84F0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE84F4: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EE84F8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE84FC: 396BBE18  addi r11, r11, -0x41e8
	ctx.r[11].s64 = ctx.r[11].s64 + -16872;
	// 82EE8500: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EE8504: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EE8508: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EE850C: 816B0360  lwz r11, 0x360(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(864 as u32) ) } as u64;
	// 82EE8510: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE8514: 419A0010  beq cr6, 0x82ee8524
	if ctx.cr[6].eq {
	pc = 0x82EE8524; continue 'dispatch;
	}
	// 82EE8518: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EE851C: 806B0360  lwz r3, 0x360(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(864 as u32) ) } as u64;
	// 82EE8520: 4BBA2BB9  bl 0x82a8b0d8
	ctx.lr = 0x82EE8524;
	sub_82A8B0D8(ctx, base);
	pc = 0x82EE8524; continue 'dispatch;
            }
            0x82EE8524 => {
    //   block [0x82EE8524..0x82EE8534)
	// 82EE8524: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EE8528: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE852C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EE8530: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8538 size=16
    let mut pc: u32 = 0x82EE8538;
    'dispatch: loop {
        match pc {
            0x82EE8538 => {
    //   block [0x82EE8538..0x82EE8548)
	// 82EE8538: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE853C: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8540: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EE8544: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EE8548 size=228
    let mut pc: u32 = 0x82EE8548;
    'dispatch: loop {
        match pc {
            0x82EE8548 => {
    //   block [0x82EE8548..0x82EE8594)
	// 82EE8548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE854C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EE8550: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE8554: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EE8558: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EE855C: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EE8560: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE8564: 409A0058  bne cr6, 0x82ee85bc
	if !ctx.cr[6].eq {
	pc = 0x82EE85BC; continue 'dispatch;
	}
	// 82EE8568: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EE856C: 896B0364  lbz r11, 0x364(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(868 as u32) ) } as u64;
	// 82EE8570: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EE8574: 40820020  bne 0x82ee8594
	if !ctx.cr[0].eq {
	pc = 0x82EE8594; continue 'dispatch;
	}
	// 82EE8578: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EE857C: A16B0008  lhz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE8580: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EE8584: 40820010  bne 0x82ee8594
	if !ctx.cr[0].eq {
	pc = 0x82EE8594; continue 'dispatch;
	}
	// 82EE8588: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE858C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EE8590: 4800000C  b 0x82ee859c
	pc = 0x82EE859C; continue 'dispatch;
            }
            0x82EE8594 => {
    //   block [0x82EE8594..0x82EE859C)
	// 82EE8594: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EE8598: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE859C; continue 'dispatch;
            }
            0x82EE859C => {
    //   block [0x82EE859C..0x82EE85BC)
	// 82EE859C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EE85A0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EE85A4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EE85A8: 994B0364  stb r10, 0x364(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(868 as u32), ctx.r[10].u8 ) };
	// 82EE85AC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EE85B0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE85B4: B14B0008  sth r10, 8(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u16 ) };
	// 82EE85B8: 48000064  b 0x82ee861c
	pc = 0x82EE861C; continue 'dispatch;
            }
            0x82EE85BC => {
    //   block [0x82EE85BC..0x82EE85F0)
	// 82EE85BC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EE85C0: 896B0364  lbz r11, 0x364(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(868 as u32) ) } as u64;
	// 82EE85C4: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EE85C8: 40820028  bne 0x82ee85f0
	if !ctx.cr[0].eq {
	pc = 0x82EE85F0; continue 'dispatch;
	}
	// 82EE85CC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EE85D0: 388B0008  addi r4, r11, 8
	ctx.r[4].s64 = ctx.r[11].s64 + 8;
	// 82EE85D4: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EE85D8: 480035A1  bl 0x82eebb78
	ctx.lr = 0x82EE85DC;
	sub_82EEBB78(ctx, base);
	// 82EE85DC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE85E0: 41820010  beq 0x82ee85f0
	if ctx.cr[0].eq {
	pc = 0x82EE85F0; continue 'dispatch;
	}
	// 82EE85E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE85E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EE85EC: 4800000C  b 0x82ee85f8
	pc = 0x82EE85F8; continue 'dispatch;
            }
            0x82EE85F0 => {
    //   block [0x82EE85F0..0x82EE85F8)
	// 82EE85F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EE85F4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE85F8; continue 'dispatch;
            }
            0x82EE85F8 => {
    //   block [0x82EE85F8..0x82EE861C)
	// 82EE85F8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EE85FC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EE8600: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EE8604: 994B0364  stb r10, 0x364(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(868 as u32), ctx.r[10].u8 ) };
	// 82EE8608: 80A1007C  lwz r5, 0x7c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EE860C: 38800080  li r4, 0x80
	ctx.r[4].s64 = 128;
	// 82EE8610: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EE8614: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EE8618: 48208D01  bl 0x830f1318
	ctx.lr = 0x82EE861C;
	sub_830F1318(ctx, base);
	pc = 0x82EE861C; continue 'dispatch;
            }
            0x82EE861C => {
    //   block [0x82EE861C..0x82EE862C)
	// 82EE861C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EE8620: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE8624: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EE8628: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8630 size=16
    let mut pc: u32 = 0x82EE8630;
    'dispatch: loop {
        match pc {
            0x82EE8630 => {
    //   block [0x82EE8630..0x82EE8640)
	// 82EE8630: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE8634: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8638: E86B0108  ld r3, 0x108(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(264 as u32) ) };
	// 82EE863C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8640 size=96
    let mut pc: u32 = 0x82EE8640;
    'dispatch: loop {
        match pc {
            0x82EE8640 => {
    //   block [0x82EE8640..0x82EE8678)
	// 82EE8640: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE8644: F8810018  std r4, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.r[4].u64 ) };
	// 82EE8648: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE864C: 896B0364  lbz r11, 0x364(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(868 as u32) ) } as u64;
	// 82EE8650: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EE8654: 40820024  bne 0x82ee8678
	if !ctx.cr[0].eq {
	pc = 0x82EE8678; continue 'dispatch;
	}
	// 82EE8658: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE865C: E96B0108  ld r11, 0x108(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(264 as u32) ) };
	// 82EE8660: E9410018  ld r10, 0x18(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) };
	// 82EE8664: 7F2B5000  cmpd cr6, r11, r10
	ctx.cr[6].compare_i64(ctx.r[11].s64, ctx.r[10].s64, &mut ctx.xer);
	// 82EE8668: 409A0010  bne cr6, 0x82ee8678
	if !ctx.cr[6].eq {
	pc = 0x82EE8678; continue 'dispatch;
	}
	// 82EE866C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE8670: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EE8674: 4800000C  b 0x82ee8680
	pc = 0x82EE8680; continue 'dispatch;
            }
            0x82EE8678 => {
    //   block [0x82EE8678..0x82EE8680)
	// 82EE8678: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EE867C: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE8680; continue 'dispatch;
            }
            0x82EE8680 => {
    //   block [0x82EE8680..0x82EE86A0)
	// 82EE8680: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8684: 8141FFF0  lwz r10, -0x10(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EE8688: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EE868C: 994B0364  stb r10, 0x364(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(868 as u32), ctx.r[10].u8 ) };
	// 82EE8690: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8694: E9410018  ld r10, 0x18(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) };
	// 82EE8698: F94B0108  std r10, 0x108(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(264 as u32), ctx.r[10].u64 ) };
	// 82EE869C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE86A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE86A0 size=16
    let mut pc: u32 = 0x82EE86A0;
    'dispatch: loop {
        match pc {
            0x82EE86A0 => {
    //   block [0x82EE86A0..0x82EE86B0)
	// 82EE86A0: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE86A4: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE86A8: E86B0110  ld r3, 0x110(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(272 as u32) ) };
	// 82EE86AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE86B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE86B0 size=96
    let mut pc: u32 = 0x82EE86B0;
    'dispatch: loop {
        match pc {
            0x82EE86B0 => {
    //   block [0x82EE86B0..0x82EE86E8)
	// 82EE86B0: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE86B4: F8810018  std r4, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.r[4].u64 ) };
	// 82EE86B8: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE86BC: 896B0364  lbz r11, 0x364(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(868 as u32) ) } as u64;
	// 82EE86C0: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EE86C4: 40820024  bne 0x82ee86e8
	if !ctx.cr[0].eq {
	pc = 0x82EE86E8; continue 'dispatch;
	}
	// 82EE86C8: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE86CC: E96B0110  ld r11, 0x110(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(272 as u32) ) };
	// 82EE86D0: E9410018  ld r10, 0x18(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) };
	// 82EE86D4: 7F2B5000  cmpd cr6, r11, r10
	ctx.cr[6].compare_i64(ctx.r[11].s64, ctx.r[10].s64, &mut ctx.xer);
	// 82EE86D8: 409A0010  bne cr6, 0x82ee86e8
	if !ctx.cr[6].eq {
	pc = 0x82EE86E8; continue 'dispatch;
	}
	// 82EE86DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE86E0: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EE86E4: 4800000C  b 0x82ee86f0
	pc = 0x82EE86F0; continue 'dispatch;
            }
            0x82EE86E8 => {
    //   block [0x82EE86E8..0x82EE86F0)
	// 82EE86E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EE86EC: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE86F0; continue 'dispatch;
            }
            0x82EE86F0 => {
    //   block [0x82EE86F0..0x82EE8710)
	// 82EE86F0: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE86F4: 8141FFF0  lwz r10, -0x10(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EE86F8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EE86FC: 994B0364  stb r10, 0x364(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(868 as u32), ctx.r[10].u8 ) };
	// 82EE8700: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8704: E9410018  ld r10, 0x18(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) };
	// 82EE8708: F94B0110  std r10, 0x110(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(272 as u32), ctx.r[10].u64 ) };
	// 82EE870C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8710 size=92
    let mut pc: u32 = 0x82EE8710;
    'dispatch: loop {
        match pc {
            0x82EE8710 => {
    //   block [0x82EE8710..0x82EE8728)
	// 82EE8710: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE8714: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE8718: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82EE871C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE8720: 9161FFF8  stw r11, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[11].u32 ) };
	// 82EE8724: 48000010  b 0x82ee8734
	pc = 0x82EE8734; continue 'dispatch;
            }
            0x82EE8728 => {
    //   block [0x82EE8728..0x82EE8734)
	// 82EE8728: 8161FFF8  lwz r11, -8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE872C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EE8730: 9161FFF8  stw r11, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE8734; continue 'dispatch;
            }
            0x82EE8734 => {
    //   block [0x82EE8734..0x82EE8764)
	// 82EE8734: 8161FFF8  lwz r11, -8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE8738: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82EE873C: 40980028  bge cr6, 0x82ee8764
	if !ctx.cr[6].lt {
	pc = 0x82EE8764; continue 'dispatch;
	}
	// 82EE8740: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8744: 396B0118  addi r11, r11, 0x118
	ctx.r[11].s64 = ctx.r[11].s64 + 280;
	// 82EE8748: 8141FFF8  lwz r10, -8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE874C: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EE8750: E921FFF0  ld r9, -0x10(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EE8754: 7D6B502A  ldx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	// 82EE8758: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EE875C: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82EE8760: 4BFFFFC8  b 0x82ee8728
	pc = 0x82EE8728; continue 'dispatch;
            }
            0x82EE8764 => {
    //   block [0x82EE8764..0x82EE876C)
	// 82EE8764: E861FFF0  ld r3, -0x10(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EE8768: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8770 size=56
    let mut pc: u32 = 0x82EE8770;
    'dispatch: loop {
        match pc {
            0x82EE8770 => {
    //   block [0x82EE8770..0x82EE87A0)
	// 82EE8770: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE8774: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EE8778: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE877C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82EE8780: 40980020  bge cr6, 0x82ee87a0
	if !ctx.cr[6].lt {
	pc = 0x82EE87A0; continue 'dispatch;
	}
	// 82EE8784: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8788: 396B0118  addi r11, r11, 0x118
	ctx.r[11].s64 = ctx.r[11].s64 + 280;
	// 82EE878C: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE8790: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EE8794: 7C6B502A  ldx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	// 82EE8798: 4800000C  b 0x82ee87a4
	pc = 0x82EE87A4; continue 'dispatch;
	// 82EE879C: 48000008  b 0x82ee87a4
	pc = 0x82EE87A4; continue 'dispatch;
            }
            0x82EE87A0 => {
    //   block [0x82EE87A0..0x82EE87A4)
	// 82EE87A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EE87A4; continue 'dispatch;
            }
            0x82EE87A4 => {
    //   block [0x82EE87A4..0x82EE87A8)
	// 82EE87A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE87A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE87A8 size=88
    let mut pc: u32 = 0x82EE87A8;
    'dispatch: loop {
        match pc {
            0x82EE87A8 => {
    //   block [0x82EE87A8..0x82EE87FC)
	// 82EE87A8: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE87AC: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EE87B0: F8A10020  std r5, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[5].u64 ) };
	// 82EE87B4: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE87B8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EE87BC: 994B0364  stb r10, 0x364(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(868 as u32), ctx.r[10].u8 ) };
	// 82EE87C0: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE87C4: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82EE87C8: 40980034  bge cr6, 0x82ee87fc
	if !ctx.cr[6].lt {
	pc = 0x82EE87FC; continue 'dispatch;
	}
	// 82EE87CC: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE87D0: 396B0118  addi r11, r11, 0x118
	ctx.r[11].s64 = ctx.r[11].s64 + 280;
	// 82EE87D4: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE87D8: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EE87DC: 7D6B502A  ldx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	// 82EE87E0: E9410020  ld r10, 0x20(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 82EE87E4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EE87E8: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE87EC: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EE87F0: 81210014  lwz r9, 0x14(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE87F4: 39290118  addi r9, r9, 0x118
	ctx.r[9].s64 = ctx.r[9].s64 + 280;
	// 82EE87F8: 7D69512A  stdx r11, r9, r10
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u64) };
	pc = 0x82EE87FC; continue 'dispatch;
            }
            0x82EE87FC => {
    //   block [0x82EE87FC..0x82EE8800)
	// 82EE87FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8800 size=16
    let mut pc: u32 = 0x82EE8800;
    'dispatch: loop {
        match pc {
            0x82EE8800 => {
    //   block [0x82EE8800..0x82EE8810)
	// 82EE8800: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE8804: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8808: E86B0130  ld r3, 0x130(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(304 as u32) ) };
	// 82EE880C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8810 size=96
    let mut pc: u32 = 0x82EE8810;
    'dispatch: loop {
        match pc {
            0x82EE8810 => {
    //   block [0x82EE8810..0x82EE8848)
	// 82EE8810: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE8814: F8810018  std r4, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.r[4].u64 ) };
	// 82EE8818: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE881C: 896B0364  lbz r11, 0x364(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(868 as u32) ) } as u64;
	// 82EE8820: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EE8824: 40820024  bne 0x82ee8848
	if !ctx.cr[0].eq {
	pc = 0x82EE8848; continue 'dispatch;
	}
	// 82EE8828: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE882C: E96B0130  ld r11, 0x130(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(304 as u32) ) };
	// 82EE8830: E9410018  ld r10, 0x18(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) };
	// 82EE8834: 7F2B5000  cmpd cr6, r11, r10
	ctx.cr[6].compare_i64(ctx.r[11].s64, ctx.r[10].s64, &mut ctx.xer);
	// 82EE8838: 409A0010  bne cr6, 0x82ee8848
	if !ctx.cr[6].eq {
	pc = 0x82EE8848; continue 'dispatch;
	}
	// 82EE883C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE8840: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EE8844: 4800000C  b 0x82ee8850
	pc = 0x82EE8850; continue 'dispatch;
            }
            0x82EE8848 => {
    //   block [0x82EE8848..0x82EE8850)
	// 82EE8848: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EE884C: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE8850; continue 'dispatch;
            }
            0x82EE8850 => {
    //   block [0x82EE8850..0x82EE8870)
	// 82EE8850: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8854: 8141FFF0  lwz r10, -0x10(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EE8858: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EE885C: 994B0364  stb r10, 0x364(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(868 as u32), ctx.r[10].u8 ) };
	// 82EE8860: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8864: E9410018  ld r10, 0x18(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) };
	// 82EE8868: F94B0130  std r10, 0x130(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(304 as u32), ctx.r[10].u64 ) };
	// 82EE886C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8870 size=16
    let mut pc: u32 = 0x82EE8870;
    'dispatch: loop {
        match pc {
            0x82EE8870 => {
    //   block [0x82EE8870..0x82EE8880)
	// 82EE8870: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE8874: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8878: 886B013C  lbz r3, 0x13c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EE887C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8880 size=96
    let mut pc: u32 = 0x82EE8880;
    'dispatch: loop {
        match pc {
            0x82EE8880 => {
    //   block [0x82EE8880..0x82EE88B8)
	// 82EE8880: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE8884: 9881001F  stb r4, 0x1f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(31 as u32), ctx.r[4].u8 ) };
	// 82EE8888: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE888C: 896B0364  lbz r11, 0x364(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(868 as u32) ) } as u64;
	// 82EE8890: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EE8894: 40820024  bne 0x82ee88b8
	if !ctx.cr[0].eq {
	pc = 0x82EE88B8; continue 'dispatch;
	}
	// 82EE8898: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE889C: 896B013C  lbz r11, 0x13c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(316 as u32) ) } as u64;
	// 82EE88A0: 8941001F  lbz r10, 0x1f(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(31 as u32) ) } as u64;
	// 82EE88A4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EE88A8: 409A0010  bne cr6, 0x82ee88b8
	if !ctx.cr[6].eq {
	pc = 0x82EE88B8; continue 'dispatch;
	}
	// 82EE88AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE88B0: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EE88B4: 4800000C  b 0x82ee88c0
	pc = 0x82EE88C0; continue 'dispatch;
            }
            0x82EE88B8 => {
    //   block [0x82EE88B8..0x82EE88C0)
	// 82EE88B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EE88BC: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE88C0; continue 'dispatch;
            }
            0x82EE88C0 => {
    //   block [0x82EE88C0..0x82EE88E0)
	// 82EE88C0: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE88C4: 8141FFF0  lwz r10, -0x10(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EE88C8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EE88CC: 994B0364  stb r10, 0x364(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(868 as u32), ctx.r[10].u8 ) };
	// 82EE88D0: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE88D4: 8941001F  lbz r10, 0x1f(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(31 as u32) ) } as u64;
	// 82EE88D8: 994B013C  stb r10, 0x13c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(316 as u32), ctx.r[10].u8 ) };
	// 82EE88DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE88E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE88E0 size=16
    let mut pc: u32 = 0x82EE88E0;
    'dispatch: loop {
        match pc {
            0x82EE88E0 => {
    //   block [0x82EE88E0..0x82EE88F0)
	// 82EE88E0: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE88E4: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE88E8: E86B0358  ld r3, 0x358(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(856 as u32) ) };
	// 82EE88EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE88F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE88F0 size=128
    let mut pc: u32 = 0x82EE88F0;
    'dispatch: loop {
        match pc {
            0x82EE88F0 => {
    //   block [0x82EE88F0..0x82EE8948)
	// 82EE88F0: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE88F4: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EE88F8: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE88FC: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EE8900: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EE8904: 7D4B5836  sld r11, r10, r11
	if (ctx.r[11].u8 & 0x40) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = (ctx.r[10].u64) << ((ctx.r[11].u8 & 0x3F) as u32);
	}
	// 82EE8908: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82EE890C: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE8910: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE8914: 41980048  blt cr6, 0x82ee895c
	if ctx.cr[6].lt {
	pc = 0x82EE895C; continue 'dispatch;
	}
	// 82EE8918: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE891C: 2F0B003F  cmpwi cr6, r11, 0x3f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 63, &mut ctx.xer);
	// 82EE8920: 4199003C  bgt cr6, 0x82ee895c
	if ctx.cr[6].gt {
	pc = 0x82EE895C; continue 'dispatch;
	}
	// 82EE8924: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8928: E96B0358  ld r11, 0x358(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(856 as u32) ) };
	// 82EE892C: E941FFF0  ld r10, -0x10(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EE8930: 7D6B5038  and r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	// 82EE8934: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 82EE8938: 419A0010  beq cr6, 0x82ee8948
	if ctx.cr[6].eq {
	pc = 0x82EE8948; continue 'dispatch;
	}
	// 82EE893C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EE8940: 9161FFF8  stw r11, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[11].u32 ) };
	// 82EE8944: 4800000C  b 0x82ee8950
	pc = 0x82EE8950; continue 'dispatch;
            }
            0x82EE8948 => {
    //   block [0x82EE8948..0x82EE8950)
	// 82EE8948: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE894C: 9161FFF8  stw r11, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE8950; continue 'dispatch;
            }
            0x82EE8950 => {
    //   block [0x82EE8950..0x82EE895C)
	// 82EE8950: 8161FFF8  lwz r11, -8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE8954: 9161FFFC  stw r11, -4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), ctx.r[11].u32 ) };
	// 82EE8958: 4800000C  b 0x82ee8964
	pc = 0x82EE8964; continue 'dispatch;
            }
            0x82EE895C => {
    //   block [0x82EE895C..0x82EE8964)
	// 82EE895C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE8960: 9161FFFC  stw r11, -4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE8964; continue 'dispatch;
            }
            0x82EE8964 => {
    //   block [0x82EE8964..0x82EE8970)
	// 82EE8964: 8161FFFC  lwz r11, -4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82EE8968: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EE896C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8970 size=204
    let mut pc: u32 = 0x82EE8970;
    'dispatch: loop {
        match pc {
            0x82EE8970 => {
    //   block [0x82EE8970..0x82EE89CC)
	// 82EE8970: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE8974: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EE8978: 98A10027  stb r5, 0x27(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(39 as u32), ctx.r[5].u8 ) };
	// 82EE897C: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE8980: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE8984: 419800B4  blt cr6, 0x82ee8a38
	if ctx.cr[6].lt {
	pc = 0x82EE8A38; continue 'dispatch;
	}
	// 82EE8988: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE898C: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 82EE8990: 409800A8  bge cr6, 0x82ee8a38
	if !ctx.cr[6].lt {
	pc = 0x82EE8A38; continue 'dispatch;
	}
	// 82EE8994: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE8998: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82EE899C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EE89A0: 7D4B5836  sld r11, r10, r11
	if (ctx.r[11].u8 & 0x40) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = (ctx.r[10].u64) << ((ctx.r[11].u8 & 0x3F) as u32);
	}
	// 82EE89A4: F961FFE8  std r11, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[11].u64 ) };
	// 82EE89A8: 89610027  lbz r11, 0x27(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(39 as u32) ) } as u64;
	// 82EE89AC: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EE89B0: 4182001C  beq 0x82ee89cc
	if ctx.cr[0].eq {
	pc = 0x82EE89CC; continue 'dispatch;
	}
	// 82EE89B4: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE89B8: E96B0358  ld r11, 0x358(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(856 as u32) ) };
	// 82EE89BC: E941FFE8  ld r10, -0x18(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EE89C0: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EE89C4: F961FFE0  std r11, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[11].u64 ) };
	// 82EE89C8: 4800001C  b 0x82ee89e4
	pc = 0x82EE89E4; continue 'dispatch;
            }
            0x82EE89CC => {
    //   block [0x82EE89CC..0x82EE89E4)
	// 82EE89CC: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE89D0: E941FFE8  ld r10, -0x18(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82EE89D4: 7D4A50F8  nor r10, r10, r10
	ctx.r[10].u64 = !(ctx.r[10].u64 | ctx.r[10].u64);
	// 82EE89D8: E96B0358  ld r11, 0x358(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(856 as u32) ) };
	// 82EE89DC: 7D6B5038  and r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	// 82EE89E0: F961FFE0  std r11, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[11].u64 ) };
	pc = 0x82EE89E4; continue 'dispatch;
            }
            0x82EE89E4 => {
    //   block [0x82EE89E4..0x82EE8A14)
	// 82EE89E4: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE89E8: 896B0364  lbz r11, 0x364(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(868 as u32) ) } as u64;
	// 82EE89EC: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EE89F0: 40820024  bne 0x82ee8a14
	if !ctx.cr[0].eq {
	pc = 0x82EE8A14; continue 'dispatch;
	}
	// 82EE89F4: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE89F8: E96B0358  ld r11, 0x358(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(856 as u32) ) };
	// 82EE89FC: E941FFE0  ld r10, -0x20(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82EE8A00: 7F2B5040  cmpld cr6, r11, r10
	ctx.cr[6].compare_u64(ctx.r[11].u64, ctx.r[10].u64, &mut ctx.xer);
	// 82EE8A04: 409A0010  bne cr6, 0x82ee8a14
	if !ctx.cr[6].eq {
	pc = 0x82EE8A14; continue 'dispatch;
	}
	// 82EE8A08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE8A0C: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EE8A10: 4800000C  b 0x82ee8a1c
	pc = 0x82EE8A1C; continue 'dispatch;
            }
            0x82EE8A14 => {
    //   block [0x82EE8A14..0x82EE8A1C)
	// 82EE8A14: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EE8A18: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE8A1C; continue 'dispatch;
            }
            0x82EE8A1C => {
    //   block [0x82EE8A1C..0x82EE8A38)
	// 82EE8A1C: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8A20: 8141FFF0  lwz r10, -0x10(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EE8A24: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EE8A28: 994B0364  stb r10, 0x364(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(868 as u32), ctx.r[10].u8 ) };
	// 82EE8A2C: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8A30: E941FFE0  ld r10, -0x20(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82EE8A34: F94B0358  std r10, 0x358(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(856 as u32), ctx.r[10].u64 ) };
	pc = 0x82EE8A38; continue 'dispatch;
            }
            0x82EE8A38 => {
    //   block [0x82EE8A38..0x82EE8A3C)
	// 82EE8A38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8A40 size=28
    let mut pc: u32 = 0x82EE8A40;
    'dispatch: loop {
        match pc {
            0x82EE8A40 => {
    //   block [0x82EE8A40..0x82EE8A5C)
	// 82EE8A40: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE8A44: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EE8A48: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8A4C: 396B0348  addi r11, r11, 0x348
	ctx.r[11].s64 = ctx.r[11].s64 + 840;
	// 82EE8A50: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE8A54: 7C6B50AE  lbzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EE8A58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8A60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EE8A60 size=204
    let mut pc: u32 = 0x82EE8A60;
    'dispatch: loop {
        match pc {
            0x82EE8A60 => {
    //   block [0x82EE8A60..0x82EE8A84)
	// 82EE8A60: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EE8A64: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EE8A68: 90A10024  stw r5, 0x24(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(36 as u32), ctx.r[5].u32 ) };
	// 82EE8A6C: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE8A70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE8A74: 41980010  blt cr6, 0x82ee8a84
	if ctx.cr[6].lt {
	pc = 0x82EE8A84; continue 'dispatch;
	}
	// 82EE8A78: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE8A7C: 2F0B000F  cmpwi cr6, r11, 0xf
	ctx.cr[6].compare_i32(ctx.r[11].s32, 15, &mut ctx.xer);
	// 82EE8A80: 41980008  blt cr6, 0x82ee8a88
	if ctx.cr[6].lt {
	pc = 0x82EE8A88; continue 'dispatch;
	}
	pc = 0x82EE8A84; continue 'dispatch;
            }
            0x82EE8A84 => {
    //   block [0x82EE8A84..0x82EE8A88)
	// 82EE8A84: 480000A4  b 0x82ee8b28
	pc = 0x82EE8B28; continue 'dispatch;
            }
            0x82EE8A88 => {
    //   block [0x82EE8A88..0x82EE8AA8)
	// 82EE8A88: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8A8C: 396B0348  addi r11, r11, 0x348
	ctx.r[11].s64 = ctx.r[11].s64 + 840;
	// 82EE8A90: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE8A94: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EE8A98: 81410024  lwz r10, 0x24(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EE8A9C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EE8AA0: 41980008  blt cr6, 0x82ee8aa8
	if ctx.cr[6].lt {
	pc = 0x82EE8AA8; continue 'dispatch;
	}
	// 82EE8AA4: 48000084  b 0x82ee8b28
	pc = 0x82EE8B28; continue 'dispatch;
            }
            0x82EE8AA8 => {
    //   block [0x82EE8AA8..0x82EE8AB8)
	// 82EE8AA8: 81610024  lwz r11, 0x24(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EE8AAC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE8AB0: 409A0008  bne cr6, 0x82ee8ab8
	if !ctx.cr[6].eq {
	pc = 0x82EE8AB8; continue 'dispatch;
	}
	// 82EE8AB4: 48000074  b 0x82ee8b28
	pc = 0x82EE8B28; continue 'dispatch;
            }
            0x82EE8AB8 => {
    //   block [0x82EE8AB8..0x82EE8AF8)
	// 82EE8AB8: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8ABC: 896B0364  lbz r11, 0x364(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(868 as u32) ) } as u64;
	// 82EE8AC0: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EE8AC4: 40820034  bne 0x82ee8af8
	if !ctx.cr[0].eq {
	pc = 0x82EE8AF8; continue 'dispatch;
	}
	// 82EE8AC8: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8ACC: 396B0348  addi r11, r11, 0x348
	ctx.r[11].s64 = ctx.r[11].s64 + 840;
	// 82EE8AD0: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE8AD4: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EE8AD8: 81410024  lwz r10, 0x24(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EE8ADC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EE8AE0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EE8AE4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82EE8AE8: 409A0010  bne cr6, 0x82ee8af8
	if !ctx.cr[6].eq {
	pc = 0x82EE8AF8; continue 'dispatch;
	}
	// 82EE8AEC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE8AF0: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EE8AF4: 4800000C  b 0x82ee8b00
	pc = 0x82EE8B00; continue 'dispatch;
            }
            0x82EE8AF8 => {
    //   block [0x82EE8AF8..0x82EE8B00)
	// 82EE8AF8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EE8AFC: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE8B00; continue 'dispatch;
            }
            0x82EE8B00 => {
    //   block [0x82EE8B00..0x82EE8B28)
	// 82EE8B00: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8B04: 8141FFF0  lwz r10, -0x10(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EE8B08: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82EE8B0C: 994B0364  stb r10, 0x364(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(868 as u32), ctx.r[10].u8 ) };
	// 82EE8B10: 81610024  lwz r11, 0x24(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EE8B14: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EE8B18: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EE8B1C: 394A0348  addi r10, r10, 0x348
	ctx.r[10].s64 = ctx.r[10].s64 + 840;
	// 82EE8B20: 8121001C  lwz r9, 0x1c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EE8B24: 7D6A49AE  stbx r11, r10, r9
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[11].u8) };
	pc = 0x82EE8B28; continue 'dispatch;
            }
            0x82EE8B28 => {
    //   block [0x82EE8B28..0x82EE8B2C)
	// 82EE8B28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE8B30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EE8B30 size=1340
    let mut pc: u32 = 0x82EE8B30;
    'dispatch: loop {
        match pc {
            0x82EE8B30 => {
    //   block [0x82EE8B30..0x82EE8B9C)
	// 82EE8B30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE8B34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EE8B38: 9421FA40  stwu r1, -0x5c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-1472 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE8B3C: 906105D4  stw r3, 0x5d4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1492 as u32), ctx.r[3].u32 ) };
	// 82EE8B40: 908105DC  stw r4, 0x5dc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1500 as u32), ctx.r[4].u32 ) };
	// 82EE8B44: 90A105E4  stw r5, 0x5e4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1508 as u32), ctx.r[5].u32 ) };
	// 82EE8B48: 80C105DC  lwz r6, 0x5dc(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1500 as u32) ) } as u64;
	// 82EE8B4C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE8B50: 38ABBF80  addi r5, r11, -0x4080
	ctx.r[5].s64 = ctx.r[11].s64 + -16512;
	// 82EE8B54: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EE8B58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EE8B5C: 4800268D  bl 0x82eeb1e8
	ctx.lr = 0x82EE8B60;
	sub_82EEB1E8(ctx, base);
	// 82EE8B60: 38610270  addi r3, r1, 0x270
	ctx.r[3].s64 = ctx.r[1].s64 + 624;
	// 82EE8B64: 48208DC5  bl 0x830f1928
	ctx.lr = 0x82EE8B68;
	sub_830F1928(ctx, base);
	// 82EE8B68: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EE8B6C: 38610270  addi r3, r1, 0x270
	ctx.r[3].s64 = ctx.r[1].s64 + 624;
	// 82EE8B70: 48208E91  bl 0x830f1a00
	ctx.lr = 0x82EE8B74;
	sub_830F1A00(ctx, base);
	// 82EE8B74: 90610264  stw r3, 0x264(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(612 as u32), ctx.r[3].u32 ) };
	// 82EE8B78: 81610264  lwz r11, 0x264(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(612 as u32) ) } as u64;
	// 82EE8B7C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE8B80: 4098001C  bge cr6, 0x82ee8b9c
	if !ctx.cr[6].lt {
	pc = 0x82EE8B9C; continue 'dispatch;
	}
	// 82EE8B84: 81610264  lwz r11, 0x264(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(612 as u32) ) } as u64;
	// 82EE8B88: 91610594  stw r11, 0x594(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1428 as u32), ctx.r[11].u32 ) };
	// 82EE8B8C: 38610270  addi r3, r1, 0x270
	ctx.r[3].s64 = ctx.r[1].s64 + 624;
	// 82EE8B90: 48208E21  bl 0x830f19b0
	ctx.lr = 0x82EE8B94;
	sub_830F19B0(ctx, base);
	// 82EE8B94: 80610594  lwz r3, 0x594(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1428 as u32) ) } as u64;
	// 82EE8B98: 480004C4  b 0x82ee905c
	pc = 0x82EE905C; continue 'dispatch;
            }
            0x82EE8B9C => {
    //   block [0x82EE8B9C..0x82EE8BD0)
	// 82EE8B9C: 38610270  addi r3, r1, 0x270
	ctx.r[3].s64 = ctx.r[1].s64 + 624;
	// 82EE8BA0: 482088B9  bl 0x830f1458
	ctx.lr = 0x82EE8BA4;
	sub_830F1458(ctx, base);
	// 82EE8BA4: 90610258  stw r3, 0x258(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(600 as u32), ctx.r[3].u32 ) };
	// 82EE8BA8: 81610258  lwz r11, 0x258(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8BAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE8BB0: 409A0020  bne cr6, 0x82ee8bd0
	if !ctx.cr[6].eq {
	pc = 0x82EE8BD0; continue 'dispatch;
	}
	// 82EE8BB4: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EE8BB8: 616B4005  ori r11, r11, 0x4005
	ctx.r[11].u64 = ctx.r[11].u64 | 16389;
	// 82EE8BBC: 91610598  stw r11, 0x598(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1432 as u32), ctx.r[11].u32 ) };
	// 82EE8BC0: 38610270  addi r3, r1, 0x270
	ctx.r[3].s64 = ctx.r[1].s64 + 624;
	// 82EE8BC4: 48208DED  bl 0x830f19b0
	ctx.lr = 0x82EE8BC8;
	sub_830F19B0(ctx, base);
	// 82EE8BC8: 80610598  lwz r3, 0x598(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1432 as u32) ) } as u64;
	// 82EE8BCC: 48000490  b 0x82ee905c
	pc = 0x82EE905C; continue 'dispatch;
            }
            0x82EE8BD0 => {
    //   block [0x82EE8BD0..0x82EE8C20)
	// 82EE8BD0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EE8BD4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE8BD8: 388BBF74  addi r4, r11, -0x408c
	ctx.r[4].s64 = ctx.r[11].s64 + -16524;
	// 82EE8BDC: 81610258  lwz r11, 0x258(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8BE0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE8BE4: 80610258  lwz r3, 0x258(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8BE8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EE8BEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE8BF0: 4E800421  bctrl
	ctx.lr = 0x82EE8BF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE8BF4: 9061025C  stw r3, 0x25c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(604 as u32), ctx.r[3].u32 ) };
	// 82EE8BF8: 8161025C  lwz r11, 0x25c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(604 as u32) ) } as u64;
	// 82EE8BFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE8C00: 409A0020  bne cr6, 0x82ee8c20
	if !ctx.cr[6].eq {
	pc = 0x82EE8C20; continue 'dispatch;
	}
	// 82EE8C04: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EE8C08: 616B4005  ori r11, r11, 0x4005
	ctx.r[11].u64 = ctx.r[11].u64 | 16389;
	// 82EE8C0C: 9161059C  stw r11, 0x59c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1436 as u32), ctx.r[11].u32 ) };
	// 82EE8C10: 38610270  addi r3, r1, 0x270
	ctx.r[3].s64 = ctx.r[1].s64 + 624;
	// 82EE8C14: 48208D9D  bl 0x830f19b0
	ctx.lr = 0x82EE8C18;
	sub_830F19B0(ctx, base);
	// 82EE8C18: 8061059C  lwz r3, 0x59c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1436 as u32) ) } as u64;
	// 82EE8C1C: 48000440  b 0x82ee905c
	pc = 0x82EE905C; continue 'dispatch;
            }
            0x82EE8C20 => {
    //   block [0x82EE8C20..0x82EE8C5C)
	// 82EE8C20: 80A1025C  lwz r5, 0x25c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(604 as u32) ) } as u64;
	// 82EE8C24: 38800080  li r4, 0x80
	ctx.r[4].s64 = 128;
	// 82EE8C28: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8C2C: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EE8C30: 482086E9  bl 0x830f1318
	ctx.lr = 0x82EE8C34;
	sub_830F1318(ctx, base);
	// 82EE8C34: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8C38: A16B0008  lhz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE8C3C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EE8C40: 4082001C  bne 0x82ee8c5c
	if !ctx.cr[0].eq {
	pc = 0x82EE8C5C; continue 'dispatch;
	}
	// 82EE8C44: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE8C48: 38ABBF5C  addi r5, r11, -0x40a4
	ctx.r[5].s64 = ctx.r[11].s64 + -16548;
	// 82EE8C4C: 38800080  li r4, 0x80
	ctx.r[4].s64 = 128;
	// 82EE8C50: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8C54: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EE8C58: 482086C1  bl 0x830f1318
	ctx.lr = 0x82EE8C5C;
	sub_830F1318(ctx, base);
	pc = 0x82EE8C5C; continue 'dispatch;
            }
            0x82EE8C5C => {
    //   block [0x82EE8C5C..0x82EE8C98)
	// 82EE8C5C: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8C60: 38AB0108  addi r5, r11, 0x108
	ctx.r[5].s64 = ctx.r[11].s64 + 264;
	// 82EE8C64: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE8C68: 388BBF44  addi r4, r11, -0x40bc
	ctx.r[4].s64 = ctx.r[11].s64 + -16572;
	// 82EE8C6C: 80610258  lwz r3, 0x258(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8C70: 48001921  bl 0x82eea590
	ctx.lr = 0x82EE8C74;
	sub_82EEA590(ctx, base);
	// 82EE8C74: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE8C78: 40820020  bne 0x82ee8c98
	if !ctx.cr[0].eq {
	pc = 0x82EE8C98; continue 'dispatch;
	}
	// 82EE8C7C: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EE8C80: 616B4005  ori r11, r11, 0x4005
	ctx.r[11].u64 = ctx.r[11].u64 | 16389;
	// 82EE8C84: 916105A0  stw r11, 0x5a0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1440 as u32), ctx.r[11].u32 ) };
	// 82EE8C88: 38610270  addi r3, r1, 0x270
	ctx.r[3].s64 = ctx.r[1].s64 + 624;
	// 82EE8C8C: 48208D25  bl 0x830f19b0
	ctx.lr = 0x82EE8C90;
	sub_830F19B0(ctx, base);
	// 82EE8C90: 806105A0  lwz r3, 0x5a0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1440 as u32) ) } as u64;
	// 82EE8C94: 480003C8  b 0x82ee905c
	pc = 0x82EE905C; continue 'dispatch;
            }
            0x82EE8C98 => {
    //   block [0x82EE8C98..0x82EE8CD4)
	// 82EE8C98: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8C9C: 38AB0130  addi r5, r11, 0x130
	ctx.r[5].s64 = ctx.r[11].s64 + 304;
	// 82EE8CA0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE8CA4: 388BBF38  addi r4, r11, -0x40c8
	ctx.r[4].s64 = ctx.r[11].s64 + -16584;
	// 82EE8CA8: 80610258  lwz r3, 0x258(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8CAC: 480018E5  bl 0x82eea590
	ctx.lr = 0x82EE8CB0;
	sub_82EEA590(ctx, base);
	// 82EE8CB0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE8CB4: 40820020  bne 0x82ee8cd4
	if !ctx.cr[0].eq {
	pc = 0x82EE8CD4; continue 'dispatch;
	}
	// 82EE8CB8: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EE8CBC: 616B4005  ori r11, r11, 0x4005
	ctx.r[11].u64 = ctx.r[11].u64 | 16389;
	// 82EE8CC0: 916105A4  stw r11, 0x5a4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1444 as u32), ctx.r[11].u32 ) };
	// 82EE8CC4: 38610270  addi r3, r1, 0x270
	ctx.r[3].s64 = ctx.r[1].s64 + 624;
	// 82EE8CC8: 48208CE9  bl 0x830f19b0
	ctx.lr = 0x82EE8CCC;
	sub_830F19B0(ctx, base);
	// 82EE8CCC: 806105A4  lwz r3, 0x5a4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1444 as u32) ) } as u64;
	// 82EE8CD0: 4800038C  b 0x82ee905c
	pc = 0x82EE905C; continue 'dispatch;
            }
            0x82EE8CD4 => {
    //   block [0x82EE8CD4..0x82EE8D10)
	// 82EE8CD4: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8CD8: 38AB0358  addi r5, r11, 0x358
	ctx.r[5].s64 = ctx.r[11].s64 + 856;
	// 82EE8CDC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE8CE0: 388BBF10  addi r4, r11, -0x40f0
	ctx.r[4].s64 = ctx.r[11].s64 + -16624;
	// 82EE8CE4: 80610258  lwz r3, 0x258(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8CE8: 48001931  bl 0x82eea618
	ctx.lr = 0x82EE8CEC;
	sub_82EEA618(ctx, base);
	// 82EE8CEC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE8CF0: 40820020  bne 0x82ee8d10
	if !ctx.cr[0].eq {
	pc = 0x82EE8D10; continue 'dispatch;
	}
	// 82EE8CF4: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EE8CF8: 616B4005  ori r11, r11, 0x4005
	ctx.r[11].u64 = ctx.r[11].u64 | 16389;
	// 82EE8CFC: 916105A8  stw r11, 0x5a8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1448 as u32), ctx.r[11].u32 ) };
	// 82EE8D00: 38610270  addi r3, r1, 0x270
	ctx.r[3].s64 = ctx.r[1].s64 + 624;
	// 82EE8D04: 48208CAD  bl 0x830f19b0
	ctx.lr = 0x82EE8D08;
	sub_830F19B0(ctx, base);
	// 82EE8D08: 806105A8  lwz r3, 0x5a8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1448 as u32) ) } as u64;
	// 82EE8D0C: 48000350  b 0x82ee905c
	pc = 0x82EE905C; continue 'dispatch;
            }
            0x82EE8D10 => {
    //   block [0x82EE8D10..0x82EE8D7C)
	// 82EE8D10: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8D14: 38AB0110  addi r5, r11, 0x110
	ctx.r[5].s64 = ctx.r[11].s64 + 272;
	// 82EE8D18: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE8D1C: 388BBF00  addi r4, r11, -0x4100
	ctx.r[4].s64 = ctx.r[11].s64 + -16640;
	// 82EE8D20: 80610258  lwz r3, 0x258(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8D24: 4800186D  bl 0x82eea590
	ctx.lr = 0x82EE8D28;
	sub_82EEA590(ctx, base);
	// 82EE8D28: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8D2C: 38AB013C  addi r5, r11, 0x13c
	ctx.r[5].s64 = ctx.r[11].s64 + 316;
	// 82EE8D30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE8D34: 388BBEEC  addi r4, r11, -0x4114
	ctx.r[4].s64 = ctx.r[11].s64 + -16660;
	// 82EE8D38: 80610258  lwz r3, 0x258(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8D3C: 48001965  bl 0x82eea6a0
	ctx.lr = 0x82EE8D40;
	sub_82EEA6A0(ctx, base);
	// 82EE8D40: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8D44: 38AB0138  addi r5, r11, 0x138
	ctx.r[5].s64 = ctx.r[11].s64 + 312;
	// 82EE8D48: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE8D4C: 388BBED4  addi r4, r11, -0x412c
	ctx.r[4].s64 = ctx.r[11].s64 + -16684;
	// 82EE8D50: 80610258  lwz r3, 0x258(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8D54: 480019D5  bl 0x82eea728
	ctx.lr = 0x82EE8D58;
	sub_82EEA728(ctx, base);
	// 82EE8D58: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8D5C: 38AB0140  addi r5, r11, 0x140
	ctx.r[5].s64 = ctx.r[11].s64 + 320;
	// 82EE8D60: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE8D64: 388BBEC8  addi r4, r11, -0x4138
	ctx.r[4].s64 = ctx.r[11].s64 + -16696;
	// 82EE8D68: 80610258  lwz r3, 0x258(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8D6C: 48001825  bl 0x82eea590
	ctx.lr = 0x82EE8D70;
	sub_82EEA590(ctx, base);
	// 82EE8D70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE8D74: 91610278  stw r11, 0x278(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(632 as u32), ctx.r[11].u32 ) };
	// 82EE8D78: 48000010  b 0x82ee8d88
	pc = 0x82EE8D88; continue 'dispatch;
            }
            0x82EE8D7C => {
    //   block [0x82EE8D7C..0x82EE8D88)
	// 82EE8D7C: 81610278  lwz r11, 0x278(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(632 as u32) ) } as u64;
	// 82EE8D80: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EE8D84: 91610278  stw r11, 0x278(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(632 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE8D88; continue 'dispatch;
            }
            0x82EE8D88 => {
    //   block [0x82EE8D88..0x82EE8DD0)
	// 82EE8D88: 81610278  lwz r11, 0x278(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(632 as u32) ) } as u64;
	// 82EE8D8C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82EE8D90: 40980040  bge cr6, 0x82ee8dd0
	if !ctx.cr[6].lt {
	pc = 0x82EE8DD0; continue 'dispatch;
	}
	// 82EE8D94: 80C10278  lwz r6, 0x278(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(632 as u32) ) } as u64;
	// 82EE8D98: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE8D9C: 38ABBEA8  addi r5, r11, -0x4158
	ctx.r[5].s64 = ctx.r[11].s64 + -16728;
	// 82EE8DA0: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EE8DA4: 38610280  addi r3, r1, 0x280
	ctx.r[3].s64 = ctx.r[1].s64 + 640;
	// 82EE8DA8: 48002441  bl 0x82eeb1e8
	ctx.lr = 0x82EE8DAC;
	sub_82EEB1E8(ctx, base);
	// 82EE8DAC: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8DB0: 396B0118  addi r11, r11, 0x118
	ctx.r[11].s64 = ctx.r[11].s64 + 280;
	// 82EE8DB4: 81410278  lwz r10, 0x278(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(632 as u32) ) } as u64;
	// 82EE8DB8: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EE8DBC: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EE8DC0: 38810280  addi r4, r1, 0x280
	ctx.r[4].s64 = ctx.r[1].s64 + 640;
	// 82EE8DC4: 80610258  lwz r3, 0x258(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8DC8: 480017C9  bl 0x82eea590
	ctx.lr = 0x82EE8DCC;
	sub_82EEA590(ctx, base);
	// 82EE8DCC: 4BFFFFB0  b 0x82ee8d7c
	pc = 0x82EE8D7C; continue 'dispatch;
            }
            0x82EE8DD0 => {
    //   block [0x82EE8DD0..0x82EE8E18)
	// 82EE8DD0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EE8DD4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE8DD8: 388BBE84  addi r4, r11, -0x417c
	ctx.r[4].s64 = ctx.r[11].s64 + -16764;
	// 82EE8DDC: 81610258  lwz r11, 0x258(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8DE0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE8DE4: 80610258  lwz r3, 0x258(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8DE8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EE8DEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE8DF0: 4E800421  bctrl
	ctx.lr = 0x82EE8DF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE8DF4: 90610260  stw r3, 0x260(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(608 as u32), ctx.r[3].u32 ) };
	// 82EE8DF8: 81610260  lwz r11, 0x260(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(608 as u32) ) } as u64;
	// 82EE8DFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE8E00: 419A0018  beq cr6, 0x82ee8e18
	if ctx.cr[6].eq {
	pc = 0x82EE8E18; continue 'dispatch;
	}
	// 82EE8E04: 80A10260  lwz r5, 0x260(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(608 as u32) ) } as u64;
	// 82EE8E08: 38800080  li r4, 0x80
	ctx.r[4].s64 = 128;
	// 82EE8E0C: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8E10: 386B0148  addi r3, r11, 0x148
	ctx.r[3].s64 = ctx.r[11].s64 + 328;
	// 82EE8E14: 48208505  bl 0x830f1318
	ctx.lr = 0x82EE8E18;
	sub_830F1318(ctx, base);
            }
            0x82EE8E18 => {
    //   block [0x82EE8E18..0x82EE8E60)
	// 82EE8E18: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EE8E1C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE8E20: 388BBE5C  addi r4, r11, -0x41a4
	ctx.r[4].s64 = ctx.r[11].s64 + -16804;
	// 82EE8E24: 81610258  lwz r11, 0x258(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8E28: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE8E2C: 80610258  lwz r3, 0x258(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8E30: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EE8E34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE8E38: 4E800421  bctrl
	ctx.lr = 0x82EE8E3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE8E3C: 9061026C  stw r3, 0x26c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(620 as u32), ctx.r[3].u32 ) };
	// 82EE8E40: 8161026C  lwz r11, 0x26c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(620 as u32) ) } as u64;
	// 82EE8E44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE8E48: 419A0018  beq cr6, 0x82ee8e60
	if ctx.cr[6].eq {
	pc = 0x82EE8E60; continue 'dispatch;
	}
	// 82EE8E4C: 80A1026C  lwz r5, 0x26c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(620 as u32) ) } as u64;
	// 82EE8E50: 38800080  li r4, 0x80
	ctx.r[4].s64 = 128;
	// 82EE8E54: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8E58: 386B0248  addi r3, r11, 0x248
	ctx.r[3].s64 = ctx.r[11].s64 + 584;
	// 82EE8E5C: 482084BD  bl 0x830f1318
	ctx.lr = 0x82EE8E60;
	sub_830F1318(ctx, base);
            }
            0x82EE8E60 => {
    //   block [0x82EE8E60..0x82EE8EA0)
	// 82EE8E60: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EE8E64: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE8E68: 388BBE34  addi r4, r11, -0x41cc
	ctx.r[4].s64 = ctx.r[11].s64 + -16844;
	// 82EE8E6C: 81610258  lwz r11, 0x258(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8E70: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE8E74: 80610258  lwz r3, 0x258(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82EE8E78: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EE8E7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EE8E80: 4E800421  bctrl
	ctx.lr = 0x82EE8E84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EE8E84: 90610268  stw r3, 0x268(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(616 as u32), ctx.r[3].u32 ) };
	// 82EE8E88: 81610268  lwz r11, 0x268(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(616 as u32) ) } as u64;
	// 82EE8E8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE8E90: 419A013C  beq cr6, 0x82ee8fcc
	if ctx.cr[6].eq {
	pc = 0x82EE8FCC; continue 'dispatch;
	}
	// 82EE8E94: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE8E98: 91610488  stw r11, 0x488(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1160 as u32), ctx.r[11].u32 ) };
	// 82EE8E9C: 48000010  b 0x82ee8eac
	pc = 0x82EE8EAC; continue 'dispatch;
            }
            0x82EE8EA0 => {
    //   block [0x82EE8EA0..0x82EE8EAC)
	// 82EE8EA0: 81610488  lwz r11, 0x488(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1160 as u32) ) } as u64;
	// 82EE8EA4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EE8EA8: 91610488  stw r11, 0x488(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1160 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE8EAC; continue 'dispatch;
            }
            0x82EE8EAC => {
    //   block [0x82EE8EAC..0x82EE8EE8)
	// 82EE8EAC: 81610488  lwz r11, 0x488(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1160 as u32) ) } as u64;
	// 82EE8EB0: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 82EE8EB4: 40980118  bge cr6, 0x82ee8fcc
	if !ctx.cr[6].lt {
	pc = 0x82EE8FCC; continue 'dispatch;
	}
	// 82EE8EB8: 81610488  lwz r11, 0x488(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1160 as u32) ) } as u64;
	// 82EE8EBC: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EE8EC0: 81410268  lwz r10, 0x268(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(616 as u32) ) } as u64;
	// 82EE8EC4: 7D6A5A2E  lhzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EE8EC8: 2F0B002E  cmpwi cr6, r11, 0x2e
	ctx.cr[6].compare_i32(ctx.r[11].s32, 46, &mut ctx.xer);
	// 82EE8ECC: 409A001C  bne cr6, 0x82ee8ee8
	if !ctx.cr[6].eq {
	pc = 0x82EE8EE8; continue 'dispatch;
	}
	// 82EE8ED0: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8ED4: 396B0348  addi r11, r11, 0x348
	ctx.r[11].s64 = ctx.r[11].s64 + 840;
	// 82EE8ED8: 81410488  lwz r10, 0x488(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1160 as u32) ) } as u64;
	// 82EE8EDC: 392000FF  li r9, 0xff
	ctx.r[9].s64 = 255;
	// 82EE8EE0: 7D2B51AE  stbx r9, r11, r10
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u8) };
	// 82EE8EE4: 480000E4  b 0x82ee8fc8
	pc = 0x82EE8FC8; continue 'dispatch;
            }
            0x82EE8EE8 => {
    //   block [0x82EE8EE8..0x82EE8F2C)
	// 82EE8EE8: 81610488  lwz r11, 0x488(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1160 as u32) ) } as u64;
	// 82EE8EEC: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EE8EF0: 81410268  lwz r10, 0x268(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(616 as u32) ) } as u64;
	// 82EE8EF4: 7D6A5A2E  lhzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EE8EF8: 2F0B0039  cmpwi cr6, r11, 0x39
	ctx.cr[6].compare_i32(ctx.r[11].s32, 57, &mut ctx.xer);
	// 82EE8EFC: 41990030  bgt cr6, 0x82ee8f2c
	if ctx.cr[6].gt {
	pc = 0x82EE8F2C; continue 'dispatch;
	}
	// 82EE8F00: 81610488  lwz r11, 0x488(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1160 as u32) ) } as u64;
	// 82EE8F04: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EE8F08: 81410268  lwz r10, 0x268(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(616 as u32) ) } as u64;
	// 82EE8F0C: 7D6A5A2E  lhzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EE8F10: 396BFFD0  addi r11, r11, -0x30
	ctx.r[11].s64 = ctx.r[11].s64 + -48;
	// 82EE8F14: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EE8F18: 814105D4  lwz r10, 0x5d4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8F1C: 394A0348  addi r10, r10, 0x348
	ctx.r[10].s64 = ctx.r[10].s64 + 840;
	// 82EE8F20: 81210488  lwz r9, 0x488(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1160 as u32) ) } as u64;
	// 82EE8F24: 7D6A49AE  stbx r11, r10, r9
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[11].u8) };
	// 82EE8F28: 480000A0  b 0x82ee8fc8
	pc = 0x82EE8FC8; continue 'dispatch;
            }
            0x82EE8F2C => {
    //   block [0x82EE8F2C..0x82EE8F7C)
	// 82EE8F2C: 81610488  lwz r11, 0x488(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1160 as u32) ) } as u64;
	// 82EE8F30: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EE8F34: 81410268  lwz r10, 0x268(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(616 as u32) ) } as u64;
	// 82EE8F38: 7D6A5A2E  lhzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EE8F3C: 2F0B005A  cmpwi cr6, r11, 0x5a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 90, &mut ctx.xer);
	// 82EE8F40: 4199003C  bgt cr6, 0x82ee8f7c
	if ctx.cr[6].gt {
	pc = 0x82EE8F7C; continue 'dispatch;
	}
	// 82EE8F44: 81610488  lwz r11, 0x488(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1160 as u32) ) } as u64;
	// 82EE8F48: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EE8F4C: 81410268  lwz r10, 0x268(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(616 as u32) ) } as u64;
	// 82EE8F50: 7D6A5A2E  lhzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EE8F54: 396BFFBF  addi r11, r11, -0x41
	ctx.r[11].s64 = ctx.r[11].s64 + -65;
	// 82EE8F58: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EE8F5C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EE8F60: 396B000A  addi r11, r11, 0xa
	ctx.r[11].s64 = ctx.r[11].s64 + 10;
	// 82EE8F64: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EE8F68: 814105D4  lwz r10, 0x5d4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8F6C: 394A0348  addi r10, r10, 0x348
	ctx.r[10].s64 = ctx.r[10].s64 + 840;
	// 82EE8F70: 81210488  lwz r9, 0x488(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1160 as u32) ) } as u64;
	// 82EE8F74: 7D6A49AE  stbx r11, r10, r9
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[11].u8) };
	// 82EE8F78: 48000050  b 0x82ee8fc8
	pc = 0x82EE8FC8; continue 'dispatch;
            }
            0x82EE8F7C => {
    //   block [0x82EE8F7C..0x82EE8FC8)
	// 82EE8F7C: 81610488  lwz r11, 0x488(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1160 as u32) ) } as u64;
	// 82EE8F80: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EE8F84: 81410268  lwz r10, 0x268(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(616 as u32) ) } as u64;
	// 82EE8F88: 7D6A5A2E  lhzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EE8F8C: 2F0B007A  cmpwi cr6, r11, 0x7a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 122, &mut ctx.xer);
	// 82EE8F90: 41990038  bgt cr6, 0x82ee8fc8
	if ctx.cr[6].gt {
	pc = 0x82EE8FC8; continue 'dispatch;
	}
	// 82EE8F94: 81610488  lwz r11, 0x488(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1160 as u32) ) } as u64;
	// 82EE8F98: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EE8F9C: 81410268  lwz r10, 0x268(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(616 as u32) ) } as u64;
	// 82EE8FA0: 7D6A5A2E  lhzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82EE8FA4: 396BFF9F  addi r11, r11, -0x61
	ctx.r[11].s64 = ctx.r[11].s64 + -97;
	// 82EE8FA8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EE8FAC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EE8FB0: 396B0024  addi r11, r11, 0x24
	ctx.r[11].s64 = ctx.r[11].s64 + 36;
	// 82EE8FB4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EE8FB8: 814105D4  lwz r10, 0x5d4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8FBC: 394A0348  addi r10, r10, 0x348
	ctx.r[10].s64 = ctx.r[10].s64 + 840;
	// 82EE8FC0: 81210488  lwz r9, 0x488(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1160 as u32) ) } as u64;
	// 82EE8FC4: 7D6A49AE  stbx r11, r10, r9
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[11].u8) };
	pc = 0x82EE8FC8; continue 'dispatch;
            }
            0x82EE8FC8 => {
    //   block [0x82EE8FC8..0x82EE8FCC)
	// 82EE8FC8: 4BFFFED8  b 0x82ee8ea0
	pc = 0x82EE8EA0; continue 'dispatch;
            }
            0x82EE8FCC => {
    //   block [0x82EE8FCC..0x82EE9000)
	// 82EE8FCC: 816105E4  lwz r11, 0x5e4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1508 as u32) ) } as u64;
	// 82EE8FD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE8FD4: 419A005C  beq cr6, 0x82ee9030
	if ctx.cr[6].eq {
	pc = 0x82EE9030; continue 'dispatch;
	}
	// 82EE8FD8: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8FDC: 816B0360  lwz r11, 0x360(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(864 as u32) ) } as u64;
	// 82EE8FE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE8FE4: 419A001C  beq cr6, 0x82ee9000
	if ctx.cr[6].eq {
	pc = 0x82EE9000; continue 'dispatch;
	}
	// 82EE8FE8: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8FEC: 806B0360  lwz r3, 0x360(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(864 as u32) ) } as u64;
	// 82EE8FF0: 4BBA20E9  bl 0x82a8b0d8
	ctx.lr = 0x82EE8FF4;
	sub_82A8B0D8(ctx, base);
	// 82EE8FF4: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE8FF8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE8FFC: 914B0360  stw r10, 0x360(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(864 as u32), ctx.r[10].u32 ) };
	pc = 0x82EE9000; continue 'dispatch;
            }
            0x82EE9000 => {
    //   block [0x82EE9000..0x82EE9030)
	// 82EE9000: 80C105DC  lwz r6, 0x5dc(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1500 as u32) ) } as u64;
	// 82EE9004: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9008: 38ABBE1C  addi r5, r11, -0x41e4
	ctx.r[5].s64 = ctx.r[11].s64 + -16868;
	// 82EE900C: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EE9010: 38610490  addi r3, r1, 0x490
	ctx.r[3].s64 = ctx.r[1].s64 + 1168;
	// 82EE9014: 48002035  bl 0x82eeb048
	ctx.lr = 0x82EE9018;
	sub_82EEB048(ctx, base);
	// 82EE9018: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE901C: 38AB0360  addi r5, r11, 0x360
	ctx.r[5].s64 = ctx.r[11].s64 + 864;
	// 82EE9020: 38810490  addi r4, r1, 0x490
	ctx.r[4].s64 = ctx.r[1].s64 + 1168;
	// 82EE9024: 806105E4  lwz r3, 0x5e4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1508 as u32) ) } as u64;
	// 82EE9028: 4BE2EB21  bl 0x82d17b48
	ctx.lr = 0x82EE902C;
	sub_82D17B48(ctx, base);
	// 82EE902C: 9061048C  stw r3, 0x48c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1164 as u32), ctx.r[3].u32 ) };
	pc = 0x82EE9030; continue 'dispatch;
            }
            0x82EE9030 => {
    //   block [0x82EE9030..0x82EE905C)
	// 82EE9030: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE9034: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE9038: 994B0364  stb r10, 0x364(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(868 as u32), ctx.r[10].u8 ) };
	// 82EE903C: 816105D4  lwz r11, 0x5d4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1492 as u32) ) } as u64;
	// 82EE9040: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE9044: 994B0365  stb r10, 0x365(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(869 as u32), ctx.r[10].u8 ) };
	// 82EE9048: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE904C: 916105AC  stw r11, 0x5ac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1452 as u32), ctx.r[11].u32 ) };
	// 82EE9050: 38610270  addi r3, r1, 0x270
	ctx.r[3].s64 = ctx.r[1].s64 + 624;
	// 82EE9054: 4820895D  bl 0x830f19b0
	ctx.lr = 0x82EE9058;
	sub_830F19B0(ctx, base);
	// 82EE9058: 806105AC  lwz r3, 0x5ac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1452 as u32) ) } as u64;
	pc = 0x82EE905C; continue 'dispatch;
            }
            0x82EE905C => {
    //   block [0x82EE905C..0x82EE906C)
	// 82EE905C: 382105C0  addi r1, r1, 0x5c0
	ctx.r[1].s64 = ctx.r[1].s64 + 1472;
	// 82EE9060: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE9064: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EE9068: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE9070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EE9070 size=536
    let mut pc: u32 = 0x82EE9070;
    'dispatch: loop {
        match pc {
            0x82EE9070 => {
    //   block [0x82EE9070..0x82EE9094)
	// 82EE9070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE9074: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EE9078: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE907C: 90610214  stw r3, 0x214(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(532 as u32), ctx.r[3].u32 ) };
	// 82EE9080: 9081021C  stw r4, 0x21c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(540 as u32), ctx.r[4].u32 ) };
	// 82EE9084: 90A10224  stw r5, 0x224(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(548 as u32), ctx.r[5].u32 ) };
	// 82EE9088: 90C1022C  stw r6, 0x22c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(556 as u32), ctx.r[6].u32 ) };
	// 82EE908C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EE9090: 396B8F48  addi r11, r11, -0x70b8
	ctx.r[11].s64 = ctx.r[11].s64 + -28856;
	pc = 0x82EE9094; continue 'dispatch;
            }
            0x82EE9094 => {
    //   block [0x82EE9094..0x82EE9124)
	// 82EE9094: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82EE9098: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82EE909C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82EE90A0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82EE90A4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82EE90A8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82EE90AC: 4082FFE8  bne 0x82ee9094
	if !ctx.cr[0].eq {
	pc = 0x82EE9094; continue 'dispatch;
	}
	// 82EE90B0: 7D4A5378  mr r10, r10
	ctx.r[10].u64 = ctx.r[10].u64;
	// 82EE90B4: 914101E8  stw r10, 0x1e8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(488 as u32), ctx.r[10].u32 ) };
	// 82EE90B8: 816101E8  lwz r11, 0x1e8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(488 as u32) ) } as u64;
	// 82EE90BC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EE90C0: 80C10060  lwz r6, 0x60(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EE90C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE90C8: 38ABBFB4  addi r5, r11, -0x404c
	ctx.r[5].s64 = ctx.r[11].s64 + -16460;
	// 82EE90CC: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 82EE90D0: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 82EE90D4: 48001F75  bl 0x82eeb048
	ctx.lr = 0x82EE90D8;
	sub_82EEB048(ctx, base);
	// 82EE90D8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EE90DC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EE90E0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EE90E4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EE90E8: 4BDD9BF9  bl 0x82cc2ce0
	ctx.lr = 0x82EE90EC;
	sub_82CC2CE0(ctx, base);
	// 82EE90EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EE90F0: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 82EE90F4: 4800224D  bl 0x82eeb340
	ctx.lr = 0x82EE90F8;
	sub_82EEB340(ctx, base);
	// 82EE90F8: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 82EE90FC: 480022D5  bl 0x82eeb3d0
	ctx.lr = 0x82EE9100;
	sub_82EEB3D0(ctx, base);
	// 82EE9100: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE9104: 41820020  beq 0x82ee9124
	if ctx.cr[0].eq {
	pc = 0x82EE9124; continue 'dispatch;
	}
	// 82EE9108: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EE910C: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 82EE9110: 916101D4  stw r11, 0x1d4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(468 as u32), ctx.r[11].u32 ) };
	// 82EE9114: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 82EE9118: 48002249  bl 0x82eeb360
	ctx.lr = 0x82EE911C;
	sub_82EEB360(ctx, base);
	// 82EE911C: 806101D4  lwz r3, 0x1d4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(468 as u32) ) } as u64;
	// 82EE9120: 48000158  b 0x82ee9278
	pc = 0x82EE9278; continue 'dispatch;
            }
            0x82EE9124 => {
    //   block [0x82EE9124..0x82EE91BC)
	// 82EE9124: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9128: 91610180  stw r11, 0x180(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[11].u32 ) };
	// 82EE912C: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 82EE9130: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EE9134: 38610184  addi r3, r1, 0x184
	ctx.r[3].s64 = ctx.r[1].s64 + 388;
	// 82EE9138: 4BDC0879  bl 0x82ca99b0
	ctx.lr = 0x82EE913C;
	sub_82CA99B0(ctx, base);
	// 82EE913C: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 82EE9140: 48004081  bl 0x82eed1c0
	ctx.lr = 0x82EE9144;
	sub_82EED1C0(ctx, base);
	// 82EE9144: 9061018C  stw r3, 0x18c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(396 as u32), ctx.r[3].u32 ) };
	// 82EE9148: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE914C: 91610178  stw r11, 0x178(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), ctx.r[11].u32 ) };
	// 82EE9150: 3961017C  addi r11, r1, 0x17c
	ctx.r[11].s64 = ctx.r[1].s64 + 380;
	// 82EE9154: 916101EC  stw r11, 0x1ec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(492 as u32), ctx.r[11].u32 ) };
	// 82EE9158: 816101EC  lwz r11, 0x1ec(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(492 as u32) ) } as u64;
	// 82EE915C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE9160: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EE9164: 39610180  addi r11, r1, 0x180
	ctx.r[11].s64 = ctx.r[1].s64 + 384;
	// 82EE9168: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EE916C: E9410178  ld r10, 0x178(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(376 as u32) ) };
	// 82EE9170: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EE9174: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82EE9178: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EE917C: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82EE9180: 80A10224  lwz r5, 0x224(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(548 as u32) ) } as u64;
	// 82EE9184: 388101B0  addi r4, r1, 0x1b0
	ctx.r[4].s64 = ctx.r[1].s64 + 432;
	// 82EE9188: 8061021C  lwz r3, 0x21c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EE918C: 4BDDAFAD  bl 0x82cc4138
	ctx.lr = 0x82EE9190;
	sub_82CC4138(ctx, base);
	// 82EE9190: 906101D0  stw r3, 0x1d0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(464 as u32), ctx.r[3].u32 ) };
	// 82EE9194: 816101D0  lwz r11, 0x1d0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(464 as u32) ) } as u64;
	// 82EE9198: 2B0B03E5  cmplwi cr6, r11, 0x3e5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 997 as u32, &mut ctx.xer);
	// 82EE919C: 419A0020  beq cr6, 0x82ee91bc
	if ctx.cr[6].eq {
	pc = 0x82EE91BC; continue 'dispatch;
	}
	// 82EE91A0: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EE91A4: 616B4005  ori r11, r11, 0x4005
	ctx.r[11].u64 = ctx.r[11].u64 | 16389;
	// 82EE91A8: 916101D8  stw r11, 0x1d8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(472 as u32), ctx.r[11].u32 ) };
	// 82EE91AC: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 82EE91B0: 480021B1  bl 0x82eeb360
	ctx.lr = 0x82EE91B4;
	sub_82EEB360(ctx, base);
	// 82EE91B4: 806101D8  lwz r3, 0x1d8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(472 as u32) ) } as u64;
	// 82EE91B8: 480000C0  b 0x82ee9278
	pc = 0x82EE9278; continue 'dispatch;
            }
            0x82EE91BC => {
    //   block [0x82EE91BC..0x82EE91F8)
	// 82EE91BC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EE91C0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EE91C4: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 82EE91C8: 4BDD9BB9  bl 0x82cc2d80
	ctx.lr = 0x82EE91CC;
	sub_82CC2D80(ctx, base);
	// 82EE91CC: 906101D0  stw r3, 0x1d0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(464 as u32), ctx.r[3].u32 ) };
	// 82EE91D0: 816101D0  lwz r11, 0x1d0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(464 as u32) ) } as u64;
	// 82EE91D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE91D8: 419A0020  beq cr6, 0x82ee91f8
	if ctx.cr[6].eq {
	pc = 0x82EE91F8; continue 'dispatch;
	}
	// 82EE91DC: 806101D0  lwz r3, 0x1d0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(464 as u32) ) } as u64;
	// 82EE91E0: 4B418CA1  bl 0x82301e80
	ctx.lr = 0x82EE91E4;
	sub_82301E80(ctx, base);
	// 82EE91E4: 906101DC  stw r3, 0x1dc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(476 as u32), ctx.r[3].u32 ) };
	// 82EE91E8: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 82EE91EC: 48002175  bl 0x82eeb360
	ctx.lr = 0x82EE91F0;
	sub_82EEB360(ctx, base);
	// 82EE91F0: 806101DC  lwz r3, 0x1dc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(476 as u32) ) } as u64;
	// 82EE91F4: 48000084  b 0x82ee9278
	pc = 0x82EE9278; continue 'dispatch;
            }
            0x82EE91F8 => {
    //   block [0x82EE91F8..0x82EE9248)
	// 82EE91F8: 38C101B0  addi r6, r1, 0x1b0
	ctx.r[6].s64 = ctx.r[1].s64 + 432;
	// 82EE91FC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9200: 38ABBFAC  addi r5, r11, -0x4054
	ctx.r[5].s64 = ctx.r[11].s64 + -16468;
	// 82EE9204: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EE9208: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EE920C: 48001E3D  bl 0x82eeb048
	ctx.lr = 0x82EE9210;
	sub_82EEB048(ctx, base);
	// 82EE9210: 80A1022C  lwz r5, 0x22c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(556 as u32) ) } as u64;
	// 82EE9214: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EE9218: 80610214  lwz r3, 0x214(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(532 as u32) ) } as u64;
	// 82EE921C: 4BFFF915  bl 0x82ee8b30
	ctx.lr = 0x82EE9220;
	sub_82EE8B30(ctx, base);
	// 82EE9220: 9061019C  stw r3, 0x19c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(412 as u32), ctx.r[3].u32 ) };
	// 82EE9224: 8161019C  lwz r11, 0x19c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(412 as u32) ) } as u64;
	// 82EE9228: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE922C: 4098001C  bge cr6, 0x82ee9248
	if !ctx.cr[6].lt {
	pc = 0x82EE9248; continue 'dispatch;
	}
	// 82EE9230: 8161019C  lwz r11, 0x19c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(412 as u32) ) } as u64;
	// 82EE9234: 916101E0  stw r11, 0x1e0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(480 as u32), ctx.r[11].u32 ) };
	// 82EE9238: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 82EE923C: 48002125  bl 0x82eeb360
	ctx.lr = 0x82EE9240;
	sub_82EEB360(ctx, base);
	// 82EE9240: 806101E0  lwz r3, 0x1e0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(480 as u32) ) } as u64;
	// 82EE9244: 48000034  b 0x82ee9278
	pc = 0x82EE9278; continue 'dispatch;
            }
            0x82EE9248 => {
    //   block [0x82EE9248..0x82EE9278)
	// 82EE9248: 38810180  addi r4, r1, 0x180
	ctx.r[4].s64 = ctx.r[1].s64 + 384;
	// 82EE924C: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 82EE9250: 4BDDA7A1  bl 0x82cc39f0
	ctx.lr = 0x82EE9254;
	sub_82CC39F0(ctx, base);
	// 82EE9254: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EE9258: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EE925C: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 82EE9260: 4BDD9B21  bl 0x82cc2d80
	ctx.lr = 0x82EE9264;
	sub_82CC2D80(ctx, base);
	// 82EE9264: 8161019C  lwz r11, 0x19c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(412 as u32) ) } as u64;
	// 82EE9268: 916101E4  stw r11, 0x1e4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(484 as u32), ctx.r[11].u32 ) };
	// 82EE926C: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 82EE9270: 480020F1  bl 0x82eeb360
	ctx.lr = 0x82EE9274;
	sub_82EEB360(ctx, base);
	// 82EE9274: 806101E4  lwz r3, 0x1e4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(484 as u32) ) } as u64;
	pc = 0x82EE9278; continue 'dispatch;
            }
            0x82EE9278 => {
    //   block [0x82EE9278..0x82EE9288)
	// 82EE9278: 38210200  addi r1, r1, 0x200
	ctx.r[1].s64 = ctx.r[1].s64 + 512;
	// 82EE927C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE9280: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EE9284: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE9288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EE9288 size=1980
    let mut pc: u32 = 0x82EE9288;
    'dispatch: loop {
        match pc {
            0x82EE9288 => {
    //   block [0x82EE9288..0x82EE92DC)
	// 82EE9288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE928C: 4BDC0145  bl 0x82ca93d0
	ctx.lr = 0x82EE9290;
	sub_82CA93D0(ctx, base);
	// 82EE9290: 9421FBC0  stwu r1, -0x440(r1)
	ea = ctx.r[1].u32.wrapping_add(-1088 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE9294: 90610454  stw r3, 0x454(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1108 as u32), ctx.r[3].u32 ) };
	// 82EE9298: 9081045C  stw r4, 0x45c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1116 as u32), ctx.r[4].u32 ) };
	// 82EE929C: 98A10467  stb r5, 0x467(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(1127 as u32), ctx.r[5].u8 ) };
	// 82EE92A0: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE92A4: 896B0364  lbz r11, 0x364(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(868 as u32) ) } as u64;
	// 82EE92A8: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EE92AC: 4182070C  beq 0x82ee99b8
	if ctx.cr[0].eq {
	pc = 0x82EE99B8; continue 'dispatch;
	}
	// 82EE92B0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82EE92B4: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82EE92B8: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	// 82EE92BC: 4800215D  bl 0x82eeb418
	ctx.lr = 0x82EE92C0;
	sub_82EEB418(ctx, base);
	// 82EE92C0: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE92C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE92C8: 419A0014  beq cr6, 0x82ee92dc
	if ctx.cr[6].eq {
	pc = 0x82EE92DC; continue 'dispatch;
	}
	// 82EE92CC: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE92D0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82EE92D4: 91610340  stw r11, 0x340(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(832 as u32), ctx.r[11].u32 ) };
	// 82EE92D8: 4800000C  b 0x82ee92e4
	pc = 0x82EE92E4; continue 'dispatch;
            }
            0x82EE92DC => {
    //   block [0x82EE92DC..0x82EE92E4)
	// 82EE92DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE92E0: 91610340  stw r11, 0x340(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(832 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE92E4; continue 'dispatch;
            }
            0x82EE92E4 => {
    //   block [0x82EE92E4..0x82EE9560)
	// 82EE92E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE92E8: 3BEBC16C  addi r31, r11, -0x3e94
	ctx.r[31].s64 = ctx.r[11].s64 + -16020;
	// 82EE92EC: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE92F0: EBCB0140  ld r30, 0x140(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(320 as u32) ) };
	// 82EE92F4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE92F8: 3BABC15C  addi r29, r11, -0x3ea4
	ctx.r[29].s64 = ctx.r[11].s64 + -16036;
	// 82EE92FC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9300: 3B8BC16C  addi r28, r11, -0x3e94
	ctx.r[28].s64 = ctx.r[11].s64 + -16020;
	// 82EE9304: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE9308: 836B0138  lwz r27, 0x138(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(312 as u32) ) } as u64;
	// 82EE930C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9310: 3B4BC140  addi r26, r11, -0x3ec0
	ctx.r[26].s64 = ctx.r[11].s64 + -16064;
	// 82EE9314: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9318: 3B2BC16C  addi r25, r11, -0x3e94
	ctx.r[25].s64 = ctx.r[11].s64 + -16020;
	// 82EE931C: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE9320: EB0B0358  ld r24, 0x358(r11)
	ctx.r[24].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(856 as u32) ) };
	// 82EE9324: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9328: 3AEBC110  addi r23, r11, -0x3ef0
	ctx.r[23].s64 = ctx.r[11].s64 + -16112;
	// 82EE932C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9330: 3ACBC16C  addi r22, r11, -0x3e94
	ctx.r[22].s64 = ctx.r[11].s64 + -16020;
	// 82EE9334: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE9338: 3AAB0148  addi r21, r11, 0x148
	ctx.r[21].s64 = ctx.r[11].s64 + 328;
	// 82EE933C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9340: 3A8BC0E4  addi r20, r11, -0x3f1c
	ctx.r[20].s64 = ctx.r[11].s64 + -16156;
	// 82EE9344: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9348: 3A6BC16C  addi r19, r11, -0x3e94
	ctx.r[19].s64 = ctx.r[11].s64 + -16020;
	// 82EE934C: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE9350: 3A4B0248  addi r18, r11, 0x248
	ctx.r[18].s64 = ctx.r[11].s64 + 584;
	// 82EE9354: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9358: 3A2BC0B8  addi r17, r11, -0x3f48
	ctx.r[17].s64 = ctx.r[11].s64 + -16200;
	// 82EE935C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9360: 3A0BC16C  addi r16, r11, -0x3e94
	ctx.r[16].s64 = ctx.r[11].s64 + -16020;
	// 82EE9364: 80610454  lwz r3, 0x454(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE9368: 4BFFF509  bl 0x82ee8870
	ctx.lr = 0x82EE936C;
	sub_82EE8870(ctx, base);
	// 82EE936C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82EE9370: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82EE9374: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82EE9378: 696F0001  xori r15, r11, 1
	ctx.r[15].u64 = ctx.r[11].u64 ^ 1;
	// 82EE937C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9380: 39CBC0A0  addi r14, r11, -0x3f60
	ctx.r[14].s64 = ctx.r[11].s64 + -16224;
	// 82EE9384: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9388: 396BC16C  addi r11, r11, -0x3e94
	ctx.r[11].s64 = ctx.r[11].s64 + -16020;
	// 82EE938C: 80610454  lwz r3, 0x454(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE9390: 91610344  stw r11, 0x344(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(836 as u32), ctx.r[11].u32 ) };
	// 82EE9394: 4BFFF30D  bl 0x82ee86a0
	ctx.lr = 0x82EE9398;
	sub_82EE86A0(ctx, base);
	// 82EE9398: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EE939C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EE93A0: 394AC08C  addi r10, r10, -0x3f74
	ctx.r[10].s64 = ctx.r[10].s64 + -16244;
	// 82EE93A4: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EE93A8: 3929C16C  addi r9, r9, -0x3e94
	ctx.r[9].s64 = ctx.r[9].s64 + -16020;
	// 82EE93AC: 80610454  lwz r3, 0x454(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE93B0: 91210348  stw r9, 0x348(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(840 as u32), ctx.r[9].u32 ) };
	// 82EE93B4: 9141034C  stw r10, 0x34c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(844 as u32), ctx.r[10].u32 ) };
	// 82EE93B8: F9610350  std r11, 0x350(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(848 as u32), ctx.r[11].u64 ) };
	// 82EE93BC: 4BFFF445  bl 0x82ee8800
	ctx.lr = 0x82EE93C0;
	sub_82EE8800(ctx, base);
	// 82EE93C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EE93C4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EE93C8: 394AC07C  addi r10, r10, -0x3f84
	ctx.r[10].s64 = ctx.r[10].s64 + -16260;
	// 82EE93CC: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EE93D0: 3929C16C  addi r9, r9, -0x3e94
	ctx.r[9].s64 = ctx.r[9].s64 + -16020;
	// 82EE93D4: 80610454  lwz r3, 0x454(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE93D8: 91210358  stw r9, 0x358(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(856 as u32), ctx.r[9].u32 ) };
	// 82EE93DC: 9141035C  stw r10, 0x35c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(860 as u32), ctx.r[10].u32 ) };
	// 82EE93E0: F9610360  std r11, 0x360(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(864 as u32), ctx.r[11].u64 ) };
	// 82EE93E4: 4BFFF24D  bl 0x82ee8630
	ctx.lr = 0x82EE93E8;
	sub_82EE8630(ctx, base);
	// 82EE93E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EE93EC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EE93F0: 394AC05C  addi r10, r10, -0x3fa4
	ctx.r[10].s64 = ctx.r[10].s64 + -16292;
	// 82EE93F4: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EE93F8: 3929C16C  addi r9, r9, -0x3e94
	ctx.r[9].s64 = ctx.r[9].s64 + -16020;
	// 82EE93FC: 80610454  lwz r3, 0x454(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE9400: 91210368  stw r9, 0x368(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(872 as u32), ctx.r[9].u32 ) };
	// 82EE9404: 9141036C  stw r10, 0x36c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(876 as u32), ctx.r[10].u32 ) };
	// 82EE9408: F9610370  std r11, 0x370(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(880 as u32), ctx.r[11].u64 ) };
	// 82EE940C: 4BFFF12D  bl 0x82ee8538
	ctx.lr = 0x82EE9410;
	sub_82EE8538(ctx, base);
	// 82EE9410: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82EE9414: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82EE9418: 394AC04C  addi r10, r10, -0x3fb4
	ctx.r[10].s64 = ctx.r[10].s64 + -16308;
	// 82EE941C: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EE9420: 3889C024  addi r4, r9, -0x3fdc
	ctx.r[4].s64 = ctx.r[9].s64 + -16348;
	// 82EE9424: 80610340  lwz r3, 0x340(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(832 as u32) ) } as u64;
	// 82EE9428: 91410378  stw r10, 0x378(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(888 as u32), ctx.r[10].u32 ) };
	// 82EE942C: 9161037C  stw r11, 0x37c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(892 as u32), ctx.r[11].u32 ) };
	// 82EE9430: 48002429  bl 0x82eeb858
	ctx.lr = 0x82EE9434;
	sub_82EEB858(ctx, base);
	// 82EE9434: 81610378  lwz r11, 0x378(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(888 as u32) ) } as u64;
	// 82EE9438: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EE943C: 4800241D  bl 0x82eeb858
	ctx.lr = 0x82EE9440;
	sub_82EEB858(ctx, base);
	// 82EE9440: 8161037C  lwz r11, 0x37c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(892 as u32) ) } as u64;
	// 82EE9444: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EE9448: 48002411  bl 0x82eeb858
	ctx.lr = 0x82EE944C;
	sub_82EEB858(ctx, base);
	// 82EE944C: 81610368  lwz r11, 0x368(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(872 as u32) ) } as u64;
	// 82EE9450: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EE9454: 48002405  bl 0x82eeb858
	ctx.lr = 0x82EE9458;
	sub_82EEB858(ctx, base);
	// 82EE9458: 8161036C  lwz r11, 0x36c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(876 as u32) ) } as u64;
	// 82EE945C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EE9460: 480023F9  bl 0x82eeb858
	ctx.lr = 0x82EE9464;
	sub_82EEB858(ctx, base);
	// 82EE9464: E9610370  ld r11, 0x370(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(880 as u32) ) };
	// 82EE9468: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EE946C: 48000CF5  bl 0x82eea160
	ctx.lr = 0x82EE9470;
	sub_82EEA160(ctx, base);
	// 82EE9470: 81610358  lwz r11, 0x358(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(856 as u32) ) } as u64;
	// 82EE9474: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EE9478: 480023E1  bl 0x82eeb858
	ctx.lr = 0x82EE947C;
	sub_82EEB858(ctx, base);
	// 82EE947C: 8161035C  lwz r11, 0x35c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(860 as u32) ) } as u64;
	// 82EE9480: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EE9484: 480023D5  bl 0x82eeb858
	ctx.lr = 0x82EE9488;
	sub_82EEB858(ctx, base);
	// 82EE9488: E9610360  ld r11, 0x360(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(864 as u32) ) };
	// 82EE948C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EE9490: 48000CD1  bl 0x82eea160
	ctx.lr = 0x82EE9494;
	sub_82EEA160(ctx, base);
	// 82EE9494: 81610348  lwz r11, 0x348(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(840 as u32) ) } as u64;
	// 82EE9498: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EE949C: 480023BD  bl 0x82eeb858
	ctx.lr = 0x82EE94A0;
	sub_82EEB858(ctx, base);
	// 82EE94A0: 8161034C  lwz r11, 0x34c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(844 as u32) ) } as u64;
	// 82EE94A4: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EE94A8: 480023B1  bl 0x82eeb858
	ctx.lr = 0x82EE94AC;
	sub_82EEB858(ctx, base);
	// 82EE94AC: E9610350  ld r11, 0x350(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(848 as u32) ) };
	// 82EE94B0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EE94B4: 48000CAD  bl 0x82eea160
	ctx.lr = 0x82EE94B8;
	sub_82EEA160(ctx, base);
	// 82EE94B8: 81610344  lwz r11, 0x344(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(836 as u32) ) } as u64;
	// 82EE94BC: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82EE94C0: 48002399  bl 0x82eeb858
	ctx.lr = 0x82EE94C4;
	sub_82EEB858(ctx, base);
	// 82EE94C4: 7DC47378  mr r4, r14
	ctx.r[4].u64 = ctx.r[14].u64;
	// 82EE94C8: 48002391  bl 0x82eeb858
	ctx.lr = 0x82EE94CC;
	sub_82EEB858(ctx, base);
	// 82EE94CC: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 82EE94D0: 48000971  bl 0x82ee9e40
	ctx.lr = 0x82EE94D4;
	sub_82EE9E40(ctx, base);
	// 82EE94D4: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 82EE94D8: 48002381  bl 0x82eeb858
	ctx.lr = 0x82EE94DC;
	sub_82EEB858(ctx, base);
	// 82EE94DC: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 82EE94E0: 48002379  bl 0x82eeb858
	ctx.lr = 0x82EE94E4;
	sub_82EEB858(ctx, base);
	// 82EE94E4: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 82EE94E8: 48002371  bl 0x82eeb858
	ctx.lr = 0x82EE94EC;
	sub_82EEB858(ctx, base);
	// 82EE94EC: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 82EE94F0: 48002369  bl 0x82eeb858
	ctx.lr = 0x82EE94F4;
	sub_82EEB858(ctx, base);
	// 82EE94F4: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82EE94F8: 48002361  bl 0x82eeb858
	ctx.lr = 0x82EE94FC;
	sub_82EEB858(ctx, base);
	// 82EE94FC: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82EE9500: 48002359  bl 0x82eeb858
	ctx.lr = 0x82EE9504;
	sub_82EEB858(ctx, base);
	// 82EE9504: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82EE9508: 48002351  bl 0x82eeb858
	ctx.lr = 0x82EE950C;
	sub_82EEB858(ctx, base);
	// 82EE950C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82EE9510: 48002349  bl 0x82eeb858
	ctx.lr = 0x82EE9514;
	sub_82EEB858(ctx, base);
	// 82EE9514: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82EE9518: 48000DB1  bl 0x82eea2c8
	ctx.lr = 0x82EE951C;
	sub_82EEA2C8(ctx, base);
	// 82EE951C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82EE9520: 48002339  bl 0x82eeb858
	ctx.lr = 0x82EE9524;
	sub_82EEB858(ctx, base);
	// 82EE9524: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82EE9528: 48002331  bl 0x82eeb858
	ctx.lr = 0x82EE952C;
	sub_82EEB858(ctx, base);
	// 82EE952C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82EE9530: 48000AC9  bl 0x82ee9ff8
	ctx.lr = 0x82EE9534;
	sub_82EE9FF8(ctx, base);
	// 82EE9534: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EE9538: 48002321  bl 0x82eeb858
	ctx.lr = 0x82EE953C;
	sub_82EEB858(ctx, base);
	// 82EE953C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EE9540: 48002319  bl 0x82eeb858
	ctx.lr = 0x82EE9544;
	sub_82EEB858(ctx, base);
	// 82EE9544: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EE9548: 48000C19  bl 0x82eea160
	ctx.lr = 0x82EE954C;
	sub_82EEA160(ctx, base);
	// 82EE954C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EE9550: 48002309  bl 0x82eeb858
	ctx.lr = 0x82EE9554;
	sub_82EEB858(ctx, base);
	// 82EE9554: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9558: 91610218  stw r11, 0x218(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 82EE955C: 48000010  b 0x82ee956c
	pc = 0x82EE956C; continue 'dispatch;
            }
            0x82EE9560 => {
    //   block [0x82EE9560..0x82EE956C)
	// 82EE9560: 81610218  lwz r11, 0x218(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(536 as u32) ) } as u64;
	// 82EE9564: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EE9568: 91610218  stw r11, 0x218(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE956C; continue 'dispatch;
            }
            0x82EE956C => {
    //   block [0x82EE956C..0x82EE9594)
	// 82EE956C: 81610218  lwz r11, 0x218(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(536 as u32) ) } as u64;
	// 82EE9570: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82EE9574: 40980084  bge cr6, 0x82ee95f8
	if !ctx.cr[6].lt {
	pc = 0x82EE95F8; continue 'dispatch;
	}
	// 82EE9578: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE957C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE9580: 419A0014  beq cr6, 0x82ee9594
	if ctx.cr[6].eq {
	pc = 0x82EE9594; continue 'dispatch;
	}
	// 82EE9584: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE9588: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82EE958C: 91610380  stw r11, 0x380(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(896 as u32), ctx.r[11].u32 ) };
	// 82EE9590: 4800000C  b 0x82ee959c
	pc = 0x82EE959C; continue 'dispatch;
            }
            0x82EE9594 => {
    //   block [0x82EE9594..0x82EE959C)
	// 82EE9594: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9598: 91610380  stw r11, 0x380(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(896 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE959C; continue 'dispatch;
            }
            0x82EE959C => {
    //   block [0x82EE959C..0x82EE95F8)
	// 82EE959C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE95A0: 3BEBC16C  addi r31, r11, -0x3e94
	ctx.r[31].s64 = ctx.r[11].s64 + -16020;
	// 82EE95A4: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE95A8: 396B0118  addi r11, r11, 0x118
	ctx.r[11].s64 = ctx.r[11].s64 + 280;
	// 82EE95AC: 81410218  lwz r10, 0x218(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(536 as u32) ) } as u64;
	// 82EE95B0: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EE95B4: 7FCB502A  ldx r30, r11, r10
	ctx.r[30].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	// 82EE95B8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE95BC: 3BABC020  addi r29, r11, -0x3fe0
	ctx.r[29].s64 = ctx.r[11].s64 + -16352;
	// 82EE95C0: 83810218  lwz r28, 0x218(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(536 as u32) ) } as u64;
	// 82EE95C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE95C8: 388BC004  addi r4, r11, -0x3ffc
	ctx.r[4].s64 = ctx.r[11].s64 + -16380;
	// 82EE95CC: 80610380  lwz r3, 0x380(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(896 as u32) ) } as u64;
	// 82EE95D0: 48002289  bl 0x82eeb858
	ctx.lr = 0x82EE95D4;
	sub_82EEB858(ctx, base);
	// 82EE95D4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82EE95D8: 4BD98C41  bl 0x82c82218
	ctx.lr = 0x82EE95DC;
	sub_82C82218(ctx, base);
	// 82EE95DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EE95E0: 480011D1  bl 0x82eea7b0
	ctx.lr = 0x82EE95E4;
	sub_82EEA7B0(ctx, base);
	// 82EE95E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EE95E8: 48000B79  bl 0x82eea160
	ctx.lr = 0x82EE95EC;
	sub_82EEA160(ctx, base);
	// 82EE95EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EE95F0: 48002269  bl 0x82eeb858
	ctx.lr = 0x82EE95F4;
	sub_82EEB858(ctx, base);
	// 82EE95F4: 4BFFFF6C  b 0x82ee9560
	pc = 0x82EE9560; continue 'dispatch;
            }
            0x82EE95F8 => {
    //   block [0x82EE95F8..0x82EE9614)
	// 82EE95F8: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE95FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE9600: 419A0014  beq cr6, 0x82ee9614
	if ctx.cr[6].eq {
	pc = 0x82EE9614; continue 'dispatch;
	}
	// 82EE9604: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE9608: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82EE960C: 91610384  stw r11, 0x384(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(900 as u32), ctx.r[11].u32 ) };
	// 82EE9610: 4800000C  b 0x82ee961c
	pc = 0x82EE961C; continue 'dispatch;
            }
            0x82EE9614 => {
    //   block [0x82EE9614..0x82EE961C)
	// 82EE9614: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9618: 91610384  stw r11, 0x384(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(900 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE961C; continue 'dispatch;
            }
            0x82EE961C => {
    //   block [0x82EE961C..0x82EE9648)
	// 82EE961C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9620: 3BEBC020  addi r31, r11, -0x3fe0
	ctx.r[31].s64 = ctx.r[11].s64 + -16352;
	// 82EE9624: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9628: 388BBFDC  addi r4, r11, -0x4024
	ctx.r[4].s64 = ctx.r[11].s64 + -16420;
	// 82EE962C: 80610384  lwz r3, 0x384(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(900 as u32) ) } as u64;
	// 82EE9630: 48002229  bl 0x82eeb858
	ctx.lr = 0x82EE9634;
	sub_82EEB858(ctx, base);
	// 82EE9634: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EE9638: 48001179  bl 0x82eea7b0
	ctx.lr = 0x82EE963C;
	sub_82EEA7B0(ctx, base);
	// 82EE963C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9640: 9161021C  stw r11, 0x21c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(540 as u32), ctx.r[11].u32 ) };
	// 82EE9644: 48000010  b 0x82ee9654
	pc = 0x82EE9654; continue 'dispatch;
            }
            0x82EE9648 => {
    //   block [0x82EE9648..0x82EE9654)
	// 82EE9648: 8161021C  lwz r11, 0x21c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EE964C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EE9650: 9161021C  stw r11, 0x21c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(540 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE9654; continue 'dispatch;
            }
            0x82EE9654 => {
    //   block [0x82EE9654..0x82EE9694)
	// 82EE9654: 8161021C  lwz r11, 0x21c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EE9658: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 82EE965C: 40980160  bge cr6, 0x82ee97bc
	if !ctx.cr[6].lt {
	pc = 0x82EE97BC; continue 'dispatch;
	}
	// 82EE9660: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE9664: 396B0348  addi r11, r11, 0x348
	ctx.r[11].s64 = ctx.r[11].s64 + 840;
	// 82EE9668: 8141021C  lwz r10, 0x21c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EE966C: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EE9670: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 82EE9674: 4098004C  bge cr6, 0x82ee96c0
	if !ctx.cr[6].lt {
	pc = 0x82EE96C0; continue 'dispatch;
	}
	// 82EE9678: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE967C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE9680: 419A0014  beq cr6, 0x82ee9694
	if ctx.cr[6].eq {
	pc = 0x82EE9694; continue 'dispatch;
	}
	// 82EE9684: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE9688: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82EE968C: 91610388  stw r11, 0x388(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(904 as u32), ctx.r[11].u32 ) };
	// 82EE9690: 4800000C  b 0x82ee969c
	pc = 0x82EE969C; continue 'dispatch;
            }
            0x82EE9694 => {
    //   block [0x82EE9694..0x82EE969C)
	// 82EE9694: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9698: 91610388  stw r11, 0x388(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(904 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE969C; continue 'dispatch;
            }
            0x82EE969C => {
    //   block [0x82EE969C..0x82EE96C0)
	// 82EE969C: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE96A0: 396B0348  addi r11, r11, 0x348
	ctx.r[11].s64 = ctx.r[11].s64 + 840;
	// 82EE96A4: 8141021C  lwz r10, 0x21c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EE96A8: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EE96AC: 396B0030  addi r11, r11, 0x30
	ctx.r[11].s64 = ctx.r[11].s64 + 48;
	// 82EE96B0: 7D640774  extsb r4, r11
	ctx.r[4].s64 = ctx.r[11].s8 as i64;
	// 82EE96B4: 80610388  lwz r3, 0x388(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(904 as u32) ) } as u64;
	// 82EE96B8: 48001441  bl 0x82eeaaf8
	ctx.lr = 0x82EE96BC;
	sub_82EEAAF8(ctx, base);
	// 82EE96BC: 480000FC  b 0x82ee97b8
	pc = 0x82EE97B8; continue 'dispatch;
            }
            0x82EE96C0 => {
    //   block [0x82EE96C0..0x82EE96F4)
	// 82EE96C0: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE96C4: 396B0348  addi r11, r11, 0x348
	ctx.r[11].s64 = ctx.r[11].s64 + 840;
	// 82EE96C8: 8141021C  lwz r10, 0x21c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EE96CC: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EE96D0: 2F0B0024  cmpwi cr6, r11, 0x24
	ctx.cr[6].compare_i32(ctx.r[11].s32, 36, &mut ctx.xer);
	// 82EE96D4: 40980050  bge cr6, 0x82ee9724
	if !ctx.cr[6].lt {
	pc = 0x82EE9724; continue 'dispatch;
	}
	// 82EE96D8: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE96DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE96E0: 419A0014  beq cr6, 0x82ee96f4
	if ctx.cr[6].eq {
	pc = 0x82EE96F4; continue 'dispatch;
	}
	// 82EE96E4: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE96E8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82EE96EC: 9161038C  stw r11, 0x38c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(908 as u32), ctx.r[11].u32 ) };
	// 82EE96F0: 4800000C  b 0x82ee96fc
	pc = 0x82EE96FC; continue 'dispatch;
            }
            0x82EE96F4 => {
    //   block [0x82EE96F4..0x82EE96FC)
	// 82EE96F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE96F8: 9161038C  stw r11, 0x38c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(908 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE96FC; continue 'dispatch;
            }
            0x82EE96FC => {
    //   block [0x82EE96FC..0x82EE9724)
	// 82EE96FC: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE9700: 396B0348  addi r11, r11, 0x348
	ctx.r[11].s64 = ctx.r[11].s64 + 840;
	// 82EE9704: 8141021C  lwz r10, 0x21c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EE9708: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EE970C: 396BFFF6  addi r11, r11, -0xa
	ctx.r[11].s64 = ctx.r[11].s64 + -10;
	// 82EE9710: 396B0041  addi r11, r11, 0x41
	ctx.r[11].s64 = ctx.r[11].s64 + 65;
	// 82EE9714: 7D640774  extsb r4, r11
	ctx.r[4].s64 = ctx.r[11].s8 as i64;
	// 82EE9718: 8061038C  lwz r3, 0x38c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(908 as u32) ) } as u64;
	// 82EE971C: 480013DD  bl 0x82eeaaf8
	ctx.lr = 0x82EE9720;
	sub_82EEAAF8(ctx, base);
	// 82EE9720: 48000098  b 0x82ee97b8
	pc = 0x82EE97B8; continue 'dispatch;
            }
            0x82EE9724 => {
    //   block [0x82EE9724..0x82EE9758)
	// 82EE9724: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE9728: 396B0348  addi r11, r11, 0x348
	ctx.r[11].s64 = ctx.r[11].s64 + 840;
	// 82EE972C: 8141021C  lwz r10, 0x21c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EE9730: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EE9734: 2F0B003E  cmpwi cr6, r11, 0x3e
	ctx.cr[6].compare_i32(ctx.r[11].s32, 62, &mut ctx.xer);
	// 82EE9738: 40980050  bge cr6, 0x82ee9788
	if !ctx.cr[6].lt {
	pc = 0x82EE9788; continue 'dispatch;
	}
	// 82EE973C: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE9740: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE9744: 419A0014  beq cr6, 0x82ee9758
	if ctx.cr[6].eq {
	pc = 0x82EE9758; continue 'dispatch;
	}
	// 82EE9748: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE974C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82EE9750: 91610390  stw r11, 0x390(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(912 as u32), ctx.r[11].u32 ) };
	// 82EE9754: 4800000C  b 0x82ee9760
	pc = 0x82EE9760; continue 'dispatch;
            }
            0x82EE9758 => {
    //   block [0x82EE9758..0x82EE9760)
	// 82EE9758: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE975C: 91610390  stw r11, 0x390(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(912 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE9760; continue 'dispatch;
            }
            0x82EE9760 => {
    //   block [0x82EE9760..0x82EE9788)
	// 82EE9760: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE9764: 396B0348  addi r11, r11, 0x348
	ctx.r[11].s64 = ctx.r[11].s64 + 840;
	// 82EE9768: 8141021C  lwz r10, 0x21c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(540 as u32) ) } as u64;
	// 82EE976C: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EE9770: 396BFFDC  addi r11, r11, -0x24
	ctx.r[11].s64 = ctx.r[11].s64 + -36;
	// 82EE9774: 396B0061  addi r11, r11, 0x61
	ctx.r[11].s64 = ctx.r[11].s64 + 97;
	// 82EE9778: 7D640774  extsb r4, r11
	ctx.r[4].s64 = ctx.r[11].s8 as i64;
	// 82EE977C: 80610390  lwz r3, 0x390(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(912 as u32) ) } as u64;
	// 82EE9780: 48001379  bl 0x82eeaaf8
	ctx.lr = 0x82EE9784;
	sub_82EEAAF8(ctx, base);
	// 82EE9784: 48000034  b 0x82ee97b8
	pc = 0x82EE97B8; continue 'dispatch;
            }
            0x82EE9788 => {
    //   block [0x82EE9788..0x82EE97A4)
	// 82EE9788: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE978C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE9790: 419A0014  beq cr6, 0x82ee97a4
	if ctx.cr[6].eq {
	pc = 0x82EE97A4; continue 'dispatch;
	}
	// 82EE9794: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE9798: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82EE979C: 91610394  stw r11, 0x394(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(916 as u32), ctx.r[11].u32 ) };
	// 82EE97A0: 4800000C  b 0x82ee97ac
	pc = 0x82EE97AC; continue 'dispatch;
            }
            0x82EE97A4 => {
    //   block [0x82EE97A4..0x82EE97AC)
	// 82EE97A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE97A8: 91610394  stw r11, 0x394(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(916 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE97AC; continue 'dispatch;
            }
            0x82EE97AC => {
    //   block [0x82EE97AC..0x82EE97B8)
	// 82EE97AC: 3880002E  li r4, 0x2e
	ctx.r[4].s64 = 46;
	// 82EE97B0: 80610394  lwz r3, 0x394(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(916 as u32) ) } as u64;
	// 82EE97B4: 48001345  bl 0x82eeaaf8
	ctx.lr = 0x82EE97B8;
	sub_82EEAAF8(ctx, base);
	pc = 0x82EE97B8; continue 'dispatch;
            }
            0x82EE97B8 => {
    //   block [0x82EE97B8..0x82EE97BC)
	// 82EE97B8: 4BFFFE90  b 0x82ee9648
	pc = 0x82EE9648; continue 'dispatch;
            }
            0x82EE97BC => {
    //   block [0x82EE97BC..0x82EE97D8)
	// 82EE97BC: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE97C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE97C4: 419A0014  beq cr6, 0x82ee97d8
	if ctx.cr[6].eq {
	pc = 0x82EE97D8; continue 'dispatch;
	}
	// 82EE97C8: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE97CC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82EE97D0: 91610398  stw r11, 0x398(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(920 as u32), ctx.r[11].u32 ) };
	// 82EE97D4: 4800000C  b 0x82ee97e0
	pc = 0x82EE97E0; continue 'dispatch;
            }
            0x82EE97D8 => {
    //   block [0x82EE97D8..0x82EE97E0)
	// 82EE97D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE97DC: 91610398  stw r11, 0x398(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(920 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE97E0; continue 'dispatch;
            }
            0x82EE97E0 => {
    //   block [0x82EE97E0..0x82EE980C)
	// 82EE97E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE97E4: 388BC16C  addi r4, r11, -0x3e94
	ctx.r[4].s64 = ctx.r[11].s64 + -16020;
	// 82EE97E8: 80610398  lwz r3, 0x398(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(920 as u32) ) } as u64;
	// 82EE97EC: 4800206D  bl 0x82eeb858
	ctx.lr = 0x82EE97F0;
	sub_82EEB858(ctx, base);
	// 82EE97F0: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE97F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE97F8: 419A0014  beq cr6, 0x82ee980c
	if ctx.cr[6].eq {
	pc = 0x82EE980C; continue 'dispatch;
	}
	// 82EE97FC: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 82EE9800: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82EE9804: 9161039C  stw r11, 0x39c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(924 as u32), ctx.r[11].u32 ) };
	// 82EE9808: 4800000C  b 0x82ee9814
	pc = 0x82EE9814; continue 'dispatch;
            }
            0x82EE980C => {
    //   block [0x82EE980C..0x82EE9814)
	// 82EE980C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9810: 9161039C  stw r11, 0x39c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(924 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE9814; continue 'dispatch;
            }
            0x82EE9814 => {
    //   block [0x82EE9814..0x82EE98B0)
	// 82EE9814: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9818: 388BBFD4  addi r4, r11, -0x402c
	ctx.r[4].s64 = ctx.r[11].s64 + -16428;
	// 82EE981C: 8061039C  lwz r3, 0x39c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(924 as u32) ) } as u64;
	// 82EE9820: 48002039  bl 0x82eeb858
	ctx.lr = 0x82EE9824;
	sub_82EEB858(ctx, base);
	// 82EE9824: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EE9828: 38810190  addi r4, r1, 0x190
	ctx.r[4].s64 = ctx.r[1].s64 + 400;
	// 82EE982C: 48001D05  bl 0x82eeb530
	ctx.lr = 0x82EE9830;
	sub_82EEB530(ctx, base);
	// 82EE9830: 80C1045C  lwz r6, 0x45c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1116 as u32) ) } as u64;
	// 82EE9834: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE9838: 38ABBFC0  addi r5, r11, -0x4040
	ctx.r[5].s64 = ctx.r[11].s64 + -16448;
	// 82EE983C: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EE9840: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EE9844: 48001805  bl 0x82eeb048
	ctx.lr = 0x82EE9848;
	sub_82EEB048(ctx, base);
	// 82EE9848: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82EE984C: 39000080  li r8, 0x80
	ctx.r[8].s64 = 128;
	// 82EE9850: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 82EE9854: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EE9858: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EE985C: 3C804000  lis r4, 0x4000
	ctx.r[4].s64 = 1073741824;
	// 82EE9860: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EE9864: 4BDD9C2D  bl 0x82cc3490
	ctx.lr = 0x82EE9868;
	sub_82CC3490(ctx, base);
	// 82EE9868: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EE986C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EE9870: 48001AD1  bl 0x82eeb340
	ctx.lr = 0x82EE9874;
	sub_82EEB340(ctx, base);
	// 82EE9874: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EE9878: 48001B59  bl 0x82eeb3d0
	ctx.lr = 0x82EE987C;
	sub_82EEB3D0(ctx, base);
	// 82EE987C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE9880: 41820030  beq 0x82ee98b0
	if ctx.cr[0].eq {
	pc = 0x82EE98B0; continue 'dispatch;
	}
	// 82EE9884: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EE9888: 616B4005  ori r11, r11, 0x4005
	ctx.r[11].u64 = ctx.r[11].u64 | 16389;
	// 82EE988C: 91610334  stw r11, 0x334(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(820 as u32), ctx.r[11].u32 ) };
	// 82EE9890: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EE9894: 48001ACD  bl 0x82eeb360
	ctx.lr = 0x82EE9898;
	sub_82EEB360(ctx, base);
	// 82EE9898: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EE989C: 4B408A1D  bl 0x822f22b8
	ctx.lr = 0x82EE98A0;
	sub_822F22B8(ctx, base);
	// 82EE98A0: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	// 82EE98A4: 48001A65  bl 0x82eeb308
	ctx.lr = 0x82EE98A8;
	sub_82EEB308(ctx, base);
	// 82EE98A8: 80610334  lwz r3, 0x334(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(820 as u32) ) } as u64;
	// 82EE98AC: 48000190  b 0x82ee9a3c
	pc = 0x82EE9A3C; continue 'dispatch;
            }
            0x82EE98B0 => {
    //   block [0x82EE98B0..0x82EE9918)
	// 82EE98B0: 3960FEFF  li r11, -0x101
	ctx.r[11].s64 = -257;
	// 82EE98B4: B161006C  sth r11, 0x6c(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u16 ) };
	// 82EE98B8: 3BE10078  addi r31, r1, 0x78
	ctx.r[31].s64 = ctx.r[1].s64 + 120;
	// 82EE98BC: 3BC1006C  addi r30, r1, 0x6c
	ctx.r[30].s64 = ctx.r[1].s64 + 108;
	// 82EE98C0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EE98C4: 480038FD  bl 0x82eed1c0
	ctx.lr = 0x82EE98C8;
	sub_82EED1C0(ctx, base);
	// 82EE98C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82EE98CC: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82EE98D0: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EE98D4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EE98D8: 4BDDD6E1  bl 0x82cc6fb8
	ctx.lr = 0x82EE98DC;
	sub_82CC6FB8(ctx, base);
	// 82EE98DC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EE98E0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EE98E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE98E8: 409A0030  bne cr6, 0x82ee9918
	if !ctx.cr[6].eq {
	pc = 0x82EE9918; continue 'dispatch;
	}
	// 82EE98EC: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EE98F0: 616B4005  ori r11, r11, 0x4005
	ctx.r[11].u64 = ctx.r[11].u64 | 16389;
	// 82EE98F4: 91610338  stw r11, 0x338(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(824 as u32), ctx.r[11].u32 ) };
	// 82EE98F8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EE98FC: 48001A65  bl 0x82eeb360
	ctx.lr = 0x82EE9900;
	sub_82EEB360(ctx, base);
	// 82EE9900: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EE9904: 4B4089B5  bl 0x822f22b8
	ctx.lr = 0x82EE9908;
	sub_822F22B8(ctx, base);
	// 82EE9908: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	// 82EE990C: 480019FD  bl 0x82eeb308
	ctx.lr = 0x82EE9910;
	sub_82EEB308(ctx, base);
	// 82EE9910: 80610338  lwz r3, 0x338(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(824 as u32) ) } as u64;
	// 82EE9914: 48000128  b 0x82ee9a3c
	pc = 0x82EE9A3C; continue 'dispatch;
            }
            0x82EE9918 => {
    //   block [0x82EE9918..0x82EE9994)
	// 82EE9918: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EE991C: 48000B15  bl 0x82eea430
	ctx.lr = 0x82EE9920;
	sub_82EEA430(ctx, base);
	// 82EE9920: 546B083C  slwi r11, r3, 1
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EE9924: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82EE9928: 3BE10078  addi r31, r1, 0x78
	ctx.r[31].s64 = ctx.r[1].s64 + 120;
	// 82EE992C: 83C1007C  lwz r30, 0x7c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EE9930: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EE9934: 4B40D045  bl 0x822f6978
	ctx.lr = 0x82EE9938;
	sub_822F6978(ctx, base);
	// 82EE9938: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82EE993C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EE9940: 48003881  bl 0x82eed1c0
	ctx.lr = 0x82EE9944;
	sub_82EED1C0(ctx, base);
	// 82EE9944: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82EE9948: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82EE994C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82EE9950: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82EE9954: 4BDDD665  bl 0x82cc6fb8
	ctx.lr = 0x82EE9958;
	sub_82CC6FB8(ctx, base);
	// 82EE9958: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EE995C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EE9960: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE9964: 409A0030  bne cr6, 0x82ee9994
	if !ctx.cr[6].eq {
	pc = 0x82EE9994; continue 'dispatch;
	}
	// 82EE9968: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82EE996C: 616B4005  ori r11, r11, 0x4005
	ctx.r[11].u64 = ctx.r[11].u64 | 16389;
	// 82EE9970: 9161033C  stw r11, 0x33c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(828 as u32), ctx.r[11].u32 ) };
	// 82EE9974: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EE9978: 480019E9  bl 0x82eeb360
	ctx.lr = 0x82EE997C;
	sub_82EEB360(ctx, base);
	// 82EE997C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EE9980: 4B408939  bl 0x822f22b8
	ctx.lr = 0x82EE9984;
	sub_822F22B8(ctx, base);
	// 82EE9984: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	// 82EE9988: 48001981  bl 0x82eeb308
	ctx.lr = 0x82EE998C;
	sub_82EEB308(ctx, base);
	// 82EE998C: 8061033C  lwz r3, 0x33c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(828 as u32) ) } as u64;
	// 82EE9990: 480000AC  b 0x82ee9a3c
	pc = 0x82EE9A3C; continue 'dispatch;
            }
            0x82EE9994 => {
    //   block [0x82EE9994..0x82EE99B8)
	// 82EE9994: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE9998: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE999C: 994B0364  stb r10, 0x364(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(868 as u32), ctx.r[10].u8 ) };
	// 82EE99A0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EE99A4: 480019BD  bl 0x82eeb360
	ctx.lr = 0x82EE99A8;
	sub_82EEB360(ctx, base);
	// 82EE99A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82EE99AC: 4B40890D  bl 0x822f22b8
	ctx.lr = 0x82EE99B0;
	sub_822F22B8(ctx, base);
	// 82EE99B0: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	// 82EE99B4: 48001955  bl 0x82eeb308
	ctx.lr = 0x82EE99B8;
	sub_82EEB308(ctx, base);
	pc = 0x82EE99B8; continue 'dispatch;
            }
            0x82EE99B8 => {
    //   block [0x82EE99B8..0x82EE9A2C)
	// 82EE99B8: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE99BC: 896B0365  lbz r11, 0x365(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(869 as u32) ) } as u64;
	// 82EE99C0: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EE99C4: 41820074  beq 0x82ee9a38
	if ctx.cr[0].eq {
	pc = 0x82EE9A38; continue 'dispatch;
	}
	// 82EE99C8: 89610467  lbz r11, 0x467(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(1127 as u32) ) } as u64;
	// 82EE99CC: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EE99D0: 41820068  beq 0x82ee9a38
	if ctx.cr[0].eq {
	pc = 0x82EE9A38; continue 'dispatch;
	}
	// 82EE99D4: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE99D8: 816B0360  lwz r11, 0x360(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(864 as u32) ) } as u64;
	// 82EE99DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE99E0: 419A0058  beq cr6, 0x82ee9a38
	if ctx.cr[6].eq {
	pc = 0x82EE9A38; continue 'dispatch;
	}
	// 82EE99E4: 80C1045C  lwz r6, 0x45c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1116 as u32) ) } as u64;
	// 82EE99E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EE99EC: 38ABBE1C  addi r5, r11, -0x41e4
	ctx.r[5].s64 = ctx.r[11].s64 + -16868;
	// 82EE99F0: 38800104  li r4, 0x104
	ctx.r[4].s64 = 260;
	// 82EE99F4: 38610230  addi r3, r1, 0x230
	ctx.r[3].s64 = ctx.r[1].s64 + 560;
	// 82EE99F8: 48001651  bl 0x82eeb048
	ctx.lr = 0x82EE99FC;
	sub_82EEB048(ctx, base);
	// 82EE99FC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82EE9A00: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE9A04: 80AB0360  lwz r5, 0x360(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(864 as u32) ) } as u64;
	// 82EE9A08: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82EE9A0C: 38610230  addi r3, r1, 0x230
	ctx.r[3].s64 = ctx.r[1].s64 + 560;
	// 82EE9A10: 4BE2CEB1  bl 0x82d168c0
	ctx.lr = 0x82EE9A14;
	sub_82D168C0(ctx, base);
	// 82EE9A14: 90610220  stw r3, 0x220(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(544 as u32), ctx.r[3].u32 ) };
	// 82EE9A18: 81610220  lwz r11, 0x220(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(544 as u32) ) } as u64;
	// 82EE9A1C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE9A20: 4098000C  bge cr6, 0x82ee9a2c
	if !ctx.cr[6].lt {
	pc = 0x82EE9A2C; continue 'dispatch;
	}
	// 82EE9A24: 80610220  lwz r3, 0x220(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(544 as u32) ) } as u64;
	// 82EE9A28: 48000014  b 0x82ee9a3c
	pc = 0x82EE9A3C; continue 'dispatch;
            }
            0x82EE9A2C => {
    //   block [0x82EE9A2C..0x82EE9A38)
	// 82EE9A2C: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82EE9A30: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE9A34: 994B0365  stb r10, 0x365(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(869 as u32), ctx.r[10].u8 ) };
	pc = 0x82EE9A38; continue 'dispatch;
            }
            0x82EE9A38 => {
    //   block [0x82EE9A38..0x82EE9A3C)
	// 82EE9A38: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EE9A3C; continue 'dispatch;
            }
            0x82EE9A3C => {
    //   block [0x82EE9A3C..0x82EE9A44)
	// 82EE9A3C: 38210440  addi r1, r1, 0x440
	ctx.r[1].s64 = ctx.r[1].s64 + 1088;
	// 82EE9A40: 4BDBF9E0  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE9A48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EE9A48 size=1016
    let mut pc: u32 = 0x82EE9A48;
    'dispatch: loop {
        match pc {
            0x82EE9A48 => {
    //   block [0x82EE9A48..0x82EE9B10)
	// 82EE9A48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE9A4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EE9A50: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE9A54: 906100F4  stw r3, 0xf4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), ctx.r[3].u32 ) };
	// 82EE9A58: 908100FC  stw r4, 0xfc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), ctx.r[4].u32 ) };
	// 82EE9A5C: 90A10104  stw r5, 0x104(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[5].u32 ) };
	// 82EE9A60: 90C1010C  stw r6, 0x10c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), ctx.r[6].u32 ) };
	// 82EE9A64: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9A68: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EE9A6C: 994B0364  stb r10, 0x364(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(868 as u32), ctx.r[10].u8 ) };
	// 82EE9A70: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9A74: E96B0108  ld r11, 0x108(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(264 as u32) ) };
	// 82EE9A78: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 82EE9A7C: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9A80: E96B0130  ld r11, 0x130(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(304 as u32) ) };
	// 82EE9A84: F96100A8  std r11, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u64 ) };
	// 82EE9A88: 81610104  lwz r11, 0x104(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82EE9A8C: E96B0108  ld r11, 0x108(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(264 as u32) ) };
	// 82EE9A90: 396BFE0C  addi r11, r11, -0x1f4
	ctx.r[11].s64 = ctx.r[11].s64 + -500;
	// 82EE9A94: F9610098  std r11, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u64 ) };
	// 82EE9A98: 81610104  lwz r11, 0x104(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82EE9A9C: E96B0130  ld r11, 0x130(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(304 as u32) ) };
	// 82EE9AA0: F96100B8  std r11, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[11].u64 ) };
	// 82EE9AA4: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9AA8: E96B0108  ld r11, 0x108(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(264 as u32) ) };
	// 82EE9AAC: E9410098  ld r10, 0x98(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 82EE9AB0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EE9AB4: 814100F4  lwz r10, 0xf4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9AB8: F96A0108  std r11, 0x108(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(264 as u32), ctx.r[11].u64 ) };
	// 82EE9ABC: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9AC0: E96B0130  ld r11, 0x130(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(304 as u32) ) };
	// 82EE9AC4: E94100B8  ld r10, 0xb8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	// 82EE9AC8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EE9ACC: 814100F4  lwz r10, 0xf4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9AD0: F96A0130  std r11, 0x130(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(304 as u32), ctx.r[11].u64 ) };
	// 82EE9AD4: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9AD8: E96B0108  ld r11, 0x108(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(264 as u32) ) };
	// 82EE9ADC: 2F2B0000  cmpdi cr6, r11, 0
	ctx.cr[6].compare_i64(ctx.r[11].s64, 0, &mut ctx.xer);
	// 82EE9AE0: 40980030  bge cr6, 0x82ee9b10
	if !ctx.cr[6].lt {
	pc = 0x82EE9B10; continue 'dispatch;
	}
	// 82EE9AE4: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9AE8: 814100F4  lwz r10, 0xf4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9AEC: E94A0108  ld r10, 0x108(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(264 as u32) ) };
	// 82EE9AF0: 7D4A00D0  neg r10, r10
	ctx.r[10].s64 = -ctx.r[10].s64;
	// 82EE9AF4: E96B0130  ld r11, 0x130(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(304 as u32) ) };
	// 82EE9AF8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EE9AFC: 814100F4  lwz r10, 0xf4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9B00: F96A0130  std r11, 0x130(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(304 as u32), ctx.r[11].u64 ) };
	// 82EE9B04: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9B08: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EE9B0C: F94B0108  std r10, 0x108(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(264 as u32), ctx.r[10].u64 ) };
	pc = 0x82EE9B10; continue 'dispatch;
            }
            0x82EE9B10 => {
    //   block [0x82EE9B10..0x82EE9B1C)
	// 82EE9B10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9B14: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82EE9B18: 48000010  b 0x82ee9b28
	pc = 0x82EE9B28; continue 'dispatch;
            }
            0x82EE9B1C => {
    //   block [0x82EE9B1C..0x82EE9B28)
	// 82EE9B1C: 816100C0  lwz r11, 0xc0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 82EE9B20: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EE9B24: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE9B28; continue 'dispatch;
            }
            0x82EE9B28 => {
    //   block [0x82EE9B28..0x82EE9B5C)
	// 82EE9B28: 816100C0  lwz r11, 0xc0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 82EE9B2C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82EE9B30: 4098002C  bge cr6, 0x82ee9b5c
	if !ctx.cr[6].lt {
	pc = 0x82EE9B5C; continue 'dispatch;
	}
	// 82EE9B34: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9B38: 396B0118  addi r11, r11, 0x118
	ctx.r[11].s64 = ctx.r[11].s64 + 280;
	// 82EE9B3C: 814100C0  lwz r10, 0xc0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 82EE9B40: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EE9B44: 812100C0  lwz r9, 0xc0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 82EE9B48: 55291838  slwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82EE9B4C: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 82EE9B50: 7D6B502A  ldx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	// 82EE9B54: 7D68492A  stdx r11, r8, r9
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32), ctx.r[11].u64) };
	// 82EE9B58: 4BFFFFC4  b 0x82ee9b1c
	pc = 0x82EE9B1C; continue 'dispatch;
            }
            0x82EE9B5C => {
    //   block [0x82EE9B5C..0x82EE9B70)
	// 82EE9B5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9B60: F96100A0  std r11, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u64 ) };
	// 82EE9B64: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9B68: 916100C4  stw r11, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 82EE9B6C: 48000010  b 0x82ee9b7c
	pc = 0x82EE9B7C; continue 'dispatch;
            }
            0x82EE9B70 => {
    //   block [0x82EE9B70..0x82EE9B7C)
	// 82EE9B70: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9B74: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EE9B78: 916100C4  stw r11, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE9B7C; continue 'dispatch;
            }
            0x82EE9B7C => {
    //   block [0x82EE9B7C..0x82EE9BEC)
	// 82EE9B7C: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9B80: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82EE9B84: 40980068  bge cr6, 0x82ee9bec
	if !ctx.cr[6].lt {
	pc = 0x82EE9BEC; continue 'dispatch;
	}
	// 82EE9B88: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9B8C: 396B0118  addi r11, r11, 0x118
	ctx.r[11].s64 = ctx.r[11].s64 + 280;
	// 82EE9B90: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9B94: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EE9B98: 81210104  lwz r9, 0x104(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82EE9B9C: 39290118  addi r9, r9, 0x118
	ctx.r[9].s64 = ctx.r[9].s64 + 280;
	// 82EE9BA0: 810100C4  lwz r8, 0xc4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9BA4: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82EE9BA8: 7D6B502A  ldx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	// 82EE9BAC: 7D49402A  ldx r10, r9, r8
	ctx.r[10].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) };
	// 82EE9BB0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82EE9BB4: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9BB8: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EE9BBC: 812100F4  lwz r9, 0xf4(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9BC0: 39290118  addi r9, r9, 0x118
	ctx.r[9].s64 = ctx.r[9].s64 + 280;
	// 82EE9BC4: 7D69512A  stdx r11, r9, r10
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u64) };
	// 82EE9BC8: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9BCC: 396B0118  addi r11, r11, 0x118
	ctx.r[11].s64 = ctx.r[11].s64 + 280;
	// 82EE9BD0: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9BD4: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82EE9BD8: E92100A0  ld r9, 0xa0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 82EE9BDC: 7D6B502A  ldx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	// 82EE9BE0: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82EE9BE4: F96100A0  std r11, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u64 ) };
	// 82EE9BE8: 4BFFFF88  b 0x82ee9b70
	pc = 0x82EE9B70; continue 'dispatch;
            }
            0x82EE9BEC => {
    //   block [0x82EE9BEC..0x82EE9C1C)
	// 82EE9BEC: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9BF0: E96B0110  ld r11, 0x110(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(272 as u32) ) };
	// 82EE9BF4: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 82EE9BF8: E96100A0  ld r11, 0xa0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 82EE9BFC: 3D400004  lis r10, 4
	ctx.r[10].s64 = 262144;
	// 82EE9C00: 614A93E0  ori r10, r10, 0x93e0
	ctx.r[10].u64 = ctx.r[10].u64 | 37856;
	// 82EE9C04: 7F2B5000  cmpd cr6, r11, r10
	ctx.cr[6].compare_i64(ctx.r[11].s64, ctx.r[10].s64, &mut ctx.xer);
	// 82EE9C08: 40990014  ble cr6, 0x82ee9c1c
	if !ctx.cr[6].gt {
	pc = 0x82EE9C1C; continue 'dispatch;
	}
	// 82EE9C0C: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9C10: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 82EE9C14: F94B0110  std r10, 0x110(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(272 as u32), ctx.r[10].u64 ) };
	// 82EE9C18: 4800005C  b 0x82ee9c74
	pc = 0x82EE9C74; continue 'dispatch;
            }
            0x82EE9C1C => {
    //   block [0x82EE9C1C..0x82EE9C40)
	// 82EE9C1C: E96100A0  ld r11, 0xa0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 82EE9C20: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 82EE9C24: 614A24F8  ori r10, r10, 0x24f8
	ctx.r[10].u64 = ctx.r[10].u64 | 9464;
	// 82EE9C28: 7F2B5000  cmpd cr6, r11, r10
	ctx.cr[6].compare_i64(ctx.r[11].s64, ctx.r[10].s64, &mut ctx.xer);
	// 82EE9C2C: 40990014  ble cr6, 0x82ee9c40
	if !ctx.cr[6].gt {
	pc = 0x82EE9C40; continue 'dispatch;
	}
	// 82EE9C30: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9C34: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82EE9C38: F94B0110  std r10, 0x110(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(272 as u32), ctx.r[10].u64 ) };
	// 82EE9C3C: 48000038  b 0x82ee9c74
	pc = 0x82EE9C74; continue 'dispatch;
            }
            0x82EE9C40 => {
    //   block [0x82EE9C40..0x82EE9C5C)
	// 82EE9C40: E96100A0  ld r11, 0xa0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 82EE9C44: 2F2B3A98  cmpdi cr6, r11, 0x3a98
	ctx.cr[6].compare_i64(ctx.r[11].s64, 15000, &mut ctx.xer);
	// 82EE9C48: 40990014  ble cr6, 0x82ee9c5c
	if !ctx.cr[6].gt {
	pc = 0x82EE9C5C; continue 'dispatch;
	}
	// 82EE9C4C: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9C50: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 82EE9C54: F94B0110  std r10, 0x110(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(272 as u32), ctx.r[10].u64 ) };
	// 82EE9C58: 4800001C  b 0x82ee9c74
	pc = 0x82EE9C74; continue 'dispatch;
            }
            0x82EE9C5C => {
    //   block [0x82EE9C5C..0x82EE9C74)
	// 82EE9C5C: E96100A0  ld r11, 0xa0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 82EE9C60: 2F2B0BB8  cmpdi cr6, r11, 0xbb8
	ctx.cr[6].compare_i64(ctx.r[11].s64, 3000, &mut ctx.xer);
	// 82EE9C64: 40990010  ble cr6, 0x82ee9c74
	if !ctx.cr[6].gt {
	pc = 0x82EE9C74; continue 'dispatch;
	}
	// 82EE9C68: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9C6C: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82EE9C70: F94B0110  std r10, 0x110(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(272 as u32), ctx.r[10].u64 ) };
	pc = 0x82EE9C74; continue 'dispatch;
            }
            0x82EE9C74 => {
    //   block [0x82EE9C74..0x82EE9CA8)
	// 82EE9C74: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9C78: E96B0358  ld r11, 0x358(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(856 as u32) ) };
	// 82EE9C7C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82EE9C80: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9C84: 81410104  lwz r10, 0x104(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82EE9C88: E96B0358  ld r11, 0x358(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(856 as u32) ) };
	// 82EE9C8C: E94A0358  ld r10, 0x358(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(856 as u32) ) };
	// 82EE9C90: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82EE9C94: 814100F4  lwz r10, 0xf4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9C98: F96A0358  std r11, 0x358(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(856 as u32), ctx.r[11].u64 ) };
	// 82EE9C9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9CA0: 916100C8  stw r11, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 82EE9CA4: 48000010  b 0x82ee9cb4
	pc = 0x82EE9CB4; continue 'dispatch;
            }
            0x82EE9CA8 => {
    //   block [0x82EE9CA8..0x82EE9CB4)
	// 82EE9CA8: 816100C8  lwz r11, 0xc8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 82EE9CAC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EE9CB0: 916100C8  stw r11, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE9CB4; continue 'dispatch;
            }
            0x82EE9CB4 => {
    //   block [0x82EE9CB4..0x82EE9CE0)
	// 82EE9CB4: 816100C8  lwz r11, 0xc8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 82EE9CB8: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 82EE9CBC: 40980024  bge cr6, 0x82ee9ce0
	if !ctx.cr[6].lt {
	pc = 0x82EE9CE0; continue 'dispatch;
	}
	// 82EE9CC0: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9CC4: 396B0348  addi r11, r11, 0x348
	ctx.r[11].s64 = ctx.r[11].s64 + 840;
	// 82EE9CC8: 814100C8  lwz r10, 0xc8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 82EE9CCC: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82EE9CD0: 810100C8  lwz r8, 0xc8(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 82EE9CD4: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EE9CD8: 7D6941AE  stbx r11, r9, r8
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[11].u8) };
	// 82EE9CDC: 4BFFFFCC  b 0x82ee9ca8
	pc = 0x82EE9CA8; continue 'dispatch;
            }
            0x82EE9CE0 => {
    //   block [0x82EE9CE0..0x82EE9CEC)
	// 82EE9CE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9CE4: 916100CC  stw r11, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 82EE9CE8: 48000010  b 0x82ee9cf8
	pc = 0x82EE9CF8; continue 'dispatch;
            }
            0x82EE9CEC => {
    //   block [0x82EE9CEC..0x82EE9CF8)
	// 82EE9CEC: 816100CC  lwz r11, 0xcc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82EE9CF0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EE9CF4: 916100CC  stw r11, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE9CF8; continue 'dispatch;
            }
            0x82EE9CF8 => {
    //   block [0x82EE9CF8..0x82EE9D24)
	// 82EE9CF8: 816100CC  lwz r11, 0xcc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82EE9CFC: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 82EE9D00: 40980024  bge cr6, 0x82ee9d24
	if !ctx.cr[6].lt {
	pc = 0x82EE9D24; continue 'dispatch;
	}
	// 82EE9D04: 808100CC  lwz r4, 0xcc(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82EE9D08: 80610104  lwz r3, 0x104(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82EE9D0C: 4BFFED35  bl 0x82ee8a40
	ctx.lr = 0x82EE9D10;
	sub_82EE8A40(ctx, base);
	// 82EE9D10: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82EE9D14: 808100CC  lwz r4, 0xcc(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82EE9D18: 806100F4  lwz r3, 0xf4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9D1C: 4BFFED45  bl 0x82ee8a60
	ctx.lr = 0x82EE9D20;
	sub_82EE8A60(ctx, base);
	// 82EE9D20: 4BFFFFCC  b 0x82ee9cec
	pc = 0x82EE9CEC; continue 'dispatch;
            }
            0x82EE9D24 => {
    //   block [0x82EE9D24..0x82EE9D68)
	// 82EE9D24: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EE9D28: 8081010C  lwz r4, 0x10c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as u64;
	// 82EE9D2C: 806100FC  lwz r3, 0xfc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(252 as u32) ) } as u64;
	// 82EE9D30: 4BDDA551  bl 0x82cc4280
	ctx.lr = 0x82EE9D34;
	sub_82CC4280(ctx, base);
	// 82EE9D34: 906100B0  stw r3, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[3].u32 ) };
	// 82EE9D38: 816100B0  lwz r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82EE9D3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE9D40: 419A00EC  beq cr6, 0x82ee9e2c
	if ctx.cr[6].eq {
	pc = 0x82EE9E2C; continue 'dispatch;
	}
	// 82EE9D44: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9D48: E9410070  ld r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82EE9D4C: F94B0108  std r10, 0x108(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(264 as u32), ctx.r[10].u64 ) };
	// 82EE9D50: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9D54: E94100A8  ld r10, 0xa8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 82EE9D58: F94B0130  std r10, 0x130(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(304 as u32), ctx.r[10].u64 ) };
	// 82EE9D5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9D60: 916100D0  stw r11, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 82EE9D64: 48000010  b 0x82ee9d74
	pc = 0x82EE9D74; continue 'dispatch;
            }
            0x82EE9D68 => {
    //   block [0x82EE9D68..0x82EE9D74)
	// 82EE9D68: 816100D0  lwz r11, 0xd0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) } as u64;
	// 82EE9D6C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EE9D70: 916100D0  stw r11, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE9D74; continue 'dispatch;
            }
            0x82EE9D74 => {
    //   block [0x82EE9D74..0x82EE9DA8)
	// 82EE9D74: 816100D0  lwz r11, 0xd0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) } as u64;
	// 82EE9D78: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82EE9D7C: 4098002C  bge cr6, 0x82ee9da8
	if !ctx.cr[6].lt {
	pc = 0x82EE9DA8; continue 'dispatch;
	}
	// 82EE9D80: 816100D0  lwz r11, 0xd0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) } as u64;
	// 82EE9D84: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82EE9D88: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 82EE9D8C: 812100F4  lwz r9, 0xf4(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9D90: 39290118  addi r9, r9, 0x118
	ctx.r[9].s64 = ctx.r[9].s64 + 280;
	// 82EE9D94: 810100D0  lwz r8, 0xd0(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) } as u64;
	// 82EE9D98: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82EE9D9C: 7D6A582A  ldx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	// 82EE9DA0: 7D69412A  stdx r11, r9, r8
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[11].u64) };
	// 82EE9DA4: 4BFFFFC4  b 0x82ee9d68
	pc = 0x82EE9D68; continue 'dispatch;
            }
            0x82EE9DA8 => {
    //   block [0x82EE9DA8..0x82EE9DC0)
	// 82EE9DA8: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9DAC: E9410060  ld r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82EE9DB0: F94B0358  std r10, 0x358(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(856 as u32), ctx.r[10].u64 ) };
	// 82EE9DB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9DB8: 916100D4  stw r11, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 82EE9DBC: 48000010  b 0x82ee9dcc
	pc = 0x82EE9DCC; continue 'dispatch;
            }
            0x82EE9DC0 => {
    //   block [0x82EE9DC0..0x82EE9DCC)
	// 82EE9DC0: 816100D4  lwz r11, 0xd4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EE9DC4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EE9DC8: 916100D4  stw r11, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE9DCC; continue 'dispatch;
            }
            0x82EE9DCC => {
    //   block [0x82EE9DCC..0x82EE9DF8)
	// 82EE9DCC: 816100D4  lwz r11, 0xd4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EE9DD0: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 82EE9DD4: 40980024  bge cr6, 0x82ee9df8
	if !ctx.cr[6].lt {
	pc = 0x82EE9DF8; continue 'dispatch;
	}
	// 82EE9DD8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EE9DDC: 814100D4  lwz r10, 0xd4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EE9DE0: 812100F4  lwz r9, 0xf4(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9DE4: 39290348  addi r9, r9, 0x348
	ctx.r[9].s64 = ctx.r[9].s64 + 840;
	// 82EE9DE8: 810100D4  lwz r8, 0xd4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82EE9DEC: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82EE9DF0: 7D6941AE  stbx r11, r9, r8
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[11].u8) };
	// 82EE9DF4: 4BFFFFCC  b 0x82ee9dc0
	pc = 0x82EE9DC0; continue 'dispatch;
            }
            0x82EE9DF8 => {
    //   block [0x82EE9DF8..0x82EE9E20)
	// 82EE9DF8: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82EE9DFC: E9410068  ld r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82EE9E00: F94B0110  std r10, 0x110(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(272 as u32), ctx.r[10].u64 ) };
	// 82EE9E04: 816100B0  lwz r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82EE9E08: 2B0B048F  cmplwi cr6, r11, 0x48f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1167 as u32, &mut ctx.xer);
	// 82EE9E0C: 409A0014  bne cr6, 0x82ee9e20
	if !ctx.cr[6].eq {
	pc = 0x82EE9E20; continue 'dispatch;
	}
	// 82EE9E10: 3860048F  li r3, 0x48f
	ctx.r[3].s64 = 1167;
	// 82EE9E14: 4B41806D  bl 0x82301e80
	ctx.lr = 0x82EE9E18;
	sub_82301E80(ctx, base);
	// 82EE9E18: 48000018  b 0x82ee9e30
	pc = 0x82EE9E30; continue 'dispatch;
	// 82EE9E1C: 48000010  b 0x82ee9e2c
	pc = 0x82EE9E2C; continue 'dispatch;
            }
            0x82EE9E20 => {
    //   block [0x82EE9E20..0x82EE9E2C)
	// 82EE9E20: 806100B0  lwz r3, 0xb0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82EE9E24: 4B41805D  bl 0x82301e80
	ctx.lr = 0x82EE9E28;
	sub_82301E80(ctx, base);
	// 82EE9E28: 48000008  b 0x82ee9e30
	pc = 0x82EE9E30; continue 'dispatch;
            }
            0x82EE9E2C => {
    //   block [0x82EE9E2C..0x82EE9E30)
	// 82EE9E2C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EE9E30; continue 'dispatch;
            }
            0x82EE9E30 => {
    //   block [0x82EE9E30..0x82EE9E40)
	// 82EE9E30: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82EE9E34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE9E38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EE9E3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE9E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EE9E40 size=440
    let mut pc: u32 = 0x82EE9E40;
    'dispatch: loop {
        match pc {
            0x82EE9E40 => {
    //   block [0x82EE9E40..0x82EE9EE8)
	// 82EE9E40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE9E44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EE9E48: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EE9E4C: 906100C4  stw r3, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[3].u32 ) };
	// 82EE9E50: 908100CC  stw r4, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[4].u32 ) };
	// 82EE9E54: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9E58: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EE9E5C: 808100C4  lwz r4, 0xc4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9E60: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EE9E64: 4BD96DED  bl 0x82c80c50
	ctx.lr = 0x82EE9E68;
	sub_82C80C50(ctx, base);
	// 82EE9E68: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EE9E6C: 4BD9610D  bl 0x82c7ff78
	ctx.lr = 0x82EE9E70;
	sub_82C7FF78(ctx, base);
	// 82EE9E70: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE9E74: 41820140  beq 0x82ee9fb4
	if ctx.cr[0].eq {
	pc = 0x82EE9FB4; continue 'dispatch;
	}
	// 82EE9E78: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82EE9E7C: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9E80: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE9E84: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9E88: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE9E8C: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EE9E90: 4B792549  bl 0x8267c3d8
	ctx.lr = 0x82EE9E94;
	sub_8267C3D8(ctx, base);
	// 82EE9E94: 4BD96E5D  bl 0x82c80cf0
	ctx.lr = 0x82EE9E98;
	sub_82C80CF0(ctx, base);
	// 82EE9E98: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 82EE9E9C: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82EE9EA0: 4B792481  bl 0x8267c320
	ctx.lr = 0x82EE9EA4;
	sub_8267C320(ctx, base);
	// 82EE9EA4: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9EA8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE9EAC: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9EB0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE9EB4: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EE9EB8: 482D21A9  bl 0x831bc060
	ctx.lr = 0x82EE9EBC;
	sub_831BC060(ctx, base);
	// 82EE9EBC: 546B052C  rlwinm r11, r3, 0, 0x14, 0x16
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0xFFFFFFFFu64;
	// 82EE9EC0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82EE9EC4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EE9EC8: 2F0B0400  cmpwi cr6, r11, 0x400
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1024, &mut ctx.xer);
	// 82EE9ECC: 419A001C  beq cr6, 0x82ee9ee8
	if ctx.cr[6].eq {
	pc = 0x82EE9EE8; continue 'dispatch;
	}
	// 82EE9ED0: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EE9ED4: 2F0B0800  cmpwi cr6, r11, 0x800
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2048, &mut ctx.xer);
	// 82EE9ED8: 419A0010  beq cr6, 0x82ee9ee8
	if ctx.cr[6].eq {
	pc = 0x82EE9EE8; continue 'dispatch;
	}
	// 82EE9EDC: 816100CC  lwz r11, 0xcc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82EE9EE0: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82EE9EE4: 4800000C  b 0x82ee9ef0
	pc = 0x82EE9EF0; continue 'dispatch;
            }
            0x82EE9EE8 => {
    //   block [0x82EE9EE8..0x82EE9EF0)
	// 82EE9EE8: 816100CC  lwz r11, 0xcc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82EE9EEC: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE9EF0; continue 'dispatch;
            }
            0x82EE9EF0 => {
    //   block [0x82EE9EF0..0x82EE9F10)
	// 82EE9EF0: 81610090  lwz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82EE9EF4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EE9EF8: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9EFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EE9F00: 409A0010  bne cr6, 0x82ee9f10
	if !ctx.cr[6].eq {
	pc = 0x82EE9F10; continue 'dispatch;
	}
	// 82EE9F04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EE9F08: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 82EE9F0C: 4800001C  b 0x82ee9f28
	pc = 0x82EE9F28; continue 'dispatch;
            }
            0x82EE9F10 => {
    //   block [0x82EE9F10..0x82EE9F28)
	// 82EE9F10: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9F14: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE9F18: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9F1C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE9F20: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EE9F24: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE9F28; continue 'dispatch;
            }
            0x82EE9F28 => {
    //   block [0x82EE9F28..0x82EE9FB4)
	// 82EE9F28: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EE9F2C: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82EE9F30: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9F34: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE9F38: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9F3C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE9F40: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EE9F44: 4BD9602D  bl 0x82c7ff70
	ctx.lr = 0x82EE9F48;
	sub_82C7FF70(ctx, base);
	// 82EE9F48: B061009C  sth r3, 0x9c(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[3].u16 ) };
	// 82EE9F4C: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EE9F50: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 82EE9F54: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9F58: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE9F5C: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9F60: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE9F64: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EE9F68: 4BA201D9  bl 0x8290a140
	ctx.lr = 0x82EE9F6C;
	sub_8290A140(ctx, base);
	// 82EE9F6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EE9F70: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82EE9F74: 4BD96435  bl 0x82c803a8
	ctx.lr = 0x82EE9F78;
	sub_82C803A8(ctx, base);
	// 82EE9F78: E8A30000  ld r5, 0(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82EE9F7C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EE9F80: 796607C6  sldi r6, r11, 0x20
	ctx.r[6].u64 = ctx.r[11].u64.wrapping_shl(32);
	ctx.r[6].u32 = ctx.r[6].u64 as u32;
	// 82EE9F84: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82EE9F88: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EE9F8C: 80E100A0  lwz r7, 0xa0(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 82EE9F90: A101009C  lhz r8, 0x9c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EE9F94: 81210098  lwz r9, 0x98(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 82EE9F98: 480004A9  bl 0x82eea440
	ctx.lr = 0x82EE9F9C;
	sub_82EEA440(ctx, base);
	// 82EE9F9C: 4BD95FDD  bl 0x82c7ff78
	ctx.lr = 0x82EE9FA0;
	sub_82C7FF78(ctx, base);
	// 82EE9FA0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EE9FA4: 41820010  beq 0x82ee9fb4
	if ctx.cr[0].eq {
	pc = 0x82EE9FB4; continue 'dispatch;
	}
	// 82EE9FA8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EE9FAC: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82EE9FB0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82EE9FB4; continue 'dispatch;
            }
            0x82EE9FB4 => {
    //   block [0x82EE9FB4..0x82EE9FF8)
	// 82EE9FB4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EE9FB8: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EE9FBC: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9FC0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EE9FC4: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9FC8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EE9FCC: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EE9FD0: 4BD91791  bl 0x82c7b760
	ctx.lr = 0x82EE9FD4;
	sub_82C7B760(ctx, base);
	// 82EE9FD4: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EE9FD8: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82EE9FDC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EE9FE0: 4BD97011  bl 0x82c80ff0
	ctx.lr = 0x82EE9FE4;
	sub_82C80FF0(ctx, base);
	// 82EE9FE4: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EE9FE8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EE9FEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EE9FF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EE9FF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EE9FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EE9FF8 size=356
    let mut pc: u32 = 0x82EE9FF8;
    'dispatch: loop {
        match pc {
            0x82EE9FF8 => {
    //   block [0x82EE9FF8..0x82EEA074)
	// 82EE9FF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EE9FFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEA000: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEA004: 906100B4  stw r3, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[3].u32 ) };
	// 82EEA008: 908100BC  stw r4, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[4].u32 ) };
	// 82EEA00C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEA010: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEA014: 808100B4  lwz r4, 0xb4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA018: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEA01C: 4BD96C35  bl 0x82c80c50
	ctx.lr = 0x82EEA020;
	sub_82C80C50(ctx, base);
	// 82EEA020: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEA024: 4BD95F55  bl 0x82c7ff78
	ctx.lr = 0x82EEA028;
	sub_82C7FF78(ctx, base);
	// 82EEA028: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEA02C: 418200EC  beq 0x82eea118
	if ctx.cr[0].eq {
	pc = 0x82EEA118; continue 'dispatch;
	}
	// 82EEA030: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82EEA034: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA038: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA03C: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA040: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA044: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA048: 4B792391  bl 0x8267c3d8
	ctx.lr = 0x82EEA04C;
	sub_8267C3D8(ctx, base);
	// 82EEA04C: 4BD96CA5  bl 0x82c80cf0
	ctx.lr = 0x82EEA050;
	sub_82C80CF0(ctx, base);
	// 82EEA050: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 82EEA054: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82EEA058: 4B7922C9  bl 0x8267c320
	ctx.lr = 0x82EEA05C;
	sub_8267C320(ctx, base);
	// 82EEA05C: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA060: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEA064: 409A0010  bne cr6, 0x82eea074
	if !ctx.cr[6].eq {
	pc = 0x82EEA074; continue 'dispatch;
	}
	// 82EEA068: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEA06C: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82EEA070: 4800001C  b 0x82eea08c
	pc = 0x82EEA08C; continue 'dispatch;
            }
            0x82EEA074 => {
    //   block [0x82EEA074..0x82EEA08C)
	// 82EEA074: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA078: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA07C: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA080: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA084: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA088: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEA08C; continue 'dispatch;
            }
            0x82EEA08C => {
    //   block [0x82EEA08C..0x82EEA118)
	// 82EEA08C: 816100BC  lwz r11, 0xbc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EEA090: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82EEA094: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA098: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA09C: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA0A0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA0A4: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA0A8: 4BD95EC9  bl 0x82c7ff70
	ctx.lr = 0x82EEA0AC;
	sub_82C7FF70(ctx, base);
	// 82EEA0AC: B0610090  sth r3, 0x90(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[3].u16 ) };
	// 82EEA0B0: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EEA0B4: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 82EEA0B8: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA0BC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA0C0: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA0C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA0C8: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA0CC: 4BA20075  bl 0x8290a140
	ctx.lr = 0x82EEA0D0;
	sub_8290A140(ctx, base);
	// 82EEA0D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EEA0D4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EEA0D8: 4BD962D1  bl 0x82c803a8
	ctx.lr = 0x82EEA0DC;
	sub_82C803A8(ctx, base);
	// 82EEA0DC: E8A30000  ld r5, 0(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82EEA0E0: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEA0E4: 796607C6  sldi r6, r11, 0x20
	ctx.r[6].u64 = ctx.r[11].u64.wrapping_shl(32);
	ctx.r[6].u32 = ctx.r[6].u64 as u32;
	// 82EEA0E8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82EEA0EC: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EEA0F0: 80E10094  lwz r7, 0x94(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEA0F4: A1010090  lhz r8, 0x90(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82EEA0F8: 8121008C  lwz r9, 0x8c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEA0FC: 4BD95E85  bl 0x82c7ff80
	ctx.lr = 0x82EEA100;
	sub_82C7FF80(ctx, base);
	// 82EEA100: 4BD95E79  bl 0x82c7ff78
	ctx.lr = 0x82EEA104;
	sub_82C7FF78(ctx, base);
	// 82EEA104: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEA108: 41820010  beq 0x82eea118
	if ctx.cr[0].eq {
	pc = 0x82EEA118; continue 'dispatch;
	}
	// 82EEA10C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEA110: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82EEA114: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEA118; continue 'dispatch;
            }
            0x82EEA118 => {
    //   block [0x82EEA118..0x82EEA15C)
	// 82EEA118: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EEA11C: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEA120: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA124: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA128: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA12C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA130: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA134: 4BD9162D  bl 0x82c7b760
	ctx.lr = 0x82EEA138;
	sub_82C7B760(ctx, base);
	// 82EEA138: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA13C: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82EEA140: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEA144: 4BD96EAD  bl 0x82c80ff0
	ctx.lr = 0x82EEA148;
	sub_82C80FF0(ctx, base);
	// 82EEA148: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEA14C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82EEA150: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEA154: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEA158: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEA160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEA160 size=356
    let mut pc: u32 = 0x82EEA160;
    'dispatch: loop {
        match pc {
            0x82EEA160 => {
    //   block [0x82EEA160..0x82EEA1DC)
	// 82EEA160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEA164: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEA168: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEA16C: 906100C4  stw r3, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[3].u32 ) };
	// 82EEA170: F88100C8  std r4, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[4].u64 ) };
	// 82EEA174: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEA178: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEA17C: 808100C4  lwz r4, 0xc4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA180: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEA184: 4BD96ACD  bl 0x82c80c50
	ctx.lr = 0x82EEA188;
	sub_82C80C50(ctx, base);
	// 82EEA188: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEA18C: 4BD95DED  bl 0x82c7ff78
	ctx.lr = 0x82EEA190;
	sub_82C7FF78(ctx, base);
	// 82EEA190: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEA194: 418200EC  beq 0x82eea280
	if ctx.cr[0].eq {
	pc = 0x82EEA280; continue 'dispatch;
	}
	// 82EEA198: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82EEA19C: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA1A0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA1A4: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA1A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA1AC: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA1B0: 4B792229  bl 0x8267c3d8
	ctx.lr = 0x82EEA1B4;
	sub_8267C3D8(ctx, base);
	// 82EEA1B4: 4BD96B3D  bl 0x82c80cf0
	ctx.lr = 0x82EEA1B8;
	sub_82C80CF0(ctx, base);
	// 82EEA1B8: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 82EEA1BC: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82EEA1C0: 4B792161  bl 0x8267c320
	ctx.lr = 0x82EEA1C4;
	sub_8267C320(ctx, base);
	// 82EEA1C4: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA1C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEA1CC: 409A0010  bne cr6, 0x82eea1dc
	if !ctx.cr[6].eq {
	pc = 0x82EEA1DC; continue 'dispatch;
	}
	// 82EEA1D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEA1D4: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82EEA1D8: 4800001C  b 0x82eea1f4
	pc = 0x82EEA1F4; continue 'dispatch;
            }
            0x82EEA1DC => {
    //   block [0x82EEA1DC..0x82EEA1F4)
	// 82EEA1DC: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA1E0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA1E4: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA1E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA1EC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA1F0: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEA1F4; continue 'dispatch;
            }
            0x82EEA1F4 => {
    //   block [0x82EEA1F4..0x82EEA280)
	// 82EEA1F4: E96100C8  ld r11, 0xc8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) };
	// 82EEA1F8: F9610090  std r11, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u64 ) };
	// 82EEA1FC: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA200: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA204: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA208: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA20C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA210: 4BD95D61  bl 0x82c7ff70
	ctx.lr = 0x82EEA214;
	sub_82C7FF70(ctx, base);
	// 82EEA214: B0610098  sth r3, 0x98(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[3].u16 ) };
	// 82EEA218: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EEA21C: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 82EEA220: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA224: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA228: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA22C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA230: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA234: 4BA1FF0D  bl 0x8290a140
	ctx.lr = 0x82EEA238;
	sub_8290A140(ctx, base);
	// 82EEA238: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EEA23C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EEA240: 4BD96169  bl 0x82c803a8
	ctx.lr = 0x82EEA244;
	sub_82C803A8(ctx, base);
	// 82EEA244: E8A30000  ld r5, 0(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82EEA248: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEA24C: 796607C6  sldi r6, r11, 0x20
	ctx.r[6].u64 = ctx.r[11].u64.wrapping_shl(32);
	ctx.r[6].u32 = ctx.r[6].u64 as u32;
	// 82EEA250: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82EEA254: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EEA258: 80E1009C  lwz r7, 0x9c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EEA25C: A1010098  lhz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 82EEA260: E9210090  ld r9, 0x90(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 82EEA264: 4800024D  bl 0x82eea4b0
	ctx.lr = 0x82EEA268;
	sub_82EEA4B0(ctx, base);
	// 82EEA268: 4BD95D11  bl 0x82c7ff78
	ctx.lr = 0x82EEA26C;
	sub_82C7FF78(ctx, base);
	// 82EEA26C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEA270: 41820010  beq 0x82eea280
	if ctx.cr[0].eq {
	pc = 0x82EEA280; continue 'dispatch;
	}
	// 82EEA274: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEA278: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82EEA27C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEA280; continue 'dispatch;
            }
            0x82EEA280 => {
    //   block [0x82EEA280..0x82EEA2C4)
	// 82EEA280: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EEA284: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEA288: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA28C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA290: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA294: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA298: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA29C: 4BD914C5  bl 0x82c7b760
	ctx.lr = 0x82EEA2A0;
	sub_82C7B760(ctx, base);
	// 82EEA2A0: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA2A4: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82EEA2A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEA2AC: 4BD96D45  bl 0x82c80ff0
	ctx.lr = 0x82EEA2B0;
	sub_82C80FF0(ctx, base);
	// 82EEA2B0: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEA2B4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EEA2B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEA2BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEA2C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEA2C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEA2C8 size=356
    let mut pc: u32 = 0x82EEA2C8;
    'dispatch: loop {
        match pc {
            0x82EEA2C8 => {
    //   block [0x82EEA2C8..0x82EEA344)
	// 82EEA2C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEA2CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEA2D0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEA2D4: 906100C4  stw r3, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[3].u32 ) };
	// 82EEA2D8: F88100C8  std r4, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[4].u64 ) };
	// 82EEA2DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEA2E0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEA2E4: 808100C4  lwz r4, 0xc4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA2E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEA2EC: 4BD96965  bl 0x82c80c50
	ctx.lr = 0x82EEA2F0;
	sub_82C80C50(ctx, base);
	// 82EEA2F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEA2F4: 4BD95C85  bl 0x82c7ff78
	ctx.lr = 0x82EEA2F8;
	sub_82C7FF78(ctx, base);
	// 82EEA2F8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEA2FC: 418200EC  beq 0x82eea3e8
	if ctx.cr[0].eq {
	pc = 0x82EEA3E8; continue 'dispatch;
	}
	// 82EEA300: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82EEA304: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA308: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA30C: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA310: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA314: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA318: 4B7920C1  bl 0x8267c3d8
	ctx.lr = 0x82EEA31C;
	sub_8267C3D8(ctx, base);
	// 82EEA31C: 4BD969D5  bl 0x82c80cf0
	ctx.lr = 0x82EEA320;
	sub_82C80CF0(ctx, base);
	// 82EEA320: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 82EEA324: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82EEA328: 4B791FF9  bl 0x8267c320
	ctx.lr = 0x82EEA32C;
	sub_8267C320(ctx, base);
	// 82EEA32C: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA330: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEA334: 409A0010  bne cr6, 0x82eea344
	if !ctx.cr[6].eq {
	pc = 0x82EEA344; continue 'dispatch;
	}
	// 82EEA338: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEA33C: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82EEA340: 4800001C  b 0x82eea35c
	pc = 0x82EEA35C; continue 'dispatch;
            }
            0x82EEA344 => {
    //   block [0x82EEA344..0x82EEA35C)
	// 82EEA344: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA348: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA34C: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA350: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA354: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA358: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEA35C; continue 'dispatch;
            }
            0x82EEA35C => {
    //   block [0x82EEA35C..0x82EEA3E8)
	// 82EEA35C: E96100C8  ld r11, 0xc8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) };
	// 82EEA360: F9610090  std r11, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u64 ) };
	// 82EEA364: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA368: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA36C: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA370: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA374: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA378: 4BD95BF9  bl 0x82c7ff70
	ctx.lr = 0x82EEA37C;
	sub_82C7FF70(ctx, base);
	// 82EEA37C: B0610098  sth r3, 0x98(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[3].u16 ) };
	// 82EEA380: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EEA384: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 82EEA388: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA38C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA390: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA394: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA398: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA39C: 4BA1FDA5  bl 0x8290a140
	ctx.lr = 0x82EEA3A0;
	sub_8290A140(ctx, base);
	// 82EEA3A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82EEA3A4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EEA3A8: 4BD96001  bl 0x82c803a8
	ctx.lr = 0x82EEA3AC;
	sub_82C803A8(ctx, base);
	// 82EEA3AC: E8A30000  ld r5, 0(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82EEA3B0: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82EEA3B4: 796607C6  sldi r6, r11, 0x20
	ctx.r[6].u64 = ctx.r[11].u64.wrapping_shl(32);
	ctx.r[6].u32 = ctx.r[6].u64 as u32;
	// 82EEA3B8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82EEA3BC: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EEA3C0: 80E1009C  lwz r7, 0x9c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82EEA3C4: A1010098  lhz r8, 0x98(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 82EEA3C8: E9210090  ld r9, 0x90(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 82EEA3CC: 48000155  bl 0x82eea520
	ctx.lr = 0x82EEA3D0;
	sub_82EEA520(ctx, base);
	// 82EEA3D0: 4BD95BA9  bl 0x82c7ff78
	ctx.lr = 0x82EEA3D4;
	sub_82C7FF78(ctx, base);
	// 82EEA3D4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEA3D8: 41820010  beq 0x82eea3e8
	if ctx.cr[0].eq {
	pc = 0x82EEA3E8; continue 'dispatch;
	}
	// 82EEA3DC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEA3E0: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82EEA3E4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEA3E8; continue 'dispatch;
            }
            0x82EEA3E8 => {
    //   block [0x82EEA3E8..0x82EEA42C)
	// 82EEA3E8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EEA3EC: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEA3F0: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA3F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA3F8: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA3FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA400: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA404: 4BD9135D  bl 0x82c7b760
	ctx.lr = 0x82EEA408;
	sub_82C7B760(ctx, base);
	// 82EEA408: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82EEA40C: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82EEA410: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEA414: 4BD96BDD  bl 0x82c80ff0
	ctx.lr = 0x82EEA418;
	sub_82C80FF0(ctx, base);
	// 82EEA418: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEA41C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82EEA420: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEA424: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEA428: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEA430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEA430 size=16
    let mut pc: u32 = 0x82EEA430;
    'dispatch: loop {
        match pc {
            0x82EEA430 => {
    //   block [0x82EEA430..0x82EEA440)
	// 82EEA430: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEA434: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEA438: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEA43C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEA440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEA440 size=112
    let mut pc: u32 = 0x82EEA440;
    'dispatch: loop {
        match pc {
            0x82EEA440 => {
    //   block [0x82EEA440..0x82EEA4B0)
	// 82EEA440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEA444: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEA448: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEA44C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEA450: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEA454: F8A10080  std r5, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[5].u64 ) };
	// 82EEA458: F8C10088  std r6, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[6].u64 ) };
	// 82EEA45C: 90E10094  stw r7, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[7].u32 ) };
	// 82EEA460: B101009E  sth r8, 0x9e(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(158 as u32), ctx.r[8].u16 ) };
	// 82EEA464: 912100A4  stw r9, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[9].u32 ) };
	// 82EEA468: 812100A4  lwz r9, 0xa4(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEA46C: A101009E  lhz r8, 0x9e(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(158 as u32) ) } as u64;
	// 82EEA470: 80E10094  lwz r7, 0x94(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEA474: E8A10080  ld r5, 0x80(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 82EEA478: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EEA47C: 796607C6  sldi r6, r11, 0x20
	ctx.r[6].u64 = ctx.r[11].u64.wrapping_shl(32);
	ctx.r[6].u32 = ctx.r[6].u64 as u32;
	// 82EEA480: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEA484: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEA488: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA48C: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEA490: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EEA494: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEA498: 4E800421  bctrl
	ctx.lr = 0x82EEA49C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEA49C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEA4A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEA4A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEA4A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEA4AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEA4B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEA4B0 size=112
    let mut pc: u32 = 0x82EEA4B0;
    'dispatch: loop {
        match pc {
            0x82EEA4B0 => {
    //   block [0x82EEA4B0..0x82EEA520)
	// 82EEA4B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEA4B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEA4B8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEA4BC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEA4C0: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEA4C4: F8A10080  std r5, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[5].u64 ) };
	// 82EEA4C8: F8C10088  std r6, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[6].u64 ) };
	// 82EEA4CC: 90E10094  stw r7, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[7].u32 ) };
	// 82EEA4D0: B101009E  sth r8, 0x9e(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(158 as u32), ctx.r[8].u16 ) };
	// 82EEA4D4: F92100A0  std r9, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[9].u64 ) };
	// 82EEA4D8: E92100A0  ld r9, 0xa0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 82EEA4DC: A101009E  lhz r8, 0x9e(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(158 as u32) ) } as u64;
	// 82EEA4E0: 80E10094  lwz r7, 0x94(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEA4E4: E8A10080  ld r5, 0x80(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 82EEA4E8: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EEA4EC: 796607C6  sldi r6, r11, 0x20
	ctx.r[6].u64 = ctx.r[11].u64.wrapping_shl(32);
	ctx.r[6].u32 = ctx.r[6].u64 as u32;
	// 82EEA4F0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEA4F4: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEA4F8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA4FC: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEA500: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEA504: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEA508: 4E800421  bctrl
	ctx.lr = 0x82EEA50C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEA50C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEA510: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEA514: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEA518: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEA51C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEA520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEA520 size=112
    let mut pc: u32 = 0x82EEA520;
    'dispatch: loop {
        match pc {
            0x82EEA520 => {
    //   block [0x82EEA520..0x82EEA590)
	// 82EEA520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEA524: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEA528: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEA52C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEA530: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEA534: F8A10080  std r5, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[5].u64 ) };
	// 82EEA538: F8C10088  std r6, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[6].u64 ) };
	// 82EEA53C: 90E10094  stw r7, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[7].u32 ) };
	// 82EEA540: B101009E  sth r8, 0x9e(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(158 as u32), ctx.r[8].u16 ) };
	// 82EEA544: F92100A0  std r9, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[9].u64 ) };
	// 82EEA548: E92100A0  ld r9, 0xa0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 82EEA54C: A101009E  lhz r8, 0x9e(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(158 as u32) ) } as u64;
	// 82EEA550: 80E10094  lwz r7, 0x94(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82EEA554: E8A10080  ld r5, 0x80(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 82EEA558: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82EEA55C: 796607C6  sldi r6, r11, 0x20
	ctx.r[6].u64 = ctx.r[11].u64.wrapping_shl(32);
	ctx.r[6].u32 = ctx.r[6].u64 as u32;
	// 82EEA560: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEA564: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEA568: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA56C: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEA570: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82EEA574: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEA578: 4E800421  bctrl
	ctx.lr = 0x82EEA57C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEA57C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEA580: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEA584: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEA588: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEA58C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEA590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEA590 size=136
    let mut pc: u32 = 0x82EEA590;
    'dispatch: loop {
        match pc {
            0x82EEA590 => {
    //   block [0x82EEA590..0x82EEA5E0)
	// 82EEA590: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEA594: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEA598: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEA59C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEA5A0: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEA5A4: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEA5A8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EEA5AC: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEA5B0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEA5B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA5B8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEA5BC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EEA5C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEA5C4: 4E800421  bctrl
	ctx.lr = 0x82EEA5C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEA5C8: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EEA5CC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEA5D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEA5D4: 409A000C  bne cr6, 0x82eea5e0
	if !ctx.cr[6].eq {
	pc = 0x82EEA5E0; continue 'dispatch;
	}
	// 82EEA5D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EEA5DC: 4800002C  b 0x82eea608
	pc = 0x82EEA608; continue 'dispatch;
            }
            0x82EEA5E0 => {
    //   block [0x82EEA5E0..0x82EEA604)
	// 82EEA5E0: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEA5E4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEA5E8: 480007E9  bl 0x82eeadd0
	ctx.lr = 0x82EEA5EC;
	sub_82EEADD0(ctx, base);
	// 82EEA5EC: 98610050  stb r3, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u8 ) };
	// 82EEA5F0: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEA5F4: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEA5F8: 4082000C  bne 0x82eea604
	if !ctx.cr[0].eq {
	pc = 0x82EEA604; continue 'dispatch;
	}
	// 82EEA5FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EEA600: 48000008  b 0x82eea608
	pc = 0x82EEA608; continue 'dispatch;
            }
            0x82EEA604 => {
    //   block [0x82EEA604..0x82EEA608)
	// 82EEA604: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EEA608; continue 'dispatch;
            }
            0x82EEA608 => {
    //   block [0x82EEA608..0x82EEA618)
	// 82EEA608: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEA60C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEA610: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEA614: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEA618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEA618 size=136
    let mut pc: u32 = 0x82EEA618;
    'dispatch: loop {
        match pc {
            0x82EEA618 => {
    //   block [0x82EEA618..0x82EEA668)
	// 82EEA618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEA61C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEA620: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEA624: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEA628: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEA62C: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEA630: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EEA634: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEA638: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEA63C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA640: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEA644: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EEA648: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEA64C: 4E800421  bctrl
	ctx.lr = 0x82EEA650;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEA650: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EEA654: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEA658: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEA65C: 409A000C  bne cr6, 0x82eea668
	if !ctx.cr[6].eq {
	pc = 0x82EEA668; continue 'dispatch;
	}
	// 82EEA660: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EEA664: 4800002C  b 0x82eea690
	pc = 0x82EEA690; continue 'dispatch;
            }
            0x82EEA668 => {
    //   block [0x82EEA668..0x82EEA68C)
	// 82EEA668: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEA66C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEA670: 480008A1  bl 0x82eeaf10
	ctx.lr = 0x82EEA674;
	sub_82EEAF10(ctx, base);
	// 82EEA674: 98610050  stb r3, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u8 ) };
	// 82EEA678: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEA67C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEA680: 4082000C  bne 0x82eea68c
	if !ctx.cr[0].eq {
	pc = 0x82EEA68C; continue 'dispatch;
	}
	// 82EEA684: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EEA688: 48000008  b 0x82eea690
	pc = 0x82EEA690; continue 'dispatch;
            }
            0x82EEA68C => {
    //   block [0x82EEA68C..0x82EEA690)
	// 82EEA68C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EEA690; continue 'dispatch;
            }
            0x82EEA690 => {
    //   block [0x82EEA690..0x82EEA6A0)
	// 82EEA690: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEA694: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEA698: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEA69C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEA6A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEA6A0 size=136
    let mut pc: u32 = 0x82EEA6A0;
    'dispatch: loop {
        match pc {
            0x82EEA6A0 => {
    //   block [0x82EEA6A0..0x82EEA6F0)
	// 82EEA6A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEA6A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEA6A8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEA6AC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEA6B0: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEA6B4: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEA6B8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EEA6BC: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEA6C0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEA6C4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA6C8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEA6CC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EEA6D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEA6D4: 4E800421  bctrl
	ctx.lr = 0x82EEA6D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEA6D8: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EEA6DC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEA6E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEA6E4: 409A000C  bne cr6, 0x82eea6f0
	if !ctx.cr[6].eq {
	pc = 0x82EEA6F0; continue 'dispatch;
	}
	// 82EEA6E8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EEA6EC: 4800002C  b 0x82eea718
	pc = 0x82EEA718; continue 'dispatch;
            }
            0x82EEA6F0 => {
    //   block [0x82EEA6F0..0x82EEA714)
	// 82EEA6F0: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEA6F4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEA6F8: 480008B9  bl 0x82eeafb0
	ctx.lr = 0x82EEA6FC;
	sub_82EEAFB0(ctx, base);
	// 82EEA6FC: 98610050  stb r3, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u8 ) };
	// 82EEA700: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEA704: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEA708: 4082000C  bne 0x82eea714
	if !ctx.cr[0].eq {
	pc = 0x82EEA714; continue 'dispatch;
	}
	// 82EEA70C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EEA710: 48000008  b 0x82eea718
	pc = 0x82EEA718; continue 'dispatch;
            }
            0x82EEA714 => {
    //   block [0x82EEA714..0x82EEA718)
	// 82EEA714: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EEA718; continue 'dispatch;
            }
            0x82EEA718 => {
    //   block [0x82EEA718..0x82EEA728)
	// 82EEA718: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEA71C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEA720: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEA724: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEA728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEA728 size=136
    let mut pc: u32 = 0x82EEA728;
    'dispatch: loop {
        match pc {
            0x82EEA728 => {
    //   block [0x82EEA728..0x82EEA778)
	// 82EEA728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEA72C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEA730: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEA734: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEA738: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEA73C: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEA740: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EEA744: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEA748: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEA74C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA750: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEA754: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82EEA758: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82EEA75C: 4E800421  bctrl
	ctx.lr = 0x82EEA760;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82EEA760: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EEA764: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEA768: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEA76C: 409A000C  bne cr6, 0x82eea778
	if !ctx.cr[6].eq {
	pc = 0x82EEA778; continue 'dispatch;
	}
	// 82EEA770: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EEA774: 4800002C  b 0x82eea7a0
	pc = 0x82EEA7A0; continue 'dispatch;
            }
            0x82EEA778 => {
    //   block [0x82EEA778..0x82EEA79C)
	// 82EEA778: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEA77C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEA780: 480006F1  bl 0x82eeae70
	ctx.lr = 0x82EEA784;
	sub_82EEAE70(ctx, base);
	// 82EEA784: 98610050  stb r3, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u8 ) };
	// 82EEA788: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEA78C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEA790: 4082000C  bne 0x82eea79c
	if !ctx.cr[0].eq {
	pc = 0x82EEA79C; continue 'dispatch;
	}
	// 82EEA794: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82EEA798: 48000008  b 0x82eea7a0
	pc = 0x82EEA7A0; continue 'dispatch;
            }
            0x82EEA79C => {
    //   block [0x82EEA79C..0x82EEA7A0)
	// 82EEA79C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82EEA7A0; continue 'dispatch;
            }
            0x82EEA7A0 => {
    //   block [0x82EEA7A0..0x82EEA7B0)
	// 82EEA7A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEA7A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEA7A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEA7AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEA7B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEA7B0 size=836
    let mut pc: u32 = 0x82EEA7B0;
    'dispatch: loop {
        match pc {
            0x82EEA7B0 => {
    //   block [0x82EEA7B0..0x82EEA848)
	// 82EEA7B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEA7B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEA7B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEA7BC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEA7C0: 906100B4  stw r3, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[3].u32 ) };
	// 82EEA7C4: 908100BC  stw r4, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[4].u32 ) };
	// 82EEA7C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEA7CC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEA7D0: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EEA7D4: 4811E52D  bl 0x83008d00
	ctx.lr = 0x82EEA7D8;
	sub_83008D00(ctx, base);
	// 82EEA7D8: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EEA7DC: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA7E0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA7E4: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA7E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA7EC: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA7F0: 4BA23521  bl 0x8290dd10
	ctx.lr = 0x82EEA7F4;
	sub_8290DD10(ctx, base);
	// 82EEA7F4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEA7F8: 40810050  ble 0x82eea848
	if !ctx.cr[0].gt {
	pc = 0x82EEA848; continue 'dispatch;
	}
	// 82EEA7FC: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA800: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA804: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA808: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA80C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA810: 4BA23501  bl 0x8290dd10
	ctx.lr = 0x82EEA814;
	sub_8290DD10(ctx, base);
	// 82EEA814: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEA818: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82EEA81C: 4099002C  ble cr6, 0x82eea848
	if !ctx.cr[6].gt {
	pc = 0x82EEA848; continue 'dispatch;
	}
	// 82EEA820: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA824: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA828: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA82C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA830: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA834: 4BA234DD  bl 0x8290dd10
	ctx.lr = 0x82EEA838;
	sub_8290DD10(ctx, base);
	// 82EEA838: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEA83C: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 82EEA840: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82EEA844: 4800000C  b 0x82eea850
	pc = 0x82EEA850; continue 'dispatch;
            }
            0x82EEA848 => {
    //   block [0x82EEA848..0x82EEA850)
	// 82EEA848: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEA84C: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEA850; continue 'dispatch;
            }
            0x82EEA850 => {
    //   block [0x82EEA850..0x82EEA884)
	// 82EEA850: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82EEA854: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EEA858: 808100B4  lwz r4, 0xb4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA85C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EEA860: 4BD963F1  bl 0x82c80c50
	ctx.lr = 0x82EEA864;
	sub_82C80C50(ctx, base);
	// 82EEA864: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EEA868: 4BD95711  bl 0x82c7ff78
	ctx.lr = 0x82EEA86C;
	sub_82C7FF78(ctx, base);
	// 82EEA86C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEA870: 40820014  bne 0x82eea884
	if !ctx.cr[0].eq {
	pc = 0x82EEA884; continue 'dispatch;
	}
	// 82EEA874: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEA878: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82EEA87C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEA880: 4800022C  b 0x82eeaaac
	pc = 0x82EEAAAC; continue 'dispatch;
            }
            0x82EEA884 => {
    //   block [0x82EEA884..0x82EEA8D8)
	// 82EEA884: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82EEA888: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA88C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA890: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA894: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA898: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA89C: 4B791B3D  bl 0x8267c3d8
	ctx.lr = 0x82EEA8A0;
	sub_8267C3D8(ctx, base);
	// 82EEA8A0: 4BD90131  bl 0x82c7a9d0
	ctx.lr = 0x82EEA8A4;
	sub_82C7A9D0(ctx, base);
	// 82EEA8A4: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 82EEA8A8: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82EEA8AC: 4B791A75  bl 0x8267c320
	ctx.lr = 0x82EEA8B0;
	sub_8267C320(ctx, base);
	// 82EEA8B0: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA8B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA8B8: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA8BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA8C0: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA8C4: 482D179D  bl 0x831bc060
	ctx.lr = 0x82EEA8C8;
	sub_831BC060(ctx, base);
	// 82EEA8C8: 546B05F2  rlwinm r11, r3, 0, 0x17, 0x19
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0xFFFFFFFFu64;
	// 82EEA8CC: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 82EEA8D0: 419A0090  beq cr6, 0x82eea960
	if ctx.cr[6].eq {
	pc = 0x82EEA960; continue 'dispatch;
	}
	// 82EEA8D4: 48000010  b 0x82eea8e4
	pc = 0x82EEA8E4; continue 'dispatch;
            }
            0x82EEA8D8 => {
    //   block [0x82EEA8D8..0x82EEA8E4)
	// 82EEA8D8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEA8DC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EEA8E0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEA8E4; continue 'dispatch;
            }
            0x82EEA8E4 => {
    //   block [0x82EEA8E4..0x82EEA95C)
	// 82EEA8E4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEA8E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEA8EC: 40990074  ble cr6, 0x82eea960
	if !ctx.cr[6].gt {
	pc = 0x82EEA960; continue 'dispatch;
	}
	// 82EEA8F0: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA8F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA8F8: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA8FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA900: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA904: 4BD9566D  bl 0x82c7ff70
	ctx.lr = 0x82EEA908;
	sub_82C7FF70(ctx, base);
	// 82EEA908: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EEA90C: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA910: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA914: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA918: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA91C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA920: 4BA1F821  bl 0x8290a140
	ctx.lr = 0x82EEA924;
	sub_8290A140(ctx, base);
	// 82EEA924: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEA928: 4BD95A19  bl 0x82c80340
	ctx.lr = 0x82EEA92C;
	sub_82C80340(ctx, base);
	// 82EEA92C: B0610070  sth r3, 0x70(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[3].u16 ) };
	// 82EEA930: 4BEC7291  bl 0x82db1bc0
	ctx.lr = 0x82EEA934;
	sub_82DB1BC0(ctx, base);
	// 82EEA934: B0610072  sth r3, 0x72(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[3].u16 ) };
	// 82EEA938: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EEA93C: 38610072  addi r3, r1, 0x72
	ctx.r[3].s64 = ctx.r[1].s64 + 114;
	// 82EEA940: 4BD8E681  bl 0x82c78fc0
	ctx.lr = 0x82EEA944;
	sub_82C78FC0(ctx, base);
	// 82EEA944: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEA948: 41820014  beq 0x82eea95c
	if ctx.cr[0].eq {
	pc = 0x82EEA95C; continue 'dispatch;
	}
	// 82EEA94C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEA950: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82EEA954: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEA958: 48000008  b 0x82eea960
	pc = 0x82EEA960; continue 'dispatch;
            }
            0x82EEA95C => {
    //   block [0x82EEA95C..0x82EEA960)
	// 82EEA95C: 4BFFFF7C  b 0x82eea8d8
	pc = 0x82EEA8D8; continue 'dispatch;
            }
            0x82EEA960 => {
    //   block [0x82EEA960..0x82EEA964)
	// 82EEA960: 4800001C  b 0x82eea97c
	pc = 0x82EEA97C; continue 'dispatch;
            }
            0x82EEA964 => {
    //   block [0x82EEA964..0x82EEA97C)
	// 82EEA964: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEA968: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EEA96C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EEA970: 816100BC  lwz r11, 0xbc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EEA974: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82EEA978: 916100BC  stw r11, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEA97C; continue 'dispatch;
            }
            0x82EEA97C => {
    //   block [0x82EEA97C..0x82EEA9F4)
	// 82EEA97C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEA980: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEA984: 409A0074  bne cr6, 0x82eea9f8
	if !ctx.cr[6].eq {
	pc = 0x82EEA9F8; continue 'dispatch;
	}
	// 82EEA988: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEA98C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEA990: 40990068  ble cr6, 0x82eea9f8
	if !ctx.cr[6].gt {
	pc = 0x82EEA9F8; continue 'dispatch;
	}
	// 82EEA994: 816100BC  lwz r11, 0xbc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82EEA998: 888B0000  lbz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA99C: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82EEA9A0: 4BD8E639  bl 0x82c78fd8
	ctx.lr = 0x82EEA9A4;
	sub_82C78FD8(ctx, base);
	// 82EEA9A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EEA9A8: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA9AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEA9B0: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEA9B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEA9B8: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEA9BC: 4BA1F785  bl 0x8290a140
	ctx.lr = 0x82EEA9C0;
	sub_8290A140(ctx, base);
	// 82EEA9C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEA9C4: 4BD9597D  bl 0x82c80340
	ctx.lr = 0x82EEA9C8;
	sub_82C80340(ctx, base);
	// 82EEA9C8: B0610074  sth r3, 0x74(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u16 ) };
	// 82EEA9CC: 4BEC71F5  bl 0x82db1bc0
	ctx.lr = 0x82EEA9D0;
	sub_82DB1BC0(ctx, base);
	// 82EEA9D0: B0610076  sth r3, 0x76(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[3].u16 ) };
	// 82EEA9D4: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82EEA9D8: 38610076  addi r3, r1, 0x76
	ctx.r[3].s64 = ctx.r[1].s64 + 118;
	// 82EEA9DC: 4BD8E5E5  bl 0x82c78fc0
	ctx.lr = 0x82EEA9E0;
	sub_82C78FC0(ctx, base);
	// 82EEA9E0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEA9E4: 41820010  beq 0x82eea9f4
	if ctx.cr[0].eq {
	pc = 0x82EEA9F4; continue 'dispatch;
	}
	// 82EEA9E8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEA9EC: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82EEA9F0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEA9F4; continue 'dispatch;
            }
            0x82EEA9F4 => {
    //   block [0x82EEA9F4..0x82EEA9F8)
	// 82EEA9F4: 4BFFFF70  b 0x82eea964
	pc = 0x82EEA964; continue 'dispatch;
            }
            0x82EEA9F8 => {
    //   block [0x82EEA9F8..0x82EEAA08)
	// 82EEA9F8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEA9FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEAA00: 409A0090  bne cr6, 0x82eeaa90
	if !ctx.cr[6].eq {
	pc = 0x82EEAA90; continue 'dispatch;
	}
	// 82EEAA04: 48000010  b 0x82eeaa14
	pc = 0x82EEAA14; continue 'dispatch;
            }
            0x82EEAA08 => {
    //   block [0x82EEAA08..0x82EEAA14)
	// 82EEAA08: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEAA0C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EEAA10: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEAA14; continue 'dispatch;
            }
            0x82EEAA14 => {
    //   block [0x82EEAA14..0x82EEAA8C)
	// 82EEAA14: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEAA18: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEAA1C: 40990074  ble cr6, 0x82eeaa90
	if !ctx.cr[6].gt {
	pc = 0x82EEAA90; continue 'dispatch;
	}
	// 82EEAA20: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEAA24: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAA28: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEAA2C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEAA30: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEAA34: 4BD9553D  bl 0x82c7ff70
	ctx.lr = 0x82EEAA38;
	sub_82C7FF70(ctx, base);
	// 82EEAA38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EEAA3C: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEAA40: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAA44: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEAA48: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEAA4C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEAA50: 4BA1F6F1  bl 0x8290a140
	ctx.lr = 0x82EEAA54;
	sub_8290A140(ctx, base);
	// 82EEAA54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEAA58: 4BD958E9  bl 0x82c80340
	ctx.lr = 0x82EEAA5C;
	sub_82C80340(ctx, base);
	// 82EEAA5C: B0610078  sth r3, 0x78(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[3].u16 ) };
	// 82EEAA60: 4BEC7161  bl 0x82db1bc0
	ctx.lr = 0x82EEAA64;
	sub_82DB1BC0(ctx, base);
	// 82EEAA64: B061007A  sth r3, 0x7a(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(122 as u32), ctx.r[3].u16 ) };
	// 82EEAA68: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82EEAA6C: 3861007A  addi r3, r1, 0x7a
	ctx.r[3].s64 = ctx.r[1].s64 + 122;
	// 82EEAA70: 4BD8E551  bl 0x82c78fc0
	ctx.lr = 0x82EEAA74;
	sub_82C78FC0(ctx, base);
	// 82EEAA74: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEAA78: 41820014  beq 0x82eeaa8c
	if ctx.cr[0].eq {
	pc = 0x82EEAA8C; continue 'dispatch;
	}
	// 82EEAA7C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEAA80: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82EEAA84: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEAA88: 48000008  b 0x82eeaa90
	pc = 0x82EEAA90; continue 'dispatch;
            }
            0x82EEAA8C => {
    //   block [0x82EEAA8C..0x82EEAA90)
	// 82EEAA8C: 4BFFFF7C  b 0x82eeaa08
	pc = 0x82EEAA08; continue 'dispatch;
            }
            0x82EEAA90 => {
    //   block [0x82EEAA90..0x82EEAAAC)
	// 82EEAA90: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EEAA94: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEAA98: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAA9C: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEAAA0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEAAA4: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEAAA8: 4B7916F9  bl 0x8267c1a0
	ctx.lr = 0x82EEAAAC;
	sub_8267C1A0(ctx, base);
	pc = 0x82EEAAAC; continue 'dispatch;
            }
            0x82EEAAAC => {
    //   block [0x82EEAAAC..0x82EEAAF4)
	// 82EEAAAC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EEAAB0: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEAAB4: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEAAB8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAABC: 814100B4  lwz r10, 0xb4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEAAC0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEAAC4: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEAAC8: 4BD90C99  bl 0x82c7b760
	ctx.lr = 0x82EEAACC;
	sub_82C7B760(ctx, base);
	// 82EEAACC: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEAAD0: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82EEAAD4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82EEAAD8: 4BD96519  bl 0x82c80ff0
	ctx.lr = 0x82EEAADC;
	sub_82C80FF0(ctx, base);
	// 82EEAADC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEAAE0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82EEAAE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEAAE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEAAEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEAAF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEAAF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEAAF8 size=724
    let mut pc: u32 = 0x82EEAAF8;
    'dispatch: loop {
        match pc {
            0x82EEAAF8 => {
    //   block [0x82EEAAF8..0x82EEAB8C)
	// 82EEAAF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEAAFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEAB00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEAB04: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEAB08: 906100A4  stw r3, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[3].u32 ) };
	// 82EEAB0C: 988100AF  stb r4, 0xaf(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(175 as u32), ctx.r[4].u8 ) };
	// 82EEAB10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEAB14: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEAB18: 808100A4  lwz r4, 0xa4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAB1C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEAB20: 4BD96131  bl 0x82c80c50
	ctx.lr = 0x82EEAB24;
	sub_82C80C50(ctx, base);
	// 82EEAB24: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEAB28: 4BD95451  bl 0x82c7ff78
	ctx.lr = 0x82EEAB2C;
	sub_82C7FF78(ctx, base);
	// 82EEAB2C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEAB30: 41820238  beq 0x82eead68
	if ctx.cr[0].eq {
	pc = 0x82EEAD68; continue 'dispatch;
	}
	// 82EEAB34: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EEAB38: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAB3C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAB40: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAB44: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEAB48: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEAB4C: 4B79188D  bl 0x8267c3d8
	ctx.lr = 0x82EEAB50;
	sub_8267C3D8(ctx, base);
	// 82EEAB50: 4BD8FE81  bl 0x82c7a9d0
	ctx.lr = 0x82EEAB54;
	sub_82C7A9D0(ctx, base);
	// 82EEAB54: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 82EEAB58: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EEAB5C: 4B7917C5  bl 0x8267c320
	ctx.lr = 0x82EEAB60;
	sub_8267C320(ctx, base);
	// 82EEAB60: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAB64: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAB68: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAB6C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEAB70: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEAB74: 4BA2319D  bl 0x8290dd10
	ctx.lr = 0x82EEAB78;
	sub_8290DD10(ctx, base);
	// 82EEAB78: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82EEAB7C: 41990010  bgt cr6, 0x82eeab8c
	if ctx.cr[6].gt {
	pc = 0x82EEAB8C; continue 'dispatch;
	}
	// 82EEAB80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEAB84: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82EEAB88: 48000024  b 0x82eeabac
	pc = 0x82EEABAC; continue 'dispatch;
            }
            0x82EEAB8C => {
    //   block [0x82EEAB8C..0x82EEABAC)
	// 82EEAB8C: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAB90: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAB94: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAB98: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEAB9C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEABA0: 4BA23171  bl 0x8290dd10
	ctx.lr = 0x82EEABA4;
	sub_8290DD10(ctx, base);
	// 82EEABA4: 3963FFFF  addi r11, r3, -1
	ctx.r[11].s64 = ctx.r[3].s64 + -1;
	// 82EEABA8: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEABAC; continue 'dispatch;
            }
            0x82EEABAC => {
    //   block [0x82EEABAC..0x82EEABDC)
	// 82EEABAC: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEABB0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EEABB4: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEABB8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEABBC: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEABC0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEABC4: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEABC8: 482D1499  bl 0x831bc060
	ctx.lr = 0x82EEABCC;
	sub_831BC060(ctx, base);
	// 82EEABCC: 546B05F2  rlwinm r11, r3, 0, 0x17, 0x19
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0xFFFFFFFFu64;
	// 82EEABD0: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 82EEABD4: 419A0098  beq cr6, 0x82eeac6c
	if ctx.cr[6].eq {
	pc = 0x82EEAC6C; continue 'dispatch;
	}
	// 82EEABD8: 48000010  b 0x82eeabe8
	pc = 0x82EEABE8; continue 'dispatch;
            }
            0x82EEABDC => {
    //   block [0x82EEABDC..0x82EEABE8)
	// 82EEABDC: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EEABE0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EEABE4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEABE8; continue 'dispatch;
            }
            0x82EEABE8 => {
    //   block [0x82EEABE8..0x82EEAC68)
	// 82EEABE8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEABEC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEABF0: 409A007C  bne cr6, 0x82eeac6c
	if !ctx.cr[6].eq {
	pc = 0x82EEAC6C; continue 'dispatch;
	}
	// 82EEABF4: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EEABF8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEABFC: 40990070  ble cr6, 0x82eeac6c
	if !ctx.cr[6].gt {
	pc = 0x82EEAC6C; continue 'dispatch;
	}
	// 82EEAC00: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAC04: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAC08: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAC0C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEAC10: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEAC14: 4BD9535D  bl 0x82c7ff70
	ctx.lr = 0x82EEAC18;
	sub_82C7FF70(ctx, base);
	// 82EEAC18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EEAC1C: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAC20: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAC24: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAC28: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEAC2C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEAC30: 4BA1F511  bl 0x8290a140
	ctx.lr = 0x82EEAC34;
	sub_8290A140(ctx, base);
	// 82EEAC34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEAC38: 4BD95709  bl 0x82c80340
	ctx.lr = 0x82EEAC3C;
	sub_82C80340(ctx, base);
	// 82EEAC3C: B061006C  sth r3, 0x6c(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[3].u16 ) };
	// 82EEAC40: 4BEC6F81  bl 0x82db1bc0
	ctx.lr = 0x82EEAC44;
	sub_82DB1BC0(ctx, base);
	// 82EEAC44: B061006E  sth r3, 0x6e(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(110 as u32), ctx.r[3].u16 ) };
	// 82EEAC48: 3881006C  addi r4, r1, 0x6c
	ctx.r[4].s64 = ctx.r[1].s64 + 108;
	// 82EEAC4C: 3861006E  addi r3, r1, 0x6e
	ctx.r[3].s64 = ctx.r[1].s64 + 110;
	// 82EEAC50: 4BD8E371  bl 0x82c78fc0
	ctx.lr = 0x82EEAC54;
	sub_82C78FC0(ctx, base);
	// 82EEAC54: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEAC58: 41820010  beq 0x82eeac68
	if ctx.cr[0].eq {
	pc = 0x82EEAC68; continue 'dispatch;
	}
	// 82EEAC5C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEAC60: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82EEAC64: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEAC68; continue 'dispatch;
            }
            0x82EEAC68 => {
    //   block [0x82EEAC68..0x82EEAC6C)
	// 82EEAC68: 4BFFFF74  b 0x82eeabdc
	pc = 0x82EEABDC; continue 'dispatch;
            }
            0x82EEAC6C => {
    //   block [0x82EEAC6C..0x82EEACD4)
	// 82EEAC6C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEAC70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEAC74: 409A0060  bne cr6, 0x82eeacd4
	if !ctx.cr[6].eq {
	pc = 0x82EEACD4; continue 'dispatch;
	}
	// 82EEAC78: 888100AF  lbz r4, 0xaf(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(175 as u32) ) } as u64;
	// 82EEAC7C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82EEAC80: 4BD8E359  bl 0x82c78fd8
	ctx.lr = 0x82EEAC84;
	sub_82C78FD8(ctx, base);
	// 82EEAC84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EEAC88: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAC8C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAC90: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAC94: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEAC98: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEAC9C: 4BA1F4A5  bl 0x8290a140
	ctx.lr = 0x82EEACA0;
	sub_8290A140(ctx, base);
	// 82EEACA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEACA4: 4BD9569D  bl 0x82c80340
	ctx.lr = 0x82EEACA8;
	sub_82C80340(ctx, base);
	// 82EEACA8: B0610070  sth r3, 0x70(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[3].u16 ) };
	// 82EEACAC: 4BEC6F15  bl 0x82db1bc0
	ctx.lr = 0x82EEACB0;
	sub_82DB1BC0(ctx, base);
	// 82EEACB0: B0610072  sth r3, 0x72(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[3].u16 ) };
	// 82EEACB4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82EEACB8: 38610072  addi r3, r1, 0x72
	ctx.r[3].s64 = ctx.r[1].s64 + 114;
	// 82EEACBC: 4BD8E305  bl 0x82c78fc0
	ctx.lr = 0x82EEACC0;
	sub_82C78FC0(ctx, base);
	// 82EEACC0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEACC4: 41820010  beq 0x82eeacd4
	if ctx.cr[0].eq {
	pc = 0x82EEACD4; continue 'dispatch;
	}
	// 82EEACC8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEACCC: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82EEACD0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEACD4; continue 'dispatch;
            }
            0x82EEACD4 => {
    //   block [0x82EEACD4..0x82EEACD8)
	// 82EEACD4: 48000010  b 0x82eeace4
	pc = 0x82EEACE4; continue 'dispatch;
            }
            0x82EEACD8 => {
    //   block [0x82EEACD8..0x82EEACE4)
	// 82EEACD8: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EEACDC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82EEACE0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEACE4; continue 'dispatch;
            }
            0x82EEACE4 => {
    //   block [0x82EEACE4..0x82EEAD64)
	// 82EEACE4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEACE8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEACEC: 409A007C  bne cr6, 0x82eead68
	if !ctx.cr[6].eq {
	pc = 0x82EEAD68; continue 'dispatch;
	}
	// 82EEACF0: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EEACF4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEACF8: 40990070  ble cr6, 0x82eead68
	if !ctx.cr[6].gt {
	pc = 0x82EEAD68; continue 'dispatch;
	}
	// 82EEACFC: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAD00: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAD04: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAD08: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEAD0C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEAD10: 4BD95261  bl 0x82c7ff70
	ctx.lr = 0x82EEAD14;
	sub_82C7FF70(ctx, base);
	// 82EEAD14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82EEAD18: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAD1C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAD20: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAD24: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEAD28: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEAD2C: 4BA1F415  bl 0x8290a140
	ctx.lr = 0x82EEAD30;
	sub_8290A140(ctx, base);
	// 82EEAD30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEAD34: 4BD9560D  bl 0x82c80340
	ctx.lr = 0x82EEAD38;
	sub_82C80340(ctx, base);
	// 82EEAD38: B0610074  sth r3, 0x74(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u16 ) };
	// 82EEAD3C: 4BEC6E85  bl 0x82db1bc0
	ctx.lr = 0x82EEAD40;
	sub_82DB1BC0(ctx, base);
	// 82EEAD40: B0610076  sth r3, 0x76(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[3].u16 ) };
	// 82EEAD44: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 82EEAD48: 38610076  addi r3, r1, 0x76
	ctx.r[3].s64 = ctx.r[1].s64 + 118;
	// 82EEAD4C: 4BD8E275  bl 0x82c78fc0
	ctx.lr = 0x82EEAD50;
	sub_82C78FC0(ctx, base);
	// 82EEAD50: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEAD54: 41820010  beq 0x82eead64
	if ctx.cr[0].eq {
	pc = 0x82EEAD64; continue 'dispatch;
	}
	// 82EEAD58: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEAD5C: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82EEAD60: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEAD64; continue 'dispatch;
            }
            0x82EEAD64 => {
    //   block [0x82EEAD64..0x82EEAD68)
	// 82EEAD64: 4BFFFF74  b 0x82eeacd8
	pc = 0x82EEACD8; continue 'dispatch;
            }
            0x82EEAD68 => {
    //   block [0x82EEAD68..0x82EEADCC)
	// 82EEAD68: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82EEAD6C: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAD70: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAD74: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAD78: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEAD7C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEAD80: 4B791421  bl 0x8267c1a0
	ctx.lr = 0x82EEAD84;
	sub_8267C1A0(ctx, base);
	// 82EEAD84: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EEAD88: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEAD8C: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAD90: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAD94: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEAD98: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEAD9C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82EEADA0: 4BD909C1  bl 0x82c7b760
	ctx.lr = 0x82EEADA4;
	sub_82C7B760(ctx, base);
	// 82EEADA4: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEADA8: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82EEADAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEADB0: 4BD96241  bl 0x82c80ff0
	ctx.lr = 0x82EEADB4;
	sub_82C80FF0(ctx, base);
	// 82EEADB4: 80610078  lwz r3, 0x78(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82EEADB8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EEADBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEADC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEADC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEADC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEADD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEADD0 size=160
    let mut pc: u32 = 0x82EEADD0;
    'dispatch: loop {
        match pc {
            0x82EEADD0 => {
    //   block [0x82EEADD0..0x82EEAE04)
	// 82EEADD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEADD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEADD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEADDC: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EEADE0: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EEADE4: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEADE8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEADEC: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEADF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEADF4: 409A0010  bne cr6, 0x82eeae04
	if !ctx.cr[6].eq {
	pc = 0x82EEAE04; continue 'dispatch;
	}
	// 82EEADF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEADFC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82EEAE00: 48000018  b 0x82eeae18
	pc = 0x82EEAE18; continue 'dispatch;
            }
            0x82EEAE04 => {
    //   block [0x82EEAE04..0x82EEAE18)
	// 82EEAE04: 38A0000A  li r5, 0xa
	ctx.r[5].s64 = 10;
	// 82EEAE08: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EEAE0C: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEAE10: 4811E249  bl 0x83009058
	ctx.lr = 0x82EEAE14;
	sub_83009058(ctx, base);
	// 82EEAE14: F8610058  std r3, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u64 ) };
	pc = 0x82EEAE18; continue 'dispatch;
            }
            0x82EEAE18 => {
    //   block [0x82EEAE18..0x82EEAE50)
	// 82EEAE18: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82EEAE1C: 8141008C  lwz r10, 0x8c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEAE20: F96A0000  std r11, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82EEAE24: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEAE28: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEAE2C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEAE30: 419A0020  beq cr6, 0x82eeae50
	if ctx.cr[6].eq {
	pc = 0x82EEAE50; continue 'dispatch;
	}
	// 82EEAE34: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEAE38: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAE3C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEAE40: 40820010  bne 0x82eeae50
	if !ctx.cr[0].eq {
	pc = 0x82EEAE50; continue 'dispatch;
	}
	// 82EEAE44: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EEAE48: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EEAE4C: 4800000C  b 0x82eeae58
	pc = 0x82EEAE58; continue 'dispatch;
            }
            0x82EEAE50 => {
    //   block [0x82EEAE50..0x82EEAE58)
	// 82EEAE50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEAE54: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEAE58; continue 'dispatch;
            }
            0x82EEAE58 => {
    //   block [0x82EEAE58..0x82EEAE70)
	// 82EEAE58: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EEAE5C: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EEAE60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EEAE64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEAE68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEAE6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEAE70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEAE70 size=160
    let mut pc: u32 = 0x82EEAE70;
    'dispatch: loop {
        match pc {
            0x82EEAE70 => {
    //   block [0x82EEAE70..0x82EEAEA4)
	// 82EEAE70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEAE74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEAE78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEAE7C: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EEAE80: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EEAE84: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEAE88: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEAE8C: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEAE90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEAE94: 409A0010  bne cr6, 0x82eeaea4
	if !ctx.cr[6].eq {
	pc = 0x82EEAEA4; continue 'dispatch;
	}
	// 82EEAE98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEAE9C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82EEAEA0: 48000018  b 0x82eeaeb8
	pc = 0x82EEAEB8; continue 'dispatch;
            }
            0x82EEAEA4 => {
    //   block [0x82EEAEA4..0x82EEAEB8)
	// 82EEAEA4: 38A0000A  li r5, 0xa
	ctx.r[5].s64 = 10;
	// 82EEAEA8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EEAEAC: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEAEB0: 4BDC2131  bl 0x82cacfe0
	ctx.lr = 0x82EEAEB4;
	sub_82CACFE0(ctx, base);
	// 82EEAEB4: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	pc = 0x82EEAEB8; continue 'dispatch;
            }
            0x82EEAEB8 => {
    //   block [0x82EEAEB8..0x82EEAEF0)
	// 82EEAEB8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEAEBC: 8141008C  lwz r10, 0x8c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEAEC0: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEAEC4: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEAEC8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEAECC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEAED0: 419A0020  beq cr6, 0x82eeaef0
	if ctx.cr[6].eq {
	pc = 0x82EEAEF0; continue 'dispatch;
	}
	// 82EEAED4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEAED8: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAEDC: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEAEE0: 40820010  bne 0x82eeaef0
	if !ctx.cr[0].eq {
	pc = 0x82EEAEF0; continue 'dispatch;
	}
	// 82EEAEE4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EEAEE8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82EEAEEC: 4800000C  b 0x82eeaef8
	pc = 0x82EEAEF8; continue 'dispatch;
            }
            0x82EEAEF0 => {
    //   block [0x82EEAEF0..0x82EEAEF8)
	// 82EEAEF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEAEF4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEAEF8; continue 'dispatch;
            }
            0x82EEAEF8 => {
    //   block [0x82EEAEF8..0x82EEAF10)
	// 82EEAEF8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82EEAEFC: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EEAF00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EEAF04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEAF08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEAF0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEAF10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEAF10 size=160
    let mut pc: u32 = 0x82EEAF10;
    'dispatch: loop {
        match pc {
            0x82EEAF10 => {
    //   block [0x82EEAF10..0x82EEAF44)
	// 82EEAF10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEAF14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEAF18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEAF1C: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82EEAF20: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82EEAF24: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEAF28: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEAF2C: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEAF30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEAF34: 409A0010  bne cr6, 0x82eeaf44
	if !ctx.cr[6].eq {
	pc = 0x82EEAF44; continue 'dispatch;
	}
	// 82EEAF38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEAF3C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82EEAF40: 48000018  b 0x82eeaf58
	pc = 0x82EEAF58; continue 'dispatch;
            }
            0x82EEAF44 => {
    //   block [0x82EEAF44..0x82EEAF58)
	// 82EEAF44: 38A0000A  li r5, 0xa
	ctx.r[5].s64 = 10;
	// 82EEAF48: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82EEAF4C: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEAF50: 4811E129  bl 0x83009078
	ctx.lr = 0x82EEAF54;
	sub_83009078(ctx, base);
	// 82EEAF54: F8610058  std r3, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u64 ) };
	pc = 0x82EEAF58; continue 'dispatch;
            }
            0x82EEAF58 => {
    //   block [0x82EEAF58..0x82EEAF90)
	// 82EEAF58: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82EEAF5C: 8141008C  lwz r10, 0x8c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEAF60: F96A0000  std r11, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82EEAF64: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEAF68: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEAF6C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82EEAF70: 419A0020  beq cr6, 0x82eeaf90
	if ctx.cr[6].eq {
	pc = 0x82EEAF90; continue 'dispatch;
	}
	// 82EEAF74: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEAF78: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAF7C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEAF80: 40820010  bne 0x82eeaf90
	if !ctx.cr[0].eq {
	pc = 0x82EEAF90; continue 'dispatch;
	}
	// 82EEAF84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EEAF88: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82EEAF8C: 4800000C  b 0x82eeaf98
	pc = 0x82EEAF98; continue 'dispatch;
            }
            0x82EEAF90 => {
    //   block [0x82EEAF90..0x82EEAF98)
	// 82EEAF90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEAF94: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEAF98; continue 'dispatch;
            }
            0x82EEAF98 => {
    //   block [0x82EEAF98..0x82EEAFB0)
	// 82EEAF98: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82EEAF9C: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EEAFA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82EEAFA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEAFA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEAFAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEAFB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEAFB0 size=152
    let mut pc: u32 = 0x82EEAFB0;
    'dispatch: loop {
        match pc {
            0x82EEAFB0 => {
    //   block [0x82EEAFB0..0x82EEB004)
	// 82EEAFB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEAFB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEAFB8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEAFBC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEAFC0: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEAFC4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEAFC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEAFCC: 419A0068  beq cr6, 0x82eeb034
	if ctx.cr[6].eq {
	pc = 0x82EEB034; continue 'dispatch;
	}
	// 82EEAFD0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEAFD4: A08B0000  lhz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEAFD8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEAFDC: 386BC17C  addi r3, r11, -0x3e84
	ctx.r[3].s64 = ctx.r[11].s64 + -16004;
	// 82EEAFE0: 4BDC1D21  bl 0x82cacd00
	ctx.lr = 0x82EEAFE4;
	sub_82CACD00(ctx, base);
	// 82EEAFE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EEAFE8: 4182001C  beq 0x82eeb004
	if ctx.cr[0].eq {
	pc = 0x82EEB004; continue 'dispatch;
	}
	// 82EEAFEC: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEAFF0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82EEAFF4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EEAFF8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EEAFFC: 4800003C  b 0x82eeb038
	pc = 0x82EEB038; continue 'dispatch;
	// 82EEB000: 48000034  b 0x82eeb034
	pc = 0x82EEB034; continue 'dispatch;
            }
            0x82EEB004 => {
    //   block [0x82EEB004..0x82EEB034)
	// 82EEB004: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB008: A08B0000  lhz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEB00C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEB010: 386BC170  addi r3, r11, -0x3e90
	ctx.r[3].s64 = ctx.r[11].s64 + -16016;
	// 82EEB014: 4BDC1CED  bl 0x82cacd00
	ctx.lr = 0x82EEB018;
	sub_82CACD00(ctx, base);
	// 82EEB018: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82EEB01C: 41820018  beq 0x82eeb034
	if ctx.cr[0].eq {
	pc = 0x82EEB034; continue 'dispatch;
	}
	// 82EEB020: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEB024: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82EEB028: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82EEB02C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82EEB030: 48000008  b 0x82eeb038
	pc = 0x82EEB038; continue 'dispatch;
            }
            0x82EEB034 => {
    //   block [0x82EEB034..0x82EEB038)
	// 82EEB034: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82EEB038; continue 'dispatch;
            }
            0x82EEB038 => {
    //   block [0x82EEB038..0x82EEB048)
	// 82EEB038: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEB03C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEB040: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEB044: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEB048 size=284
    let mut pc: u32 = 0x82EEB048;
    'dispatch: loop {
        match pc {
            0x82EEB048 => {
    //   block [0x82EEB048..0x82EEB0CC)
	// 82EEB048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEB04C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEB050: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEB054: F8C10028  std r6, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
	// 82EEB058: F8E10030  std r7, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.r[7].u64 ) };
	// 82EEB05C: F9010038  std r8, 0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(56 as u32), ctx.r[8].u64 ) };
	// 82EEB060: F9210040  std r9, 0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(64 as u32), ctx.r[9].u64 ) };
	// 82EEB064: F9410048  std r10, 0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(72 as u32), ctx.r[10].u64 ) };
	// 82EEB068: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEB06C: 906100A4  stw r3, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[3].u32 ) };
	// 82EEB070: 908100AC  stw r4, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[4].u32 ) };
	// 82EEB074: 90A100B4  stw r5, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[5].u32 ) };
	// 82EEB078: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEB07C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEB080: 409A004C  bne cr6, 0x82eeb0cc
	if !ctx.cr[6].eq {
	pc = 0x82EEB0CC; continue 'dispatch;
	}
	// 82EEB084: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEB088: 896B8F4D  lbz r11, -0x70b3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28851 as u32) ) } as u64;
	// 82EEB08C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEB090: 4082003C  bne 0x82eeb0cc
	if !ctx.cr[0].eq {
	pc = 0x82EEB0CC; continue 'dispatch;
	}
	// 82EEB094: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEB098: 3BEB8F4D  addi r31, r11, -0x70b3
	ctx.r[31].s64 = ctx.r[11].s64 + -28851;
	// 82EEB09C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEB0A0: 38CBC1FC  addi r6, r11, -0x3e04
	ctx.r[6].s64 = ctx.r[11].s64 + -15876;
	// 82EEB0A4: 38A00017  li r5, 0x17
	ctx.r[5].s64 = 23;
	// 82EEB0A8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEB0AC: 388BC198  addi r4, r11, -0x3e68
	ctx.r[4].s64 = ctx.r[11].s64 + -15976;
	// 82EEB0B0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEB0B4: 480000B5  bl 0x82eeb168
	ctx.lr = 0x82EEB0B8;
	sub_82EEB168(ctx, base);
	// 82EEB0B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEB0BC: 48206CFD  bl 0x830f1db8
	ctx.lr = 0x82EEB0C0;
	sub_830F1DB8(ctx, base);
	// 82EEB0C0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEB0C4: 40820008  bne 0x82eeb0cc
	if !ctx.cr[0].eq {
	pc = 0x82EEB0CC; continue 'dispatch;
	}
	// 82EEB0C8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82EEB0CC; continue 'dispatch;
            }
            0x82EEB0CC => {
    //   block [0x82EEB0CC..0x82EEB120)
	// 82EEB0CC: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEB0D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEB0D4: 409A004C  bne cr6, 0x82eeb120
	if !ctx.cr[6].eq {
	pc = 0x82EEB120; continue 'dispatch;
	}
	// 82EEB0D8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEB0DC: 896B8F4C  lbz r11, -0x70b4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28852 as u32) ) } as u64;
	// 82EEB0E0: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEB0E4: 4082003C  bne 0x82eeb120
	if !ctx.cr[0].eq {
	pc = 0x82EEB120; continue 'dispatch;
	}
	// 82EEB0E8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEB0EC: 3BEB8F4C  addi r31, r11, -0x70b4
	ctx.r[31].s64 = ctx.r[11].s64 + -28852;
	// 82EEB0F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEB0F4: 38CBC188  addi r6, r11, -0x3e78
	ctx.r[6].s64 = ctx.r[11].s64 + -15992;
	// 82EEB0F8: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 82EEB0FC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEB100: 388BC198  addi r4, r11, -0x3e68
	ctx.r[4].s64 = ctx.r[11].s64 + -15976;
	// 82EEB104: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EEB108: 48000061  bl 0x82eeb168
	ctx.lr = 0x82EEB10C;
	sub_82EEB168(ctx, base);
	// 82EEB10C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEB110: 48206CA9  bl 0x830f1db8
	ctx.lr = 0x82EEB114;
	sub_830F1DB8(ctx, base);
	// 82EEB114: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEB118: 40820008  bne 0x82eeb120
	if !ctx.cr[0].eq {
	pc = 0x82EEB120; continue 'dispatch;
	}
	// 82EEB11C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82EEB120; continue 'dispatch;
            }
            0x82EEB120 => {
    //   block [0x82EEB120..0x82EEB164)
	// 82EEB120: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EEB124: 394100B8  addi r10, r1, 0xb8
	ctx.r[10].s64 = ctx.r[1].s64 + 184;
	// 82EEB128: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EEB12C: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEB130: 80A100B4  lwz r5, 0xb4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEB134: 808100AC  lwz r4, 0xac(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82EEB138: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEB13C: 4BDC148D  bl 0x82cac5c8
	ctx.lr = 0x82EEB140;
	sub_82CAC5C8(ctx, base);
	// 82EEB140: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EEB144: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEB148: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEB14C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEB150: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EEB154: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEB158: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEB15C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEB160: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEB168 size=76
    let mut pc: u32 = 0x82EEB168;
    'dispatch: loop {
        match pc {
            0x82EEB168 => {
    //   block [0x82EEB168..0x82EEB1B4)
	// 82EEB168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEB16C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEB170: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEB174: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEB178: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEB17C: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEB180: 90C1008C  stw r6, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[6].u32 ) };
	// 82EEB184: 80A10084  lwz r5, 0x84(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEB188: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEB18C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB190: 48000029  bl 0x82eeb1b8
	ctx.lr = 0x82EEB194;
	sub_82EEB1B8(ctx, base);
	// 82EEB194: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB198: 8141008C  lwz r10, 0x8c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82EEB19C: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EEB1A0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB1A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEB1A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEB1AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEB1B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB1B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEB1B8 size=44
    let mut pc: u32 = 0x82EEB1B8;
    'dispatch: loop {
        match pc {
            0x82EEB1B8 => {
    //   block [0x82EEB1B8..0x82EEB1E4)
	// 82EEB1B8: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEB1BC: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EEB1C0: 90A10024  stw r5, 0x24(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(36 as u32), ctx.r[5].u32 ) };
	// 82EEB1C4: 81610024  lwz r11, 0x24(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) } as u64;
	// 82EEB1C8: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEB1CC: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEB1D0: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEB1D4: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EEB1D8: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82EEB1DC: 80610014  lwz r3, 0x14(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEB1E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB1E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEB1E8 size=284
    let mut pc: u32 = 0x82EEB1E8;
    'dispatch: loop {
        match pc {
            0x82EEB1E8 => {
    //   block [0x82EEB1E8..0x82EEB26C)
	// 82EEB1E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEB1EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEB1F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82EEB1F4: F8C10028  std r6, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
	// 82EEB1F8: F8E10030  std r7, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.r[7].u64 ) };
	// 82EEB1FC: F9010038  std r8, 0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(56 as u32), ctx.r[8].u64 ) };
	// 82EEB200: F9210040  std r9, 0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(64 as u32), ctx.r[9].u64 ) };
	// 82EEB204: F9410048  std r10, 0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(72 as u32), ctx.r[10].u64 ) };
	// 82EEB208: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEB20C: 906100A4  stw r3, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[3].u32 ) };
	// 82EEB210: 908100AC  stw r4, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[4].u32 ) };
	// 82EEB214: 90A100B4  stw r5, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[5].u32 ) };
	// 82EEB218: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEB21C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEB220: 409A004C  bne cr6, 0x82eeb26c
	if !ctx.cr[6].eq {
	pc = 0x82EEB26C; continue 'dispatch;
	}
	// 82EEB224: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEB228: 896B8F4F  lbz r11, -0x70b1(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28849 as u32) ) } as u64;
	// 82EEB22C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEB230: 4082003C  bne 0x82eeb26c
	if !ctx.cr[0].eq {
	pc = 0x82EEB26C; continue 'dispatch;
	}
	// 82EEB234: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEB238: 3BEB8F4F  addi r31, r11, -0x70b1
	ctx.r[31].s64 = ctx.r[11].s64 + -28849;
	// 82EEB23C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEB240: 38CBC1FC  addi r6, r11, -0x3e04
	ctx.r[6].s64 = ctx.r[11].s64 + -15876;
	// 82EEB244: 38A00022  li r5, 0x22
	ctx.r[5].s64 = 34;
	// 82EEB248: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEB24C: 388BC198  addi r4, r11, -0x3e68
	ctx.r[4].s64 = ctx.r[11].s64 + -15976;
	// 82EEB250: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82EEB254: 4BFFFF15  bl 0x82eeb168
	ctx.lr = 0x82EEB258;
	sub_82EEB168(ctx, base);
	// 82EEB258: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEB25C: 48206B5D  bl 0x830f1db8
	ctx.lr = 0x82EEB260;
	sub_830F1DB8(ctx, base);
	// 82EEB260: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEB264: 40820008  bne 0x82eeb26c
	if !ctx.cr[0].eq {
	pc = 0x82EEB26C; continue 'dispatch;
	}
	// 82EEB268: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82EEB26C; continue 'dispatch;
            }
            0x82EEB26C => {
    //   block [0x82EEB26C..0x82EEB2C0)
	// 82EEB26C: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEB270: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEB274: 409A004C  bne cr6, 0x82eeb2c0
	if !ctx.cr[6].eq {
	pc = 0x82EEB2C0; continue 'dispatch;
	}
	// 82EEB278: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEB27C: 896B8F4E  lbz r11, -0x70b2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28850 as u32) ) } as u64;
	// 82EEB280: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82EEB284: 4082003C  bne 0x82eeb2c0
	if !ctx.cr[0].eq {
	pc = 0x82EEB2C0; continue 'dispatch;
	}
	// 82EEB288: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82EEB28C: 3BEB8F4E  addi r31, r11, -0x70b2
	ctx.r[31].s64 = ctx.r[11].s64 + -28850;
	// 82EEB290: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEB294: 38CBC188  addi r6, r11, -0x3e78
	ctx.r[6].s64 = ctx.r[11].s64 + -15992;
	// 82EEB298: 38A00023  li r5, 0x23
	ctx.r[5].s64 = 35;
	// 82EEB29C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEB2A0: 388BC198  addi r4, r11, -0x3e68
	ctx.r[4].s64 = ctx.r[11].s64 + -15976;
	// 82EEB2A4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82EEB2A8: 4BFFFEC1  bl 0x82eeb168
	ctx.lr = 0x82EEB2AC;
	sub_82EEB168(ctx, base);
	// 82EEB2AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82EEB2B0: 48206B09  bl 0x830f1db8
	ctx.lr = 0x82EEB2B4;
	sub_830F1DB8(ctx, base);
	// 82EEB2B4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEB2B8: 40820008  bne 0x82eeb2c0
	if !ctx.cr[0].eq {
	pc = 0x82EEB2C0; continue 'dispatch;
	}
	// 82EEB2BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82EEB2C0; continue 'dispatch;
            }
            0x82EEB2C0 => {
    //   block [0x82EEB2C0..0x82EEB304)
	// 82EEB2C0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82EEB2C4: 394100B8  addi r10, r1, 0xb8
	ctx.r[10].s64 = ctx.r[1].s64 + 184;
	// 82EEB2C8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82EEB2CC: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEB2D0: 80A100B4  lwz r5, 0xb4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82EEB2D4: 808100AC  lwz r4, 0xac(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82EEB2D8: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82EEB2DC: 4BDC25A5  bl 0x82cad880
	ctx.lr = 0x82EEB2E0;
	sub_82CAD880(ctx, base);
	// 82EEB2E0: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82EEB2E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEB2E8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEB2EC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82EEB2F0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82EEB2F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEB2F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEB2FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82EEB300: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEB308 size=56
    let mut pc: u32 = 0x82EEB308;
    'dispatch: loop {
        match pc {
            0x82EEB308 => {
    //   block [0x82EEB308..0x82EEB340)
	// 82EEB308: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEB30C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEB310: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEB314: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEB318: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB31C: 386B0054  addi r3, r11, 0x54
	ctx.r[3].s64 = ctx.r[11].s64 + 84;
	// 82EEB320: 480001B1  bl 0x82eeb4d0
	ctx.lr = 0x82EEB324;
	sub_82EEB4D0(ctx, base);
	// 82EEB324: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB328: 386B0054  addi r3, r11, 0x54
	ctx.r[3].s64 = ctx.r[11].s64 + 84;
	// 82EEB32C: 4BD8DDB5  bl 0x82c790e0
	ctx.lr = 0x82EEB330;
	sub_82C790E0(ctx, base);
	// 82EEB330: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEB334: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEB338: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEB33C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEB340 size=28
    let mut pc: u32 = 0x82EEB340;
    'dispatch: loop {
        match pc {
            0x82EEB340 => {
    //   block [0x82EEB340..0x82EEB35C)
	// 82EEB340: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEB344: 9081001C  stw r4, 0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82EEB348: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82EEB34C: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEB350: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEB354: 80610014  lwz r3, 0x14(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEB358: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEB360 size=44
    let mut pc: u32 = 0x82EEB360;
    'dispatch: loop {
        match pc {
            0x82EEB360 => {
    //   block [0x82EEB360..0x82EEB38C)
	// 82EEB360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEB364: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEB368: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEB36C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEB370: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB374: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEB378: 48000019  bl 0x82eeb390
	ctx.lr = 0x82EEB37C;
	sub_82EEB390(ctx, base);
	// 82EEB37C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEB380: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEB384: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEB388: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEB390 size=64
    let mut pc: u32 = 0x82EEB390;
    'dispatch: loop {
        match pc {
            0x82EEB390 => {
    //   block [0x82EEB390..0x82EEB3C0)
	// 82EEB390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEB394: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEB398: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEB39C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEB3A0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB3A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEB3A8: 419A0018  beq cr6, 0x82eeb3c0
	if ctx.cr[6].eq {
	pc = 0x82EEB3C0; continue 'dispatch;
	}
	// 82EEB3AC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB3B0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EEB3B4: 419A000C  beq cr6, 0x82eeb3c0
	if ctx.cr[6].eq {
	pc = 0x82EEB3C0; continue 'dispatch;
	}
	// 82EEB3B8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB3BC: 4BDD73F5  bl 0x82cc27b0
	ctx.lr = 0x82EEB3C0;
	sub_82CC27B0(ctx, base);
	pc = 0x82EEB3C0; continue 'dispatch;
            }
            0x82EEB3C0 => {
    //   block [0x82EEB3C0..0x82EEB3D0)
	// 82EEB3C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEB3C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEB3C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEB3CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB3D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82EEB3D0 size=68
    let mut pc: u32 = 0x82EEB3D0;
    'dispatch: loop {
        match pc {
            0x82EEB3D0 => {
    //   block [0x82EEB3D0..0x82EEB400)
	// 82EEB3D0: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82EEB3D4: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEB3D8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEB3DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEB3E0: 419A0020  beq cr6, 0x82eeb400
	if ctx.cr[6].eq {
	pc = 0x82EEB400; continue 'dispatch;
	}
	// 82EEB3E4: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82EEB3E8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEB3EC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82EEB3F0: 419A0010  beq cr6, 0x82eeb400
	if ctx.cr[6].eq {
	pc = 0x82EEB400; continue 'dispatch;
	}
	// 82EEB3F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEB3F8: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82EEB3FC: 4800000C  b 0x82eeb408
	pc = 0x82EEB408; continue 'dispatch;
            }
            0x82EEB400 => {
    //   block [0x82EEB400..0x82EEB408)
	// 82EEB400: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82EEB404: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEB408; continue 'dispatch;
            }
            0x82EEB408 => {
    //   block [0x82EEB408..0x82EEB414)
	// 82EEB408: 8161FFF0  lwz r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82EEB40C: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82EEB410: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEB418 size=184
    let mut pc: u32 = 0x82EEB418;
    'dispatch: loop {
        match pc {
            0x82EEB418 => {
    //   block [0x82EEB418..0x82EEB47C)
	// 82EEB418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEB41C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEB420: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEB424: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEB428: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEB42C: 90A10084  stw r5, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[5].u32 ) };
	// 82EEB430: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEB434: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEB438: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82EEB43C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82EEB440: 419A003C  beq cr6, 0x82eeb47c
	if ctx.cr[6].eq {
	pc = 0x82EEB47C; continue 'dispatch;
	}
	// 82EEB444: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82EEB448: 396BC20C  addi r11, r11, -0x3df4
	ctx.r[11].s64 = ctx.r[11].s64 + -15860;
	// 82EEB44C: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB450: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82EEB454: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB458: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82EEB45C: 394AB27C  addi r10, r10, -0x4d84
	ctx.r[10].s64 = ctx.r[10].s64 + -19844;
	// 82EEB460: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82EEB464: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB468: 386B0054  addi r3, r11, 0x54
	ctx.r[3].s64 = ctx.r[11].s64 + 84;
	// 82EEB46C: 4BD8DCA5  bl 0x82c79110
	ctx.lr = 0x82EEB470;
	sub_82C79110(ctx, base);
	// 82EEB470: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEB474: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82EEB478: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEB47C; continue 'dispatch;
            }
            0x82EEB47C => {
    //   block [0x82EEB47C..0x82EEB4D0)
	// 82EEB47C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82EEB480: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB484: 388B000C  addi r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 + 12;
	// 82EEB488: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB48C: 4800023D  bl 0x82eeb6c8
	ctx.lr = 0x82EEB490;
	sub_82EEB6C8(ctx, base);
	// 82EEB490: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB494: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82EEB498: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB49C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEB4A0: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EEB4A4: 3929C208  addi r9, r9, -0x3df8
	ctx.r[9].s64 = ctx.r[9].s64 + -15864;
	// 82EEB4A8: 7D2A592E  stwx r9, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u32) };
	// 82EEB4AC: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEB4B0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB4B4: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82EEB4B8: 4BD94F89  bl 0x82c80440
	ctx.lr = 0x82EEB4BC;
	sub_82C80440(ctx, base);
	// 82EEB4BC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB4C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEB4C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEB4C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEB4CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB4D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEB4D0 size=96
    let mut pc: u32 = 0x82EEB4D0;
    'dispatch: loop {
        match pc {
            0x82EEB4D0 => {
    //   block [0x82EEB4D0..0x82EEB530)
	// 82EEB4D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEB4D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEB4D8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEB4DC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEB4E0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB4E4: 396BFFAC  addi r11, r11, -0x54
	ctx.r[11].s64 = ctx.r[11].s64 + -84;
	// 82EEB4E8: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB4EC: 814AFFAC  lwz r10, -0x54(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-84 as u32) ) } as u64;
	// 82EEB4F0: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEB4F4: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EEB4F8: 3929C208  addi r9, r9, -0x3df8
	ctx.r[9].s64 = ctx.r[9].s64 + -15864;
	// 82EEB4FC: 7D2B512E  stwx r9, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u32) };
	// 82EEB500: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB504: 396BFFAC  addi r11, r11, -0x54
	ctx.r[11].s64 = ctx.r[11].s64 + -84;
	// 82EEB508: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82EEB50C: 4BD8E2FD  bl 0x82c79808
	ctx.lr = 0x82EEB510;
	sub_82C79808(ctx, base);
	// 82EEB510: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB514: 396BFFAC  addi r11, r11, -0x54
	ctx.r[11].s64 = ctx.r[11].s64 + -84;
	// 82EEB518: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82EEB51C: 4800004D  bl 0x82eeb568
	ctx.lr = 0x82EEB520;
	sub_82EEB568(ctx, base);
	// 82EEB520: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEB524: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEB528: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEB52C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEB530 size=56
    let mut pc: u32 = 0x82EEB530;
    'dispatch: loop {
        match pc {
            0x82EEB530 => {
    //   block [0x82EEB530..0x82EEB568)
	// 82EEB530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEB534: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEB538: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEB53C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEB540: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEB544: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB548: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEB54C: 388B000C  addi r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 + 12;
	// 82EEB550: 4BD95031  bl 0x82c80580
	ctx.lr = 0x82EEB554;
	sub_82C80580(ctx, base);
	// 82EEB554: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB558: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEB55C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEB560: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEB564: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEB568 size=132
    let mut pc: u32 = 0x82EEB568;
    'dispatch: loop {
        match pc {
            0x82EEB568 => {
    //   block [0x82EEB568..0x82EEB5B8)
	// 82EEB568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEB56C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEB570: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEB574: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEB578: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB57C: 396BFFF4  addi r11, r11, -0xc
	ctx.r[11].s64 = ctx.r[11].s64 + -12;
	// 82EEB580: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB584: 814AFFF4  lwz r10, -0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82EEB588: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82EEB58C: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82EEB590: 3929C214  addi r9, r9, -0x3dec
	ctx.r[9].s64 = ctx.r[9].s64 + -15852;
	// 82EEB594: 7D2B512E  stwx r9, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u32) };
	// 82EEB598: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB59C: 356BFFF4  addic. r11, r11, -0xc
	ctx.xer.ca = (ctx.r[11].u32 > (!(-12 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -12;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEB5A0: 41820018  beq 0x82eeb5b8
	if ctx.cr[0].eq {
	pc = 0x82EEB5B8; continue 'dispatch;
	}
	// 82EEB5A4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB5A8: 396BFFF4  addi r11, r11, -0xc
	ctx.r[11].s64 = ctx.r[11].s64 + -12;
	// 82EEB5AC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82EEB5B0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82EEB5B4: 4800000C  b 0x82eeb5c0
	pc = 0x82EEB5C0; continue 'dispatch;
            }
            0x82EEB5B8 => {
    //   block [0x82EEB5B8..0x82EEB5C0)
	// 82EEB5B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82EEB5BC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82EEB5C0; continue 'dispatch;
            }
            0x82EEB5C0 => {
    //   block [0x82EEB5C0..0x82EEB5EC)
	// 82EEB5C0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82EEB5C4: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82EEB5C8: 4BD94989  bl 0x82c7ff50
	ctx.lr = 0x82EEB5CC;
	sub_82C7FF50(ctx, base);
	// 82EEB5CC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB5D0: 396BFFF4  addi r11, r11, -0xc
	ctx.r[11].s64 = ctx.r[11].s64 + -12;
	// 82EEB5D4: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82EEB5D8: 4BD8DB19  bl 0x82c790f0
	ctx.lr = 0x82EEB5DC;
	sub_82C790F0(ctx, base);
	// 82EEB5DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEB5E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEB5E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEB5E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB5F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEB5F0 size=80
    let mut pc: u32 = 0x82EEB5F0;
    'dispatch: loop {
        match pc {
            0x82EEB5F0 => {
    //   block [0x82EEB5F0..0x82EEB628)
	// 82EEB5F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEB5F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEB5F8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEB5FC: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEB600: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEB604: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB608: 386BFFAC  addi r3, r11, -0x54
	ctx.r[3].s64 = ctx.r[11].s64 + -84;
	// 82EEB60C: 4BFFFCFD  bl 0x82eeb308
	ctx.lr = 0x82EEB610;
	sub_82EEB308(ctx, base);
	// 82EEB610: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEB614: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEB618: 41820010  beq 0x82eeb628
	if ctx.cr[0].eq {
	pc = 0x82EEB628; continue 'dispatch;
	}
	// 82EEB61C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB620: 386BFFAC  addi r3, r11, -0x54
	ctx.r[3].s64 = ctx.r[11].s64 + -84;
	// 82EEB624: 4B95A18D  bl 0x828457b0
	ctx.lr = 0x82EEB628;
	sub_828457B0(ctx, base);
	pc = 0x82EEB628; continue 'dispatch;
            }
            0x82EEB628 => {
    //   block [0x82EEB628..0x82EEB640)
	// 82EEB628: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB62C: 386BFFAC  addi r3, r11, -0x54
	ctx.r[3].s64 = ctx.r[11].s64 + -84;
	// 82EEB630: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEB634: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEB638: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEB63C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEB640 size=80
    let mut pc: u32 = 0x82EEB640;
    'dispatch: loop {
        match pc {
            0x82EEB640 => {
    //   block [0x82EEB640..0x82EEB678)
	// 82EEB640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEB644: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEB648: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEB64C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEB650: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82EEB654: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB658: 386BFFF4  addi r3, r11, -0xc
	ctx.r[3].s64 = ctx.r[11].s64 + -12;
	// 82EEB65C: 48000035  bl 0x82eeb690
	ctx.lr = 0x82EEB660;
	sub_82EEB690(ctx, base);
	// 82EEB660: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82EEB664: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82EEB668: 41820010  beq 0x82eeb678
	if ctx.cr[0].eq {
	pc = 0x82EEB678; continue 'dispatch;
	}
	// 82EEB66C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB670: 386BFFF4  addi r3, r11, -0xc
	ctx.r[3].s64 = ctx.r[11].s64 + -12;
	// 82EEB674: 4B95A13D  bl 0x828457b0
	ctx.lr = 0x82EEB678;
	sub_828457B0(ctx, base);
	pc = 0x82EEB678; continue 'dispatch;
            }
            0x82EEB678 => {
    //   block [0x82EEB678..0x82EEB690)
	// 82EEB678: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB67C: 386BFFF4  addi r3, r11, -0xc
	ctx.r[3].s64 = ctx.r[11].s64 + -12;
	// 82EEB680: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEB684: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEB688: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEB68C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82EEB690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82EEB690 size=56
    let mut pc: u32 = 0x82EEB690;
    'dispatch: loop {
        match pc {
            0x82EEB690 => {
    //   block [0x82EEB690..0x82EEB6C8)
	// 82EEB690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82EEB694: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82EEB698: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82EEB69C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82EEB6A0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB6A4: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82EEB6A8: 4BFFFEC1  bl 0x82eeb568
	ctx.lr = 0x82EEB6AC;
	sub_82EEB568(ctx, base);
	// 82EEB6AC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82EEB6B0: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82EEB6B4: 4BD8DA2D  bl 0x82c790e0
	ctx.lr = 0x82EEB6B8;
	sub_82C790E0(ctx, base);
	// 82EEB6B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82EEB6BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82EEB6C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82EEB6C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


