pub fn sub_824FEBB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824FEBB8 size=260
    let mut pc: u32 = 0x824FEBB8;
    'dispatch: loop {
        match pc {
            0x824FEBB8 => {
    //   block [0x824FEBB8..0x824FEC04)
	// 824FEBB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824FEBBC: 48036501  bl 0x825350bc
	ctx.lr = 0x824FEBC0;
	sub_82535080(ctx, base);
	// 824FEBC0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824FEBC4: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824FEBC8: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824FEBCC: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 824FEBD0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 824FEBD4: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824FEBD8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824FEBDC: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824FEBE0: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 824FEBE4: 40980020  bge cr6, 0x824fec04
	if !ctx.cr[6].lt {
	pc = 0x824FEC04; continue 'dispatch;
	}
	// 824FEBE8: 3C808206  lis r4, -0x7dfa
	ctx.r[4].s64 = -2113536000;
	// 824FEBEC: 38844334  addi r4, r4, 0x4334
	ctx.r[4].s64 = ctx.r[4].s64 + 17204;
	// 824FEBF0: 908A0000  stw r4, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 824FEBF4: 7C8C42E6  mftb r4, 0x10c
	ctx.r[4].u64 = crate::rt::rdtsc_u64();
	// 824FEBF8: 3BAA000C  addi r29, r10, 0xc
	ctx.r[29].s64 = ctx.r[10].s64 + 12;
	// 824FEBFC: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 824FEC00: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	pc = 0x824FEC04; continue 'dispatch;
            }
            0x824FEC04 => {
    //   block [0x824FEC04..0x824FEC1C)
	// 824FEC04: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 824FEC08: 90A90004  stw r5, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 824FEC0C: 9109000C  stw r8, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 824FEC10: 39660014  addi r11, r6, 0x14
	ctx.r[11].s64 = ctx.r[6].s64 + 20;
	// 824FEC14: 409A0008  bne cr6, 0x824fec1c
	if !ctx.cr[6].eq {
	pc = 0x824FEC1C; continue 'dispatch;
	}
	// 824FEC18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824FEC1C; continue 'dispatch;
            }
            0x824FEC1C => {
    //   block [0x824FEC1C..0x824FEC38)
	// 824FEC1C: 91690008  stw r11, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 824FEC20: 89650020  lbz r11, 0x20(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(32 as u32) ) } as u64;
	// 824FEC24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824FEC28: 419A0010  beq cr6, 0x824fec38
	if ctx.cr[6].eq {
	pc = 0x824FEC38; continue 'dispatch;
	}
	// 824FEC2C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 824FEC30: 39660010  addi r11, r6, 0x10
	ctx.r[11].s64 = ctx.r[6].s64 + 16;
	// 824FEC34: 409A0008  bne cr6, 0x824fec3c
	if !ctx.cr[6].eq {
	pc = 0x824FEC3C; continue 'dispatch;
	}
	pc = 0x824FEC38; continue 'dispatch;
            }
            0x824FEC38 => {
    //   block [0x824FEC38..0x824FEC3C)
	// 824FEC38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824FEC3C; continue 'dispatch;
            }
            0x824FEC3C => {
    //   block [0x824FEC3C..0x824FECBC)
	// 824FEC3C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 824FEC40: 91690034  stw r11, 0x34(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824FECC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824FECC0 size=468
    let mut pc: u32 = 0x824FECC0;
    'dispatch: loop {
        match pc {
            0x824FECC0 => {
    //   block [0x824FECC0..0x824FED1C)
	// 824FECC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824FECC4: 480363DD  bl 0x825350a0
	ctx.lr = 0x824FECC8;
	sub_82535080(ctx, base);
	// 824FECC8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824FECCC: 832D0000  lwz r25, 0(r13)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824FECD0: 3AC00014  li r22, 0x14
	ctx.r[22].s64 = 20;
	// 824FECD4: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 824FECD8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 824FECDC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 824FECE0: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 824FECE4: 7D79B02E  lwzx r11, r25, r22
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 824FECE8: 7CF73B78  mr r23, r7
	ctx.r[23].u64 = ctx.r[7].u64;
	// 824FECEC: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	// 824FECF0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824FECF4: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824FECF8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 824FECFC: 40980020  bge cr6, 0x824fed1c
	if !ctx.cr[6].lt {
	pc = 0x824FED1C; continue 'dispatch;
	}
	// 824FED00: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824FED04: 39294344  addi r9, r9, 0x4344
	ctx.r[9].s64 = ctx.r[9].s64 + 17220;
	// 824FED08: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824FED0C: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 824FED10: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 824FED14: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 824FED18: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x824FED1C; continue 'dispatch;
            }
            0x824FED1C => {
    //   block [0x824FED1C..0x824FEE94)
	// 824FED1C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824FEE98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824FEE98 size=256
    let mut pc: u32 = 0x824FEE98;
    'dispatch: loop {
        match pc {
            0x824FEE98 => {
    //   block [0x824FEE98..0x824FEEE0)
	// 824FEE98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824FEE9C: 4803621D  bl 0x825350b8
	ctx.lr = 0x824FEEA0;
	sub_82535080(ctx, base);
	// 824FEEA0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824FEEA4: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824FEEA8: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 824FEEAC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 824FEEB0: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824FEEB4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824FEEB8: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 824FEEBC: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 824FEEC0: 40980020  bge cr6, 0x824feee0
	if !ctx.cr[6].lt {
	pc = 0x824FEEE0; continue 'dispatch;
	}
	// 824FEEC4: 3C808206  lis r4, -0x7dfa
	ctx.r[4].s64 = -2113536000;
	// 824FEEC8: 38844354  addi r4, r4, 0x4354
	ctx.r[4].s64 = ctx.r[4].s64 + 17236;
	// 824FEECC: 908A0000  stw r4, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 824FEED0: 7C8C42E6  mftb r4, 0x10c
	ctx.r[4].u64 = crate::rt::rdtsc_u64();
	// 824FEED4: 3B8A000C  addi r28, r10, 0xc
	ctx.r[28].s64 = ctx.r[10].s64 + 12;
	// 824FEED8: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 824FEEDC: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	pc = 0x824FEEE0; continue 'dispatch;
            }
            0x824FEEE0 => {
    //   block [0x824FEEE0..0x824FEEF8)
	// 824FEEE0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 824FEEE4: 90A30004  stw r5, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 824FEEE8: 9123000C  stw r9, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 824FEEEC: 39670014  addi r11, r7, 0x14
	ctx.r[11].s64 = ctx.r[7].s64 + 20;
	// 824FEEF0: 409A0008  bne cr6, 0x824feef8
	if !ctx.cr[6].eq {
	pc = 0x824FEEF8; continue 'dispatch;
	}
	// 824FEEF4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824FEEF8; continue 'dispatch;
            }
            0x824FEEF8 => {
    //   block [0x824FEEF8..0x824FEF14)
	// 824FEEF8: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 824FEEFC: 89650020  lbz r11, 0x20(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(32 as u32) ) } as u64;
	// 824FEF00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824FEF04: 419A0010  beq cr6, 0x824fef14
	if ctx.cr[6].eq {
	pc = 0x824FEF14; continue 'dispatch;
	}
	// 824FEF08: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 824FEF0C: 39670010  addi r11, r7, 0x10
	ctx.r[11].s64 = ctx.r[7].s64 + 16;
	// 824FEF10: 409A0008  bne cr6, 0x824fef18
	if !ctx.cr[6].eq {
	pc = 0x824FEF18; continue 'dispatch;
	}
	pc = 0x824FEF14; continue 'dispatch;
            }
            0x824FEF14 => {
    //   block [0x824FEF14..0x824FEF18)
	// 824FEF14: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x824FEF18; continue 'dispatch;
            }
            0x824FEF18 => {
    //   block [0x824FEF18..0x824FEF98)
	// 824FEF18: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 824FEF1C: 91630034  stw r11, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824FEFB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824FEFB8 size=368
    let mut pc: u32 = 0x824FEFB8;
    'dispatch: loop {
        match pc {
            0x824FEFB8 => {
    //   block [0x824FEFB8..0x824FEFE4)
	// 824FEFB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824FEFBC: 48036101  bl 0x825350bc
	ctx.lr = 0x824FEFC0;
	sub_82535080(ctx, base);
	// 824FEFC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824FEFC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824FEFC8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 824FEFCC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 824FEFD0: 395F0EB0  addi r10, r31, 0xeb0
	ctx.r[10].s64 = ctx.r[31].s64 + 3760;
	// 824FEFD4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 824FEFD8: 3BA00064  li r29, 0x64
	ctx.r[29].s64 = 100;
	// 824FEFDC: 90FF0190  stw r7, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[7].u32 ) };
	// 824FEFE0: 90FF0EA0  stw r7, 0xea0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(3744 as u32), ctx.r[7].u32 ) };
	pc = 0x824FEFE4; continue 'dispatch;
            }
            0x824FEFE4 => {
    //   block [0x824FEFE4..0x824FEFE8)
	// 824FEFE4: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	pc = 0x824FEFE8; continue 'dispatch;
            }
            0x824FEFE8 => {
    //   block [0x824FEFE8..0x824FF020)
	// 824FEFE8: 813F1E30  lwz r9, 0x1e30(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7728 as u32) ) } as u64;
	// 824FEFEC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 824FEFF0: 419A0030  beq cr6, 0x824ff020
	if ctx.cr[6].eq {
	pc = 0x824FF020; continue 'dispatch;
	}
	// 824FEFF4: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 824FEFF8: 9BA90002  stb r29, 2(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(2 as u32), ctx.r[29].u8 ) };
	// 824FEFFC: 813F1E34  lwz r9, 0x1e34(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7732 as u32) ) } as u64;
	// 824FF000: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 824FF004: 9BA90002  stb r29, 2(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(2 as u32), ctx.r[29].u8 ) };
	// 824FF008: 813F1E38  lwz r9, 0x1e38(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7736 as u32) ) } as u64;
	// 824FF00C: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 824FF010: 9BA90002  stb r29, 2(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(2 as u32), ctx.r[29].u8 ) };
	// 824FF014: 813F1E3C  lwz r9, 0x1e3c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7740 as u32) ) } as u64;
	// 824FF018: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 824FF01C: 9BA90002  stb r29, 2(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(2 as u32), ctx.r[29].u8 ) };
	pc = 0x824FF020; continue 'dispatch;
            }
            0x824FF020 => {
    //   block [0x824FF020..0x824FF0EC)
	// 824FF020: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 824FF024: 9BCAF2F0  stb r30, -0xd10(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(-3344 as u32), ctx.r[30].u8 ) };
	// 824FF028: 9BCA0000  stb r30, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[30].u8 ) };
	// 824FF02C: 396B0003  addi r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 + 3;
	// 824FF030: 9BCAF6F0  stb r30, -0x910(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(-2320 as u32), ctx.r[30].u8 ) };
	// 824FF034: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 824FF038: 9BCA0400  stb r30, 0x400(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(1024 as u32), ctx.r[30].u8 ) };
	// 824FF03C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824FF040: 409AFFA8  bne cr6, 0x824fefe8
	if !ctx.cr[6].eq {
	pc = 0x824FEFE8; continue 'dispatch;
	}
	// 824FF044: 2F0B0C00  cmpwi cr6, r11, 0xc00
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3072, &mut ctx.xer);
	// 824FF048: 4198FF9C  blt cr6, 0x824fefe4
	if ctx.cr[6].lt {
	pc = 0x824FEFE4; continue 'dispatch;
	}
	// 824FF04C: 3D208250  lis r9, -0x7db0
	ctx.r[9].s64 = -2108686336;
	// 824FF050: 3D408250  lis r10, -0x7db0
	ctx.r[10].s64 = -2108686336;
	// 824FF054: 3D608250  lis r11, -0x7db0
	ctx.r[11].s64 = -2108686336;
	// 824FF058: 3D008250  lis r8, -0x7db0
	ctx.r[8].s64 = -2108686336;
	// 824FF05C: 38C90B28  addi r6, r9, 0xb28
	ctx.r[6].s64 = ctx.r[9].s64 + 2856;
	// 824FF060: 38AA0B20  addi r5, r10, 0xb20
	ctx.r[5].s64 = ctx.r[10].s64 + 2848;
	// 824FF064: 388B0B30  addi r4, r11, 0xb30
	ctx.r[4].s64 = ctx.r[11].s64 + 2864;
	// 824FF068: 39080B38  addi r8, r8, 0xb38
	ctx.r[8].s64 = ctx.r[8].s64 + 2872;
	// 824FF06C: 3D208250  lis r9, -0x7db0
	ctx.r[9].s64 = -2108686336;
	// 824FF070: 3D408250  lis r10, -0x7db0
	ctx.r[10].s64 = -2108686336;
	// 824FF074: 90DF09A4  stw r6, 0x9a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2468 as u32), ctx.r[6].u32 ) };
	// 824FF078: 3D608250  lis r11, -0x7db0
	ctx.r[11].s64 = -2108686336;
	// 824FF07C: 90BF09A8  stw r5, 0x9a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2472 as u32), ctx.r[5].u32 ) };
	// 824FF080: 3929EF98  addi r9, r9, -0x1068
	ctx.r[9].s64 = ctx.r[9].s64 + -4200;
	// 824FF084: 909F09AC  stw r4, 0x9ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2476 as u32), ctx.r[4].u32 ) };
	// 824FF088: 394AEFA8  addi r10, r10, -0x1058
	ctx.r[10].s64 = ctx.r[10].s64 + -4184;
	// 824FF08C: 911F09A0  stw r8, 0x9a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2464 as u32), ctx.r[8].u32 ) };
	// 824FF090: 396BEFB0  addi r11, r11, -0x1050
	ctx.r[11].s64 = ctx.r[11].s64 + -4176;
	// 824FF094: 9BDF09B0  stb r30, 0x9b0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(2480 as u32), ctx.r[30].u8 ) };
	// 824FF098: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824FF09C: 98FF09B1  stb r7, 0x9b1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(2481 as u32), ctx.r[7].u8 ) };
	// 824FF0A0: 93DF16B8  stw r30, 0x16b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5816 as u32), ctx.r[30].u32 ) };
	// 824FF0A4: 913F16B0  stw r9, 0x16b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5808 as u32), ctx.r[9].u32 ) };
	// 824FF0A8: 915F16B4  stw r10, 0x16b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5812 as u32), ctx.r[10].u32 ) };
	// 824FF0AC: 93DF16BC  stw r30, 0x16bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5820 as u32), ctx.r[30].u32 ) };
	// 824FF0B0: 93DF16C0  stw r30, 0x16c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5824 as u32), ctx.r[30].u32 ) };
	// 824FF0B4: 93DF16C4  stw r30, 0x16c4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5828 as u32), ctx.r[30].u32 ) };
	// 824FF0B8: 93DF16C8  stw r30, 0x16c8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5832 as u32), ctx.r[30].u32 ) };
	// 824FF0BC: 93DF16CC  stw r30, 0x16cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5836 as u32), ctx.r[30].u32 ) };
	// 824FF0C0: 93DF16D8  stw r30, 0x16d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5848 as u32), ctx.r[30].u32 ) };
	// 824FF0C4: 93DF16D0  stw r30, 0x16d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5840 as u32), ctx.r[30].u32 ) };
	// 824FF0C8: 93DF16D4  stw r30, 0x16d4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5844 as u32), ctx.r[30].u32 ) };
	// 824FF0CC: 917F16DC  stw r11, 0x16dc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5852 as u32), ctx.r[11].u32 ) };
	// 824FF0D0: 93DF16F0  stw r30, 0x16f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(5872 as u32), ctx.r[30].u32 ) };
	// 824FF0D4: 4802A665  bl 0x82529738
	ctx.lr = 0x824FF0D8;
	sub_82529738(ctx, base);
	// 824FF0D8: 9BDF1E20  stb r30, 0x1e20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(7712 as u32), ctx.r[30].u8 ) };
	// 824FF0DC: 817F1E38  lwz r11, 0x1e38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7736 as u32) ) } as u64;
	// 824FF0E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824FF0E4: 419A003C  beq cr6, 0x824ff120
	if ctx.cr[6].eq {
	pc = 0x824FF120; continue 'dispatch;
	}
	// 824FF0E8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x824FF0EC; continue 'dispatch;
            }
            0x824FF0EC => {
    //   block [0x824FF0EC..0x824FF0F0)
	// 824FF0EC: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	pc = 0x824FF0F0; continue 'dispatch;
            }
            0x824FF0F0 => {
    //   block [0x824FF0F0..0x824FF120)
	// 824FF0F0: 813F1E38  lwz r9, 0x1e38(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7736 as u32) ) } as u64;
	// 824FF0F4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824FF0F8: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 824FF0FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824FF100: 9BA90002  stb r29, 2(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(2 as u32), ctx.r[29].u8 ) };
	// 824FF104: 813F1E3C  lwz r9, 0x1e3c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7740 as u32) ) } as u64;
	// 824FF108: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 824FF10C: 396B0003  addi r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 + 3;
	// 824FF110: 9BA90002  stb r29, 2(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(2 as u32), ctx.r[29].u8 ) };
	// 824FF114: 409AFFDC  bne cr6, 0x824ff0f0
	if !ctx.cr[6].eq {
	pc = 0x824FF0F0; continue 'dispatch;
	}
	// 824FF118: 2F0B0C00  cmpwi cr6, r11, 0xc00
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3072, &mut ctx.xer);
	// 824FF11C: 4198FFD0  blt cr6, 0x824ff0ec
	if ctx.cr[6].lt {
	pc = 0x824FF0EC; continue 'dispatch;
	}
	pc = 0x824FF120; continue 'dispatch;
            }
            0x824FF120 => {
    //   block [0x824FF120..0x824FF128)
	// 824FF120: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824FF124: 48035FE8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824FF128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x824FF128 size=8
    let mut pc: u32 = 0x824FF128;
    'dispatch: loop {
        match pc {
            0x824FF128 => {
    //   block [0x824FF128..0x824FF130)
	// 824FF128: 98831E23  stb r4, 0x1e23(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7715 as u32), ctx.r[4].u8 ) };
	// 824FF12C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824FF130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824FF130 size=244
    let mut pc: u32 = 0x824FF130;
    'dispatch: loop {
        match pc {
            0x824FF130 => {
    //   block [0x824FF130..0x824FF164)
	// 824FF130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824FF134: 48035F81  bl 0x825350b4
	ctx.lr = 0x824FF138;
	sub_82535080(ctx, base);
	// 824FF138: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824FF13C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 824FF140: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824FF144: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 824FF148: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 824FF14C: A17D0004  lhz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824FF150: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824FF154: 419A0010  beq cr6, 0x824ff164
	if ctx.cr[6].eq {
	pc = 0x824FF164; continue 'dispatch;
	}
	// 824FF158: A17D0006  lhz r11, 6(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(6 as u32) ) } as u64;
	// 824FF15C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824FF160: B17D0006  sth r11, 6(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	pc = 0x824FF164; continue 'dispatch;
            }
            0x824FF164 => {
    //   block [0x824FF164..0x824FF1B0)
	// 824FF164: 576B1838  slwi r11, r27, 3
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824FF168: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 824FF16C: 396B0003  addi r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 + 3;
	// 824FF170: 557F103A  slwi r31, r11, 2
	ctx.r[31].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 824FF174: 7C7FF02E  lwzx r3, r31, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824FF178: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824FF17C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824FF180: 419A0030  beq cr6, 0x824ff1b0
	if ctx.cr[6].eq {
	pc = 0x824FF1B0; continue 'dispatch;
	}
	// 824FF184: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824FF188: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824FF18C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824FF190: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824FF194: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824FF198: 409A0018  bne cr6, 0x824ff1b0
	if !ctx.cr[6].eq {
	pc = 0x824FF1B0; continue 'dispatch;
	}
	// 824FF19C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824FF1A0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824FF1A4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824FF1A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824FF1AC: 4E800421  bctrl
	ctx.lr = 0x824FF1B0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824FF1B0 => {
    //   block [0x824FF1B0..0x824FF1CC)
	// 824FF1B0: 7FBFF12E  stwx r29, r31, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32), ctx.r[29].u32) };
	// 824FF1B4: A17D0004  lhz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 824FF1B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824FF1BC: 419A0010  beq cr6, 0x824ff1cc
	if ctx.cr[6].eq {
	pc = 0x824FF1CC; continue 'dispatch;
	}
	// 824FF1C0: A17D0006  lhz r11, 6(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(6 as u32) ) } as u64;
	// 824FF1C4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824FF1C8: B17D0006  sth r11, 6(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	pc = 0x824FF1CC; continue 'dispatch;
            }
            0x824FF1CC => {
    //   block [0x824FF1CC..0x824FF218)
	// 824FF1CC: 578B1838  slwi r11, r28, 3
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824FF1D0: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 824FF1D4: 396B0003  addi r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 + 3;
	// 824FF1D8: 557F103A  slwi r31, r11, 2
	ctx.r[31].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 824FF1DC: 7C7FF02E  lwzx r3, r31, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824FF1E0: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824FF1E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824FF1E8: 419A0030  beq cr6, 0x824ff218
	if ctx.cr[6].eq {
	pc = 0x824FF218; continue 'dispatch;
	}
	// 824FF1EC: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824FF1F0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824FF1F4: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824FF1F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824FF1FC: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824FF200: 409A0018  bne cr6, 0x824ff218
	if !ctx.cr[6].eq {
	pc = 0x824FF218; continue 'dispatch;
	}
	// 824FF204: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824FF208: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824FF20C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824FF210: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824FF214: 4E800421  bctrl
	ctx.lr = 0x824FF218;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824FF218 => {
    //   block [0x824FF218..0x824FF224)
	// 824FF218: 7FBFF12E  stwx r29, r31, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32), ctx.r[29].u32) };
	// 824FF21C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 824FF220: 48035EE4  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824FF228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824FF228 size=248
    let mut pc: u32 = 0x824FF228;
    'dispatch: loop {
        match pc {
            0x824FF228 => {
    //   block [0x824FF228..0x824FF254)
	// 824FF228: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824FF22C: 48035E8D  bl 0x825350b8
	ctx.lr = 0x824FF230;
	sub_82535080(ctx, base);
	// 824FF230: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824FF234: 54AB2834  slwi r11, r5, 5
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824FF238: 39450003  addi r10, r5, 3
	ctx.r[10].s64 = ctx.r[5].s64 + 3;
	// 824FF23C: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 824FF240: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824FF244: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 824FF248: 3BAB000C  addi r29, r11, 0xc
	ctx.r[29].s64 = ctx.r[11].s64 + 12;
	// 824FF24C: 7FCA1A14  add r30, r10, r3
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 824FF250: 3B800008  li r28, 8
	ctx.r[28].s64 = 8;
	pc = 0x824FF254; continue 'dispatch;
            }
            0x824FF254 => {
    //   block [0x824FF254..0x824FF26C)
	// 824FF254: A17F0004  lhz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824FF258: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824FF25C: 419A0010  beq cr6, 0x824ff26c
	if ctx.cr[6].eq {
	pc = 0x824FF26C; continue 'dispatch;
	}
	// 824FF260: A17F0006  lhz r11, 6(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 824FF264: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824FF268: B17F0006  sth r11, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	pc = 0x824FF26C; continue 'dispatch;
            }
            0x824FF26C => {
    //   block [0x824FF26C..0x824FF2A8)
	// 824FF26C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 824FF270: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824FF274: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824FF278: 419A0030  beq cr6, 0x824ff2a8
	if ctx.cr[6].eq {
	pc = 0x824FF2A8; continue 'dispatch;
	}
	// 824FF27C: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824FF280: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824FF284: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824FF288: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824FF28C: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824FF290: 409A0018  bne cr6, 0x824ff2a8
	if !ctx.cr[6].eq {
	pc = 0x824FF2A8; continue 'dispatch;
	}
	// 824FF294: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824FF298: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824FF29C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824FF2A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824FF2A4: 4E800421  bctrl
	ctx.lr = 0x824FF2A8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824FF2A8 => {
    //   block [0x824FF2A8..0x824FF2C4)
	// 824FF2A8: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 824FF2AC: A17F0004  lhz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824FF2B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824FF2B4: 419A0010  beq cr6, 0x824ff2c4
	if ctx.cr[6].eq {
	pc = 0x824FF2C4; continue 'dispatch;
	}
	// 824FF2B8: A17F0006  lhz r11, 6(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 824FF2BC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824FF2C0: B17F0006  sth r11, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	pc = 0x824FF2C4; continue 'dispatch;
            }
            0x824FF2C4 => {
    //   block [0x824FF2C4..0x824FF300)
	// 824FF2C4: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 824FF2C8: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824FF2CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824FF2D0: 419A0030  beq cr6, 0x824ff300
	if ctx.cr[6].eq {
	pc = 0x824FF300; continue 'dispatch;
	}
	// 824FF2D4: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824FF2D8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824FF2DC: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824FF2E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824FF2E4: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824FF2E8: 409A0018  bne cr6, 0x824ff300
	if !ctx.cr[6].eq {
	pc = 0x824FF300; continue 'dispatch;
	}
	// 824FF2EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824FF2F0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824FF2F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824FF2F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824FF2FC: 4E800421  bctrl
	ctx.lr = 0x824FF300;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824FF300 => {
    //   block [0x824FF300..0x824FF320)
	// 824FF300: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 824FF304: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 824FF308: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 824FF30C: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 824FF310: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 824FF314: 409AFF40  bne cr6, 0x824ff254
	if !ctx.cr[6].eq {
	pc = 0x824FF254; continue 'dispatch;
	}
	// 824FF318: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 824FF31C: 48035DEC  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824FF320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824FF320 size=108
    let mut pc: u32 = 0x824FF320;
    'dispatch: loop {
        match pc {
            0x824FF320 => {
    //   block [0x824FF320..0x824FF384)
	// 824FF320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824FF324: 48035D99  bl 0x825350bc
	ctx.lr = 0x824FF328;
	sub_82535080(ctx, base);
	// 824FF328: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824FF32C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824FF330: 809F1E30  lwz r4, 0x1e30(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7728 as u32) ) } as u64;
	// 824FF334: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 824FF338: 419A004C  beq cr6, 0x824ff384
	if ctx.cr[6].eq {
	pc = 0x824FF384; continue 'dispatch;
	}
	// 824FF33C: 83AD0000  lwz r29, 0(r13)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824FF340: 3BC00010  li r30, 0x10
	ctx.r[30].s64 = 16;
	// 824FF344: 7C7EE82E  lwzx r3, r30, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824FF348: 4BF64F79  bl 0x824642c0
	ctx.lr = 0x824FF34C;
	sub_824642C0(ctx, base);
	// 824FF34C: 809F1E34  lwz r4, 0x1e34(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7732 as u32) ) } as u64;
	// 824FF350: 7C7EE82E  lwzx r3, r30, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824FF354: 4BF64F6D  bl 0x824642c0
	ctx.lr = 0x824FF358;
	sub_824642C0(ctx, base);
	// 824FF358: 809F1E38  lwz r4, 0x1e38(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7736 as u32) ) } as u64;
	// 824FF35C: 7C7EE82E  lwzx r3, r30, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824FF360: 4BF64F61  bl 0x824642c0
	ctx.lr = 0x824FF364;
	sub_824642C0(ctx, base);
	// 824FF364: 809F1E3C  lwz r4, 0x1e3c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7740 as u32) ) } as u64;
	// 824FF368: 7C7EE82E  lwzx r3, r30, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 824FF36C: 4BF64F55  bl 0x824642c0
	ctx.lr = 0x824FF370;
	sub_824642C0(ctx, base);
	// 824FF370: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824FF374: 917F1E30  stw r11, 0x1e30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7728 as u32), ctx.r[11].u32 ) };
	// 824FF378: 917F1E34  stw r11, 0x1e34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7732 as u32), ctx.r[11].u32 ) };
	// 824FF37C: 917F1E38  stw r11, 0x1e38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7736 as u32), ctx.r[11].u32 ) };
	// 824FF380: 917F1E3C  stw r11, 0x1e3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7740 as u32), ctx.r[11].u32 ) };
	pc = 0x824FF384; continue 'dispatch;
            }
            0x824FF384 => {
    //   block [0x824FF384..0x824FF38C)
	// 824FF384: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824FF388: 48035D84  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824FF390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824FF390 size=540
    let mut pc: u32 = 0x824FF390;
    'dispatch: loop {
        match pc {
            0x824FF390 => {
    //   block [0x824FF390..0x824FF3E4)
	// 824FF390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824FF394: 48035CED  bl 0x82535080
	ctx.lr = 0x824FF398;
	sub_82535080(ctx, base);
	// 824FF398: 9421FB00  stwu r1, -0x500(r1)
	ea = ctx.r[1].u32.wrapping_add(-1280 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824FF39C: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 824FF3A0: 83C10554  lwz r30, 0x554(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1364 as u32) ) } as u64;
	// 824FF3A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 824FF3A8: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 824FF3AC: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 824FF3B0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 824FF3B4: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 824FF3B8: 99741E20  stb r11, 0x1e20(r20)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[20].u32.wrapping_add(7712 as u32), ctx.r[11].u8 ) };
	// 824FF3BC: 7CF53B78  mr r21, r7
	ctx.r[21].u64 = ctx.r[7].u64;
	// 824FF3C0: 81741E28  lwz r11, 0x1e28(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(7720 as u32) ) } as u64;
	// 824FF3C4: 7D0E4378  mr r14, r8
	ctx.r[14].u64 = ctx.r[8].u64;
	// 824FF3C8: 92E10524  stw r23, 0x524(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1316 as u32), ctx.r[23].u32 ) };
	// 824FF3CC: 7D535378  mr r19, r10
	ctx.r[19].u64 = ctx.r[10].u64;
	// 824FF3D0: 93210544  stw r25, 0x544(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1348 as u32), ctx.r[25].u32 ) };
	// 824FF3D4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 824FF3D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824FF3DC: 40990094  ble cr6, 0x824ff470
	if !ctx.cr[6].gt {
	pc = 0x824FF470; continue 'dispatch;
	}
	// 824FF3E0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x824FF3E4; continue 'dispatch;
            }
            0x824FF3E4 => {
    //   block [0x824FF3E4..0x824FF424)
	// 824FF3E4: 81741E24  lwz r11, 0x1e24(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(7716 as u32) ) } as u64;
	// 824FF3E8: 7FEBE214  add r31, r11, r28
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 824FF3EC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824FF3F0: 7F0BD000  cmpw cr6, r11, r26
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[26].s32, &mut ctx.xer);
	// 824FF3F4: 409A0030  bne cr6, 0x824ff424
	if !ctx.cr[6].eq {
	pc = 0x824FF424; continue 'dispatch;
	}
	// 824FF3F8: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 824FF3FC: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824FF400: 7E6A9B78  mr r10, r19
	ctx.r[10].u64 = ctx.r[19].u64;
	// 824FF404: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 824FF408: 7DC87378  mr r8, r14
	ctx.r[8].u64 = ctx.r[14].u64;
	// 824FF40C: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	// 824FF410: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 824FF414: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 824FF418: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824FF41C: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 824FF420: 4BFFFF71  bl 0x824ff390
	ctx.lr = 0x824FF424;
	sub_824FF390(ctx, base);
	pc = 0x824FF424; continue 'dispatch;
            }
            0x824FF424 => {
    //   block [0x824FF424..0x824FF45C)
	// 824FF424: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 824FF428: 7F0BA800  cmpw cr6, r11, r21
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[21].s32, &mut ctx.xer);
	// 824FF42C: 409A0030  bne cr6, 0x824ff45c
	if !ctx.cr[6].eq {
	pc = 0x824FF45C; continue 'dispatch;
	}
	// 824FF430: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 824FF434: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824FF438: 7E6A9B78  mr r10, r19
	ctx.r[10].u64 = ctx.r[19].u64;
	// 824FF43C: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 824FF440: 7DC87378  mr r8, r14
	ctx.r[8].u64 = ctx.r[14].u64;
	// 824FF444: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 824FF448: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 824FF44C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 824FF450: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 824FF454: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 824FF458: 4BFFFF39  bl 0x824ff390
	ctx.lr = 0x824FF45C;
	sub_824FF390(ctx, base);
	pc = 0x824FF45C; continue 'dispatch;
            }
            0x824FF45C => {
    //   block [0x824FF45C..0x824FF470)
	// 824FF45C: 81741E28  lwz r11, 0x1e28(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(7720 as u32) ) } as u64;
	// 824FF460: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 824FF464: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 824FF468: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824FF46C: 4198FF78  blt cr6, 0x824ff3e4
	if ctx.cr[6].lt {
	pc = 0x824FF3E4; continue 'dispatch;
	}
	pc = 0x824FF470; continue 'dispatch;
            }
            0x824FF470 => {
    //   block [0x824FF470..0x824FF498)
	// 824FF470: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 824FF474: 7EB0AB78  mr r16, r21
	ctx.r[16].u64 = ctx.r[21].u64;
	// 824FF478: 393A0001  addi r9, r26, 1
	ctx.r[9].s64 = ctx.r[26].s64 + 1;
	// 824FF47C: 39F50001  addi r15, r21, 1
	ctx.r[15].s64 = ctx.r[21].s64 + 1;
	// 824FF480: 7FD6F378  mr r22, r30
	ctx.r[22].u64 = ctx.r[30].u64;
	// 824FF484: 2F1AFFFF  cmpwi cr6, r26, -1
	ctx.cr[6].compare_i32(ctx.r[26].s32, -1, &mut ctx.xer);
	// 824FF488: 409A0010  bne cr6, 0x824ff498
	if !ctx.cr[6].eq {
	pc = 0x824FF498; continue 'dispatch;
	}
	// 824FF48C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 824FF490: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 824FF494: 3ADE0001  addi r22, r30, 1
	ctx.r[22].s64 = ctx.r[30].s64 + 1;
	pc = 0x824FF498; continue 'dispatch;
            }
            0x824FF498 => {
    //   block [0x824FF498..0x824FF4AC)
	// 824FF498: 2F15FFFF  cmpwi cr6, r21, -1
	ctx.cr[6].compare_i32(ctx.r[21].s32, -1, &mut ctx.xer);
	// 824FF49C: 409A0010  bne cr6, 0x824ff4ac
	if !ctx.cr[6].eq {
	pc = 0x824FF4AC; continue 'dispatch;
	}
	// 824FF4A0: 3A000001  li r16, 1
	ctx.r[16].s64 = 1;
	// 824FF4A4: 39E00020  li r15, 0x20
	ctx.r[15].s64 = 32;
	// 824FF4A8: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	pc = 0x824FF4AC; continue 'dispatch;
            }
            0x824FF4AC => {
    //   block [0x824FF4AC..0x824FF4DC)
	// 824FF4AC: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 824FF4B0: 409800F4  bge cr6, 0x824ff5a4
	if !ctx.cr[6].lt {
	pc = 0x824FF5A4; continue 'dispatch;
	}
	// 824FF4B4: 554B2834  slwi r11, r10, 5
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824FF4B8: 7E2A4850  subf r17, r10, r9
	ctx.r[17].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 824FF4BC: 7D4B8214  add r10, r11, r16
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[16].u64;
	// 824FF4C0: 7F0BEA14  add r24, r11, r29
	ctx.r[24].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 824FF4C4: 554B083C  slwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824FF4C8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 824FF4CC: 7D6B9A14  add r11, r11, r19
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[19].u64;
	// 824FF4D0: 3A4B0001  addi r18, r11, 1
	ctx.r[18].s64 = ctx.r[11].s64 + 1;
	// 824FF4D4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824FF4D8: 3B2B4380  addi r25, r11, 0x4380
	ctx.r[25].s64 = ctx.r[11].s64 + 17280;
	pc = 0x824FF4DC; continue 'dispatch;
            }
            0x824FF4DC => {
    //   block [0x824FF4DC..0x824FF4F0)
	// 824FF4DC: 7E1B8378  mr r27, r16
	ctx.r[27].u64 = ctx.r[16].u64;
	// 824FF4E0: 7F107800  cmpw cr6, r16, r15
	ctx.cr[6].compare_i32(ctx.r[16].s32, ctx.r[15].s32, &mut ctx.xer);
	// 824FF4E4: 409800AC  bge cr6, 0x824ff590
	if !ctx.cr[6].lt {
	pc = 0x824FF590; continue 'dispatch;
	}
	// 824FF4E8: 56F7063E  clrlwi r23, r23, 0x18
	ctx.r[23].u64 = ctx.r[23].u32 as u64 & 0x000000FFu64;
	// 824FF4EC: 7E5F9378  mr r31, r18
	ctx.r[31].u64 = ctx.r[18].u64;
	pc = 0x824FF4F0; continue 'dispatch;
            }
            0x824FF4F0 => {
    //   block [0x824FF4F0..0x824FF56C)
	// 824FF4F0: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 824FF4F4: 7EF8D9AE  stbx r23, r24, r27
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[24].u32.wrapping_add(ctx.r[27].u32), ctx.r[23].u8) };
	// 824FF4F8: 419A0084  beq cr6, 0x824ff57c
	if ctx.cr[6].eq {
	pc = 0x824FF57C; continue 'dispatch;
	}
	// 824FF4FC: 89741E23  lbz r11, 0x1e23(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[20].u32.wrapping_add(7715 as u32) ) } as u64;
	// 824FF500: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824FF504: 419A0068  beq cr6, 0x824ff56c
	if ctx.cr[6].eq {
	pc = 0x824FF56C; continue 'dispatch;
	}
	// 824FF508: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 824FF50C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 824FF510: 7F165800  cmpw cr6, r22, r11
	ctx.cr[6].compare_i32(ctx.r[22].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824FF514: 40990058  ble cr6, 0x824ff56c
	if !ctx.cr[6].gt {
	pc = 0x824FF56C; continue 'dispatch;
	}
	// 824FF518: 897FFFFF  lbz r11, -1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-1 as u32) ) } as u64;
	// 824FF51C: 7D630774  extsb r3, r11
	ctx.r[3].s64 = ctx.r[11].s8 as i64;
	// 824FF520: 480292F1  bl 0x82528810
	ctx.lr = 0x824FF524;
	sub_82528810(ctx, base);
	// 824FF524: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824FF528: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 824FF52C: 7D630774  extsb r3, r11
	ctx.r[3].s64 = ctx.r[11].s8 as i64;
	// 824FF530: 480292E1  bl 0x82528810
	ctx.lr = 0x824FF534;
	sub_82528810(ctx, base);
	// 824FF534: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 824FF538: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 824FF53C: 480292D5  bl 0x82528810
	ctx.lr = 0x824FF540;
	sub_82528810(ctx, base);
	// 824FF540: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 824FF544: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 824FF548: 480292C9  bl 0x82528810
	ctx.lr = 0x824FF54C;
	sub_82528810(ctx, base);
	// 824FF54C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 824FF550: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 824FF554: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 824FF558: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 824FF55C: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 824FF560: 388003E8  li r4, 0x3e8
	ctx.r[4].s64 = 1000;
	// 824FF564: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 824FF568: 4BF6A9D9  bl 0x82469f40
	ctx.lr = 0x824FF56C;
	sub_82469F40(ctx, base);
	pc = 0x824FF56C; continue 'dispatch;
            }
            0x824FF56C => {
    //   block [0x824FF56C..0x824FF57C)
	// 824FF56C: 81210544  lwz r9, 0x544(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1348 as u32) ) } as u64;
	// 824FF570: 9ADF0001  stb r22, 1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1 as u32), ctx.r[22].u8 ) };
	// 824FF574: 99DFFFFF  stb r14, -1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(-1 as u32), ctx.r[14].u8 ) };
	// 824FF578: 993F0000  stb r9, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	pc = 0x824FF57C; continue 'dispatch;
            }
            0x824FF57C => {
    //   block [0x824FF57C..0x824FF590)
	// 824FF57C: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 824FF580: 3BFF0003  addi r31, r31, 3
	ctx.r[31].s64 = ctx.r[31].s64 + 3;
	// 824FF584: 7F1B7800  cmpw cr6, r27, r15
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[15].s32, &mut ctx.xer);
	// 824FF588: 4198FF68  blt cr6, 0x824ff4f0
	if ctx.cr[6].lt {
	pc = 0x824FF4F0; continue 'dispatch;
	}
	// 824FF58C: 82E10524  lwz r23, 0x524(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1316 as u32) ) } as u64;
	pc = 0x824FF590; continue 'dispatch;
            }
            0x824FF590 => {
    //   block [0x824FF590..0x824FF5A4)
	// 824FF590: 3A31FFFF  addi r17, r17, -1
	ctx.r[17].s64 = ctx.r[17].s64 + -1;
	// 824FF594: 3A520060  addi r18, r18, 0x60
	ctx.r[18].s64 = ctx.r[18].s64 + 96;
	// 824FF598: 3B180020  addi r24, r24, 0x20
	ctx.r[24].s64 = ctx.r[24].s64 + 32;
	// 824FF59C: 2B110000  cmplwi cr6, r17, 0
	ctx.cr[6].compare_u32(ctx.r[17].u32, 0 as u32, &mut ctx.xer);
	// 824FF5A0: 409AFF3C  bne cr6, 0x824ff4dc
	if !ctx.cr[6].eq {
	pc = 0x824FF4DC; continue 'dispatch;
	}
	pc = 0x824FF5A4; continue 'dispatch;
            }
            0x824FF5A4 => {
    //   block [0x824FF5A4..0x824FF5AC)
	// 824FF5A4: 38210500  addi r1, r1, 0x500
	ctx.r[1].s64 = ctx.r[1].s64 + 1280;
	// 824FF5A8: 48035B28  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824FF5B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824FF5B0 size=140
    let mut pc: u32 = 0x824FF5B0;
    'dispatch: loop {
        match pc {
            0x824FF5B0 => {
    //   block [0x824FF5B0..0x824FF5FC)
	// 824FF5B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824FF5B4: 48035B01  bl 0x825350b4
	ctx.lr = 0x824FF5B8;
	sub_82535080(ctx, base);
	// 824FF5B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824FF5BC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 824FF5C0: 39450044  addi r10, r5, 0x44
	ctx.r[10].s64 = ctx.r[5].s64 + 68;
	// 824FF5C4: 397D0044  addi r11, r29, 0x44
	ctx.r[11].s64 = ctx.r[29].s64 + 68;
	// 824FF5C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824FF5CC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824FF5D0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 824FF5D4: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 824FF5D8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 824FF5DC: 7D2BF82E  lwzx r9, r11, r31
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 824FF5E0: 7D4AF82E  lwzx r10, r10, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 824FF5E4: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 824FF5E8: 7D4BF92E  stwx r10, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[10].u32) };
	// 824FF5EC: 817F1E28  lwz r11, 0x1e28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7720 as u32) ) } as u64;
	// 824FF5F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824FF5F4: 40990040  ble cr6, 0x824ff634
	if !ctx.cr[6].gt {
	pc = 0x824FF634; continue 'dispatch;
	}
	// 824FF5F8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x824FF5FC; continue 'dispatch;
            }
            0x824FF5FC => {
    //   block [0x824FF5FC..0x824FF620)
	// 824FF5FC: 817F1E24  lwz r11, 0x1e24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7716 as u32) ) } as u64;
	// 824FF600: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 824FF604: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 824FF608: 7F05E800  cmpw cr6, r5, r29
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[29].s32, &mut ctx.xer);
	// 824FF60C: 409A0014  bne cr6, 0x824ff620
	if !ctx.cr[6].eq {
	pc = 0x824FF620; continue 'dispatch;
	}
	// 824FF610: 38DB0001  addi r6, r27, 1
	ctx.r[6].s64 = ctx.r[27].s64 + 1;
	// 824FF614: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824FF618: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824FF61C: 4BFFFF95  bl 0x824ff5b0
	ctx.lr = 0x824FF620;
	sub_824FF5B0(ctx, base);
	pc = 0x824FF620; continue 'dispatch;
            }
            0x824FF620 => {
    //   block [0x824FF620..0x824FF634)
	// 824FF620: 817F1E28  lwz r11, 0x1e28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7720 as u32) ) } as u64;
	// 824FF624: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 824FF628: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 824FF62C: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 824FF630: 4198FFCC  blt cr6, 0x824ff5fc
	if ctx.cr[6].lt {
	pc = 0x824FF5FC; continue 'dispatch;
	}
	pc = 0x824FF634; continue 'dispatch;
            }
            0x824FF634 => {
    //   block [0x824FF634..0x824FF63C)
	// 824FF634: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 824FF638: 48035ACC  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824FF640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x824FF640 size=1220
    let mut pc: u32 = 0x824FF640;
    'dispatch: loop {
        match pc {
            0x824FF640 => {
    //   block [0x824FF640..0x824FF6B0)
	// 824FF640: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 824FF644: C0040008  lfs f0, 8(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824FF648: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 824FF64C: D0031E44  stfs f0, 0x1e44(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(7748 as u32), tmp.u32 ) };
	// 824FF650: 39631C60  addi r11, r3, 0x1c60
	ctx.r[11].s64 = ctx.r[3].s64 + 7264;
	// 824FF654: C004000C  lfs f0, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824FF658: D0031E40  stfs f0, 0x1e40(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(7744 as u32), tmp.u32 ) };
	// 824FF65C: 8924001B  lbz r9, 0x1b(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(27 as u32) ) } as u64;
	// 824FF660: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824FF664: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 824FF668: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824FF66C: 992B003A  stb r9, 0x3a(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(58 as u32), ctx.r[9].u8 ) };
	// 824FF670: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 824FF674: C00ABFFC  lfs f0, -0x4004(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824FF678: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 824FF67C: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824FF680: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 824FF684: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824FF688: D1AB0004  stfs f13, 4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 824FF68C: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824FF690: D1AB000C  stfs f13, 0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 824FF694: 89440019  lbz r10, 0x19(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(25 as u32) ) } as u64;
	// 824FF698: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824FF69C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 824FF6A0: C10A24DC  lfs f8, 0x24dc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9436 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 824FF6A4: 419A000C  beq cr6, 0x824ff6b0
	if ctx.cr[6].eq {
	pc = 0x824FF6B0; continue 'dispatch;
	}
	// 824FF6A8: EDA00232  fmuls f13, f0, f8
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[8].f64) as f32) as f64);
	// 824FF6AC: D1AB000C  stfs f13, 0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x824FF6B0; continue 'dispatch;
            }
            0x824FF6B0 => {
    //   block [0x824FF6B0..0x824FF6D4)
	// 824FF6B0: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824FF6B4: D1AB0008  stfs f13, 8(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 824FF6B8: 8944001A  lbz r10, 0x1a(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(26 as u32) ) } as u64;
	// 824FF6BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824FF6C0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 824FF6C4: C12A2074  lfs f9, 0x2074(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8308 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 824FF6C8: 419A000C  beq cr6, 0x824ff6d4
	if ctx.cr[6].eq {
	pc = 0x824FF6D4; continue 'dispatch;
	}
	// 824FF6CC: EC000272  fmuls f0, f0, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[9].f64) as f32) as f64);
	// 824FF6D0: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x824FF6D4; continue 'dispatch;
            }
            0x824FF6D4 => {
    //   block [0x824FF6D4..0x824FF748)
	// 824FF6D4: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824FF6D8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 824FF6DC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 824FF6E0: 38A31DA0  addi r5, r3, 0x1da0
	ctx.r[5].s64 = ctx.r[3].s64 + 7584;
	// 824FF6E4: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 824FF6E8: C1894478  lfs f12, 0x4478(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(17528 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824FF6EC: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 824FF6F0: C00A8CB4  lfs f0, -0x734c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-29516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824FF6F4: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 824FF6F8: D00B0030  stfs f0, 0x30(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 824FF6FC: 93EB0010  stw r31, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 824FF700: A0E40010  lhz r7, 0x10(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 824FF704: D18B0024  stfs f12, 0x24(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 824FF708: D18B0028  stfs f12, 0x28(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 824FF70C: C8094470  lfd f0, 0x4470(r9)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(17520 as u32) ) };
	// 824FF710: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 824FF714: FD600210  fabs f11, f0
	ctx.f[11].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 824FF718: C1AA4468  lfs f13, 0x4468(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(17512 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824FF71C: D1AB0014  stfs f13, 0x14(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 824FF720: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 824FF724: D1AB0018  stfs f13, 0x18(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 824FF728: B0EB0038  sth r7, 0x38(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[7].u16 ) };
	// 824FF72C: D16B002C  stfs f11, 0x2c(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 824FF730: C0091850  lfs f0, 0x1850(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824FF734: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 824FF738: D00B001C  stfs f0, 0x1c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 824FF73C: D00B0020  stfs f0, 0x20(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 824FF740: D00B0034  stfs f0, 0x34(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 824FF744: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x824FF748; continue 'dispatch;
            }
            0x824FF748 => {
    //   block [0x824FF748..0x824FF770)
	// 824FF748: E9480000  ld r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 824FF74C: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 824FF750: F9490000  std r10, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 824FF754: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 824FF758: 4200FFF0  bdnz 0x824ff748
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x824FF748; continue 'dispatch;
	}
	// 824FF75C: 38E31CA0  addi r7, r3, 0x1ca0
	ctx.r[7].s64 = ctx.r[3].s64 + 7328;
	// 824FF760: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 824FF764: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	// 824FF768: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 824FF76C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x824FF770; continue 'dispatch;
            }
            0x824FF770 => {
    //   block [0x824FF770..0x824FF798)
	// 824FF770: E90A0000  ld r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 824FF774: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 824FF778: F9090000  std r8, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 824FF77C: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 824FF780: 4200FFF0  bdnz 0x824ff770
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x824FF770; continue 'dispatch;
	}
	// 824FF784: 39031CE0  addi r8, r3, 0x1ce0
	ctx.r[8].s64 = ctx.r[3].s64 + 7392;
	// 824FF788: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 824FF78C: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 824FF790: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 824FF794: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	pc = 0x824FF798; continue 'dispatch;
            }
            0x824FF798 => {
    //   block [0x824FF798..0x824FF7BC)
	// 824FF798: E8CA0000  ld r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 824FF79C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 824FF7A0: F8C90000  std r6, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 824FF7A4: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 824FF7A8: 4200FFF0  bdnz 0x824ff798
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x824FF798; continue 'dispatch;
	}
	// 824FF7AC: 39231D20  addi r9, r3, 0x1d20
	ctx.r[9].s64 = ctx.r[3].s64 + 7456;
	// 824FF7B0: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 824FF7B4: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 824FF7B8: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	pc = 0x824FF7BC; continue 'dispatch;
            }
            0x824FF7BC => {
    //   block [0x824FF7BC..0x824FF884)
	// 824FF7BC: E8CB0000  ld r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 824FF7C0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 824FF7C4: F8CA0000  std r6, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 824FF7C8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 824FF7CC: 4200FFF0  bdnz 0x824ff7bc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x824FF7BC; continue 'dispatch;
	}
	// 824FF7D0: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824FF7D4: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 824FF7D8: D005000C  stfs f0, 0xc(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 824FF7DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 824FF7E0: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824FF7E4: D0050004  stfs f0, 4(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 824FF7E8: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824FF7EC: D0050008  stfs f0, 8(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 824FF7F0: 89640018  lbz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 824FF7F4: C1A62090  lfs f13, 0x2090(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8336 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 824FF7F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824FF7FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 824FF800: C00B0828  lfs f0, 0x828(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2088 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824FF804: 419A0080  beq cr6, 0x824ff884
	if ctx.cr[6].eq {
	pc = 0x824FF884; continue 'dispatch;
	}
	// 824FF808: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824FF80C: C16B27B4  lfs f11, 0x27b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10164 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824FF810: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824FF814: D1670014  stfs f11, 0x14(r7)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 824FF818: C18B4464  lfs f12, 0x4464(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17508 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824FF81C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824FF820: D1870018  stfs f12, 0x18(r7)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 824FF824: C16B3260  lfs f11, 0x3260(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12896 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824FF828: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824FF82C: D1670024  stfs f11, 0x24(r7)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 824FF830: C14B4460  lfs f10, 0x4460(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17504 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 824FF834: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824FF838: D1470028  stfs f10, 0x28(r7)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 824FF83C: C16B445C  lfs f11, 0x445c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17500 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824FF840: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824FF844: D167002C  stfs f11, 0x2c(r7)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 824FF848: C14B235C  lfs f10, 0x235c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9052 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 824FF84C: D1470030  stfs f10, 0x30(r7)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 824FF850: C164000C  lfs f11, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824FF854: ED605824  fdivs f11, f0, f11
	ctx.f[11].f64 = ((ctx.f[0].f64 / ctx.f[11].f64) as f32) as f64;
	// 824FF858: D167001C  stfs f11, 0x1c(r7)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 824FF85C: C164000C  lfs f11, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824FF860: ED6D5824  fdivs f11, f13, f11
	ctx.f[11].f64 = ((ctx.f[13].f64 / ctx.f[11].f64) as f32) as f64;
	// 824FF864: D1670020  stfs f11, 0x20(r7)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 824FF868: C164000C  lfs f11, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824FF86C: ED8C5824  fdivs f12, f12, f11
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[11].f64) as f32) as f64;
	// 824FF870: ED8C0232  fmuls f12, f12, f8
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[8].f64) as f32) as f64);
	// 824FF874: D1870034  stfs f12, 0x34(r7)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 824FF878: A1640012  lhz r11, 0x12(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(18 as u32) ) } as u64;
	// 824FF87C: 91470010  stw r10, 0x10(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 824FF880: B1670038  sth r11, 0x38(r7)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[7].u32.wrapping_add(56 as u32), ctx.r[11].u16 ) };
	pc = 0x824FF884; continue 'dispatch;
            }
            0x824FF884 => {
    //   block [0x824FF884..0x824FF90C)
	// 824FF884: 89640018  lbz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 824FF888: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824FF88C: 419A0080  beq cr6, 0x824ff90c
	if ctx.cr[6].eq {
	pc = 0x824FF90C; continue 'dispatch;
	}
	// 824FF890: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824FF894: C16B2048  lfs f11, 0x2048(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8264 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824FF898: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824FF89C: D1680014  stfs f11, 0x14(r8)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 824FF8A0: C18B280C  lfs f12, 0x280c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10252 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824FF8A4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824FF8A8: D1880018  stfs f12, 0x18(r8)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 824FF8AC: C16B4458  lfs f11, 0x4458(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17496 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824FF8B0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824FF8B4: D1680024  stfs f11, 0x24(r8)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 824FF8B8: C14B4454  lfs f10, 0x4454(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17492 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 824FF8BC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824FF8C0: D1480028  stfs f10, 0x28(r8)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 824FF8C4: C16B21B8  lfs f11, 0x21b8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8632 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824FF8C8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824FF8CC: D168002C  stfs f11, 0x2c(r8)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 824FF8D0: C14B2120  lfs f10, 0x2120(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8480 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 824FF8D4: D1480030  stfs f10, 0x30(r8)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 824FF8D8: C164000C  lfs f11, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824FF8DC: ED605824  fdivs f11, f0, f11
	ctx.f[11].f64 = ((ctx.f[0].f64 / ctx.f[11].f64) as f32) as f64;
	// 824FF8E0: D168001C  stfs f11, 0x1c(r8)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 824FF8E4: C164000C  lfs f11, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824FF8E8: ED6D5824  fdivs f11, f13, f11
	ctx.f[11].f64 = ((ctx.f[13].f64 / ctx.f[11].f64) as f32) as f64;
	// 824FF8EC: D1680020  stfs f11, 0x20(r8)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 824FF8F0: C164000C  lfs f11, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824FF8F4: ED8C5824  fdivs f12, f12, f11
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[11].f64) as f32) as f64;
	// 824FF8F8: ED8C0272  fmuls f12, f12, f9
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[9].f64) as f32) as f64);
	// 824FF8FC: D1880034  stfs f12, 0x34(r8)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 824FF900: A1640014  lhz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 824FF904: 91480010  stw r10, 0x10(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 824FF908: B1680038  sth r11, 0x38(r8)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[8].u32.wrapping_add(56 as u32), ctx.r[11].u16 ) };
	pc = 0x824FF90C; continue 'dispatch;
            }
            0x824FF90C => {
    //   block [0x824FF90C..0x824FF99C)
	// 824FF90C: C1840004  lfs f12, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824FF910: D1890000  stfs f12, 0(r9)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 824FF914: 89640018  lbz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 824FF918: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824FF91C: 419A0080  beq cr6, 0x824ff99c
	if ctx.cr[6].eq {
	pc = 0x824FF99C; continue 'dispatch;
	}
	// 824FF920: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824FF924: C16B2500  lfs f11, 0x2500(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9472 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824FF928: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824FF92C: D1690014  stfs f11, 0x14(r9)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 824FF930: C18B4450  lfs f12, 0x4450(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17488 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 824FF934: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 824FF938: D1890018  stfs f12, 0x18(r9)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 824FF93C: C16B29BC  lfs f11, 0x29bc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10684 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824FF940: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824FF944: D1690024  stfs f11, 0x24(r9)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 824FF948: C14B444C  lfs f10, 0x444c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17484 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 824FF94C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824FF950: D1490028  stfs f10, 0x28(r9)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 824FF954: C16B4448  lfs f11, 0x4448(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17480 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824FF958: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824FF95C: D169002C  stfs f11, 0x2c(r9)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 824FF960: C14B4444  lfs f10, 0x4444(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17476 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 824FF964: D1490030  stfs f10, 0x30(r9)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 824FF968: C164000C  lfs f11, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 824FF96C: EC005824  fdivs f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[11].f64) as f32) as f64;
	// 824FF970: D009001C  stfs f0, 0x1c(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 824FF974: C004000C  lfs f0, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824FF978: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 824FF97C: D0090020  stfs f0, 0x20(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 824FF980: C004000C  lfs f0, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824FF984: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 824FF988: EC000272  fmuls f0, f0, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[9].f64) as f32) as f64);
	// 824FF98C: D0090034  stfs f0, 0x34(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 824FF990: A1640016  lhz r11, 0x16(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(22 as u32) ) } as u64;
	// 824FF994: 91490010  stw r10, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 824FF998: B1690038  sth r11, 0x38(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(56 as u32), ctx.r[11].u16 ) };
	pc = 0x824FF99C; continue 'dispatch;
            }
            0x824FF99C => {
    //   block [0x824FF99C..0x824FF9AC)
	// 824FF99C: 39631D60  addi r11, r3, 0x1d60
	ctx.r[11].s64 = ctx.r[3].s64 + 7520;
	// 824FF9A0: 38E00008  li r7, 8
	ctx.r[7].s64 = 8;
	// 824FF9A4: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 824FF9A8: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	pc = 0x824FF9AC; continue 'dispatch;
            }
            0x824FF9AC => {
    //   block [0x824FF9AC..0x824FF9E0)
	// 824FF9AC: E8E90000  ld r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 824FF9B0: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 824FF9B4: F8E80000  std r7, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u64 ) };
	// 824FF9B8: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 824FF9BC: 4200FFF0  bdnz 0x824ff9ac
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x824FF9AC; continue 'dispatch;
	}
	// 824FF9C0: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824FF9C4: 39231BB0  addi r9, r3, 0x1bb0
	ctx.r[9].s64 = ctx.r[3].s64 + 7088;
	// 824FF9C8: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 824FF9CC: 39000064  li r8, 0x64
	ctx.r[8].s64 = 100;
	// 824FF9D0: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 824FF9D4: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 824FF9D8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 824FF9DC: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x824FF9E0; continue 'dispatch;
            }
            0x824FF9E0 => {
    //   block [0x824FF9E0..0x824FFB04)
	// 824FF9E0: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 824FF9E4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824FF9E8: 4200FFF8  bdnz 0x824ff9e0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x824FF9E0; continue 'dispatch;
	}
	// 824FF9EC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 824FF9F0: 9BE31BBB  stb r31, 0x1bbb(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7099 as u32), ctx.r[31].u8 ) };
	// 824FF9F4: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 824FF9F8: 9BE31BBC  stb r31, 0x1bbc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7100 as u32), ctx.r[31].u8 ) };
	// 824FF9FC: 38E00004  li r7, 4
	ctx.r[7].s64 = 4;
	// 824FFA00: 99431BBD  stb r10, 0x1bbd(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7101 as u32), ctx.r[10].u8 ) };
	// 824FFA04: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 824FFA08: 9BE31BC5  stb r31, 0x1bc5(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7109 as u32), ctx.r[31].u8 ) };
	// 824FFA0C: 9BE31BC6  stb r31, 0x1bc6(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7110 as u32), ctx.r[31].u8 ) };
	// 824FFA10: 99631BC3  stb r11, 0x1bc3(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7107 as u32), ctx.r[11].u8 ) };
	// 824FFA14: 99231BBE  stb r9, 0x1bbe(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7102 as u32), ctx.r[9].u8 ) };
	// 824FFA18: 98E31BBF  stb r7, 0x1bbf(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7103 as u32), ctx.r[7].u8 ) };
	// 824FFA1C: 99231BC0  stb r9, 0x1bc0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7104 as u32), ctx.r[9].u8 ) };
	// 824FFA20: 99031BC2  stb r8, 0x1bc2(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7106 as u32), ctx.r[8].u8 ) };
	// 824FFA24: 99631BCD  stb r11, 0x1bcd(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7117 as u32), ctx.r[11].u8 ) };
	// 824FFA28: 99431BC7  stb r10, 0x1bc7(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7111 as u32), ctx.r[10].u8 ) };
	// 824FFA2C: 99631BC8  stb r11, 0x1bc8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7112 as u32), ctx.r[11].u8 ) };
	// 824FFA30: 99631BC9  stb r11, 0x1bc9(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7113 as u32), ctx.r[11].u8 ) };
	// 824FFA34: 99631BCA  stb r11, 0x1bca(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7114 as u32), ctx.r[11].u8 ) };
	// 824FFA38: 99631BCC  stb r11, 0x1bcc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7116 as u32), ctx.r[11].u8 ) };
	// 824FFA3C: 99631C0B  stb r11, 0x1c0b(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7179 as u32), ctx.r[11].u8 ) };
	// 824FFA40: 99631C0C  stb r11, 0x1c0c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7180 as u32), ctx.r[11].u8 ) };
	// 824FFA44: 99631C13  stb r11, 0x1c13(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7187 as u32), ctx.r[11].u8 ) };
	// 824FFA48: 99431C0D  stb r10, 0x1c0d(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7181 as u32), ctx.r[10].u8 ) };
	// 824FFA4C: 99631C0E  stb r11, 0x1c0e(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7182 as u32), ctx.r[11].u8 ) };
	// 824FFA50: 99631C0F  stb r11, 0x1c0f(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7183 as u32), ctx.r[11].u8 ) };
	// 824FFA54: 99631C10  stb r11, 0x1c10(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7184 as u32), ctx.r[11].u8 ) };
	// 824FFA58: 99631C12  stb r11, 0x1c12(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7186 as u32), ctx.r[11].u8 ) };
	// 824FFA5C: 99431BCF  stb r10, 0x1bcf(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7119 as u32), ctx.r[10].u8 ) };
	// 824FFA60: 99431BD0  stb r10, 0x1bd0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7120 as u32), ctx.r[10].u8 ) };
	// 824FFA64: 99431BD7  stb r10, 0x1bd7(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7127 as u32), ctx.r[10].u8 ) };
	// 824FFA68: 99431BD1  stb r10, 0x1bd1(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7121 as u32), ctx.r[10].u8 ) };
	// 824FFA6C: 99431BD2  stb r10, 0x1bd2(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7122 as u32), ctx.r[10].u8 ) };
	// 824FFA70: 99431BD3  stb r10, 0x1bd3(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7123 as u32), ctx.r[10].u8 ) };
	// 824FFA74: 99631BD4  stb r11, 0x1bd4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7124 as u32), ctx.r[11].u8 ) };
	// 824FFA78: 99431BD6  stb r10, 0x1bd6(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7126 as u32), ctx.r[10].u8 ) };
	// 824FFA7C: 99231BD9  stb r9, 0x1bd9(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7129 as u32), ctx.r[9].u8 ) };
	// 824FFA80: 99631BDA  stb r11, 0x1bda(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7130 as u32), ctx.r[11].u8 ) };
	// 824FFA84: 99631BE1  stb r11, 0x1be1(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7137 as u32), ctx.r[11].u8 ) };
	// 824FFA88: 99431BDB  stb r10, 0x1bdb(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7131 as u32), ctx.r[10].u8 ) };
	// 824FFA8C: 99431BDC  stb r10, 0x1bdc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7132 as u32), ctx.r[10].u8 ) };
	// 824FFA90: 99631BDD  stb r11, 0x1bdd(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7133 as u32), ctx.r[11].u8 ) };
	// 824FFA94: 99631BDE  stb r11, 0x1bde(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7134 as u32), ctx.r[11].u8 ) };
	// 824FFA98: 99631BE0  stb r11, 0x1be0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7136 as u32), ctx.r[11].u8 ) };
	// 824FFA9C: 98E31BE3  stb r7, 0x1be3(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7139 as u32), ctx.r[7].u8 ) };
	// 824FFAA0: 99631BE4  stb r11, 0x1be4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7140 as u32), ctx.r[11].u8 ) };
	// 824FFAA4: 99631BEB  stb r11, 0x1beb(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7147 as u32), ctx.r[11].u8 ) };
	// 824FFAA8: 99431BE5  stb r10, 0x1be5(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7141 as u32), ctx.r[10].u8 ) };
	// 824FFAAC: 99631BE6  stb r11, 0x1be6(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7142 as u32), ctx.r[11].u8 ) };
	// 824FFAB0: 99631BE7  stb r11, 0x1be7(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7143 as u32), ctx.r[11].u8 ) };
	// 824FFAB4: 99631BE8  stb r11, 0x1be8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7144 as u32), ctx.r[11].u8 ) };
	// 824FFAB8: 99631BEA  stb r11, 0x1bea(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7146 as u32), ctx.r[11].u8 ) };
	// 824FFABC: 99231BED  stb r9, 0x1bed(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7149 as u32), ctx.r[9].u8 ) };
	// 824FFAC0: 99631BEE  stb r11, 0x1bee(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7150 as u32), ctx.r[11].u8 ) };
	// 824FFAC4: 99631BF5  stb r11, 0x1bf5(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7157 as u32), ctx.r[11].u8 ) };
	// 824FFAC8: 99631BEF  stb r11, 0x1bef(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7151 as u32), ctx.r[11].u8 ) };
	// 824FFACC: 99631BF0  stb r11, 0x1bf0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7152 as u32), ctx.r[11].u8 ) };
	// 824FFAD0: 99631BF1  stb r11, 0x1bf1(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7153 as u32), ctx.r[11].u8 ) };
	// 824FFAD4: 99631BF2  stb r11, 0x1bf2(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7154 as u32), ctx.r[11].u8 ) };
	// 824FFAD8: 99631BF4  stb r11, 0x1bf4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7156 as u32), ctx.r[11].u8 ) };
	// 824FFADC: 99031C01  stb r8, 0x1c01(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7169 as u32), ctx.r[8].u8 ) };
	// 824FFAE0: 99631C02  stb r11, 0x1c02(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7170 as u32), ctx.r[11].u8 ) };
	// 824FFAE4: 99631C09  stb r11, 0x1c09(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7177 as u32), ctx.r[11].u8 ) };
	// 824FFAE8: 99431C03  stb r10, 0x1c03(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7171 as u32), ctx.r[10].u8 ) };
	// 824FFAEC: 99631C04  stb r11, 0x1c04(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7172 as u32), ctx.r[11].u8 ) };
	// 824FFAF0: 99631C05  stb r11, 0x1c05(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7173 as u32), ctx.r[11].u8 ) };
	// 824FFAF4: 99631C06  stb r11, 0x1c06(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7174 as u32), ctx.r[11].u8 ) };
	// 824FFAF8: 99631C08  stb r11, 0x1c08(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7176 as u32), ctx.r[11].u8 ) };
	// 824FFAFC: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 824FFB00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824FFB08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824FFB08 size=344
    let mut pc: u32 = 0x824FFB08;
    'dispatch: loop {
        match pc {
            0x824FFB08 => {
    //   block [0x824FFB08..0x824FFB48)
	// 824FFB08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824FFB0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 824FFB10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 824FFB14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 824FFB18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824FFB1C: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 824FFB20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824FFB24: 392A4480  addi r9, r10, 0x4480
	ctx.r[9].s64 = ctx.r[10].s64 + 17536;
	// 824FFB28: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 824FFB2C: 397F09A0  addi r11, r31, 0x9a0
	ctx.r[11].s64 = ctx.r[31].s64 + 2464;
	// 824FFB30: 3940003F  li r10, 0x3f
	ctx.r[10].s64 = 63;
	// 824FFB34: 909F0008  stw r4, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 824FFB38: 396B0011  addi r11, r11, 0x11
	ctx.r[11].s64 = ctx.r[11].s64 + 17;
	// 824FFB3C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824FFB40: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 824FFB44: B0FF0006  sth r7, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[7].u16 ) };
	pc = 0x824FFB48; continue 'dispatch;
            }
            0x824FFB48 => {
    //   block [0x824FFB48..0x824FFB6C)
	// 824FFB48: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824FFB4C: 9BCBFFFF  stb r30, -1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-1 as u32), ctx.r[30].u8 ) };
	// 824FFB50: 9BCB0000  stb r30, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u8 ) };
	// 824FFB54: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 824FFB58: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824FFB5C: 4098FFEC  bge cr6, 0x824ffb48
	if !ctx.cr[6].lt {
	pc = 0x824FFB48; continue 'dispatch;
	}
	// 824FFB60: 397F16B0  addi r11, r31, 0x16b0
	ctx.r[11].s64 = ctx.r[31].s64 + 5808;
	// 824FFB64: 3940000F  li r10, 0xf
	ctx.r[10].s64 = 15;
	// 824FFB68: 396B0031  addi r11, r11, 0x31
	ctx.r[11].s64 = ctx.r[11].s64 + 49;
	pc = 0x824FFB6C; continue 'dispatch;
            }
            0x824FFB6C => {
    //   block [0x824FFB6C..0x824FFBD4)
	// 824FFB6C: 9BCBFFFF  stb r30, -1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-1 as u32), ctx.r[30].u8 ) };
	// 824FFB70: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 824FFB74: 9BCB0000  stb r30, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u8 ) };
	// 824FFB78: 9BCB0001  stb r30, 1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1 as u32), ctx.r[30].u8 ) };
	// 824FFB7C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824FFB80: 93CBFFE7  stw r30, -0x19(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-25 as u32), ctx.r[30].u32 ) };
	// 824FFB84: 93CBFFEB  stw r30, -0x15(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-21 as u32), ctx.r[30].u32 ) };
	// 824FFB88: 93CBFFEF  stw r30, -0x11(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-17 as u32), ctx.r[30].u32 ) };
	// 824FFB8C: 93CBFFF3  stw r30, -0xd(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-13 as u32), ctx.r[30].u32 ) };
	// 824FFB90: 93CBFFF7  stw r30, -9(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9 as u32), ctx.r[30].u32 ) };
	// 824FFB94: 396B0050  addi r11, r11, 0x50
	ctx.r[11].s64 = ctx.r[11].s64 + 80;
	// 824FFB98: 4098FFD4  bge cr6, 0x824ffb6c
	if !ctx.cr[6].lt {
	pc = 0x824FFB6C; continue 'dispatch;
	}
	// 824FFB9C: 3D408000  lis r10, -0x8000
	ctx.r[10].s64 = -2147483648;
	// 824FFBA0: 93DF1E24  stw r30, 0x1e24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7716 as u32), ctx.r[30].u32 ) };
	// 824FFBA4: 93DF1E28  stw r30, 0x1e28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7720 as u32), ctx.r[30].u32 ) };
	// 824FFBA8: 397F000C  addi r11, r31, 0xc
	ctx.r[11].s64 = ctx.r[31].s64 + 12;
	// 824FFBAC: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	// 824FFBB0: 915F1E2C  stw r10, 0x1e2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7724 as u32), ctx.r[10].u32 ) };
	// 824FFBB4: 93DF1E30  stw r30, 0x1e30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7728 as u32), ctx.r[30].u32 ) };
	// 824FFBB8: 93DF1E34  stw r30, 0x1e34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7732 as u32), ctx.r[30].u32 ) };
	// 824FFBBC: 93DF1E38  stw r30, 0x1e38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7736 as u32), ctx.r[30].u32 ) };
	// 824FFBC0: 93DF1E3C  stw r30, 0x1e3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(7740 as u32), ctx.r[30].u32 ) };
	// 824FFBC4: 9BDF1E20  stb r30, 0x1e20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(7712 as u32), ctx.r[30].u8 ) };
	// 824FFBC8: 98FF1E23  stb r7, 0x1e23(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(7715 as u32), ctx.r[7].u8 ) };
	// 824FFBCC: 93DF0EA0  stw r30, 0xea0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(3744 as u32), ctx.r[30].u32 ) };
	// 824FFBD0: 9BDF1E22  stb r30, 0x1e22(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(7714 as u32), ctx.r[30].u8 ) };
	pc = 0x824FFBD4; continue 'dispatch;
            }
            0x824FFBD4 => {
    //   block [0x824FFBD4..0x824FFBD8)
	// 824FFBD4: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	pc = 0x824FFBD8; continue 'dispatch;
            }
            0x824FFBD8 => {
    //   block [0x824FFBD8..0x824FFBFC)
	// 824FFBD8: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 824FFBDC: 90AB0000  stw r5, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 824FFBE0: 419A001C  beq cr6, 0x824ffbfc
	if ctx.cr[6].eq {
	pc = 0x824FFBFC; continue 'dispatch;
	}
	// 824FFBE4: A1450004  lhz r10, 4(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 824FFBE8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 824FFBEC: 419A0010  beq cr6, 0x824ffbfc
	if ctx.cr[6].eq {
	pc = 0x824FFBFC; continue 'dispatch;
	}
	// 824FFBF0: A1450006  lhz r10, 6(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(6 as u32) ) } as u64;
	// 824FFBF4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 824FFBF8: B1450006  sth r10, 6(r5)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[5].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	pc = 0x824FFBFC; continue 'dispatch;
            }
            0x824FFBFC => {
    //   block [0x824FFBFC..0x824FFC20)
	// 824FFBFC: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 824FFC00: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824FFC04: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 824FFC08: 409AFFD0  bne cr6, 0x824ffbd8
	if !ctx.cr[6].eq {
	pc = 0x824FFBD8; continue 'dispatch;
	}
	// 824FFC0C: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 824FFC10: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 824FFC14: 409AFFC0  bne cr6, 0x824ffbd4
	if !ctx.cr[6].eq {
	pc = 0x824FFBD4; continue 'dispatch;
	}
	// 824FFC18: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 824FFC1C: 395F0110  addi r10, r31, 0x110
	ctx.r[10].s64 = ctx.r[31].s64 + 272;
	pc = 0x824FFC20; continue 'dispatch;
            }
            0x824FFC20 => {
    //   block [0x824FFC20..0x824FFC60)
	// 824FFC20: 7CE95830  slw r9, r7, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[7].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 824FFC24: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824FFC28: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 824FFC2C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824FFC30: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 824FFC34: 4198FFEC  blt cr6, 0x824ffc20
	if ctx.cr[6].lt {
	pc = 0x824FFC20; continue 'dispatch;
	}
	// 824FFC38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824FFC3C: 4BFFF37D  bl 0x824fefb8
	ctx.lr = 0x824FFC40;
	sub_824FEFB8(ctx, base);
	// 824FFC40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824FFC44: 9BDF1E21  stb r30, 0x1e21(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(7713 as u32), ctx.r[30].u8 ) };
	// 824FFC48: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 824FFC4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 824FFC50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 824FFC54: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 824FFC58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 824FFC5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824FFC60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824FFC60 size=292
    let mut pc: u32 = 0x824FFC60;
    'dispatch: loop {
        match pc {
            0x824FFC60 => {
    //   block [0x824FFC60..0x824FFCD0)
	// 824FFC60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824FFC64: 48035455  bl 0x825350b8
	ctx.lr = 0x824FFC68;
	sub_82535080(ctx, base);
	// 824FFC68: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824FFC6C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 824FFC70: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 824FFC74: 396B4480  addi r11, r11, 0x4480
	ctx.r[11].s64 = ctx.r[11].s64 + 17536;
	// 824FFC78: 809D1E30  lwz r4, 0x1e30(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(7728 as u32) ) } as u64;
	// 824FFC7C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 824FFC80: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824FFC84: 419A004C  beq cr6, 0x824ffcd0
	if ctx.cr[6].eq {
	pc = 0x824FFCD0; continue 'dispatch;
	}
	// 824FFC88: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824FFC8C: 3BE00010  li r31, 0x10
	ctx.r[31].s64 = 16;
	// 824FFC90: 7C7FF02E  lwzx r3, r31, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824FFC94: 4BF6462D  bl 0x824642c0
	ctx.lr = 0x824FFC98;
	sub_824642C0(ctx, base);
	// 824FFC98: 809D1E34  lwz r4, 0x1e34(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(7732 as u32) ) } as u64;
	// 824FFC9C: 7C7FF02E  lwzx r3, r31, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824FFCA0: 4BF64621  bl 0x824642c0
	ctx.lr = 0x824FFCA4;
	sub_824642C0(ctx, base);
	// 824FFCA4: 809D1E38  lwz r4, 0x1e38(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(7736 as u32) ) } as u64;
	// 824FFCA8: 7C7FF02E  lwzx r3, r31, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824FFCAC: 4BF64615  bl 0x824642c0
	ctx.lr = 0x824FFCB0;
	sub_824642C0(ctx, base);
	// 824FFCB0: 809D1E3C  lwz r4, 0x1e3c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(7740 as u32) ) } as u64;
	// 824FFCB4: 7C7FF02E  lwzx r3, r31, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 824FFCB8: 4BF64609  bl 0x824642c0
	ctx.lr = 0x824FFCBC;
	sub_824642C0(ctx, base);
	// 824FFCBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 824FFCC0: 917D1E30  stw r11, 0x1e30(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(7728 as u32), ctx.r[11].u32 ) };
	// 824FFCC4: 917D1E34  stw r11, 0x1e34(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(7732 as u32), ctx.r[11].u32 ) };
	// 824FFCC8: 917D1E38  stw r11, 0x1e38(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(7736 as u32), ctx.r[11].u32 ) };
	// 824FFCCC: 917D1E3C  stw r11, 0x1e3c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(7740 as u32), ctx.r[11].u32 ) };
	pc = 0x824FFCD0; continue 'dispatch;
            }
            0x824FFCD0 => {
    //   block [0x824FFCD0..0x824FFCD8)
	// 824FFCD0: 397D000C  addi r11, r29, 0xc
	ctx.r[11].s64 = ctx.r[29].s64 + 12;
	// 824FFCD4: 3B800008  li r28, 8
	ctx.r[28].s64 = 8;
	pc = 0x824FFCD8; continue 'dispatch;
            }
            0x824FFCD8 => {
    //   block [0x824FFCD8..0x824FFCE0)
	// 824FFCD8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 824FFCDC: 3BC00008  li r30, 8
	ctx.r[30].s64 = 8;
	pc = 0x824FFCE0; continue 'dispatch;
            }
            0x824FFCE0 => {
    //   block [0x824FFCE0..0x824FFD24)
	// 824FFCE0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 824FFCE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 824FFCE8: 419A003C  beq cr6, 0x824ffd24
	if ctx.cr[6].eq {
	pc = 0x824FFD24; continue 'dispatch;
	}
	// 824FFCEC: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 824FFCF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824FFCF4: 419A0030  beq cr6, 0x824ffd24
	if ctx.cr[6].eq {
	pc = 0x824FFD24; continue 'dispatch;
	}
	// 824FFCF8: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 824FFCFC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 824FFD00: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 824FFD04: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 824FFD08: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 824FFD0C: 409A0018  bne cr6, 0x824ffd24
	if !ctx.cr[6].eq {
	pc = 0x824FFD24; continue 'dispatch;
	}
	// 824FFD10: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 824FFD14: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 824FFD18: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 824FFD1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 824FFD20: 4E800421  bctrl
	ctx.lr = 0x824FFD24;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x824FFD24 => {
    //   block [0x824FFD24..0x824FFD70)
	// 824FFD24: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 824FFD28: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 824FFD2C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 824FFD30: 409AFFB0  bne cr6, 0x824ffce0
	if !ctx.cr[6].eq {
	pc = 0x824FFCE0; continue 'dispatch;
	}
	// 824FFD34: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 824FFD38: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 824FFD3C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 824FFD40: 409AFF98  bne cr6, 0x824ffcd8
	if !ctx.cr[6].eq {
	pc = 0x824FFCD8; continue 'dispatch;
	}
	// 824FFD44: 817D1E2C  lwz r11, 0x1e2c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(7724 as u32) ) } as u64;
	// 824FFD48: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 824FFD4C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 824FFD50: 409A0020  bne cr6, 0x824ffd70
	if !ctx.cr[6].eq {
	pc = 0x824FFD70; continue 'dispatch;
	}
	// 824FFD54: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 824FFD58: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 824FFD5C: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 824FFD60: 809D1E24  lwz r4, 0x1e24(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(7716 as u32) ) } as u64;
	// 824FFD64: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 824FFD68: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 824FFD6C: 4BF6434D  bl 0x824640b8
	ctx.lr = 0x824FFD70;
	sub_824640B8(ctx, base);
	pc = 0x824FFD70; continue 'dispatch;
            }
            0x824FFD70 => {
    //   block [0x824FFD70..0x824FFD84)
	// 824FFD70: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 824FFD74: 396B6DD0  addi r11, r11, 0x6dd0
	ctx.r[11].s64 = ctx.r[11].s64 + 28112;
	// 824FFD78: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 824FFD7C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 824FFD80: 48035388  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824FFD88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824FFD88 size=280
    let mut pc: u32 = 0x824FFD88;
    'dispatch: loop {
        match pc {
            0x824FFD88 => {
    //   block [0x824FFD88..0x824FFDC8)
	// 824FFD88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824FFD8C: 48035329  bl 0x825350b4
	ctx.lr = 0x824FFD90;
	sub_82535080(ctx, base);
	// 824FFD90: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824FFD94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824FFD98: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 824FFD9C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 824FFDA0: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 824FFDA4: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 824FFDA8: 817F0190  lwz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 824FFDAC: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 824FFDB0: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 824FFDB4: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 824FFDB8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824FFDBC: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 824FFDC0: 396B09A0  addi r11, r11, 0x9a0
	ctx.r[11].s64 = ctx.r[11].s64 + 2464;
	// 824FFDC4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x824FFDC8; continue 'dispatch;
            }
            0x824FFDC8 => {
    //   block [0x824FFDC8..0x824FFE8C)
	// 824FFDC8: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 824FFDCC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 824FFDD0: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824FFDD4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824FFDD8: 4200FFF0  bdnz 0x824ffdc8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x824FFDC8; continue 'dispatch;
	}
	// 824FFDDC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 824FFDE0: 815F1E38  lwz r10, 0x1e38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7736 as u32) ) } as u64;
	// 824FFDE4: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 824FFDE8: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 824FFDEC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 824FFDF0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 824FFDF4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 824FFDF8: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 824FFDFC: 389F0EB0  addi r4, r31, 0xeb0
	ctx.r[4].s64 = ctx.r[31].s64 + 3760;
	// 824FFE00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824FFE04: 4BFFF58D  bl 0x824ff390
	ctx.lr = 0x824FFE08;
	sub_824FF390(ctx, base);
	// 824FFE08: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 824FFE0C: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 824FFE10: 815F1E30  lwz r10, 0x1e30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7728 as u32) ) } as u64;
	// 824FFE14: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 824FFE18: 80BF0190  lwz r5, 0x190(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 824FFE1C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 824FFE20: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 824FFE24: 389F01A0  addi r4, r31, 0x1a0
	ctx.r[4].s64 = ctx.r[31].s64 + 416;
	// 824FFE28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824FFE2C: 4BFFF565  bl 0x824ff390
	ctx.lr = 0x824FFE30;
	sub_824FF390(ctx, base);
	// 824FFE30: 897C0011  lbz r11, 0x11(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(17 as u32) ) } as u64;
	// 824FFE34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824FFE38: 419A0054  beq cr6, 0x824ffe8c
	if ctx.cr[6].eq {
	pc = 0x824FFE8C; continue 'dispatch;
	}
	// 824FFE3C: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 824FFE40: 815F1E3C  lwz r10, 0x1e3c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7740 as u32) ) } as u64;
	// 824FFE44: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 824FFE48: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 824FFE4C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 824FFE50: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 824FFE54: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 824FFE58: 389F12B0  addi r4, r31, 0x12b0
	ctx.r[4].s64 = ctx.r[31].s64 + 4784;
	// 824FFE5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824FFE60: 4BFFF531  bl 0x824ff390
	ctx.lr = 0x824FFE64;
	sub_824FF390(ctx, base);
	// 824FFE64: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 824FFE68: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 824FFE6C: 815F1E34  lwz r10, 0x1e34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7732 as u32) ) } as u64;
	// 824FFE70: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 824FFE74: 80BF0190  lwz r5, 0x190(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 824FFE78: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 824FFE7C: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 824FFE80: 389F05A0  addi r4, r31, 0x5a0
	ctx.r[4].s64 = ctx.r[31].s64 + 1440;
	// 824FFE84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824FFE88: 4BFFF509  bl 0x824ff390
	ctx.lr = 0x824FFE8C;
	sub_824FF390(ctx, base);
	pc = 0x824FFE8C; continue 'dispatch;
            }
            0x824FFE8C => {
    //   block [0x824FFE8C..0x824FFEA0)
	// 824FFE8C: 817F0190  lwz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 824FFE90: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824FFE94: 917F0190  stw r11, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[11].u32 ) };
	// 824FFE98: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 824FFE9C: 48035268  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824FFEA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824FFEA0 size=200
    let mut pc: u32 = 0x824FFEA0;
    'dispatch: loop {
        match pc {
            0x824FFEA0 => {
    //   block [0x824FFEA0..0x824FFEE0)
	// 824FFEA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824FFEA4: 48035211  bl 0x825350b4
	ctx.lr = 0x824FFEA8;
	sub_82535080(ctx, base);
	// 824FFEA8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824FFEAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824FFEB0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 824FFEB4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 824FFEB8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 824FFEBC: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 824FFEC0: 817F0190  lwz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 824FFEC4: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 824FFEC8: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 824FFECC: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 824FFED0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824FFED4: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 824FFED8: 396B09A0  addi r11, r11, 0x9a0
	ctx.r[11].s64 = ctx.r[11].s64 + 2464;
	// 824FFEDC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x824FFEE0; continue 'dispatch;
            }
            0x824FFEE0 => {
    //   block [0x824FFEE0..0x824FFF54)
	// 824FFEE0: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 824FFEE4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 824FFEE8: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 824FFEEC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 824FFEF0: 4200FFF0  bdnz 0x824ffee0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x824FFEE0; continue 'dispatch;
	}
	// 824FFEF4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 824FFEF8: 815F1E30  lwz r10, 0x1e30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7728 as u32) ) } as u64;
	// 824FFEFC: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 824FFF00: 80BF0190  lwz r5, 0x190(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 824FFF04: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 824FFF08: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 824FFF0C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 824FFF10: 389F01A0  addi r4, r31, 0x1a0
	ctx.r[4].s64 = ctx.r[31].s64 + 416;
	// 824FFF14: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 824FFF18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824FFF1C: 4BFFF475  bl 0x824ff390
	ctx.lr = 0x824FFF20;
	sub_824FF390(ctx, base);
	// 824FFF20: 897C0011  lbz r11, 0x11(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(17 as u32) ) } as u64;
	// 824FFF24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824FFF28: 419A002C  beq cr6, 0x824fff54
	if ctx.cr[6].eq {
	pc = 0x824FFF54; continue 'dispatch;
	}
	// 824FFF2C: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 824FFF30: 815F1E34  lwz r10, 0x1e34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7732 as u32) ) } as u64;
	// 824FFF34: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 824FFF38: 80BF0190  lwz r5, 0x190(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 824FFF3C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 824FFF40: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 824FFF44: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 824FFF48: 389F05A0  addi r4, r31, 0x5a0
	ctx.r[4].s64 = ctx.r[31].s64 + 1440;
	// 824FFF4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 824FFF50: 4BFFF441  bl 0x824ff390
	ctx.lr = 0x824FFF54;
	sub_824FF390(ctx, base);
	pc = 0x824FFF54; continue 'dispatch;
            }
            0x824FFF54 => {
    //   block [0x824FFF54..0x824FFF68)
	// 824FFF54: 817F0190  lwz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 824FFF58: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 824FFF5C: 917F0190  stw r11, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[11].u32 ) };
	// 824FFF60: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 824FFF64: 480351A0  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_824FFF68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x824FFF68 size=468
    let mut pc: u32 = 0x824FFF68;
    'dispatch: loop {
        match pc {
            0x824FFF68 => {
    //   block [0x824FFF68..0x824FFF9C)
	// 824FFF68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 824FFF6C: 48035141  bl 0x825350ac
	ctx.lr = 0x824FFF70;
	sub_82535080(ctx, base);
	// 824FFF70: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 824FFF74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 824FFF78: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 824FFF7C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 824FFF80: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 824FFF84: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 824FFF88: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 824FFF8C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 824FFF90: 9B5F1E21  stb r26, 0x1e21(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(7713 as u32), ctx.r[26].u8 ) };
	// 824FFF94: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 824FFF98: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x824FFF9C; continue 'dispatch;
            }
            0x824FFF9C => {
    //   block [0x824FFF9C..0x824FFFFC)
	// 824FFF9C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 824FFFA0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 824FFFA4: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 824FFFA8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 824FFFAC: 4200FFF0  bdnz 0x824fff9c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x824FFF9C; continue 'dispatch;
	}
	// 824FFFB0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 824FFFB4: 8B210090  lbz r25, 0x90(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 824FFFB8: 7F1DE000  cmpw cr6, r29, r28
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[28].s32, &mut ctx.xer);
	// 824FFFBC: 936100A0  stw r27, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[27].u32 ) };
	// 824FFFC0: 419A00BC  beq cr6, 0x8250007c
	if ctx.cr[6].eq {
	pc = 0x8250007C; continue 'dispatch;
	}
	// 824FFFC4: 897E0031  lbz r11, 0x31(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(49 as u32) ) } as u64;
	// 824FFFC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 824FFFCC: 409A00B0  bne cr6, 0x8250007c
	if !ctx.cr[6].eq {
	pc = 0x8250007C; continue 'dispatch;
	}
	// 824FFFD0: 817F0EA0  lwz r11, 0xea0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(3744 as u32) ) } as u64;
	// 824FFFD4: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 824FFFD8: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 824FFFDC: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 824FFFE0: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 824FFFE4: 914100A0  stw r10, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 824FFFE8: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 824FFFEC: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 824FFFF0: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 824FFFF4: 396B16B0  addi r11, r11, 0x16b0
	ctx.r[11].s64 = ctx.r[11].s64 + 5808;
	// 824FFFF8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x824FFFFC; continue 'dispatch;
            }
            0x824FFFFC => {
    //   block [0x824FFFFC..0x8250006C)
	// 824FFFFC: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 82500000: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82500004: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82500008: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8250000C: 4200FFF0  bdnz 0x824ffffc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x824FFFFC; continue 'dispatch;
	}
	// 82500010: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82500014: 815F1E38  lwz r10, 0x1e38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7736 as u32) ) } as u64;
	// 82500018: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 8250001C: 80BF0EA0  lwz r5, 0xea0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(3744 as u32) ) } as u64;
	// 82500020: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82500024: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 82500028: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 8250002C: 389F0EB0  addi r4, r31, 0xeb0
	ctx.r[4].s64 = ctx.r[31].s64 + 3760;
	// 82500030: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82500034: 4BFFF35D  bl 0x824ff390
	ctx.lr = 0x82500038;
	sub_824FF390(ctx, base);
	// 82500038: 7F2B0774  extsb r11, r25
	ctx.r[11].s64 = ctx.r[25].s8 as i64;
	// 8250003C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82500040: 419A002C  beq cr6, 0x8250006c
	if ctx.cr[6].eq {
	pc = 0x8250006C; continue 'dispatch;
	}
	// 82500044: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82500048: 815F1E3C  lwz r10, 0x1e3c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7740 as u32) ) } as u64;
	// 8250004C: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 82500050: 80BF0EA0  lwz r5, 0xea0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(3744 as u32) ) } as u64;
	// 82500054: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82500058: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 8250005C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82500060: 389F12B0  addi r4, r31, 0x12b0
	ctx.r[4].s64 = ctx.r[31].s64 + 4784;
	// 82500064: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82500068: 4BFFF329  bl 0x824ff390
	ctx.lr = 0x8250006C;
	sub_824FF390(ctx, base);
	pc = 0x8250006C; continue 'dispatch;
            }
            0x8250006C => {
    //   block [0x8250006C..0x8250007C)
	// 8250006C: 817F0EA0  lwz r11, 0xea0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(3744 as u32) ) } as u64;
	// 82500070: 934100A0  stw r26, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[26].u32 ) };
	// 82500074: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82500078: 917F0EA0  stw r11, 0xea0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(3744 as u32), ctx.r[11].u32 ) };
	pc = 0x8250007C; continue 'dispatch;
            }
            0x8250007C => {
    //   block [0x8250007C..0x825000B4)
	// 8250007C: 897E0032  lbz r11, 0x32(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(50 as u32) ) } as u64;
	// 82500080: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82500084: 409A0048  bne cr6, 0x825000cc
	if !ctx.cr[6].eq {
	pc = 0x825000CC; continue 'dispatch;
	}
	// 82500088: 83DF0EA0  lwz r30, 0xea0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(3744 as u32) ) } as u64;
	// 8250008C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82500090: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 82500094: 395E0001  addi r10, r30, 1
	ctx.r[10].s64 = ctx.r[30].s64 + 1;
	// 82500098: 915F0EA0  stw r10, 0xea0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(3744 as u32), ctx.r[10].u32 ) };
	// 8250009C: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825000A0: 7D5E5214  add r10, r30, r10
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 825000A4: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825000A8: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 825000AC: 394A16B0  addi r10, r10, 0x16b0
	ctx.r[10].s64 = ctx.r[10].s64 + 5808;
	// 825000B0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x825000B4; continue 'dispatch;
            }
            0x825000B4 => {
    //   block [0x825000B4..0x825000CC)
	// 825000B4: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 825000B8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825000BC: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 825000C0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825000C4: 4200FFF0  bdnz 0x825000b4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825000B4; continue 'dispatch;
	}
	// 825000C8: 4800000C  b 0x825000d4
	pc = 0x825000D4; continue 'dispatch;
            }
            0x825000CC => {
    //   block [0x825000CC..0x825000D4)
	// 825000CC: 817F0EA0  lwz r11, 0xea0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(3744 as u32) ) } as u64;
	// 825000D0: 3BCBFFFF  addi r30, r11, -1
	ctx.r[30].s64 = ctx.r[11].s64 + -1;
	pc = 0x825000D4; continue 'dispatch;
            }
            0x825000D4 => {
    //   block [0x825000D4..0x82500130)
	// 825000D4: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 825000D8: 815F1E38  lwz r10, 0x1e38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7736 as u32) ) } as u64;
	// 825000DC: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 825000E0: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 825000E4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 825000E8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 825000EC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825000F0: 389F0EB0  addi r4, r31, 0xeb0
	ctx.r[4].s64 = ctx.r[31].s64 + 3760;
	// 825000F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825000F8: 4BFFF299  bl 0x824ff390
	ctx.lr = 0x825000FC;
	sub_824FF390(ctx, base);
	// 825000FC: 7F2B0774  extsb r11, r25
	ctx.r[11].s64 = ctx.r[25].s8 as i64;
	// 82500100: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82500104: 419A002C  beq cr6, 0x82500130
	if ctx.cr[6].eq {
	pc = 0x82500130; continue 'dispatch;
	}
	// 82500108: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 8250010C: 815F1E3C  lwz r10, 0x1e3c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7740 as u32) ) } as u64;
	// 82500110: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82500114: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 82500118: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 8250011C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82500120: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82500124: 389F12B0  addi r4, r31, 0x12b0
	ctx.r[4].s64 = ctx.r[31].s64 + 4784;
	// 82500128: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250012C: 4BFFF265  bl 0x824ff390
	ctx.lr = 0x82500130;
	sub_824FF390(ctx, base);
	pc = 0x82500130; continue 'dispatch;
            }
            0x82500130 => {
    //   block [0x82500130..0x8250013C)
	// 82500130: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82500134: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82500138: 48034FC4  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82500140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82500140 size=280
    let mut pc: u32 = 0x82500140;
    'dispatch: loop {
        match pc {
            0x82500140 => {
    //   block [0x82500140..0x82500170)
	// 82500140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82500144: 48034F79  bl 0x825350bc
	ctx.lr = 0x82500148;
	sub_82535080(ctx, base);
	// 82500148: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250014C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82500150: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82500154: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82500158: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8250015C: 817F1E28  lwz r11, 0x1e28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7720 as u32) ) } as u64;
	// 82500160: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82500164: 40990094  ble cr6, 0x825001f8
	if !ctx.cr[6].gt {
	pc = 0x825001F8; continue 'dispatch;
	}
	// 82500168: 391F1E24  addi r8, r31, 0x1e24
	ctx.r[8].s64 = ctx.r[31].s64 + 7716;
	// 8250016C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	pc = 0x82500170; continue 'dispatch;
            }
            0x82500170 => {
    //   block [0x82500170..0x825001AC)
	// 82500170: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82500174: 7D665A14  add r11, r6, r11
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 82500178: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250017C: 7F0AF000  cmpw cr6, r10, r30
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[30].s32, &mut ctx.xer);
	// 82500180: 409A0064  bne cr6, 0x825001e4
	if !ctx.cr[6].eq {
	pc = 0x825001E4; continue 'dispatch;
	}
	// 82500184: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82500188: 7F0BE800  cmpw cr6, r11, r29
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[29].s32, &mut ctx.xer);
	// 8250018C: 409A0058  bne cr6, 0x825001e4
	if !ctx.cr[6].eq {
	pc = 0x825001E4; continue 'dispatch;
	}
	// 82500190: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82500194: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	// 82500198: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8250019C: 7F075800  cmpw cr6, r7, r11
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825001A0: 91680004  stw r11, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825001A4: 40980038  bge cr6, 0x825001dc
	if !ctx.cr[6].lt {
	pc = 0x825001DC; continue 'dispatch;
	}
	// 825001A8: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	pc = 0x825001AC; continue 'dispatch;
            }
            0x825001AC => {
    //   block [0x825001AC..0x825001DC)
	// 825001AC: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 825001B0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825001B4: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825001B8: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 825001BC: 38AB0008  addi r5, r11, 8
	ctx.r[5].s64 = ctx.r[11].s64 + 8;
	// 825001C0: 80850000  lwz r4, 0(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 825001C4: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 825001C8: 80A50004  lwz r5, 4(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 825001CC: 90AB0004  stw r5, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 825001D0: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 825001D4: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825001D8: 4198FFD4  blt cr6, 0x825001ac
	if ctx.cr[6].lt {
	pc = 0x825001AC; continue 'dispatch;
	}
	pc = 0x825001DC; continue 'dispatch;
            }
            0x825001DC => {
    //   block [0x825001DC..0x825001E4)
	// 825001DC: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 825001E0: 38C6FFF8  addi r6, r6, -8
	ctx.r[6].s64 = ctx.r[6].s64 + -8;
	pc = 0x825001E4; continue 'dispatch;
            }
            0x825001E4 => {
    //   block [0x825001E4..0x825001F8)
	// 825001E4: 817F1E28  lwz r11, 0x1e28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7720 as u32) ) } as u64;
	// 825001E8: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 825001EC: 38C60008  addi r6, r6, 8
	ctx.r[6].s64 = ctx.r[6].s64 + 8;
	// 825001F0: 7F075800  cmpw cr6, r7, r11
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825001F4: 4198FF7C  blt cr6, 0x82500170
	if ctx.cr[6].lt {
	pc = 0x82500170; continue 'dispatch;
	}
	pc = 0x825001F8; continue 'dispatch;
            }
            0x825001F8 => {
    //   block [0x825001F8..0x82500230)
	// 825001F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825001FC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82500200: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82500204: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82500208: 4BFFF3A9  bl 0x824ff5b0
	ctx.lr = 0x8250020C;
	sub_824FF5B0(ctx, base);
	// 8250020C: 3BFF1E24  addi r31, r31, 0x1e24
	ctx.r[31].s64 = ctx.r[31].s64 + 7716;
	// 82500210: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82500214: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82500218: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 8250021C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82500220: 409A0010  bne cr6, 0x82500230
	if !ctx.cr[6].eq {
	pc = 0x82500230; continue 'dispatch;
	}
	// 82500224: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82500228: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250022C: 4BF6E125  bl 0x8246e350
	ctx.lr = 0x82500230;
	sub_8246E350(ctx, base);
	pc = 0x82500230; continue 'dispatch;
            }
            0x82500230 => {
    //   block [0x82500230..0x82500258)
	// 82500230: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82500234: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82500238: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8250023C: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 82500240: 7D6A4A14  add r11, r10, r9
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82500244: 911F0004  stw r8, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82500248: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8250024C: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82500250: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82500254: 48034EB8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82500258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82500258 size=320
    let mut pc: u32 = 0x82500258;
    'dispatch: loop {
        match pc {
            0x82500258 => {
    //   block [0x82500258..0x825002EC)
	// 82500258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250025C: 48034E59  bl 0x825350b4
	ctx.lr = 0x82500260;
	sub_82535080(ctx, base);
	// 82500260: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82500264: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82500268: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8250026C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82500270: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82500274: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82500278: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250027C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82500280: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82500284: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82500288: 4E800421  bctrl
	ctx.lr = 0x8250028C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250028C: 80DF1E30  lwz r6, 0x1e30(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7728 as u32) ) } as u64;
	// 82500290: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82500294: 419A0058  beq cr6, 0x825002ec
	if ctx.cr[6].eq {
	pc = 0x825002EC; continue 'dispatch;
	}
	// 82500298: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8250029C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 825002A0: 3BCB44B8  addi r30, r11, 0x44b8
	ctx.r[30].s64 = ctx.r[11].s64 + 17592;
	// 825002A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825002A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825002AC: 4BF63775  bl 0x82463a20
	ctx.lr = 0x825002B0;
	sub_82463A20(ctx, base);
	// 825002B0: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 825002B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825002B8: 80DF1E34  lwz r6, 0x1e34(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7732 as u32) ) } as u64;
	// 825002BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825002C0: 4BF63761  bl 0x82463a20
	ctx.lr = 0x825002C4;
	sub_82463A20(ctx, base);
	// 825002C4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 825002C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825002CC: 80DF1E38  lwz r6, 0x1e38(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7736 as u32) ) } as u64;
	// 825002D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825002D4: 4BF6374D  bl 0x82463a20
	ctx.lr = 0x825002D8;
	sub_82463A20(ctx, base);
	// 825002D8: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 825002DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825002E0: 80DF1E3C  lwz r6, 0x1e3c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7740 as u32) ) } as u64;
	// 825002E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825002E8: 4BF63739  bl 0x82463a20
	ctx.lr = 0x825002EC;
	sub_82463A20(ctx, base);
            }
            0x825002EC => {
    //   block [0x825002EC..0x8250032C)
	// 825002EC: 815F1E2C  lwz r10, 0x1e2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7724 as u32) ) } as u64;
	// 825002F0: 554B0000  rlwinm r11, r10, 0, 0, 0
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 825002F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825002F8: 409A0034  bne cr6, 0x8250032c
	if !ctx.cr[6].eq {
	pc = 0x8250032C; continue 'dispatch;
	}
	// 825002FC: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82500300: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82500304: 80FF1E28  lwz r7, 0x1e28(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7720 as u32) ) } as u64;
	// 82500308: 55481838  slwi r8, r10, 3
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8250030C: 388B44A0  addi r4, r11, 0x44a0
	ctx.r[4].s64 = ctx.r[11].s64 + 17568;
	// 82500310: 80DF1E24  lwz r6, 0x1e24(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7716 as u32) ) } as u64;
	// 82500314: 54E71838  slwi r7, r7, 3
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82500318: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8250031C: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82500320: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82500324: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82500328: 4E800421  bctrl
	ctx.lr = 0x8250032C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8250032C => {
    //   block [0x8250032C..0x8250033C)
	// 8250032C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82500330: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82500334: 3B600008  li r27, 8
	ctx.r[27].s64 = 8;
	// 82500338: 3B8B448C  addi r28, r11, 0x448c
	ctx.r[28].s64 = ctx.r[11].s64 + 17548;
	pc = 0x8250033C; continue 'dispatch;
            }
            0x8250033C => {
    //   block [0x8250033C..0x82500340)
	// 8250033C: 3BC00008  li r30, 8
	ctx.r[30].s64 = 8;
	pc = 0x82500340; continue 'dispatch;
            }
            0x82500340 => {
    //   block [0x82500340..0x82500398)
	// 82500340: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82500344: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82500348: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250034C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82500350: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82500354: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82500358: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250035C: 4E800421  bctrl
	ctx.lr = 0x82500360;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82500360: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 82500364: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82500368: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8250036C: 409AFFD4  bne cr6, 0x82500340
	if !ctx.cr[6].eq {
	pc = 0x82500340; continue 'dispatch;
	}
	// 82500370: 3B7BFFFF  addi r27, r27, -1
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	// 82500374: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82500378: 409AFFC4  bne cr6, 0x8250033c
	if !ctx.cr[6].eq {
	pc = 0x8250033C; continue 'dispatch;
	}
	// 8250037C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82500380: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82500384: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82500388: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250038C: 4E800421  bctrl
	ctx.lr = 0x82500390;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82500390: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82500394: 48034D70  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82500398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82500398 size=1156
    let mut pc: u32 = 0x82500398;
    'dispatch: loop {
        match pc {
            0x82500398 => {
    //   block [0x82500398..0x82500410)
	// 82500398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250039C: 48034CF5  bl 0x82535090
	ctx.lr = 0x825003A0;
	sub_82535080(ctx, base);
	// 825003A0: 9421FBB0  stwu r1, -0x450(r1)
	ea = ctx.r[1].u32.wrapping_add(-1104 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825003A4: 3F208293  lis r25, -0x7d6d
	ctx.r[25].s64 = -2104295424;
	// 825003A8: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 825003AC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825003B0: 3C805E43  lis r4, 0x5e43
	ctx.r[4].s64 = 1581449216;
	// 825003B4: 38AB4534  addi r5, r11, 0x4534
	ctx.r[5].s64 = ctx.r[11].s64 + 17716;
	// 825003B8: 80799190  lwz r3, -0x6e70(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-28272 as u32) ) } as u64;
	// 825003BC: 608445E4  ori r4, r4, 0x45e4
	ctx.r[4].u64 = ctx.r[4].u64 | 17892;
	// 825003C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825003C4: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 825003C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825003CC: 4E800421  bctrl
	ctx.lr = 0x825003D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825003D0: 81731E30  lwz r11, 0x1e30(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(7728 as u32) ) } as u64;
	// 825003D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825003D8: 419A043C  beq cr6, 0x82500814
	if ctx.cr[6].eq {
	pc = 0x82500814; continue 'dispatch;
	}
	// 825003DC: 81731E34  lwz r11, 0x1e34(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(7732 as u32) ) } as u64;
	// 825003E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825003E4: 419A0430  beq cr6, 0x82500814
	if ctx.cr[6].eq {
	pc = 0x82500814; continue 'dispatch;
	}
	// 825003E8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825003EC: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 825003F0: 3AAB4520  addi r21, r11, 0x4520
	ctx.r[21].s64 = ctx.r[11].s64 + 17696;
	// 825003F4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825003F8: 7E96A378  mr r22, r20
	ctx.r[22].u64 = ctx.r[20].u64;
	// 825003FC: 3B4B44F8  addi r26, r11, 0x44f8
	ctx.r[26].s64 = ctx.r[11].s64 + 17656;
	// 82500400: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82500404: 3AE00003  li r23, 3
	ctx.r[23].s64 = 3;
	// 82500408: 3B0B44DC  addi r24, r11, 0x44dc
	ctx.r[24].s64 = ctx.r[11].s64 + 17628;
	// 8250040C: 3E408000  lis r18, -0x8000
	ctx.r[18].s64 = -2147483648;
            }
            0x82500410 => {
    //   block [0x82500410..0x82500448)
	// 82500410: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82500414: 92810060  stw r20, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[20].u32 ) };
	// 82500418: 92810064  stw r20, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[20].u32 ) };
	// 8250041C: 92410068  stw r18, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[18].u32 ) };
	// 82500420: 4BF69E01  bl 0x8246a220
	ctx.lr = 0x82500424;
	sub_8246A220(ctx, base);
	// 82500424: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82500428: 3BE30001  addi r31, r3, 1
	ctx.r[31].s64 = ctx.r[3].s64 + 1;
	// 8250042C: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82500430: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 82500434: 40980024  bge cr6, 0x82500458
	if !ctx.cr[6].lt {
	pc = 0x82500458; continue 'dispatch;
	}
	// 82500438: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8250043C: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82500440: 41980008  blt cr6, 0x82500448
	if ctx.cr[6].lt {
	pc = 0x82500448; continue 'dispatch;
	}
	// 82500444: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82500448; continue 'dispatch;
            }
            0x82500448 => {
    //   block [0x82500448..0x82500458)
	// 82500448: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8250044C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82500450: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82500454: 4BF6DE75  bl 0x8246e2c8
	ctx.lr = 0x82500458;
	sub_8246E2C8(ctx, base);
	pc = 0x82500458; continue 'dispatch;
            }
            0x82500458 => {
    //   block [0x82500458..0x825004B0)
	// 82500458: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8250045C: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82500460: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82500464: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82500468: 4BF69EC1  bl 0x8246a328
	ctx.lr = 0x8250046C;
	sub_8246A328(ctx, base);
	// 8250046C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82500470: 480283A1  bl 0x82528810
	ctx.lr = 0x82500474;
	sub_82528810(ctx, base);
	// 82500474: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82500478: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8250047C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82500480: 4BF6A7D1  bl 0x8246ac50
	ctx.lr = 0x82500484;
	sub_8246AC50(ctx, base);
	// 82500484: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82500488: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8250048C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82500490: 409A0020  bne cr6, 0x825004b0
	if !ctx.cr[6].eq {
	pc = 0x825004B0; continue 'dispatch;
	}
	// 82500494: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82500498: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8250049C: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 825004A0: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825004A4: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825004A8: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825004AC: 4BF63C0D  bl 0x824640b8
	ctx.lr = 0x825004B0;
	sub_824640B8(ctx, base);
	pc = 0x825004B0; continue 'dispatch;
            }
            0x825004B0 => {
    //   block [0x825004B0..0x82500504)
	// 825004B0: 38A00200  li r5, 0x200
	ctx.r[5].s64 = 512;
	// 825004B4: 388101D0  addi r4, r1, 0x1d0
	ctx.r[4].s64 = ctx.r[1].s64 + 464;
	// 825004B8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825004BC: 4BF6893D  bl 0x82468df8
	ctx.lr = 0x825004C0;
	sub_82468DF8(ctx, base);
	// 825004C0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825004C4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825004C8: 4BF68531  bl 0x824689f8
	ctx.lr = 0x825004CC;
	sub_824689F8(ctx, base);
	// 825004CC: 80799190  lwz r3, -0x6e70(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-28272 as u32) ) } as u64;
	// 825004D0: 39000222  li r8, 0x222
	ctx.r[8].s64 = 546;
	// 825004D4: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 825004D8: 38C101D0  addi r6, r1, 0x1d0
	ctx.r[6].s64 = ctx.r[1].s64 + 464;
	// 825004DC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825004E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825004E4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825004E8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825004EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825004F0: 4E800421  bctrl
	ctx.lr = 0x825004F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825004F4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825004F8: 4BF683E9  bl 0x824688e0
	ctx.lr = 0x825004FC;
	sub_824688E0(ctx, base);
	// 825004FC: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82500500: 7EFBBB78  mr r27, r23
	ctx.r[27].u64 = ctx.r[23].u64;
            }
            0x82500504 => {
    //   block [0x82500504..0x825005B4)
	// 82500504: 81731E34  lwz r11, 0x1e34(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(7732 as u32) ) } as u64;
	// 82500508: 7FFB5A14  add r31, r27, r11
	ctx.r[31].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 8250050C: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 82500510: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82500514: 2F0B0064  cmpwi cr6, r11, 0x64
	ctx.cr[6].compare_i32(ctx.r[11].s32, 100, &mut ctx.xer);
	// 82500518: 4098009C  bge cr6, 0x825005b4
	if !ctx.cr[6].lt {
	pc = 0x825005B4; continue 'dispatch;
	}
	// 8250051C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82500520: 480282F1  bl 0x82528810
	ctx.lr = 0x82500524;
	sub_82528810(ctx, base);
	// 82500524: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82500528: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8250052C: 7D630774  extsb r3, r11
	ctx.r[3].s64 = ctx.r[11].s8 as i64;
	// 82500530: 480282E1  bl 0x82528810
	ctx.lr = 0x82500534;
	sub_82528810(ctx, base);
	// 82500534: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 82500538: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8250053C: 7D630774  extsb r3, r11
	ctx.r[3].s64 = ctx.r[11].s8 as i64;
	// 82500540: 480282D1  bl 0x82528810
	ctx.lr = 0x82500544;
	sub_82528810(ctx, base);
	// 82500544: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 82500548: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 8250054C: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82500550: 7D670774  extsb r7, r11
	ctx.r[7].s64 = ctx.r[11].s8 as i64;
	// 82500554: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82500558: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 8250055C: 388000FF  li r4, 0xff
	ctx.r[4].s64 = 255;
	// 82500560: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82500564: 4BF699DD  bl 0x82469f40
	ctx.lr = 0x82500568;
	sub_82469F40(ctx, base);
	// 82500568: 38A00200  li r5, 0x200
	ctx.r[5].s64 = 512;
	// 8250056C: 388101D0  addi r4, r1, 0x1d0
	ctx.r[4].s64 = ctx.r[1].s64 + 464;
	// 82500570: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82500574: 4BF68885  bl 0x82468df8
	ctx.lr = 0x82500578;
	sub_82468DF8(ctx, base);
	// 82500578: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 8250057C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82500580: 4BF67D21  bl 0x824682a0
	ctx.lr = 0x82500584;
	sub_824682A0(ctx, base);
	// 82500584: 80799190  lwz r3, -0x6e70(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-28272 as u32) ) } as u64;
	// 82500588: 39000231  li r8, 0x231
	ctx.r[8].s64 = 561;
	// 8250058C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82500590: 38C101D0  addi r6, r1, 0x1d0
	ctx.r[6].s64 = ctx.r[1].s64 + 464;
	// 82500594: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82500598: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250059C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825005A0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825005A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825005A8: 4E800421  bctrl
	ctx.lr = 0x825005AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825005AC: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 825005B0: 4BF68331  bl 0x824688e0
	ctx.lr = 0x825005B4;
	sub_824688E0(ctx, base);
            }
            0x825005B4 => {
    //   block [0x825005B4..0x825005F0)
	// 825005B4: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 825005B8: 3B7B0003  addi r27, r27, 3
	ctx.r[27].s64 = ctx.r[27].s64 + 3;
	// 825005BC: 2F1C0020  cmpwi cr6, r28, 0x20
	ctx.cr[6].compare_i32(ctx.r[28].s32, 32, &mut ctx.xer);
	// 825005C0: 4198FF44  blt cr6, 0x82500504
	if ctx.cr[6].lt {
	pc = 0x82500504; continue 'dispatch;
	}
	// 825005C4: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 825005C8: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825005CC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825005D0: 409A0020  bne cr6, 0x825005f0
	if !ctx.cr[6].eq {
	pc = 0x825005F0; continue 'dispatch;
	}
	// 825005D4: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825005D8: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825005DC: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 825005E0: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 825005E4: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825005E8: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825005EC: 4BF63ACD  bl 0x824640b8
	ctx.lr = 0x825005F0;
	sub_824640B8(ctx, base);
	pc = 0x825005F0; continue 'dispatch;
            }
            0x825005F0 => {
    //   block [0x825005F0..0x82500610)
	// 825005F0: 3AF70060  addi r23, r23, 0x60
	ctx.r[23].s64 = ctx.r[23].s64 + 96;
	// 825005F4: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 825005F8: 2F170C03  cmpwi cr6, r23, 0xc03
	ctx.cr[6].compare_i32(ctx.r[23].s32, 3075, &mut ctx.xer);
	// 825005FC: 4198FE14  blt cr6, 0x82500410
	if ctx.cr[6].lt {
	pc = 0x82500410; continue 'dispatch;
	}
	// 82500600: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82500604: 7E96A378  mr r22, r20
	ctx.r[22].u64 = ctx.r[20].u64;
	// 82500608: 3B000003  li r24, 3
	ctx.r[24].s64 = 3;
	// 8250060C: 3AEB44C4  addi r23, r11, 0x44c4
	ctx.r[23].s64 = ctx.r[11].s64 + 17604;
	pc = 0x82500610; continue 'dispatch;
            }
            0x82500610 => {
    //   block [0x82500610..0x82500648)
	// 82500610: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82500614: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 82500618: 92810054  stw r20, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[20].u32 ) };
	// 8250061C: 92410058  stw r18, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[18].u32 ) };
	// 82500620: 4BF69C01  bl 0x8246a220
	ctx.lr = 0x82500624;
	sub_8246A220(ctx, base);
	// 82500624: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82500628: 3BE30001  addi r31, r3, 1
	ctx.r[31].s64 = ctx.r[3].s64 + 1;
	// 8250062C: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82500630: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 82500634: 40980024  bge cr6, 0x82500658
	if !ctx.cr[6].lt {
	pc = 0x82500658; continue 'dispatch;
	}
	// 82500638: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8250063C: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82500640: 41980008  blt cr6, 0x82500648
	if ctx.cr[6].lt {
	pc = 0x82500648; continue 'dispatch;
	}
	// 82500644: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82500648; continue 'dispatch;
            }
            0x82500648 => {
    //   block [0x82500648..0x82500658)
	// 82500648: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8250064C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82500650: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82500654: 4BF6DC75  bl 0x8246e2c8
	ctx.lr = 0x82500658;
	sub_8246E2C8(ctx, base);
	pc = 0x82500658; continue 'dispatch;
            }
            0x82500658 => {
    //   block [0x82500658..0x825006B0)
	// 82500658: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8250065C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82500660: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82500664: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82500668: 4BF69CC1  bl 0x8246a328
	ctx.lr = 0x8250066C;
	sub_8246A328(ctx, base);
	// 8250066C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82500670: 480281A1  bl 0x82528810
	ctx.lr = 0x82500674;
	sub_82528810(ctx, base);
	// 82500674: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82500678: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8250067C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82500680: 4BF6A5D1  bl 0x8246ac50
	ctx.lr = 0x82500684;
	sub_8246AC50(ctx, base);
	// 82500684: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82500688: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8250068C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82500690: 409A0020  bne cr6, 0x825006b0
	if !ctx.cr[6].eq {
	pc = 0x825006B0; continue 'dispatch;
	}
	// 82500694: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82500698: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8250069C: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 825006A0: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825006A4: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825006A8: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825006AC: 4BF63A0D  bl 0x824640b8
	ctx.lr = 0x825006B0;
	sub_824640B8(ctx, base);
	pc = 0x825006B0; continue 'dispatch;
            }
            0x825006B0 => {
    //   block [0x825006B0..0x82500704)
	// 825006B0: 38A00200  li r5, 0x200
	ctx.r[5].s64 = 512;
	// 825006B4: 388101D0  addi r4, r1, 0x1d0
	ctx.r[4].s64 = ctx.r[1].s64 + 464;
	// 825006B8: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 825006BC: 4BF6873D  bl 0x82468df8
	ctx.lr = 0x825006C0;
	sub_82468DF8(ctx, base);
	// 825006C0: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 825006C4: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 825006C8: 4BF68331  bl 0x824689f8
	ctx.lr = 0x825006CC;
	sub_824689F8(ctx, base);
	// 825006CC: 80799190  lwz r3, -0x6e70(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-28272 as u32) ) } as u64;
	// 825006D0: 39000239  li r8, 0x239
	ctx.r[8].s64 = 569;
	// 825006D4: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 825006D8: 38C101D0  addi r6, r1, 0x1d0
	ctx.r[6].s64 = ctx.r[1].s64 + 464;
	// 825006DC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825006E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825006E4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825006E8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825006EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825006F0: 4E800421  bctrl
	ctx.lr = 0x825006F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825006F4: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 825006F8: 4BF681E9  bl 0x824688e0
	ctx.lr = 0x825006FC;
	sub_824688E0(ctx, base);
	// 825006FC: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82500700: 7F1BC378  mr r27, r24
	ctx.r[27].u64 = ctx.r[24].u64;
            }
            0x82500704 => {
    //   block [0x82500704..0x825007B4)
	// 82500704: 81731E30  lwz r11, 0x1e30(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(7728 as u32) ) } as u64;
	// 82500708: 7FFB5A14  add r31, r27, r11
	ctx.r[31].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 8250070C: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 82500710: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82500714: 2F0B0064  cmpwi cr6, r11, 0x64
	ctx.cr[6].compare_i32(ctx.r[11].s32, 100, &mut ctx.xer);
	// 82500718: 4098009C  bge cr6, 0x825007b4
	if !ctx.cr[6].lt {
	pc = 0x825007B4; continue 'dispatch;
	}
	// 8250071C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82500720: 480280F1  bl 0x82528810
	ctx.lr = 0x82500724;
	sub_82528810(ctx, base);
	// 82500724: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82500728: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8250072C: 7D630774  extsb r3, r11
	ctx.r[3].s64 = ctx.r[11].s8 as i64;
	// 82500730: 480280E1  bl 0x82528810
	ctx.lr = 0x82500734;
	sub_82528810(ctx, base);
	// 82500734: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 82500738: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8250073C: 7D630774  extsb r3, r11
	ctx.r[3].s64 = ctx.r[11].s8 as i64;
	// 82500740: 480280D1  bl 0x82528810
	ctx.lr = 0x82500744;
	sub_82528810(ctx, base);
	// 82500744: 897F0002  lbz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 82500748: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 8250074C: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82500750: 7D670774  extsb r7, r11
	ctx.r[7].s64 = ctx.r[11].s8 as i64;
	// 82500754: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82500758: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 8250075C: 388000FF  li r4, 0xff
	ctx.r[4].s64 = 255;
	// 82500760: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82500764: 4BF697DD  bl 0x82469f40
	ctx.lr = 0x82500768;
	sub_82469F40(ctx, base);
	// 82500768: 38A00200  li r5, 0x200
	ctx.r[5].s64 = 512;
	// 8250076C: 388101D0  addi r4, r1, 0x1d0
	ctx.r[4].s64 = ctx.r[1].s64 + 464;
	// 82500770: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82500774: 4BF68685  bl 0x82468df8
	ctx.lr = 0x82500778;
	sub_82468DF8(ctx, base);
	// 82500778: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 8250077C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82500780: 4BF67B21  bl 0x824682a0
	ctx.lr = 0x82500784;
	sub_824682A0(ctx, base);
	// 82500784: 80799190  lwz r3, -0x6e70(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-28272 as u32) ) } as u64;
	// 82500788: 39000248  li r8, 0x248
	ctx.r[8].s64 = 584;
	// 8250078C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82500790: 38C101D0  addi r6, r1, 0x1d0
	ctx.r[6].s64 = ctx.r[1].s64 + 464;
	// 82500794: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82500798: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250079C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825007A0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825007A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825007A8: 4E800421  bctrl
	ctx.lr = 0x825007AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825007AC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825007B0: 4BF68131  bl 0x824688e0
	ctx.lr = 0x825007B4;
	sub_824688E0(ctx, base);
            }
            0x825007B4 => {
    //   block [0x825007B4..0x825007F0)
	// 825007B4: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 825007B8: 3B7B0003  addi r27, r27, 3
	ctx.r[27].s64 = ctx.r[27].s64 + 3;
	// 825007BC: 2F1C0020  cmpwi cr6, r28, 0x20
	ctx.cr[6].compare_i32(ctx.r[28].s32, 32, &mut ctx.xer);
	// 825007C0: 4198FF44  blt cr6, 0x82500704
	if ctx.cr[6].lt {
	pc = 0x82500704; continue 'dispatch;
	}
	// 825007C4: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 825007C8: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825007CC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825007D0: 409A0020  bne cr6, 0x825007f0
	if !ctx.cr[6].eq {
	pc = 0x825007F0; continue 'dispatch;
	}
	// 825007D4: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825007D8: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825007DC: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 825007E0: 80810080  lwz r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 825007E4: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825007E8: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825007EC: 4BF638CD  bl 0x824640b8
	ctx.lr = 0x825007F0;
	sub_824640B8(ctx, base);
	pc = 0x825007F0; continue 'dispatch;
            }
            0x825007F0 => {
    //   block [0x825007F0..0x82500814)
	// 825007F0: 3B180060  addi r24, r24, 0x60
	ctx.r[24].s64 = ctx.r[24].s64 + 96;
	// 825007F4: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 825007F8: 2F180C03  cmpwi cr6, r24, 0xc03
	ctx.cr[6].compare_i32(ctx.r[24].s32, 3075, &mut ctx.xer);
	// 825007FC: 4198FE14  blt cr6, 0x82500610
	if ctx.cr[6].lt {
	pc = 0x82500610; continue 'dispatch;
	}
	// 82500800: 80799190  lwz r3, -0x6e70(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-28272 as u32) ) } as u64;
	// 82500804: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82500808: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 8250080C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82500810: 4E800421  bctrl
	ctx.lr = 0x82500814;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82500814 => {
    //   block [0x82500814..0x8250081C)
	// 82500814: 38210450  addi r1, r1, 0x450
	ctx.r[1].s64 = ctx.r[1].s64 + 1104;
	// 82500818: 480348C8  b 0x825350e0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82500820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82500820 size=100
    let mut pc: u32 = 0x82500820;
    'dispatch: loop {
        match pc {
            0x82500820 => {
    //   block [0x82500820..0x82500868)
	// 82500820: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82500824: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82500828: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8250082C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82500830: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82500834: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82500838: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8250083C: 4BFFF425  bl 0x824ffc60
	ctx.lr = 0x82500840;
	sub_824FFC60(ctx, base);
	// 82500840: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82500844: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82500848: 419A0020  beq cr6, 0x82500868
	if ctx.cr[6].eq {
	pc = 0x82500868; continue 'dispatch;
	}
	// 8250084C: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82500850: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82500854: 38C00027  li r6, 0x27
	ctx.r[6].s64 = 39;
	// 82500858: A0BF0004  lhz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250085C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82500860: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82500864: 4BF63855  bl 0x824640b8
	ctx.lr = 0x82500868;
	sub_824640B8(ctx, base);
	pc = 0x82500868; continue 'dispatch;
            }
            0x82500868 => {
    //   block [0x82500868..0x82500884)
	// 82500868: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250086C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82500870: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82500874: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82500878: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8250087C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82500880: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82500888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82500888 size=184
    let mut pc: u32 = 0x82500888;
    'dispatch: loop {
        match pc {
            0x82500888 => {
    //   block [0x82500888..0x82500930)
	// 82500888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250088C: 48034831  bl 0x825350bc
	ctx.lr = 0x82500890;
	sub_82535080(ctx, base);
	// 82500890: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82500894: 89640005  lbz r11, 5(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(5 as u32) ) } as u64;
	// 82500898: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8250089C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825008A0: 7FCB2214  add r30, r11, r4
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 825008A4: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825008A8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825008AC: 419A0084  beq cr6, 0x82500930
	if ctx.cr[6].eq {
	pc = 0x82500930; continue 'dispatch;
	}
	// 825008B0: 80BF0014  lwz r5, 0x14(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 825008B4: 7F05F040  cmplw cr6, r5, r30
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[30].u32, &mut ctx.xer);
	// 825008B8: 419A0078  beq cr6, 0x82500930
	if ctx.cr[6].eq {
	pc = 0x82500930; continue 'dispatch;
	}
	// 825008BC: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825008C0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825008C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825008C8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825008CC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825008D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825008D4: 4E800421  bctrl
	ctx.lr = 0x825008D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825008D8: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825008DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825008E0: 419A0050  beq cr6, 0x82500930
	if ctx.cr[6].eq {
	pc = 0x82500930; continue 'dispatch;
	}
	// 825008E4: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 825008E8: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 825008EC: 813D000C  lwz r9, 0xc(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 825008F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825008F4: 394A000D  addi r10, r10, 0xd
	ctx.r[10].s64 = ctx.r[10].s64 + 13;
	// 825008F8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 825008FC: 80FF0010  lwz r7, 0x10(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82500900: 554A2834  slwi r10, r10, 5
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82500904: 80DF000C  lwz r6, 0xc(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82500908: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8250090C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82500910: 7D4A58AE  lbzx r10, r10, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82500914: 5549103E  rotlwi r9, r10, 2
	ctx.r[9].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 82500918: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 8250091C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82500920: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82500924: 816B09AC  lwz r11, 0x9ac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2476 as u32) ) } as u64;
	// 82500928: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250092C: 4E800421  bctrl
	ctx.lr = 0x82500930;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82500930 => {
    //   block [0x82500930..0x82500940)
	// 82500930: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82500934: C02B0004  lfs f1, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82500938: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8250093C: 480347D0  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82500940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82500940 size=476
    let mut pc: u32 = 0x82500940;
    'dispatch: loop {
        match pc {
            0x82500940 => {
    //   block [0x82500940..0x82500B1C)
	// 82500940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82500944: 48034759  bl 0x8253509c
	ctx.lr = 0x82500948;
	sub_82535080(ctx, base);
	// 82500948: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82500B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82500B48 size=12
    let mut pc: u32 = 0x82500B48;
    'dispatch: loop {
        match pc {
            0x82500B48 => {
    //   block [0x82500B48..0x82500B54)
	// 82500B48: 3D608282  lis r11, -0x7d7e
	ctx.r[11].s64 = -2105409536;
	// 82500B4C: 386BD24C  addi r3, r11, -0x2db4
	ctx.r[3].s64 = ctx.r[11].s64 + -11700;
	// 82500B50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82500B78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82500B78 size=368
    let mut pc: u32 = 0x82500B78;
    'dispatch: loop {
        match pc {
            0x82500B78 => {
    //   block [0x82500B78..0x82500BCC)
	// 82500B78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82500B7C: 48034541  bl 0x825350bc
	ctx.lr = 0x82500B80;
	sub_82535080(ctx, base);
	// 82500B80: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82500B84: 48035451  bl 0x82535fd4
	ctx.lr = 0x82500B88;
	sub_82535FB0(ctx, base);
	// 82500B88: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82500B8C: 3D60829A  lis r11, -0x7d66
	ctx.r[11].s64 = -2103836672;
	// 82500B90: FF400890  fmr f26, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[26].f64 = ctx.f[1].f64;
	// 82500B94: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 82500B98: FF601090  fmr f27, f2
	ctx.f[27].f64 = ctx.f[2].f64;
	// 82500B9C: 3BAB2380  addi r29, r11, 0x2380
	ctx.r[29].s64 = ctx.r[11].s64 + 9088;
	// 82500BA0: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82500BA4: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82500BA8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82500BAC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82500BB0: C2E72074  lfs f23, 0x2074(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8308 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 82500BB4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82500BB8: C3281850  lfs f25, 0x1850(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(6224 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82500BBC: 3BFD0004  addi r31, r29, 4
	ctx.r[31].s64 = ctx.r[29].s64 + 4;
	// 82500BC0: C3891FF8  lfs f28, 0x1ff8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82500BC4: C3CA2930  lfs f30, 0x2930(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10544 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82500BC8: C30B4598  lfs f24, 0x4598(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17816 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	pc = 0x82500BCC; continue 'dispatch;
            }
            0x82500BCC => {
    //   block [0x82500BCC..0x82500C10)
	// 82500BCC: 7FCB07B4  extsw r11, r30
	ctx.r[11].s64 = ctx.r[30].s32 as i64;
	// 82500BD0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82500BD4: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82500BD8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82500BDC: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82500BE0: EFE0F638  fmsubs f31, f0, f24, f30
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[24].f64 - ctx.f[30].f64) as f32) as f64);
	// 82500BE4: FF1FE000  fcmpu cr6, f31, f28
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[28].f64);
	// 82500BE8: 40980070  bge cr6, 0x82500c58
	if !ctx.cr[6].lt {
	pc = 0x82500C58; continue 'dispatch;
	}
	// 82500BEC: FC00FA10  fabs f0, f31
	ctx.f[0].u64 = ctx.f[31].u64 & !0x8000_0000_0000_0000u64;
	// 82500BF0: D33FFFFC  stfs f25, -4(r31)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82500BF4: D39F0000  stfs f28, 0(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82500BF8: EFBE0028  fsubs f29, f30, f0
	ctx.f[29].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 82500BFC: EFFDD028  fsubs f31, f29, f26
	ctx.f[31].f64 = (((ctx.f[29].f64 - ctx.f[26].f64) as f32) as f64);
	// 82500C00: FF1FD800  fcmpu cr6, f31, f27
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[27].f64);
	// 82500C04: 4099000C  ble cr6, 0x82500c10
	if !ctx.cr[6].gt {
	pc = 0x82500C10; continue 'dispatch;
	}
	// 82500C08: FC20D890  fmr f1, f27
	ctx.f[1].f64 = ctx.f[27].f64;
	// 82500C0C: 48000008  b 0x82500c14
	pc = 0x82500C14; continue 'dispatch;
            }
            0x82500C10 => {
    //   block [0x82500C10..0x82500C14)
	// 82500C10: FC3FE7EE  fsel f1, f31, f31, f28
	ctx.f[1].f64 = if ctx.f[31].f64 >= 0.0 { ctx.f[31].f64 } else { ctx.f[28].f64 };
	pc = 0x82500C14; continue 'dispatch;
            }
            0x82500C14 => {
    //   block [0x82500C14..0x82500C58)
	// 82500C14: 48035715  bl 0x82536328
	ctx.lr = 0x82500C18;
	sub_82536328(ctx, base);
	// 82500C18: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82500C1C: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82500C20: FC3FE7EE  fsel f1, f31, f31, f28
	ctx.f[1].f64 = if ctx.f[31].f64 >= 0.0 { ctx.f[31].f64 } else { ctx.f[28].f64 };
	// 82500C24: 48035705  bl 0x82536328
	ctx.lr = 0x82500C28;
	sub_82536328(ctx, base);
	// 82500C28: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82500C2C: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82500C30: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82500C34: 480356F5  bl 0x82536328
	ctx.lr = 0x82500C38;
	sub_82536328(ctx, base);
	// 82500C38: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 82500C3C: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82500C40: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82500C44: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82500C48: 48035611  bl 0x82536258
	ctx.lr = 0x82500C4C;
	sub_82536258(ctx, base);
	// 82500C4C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82500C50: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82500C54: 48000070  b 0x82500cc4
	pc = 0x82500CC4; continue 'dispatch;
            }
            0x82500C58 => {
    //   block [0x82500C58..0x82500CA8)
	// 82500C58: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82500C5C: 480356CD  bl 0x82536328
	ctx.lr = 0x82500C60;
	sub_82536328(ctx, base);
	// 82500C60: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 82500C64: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82500C68: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82500C6C: D01FFFFC  stfs f0, -4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82500C70: 480355E9  bl 0x82536258
	ctx.lr = 0x82500C74;
	sub_82536258(ctx, base);
	// 82500C74: EFFFD02A  fadds f31, f31, f26
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ((ctx.f[31].f64 + ctx.f[26].f64) as f32) as f64;
	// 82500C78: FC000818  frsp f0, f1
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82500C7C: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82500C80: EC1FF028  fsubs f0, f31, f30
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[30].f64) as f32) as f64);
	// 82500C84: FC20FFAE  fsel f1, f0, f30, f31
	ctx.f[1].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[30].f64 } else { ctx.f[31].f64 };
	// 82500C88: 480356A1  bl 0x82536328
	ctx.lr = 0x82500C8C;
	sub_82536328(ctx, base);
	// 82500C8C: EC1ED828  fsubs f0, f30, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[27].f64) as f32) as f64);
	// 82500C90: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82500C94: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82500C98: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82500C9C: 4098000C  bge cr6, 0x82500ca8
	if !ctx.cr[6].lt {
	pc = 0x82500CA8; continue 'dispatch;
	}
	// 82500CA0: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 82500CA4: 4800000C  b 0x82500cb0
	pc = 0x82500CB0; continue 'dispatch;
            }
            0x82500CA8 => {
    //   block [0x82500CA8..0x82500CB0)
	// 82500CA8: EC1FF028  fsubs f0, f31, f30
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[30].f64) as f32) as f64);
	// 82500CAC: FC20FFAE  fsel f1, f0, f30, f31
	ctx.f[1].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[30].f64 } else { ctx.f[31].f64 };
	pc = 0x82500CB0; continue 'dispatch;
            }
            0x82500CB0 => {
    //   block [0x82500CB0..0x82500CC4)
	// 82500CB0: 48035679  bl 0x82536328
	ctx.lr = 0x82500CB4;
	sub_82536328(ctx, base);
	// 82500CB4: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82500CB8: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82500CBC: D2FF000C  stfs f23, 0xc(r31)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82500CC0: D39F0010  stfs f28, 0x10(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	pc = 0x82500CC4; continue 'dispatch;
            }
            0x82500CC4 => {
    //   block [0x82500CC4..0x82500CE8)
	// 82500CC4: 3BFF0018  addi r31, r31, 0x18
	ctx.r[31].s64 = ctx.r[31].s64 + 24;
	// 82500CC8: 397D02EC  addi r11, r29, 0x2ec
	ctx.r[11].s64 = ctx.r[29].s64 + 748;
	// 82500CCC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82500CD0: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82500CD4: 4198FEF8  blt cr6, 0x82500bcc
	if ctx.cr[6].lt {
	pc = 0x82500BCC; continue 'dispatch;
	}
	// 82500CD8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82500CDC: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82500CE0: 48035341  bl 0x82536020
	ctx.lr = 0x82500CE4;
	sub_82535FFC(ctx, base);
	// 82500CE4: 48034428  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82500CE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82500CE8 size=28
    let mut pc: u32 = 0x82500CE8;
    'dispatch: loop {
        match pc {
            0x82500CE8 => {
    //   block [0x82500CE8..0x82500D04)
	// 82500CE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82500CEC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82500CF0: B1630020  sth r11, 0x20(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u16 ) };
	// 82500CF4: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82500CF8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82500CFC: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82500D00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82500D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82500D08 size=120
    let mut pc: u32 = 0x82500D08;
    'dispatch: loop {
        match pc {
            0x82500D08 => {
    //   block [0x82500D08..0x82500D48)
	// 82500D08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82500D0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82500D10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82500D14: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82500D18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82500D1C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82500D20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82500D24: 419A0048  beq cr6, 0x82500d6c
	if ctx.cr[6].eq {
	pc = 0x82500D6C; continue 'dispatch;
	}
	// 82500D28: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82500D2C: 2F0A000A  cmpwi cr6, r10, 0xa
	ctx.cr[6].compare_i32(ctx.r[10].s32, 10, &mut ctx.xer);
	// 82500D30: 409A0018  bne cr6, 0x82500d48
	if !ctx.cr[6].eq {
	pc = 0x82500D48; continue 'dispatch;
	}
	// 82500D34: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82500D38: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82500D3C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82500D40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82500D44: 4E800421  bctrl
	ctx.lr = 0x82500D48;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82500D48 => {
    //   block [0x82500D48..0x82500D6C)
	// 82500D48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82500D4C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82500D50: 2F0A0008  cmpwi cr6, r10, 8
	ctx.cr[6].compare_i32(ctx.r[10].s32, 8, &mut ctx.xer);
	// 82500D54: 409A0018  bne cr6, 0x82500d6c
	if !ctx.cr[6].eq {
	pc = 0x82500D6C; continue 'dispatch;
	}
	// 82500D58: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82500D5C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82500D60: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82500D64: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82500D68: 4E800421  bctrl
	ctx.lr = 0x82500D6C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82500D6C => {
    //   block [0x82500D6C..0x82500D80)
	// 82500D6C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82500D70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82500D74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82500D78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82500D7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82500D80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82500D80 size=448
    let mut pc: u32 = 0x82500D80;
    'dispatch: loop {
        match pc {
            0x82500D80 => {
    //   block [0x82500D80..0x82500F40)
	// 82500D80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82500D84: 4803432D  bl 0x825350b0
	ctx.lr = 0x82500D88;
	sub_82535080(ctx, base);
	// 82500D88: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82500D8C: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82500D90: D001FFB0  stfs f0, -0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), tmp.u32 ) };
	// 82500D94: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82500D98: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82500D9C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82500DA0: D001FFB4  stfs f0, -0x4c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-76 as u32), tmp.u32 ) };
	// 82500DA4: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82500DA8: D001FFB8  stfs f0, -0x48(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), tmp.u32 ) };
	// 82500DAC: 3961FFB0  addi r11, r1, -0x50
	ctx.r[11].s64 = ctx.r[1].s64 + -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82500F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82500F40 size=1084
    let mut pc: u32 = 0x82500F40;
    'dispatch: loop {
        match pc {
            0x82500F40 => {
    //   block [0x82500F40..0x8250137C)
	// 82500F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82500F44: 4803415D  bl 0x825350a0
	ctx.lr = 0x82500F48;
	sub_82535080(ctx, base);
	// 82500F48: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82500F4C: 48035091  bl 0x82535fdc
	ctx.lr = 0x82500F50;
	sub_82535FB0(ctx, base);
	// 82500F50: 3980FF60  li r12, -0xa0
	ctx.r[12].s64 = -160;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82501380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82501380 size=4
    let mut pc: u32 = 0x82501380;
    'dispatch: loop {
        match pc {
            0x82501380 => {
    //   block [0x82501380..0x82501384)
	// 82501380: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82501388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82501388 size=84
    let mut pc: u32 = 0x82501388;
    'dispatch: loop {
        match pc {
            0x82501388 => {
    //   block [0x82501388..0x825013DC)
	// 82501388: 7C6B1E70  srawi r11, r3, 3
	ctx.xer.ca = (ctx.r[3].s32 < 0) && ((ctx.r[3].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[3].s32 >> 3) as i64;
	// 8250138C: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82501390: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82501394: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82501398: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8250139C: C801FFF0  lfd f0, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825013A0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 825013A4: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 825013A8: C00B8E30  lfs f0, -0x71d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825013AC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825013B0: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 825013B4: C00B45C0  lfs f0, 0x45c0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17856 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825013B8: 3D608282  lis r11, -0x7d7e
	ctx.r[11].s64 = -2105409536;
	// 825013BC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825013C0: D00BD258  stfs f0, -0x2da8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-11688 as u32), tmp.u32 ) };
	// 825013C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825013C8: C1AB1850  lfs f13, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825013CC: 3D608282  lis r11, -0x7d7e
	ctx.r[11].s64 = -2105409536;
	// 825013D0: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 825013D4: D00BD25C  stfs f0, -0x2da4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-11684 as u32), tmp.u32 ) };
	// 825013D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825013E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825013E0 size=8
    let mut pc: u32 = 0x825013E0;
    'dispatch: loop {
        match pc {
            0x825013E0 => {
    //   block [0x825013E0..0x825013E8)
	// 825013E0: C0230014  lfs f1, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825013E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825013E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825013E8 size=8
    let mut pc: u32 = 0x825013E8;
    'dispatch: loop {
        match pc {
            0x825013E8 => {
    //   block [0x825013E8..0x825013F0)
	// 825013E8: 38600012  li r3, 0x12
	ctx.r[3].s64 = 18;
	// 825013EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825013F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825013F0 size=96
    let mut pc: u32 = 0x825013F0;
    'dispatch: loop {
        match pc {
            0x825013F0 => {
    //   block [0x825013F0..0x82501450)
	// 825013F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825013F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825013F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825013FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82501400: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82501404: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82501408: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8250140C: 388B45C4  addi r4, r11, 0x45c4
	ctx.r[4].s64 = ctx.r[11].s64 + 17860;
	// 82501410: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82501414: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82501418: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250141C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82501420: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82501424: 4E800421  bctrl
	ctx.lr = 0x82501428;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82501428: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250142C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82501430: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82501434: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82501438: 4E800421  bctrl
	ctx.lr = 0x8250143C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250143C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82501440: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82501444: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82501448: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8250144C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82501450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82501450 size=72
    let mut pc: u32 = 0x82501450;
    'dispatch: loop {
        match pc {
            0x82501450 => {
    //   block [0x82501450..0x82501468)
	// 82501450: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82501454: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82501458: C02B1FF8  lfs f1, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8250145C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82501460: C1AA2278  lfs f13, 0x2278(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8824 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82501464: C00B20B0  lfs f0, 0x20b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8368 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82501468; continue 'dispatch;
            }
            0x82501468 => {
    //   block [0x82501468..0x82501498)
	// 82501468: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 8250146C: FD80081E  fctiwz f12, f1
	ctx.f[12].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 82501470: 7D805FAE  stfiwx f12, 0, r11
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82501474: 8161FFF0  lwz r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82501478: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8250147C: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 82501480: EC21002A  fadds f1, f1, f0
	ctx.f[1].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82501484: FF016800  fcmpu cr6, f1, f13
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[13].f64);
	// 82501488: 4198FFE0  blt cr6, 0x82501468
	if ctx.cr[6].lt {
	pc = 0x82501468; continue 'dispatch;
	}
	// 8250148C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82501490: C02B1850  lfs f1, 0x1850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82501494: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82501498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82501498 size=292
    let mut pc: u32 = 0x82501498;
    'dispatch: loop {
        match pc {
            0x82501498 => {
    //   block [0x82501498..0x825015BC)
	// 82501498: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 8250149C: 38C00030  li r6, 0x30
	ctx.r[6].s64 = 48;
	// 825014A0: 39630040  addi r11, r3, 0x40
	ctx.r[11].s64 = ctx.r[3].s64 + 64;
	// 825014A4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825014A8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825015C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825015C0 size=32
    let mut pc: u32 = 0x825015C0;
    'dispatch: loop {
        match pc {
            0x825015C0 => {
    //   block [0x825015C0..0x825015E0)
	// 825015C0: C0030010  lfs f0, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825015C4: EC00082A  fadds f0, f0, f1
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 825015C8: D0230014  stfs f1, 0x14(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 825015CC: D003002C  stfs f0, 0x2c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 825015D0: C0030010  lfs f0, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825015D4: EC00082A  fadds f0, f0, f1
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 825015D8: D003003C  stfs f0, 0x3c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 825015DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825015E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825015E0 size=568
    let mut pc: u32 = 0x825015E0;
    'dispatch: loop {
        match pc {
            0x825015E0 => {
    //   block [0x825015E0..0x82501818)
	// 825015E0: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82501818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82501818 size=276
    let mut pc: u32 = 0x82501818;
    'dispatch: loop {
        match pc {
            0x82501818 => {
    //   block [0x82501818..0x82501898)
	// 82501818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250181C: 48033899  bl 0x825350b4
	ctx.lr = 0x82501820;
	sub_82535080(ctx, base);
	// 82501820: 3945FFFF  addi r10, r5, -1
	ctx.r[10].s64 = ctx.r[5].s64 + -1;
	// 82501824: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82501828: 41980100  blt cr6, 0x82501928
	if ctx.cr[6].lt {
	pc = 0x82501928; continue 'dispatch;
	}
	// 8250182C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82501830: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82501834: 38A30014  addi r5, r3, 0x14
	ctx.r[5].s64 = ctx.r[3].s64 + 20;
	// 82501838: 3BE30050  addi r31, r3, 0x50
	ctx.r[31].s64 = ctx.r[3].s64 + 80;
	// 8250183C: 3BC30040  addi r30, r3, 0x40
	ctx.r[30].s64 = ctx.r[3].s64 + 64;
	// 82501840: C1491850  lfs f10, 0x1850(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(6224 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82501844: 3FA08282  lis r29, -0x7d7e
	ctx.r[29].s64 = -2105409536;
	// 82501848: C16BBFFC  lfs f11, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8250184C: A1640000  lhz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82501850: 557C073E  clrlwi r28, r11, 0x1c
	ctx.r[28].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 82501854: 557B06F6  rlwinm r27, r11, 0, 0x1b, 0x1b
	ctx.r[27].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82501858: 5569CFFE  rlwinm r9, r11, 0x19, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 8250185C: 5568D7FE  rlwinm r8, r11, 0x1a, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82501860: 5567DFFE  rlwinm r7, r11, 0x1b, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82501864: FB81FFC8  std r28, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.r[28].u64 ) };
	// 82501868: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8250186C: C801FFC8  lfd f0, -0x38(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82501870: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82501874: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82501878: EDA0582A  fadds f13, f0, f11
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 8250187C: C01DD25C  lfs f0, -0x2da4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-11684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82501880: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82501884: EDA0503C  fnmsubs f13, f0, f0, f10
	ctx.f[13].f64 = -(((ctx.f[0].f64 * ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 82501888: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 8250188C: 419A000C  beq cr6, 0x82501898
	if ctx.cr[6].eq {
	pc = 0x82501898; continue 'dispatch;
	}
	// 82501890: FD806890  fmr f12, f13
	ctx.f[12].f64 = ctx.f[13].f64;
	// 82501894: 4800000C  b 0x825018a0
	pc = 0x825018A0; continue 'dispatch;
            }
            0x82501898 => {
    //   block [0x82501898..0x825018A0)
	// 82501898: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	// 8250189C: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x825018A0; continue 'dispatch;
            }
            0x825018A0 => {
    //   block [0x825018A0..0x825018B8)
	// 825018A0: D001FFC0  stfs f0, -0x40(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), tmp.u32 ) };
	// 825018A4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 825018A8: D181FFC4  stfs f12, -0x3c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-60 as u32), tmp.u32 ) };
	// 825018AC: 409A000C  bne cr6, 0x825018b8
	if !ctx.cr[6].eq {
	pc = 0x825018B8; continue 'dispatch;
	}
	// 825018B0: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 825018B4: D001FFC0  stfs f0, -0x40(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), tmp.u32 ) };
	pc = 0x825018B8; continue 'dispatch;
            }
            0x825018B8 => {
    //   block [0x825018B8..0x825018C8)
	// 825018B8: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 825018BC: 409A000C  bne cr6, 0x825018c8
	if !ctx.cr[6].eq {
	pc = 0x825018C8; continue 'dispatch;
	}
	// 825018C0: FC006050  fneg f0, f12
	ctx.f[0].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 825018C4: D001FFC4  stfs f0, -0x3c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-60 as u32), tmp.u32 ) };
	pc = 0x825018C8; continue 'dispatch;
            }
            0x825018C8 => {
    //   block [0x825018C8..0x82501928)
	// 825018C8: 3901FFC0  addi r8, r1, -0x40
	ctx.r[8].s64 = ctx.r[1].s64 + -64;
	pc = 0x82501928; continue 'dispatch;
            }
            0x82501928 => {
    //   block [0x82501928..0x8250192C)
	// 82501928: 480337DC  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82501930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82501930 size=56
    let mut pc: u32 = 0x82501930;
    'dispatch: loop {
        match pc {
            0x82501930 => {
    //   block [0x82501930..0x82501968)
	// 82501930: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82501934: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 82501938: 3921FFF0  addi r9, r1, -0x10
	ctx.r[9].s64 = ctx.r[1].s64 + -16;
	// 8250193C: C00BBFFC  lfs f0, -0x4004(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82501940: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82501968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82501968 size=16
    let mut pc: u32 = 0x82501968;
    'dispatch: loop {
        match pc {
            0x82501968 => {
    //   block [0x82501968..0x82501978)
	// 82501968: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82501978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82501978 size=592
    let mut pc: u32 = 0x82501978;
    'dispatch: loop {
        match pc {
            0x82501978 => {
    //   block [0x82501978..0x82501BC8)
	// 82501978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250197C: 48033729  bl 0x825350a4
	ctx.lr = 0x82501980;
	sub_82535080(ctx, base);
	// 82501980: 39430020  addi r10, r3, 0x20
	ctx.r[10].s64 = ctx.r[3].s64 + 32;
	// 82501984: C0030014  lfs f0, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82501988: 39230030  addi r9, r3, 0x30
	ctx.r[9].s64 = ctx.r[3].s64 + 48;
	// 8250198C: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82501990: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82501994: D001FF90  stfs f0, -0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82501BC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82501BC8 size=184
    let mut pc: u32 = 0x82501BC8;
    'dispatch: loop {
        match pc {
            0x82501BC8 => {
    //   block [0x82501BC8..0x82501C2C)
	// 82501BC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82501BCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82501BD0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82501BD4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82501BD8: D0430010  stfs f2, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82501BDC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82501BE0: FD600890  fmr f11, f1
	ctx.f[11].f64 = ctx.f[1].f64;
	// 82501BE4: 396B45D4  addi r11, r11, 0x45d4
	ctx.r[11].s64 = ctx.r[11].s64 + 17876;
	// 82501BE8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82501BEC: 39000003  li r8, 3
	ctx.r[8].s64 = 3;
	// 82501BF0: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82501BF4: 3D208282  lis r9, -0x7d7e
	ctx.r[9].s64 = -2105409536;
	// 82501BF8: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82501BFC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82501C00: B1430006  sth r10, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 82501C04: 9103000C  stw r8, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82501C08: C009D260  lfs f0, -0x2da0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-11680 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82501C0C: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82501C10: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82501C14: 40980018  bge cr6, 0x82501c2c
	if !ctx.cr[6].lt {
	pc = 0x82501C2C; continue 'dispatch;
	}
	// 82501C18: 4BFFF839  bl 0x82501450
	ctx.lr = 0x82501C1C;
	sub_82501450(ctx, base);
	// 82501C1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82501C20: C00B1850  lfs f0, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82501C24: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82501C28: D009D260  stfs f0, -0x2da0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-11680 as u32), tmp.u32 ) };
	pc = 0x82501C2C; continue 'dispatch;
            }
            0x82501C2C => {
    //   block [0x82501C2C..0x82501C80)
	// 82501C2C: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82501C80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82501C80 size=112
    let mut pc: u32 = 0x82501C80;
    'dispatch: loop {
        match pc {
            0x82501C80 => {
    //   block [0x82501C80..0x82501CD8)
	// 82501C80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82501C84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82501C88: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82501C8C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82501C90: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82501C94: 396B45D4  addi r11, r11, 0x45d4
	ctx.r[11].s64 = ctx.r[11].s64 + 17876;
	// 82501C98: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82501C9C: B1430006  sth r10, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 82501CA0: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82501CA4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82501CA8: 419A0030  beq cr6, 0x82501cd8
	if ctx.cr[6].eq {
	pc = 0x82501CD8; continue 'dispatch;
	}
	// 82501CAC: 3D208282  lis r9, -0x7d7e
	ctx.r[9].s64 = -2105409536;
	// 82501CB0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82501CB4: C009D260  lfs f0, -0x2da0(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-11680 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82501CB8: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82501CBC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82501CC0: 40980018  bge cr6, 0x82501cd8
	if !ctx.cr[6].lt {
	pc = 0x82501CD8; continue 'dispatch;
	}
	// 82501CC4: 4BFFF78D  bl 0x82501450
	ctx.lr = 0x82501CC8;
	sub_82501450(ctx, base);
	// 82501CC8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82501CCC: C00B1850  lfs f0, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82501CD0: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82501CD4: D009D260  stfs f0, -0x2da0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-11680 as u32), tmp.u32 ) };
	pc = 0x82501CD8; continue 'dispatch;
            }
            0x82501CD8 => {
    //   block [0x82501CD8..0x82501CF0)
	// 82501CD8: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82501CDC: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82501CE0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82501CE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82501CE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82501CEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82501CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82501CF0 size=436
    let mut pc: u32 = 0x82501CF0;
    'dispatch: loop {
        match pc {
            0x82501CF0 => {
    //   block [0x82501CF0..0x82501EA4)
	// 82501CF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82501CF4: 480333B5  bl 0x825350a8
	ctx.lr = 0x82501CF8;
	sub_82535080(ctx, base);
	// 82501CF8: 39640010  addi r11, r4, 0x10
	ctx.r[11].s64 = ctx.r[4].s64 + 16;
	// 82501CFC: EB640000  ld r27, 0(r4)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	// 82501D00: 39440020  addi r10, r4, 0x20
	ctx.r[10].s64 = ctx.r[4].s64 + 32;
	// 82501D04: 39240030  addi r9, r4, 0x30
	ctx.r[9].s64 = ctx.r[4].s64 + 48;
	// 82501D08: E8840008  ld r4, 8(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	// 82501D0C: 3901FF60  addi r8, r1, -0xa0
	ctx.r[8].s64 = ctx.r[1].s64 + -160;
	// 82501D10: 38E1FF70  addi r7, r1, -0x90
	ctx.r[7].s64 = ctx.r[1].s64 + -144;
	// 82501D14: EB4B0000  ld r26, 0(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82501D18: 38A1FF80  addi r5, r1, -0x80
	ctx.r[5].s64 = ctx.r[1].s64 + -128;
	// 82501D1C: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82501D20: 3BE1FF90  addi r31, r1, -0x70
	ctx.r[31].s64 = ctx.r[1].s64 + -112;
	// 82501D24: EB2A0000  ld r25, 0(r10)
	ctx.r[25].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 82501D28: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82501D2C: FB680000  std r27, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[27].u64 ) };
	// 82501D30: 3B81FFA0  addi r28, r1, -0x60
	ctx.r[28].s64 = ctx.r[1].s64 + -96;
	// 82501D34: F8880008  std r4, 8(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[4].u64 ) };
	// 82501D38: 3BA30030  addi r29, r3, 0x30
	ctx.r[29].s64 = ctx.r[3].s64 + 48;
	// 82501D3C: FB470000  std r26, 0(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[26].u64 ) };
	// 82501D40: F9670008  std r11, 8(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82501D44: 3961FF60  addi r11, r1, -0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + -160;
	// 82501D48: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 82501D4C: FB250000  std r25, 0(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[25].u64 ) };
	// 82501D50: EB090000  ld r24, 0(r9)
	ctx.r[24].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 82501D54: E9290008  ld r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82501EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82501EA8 size=1420
    let mut pc: u32 = 0x82501EA8;
    'dispatch: loop {
        match pc {
            0x82501EA8 => {
    //   block [0x82501EA8..0x82501F08)
	// 82501EA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82501EAC: 48033209  bl 0x825350b4
	ctx.lr = 0x82501EB0;
	sub_82535080(ctx, base);
	// 82501EB0: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 82501EB4: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82501EB8: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82501EBC: 812D0000  lwz r9, 0(r13)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82501EC0: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82501EC4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82501EC8: 7FAA4A14  add r29, r10, r9
	ctx.r[29].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82501ECC: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82501ED0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82501ED4: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82501ED8: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82501EDC: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82501EE0: 810A000C  lwz r8, 0xc(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82501EE4: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82501EE8: 40980020  bge cr6, 0x82501f08
	if !ctx.cr[6].lt {
	pc = 0x82501F08; continue 'dispatch;
	}
	// 82501EEC: 3D008206  lis r8, -0x7dfa
	ctx.r[8].s64 = -2113536000;
	// 82501EF0: 39084614  addi r8, r8, 0x4614
	ctx.r[8].s64 = ctx.r[8].s64 + 17940;
	// 82501EF4: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82501EF8: 7D0C42E6  mftb r8, 0x10c
	ctx.r[8].u64 = crate::rt::rdtsc_u64();
	// 82501EFC: 38E9000C  addi r7, r9, 0xc
	ctx.r[7].s64 = ctx.r[9].s64 + 12;
	// 82501F00: 91090004  stw r8, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82501F04: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	pc = 0x82501F08; continue 'dispatch;
            }
            0x82501F08 => {
    //   block [0x82501F08..0x82502434)
	// 82501F08: 394B0040  addi r10, r11, 0x40
	ctx.r[10].s64 = ctx.r[11].s64 + 64;
	// 82501F0C: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82501F10: 392B0050  addi r9, r11, 0x50
	ctx.r[9].s64 = ctx.r[11].s64 + 80;
	// 82501F14: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82501F18: 390B0010  addi r8, r11, 0x10
	ctx.r[8].s64 = ctx.r[11].s64 + 16;
	// 82501F1C: EFE0682A  fadds f31, f0, f13
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82501F20: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 82501F24: 3B800030  li r28, 0x30
	ctx.r[28].s64 = 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82502438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82502438 size=160
    let mut pc: u32 = 0x82502438;
    'dispatch: loop {
        match pc {
            0x82502438 => {
    //   block [0x82502438..0x82502454)
	// 82502438: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 8250243C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82502440: 419A0014  beq cr6, 0x82502454
	if ctx.cr[6].eq {
	pc = 0x82502454; continue 'dispatch;
	}
	// 82502444: C004001C  lfs f0, 0x1c(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82502448: C1A3002C  lfs f13, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8250244C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82502450: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	pc = 0x82502454; continue 'dispatch;
            }
            0x82502454 => {
    //   block [0x82502454..0x825024D8)
	// 82502454: 39630010  addi r11, r3, 0x10
	ctx.r[11].s64 = ctx.r[3].s64 + 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825024D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825024D8 size=4
    let mut pc: u32 = 0x825024D8;
    'dispatch: loop {
        match pc {
            0x825024D8 => {
    //   block [0x825024D8..0x825024DC)
	// 825024D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825024E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825024E0 size=8
    let mut pc: u32 = 0x825024E0;
    'dispatch: loop {
        match pc {
            0x825024E0 => {
    //   block [0x825024E0..0x825024E8)
	// 825024E0: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 825024E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825024E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825024E8 size=260
    let mut pc: u32 = 0x825024E8;
    'dispatch: loop {
        match pc {
            0x825024E8 => {
    //   block [0x825024E8..0x825025EC)
	// 825024E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825024EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825024F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825024F4: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825024F8: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 825024FC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82502500: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82502504: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82502508: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825025F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825025F0 size=8
    let mut pc: u32 = 0x825025F0;
    'dispatch: loop {
        match pc {
            0x825025F0 => {
    //   block [0x825025F0..0x825025F8)
	// 825025F0: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 825025F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825025F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825025F8 size=108
    let mut pc: u32 = 0x825025F8;
    'dispatch: loop {
        match pc {
            0x825025F8 => {
    //   block [0x825025F8..0x82502664)
	// 825025F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825025FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82502600: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82502604: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82502608: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250260C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82502610: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82502614: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82502618: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250261C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82502620: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82502624: 4E800421  bctrl
	ctx.lr = 0x82502628;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82502628: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82502668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82502668 size=128
    let mut pc: u32 = 0x82502668;
    'dispatch: loop {
        match pc {
            0x82502668 => {
    //   block [0x82502668..0x825026E8)
	// 82502668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250266C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82502670: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82502674: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82502678: 3D608283  lis r11, -0x7d7d
	ctx.r[11].s64 = -2105344000;
	// 8250267C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82502680: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82502684: 388B2690  addi r4, r11, 0x2690
	ctx.r[4].s64 = ctx.r[11].s64 + 9872;
	// 82502688: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8250268C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82502690: C02B1FF8  lfs f1, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82502694: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82502698: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250269C: 4E800421  bctrl
	ctx.lr = 0x825026A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825026A0: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 825026A4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825026E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825026E8 size=220
    let mut pc: u32 = 0x825026E8;
    'dispatch: loop {
        match pc {
            0x825026E8 => {
    //   block [0x825026E8..0x825027AC)
	// 825026E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825026EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825026F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825026F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825026F8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825026FC: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82502700: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82502704: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82502708: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8250270C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82502710: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82502714: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 82502718: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8250271C: C01F0004  lfs f0, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82502720: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82502724: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82502728: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 8250272C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82502730: 914100A0  stw r10, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 82502734: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82502738: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 8250273C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82502740: 4E800421  bctrl
	ctx.lr = 0x82502744;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82502744: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82502748: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8250274C: 419A0060  beq cr6, 0x825027ac
	if ctx.cr[6].eq {
	pc = 0x825027AC; continue 'dispatch;
	}
	// 82502750: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82502754: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82502758: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 8250275C: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82502760: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82502764: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82502768: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            0x825027AC => {
    //   block [0x825027AC..0x825027C4)
	// 825027AC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 825027B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825027B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825027B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825027BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825027C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825027C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825027C8 size=8
    let mut pc: u32 = 0x825027C8;
    'dispatch: loop {
        match pc {
            0x825027C8 => {
    //   block [0x825027C8..0x825027D0)
	// 825027C8: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 825027CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825027D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825027D0 size=96
    let mut pc: u32 = 0x825027D0;
    'dispatch: loop {
        match pc {
            0x825027D0 => {
    //   block [0x825027D0..0x82502830)
	// 825027D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825027D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825027D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825027DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825027E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825027E4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825027E8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825027EC: 388B4650  addi r4, r11, 0x4650
	ctx.r[4].s64 = ctx.r[11].s64 + 18000;
	// 825027F0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825027F4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825027F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825027FC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82502800: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82502804: 4E800421  bctrl
	ctx.lr = 0x82502808;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82502808: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250280C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82502810: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82502814: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82502818: 4E800421  bctrl
	ctx.lr = 0x8250281C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250281C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82502820: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82502824: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82502828: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8250282C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82502830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82502830 size=76
    let mut pc: u32 = 0x82502830;
    'dispatch: loop {
        match pc {
            0x82502830 => {
    //   block [0x82502830..0x8250287C)
	// 82502830: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250287C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8250287C size=20
    let mut pc: u32 = 0x8250287C;
    'dispatch: loop {
        match pc {
            0x8250287C => {
    //   block [0x8250287C..0x82502890)
	// 8250287C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82502890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82502890 size=60
    let mut pc: u32 = 0x82502890;
    'dispatch: loop {
        match pc {
            0x82502890 => {
    //   block [0x82502890..0x825028CC)
	// 82502890: 3965FFFF  addi r11, r5, -1
	ctx.r[11].s64 = ctx.r[5].s64 + -1;
	// 82502894: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82502898: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 8250289C: 39230020  addi r9, r3, 0x20
	ctx.r[9].s64 = ctx.r[3].s64 + 32;
	// 825028A0: A1440000  lhz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825028A4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825028A8: 38840002  addi r4, r4, 2
	ctx.r[4].s64 = ctx.r[4].s64 + 2;
	// 825028AC: 65483F00  oris r8, r10, 0x3f00
	ctx.r[8].u64 = ctx.r[10].u64 | 1056964608;
	// 825028B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825028D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825028D0 size=56
    let mut pc: u32 = 0x825028D0;
    'dispatch: loop {
        match pc {
            0x825028D0 => {
    //   block [0x825028D0..0x82502908)
	// 825028D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825028D4: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 825028D8: 3921FFF0  addi r9, r1, -0x10
	ctx.r[9].s64 = ctx.r[1].s64 + -16;
	// 825028DC: C00BBFFC  lfs f0, -0x4004(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825028E0: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82502908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82502908 size=16
    let mut pc: u32 = 0x82502908;
    'dispatch: loop {
        match pc {
            0x82502908 => {
    //   block [0x82502908..0x82502918)
	// 82502908: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82502918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82502918 size=40
    let mut pc: u32 = 0x82502918;
    'dispatch: loop {
        match pc {
            0x82502918 => {
    //   block [0x82502918..0x82502940)
	// 82502918: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8250291C: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 82502920: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 82502924: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82502928: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82502940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82502940 size=272
    let mut pc: u32 = 0x82502940;
    'dispatch: loop {
        match pc {
            0x82502940 => {
    //   block [0x82502940..0x82502A50)
	// 82502940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82502944: 48032775  bl 0x825350b8
	ctx.lr = 0x82502948;
	sub_82535080(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82502A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82502A50 size=76
    let mut pc: u32 = 0x82502A50;
    'dispatch: loop {
        match pc {
            0x82502A50 => {
    //   block [0x82502A50..0x82502A9C)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82502AD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82502AD0 size=76
    let mut pc: u32 = 0x82502AD0;
    'dispatch: loop {
        match pc {
            0x82502AD0 => {
    //   block [0x82502AD0..0x82502B1C)
	// 82502AD0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82502AD4: D0230010  stfs f1, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82502AD8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82502ADC: 396B291C  addi r11, r11, 0x291c
	ctx.r[11].s64 = ctx.r[11].s64 + 10524;
	// 82502AE0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82502AE4: 39000006  li r8, 6
	ctx.r[8].s64 = 6;
	// 82502AE8: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 82502AEC: 38C00030  li r6, 0x30
	ctx.r[6].s64 = 48;
	// 82502AF0: B1430006  sth r10, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 82502AF4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82502AF8: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82502AFC: 9103000C  stw r8, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82502B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82502B20 size=276
    let mut pc: u32 = 0x82502B20;
    'dispatch: loop {
        match pc {
            0x82502B20 => {
    //   block [0x82502B20..0x82502C34)
	// 82502B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82502B24: 48032589  bl 0x825350ac
	ctx.lr = 0x82502B28;
	sub_82535080(ctx, base);
	// 82502B28: C0030010  lfs f0, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82502B2C: 39640010  addi r11, r4, 0x10
	ctx.r[11].s64 = ctx.r[4].s64 + 16;
	// 82502B30: EC00082A  fadds f0, f0, f1
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 82502B34: D001FF60  stfs f0, -0xa0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), tmp.u32 ) };
	// 82502B38: 3B81FF60  addi r28, r1, -0xa0
	ctx.r[28].s64 = ctx.r[1].s64 + -160;
	// 82502B3C: 39440020  addi r10, r4, 0x20
	ctx.r[10].s64 = ctx.r[4].s64 + 32;
	// 82502B40: 39240030  addi r9, r4, 0x30
	ctx.r[9].s64 = ctx.r[4].s64 + 48;
	// 82502B44: EB6B0000  ld r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82502B48: 3901FF70  addi r8, r1, -0x90
	ctx.r[8].s64 = ctx.r[1].s64 + -144;
	// 82502B4C: 38E1FF80  addi r7, r1, -0x80
	ctx.r[7].s64 = ctx.r[1].s64 + -128;
	// 82502B50: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82502C38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82502C38 size=1092
    let mut pc: u32 = 0x82502C38;
    'dispatch: loop {
        match pc {
            0x82502C38 => {
    //   block [0x82502C38..0x82502C90)
	// 82502C38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82502C3C: 4803246D  bl 0x825350a8
	ctx.lr = 0x82502C40;
	sub_82535080(ctx, base);
	// 82502C40: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82502C44: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82502C48: 39600014  li r11, 0x14
	ctx.r[11].s64 = 20;
	// 82502C4C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82502C50: 7F4B5214  add r26, r11, r10
	ctx.r[26].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82502C54: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82502C58: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82502C5C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82502C60: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82502C64: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82502C68: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82502C6C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82502C70: 40980020  bge cr6, 0x82502c90
	if !ctx.cr[6].lt {
	pc = 0x82502C90; continue 'dispatch;
	}
	// 82502C74: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 82502C78: 39294660  addi r9, r9, 0x4660
	ctx.r[9].s64 = ctx.r[9].s64 + 18016;
	// 82502C7C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82502C80: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 82502C84: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 82502C88: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82502C8C: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x82502C90; continue 'dispatch;
            }
            0x82502C90 => {
    //   block [0x82502C90..0x8250307C)
	// 82502C90: 3BBB0030  addi r29, r27, 0x30
	ctx.r[29].s64 = ctx.r[27].s64 + 48;
	// 82502C94: 3BDB0020  addi r30, r27, 0x20
	ctx.r[30].s64 = ctx.r[27].s64 + 32;
	// 82502C98: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82502C9C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82502CA0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82502CA4: 4BFFFDAD  bl 0x82502a50
	ctx.lr = 0x82502CA8;
	sub_82502A50(ctx, base);
	// 82502CA8: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82503080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82503080 size=8
    let mut pc: u32 = 0x82503080;
    'dispatch: loop {
        match pc {
            0x82503080 => {
    //   block [0x82503080..0x82503088)
	// 82503080: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82503084: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82503088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82503088 size=116
    let mut pc: u32 = 0x82503088;
    'dispatch: loop {
        match pc {
            0x82503088 => {
    //   block [0x82503088..0x825030BC)
	// 82503088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250308C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82503090: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82503094: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82503098: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250309C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825030A0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825030A4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825030A8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825030AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825030B0: 4E800421  bctrl
	ctx.lr = 0x825030B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825030B4: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 825030B8: 419A0028  beq cr6, 0x825030e0
	if ctx.cr[6].eq {
	pc = 0x825030E0; continue 'dispatch;
	}
            }
            0x825030BC => {
    //   block [0x825030BC..0x825030E0)
	// 825030BC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825030C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825030C4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 825030C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825030CC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825030D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825030D4: 4E800421  bctrl
	ctx.lr = 0x825030D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825030D8: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 825030DC: 409AFFE0  bne cr6, 0x825030bc
	if !ctx.cr[6].eq {
	pc = 0x825030BC; continue 'dispatch;
	}
            }
            0x825030E0 => {
    //   block [0x825030E0..0x825030FC)
	// 825030E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825030E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825030E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825030EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825030F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825030F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825030F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82503100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82503100 size=8
    let mut pc: u32 = 0x82503100;
    'dispatch: loop {
        match pc {
            0x82503100 => {
    //   block [0x82503100..0x82503108)
	// 82503100: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82503104: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82503108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82503108 size=144
    let mut pc: u32 = 0x82503108;
    'dispatch: loop {
        match pc {
            0x82503108 => {
    //   block [0x82503108..0x82503198)
	// 82503108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250310C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82503110: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82503114: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82503118: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250311C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82503120: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82503124: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82503128: 388B4678  addi r4, r11, 0x4678
	ctx.r[4].s64 = ctx.r[11].s64 + 18040;
	// 8250312C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82503130: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82503134: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82503138: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250313C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82503140: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82503144: 4E800421  bctrl
	ctx.lr = 0x82503148;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82503148: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250314C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82503150: 80DE0014  lwz r6, 0x14(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82503154: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82503158: 388B466C  addi r4, r11, 0x466c
	ctx.r[4].s64 = ctx.r[11].s64 + 18028;
	// 8250315C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82503160: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82503164: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82503168: 4E800421  bctrl
	ctx.lr = 0x8250316C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250316C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82503170: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82503174: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82503178: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250317C: 4E800421  bctrl
	ctx.lr = 0x82503180;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82503180: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82503184: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82503188: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8250318C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82503190: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82503194: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82503198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82503198 size=8
    let mut pc: u32 = 0x82503198;
    'dispatch: loop {
        match pc {
            0x82503198 => {
    //   block [0x82503198..0x825031A0)
	// 82503198: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 8250319C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825031A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825031A0 size=60
    let mut pc: u32 = 0x825031A0;
    'dispatch: loop {
        match pc {
            0x825031A0 => {
    //   block [0x825031A0..0x825031DC)
	// 825031A0: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 825031A4: 38830030  addi r4, r3, 0x30
	ctx.r[4].s64 = ctx.r[3].s64 + 48;
	// 825031A8: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 825031AC: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 825031B0: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825031E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825031E0 size=176
    let mut pc: u32 = 0x825031E0;
    'dispatch: loop {
        match pc {
            0x825031E0 => {
    //   block [0x825031E0..0x82503240)
	// 825031E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825031E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825031E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825031EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825031F0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825031F4: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 825031F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825031FC: 396B2A8C  addi r11, r11, 0x2a8c
	ctx.r[11].s64 = ctx.r[11].s64 + 10892;
	// 82503200: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82503204: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82503208: 38E0001C  li r7, 0x1c
	ctx.r[7].s64 = 28;
	// 8250320C: 394A2A68  addi r10, r10, 0x2a68
	ctx.r[10].s64 = ctx.r[10].s64 + 10856;
	// 82503210: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82503214: B13F0006  sth r9, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 82503218: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 8250321C: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82503220: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82503224: 909F0014  stw r4, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[4].u32 ) };
	// 82503228: A1640004  lhz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250322C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82503230: 419A0010  beq cr6, 0x82503240
	if ctx.cr[6].eq {
	pc = 0x82503240; continue 'dispatch;
	}
	// 82503234: A1640006  lhz r11, 6(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(6 as u32) ) } as u64;
	// 82503238: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8250323C: B1640006  sth r11, 6(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	pc = 0x82503240; continue 'dispatch;
            }
            0x82503240 => {
    //   block [0x82503240..0x82503290)
	// 82503240: 389F0030  addi r4, r31, 0x30
	ctx.r[4].s64 = ctx.r[31].s64 + 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82503290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82503290 size=108
    let mut pc: u32 = 0x82503290;
    'dispatch: loop {
        match pc {
            0x82503290 => {
    //   block [0x82503290..0x825032FC)
	// 82503290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82503294: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82503298: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8250329C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825032A0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 825032A4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825032A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825032AC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 825032B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825032B4: 38BF0030  addi r5, r31, 0x30
	ctx.r[5].s64 = ctx.r[31].s64 + 48;
	// 825032B8: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 825032BC: 480A5DDD  bl 0x825a9098
	ctx.lr = 0x825032C0;
	sub_825A9098(ctx, base);
	// 825032C0: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 825032C4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825032C8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825032CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825032D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825032D4: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 825032D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825032DC: 4E800421  bctrl
	ctx.lr = 0x825032E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825032E0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825032E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825032E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825032EC: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 825032F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825032F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825032F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82503300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82503300 size=216
    let mut pc: u32 = 0x82503300;
    'dispatch: loop {
        match pc {
            0x82503300 => {
    //   block [0x82503300..0x825033D8)
	// 82503300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82503304: 48031DB5  bl 0x825350b8
	ctx.lr = 0x82503308;
	sub_82535080(ctx, base);
	// 82503308: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250330C: 3BE30030  addi r31, r3, 0x30
	ctx.r[31].s64 = ctx.r[3].s64 + 48;
	// 82503310: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82503314: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82503318: 3B800010  li r28, 0x10
	ctx.r[28].s64 = 16;
	// 8250331C: 3BA00020  li r29, 0x20
	ctx.r[29].s64 = 32;
	// 82503320: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825033D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825033D8 size=436
    let mut pc: u32 = 0x825033D8;
    'dispatch: loop {
        match pc {
            0x825033D8 => {
    //   block [0x825033D8..0x82503424)
	// 825033D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825033DC: 48031CD9  bl 0x825350b4
	ctx.lr = 0x825033E0;
	sub_82535080(ctx, base);
	// 825033E0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825033E4: 836D0000  lwz r27, 0(r13)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825033E8: 3B800014  li r28, 0x14
	ctx.r[28].s64 = 20;
	// 825033EC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825033F0: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 825033F4: 7D7CD82E  lwzx r11, r28, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 825033F8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825033FC: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82503400: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82503404: 40980020  bge cr6, 0x82503424
	if !ctx.cr[6].lt {
	pc = 0x82503424; continue 'dispatch;
	}
	// 82503408: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 8250340C: 39294688  addi r9, r9, 0x4688
	ctx.r[9].s64 = ctx.r[9].s64 + 18056;
	// 82503410: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82503414: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 82503418: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 8250341C: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82503420: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x82503424; continue 'dispatch;
            }
            0x82503424 => {
    //   block [0x82503424..0x82503434)
	// 82503424: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82503428: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 8250342C: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 82503430: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82503434; continue 'dispatch;
            }
            0x82503434 => {
    //   block [0x82503434..0x8250358C)
	// 82503434: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82503438: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8250343C: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82503440: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82503444: 4200FFF0  bdnz 0x82503434
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82503434; continue 'dispatch;
	}
	// 82503448: 3BE40030  addi r31, r4, 0x30
	ctx.r[31].s64 = ctx.r[4].s64 + 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82503590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82503590 size=384
    let mut pc: u32 = 0x82503590;
    'dispatch: loop {
        match pc {
            0x82503590 => {
    //   block [0x82503590..0x825035E4)
	// 82503590: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82503594: 48031B21  bl 0x825350b4
	ctx.lr = 0x82503598;
	sub_82535080(ctx, base);
	// 82503598: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250359C: 838D0000  lwz r28, 0(r13)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825035A0: 3BA00014  li r29, 0x14
	ctx.r[29].s64 = 20;
	// 825035A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825035A8: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 825035AC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825035B0: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 825035B4: 7D7DE02E  lwzx r11, r29, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 825035B8: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825035BC: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825035C0: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825035C4: 40980020  bge cr6, 0x825035e4
	if !ctx.cr[6].lt {
	pc = 0x825035E4; continue 'dispatch;
	}
	// 825035C8: 3D008206  lis r8, -0x7dfa
	ctx.r[8].s64 = -2113536000;
	// 825035CC: 39084688  addi r8, r8, 0x4688
	ctx.r[8].s64 = ctx.r[8].s64 + 18056;
	// 825035D0: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825035D4: 7D0C42E6  mftb r8, 0x10c
	ctx.r[8].u64 = crate::rt::rdtsc_u64();
	// 825035D8: 38E9000C  addi r7, r9, 0xc
	ctx.r[7].s64 = ctx.r[9].s64 + 12;
	// 825035DC: 91090004  stw r8, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 825035E0: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	pc = 0x825035E4; continue 'dispatch;
            }
            0x825035E4 => {
    //   block [0x825035E4..0x825035F4)
	// 825035E4: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 825035E8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 825035EC: 39000006  li r8, 6
	ctx.r[8].s64 = 6;
	// 825035F0: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x825035F4; continue 'dispatch;
            }
            0x825035F4 => {
    //   block [0x825035F4..0x82503710)
	// 825035F4: E90B0000  ld r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 825035F8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825035FC: F9090000  std r8, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 82503600: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82503604: 4200FFF0  bdnz 0x825035f4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825035F4; continue 'dispatch;
	}
	// 82503608: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82503718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82503718 size=156
    let mut pc: u32 = 0x82503718;
    'dispatch: loop {
        match pc {
            0x82503718 => {
    //   block [0x82503718..0x82503748)
	// 82503718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250371C: 48031995  bl 0x825350b0
	ctx.lr = 0x82503720;
	sub_82535080(ctx, base);
	// 82503720: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82503724: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82503728: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8250372C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82503730: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82503734: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 82503738: 3B6BFFFF  addi r27, r11, -1
	ctx.r[27].s64 = ctx.r[11].s64 + -1;
	// 8250373C: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82503740: 4198004C  blt cr6, 0x8250378c
	if ctx.cr[6].lt {
	pc = 0x8250378C; continue 'dispatch;
	}
	// 82503744: 577F103A  slwi r31, r27, 2
	ctx.r[31].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	pc = 0x82503748; continue 'dispatch;
            }
            0x82503748 => {
    //   block [0x82503748..0x8250378C)
	// 82503748: 817E0028  lwz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 8250374C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82503750: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82503754: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82503758: 7D6BF82E  lwzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 8250375C: 388B0008  addi r4, r11, 8
	ctx.r[4].s64 = ctx.r[11].s64 + 8;
	// 82503760: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82503764: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82503768: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250376C: 4E800421  bctrl
	ctx.lr = 0x82503770;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82503770: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82503774: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82503778: 419A0028  beq cr6, 0x825037a0
	if ctx.cr[6].eq {
	pc = 0x825037A0; continue 'dispatch;
	}
	// 8250377C: 3B7BFFFF  addi r27, r27, -1
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	// 82503780: 3BFFFFFC  addi r31, r31, -4
	ctx.r[31].s64 = ctx.r[31].s64 + -4;
	// 82503784: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82503788: 4098FFC0  bge cr6, 0x82503748
	if !ctx.cr[6].lt {
	pc = 0x82503748; continue 'dispatch;
	}
            }
            0x8250378C => {
    //   block [0x8250378C..0x825037A0)
	// 8250378C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82503790: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82503794: 997A0000  stb r11, 0(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82503798: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8250379C: 48031964  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x825037A0 => {
    //   block [0x825037A0..0x825037B4)
	// 825037A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825037A4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825037A8: 997A0000  stb r11, 0(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825037AC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825037B0: 48031950  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825037B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825037B8 size=180
    let mut pc: u32 = 0x825037B8;
    'dispatch: loop {
        match pc {
            0x825037B8 => {
    //   block [0x825037B8..0x825037F4)
	// 825037B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825037BC: 480318E9  bl 0x825350a4
	ctx.lr = 0x825037C0;
	sub_82535080(ctx, base);
	// 825037C0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825037C4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825037C8: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 825037CC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825037D0: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825037D4: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 825037D8: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 825037DC: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 825037E0: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 825037E4: 3B0BFFFF  addi r24, r11, -1
	ctx.r[24].s64 = ctx.r[11].s64 + -1;
	// 825037E8: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 825037EC: 41980058  blt cr6, 0x82503844
	if ctx.cr[6].lt {
	pc = 0x82503844; continue 'dispatch;
	}
	// 825037F0: 571E103A  slwi r30, r24, 2
	ctx.r[30].u32 = ctx.r[24].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	pc = 0x825037F4; continue 'dispatch;
            }
            0x825037F4 => {
    //   block [0x825037F4..0x82503844)
	// 825037F4: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 825037F8: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 825037FC: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82503800: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82503804: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82503808: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8250380C: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82503810: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82503814: 388B000C  addi r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 + 12;
	// 82503818: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250381C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82503820: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82503824: 4E800421  bctrl
	ctx.lr = 0x82503828;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82503828: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250382C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82503830: 419A0028  beq cr6, 0x82503858
	if ctx.cr[6].eq {
	pc = 0x82503858; continue 'dispatch;
	}
	// 82503834: 3B18FFFF  addi r24, r24, -1
	ctx.r[24].s64 = ctx.r[24].s64 + -1;
	// 82503838: 3BDEFFFC  addi r30, r30, -4
	ctx.r[30].s64 = ctx.r[30].s64 + -4;
	// 8250383C: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 82503840: 4098FFB4  bge cr6, 0x825037f4
	if !ctx.cr[6].lt {
	pc = 0x825037F4; continue 'dispatch;
	}
            }
            0x82503844 => {
    //   block [0x82503844..0x82503858)
	// 82503844: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82503848: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 8250384C: 99770000  stb r11, 0(r23)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82503850: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82503854: 480318A0  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            0x82503858 => {
    //   block [0x82503858..0x8250386C)
	// 82503858: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8250385C: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82503860: 99770000  stb r11, 0(r23)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82503864: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82503868: 4803188C  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82503870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82503870 size=172
    let mut pc: u32 = 0x82503870;
    'dispatch: loop {
        match pc {
            0x82503870 => {
    //   block [0x82503870..0x825038A8)
	// 82503870: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82503874: 48031835  bl 0x825350a8
	ctx.lr = 0x82503878;
	sub_82535080(ctx, base);
	// 82503878: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250387C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82503880: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82503884: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82503888: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 8250388C: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82503890: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82503894: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 82503898: 3B2BFFFF  addi r25, r11, -1
	ctx.r[25].s64 = ctx.r[11].s64 + -1;
	// 8250389C: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 825038A0: 41980054  blt cr6, 0x825038f4
	if ctx.cr[6].lt {
	pc = 0x825038F4; continue 'dispatch;
	}
	// 825038A4: 573F103A  slwi r31, r25, 2
	ctx.r[31].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	pc = 0x825038A8; continue 'dispatch;
            }
            0x825038A8 => {
    //   block [0x825038A8..0x825038F4)
	// 825038A8: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 825038AC: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 825038B0: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 825038B4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825038B8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825038BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825038C0: 7D6BF82E  lwzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 825038C4: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 825038C8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825038CC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825038D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825038D4: 4E800421  bctrl
	ctx.lr = 0x825038D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825038D8: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825038DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825038E0: 419A0028  beq cr6, 0x82503908
	if ctx.cr[6].eq {
	pc = 0x82503908; continue 'dispatch;
	}
	// 825038E4: 3B39FFFF  addi r25, r25, -1
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	// 825038E8: 3BFFFFFC  addi r31, r31, -4
	ctx.r[31].s64 = ctx.r[31].s64 + -4;
	// 825038EC: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 825038F0: 4098FFB8  bge cr6, 0x825038a8
	if !ctx.cr[6].lt {
	pc = 0x825038A8; continue 'dispatch;
	}
            }
            0x825038F4 => {
    //   block [0x825038F4..0x82503908)
	// 825038F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825038F8: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 825038FC: 99780000  stb r11, 0(r24)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82503900: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82503904: 480317F4  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            0x82503908 => {
    //   block [0x82503908..0x8250391C)
	// 82503908: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8250390C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82503910: 99780000  stb r11, 0(r24)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82503914: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82503918: 480317E0  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82503920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82503920 size=196
    let mut pc: u32 = 0x82503920;
    'dispatch: loop {
        match pc {
            0x82503920 => {
    //   block [0x82503920..0x82503964)
	// 82503920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82503924: 48031779  bl 0x8253509c
	ctx.lr = 0x82503928;
	sub_82535080(ctx, base);
	// 82503928: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250392C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82503930: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 82503934: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82503938: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 8250393C: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82503940: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82503944: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 82503948: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 8250394C: 3ACBFFFF  addi r22, r11, -1
	ctx.r[22].s64 = ctx.r[11].s64 + -1;
	// 82503950: 7D585378  mr r24, r10
	ctx.r[24].u64 = ctx.r[10].u64;
	// 82503954: 2F160000  cmpwi cr6, r22, 0
	ctx.cr[6].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 82503958: 41980064  blt cr6, 0x825039bc
	if ctx.cr[6].lt {
	pc = 0x825039BC; continue 'dispatch;
	}
	// 8250395C: 82E10124  lwz r23, 0x124(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) } as u64;
	// 82503960: 56DE103A  slwi r30, r22, 2
	ctx.r[30].u32 = ctx.r[22].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	pc = 0x82503964; continue 'dispatch;
            }
            0x82503964 => {
    //   block [0x82503964..0x825039BC)
	// 82503964: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82503968: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 8250396C: 92E10054  stw r23, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[23].u32 ) };
	// 82503970: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 82503974: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82503978: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 8250397C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82503980: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82503984: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82503988: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8250398C: 388B000C  addi r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 + 12;
	// 82503990: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82503994: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82503998: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250399C: 4E800421  bctrl
	ctx.lr = 0x825039A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825039A0: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825039A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825039A8: 419A0028  beq cr6, 0x825039d0
	if ctx.cr[6].eq {
	pc = 0x825039D0; continue 'dispatch;
	}
	// 825039AC: 3AD6FFFF  addi r22, r22, -1
	ctx.r[22].s64 = ctx.r[22].s64 + -1;
	// 825039B0: 3BDEFFFC  addi r30, r30, -4
	ctx.r[30].s64 = ctx.r[30].s64 + -4;
	// 825039B4: 2F160000  cmpwi cr6, r22, 0
	ctx.cr[6].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 825039B8: 4098FFAC  bge cr6, 0x82503964
	if !ctx.cr[6].lt {
	pc = 0x82503964; continue 'dispatch;
	}
            }
            0x825039BC => {
    //   block [0x825039BC..0x825039D0)
	// 825039BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825039C0: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 825039C4: 99750000  stb r11, 0(r21)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825039C8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 825039CC: 48031720  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            0x825039D0 => {
    //   block [0x825039D0..0x825039E4)
	// 825039D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825039D4: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 825039D8: 99750000  stb r11, 0(r21)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825039DC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 825039E0: 4803170C  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825039E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825039E8 size=156
    let mut pc: u32 = 0x825039E8;
    'dispatch: loop {
        match pc {
            0x825039E8 => {
    //   block [0x825039E8..0x82503A18)
	// 825039E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825039EC: 480316C5  bl 0x825350b0
	ctx.lr = 0x825039F0;
	sub_82535080(ctx, base);
	// 825039F0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825039F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825039F8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825039FC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82503A00: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82503A04: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82503A08: 3B6BFFFF  addi r27, r11, -1
	ctx.r[27].s64 = ctx.r[11].s64 + -1;
	// 82503A0C: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82503A10: 4198004C  blt cr6, 0x82503a5c
	if ctx.cr[6].lt {
	pc = 0x82503A5C; continue 'dispatch;
	}
	// 82503A14: 577F103A  slwi r31, r27, 2
	ctx.r[31].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	pc = 0x82503A18; continue 'dispatch;
            }
            0x82503A18 => {
    //   block [0x82503A18..0x82503A5C)
	// 82503A18: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82503A1C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82503A20: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82503A24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82503A28: 7D6BF82E  lwzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82503A2C: 388B0014  addi r4, r11, 0x14
	ctx.r[4].s64 = ctx.r[11].s64 + 20;
	// 82503A30: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82503A34: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82503A38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82503A3C: 4E800421  bctrl
	ctx.lr = 0x82503A40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82503A40: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82503A44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82503A48: 419A0028  beq cr6, 0x82503a70
	if ctx.cr[6].eq {
	pc = 0x82503A70; continue 'dispatch;
	}
	// 82503A4C: 3B7BFFFF  addi r27, r27, -1
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	// 82503A50: 3BFFFFFC  addi r31, r31, -4
	ctx.r[31].s64 = ctx.r[31].s64 + -4;
	// 82503A54: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82503A58: 4098FFC0  bge cr6, 0x82503a18
	if !ctx.cr[6].lt {
	pc = 0x82503A18; continue 'dispatch;
	}
            }
            0x82503A5C => {
    //   block [0x82503A5C..0x82503A70)
	// 82503A5C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82503A60: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82503A64: 997A0000  stb r11, 0(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82503A68: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82503A6C: 48031694  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x82503A70 => {
    //   block [0x82503A70..0x82503A84)
	// 82503A70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82503A74: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82503A78: 997A0000  stb r11, 0(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82503A7C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82503A80: 48031680  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82503A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82503A88 size=148
    let mut pc: u32 = 0x82503A88;
    'dispatch: loop {
        match pc {
            0x82503A88 => {
    //   block [0x82503A88..0x82503AA4)
	// 82503A88: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82503A8C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82503A90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82503A94: 81090034  lwz r8, 0x34(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(52 as u32) ) } as u64;
	// 82503A98: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82503A9C: 40990024  ble cr6, 0x82503ac0
	if !ctx.cr[6].gt {
	pc = 0x82503AC0; continue 'dispatch;
	}
	// 82503AA0: 81490030  lwz r10, 0x30(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(48 as u32) ) } as u64;
	pc = 0x82503AA4; continue 'dispatch;
            }
            0x82503AA4 => {
    //   block [0x82503AA4..0x82503AC0)
	// 82503AA4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82503AA8: 7F071840  cmplw cr6, r7, r3
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82503AAC: 419A0018  beq cr6, 0x82503ac4
	if ctx.cr[6].eq {
	pc = 0x82503AC4; continue 'dispatch;
	}
	// 82503AB0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82503AB4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82503AB8: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82503ABC: 4198FFE8  blt cr6, 0x82503aa4
	if ctx.cr[6].lt {
	pc = 0x82503AA4; continue 'dispatch;
	}
	pc = 0x82503AC0; continue 'dispatch;
            }
            0x82503AC0 => {
    //   block [0x82503AC0..0x82503AC4)
	// 82503AC0: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	pc = 0x82503AC4; continue 'dispatch;
            }
            0x82503AC4 => {
    //   block [0x82503AC4..0x82503B1C)
	// 82503AC4: 81490034  lwz r10, 0x34(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(52 as u32) ) } as u64;
	// 82503AC8: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82503ACC: 81690030  lwz r11, 0x30(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(48 as u32) ) } as u64;
	// 82503AD0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82503AD4: 5547103A  slwi r7, r10, 2
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82503AD8: 91490034  stw r10, 0x34(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	// 82503ADC: 7D47582E  lwzx r10, r7, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82503AE0: 7D48592E  stwx r10, r8, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	// 82503AE4: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82503AE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82503AEC: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82503AF0: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 82503AF4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82503AF8: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 82503AFC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82503B00: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 82503B04: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 82503B08: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82503B0C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82503B10: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82503B14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82503B18: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82503B1C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82503B1C size=4
    let mut pc: u32 = 0x82503B1C;
    'dispatch: loop {
        match pc {
            0x82503B1C => {
    //   block [0x82503B1C..0x82503B20)
	// 82503B1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82503B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82503B20 size=364
    let mut pc: u32 = 0x82503B20;
    'dispatch: loop {
        match pc {
            0x82503B20 => {
    //   block [0x82503B20..0x82503BD0)
	// 82503B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82503B24: 48031595  bl 0x825350b8
	ctx.lr = 0x82503B28;
	sub_82535080(ctx, base);
	// 82503B28: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82503B2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82503B30: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82503B34: 4BFFAC8D  bl 0x824fe7c0
	ctx.lr = 0x82503B38;
	sub_824FE7C0(ctx, base);
	// 82503B38: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82503B3C: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 82503B40: 396B2B04  addi r11, r11, 0x2b04
	ctx.r[11].s64 = ctx.r[11].s64 + 11012;
	// 82503B44: 394A2AF8  addi r10, r10, 0x2af8
	ctx.r[10].s64 = ctx.r[10].s64 + 11000;
	// 82503B48: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 82503B4C: 3D008206  lis r8, -0x7dfa
	ctx.r[8].s64 = -2113536000;
	// 82503B50: 3CE08206  lis r7, -0x7dfa
	ctx.r[7].s64 = -2113536000;
	// 82503B54: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82503B58: 39292AE4  addi r9, r9, 0x2ae4
	ctx.r[9].s64 = ctx.r[9].s64 + 10980;
	// 82503B5C: 39082AD8  addi r8, r8, 0x2ad8
	ctx.r[8].s64 = ctx.r[8].s64 + 10968;
	// 82503B60: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82503B64: 38E72ACC  addi r7, r7, 0x2acc
	ctx.r[7].s64 = ctx.r[7].s64 + 10956;
	// 82503B68: 3BDF0030  addi r30, r31, 0x30
	ctx.r[30].s64 = ctx.r[31].s64 + 48;
	// 82503B6C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82503B70: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82503B74: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82503B78: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 82503B7C: 911F0010  stw r8, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 82503B80: 90FF0014  stw r7, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 82503B84: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82503B88: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82503B8C: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82503B90: 915F0020  stw r10, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 82503B94: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82503B98: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82503B9C: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82503BA0: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82503BA4: 40980060  bge cr6, 0x82503c04
	if !ctx.cr[6].lt {
	pc = 0x82503C04; continue 'dispatch;
	}
	// 82503BA8: 556B0000  rlwinm r11, r11, 0, 0, 0
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82503BAC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82503BB0: 409A0020  bne cr6, 0x82503bd0
	if !ctx.cr[6].eq {
	pc = 0x82503BD0; continue 'dispatch;
	}
	// 82503BB4: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82503BB8: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82503BBC: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 82503BC0: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82503BC4: 5545103A  slwi r5, r10, 2
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82503BC8: 7C69582E  lwzx r3, r9, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82503BCC: 4BF604ED  bl 0x824640b8
	ctx.lr = 0x82503BD0;
	sub_824640B8(ctx, base);
	pc = 0x82503BD0; continue 'dispatch;
            }
            0x82503BD0 => {
    //   block [0x82503BD0..0x82503C04)
	// 82503BD0: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82503BD4: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82503BD8: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82503BDC: 38A00017  li r5, 0x17
	ctx.r[5].s64 = 23;
	// 82503BE0: 5524103A  slwi r4, r9, 2
	ctx.r[4].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82503BE4: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82503BE8: 4BF60451  bl 0x82464038
	ctx.lr = 0x82503BEC;
	sub_82464038(ctx, base);
	// 82503BEC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82503BF0: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82503BF4: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82503BF8: 556B0042  rlwinm r11, r11, 0, 1, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82503BFC: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82503C00: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82503C04; continue 'dispatch;
            }
            0x82503C04 => {
    //   block [0x82503C04..0x82503C20)
	// 82503C04: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82503C08: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82503C0C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82503C10: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82503C14: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82503C18: 40990020  ble cr6, 0x82503c38
	if !ctx.cr[6].gt {
	pc = 0x82503C38; continue 'dispatch;
	}
	// 82503C1C: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	pc = 0x82503C20; continue 'dispatch;
            }
            0x82503C20 => {
    //   block [0x82503C20..0x82503C38)
	// 82503C20: 7D09582E  lwzx r8, r9, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82503C24: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82503C28: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82503C2C: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82503C30: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82503C34: 409AFFEC  bne cr6, 0x82503c20
	if !ctx.cr[6].eq {
	pc = 0x82503C20; continue 'dispatch;
	}
	pc = 0x82503C38; continue 'dispatch;
            }
            0x82503C38 => {
    //   block [0x82503C38..0x82503C4C)
	// 82503C38: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82503C3C: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 82503C40: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82503C44: 4099003C  ble cr6, 0x82503c80
	if !ctx.cr[6].gt {
	pc = 0x82503C80; continue 'dispatch;
	}
	// 82503C48: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	pc = 0x82503C4C; continue 'dispatch;
            }
            0x82503C4C => {
    //   block [0x82503C4C..0x82503C6C)
	// 82503C4C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82503C50: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82503C54: A10B0004  lhz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82503C58: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82503C5C: 419A0010  beq cr6, 0x82503c6c
	if ctx.cr[6].eq {
	pc = 0x82503C6C; continue 'dispatch;
	}
	// 82503C60: A10B0006  lhz r8, 6(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 82503C64: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82503C68: B10B0006  sth r8, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[8].u16 ) };
	pc = 0x82503C6C; continue 'dispatch;
            }
            0x82503C6C => {
    //   block [0x82503C6C..0x82503C80)
	// 82503C6C: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82503C70: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82503C74: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82503C78: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82503C7C: 4198FFD0  blt cr6, 0x82503c4c
	if ctx.cr[6].lt {
	pc = 0x82503C4C; continue 'dispatch;
	}
	pc = 0x82503C80; continue 'dispatch;
            }
            0x82503C80 => {
    //   block [0x82503C80..0x82503C8C)
	// 82503C80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82503C84: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82503C88: 48031480  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82503C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82503C90 size=292
    let mut pc: u32 = 0x82503C90;
    'dispatch: loop {
        match pc {
            0x82503C90 => {
    //   block [0x82503C90..0x82503CF0)
	// 82503C90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82503C94: 48031429  bl 0x825350bc
	ctx.lr = 0x82503C98;
	sub_82535080(ctx, base);
	// 82503C98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82503C9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82503CA0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82503CA4: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 82503CA8: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 82503CAC: 3D008206  lis r8, -0x7dfa
	ctx.r[8].s64 = -2113536000;
	// 82503CB0: 3CE08206  lis r7, -0x7dfa
	ctx.r[7].s64 = -2113536000;
	// 82503CB4: 80DF0034  lwz r6, 0x34(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82503CB8: 396B2B04  addi r11, r11, 0x2b04
	ctx.r[11].s64 = ctx.r[11].s64 + 11012;
	// 82503CBC: 394A2AF8  addi r10, r10, 0x2af8
	ctx.r[10].s64 = ctx.r[10].s64 + 11000;
	// 82503CC0: 39292AE4  addi r9, r9, 0x2ae4
	ctx.r[9].s64 = ctx.r[9].s64 + 10980;
	// 82503CC4: 39082AD8  addi r8, r8, 0x2ad8
	ctx.r[8].s64 = ctx.r[8].s64 + 10968;
	// 82503CC8: 38E72ACC  addi r7, r7, 0x2acc
	ctx.r[7].s64 = ctx.r[7].s64 + 10956;
	// 82503CCC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82503CD0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82503CD4: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82503CD8: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82503CDC: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82503CE0: 911F0010  stw r8, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 82503CE4: 90FF0014  stw r7, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 82503CE8: 4099005C  ble cr6, 0x82503d44
	if !ctx.cr[6].gt {
	pc = 0x82503D44; continue 'dispatch;
	}
	// 82503CEC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82503CF0; continue 'dispatch;
            }
            0x82503CF0 => {
    //   block [0x82503CF0..0x82503D30)
	// 82503CF0: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82503CF4: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82503CF8: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82503CFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82503D00: 419A0030  beq cr6, 0x82503d30
	if ctx.cr[6].eq {
	pc = 0x82503D30; continue 'dispatch;
	}
	// 82503D04: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 82503D08: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82503D0C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 82503D10: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82503D14: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 82503D18: 409A0018  bne cr6, 0x82503d30
	if !ctx.cr[6].eq {
	pc = 0x82503D30; continue 'dispatch;
	}
	// 82503D1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82503D20: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82503D24: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82503D28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82503D2C: 4E800421  bctrl
	ctx.lr = 0x82503D30;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82503D30 => {
    //   block [0x82503D30..0x82503D44)
	// 82503D30: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82503D34: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82503D38: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82503D3C: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82503D40: 4198FFB0  blt cr6, 0x82503cf0
	if ctx.cr[6].lt {
	pc = 0x82503CF0; continue 'dispatch;
	}
	pc = 0x82503D44; continue 'dispatch;
            }
            0x82503D44 => {
    //   block [0x82503D44..0x82503D70)
	// 82503D44: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82503D48: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82503D4C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82503D50: 409A0020  bne cr6, 0x82503d70
	if !ctx.cr[6].eq {
	pc = 0x82503D70; continue 'dispatch;
	}
	// 82503D54: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82503D58: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82503D5C: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 82503D60: 809F0030  lwz r4, 0x30(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82503D64: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82503D68: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82503D6C: 4BF6034D  bl 0x824640b8
	ctx.lr = 0x82503D70;
	sub_824640B8(ctx, base);
	pc = 0x82503D70; continue 'dispatch;
            }
            0x82503D70 => {
    //   block [0x82503D70..0x82503DB4)
	// 82503D70: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82503D74: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 82503D78: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 82503D7C: 396BFAD4  addi r11, r11, -0x52c
	ctx.r[11].s64 = ctx.r[11].s64 + -1324;
	// 82503D80: 3D008206  lis r8, -0x7dfa
	ctx.r[8].s64 = -2113536000;
	// 82503D84: 394AFAF4  addi r10, r10, -0x50c
	ctx.r[10].s64 = ctx.r[10].s64 + -1292;
	// 82503D88: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82503D8C: 3929FAE0  addi r9, r9, -0x520
	ctx.r[9].s64 = ctx.r[9].s64 + -1312;
	// 82503D90: 3908FAB8  addi r8, r8, -0x548
	ctx.r[8].s64 = ctx.r[8].s64 + -1352;
	// 82503D94: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82503D98: 38E76DD0  addi r7, r7, 0x6dd0
	ctx.r[7].s64 = ctx.r[7].s64 + 28112;
	// 82503D9C: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82503DA0: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82503DA4: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82503DA8: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82503DAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82503DB0: 4803135C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82503DB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82503DB8 size=128
    let mut pc: u32 = 0x82503DB8;
    'dispatch: loop {
        match pc {
            0x82503DB8 => {
    //   block [0x82503DB8..0x82503E38)
	// 82503DB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82503DBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82503DC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82503DC4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82503DC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82503DCC: 4BFFA9F5  bl 0x824fe7c0
	ctx.lr = 0x82503DD0;
	sub_824FE7C0(ctx, base);
	// 82503DD0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82503DD4: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 82503DD8: 396B2B04  addi r11, r11, 0x2b04
	ctx.r[11].s64 = ctx.r[11].s64 + 11012;
	// 82503DDC: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 82503DE0: 3D008206  lis r8, -0x7dfa
	ctx.r[8].s64 = -2113536000;
	// 82503DE4: 3CE08206  lis r7, -0x7dfa
	ctx.r[7].s64 = -2113536000;
	// 82503DE8: 394A2AF8  addi r10, r10, 0x2af8
	ctx.r[10].s64 = ctx.r[10].s64 + 11000;
	// 82503DEC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82503DF0: 39292AE4  addi r9, r9, 0x2ae4
	ctx.r[9].s64 = ctx.r[9].s64 + 10980;
	// 82503DF4: 39082AD8  addi r8, r8, 0x2ad8
	ctx.r[8].s64 = ctx.r[8].s64 + 10968;
	// 82503DF8: 38E72ACC  addi r7, r7, 0x2acc
	ctx.r[7].s64 = ctx.r[7].s64 + 10956;
	// 82503DFC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82503E00: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82503E04: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82503E08: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82503E0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82503E10: 911F0010  stw r8, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 82503E14: 90FF0014  stw r7, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 82503E18: 90DF0030  stw r6, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[6].u32 ) };
	// 82503E1C: 90DF0034  stw r6, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[6].u32 ) };
	// 82503E20: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 82503E24: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82503E28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82503E2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82503E30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82503E34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82503E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82503E38 size=136
    let mut pc: u32 = 0x82503E38;
    'dispatch: loop {
        match pc {
            0x82503E38 => {
    //   block [0x82503E38..0x82503E68)
	// 82503E38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82503E3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82503E40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82503E44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82503E48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82503E4C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82503E50: A17E0004  lhz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82503E54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82503E58: 419A0010  beq cr6, 0x82503e68
	if ctx.cr[6].eq {
	pc = 0x82503E68; continue 'dispatch;
	}
	// 82503E5C: A17E0006  lhz r11, 6(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 82503E60: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82503E64: B17E0006  sth r11, 6(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	pc = 0x82503E68; continue 'dispatch;
            }
            0x82503E68 => {
    //   block [0x82503E68..0x82503E8C)
	// 82503E68: 3BE30030  addi r31, r3, 0x30
	ctx.r[31].s64 = ctx.r[3].s64 + 48;
	// 82503E6C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82503E70: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82503E74: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82503E78: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82503E7C: 409A0010  bne cr6, 0x82503e8c
	if !ctx.cr[6].eq {
	pc = 0x82503E8C; continue 'dispatch;
	}
	// 82503E80: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82503E84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82503E88: 4BF6A4C9  bl 0x8246e350
	ctx.lr = 0x82503E8C;
	sub_8246E350(ctx, base);
	pc = 0x82503E8C; continue 'dispatch;
            }
            0x82503E8C => {
    //   block [0x82503E8C..0x82503EC0)
	// 82503E8C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82503E90: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82503E94: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82503E98: 7FCB512E  stwx r30, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[30].u32) };
	// 82503E9C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82503EA0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82503EA4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82503EA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82503EAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82503EB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82503EB4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82503EB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82503EBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82503EE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82503EE0 size=216
    let mut pc: u32 = 0x82503EE0;
    'dispatch: loop {
        match pc {
            0x82503EE0 => {
    //   block [0x82503EE0..0x82503F5C)
	// 82503EE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82503EE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82503EE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82503EEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82503EF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82503EF4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82503EF8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82503EFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82503F00: 388B46BC  addi r4, r11, 0x46bc
	ctx.r[4].s64 = ctx.r[11].s64 + 18108;
	// 82503F04: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82503F08: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82503F0C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82503F10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82503F14: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82503F18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82503F1C: 4E800421  bctrl
	ctx.lr = 0x82503F20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82503F20: 80DE0050  lwz r6, 0x50(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 82503F24: 397E0070  addi r11, r30, 0x70
	ctx.r[11].s64 = ctx.r[30].s64 + 112;
	// 82503F28: 7F065840  cmplw cr6, r6, r11
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82503F2C: 419A0030  beq cr6, 0x82503f5c
	if ctx.cr[6].eq {
	pc = 0x82503F5C; continue 'dispatch;
	}
	// 82503F30: 815E0054  lwz r10, 0x54(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 82503F34: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82503F38: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82503F3C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82503F40: 55483032  slwi r8, r10, 6
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(6);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82503F44: 388B46A8  addi r4, r11, 0x46a8
	ctx.r[4].s64 = ctx.r[11].s64 + 18088;
	// 82503F48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82503F4C: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 82503F50: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82503F54: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82503F58: 4E800421  bctrl
	ctx.lr = 0x82503F5C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82503F5C => {
    //   block [0x82503F5C..0x82503FB8)
	// 82503F5C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82503F60: 815E005C  lwz r10, 0x5c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(92 as u32) ) } as u64;
	// 82503F64: 80DE0058  lwz r6, 0x58(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) } as u64;
	// 82503F68: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82503F6C: 388B4698  addi r4, r11, 0x4698
	ctx.r[4].s64 = ctx.r[11].s64 + 18072;
	// 82503F70: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82503F74: 55483032  slwi r8, r10, 6
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(6);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82503F78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82503F7C: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 82503F80: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82503F84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82503F88: 4E800421  bctrl
	ctx.lr = 0x82503F8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82503F8C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82503F90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82503F94: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82503F98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82503F9C: 4E800421  bctrl
	ctx.lr = 0x82503FA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82503FA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82503FA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82503FA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82503FAC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82503FB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82503FB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82503FB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82503FB8 size=244
    let mut pc: u32 = 0x82503FB8;
    'dispatch: loop {
        match pc {
            0x82503FB8 => {
    //   block [0x82503FB8..0x82503FE0)
	// 82503FB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82503FBC: 480310F1  bl 0x825350ac
	ctx.lr = 0x82503FC0;
	sub_82535080(ctx, base);
	// 82503FC0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82503FC4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82503FC8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82503FCC: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82503FD0: 817A005C  lwz r11, 0x5c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(92 as u32) ) } as u64;
	// 82503FD4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82503FD8: 409900BC  ble cr6, 0x82504094
	if !ctx.cr[6].gt {
	pc = 0x82504094; continue 'dispatch;
	}
	// 82503FDC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	pc = 0x82503FE0; continue 'dispatch;
            }
            0x82503FE0 => {
    //   block [0x82503FE0..0x82503FFC)
	// 82503FE0: 817A0058  lwz r11, 0x58(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(88 as u32) ) } as u64;
	// 82503FE4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82503FE8: 7FFB5A14  add r31, r27, r11
	ctx.r[31].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 82503FEC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82503FF0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82503FF4: 4099008C  ble cr6, 0x82504080
	if !ctx.cr[6].gt {
	pc = 0x82504080; continue 'dispatch;
	}
	// 82503FF8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82503FFC; continue 'dispatch;
            }
            0x82503FFC => {
    //   block [0x82503FFC..0x82504040)
	// 82503FFC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82504000: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 82504004: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82504008: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8250400C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82504010: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82504014: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82504018: 4E800421  bctrl
	ctx.lr = 0x8250401C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250401C: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82504020: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82504024: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82504028: 409A0018  bne cr6, 0x82504040
	if !ctx.cr[6].eq {
	pc = 0x82504040; continue 'dispatch;
	}
	// 8250402C: 895F0019  lbz r10, 0x19(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(25 as u32) ) } as u64;
	// 82504030: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82504034: 409A000C  bne cr6, 0x82504040
	if !ctx.cr[6].eq {
	pc = 0x82504040; continue 'dispatch;
	}
	// 82504038: 39600200  li r11, 0x200
	ctx.r[11].s64 = 512;
	// 8250403C: 48000020  b 0x8250405c
	pc = 0x8250405C; continue 'dispatch;
            }
            0x82504040 => {
    //   block [0x82504040..0x82504058)
	// 82504040: 895F0019  lbz r10, 0x19(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(25 as u32) ) } as u64;
	// 82504044: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82504048: 409A0010  bne cr6, 0x82504058
	if !ctx.cr[6].eq {
	pc = 0x82504058; continue 'dispatch;
	}
	// 8250404C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82504050: 396001D0  li r11, 0x1d0
	ctx.r[11].s64 = 464;
	// 82504054: 409A0008  bne cr6, 0x8250405c
	if !ctx.cr[6].eq {
	pc = 0x8250405C; continue 'dispatch;
	}
	pc = 0x82504058; continue 'dispatch;
            }
            0x82504058 => {
    //   block [0x82504058..0x8250405C)
	// 82504058: 396001A0  li r11, 0x1a0
	ctx.r[11].s64 = 416;
	pc = 0x8250405C; continue 'dispatch;
            }
            0x8250405C => {
    //   block [0x8250405C..0x82504080)
	// 8250405C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82504060: 41980040  blt cr6, 0x825040a0
	if ctx.cr[6].lt {
	pc = 0x825040A0; continue 'dispatch;
	}
	// 82504064: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82504068: 41990038  bgt cr6, 0x825040a0
	if ctx.cr[6].gt {
	pc = 0x825040A0; continue 'dispatch;
	}
	// 8250406C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82504070: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82504074: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82504078: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8250407C: 4198FF80  blt cr6, 0x82503ffc
	if ctx.cr[6].lt {
	pc = 0x82503FFC; continue 'dispatch;
	}
	pc = 0x82504080; continue 'dispatch;
            }
            0x82504080 => {
    //   block [0x82504080..0x82504094)
	// 82504080: 817A005C  lwz r11, 0x5c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(92 as u32) ) } as u64;
	// 82504084: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 82504088: 3B7B0040  addi r27, r27, 0x40
	ctx.r[27].s64 = ctx.r[27].s64 + 64;
	// 8250408C: 7F195800  cmpw cr6, r25, r11
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82504090: 4198FF50  blt cr6, 0x82503fe0
	if ctx.cr[6].lt {
	pc = 0x82503FE0; continue 'dispatch;
	}
	pc = 0x82504094; continue 'dispatch;
            }
            0x82504094 => {
    //   block [0x82504094..0x825040A0)
	// 82504094: 386000C0  li r3, 0xc0
	ctx.r[3].s64 = 192;
	// 82504098: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8250409C: 48031060  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            0x825040A0 => {
    //   block [0x825040A0..0x825040AC)
	// 825040A0: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 825040A4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825040A8: 48031054  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825040B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825040B0 size=140
    let mut pc: u32 = 0x825040B0;
    'dispatch: loop {
        match pc {
            0x825040B0 => {
    //   block [0x825040B0..0x825040EC)
	// 825040B0: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 825040B4: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 825040B8: 54880000  rlwinm r8, r4, 0, 0, 0
	ctx.r[8].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	// 825040BC: 5489007E  clrlwi r9, r4, 1
	ctx.r[9].u64 = ctx.r[4].u32 as u64 & 0x7FFFFFFFu64;
	// 825040C0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 825040C4: 210B0020  subfic r8, r11, 0x20
	ctx.xer.ca = ctx.r[11].u32 <= 32 as u32;
	ctx.r[8].s64 = (32 as i64) - ctx.r[11].s64;
	// 825040C8: 7D4B5C30  srw r11, r10, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[10].u32) >> ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 825040CC: 7D672038  and r7, r11, r4
	ctx.r[7].u64 = ctx.r[11].u64 & ctx.r[4].u64;
	// 825040D0: 7D2B4430  srw r11, r9, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[9].u32) >> ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 825040D4: 409A0020  bne cr6, 0x825040f4
	if !ctx.cr[6].eq {
	pc = 0x825040F4; continue 'dispatch;
	}
	// 825040D8: 81430054  lwz r10, 0x54(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(84 as u32) ) } as u64;
	// 825040DC: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 825040E0: 409A000C  bne cr6, 0x825040ec
	if !ctx.cr[6].eq {
	pc = 0x825040EC; continue 'dispatch;
	}
	// 825040E4: 39630070  addi r11, r3, 0x70
	ctx.r[11].s64 = ctx.r[3].s64 + 112;
	// 825040E8: 48000018  b 0x82504100
	pc = 0x82504100; continue 'dispatch;
            }
            0x825040EC => {
    //   block [0x825040EC..0x825040F4)
	// 825040EC: 81430050  lwz r10, 0x50(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) } as u64;
	// 825040F0: 48000008  b 0x825040f8
	pc = 0x825040F8; continue 'dispatch;
            }
            0x825040F4 => {
    //   block [0x825040F4..0x825040F8)
	// 825040F4: 81430058  lwz r10, 0x58(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) } as u64;
	pc = 0x825040F8; continue 'dispatch;
            }
            0x825040F8 => {
    //   block [0x825040F8..0x82504100)
	// 825040F8: 556B3032  slwi r11, r11, 6
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825040FC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	pc = 0x82504100; continue 'dispatch;
            }
            0x82504100 => {
    //   block [0x82504100..0x8250413C)
	// 82504100: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82504104: A10B0002  lhz r8, 2(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82504108: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8250410C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82504110: 7D080734  extsh r8, r8
	ctx.r[8].s64 = ctx.r[8].s16 as i64;
	// 82504114: 419A0038  beq cr6, 0x8250414c
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x8250414C);
		return;
	}
	// 82504118: 88AB0001  lbz r5, 1(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 8250411C: A0CB0008  lhz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82504120: 2B050001  cmplwi cr6, r5, 1
	ctx.cr[6].compare_u32(ctx.r[5].u32, 1 as u32, &mut ctx.xer);
	// 82504124: 7D6639D6  mullw r11, r6, r7
	ctx.r[11].s32 = ((ctx.r[6].s32 as i64 * ctx.r[7].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82504128: 409A0014  bne cr6, 0x8250413c
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x8250413C);
		return;
	}
	// 8250412C: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82504130: 7D6B41D6  mullw r11, r11, r8
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82504134: 7C6B4A14  add r3, r11, r9
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82504138: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82504158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82504158 size=68
    let mut pc: u32 = 0x82504158;
    'dispatch: loop {
        match pc {
            0x82504158 => {
    //   block [0x82504158..0x82504188)
	// 82504158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250415C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82504160: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82504164: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82504168: 4BFFFF49  bl 0x825040b0
	ctx.lr = 0x8250416C;
	sub_825040B0(ctx, base);
	// 8250416C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82504170: 419A0018  beq cr6, 0x82504188
	if ctx.cr[6].eq {
	pc = 0x82504188; continue 'dispatch;
	}
	// 82504174: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82504178: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8250417C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82504180: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82504184: 4E800020  blr
	return;
            }
            0x82504188 => {
    //   block [0x82504188..0x8250419C)
	// 82504188: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8250418C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82504190: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82504194: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82504198: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825041A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825041A0 size=168
    let mut pc: u32 = 0x825041A0;
    'dispatch: loop {
        match pc {
            0x825041A0 => {
    //   block [0x825041A0..0x82504248)
	// 825041A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825041A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825041A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825041AC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825041B0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 825041B4: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 825041B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825041BC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825041C0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825041C4: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825041C8: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 825041CC: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825041D0: C0060000  lfs f0, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825041D4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825041D8: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825041DC: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825041E0: C0060004  lfs f0, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825041E4: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 825041E8: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825041EC: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825041F0: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 825041F4: C0060008  lfs f0, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825041F8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825041FC: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82504200: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82504248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82504248 size=268
    let mut pc: u32 = 0x82504248;
    'dispatch: loop {
        match pc {
            0x82504248 => {
    //   block [0x82504248..0x82504354)
	// 82504248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250424C: 48030E61  bl 0x825350ac
	ctx.lr = 0x82504250;
	sub_82535080(ctx, base);
	// 82504250: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82504254: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82504258: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 8250425C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82504260: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82504264: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82504268: C00B8CB4  lfs f0, -0x734c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8250426C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82504270: D01B0000  stfs f0, 0(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82504274: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82504358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82504358 size=244
    let mut pc: u32 = 0x82504358;
    'dispatch: loop {
        match pc {
            0x82504358 => {
    //   block [0x82504358..0x8250444C)
	// 82504358: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250435C: 48030D59  bl 0x825350b4
	ctx.lr = 0x82504360;
	sub_82535080(ctx, base);
	// 82504360: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82504364: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82504368: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8250436C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82504370: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 82504374: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82504378: 3929FA60  addi r9, r9, -0x5a0
	ctx.r[9].s64 = ctx.r[9].s64 + -1440;
	// 8250437C: C00B8CB4  lfs f0, -0x734c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82504380: 3B9F0010  addi r28, r31, 0x10
	ctx.r[28].s64 = ctx.r[31].s64 + 16;
	// 82504384: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82504388: 397E0030  addi r11, r30, 0x30
	ctx.r[11].s64 = ctx.r[30].s64 + 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82504450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82504450 size=408
    let mut pc: u32 = 0x82504450;
    'dispatch: loop {
        match pc {
            0x82504450 => {
    //   block [0x82504450..0x825045E8)
	// 82504450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82504454: 48030C65  bl 0x825350b8
	ctx.lr = 0x82504458;
	sub_82535080(ctx, base);
	// 82504458: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825045E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825045E8 size=388
    let mut pc: u32 = 0x825045E8;
    'dispatch: loop {
        match pc {
            0x825045E8 => {
    //   block [0x825045E8..0x82504684)
	// 825045E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825045EC: 48030AC5  bl 0x825350b0
	ctx.lr = 0x825045F0;
	sub_82535080(ctx, base);
	// 825045F0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825045F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825045F8: 812D0000  lwz r9, 0(r13)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825045FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82504600: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82504604: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82504608: 397F0030  addi r11, r31, 0x30
	ctx.r[11].s64 = ctx.r[31].s64 + 48;
	// 8250460C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82504610: 995F0000  stb r10, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82504614: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82504618: 995F0001  stb r10, 1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1 as u32), ctx.r[10].u8 ) };
	// 8250461C: 577C103A  slwi r28, r27, 2
	ctx.r[28].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82504620: B3BF0008  sth r29, 8(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u16 ) };
	// 82504624: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82504628: B3BF0002  sth r29, 2(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(2 as u32), ctx.r[29].u16 ) };
	// 8250462C: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82504630: B15F000A  sth r10, 0xa(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(10 as u32), ctx.r[10].u16 ) };
	// 82504634: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82504638: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 8250463C: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82504640: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82504644: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82504648: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250464C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82504650: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82504654: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82504658: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 8250465C: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82504660: 7C68482E  lwzx r3, r8, r9
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82504664: 4BF5F9D5  bl 0x82464038
	ctx.lr = 0x82504668;
	sub_82464038(ctx, base);
	// 82504668: 5789F0BE  srwi r9, r28, 2
	ctx.r[9].u32 = ctx.r[28].u32.wrapping_shr(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8250466C: 937F0014  stw r27, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[27].u32 ) };
	// 82504670: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82504674: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 82504678: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 8250467C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82504680: 40990020  ble cr6, 0x825046a0
	if !ctx.cr[6].gt {
	pc = 0x825046A0; continue 'dispatch;
	}
	pc = 0x82504684; continue 'dispatch;
            }
            0x82504684 => {
    //   block [0x82504684..0x825046A0)
	// 82504684: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82504688: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 8250468C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82504690: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82504694: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82504698: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 8250469C: 409AFFE8  bne cr6, 0x82504684
	if !ctx.cr[6].eq {
	pc = 0x82504684; continue 'dispatch;
	}
	pc = 0x825046A0; continue 'dispatch;
            }
            0x825046A0 => {
    //   block [0x825046A0..0x825046AC)
	// 825046A0: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 825046A4: 40990038  ble cr6, 0x825046dc
	if !ctx.cr[6].gt {
	pc = 0x825046DC; continue 'dispatch;
	}
	// 825046A8: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x825046AC; continue 'dispatch;
            }
            0x825046AC => {
    //   block [0x825046AC..0x825046CC)
	// 825046AC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825046B0: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825046B4: A12B0004  lhz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825046B8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825046BC: 419A0010  beq cr6, 0x825046cc
	if ctx.cr[6].eq {
	pc = 0x825046CC; continue 'dispatch;
	}
	// 825046C0: A12B0006  lhz r9, 6(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 825046C4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825046C8: B12B0006  sth r9, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	pc = 0x825046CC; continue 'dispatch;
            }
            0x825046CC => {
    //   block [0x825046CC..0x825046DC)
	// 825046CC: 3B7BFFFF  addi r27, r27, -1
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	// 825046D0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825046D4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 825046D8: 409AFFD4  bne cr6, 0x825046ac
	if !ctx.cr[6].eq {
	pc = 0x825046AC; continue 'dispatch;
	}
	pc = 0x825046DC; continue 'dispatch;
            }
            0x825046DC => {
    //   block [0x825046DC..0x8250476C)
	// 825046DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825046E0: 117F038C  vspltisw v11, -1
	for i in 0..4 {
		ctx.v[11].u32[i] = 4294967295;
	}
	// 825046E4: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 825046E8: C00B2238  lfs f0, 0x2238(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8760 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825046EC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825046F0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825046F4: 396B9FA0  addi r11, r11, -0x6060
	ctx.r[11].s64 = ctx.r[11].s64 + -24672;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82504770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82504770 size=420
    let mut pc: u32 = 0x82504770;
    'dispatch: loop {
        match pc {
            0x82504770 => {
    //   block [0x82504770..0x8250481C)
	// 82504770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82504774: 48030939  bl 0x825350ac
	ctx.lr = 0x82504778;
	sub_82535080(ctx, base);
	// 82504778: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250477C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82504780: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82504784: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82504788: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 8250478C: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82504790: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82504794: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 82504798: 997F0000  stb r11, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 8250479C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 825047A0: 997F0001  stb r11, 1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 825047A4: B3BF0008  sth r29, 8(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u16 ) };
	// 825047A8: B3BF0002  sth r29, 2(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(2 as u32), ctx.r[29].u16 ) };
	// 825047AC: B17F000A  sth r11, 0xa(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(10 as u32), ctx.r[11].u16 ) };
	// 825047B0: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 825047B4: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 825047B8: 480A3F99  bl 0x825a8750
	ctx.lr = 0x825047BC;
	sub_825A8750(ctx, base);
	// 825047BC: 397A0030  addi r11, r26, 0x30
	ctx.r[11].s64 = ctx.r[26].s64 + 48;
	// 825047C0: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825047C4: 3BDF0030  addi r30, r31, 0x30
	ctx.r[30].s64 = ctx.r[31].s64 + 48;
	// 825047C8: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825047CC: 577C103A  slwi r28, r27, 2
	ctx.r[28].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 825047D0: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 825047D4: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825047D8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825047DC: 911E0000  stw r8, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825047E0: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825047E4: 911E0004  stw r8, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 825047E8: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825047EC: 911E0008  stw r8, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825047F0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825047F4: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825047F8: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825047FC: 4BF5F83D  bl 0x82464038
	ctx.lr = 0x82504800;
	sub_82464038(ctx, base);
	// 82504800: 5789F0BE  srwi r9, r28, 2
	ctx.r[9].u32 = ctx.r[28].u32.wrapping_shr(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82504804: 937F0014  stw r27, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[27].u32 ) };
	// 82504808: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 8250480C: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 82504810: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82504814: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82504818: 40990020  ble cr6, 0x82504838
	if !ctx.cr[6].gt {
	pc = 0x82504838; continue 'dispatch;
	}
	pc = 0x8250481C; continue 'dispatch;
            }
            0x8250481C => {
    //   block [0x8250481C..0x82504838)
	// 8250481C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82504820: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82504824: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82504828: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8250482C: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82504830: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82504834: 409AFFE8  bne cr6, 0x8250481c
	if !ctx.cr[6].eq {
	pc = 0x8250481C; continue 'dispatch;
	}
	pc = 0x82504838; continue 'dispatch;
            }
            0x82504838 => {
    //   block [0x82504838..0x82504840)
	// 82504838: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 8250483C: 40990034  ble cr6, 0x82504870
	if !ctx.cr[6].gt {
	pc = 0x82504870; continue 'dispatch;
	}
	pc = 0x82504840; continue 'dispatch;
            }
            0x82504840 => {
    //   block [0x82504840..0x82504860)
	// 82504840: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82504844: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82504848: A14B0004  lhz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250484C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82504850: 419A0010  beq cr6, 0x82504860
	if ctx.cr[6].eq {
	pc = 0x82504860; continue 'dispatch;
	}
	// 82504854: A14B0006  lhz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 82504858: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8250485C: B14B0006  sth r10, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	pc = 0x82504860; continue 'dispatch;
            }
            0x82504860 => {
    //   block [0x82504860..0x82504870)
	// 82504860: 3B7BFFFF  addi r27, r27, -1
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	// 82504864: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82504868: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8250486C: 409AFFD4  bne cr6, 0x82504840
	if !ctx.cr[6].eq {
	pc = 0x82504840; continue 'dispatch;
	}
	pc = 0x82504870; continue 'dispatch;
            }
            0x82504870 => {
    //   block [0x82504870..0x82504914)
	// 82504870: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82504918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82504918 size=160
    let mut pc: u32 = 0x82504918;
    'dispatch: loop {
        match pc {
            0x82504918 => {
    //   block [0x82504918..0x8250493C)
	// 82504918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250491C: 480307A1  bl 0x825350bc
	ctx.lr = 0x82504920;
	sub_82535080(ctx, base);
	// 82504920: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82504924: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82504928: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8250492C: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82504930: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82504934: 4099005C  ble cr6, 0x82504990
	if !ctx.cr[6].gt {
	pc = 0x82504990; continue 'dispatch;
	}
	// 82504938: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x8250493C; continue 'dispatch;
            }
            0x8250493C => {
    //   block [0x8250493C..0x8250497C)
	// 8250493C: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82504940: 7C6BF82E  lwzx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82504944: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82504948: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8250494C: 419A0030  beq cr6, 0x8250497c
	if ctx.cr[6].eq {
	pc = 0x8250497C; continue 'dispatch;
	}
	// 82504950: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 82504954: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82504958: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 8250495C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82504960: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 82504964: 409A0018  bne cr6, 0x8250497c
	if !ctx.cr[6].eq {
	pc = 0x8250497C; continue 'dispatch;
	}
	// 82504968: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250496C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82504970: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82504974: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82504978: 4E800421  bctrl
	ctx.lr = 0x8250497C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8250497C => {
    //   block [0x8250497C..0x82504990)
	// 8250497C: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82504980: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82504984: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82504988: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8250498C: 4198FFB0  blt cr6, 0x8250493c
	if ctx.cr[6].lt {
	pc = 0x8250493C; continue 'dispatch;
	}
	pc = 0x82504990; continue 'dispatch;
            }
            0x82504990 => {
    //   block [0x82504990..0x825049B8)
	// 82504990: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82504994: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82504998: 813E0014  lwz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 8250499C: 38C00027  li r6, 0x27
	ctx.r[6].s64 = 39;
	// 825049A0: 809E0010  lwz r4, 0x10(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825049A4: 5525103A  slwi r5, r9, 2
	ctx.r[5].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 825049A8: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825049AC: 4BF5F70D  bl 0x824640b8
	ctx.lr = 0x825049B0;
	sub_824640B8(ctx, base);
	// 825049B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825049B4: 48030758  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825049B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825049B8 size=44
    let mut pc: u32 = 0x825049B8;
    'dispatch: loop {
        match pc {
            0x825049B8 => {
    //   block [0x825049B8..0x825049E4)
	// 825049B8: 81630054  lwz r11, 0x54(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(84 as u32) ) } as u64;
	// 825049BC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825049C0: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 825049C4: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825049C8: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 825049CC: 80830050  lwz r4, 0x50(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) } as u64;
	// 825049D0: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825049D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825049D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825049DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825049E0: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825049E4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825049E4 size=4
    let mut pc: u32 = 0x825049E4;
    'dispatch: loop {
        match pc {
            0x825049E4 => {
    //   block [0x825049E4..0x825049E8)
	// 825049E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825049E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825049E8 size=32
    let mut pc: u32 = 0x825049E8;
    'dispatch: loop {
        match pc {
            0x825049E8 => {
    //   block [0x825049E8..0x82504A08)
	// 825049E8: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825049EC: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 825049F0: 80830058  lwz r4, 0x58(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) } as u64;
	// 825049F4: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825049F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825049FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82504A00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82504A04: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82504A08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82504A08 size=256
    let mut pc: u32 = 0x82504A08;
    'dispatch: loop {
        match pc {
            0x82504A08 => {
    //   block [0x82504A08..0x82504B08)
	// 82504A08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82504A0C: 480306B1  bl 0x825350bc
	ctx.lr = 0x82504A10;
	sub_82535080(ctx, base);
	// 82504A10: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82504A14: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82504A18: 3880000F  li r4, 0xf
	ctx.r[4].s64 = 15;
	// 82504A1C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82504A20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82504A24: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82504A28: 48006899  bl 0x8250b2c0
	ctx.lr = 0x82504A2C;
	sub_8250B2C0(ctx, base);
	// 82504A2C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82504A30: 395F0070  addi r10, r31, 0x70
	ctx.r[10].s64 = ctx.r[31].s64 + 112;
	// 82504A34: 3C808000  lis r4, -0x8000
	ctx.r[4].s64 = -2147483648;
	// 82504A38: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82504A3C: 38CA0020  addi r6, r10, 0x20
	ctx.r[6].s64 = ctx.r[10].s64 + 32;
	// 82504A40: C00B1850  lfs f0, 0x1850(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82504A44: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82504A48: 3BA00006  li r29, 6
	ctx.r[29].s64 = 6;
	// 82504A4C: 392B46F0  addi r9, r11, 0x46f0
	ctx.r[9].s64 = ctx.r[11].s64 + 18160;
	// 82504A50: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82504A54: 38FF0040  addi r7, r31, 0x40
	ctx.r[7].s64 = ctx.r[31].s64 + 64;
	// 82504A58: 390B46CC  addi r8, r11, 0x46cc
	ctx.r[8].s64 = ctx.r[11].s64 + 18124;
	// 82504A5C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82504A60: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82504A64: 393F0020  addi r9, r31, 0x20
	ctx.r[9].s64 = ctx.r[31].s64 + 32;
	// 82504A68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82504A6C: 911F0010  stw r8, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 82504A70: 391F0030  addi r8, r31, 0x30
	ctx.r[8].s64 = ctx.r[31].s64 + 48;
	// 82504A74: C1AB0DA0  lfs f13, 0xda0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3488 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82504A78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82504A7C: 909F0068  stw r4, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[4].u32 ) };
	// 82504A80: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82504A84: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82504A88: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82504A8C: 98AA0001  stb r5, 1(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(1 as u32), ctx.r[5].u8 ) };
	// 82504A90: B16A0008  sth r11, 8(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u16 ) };
	// 82504A94: B16A0002  sth r11, 2(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(2 as u32), ctx.r[11].u16 ) };
	// 82504A98: B0AA000A  sth r5, 0xa(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(10 as u32), ctx.r[5].u16 ) };
	// 82504A9C: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82504AA0: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82504AA4: 996A0039  stb r11, 0x39(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(57 as u32), ctx.r[11].u8 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82504B08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82504B08 size=868
    let mut pc: u32 = 0x82504B08;
    'dispatch: loop {
        match pc {
            0x82504B08 => {
    //   block [0x82504B08..0x82504E6C)
	// 82504B08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82504B0C: 480305A1  bl 0x825350ac
	ctx.lr = 0x82504B10;
	sub_82535080(ctx, base);
	// 82504B10: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82504B14: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82504B18: 3880000F  li r4, 0xf
	ctx.r[4].s64 = 15;
	// 82504B1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82504B20: 480067A1  bl 0x8250b2c0
	ctx.lr = 0x82504B24;
	sub_8250B2C0(ctx, base);
	// 82504B24: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82504B28: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 82504B2C: 396B46F0  addi r11, r11, 0x46f0
	ctx.r[11].s64 = ctx.r[11].s64 + 18160;
	// 82504B30: 3BBF0070  addi r29, r31, 0x70
	ctx.r[29].s64 = ctx.r[31].s64 + 112;
	// 82504B34: 394A46CC  addi r10, r10, 0x46cc
	ctx.r[10].s64 = ctx.r[10].s64 + 18124;
	// 82504B38: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82504B3C: 3B7F0060  addi r27, r31, 0x60
	ctx.r[27].s64 = ctx.r[31].s64 + 96;
	// 82504B40: 3D208000  lis r9, -0x8000
	ctx.r[9].s64 = -2147483648;
	// 82504B44: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82504B48: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 82504B4C: 397D0020  addi r11, r29, 0x20
	ctx.r[11].s64 = ctx.r[29].s64 + 32;
	// 82504B50: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82504B54: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 82504B58: 939B0000  stw r28, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82504B5C: 3B5E0040  addi r26, r30, 0x40
	ctx.r[26].s64 = ctx.r[30].s64 + 64;
	// 82504B60: 939B0004  stw r28, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82504B64: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82504B68: 9B9D0000  stb r28, 0(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[28].u8 ) };
	// 82504B6C: 9B3D0001  stb r25, 1(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(1 as u32), ctx.r[25].u8 ) };
	// 82504B70: B39D0008  sth r28, 8(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[28].u16 ) };
	// 82504B74: B39D0002  sth r28, 2(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(2 as u32), ctx.r[28].u16 ) };
	// 82504B78: B33D000A  sth r25, 0xa(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(10 as u32), ctx.r[25].u16 ) };
	// 82504B7C: 939D000C  stw r28, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82504B80: 939D0004  stw r28, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82504B84: 9B9D0039  stb r28, 0x39(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(57 as u32), ctx.r[28].u8 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82504E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82504E70 size=368
    let mut pc: u32 = 0x82504E70;
    'dispatch: loop {
        match pc {
            0x82504E70 => {
    //   block [0x82504E70..0x82504EB4)
	// 82504E70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82504E74: 48030235  bl 0x825350a8
	ctx.lr = 0x82504E78;
	sub_82535080(ctx, base);
	// 82504E78: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82504E7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82504E80: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82504E84: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 82504E88: 396B46F0  addi r11, r11, 0x46f0
	ctx.r[11].s64 = ctx.r[11].s64 + 18160;
	// 82504E8C: 394A46CC  addi r10, r10, 0x46cc
	ctx.r[10].s64 = ctx.r[10].s64 + 18124;
	// 82504E90: 813E005C  lwz r9, 0x5c(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(92 as u32) ) } as u64;
	// 82504E94: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82504E98: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82504E9C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82504EA0: 915E0010  stw r10, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82504EA4: 409900AC  ble cr6, 0x82504f50
	if !ctx.cr[6].gt {
	pc = 0x82504F50; continue 'dispatch;
	}
	// 82504EA8: 830D0000  lwz r24, 0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82504EAC: 3B200010  li r25, 0x10
	ctx.r[25].s64 = 16;
	// 82504EB0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	pc = 0x82504EB4; continue 'dispatch;
            }
            0x82504EB4 => {
    //   block [0x82504EB4..0x82504ED0)
	// 82504EB4: 817E0058  lwz r11, 0x58(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) } as u64;
	// 82504EB8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82504EBC: 7FEBDA14  add r31, r11, r27
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82504EC0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82504EC4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82504EC8: 4099005C  ble cr6, 0x82504f24
	if !ctx.cr[6].gt {
	pc = 0x82504F24; continue 'dispatch;
	}
	// 82504ECC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82504ED0; continue 'dispatch;
            }
            0x82504ED0 => {
    //   block [0x82504ED0..0x82504F10)
	// 82504ED0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82504ED4: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82504ED8: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82504EDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82504EE0: 419A0030  beq cr6, 0x82504f10
	if ctx.cr[6].eq {
	pc = 0x82504F10; continue 'dispatch;
	}
	// 82504EE4: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 82504EE8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82504EEC: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 82504EF0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82504EF4: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 82504EF8: 409A0018  bne cr6, 0x82504f10
	if !ctx.cr[6].eq {
	pc = 0x82504F10; continue 'dispatch;
	}
	// 82504EFC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82504F00: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82504F04: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82504F08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82504F0C: 4E800421  bctrl
	ctx.lr = 0x82504F10;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82504F10 => {
    //   block [0x82504F10..0x82504F24)
	// 82504F10: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82504F14: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82504F18: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82504F1C: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82504F20: 4198FFB0  blt cr6, 0x82504ed0
	if ctx.cr[6].lt {
	pc = 0x82504ED0; continue 'dispatch;
	}
	pc = 0x82504F24; continue 'dispatch;
            }
            0x82504F24 => {
    //   block [0x82504F24..0x82504F50)
	// 82504F24: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82504F28: 38C00027  li r6, 0x27
	ctx.r[6].s64 = 39;
	// 82504F2C: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82504F30: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82504F34: 7C79C02E  lwzx r3, r25, r24
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 82504F38: 4BF5F181  bl 0x824640b8
	ctx.lr = 0x82504F3C;
	sub_824640B8(ctx, base);
	// 82504F3C: 817E005C  lwz r11, 0x5c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(92 as u32) ) } as u64;
	// 82504F40: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82504F44: 3B7B0040  addi r27, r27, 0x40
	ctx.r[27].s64 = ctx.r[27].s64 + 64;
	// 82504F48: 7F1A5800  cmpw cr6, r26, r11
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82504F4C: 4198FF68  blt cr6, 0x82504eb4
	if ctx.cr[6].lt {
	pc = 0x82504EB4; continue 'dispatch;
	}
	pc = 0x82504F50; continue 'dispatch;
            }
            0x82504F50 => {
    //   block [0x82504F50..0x82504F7C)
	// 82504F50: 817E0054  lwz r11, 0x54(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 82504F54: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82504F58: 40990024  ble cr6, 0x82504f7c
	if !ctx.cr[6].gt {
	pc = 0x82504F7C; continue 'dispatch;
	}
	// 82504F5C: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82504F60: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82504F64: 809E0050  lwz r4, 0x50(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 82504F68: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82504F6C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82504F70: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82504F74: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82504F78: 4E800421  bctrl
	ctx.lr = 0x82504F7C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82504F7C => {
    //   block [0x82504F7C..0x82504FC0)
	// 82504F7C: 83AD0000  lwz r29, 0(r13)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82504F80: 3BE00010  li r31, 0x10
	ctx.r[31].s64 = 16;
	// 82504F84: 809E0058  lwz r4, 0x58(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) } as u64;
	// 82504F88: 7C7FE82E  lwzx r3, r31, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82504F8C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82504F90: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82504F94: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82504F98: 4E800421  bctrl
	ctx.lr = 0x82504F9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82504F9C: 817E0068  lwz r11, 0x68(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) } as u64;
	// 82504FA0: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82504FA4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82504FA8: 409A0018  bne cr6, 0x82504fc0
	if !ctx.cr[6].eq {
	pc = 0x82504FC0; continue 'dispatch;
	}
	// 82504FAC: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 82504FB0: 809E0060  lwz r4, 0x60(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 82504FB4: 5565087C  rlwinm r5, r11, 1, 1, 0x1e
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 82504FB8: 7C7FE82E  lwzx r3, r31, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82504FBC: 4BF5F0FD  bl 0x824640b8
	ctx.lr = 0x82504FC0;
	sub_824640B8(ctx, base);
            }
            0x82504FC0 => {
    //   block [0x82504FC0..0x82504FE0)
	// 82504FC0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82504FC4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82504FC8: 396B2A44  addi r11, r11, 0x2a44
	ctx.r[11].s64 = ctx.r[11].s64 + 10820;
	// 82504FCC: 394A6DD0  addi r10, r10, 0x6dd0
	ctx.r[10].s64 = ctx.r[10].s64 + 28112;
	// 82504FD0: 917E0010  stw r11, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82504FD4: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82504FD8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82504FDC: 4803011C  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82504FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82504FE0 size=420
    let mut pc: u32 = 0x82504FE0;
    'dispatch: loop {
        match pc {
            0x82504FE0 => {
    //   block [0x82504FE0..0x82505048)
	// 82504FE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82504FE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82504FE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82504FEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82504FF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82504FF4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82504FF8: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 82504FFC: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 82505000: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82505004: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82505008: 396B2A44  addi r11, r11, 0x2a44
	ctx.r[11].s64 = ctx.r[11].s64 + 10820;
	// 8250500C: 394A46F0  addi r10, r10, 0x46f0
	ctx.r[10].s64 = ctx.r[10].s64 + 18160;
	// 82505010: 392946CC  addi r9, r9, 0x46cc
	ctx.r[9].s64 = ctx.r[9].s64 + 18124;
	// 82505014: 38E00008  li r7, 8
	ctx.r[7].s64 = 8;
	// 82505018: B11F0006  sth r8, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[8].u16 ) };
	// 8250501C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82505020: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82505024: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82505028: 913F0010  stw r9, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 8250502C: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82505030: 419A0130  beq cr6, 0x82505160
	if ctx.cr[6].eq {
	pc = 0x82505160; continue 'dispatch;
	}
	// 82505034: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82505038: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8250503C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82505040: 40990034  ble cr6, 0x82505074
	if !ctx.cr[6].gt {
	pc = 0x82505074; continue 'dispatch;
	}
	// 82505044: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82505048; continue 'dispatch;
            }
            0x82505048 => {
    //   block [0x82505048..0x82505060)
	// 82505048: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 8250504C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82505050: 88EB0001  lbz r7, 1(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82505054: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82505058: 409A0008  bne cr6, 0x82505060
	if !ctx.cr[6].eq {
	pc = 0x82505060; continue 'dispatch;
	}
	// 8250505C: 990B0001  stb r8, 1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1 as u32), ctx.r[8].u8 ) };
	pc = 0x82505060; continue 'dispatch;
            }
            0x82505060 => {
    //   block [0x82505060..0x82505074)
	// 82505060: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82505064: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82505068: 394A0040  addi r10, r10, 0x40
	ctx.r[10].s64 = ctx.r[10].s64 + 64;
	// 8250506C: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82505070: 4198FFD8  blt cr6, 0x82505048
	if ctx.cr[6].lt {
	pc = 0x82505048; continue 'dispatch;
	}
	pc = 0x82505074; continue 'dispatch;
            }
            0x82505074 => {
    //   block [0x82505074..0x82505088)
	// 82505074: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82505078: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8250507C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82505080: 40990034  ble cr6, 0x825050b4
	if !ctx.cr[6].gt {
	pc = 0x825050B4; continue 'dispatch;
	}
	// 82505084: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82505088; continue 'dispatch;
            }
            0x82505088 => {
    //   block [0x82505088..0x825050A0)
	// 82505088: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 8250508C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82505090: 88EB0001  lbz r7, 1(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82505094: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82505098: 409A0008  bne cr6, 0x825050a0
	if !ctx.cr[6].eq {
	pc = 0x825050A0; continue 'dispatch;
	}
	// 8250509C: 990B0001  stb r8, 1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1 as u32), ctx.r[8].u8 ) };
	pc = 0x825050A0; continue 'dispatch;
            }
            0x825050A0 => {
    //   block [0x825050A0..0x825050B4)
	// 825050A0: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 825050A4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825050A8: 394A0040  addi r10, r10, 0x40
	ctx.r[10].s64 = ctx.r[10].s64 + 64;
	// 825050AC: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825050B0: 4198FFD8  blt cr6, 0x82505088
	if ctx.cr[6].lt {
	pc = 0x82505088; continue 'dispatch;
	}
	pc = 0x825050B4; continue 'dispatch;
            }
            0x825050B4 => {
    //   block [0x825050B4..0x825050CC)
	// 825050B4: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 825050B8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825050BC: 409A0010  bne cr6, 0x825050cc
	if !ctx.cr[6].eq {
	pc = 0x825050CC; continue 'dispatch;
	}
	// 825050C0: 3BDF0070  addi r30, r31, 0x70
	ctx.r[30].s64 = ctx.r[31].s64 + 112;
	// 825050C4: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 825050C8: 4800003C  b 0x82505104
	pc = 0x82505104; continue 'dispatch;
            }
            0x825050CC => {
    //   block [0x825050CC..0x82505104)
	// 825050CC: 40990048  ble cr6, 0x82505114
	if !ctx.cr[6].gt {
	pc = 0x82505114; continue 'dispatch;
	}
	// 825050D0: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825050D4: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825050D8: 55653032  slwi r5, r11, 6
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 825050DC: 38C00025  li r6, 0x25
	ctx.r[6].s64 = 37;
	// 825050E0: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 825050E4: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825050E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825050EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825050F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825050F4: 4E800421  bctrl
	ctx.lr = 0x825050F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825050F8: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 825050FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82505100: 55653032  slwi r5, r11, 6
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
            }
            0x82505104 => {
    //   block [0x82505104..0x82505114)
	// 82505104: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82505108: 809F0050  lwz r4, 0x50(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 8250510C: 4BF6521D  bl 0x8246a328
	ctx.lr = 0x82505110;
	sub_8246A328(ctx, base);
	// 82505110: 93DF0050  stw r30, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	pc = 0x82505114; continue 'dispatch;
            }
            0x82505114 => {
    //   block [0x82505114..0x82505160)
	// 82505114: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82505118: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8250511C: 40990044  ble cr6, 0x82505160
	if !ctx.cr[6].gt {
	pc = 0x82505160; continue 'dispatch;
	}
	// 82505120: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82505124: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82505128: 55653032  slwi r5, r11, 6
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 8250512C: 38C00025  li r6, 0x25
	ctx.r[6].s64 = 37;
	// 82505130: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 82505134: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82505138: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250513C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82505140: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82505144: 4E800421  bctrl
	ctx.lr = 0x82505148;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82505148: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 8250514C: 809F0058  lwz r4, 0x58(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82505150: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82505154: 55653032  slwi r5, r11, 6
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82505158: 4BF651D1  bl 0x8246a328
	ctx.lr = 0x8250515C;
	sub_8246A328(ctx, base);
	// 8250515C: 93DF0058  stw r30, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
            }
            0x82505160 => {
    //   block [0x82505160..0x82505184)
	// 82505160: 3960000F  li r11, 0xf
	ctx.r[11].s64 = 15;
	// 82505164: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82505168: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 8250516C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82505170: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82505174: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82505178: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8250517C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82505180: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82505188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82505188 size=364
    let mut pc: u32 = 0x82505188;
    'dispatch: loop {
        match pc {
            0x82505188 => {
    //   block [0x82505188..0x825051BC)
	// 82505188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250518C: 4802FF11  bl 0x8253509c
	ctx.lr = 0x82505190;
	sub_82535080(ctx, base);
	// 82505190: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82505194: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82505198: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 8250519C: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 825051A0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825051A4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825051A8: 817D0054  lwz r11, 0x54(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(84 as u32) ) } as u64;
	// 825051AC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825051B0: 40990038  ble cr6, 0x825051e8
	if !ctx.cr[6].gt {
	pc = 0x825051E8; continue 'dispatch;
	}
	// 825051B4: 815D0050  lwz r10, 0x50(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(80 as u32) ) } as u64;
	// 825051B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825051BC; continue 'dispatch;
            }
            0x825051BC => {
    //   block [0x825051BC..0x825051E8)
	// 825051BC: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825051C0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825051C4: 93EA003C  stw r31, 0x3c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(60 as u32), ctx.r[31].u32 ) };
	// 825051C8: 811D0054  lwz r8, 0x54(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(84 as u32) ) } as u64;
	// 825051CC: 815D0050  lwz r10, 0x50(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(80 as u32) ) } as u64;
	// 825051D0: 7F094000  cmpw cr6, r9, r8
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[8].s32, &mut ctx.xer);
	// 825051D4: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825051D8: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 825051DC: 81080010  lwz r8, 0x10(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) } as u64;
	// 825051E0: 7FE8FA14  add r31, r8, r31
	ctx.r[31].u64 = ctx.r[8].u64 + ctx.r[31].u64;
	// 825051E4: 4198FFD8  blt cr6, 0x825051bc
	if ctx.cr[6].lt {
	pc = 0x825051BC; continue 'dispatch;
	}
	pc = 0x825051E8; continue 'dispatch;
            }
            0x825051E8 => {
    //   block [0x825051E8..0x8250520C)
	// 825051E8: 3AFD0060  addi r23, r29, 0x60
	ctx.r[23].s64 = ctx.r[29].s64 + 96;
	// 825051EC: 81770008  lwz r11, 8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 825051F0: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825051F4: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 825051F8: 40980014  bge cr6, 0x8250520c
	if !ctx.cr[6].lt {
	pc = 0x8250520C; continue 'dispatch;
	}
	// 825051FC: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82505200: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82505204: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82505208: 4BF690C1  bl 0x8246e2c8
	ctx.lr = 0x8250520C;
	sub_8246E2C8(ctx, base);
	pc = 0x8250520C; continue 'dispatch;
            }
            0x8250520C => {
    //   block [0x8250520C..0x8250522C)
	// 8250520C: 81770008  lwz r11, 8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 82505210: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82505214: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 82505218: 40980024  bge cr6, 0x8250523c
	if !ctx.cr[6].lt {
	pc = 0x8250523C; continue 'dispatch;
	}
	// 8250521C: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82505220: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82505224: 41980008  blt cr6, 0x8250522c
	if ctx.cr[6].lt {
	pc = 0x8250522C; continue 'dispatch;
	}
	// 82505228: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x8250522C; continue 'dispatch;
            }
            0x8250522C => {
    //   block [0x8250522C..0x8250523C)
	// 8250522C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82505230: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82505234: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82505238: 4BF69091  bl 0x8246e2c8
	ctx.lr = 0x8250523C;
	sub_8246E2C8(ctx, base);
	pc = 0x8250523C; continue 'dispatch;
            }
            0x8250523C => {
    //   block [0x8250523C..0x82505258)
	// 8250523C: 93F70004  stw r31, 4(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82505240: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82505244: 817D0054  lwz r11, 0x54(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(84 as u32) ) } as u64;
	// 82505248: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 8250524C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82505250: 40990090  ble cr6, 0x825052e0
	if !ctx.cr[6].gt {
	pc = 0x825052E0; continue 'dispatch;
	}
	// 82505254: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	pc = 0x82505258; continue 'dispatch;
            }
            0x82505258 => {
    //   block [0x82505258..0x82505284)
	// 82505258: 817D0050  lwz r11, 0x50(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(80 as u32) ) } as u64;
	// 8250525C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82505260: 7D7A5A14  add r11, r26, r11
	ctx.r[11].u64 = ctx.r[26].u64 + ctx.r[11].u64;
	// 82505264: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82505268: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8250526C: 40990060  ble cr6, 0x825052cc
	if !ctx.cr[6].gt {
	pc = 0x825052CC; continue 'dispatch;
	}
	// 82505270: 3975FFFB  addi r11, r21, -5
	ctx.r[11].s64 = ctx.r[21].s64 + -5;
	// 82505274: 577E083C  slwi r30, r27, 1
	ctx.r[30].u32 = ctx.r[27].u32.wrapping_shl(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82505278: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8250527C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82505280: 69790001  xori r25, r11, 1
	ctx.r[25].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x82505284; continue 'dispatch;
            }
            0x82505284 => {
    //   block [0x82505284..0x825052CC)
	// 82505284: 815D0018  lwz r10, 0x18(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82505288: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 8250528C: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82505290: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82505294: 214A0020  subfic r10, r10, 0x20
	ctx.xer.ca = ctx.r[10].u32 <= 32 as u32;
	ctx.r[10].s64 = (32 as i64) - ctx.r[10].s64;
	// 82505298: 7F8BF214  add r28, r11, r30
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 8250529C: 7F0B5030  slw r11, r24, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[24].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 825052A0: 7D63FB78  or r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 | ctx.r[31].u64;
	// 825052A4: 48024B4D  bl 0x82529df0
	ctx.lr = 0x825052A8;
	sub_82529DF0(ctx, base);
	// 825052A8: B07C0000  sth r3, 0(r28)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[3].u16 ) };
	// 825052AC: 817D0050  lwz r11, 0x50(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(80 as u32) ) } as u64;
	// 825052B0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825052B4: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 825052B8: 7D7A5A14  add r11, r26, r11
	ctx.r[11].u64 = ctx.r[26].u64 + ctx.r[11].u64;
	// 825052BC: 3BDE0002  addi r30, r30, 2
	ctx.r[30].s64 = ctx.r[30].s64 + 2;
	// 825052C0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825052C4: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825052C8: 4198FFBC  blt cr6, 0x82505284
	if ctx.cr[6].lt {
	pc = 0x82505284; continue 'dispatch;
	}
	pc = 0x825052CC; continue 'dispatch;
            }
            0x825052CC => {
    //   block [0x825052CC..0x825052E0)
	// 825052CC: 817D0054  lwz r11, 0x54(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(84 as u32) ) } as u64;
	// 825052D0: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 825052D4: 3B5A0040  addi r26, r26, 0x40
	ctx.r[26].s64 = ctx.r[26].s64 + 64;
	// 825052D8: 7F185800  cmpw cr6, r24, r11
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825052DC: 4198FF7C  blt cr6, 0x82505258
	if ctx.cr[6].lt {
	pc = 0x82505258; continue 'dispatch;
	}
	pc = 0x825052E0; continue 'dispatch;
            }
            0x825052E0 => {
    //   block [0x825052E0..0x825052F4)
	// 825052E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825052E4: 997D0014  stb r11, 0x14(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 825052E8: 9ABD006C  stb r21, 0x6c(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(108 as u32), ctx.r[21].u8 ) };
	// 825052EC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825052F0: 4802FDFC  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825052F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825052F8 size=200
    let mut pc: u32 = 0x825052F8;
    'dispatch: loop {
        match pc {
            0x825052F8 => {
    //   block [0x825052F8..0x82505328)
	// 825052F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825052FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82505300: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82505304: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82505308: 9421FD80  stwu r1, -0x280(r1)
	ea = ctx.r[1].u32.wrapping_add(-640 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250530C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82505310: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82505314: 815F004C  lwz r10, 0x4c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82505318: 7D4A5A15  add. r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8250531C: 4082000C  bne 0x82505328
	if !ctx.cr[0].eq {
	pc = 0x82505328; continue 'dispatch;
	}
	// 82505320: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82505324: 48000084  b 0x825053a8
	pc = 0x825053A8; continue 'dispatch;
            }
            0x82505328 => {
    //   block [0x82505328..0x82505338)
	// 82505328: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8250532C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82505330: 409A0008  bne cr6, 0x82505338
	if !ctx.cr[6].eq {
	pc = 0x82505338; continue 'dispatch;
	}
	// 82505334: 3FC08000  lis r30, -0x8000
	ctx.r[30].s64 = -2147483648;
	pc = 0x82505338; continue 'dispatch;
            }
            0x82505338 => {
    //   block [0x82505338..0x82505360)
	// 82505338: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250533C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82505340: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82505344: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82505348: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8250534C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82505350: 4E800421  bctrl
	ctx.lr = 0x82505354;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82505354: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82505358: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 8250535C: 419A000C  beq cr6, 0x82505368
	if ctx.cr[6].eq {
	pc = 0x82505368; continue 'dispatch;
	}
            }
            0x82505360 => {
    //   block [0x82505360..0x82505368)
	// 82505360: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82505364: 48000044  b 0x825053a8
	pc = 0x825053A8; continue 'dispatch;
            }
            0x82505368 => {
    //   block [0x82505368..0x825053A8)
	// 82505368: 3D608282  lis r11, -0x7d7e
	ctx.r[11].s64 = -2105409536;
	// 8250536C: 38C30040  addi r6, r3, 0x40
	ctx.r[6].s64 = ctx.r[3].s64 + 64;
	// 82505370: 38A30030  addi r5, r3, 0x30
	ctx.r[5].s64 = ctx.r[3].s64 + 48;
	// 82505374: 38830020  addi r4, r3, 0x20
	ctx.r[4].s64 = ctx.r[3].s64 + 32;
	// 82505378: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8250537C: C02BE098  lfs f1, -0x1f68(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8040 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82505380: 48024DC1  bl 0x8252a140
	ctx.lr = 0x82505384;
	sub_8252A140(ctx, base);
	// 82505384: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82505388: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8250538C: 419AFFD4  beq cr6, 0x82505360
	if ctx.cr[6].eq {
	pc = 0x82505360; continue 'dispatch;
	}
	// 82505390: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82505394: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82505398: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250539C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825053A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825053A4: 4E800421  bctrl
	ctx.lr = 0x825053A8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x825053A8 => {
    //   block [0x825053A8..0x825053C0)
	// 825053A8: 38210280  addi r1, r1, 0x280
	ctx.r[1].s64 = ctx.r[1].s64 + 640;
	// 825053AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825053B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825053B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825053B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825053BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825053C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825053C0 size=296
    let mut pc: u32 = 0x825053C0;
    'dispatch: loop {
        match pc {
            0x825053C0 => {
    //   block [0x825053C0..0x825053F4)
	// 825053C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825053C4: 4802FCE9  bl 0x825350ac
	ctx.lr = 0x825053C8;
	sub_82535080(ctx, base);
	// 825053C8: 9421FD60  stwu r1, -0x2a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-672 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825053CC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825053D0: 3B20FFFF  li r25, -1
	ctx.r[25].s64 = -1;
	// 825053D4: 548A007E  clrlwi r10, r4, 1
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x7FFFFFFFu64;
	// 825053D8: 549B0000  rlwinm r27, r4, 0, 0, 0
	ctx.r[27].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	// 825053DC: 3F408282  lis r26, -0x7d7e
	ctx.r[26].s64 = -2105409536;
	// 825053E0: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825053E4: 212B0020  subfic r9, r11, 0x20
	ctx.xer.ca = ctx.r[11].u32 <= 32 as u32;
	ctx.r[9].s64 = (32 as i64) - ctx.r[11].s64;
	// 825053E8: 7F2B5C30  srw r11, r25, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[25].u32) >> ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 825053EC: 7D7F2038  and r31, r11, r4
	ctx.r[31].u64 = ctx.r[11].u64 & ctx.r[4].u64;
	// 825053F0: 7D5E4C30  srw r30, r10, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[30].u64 = 0;
	} else {
		ctx.r[30].u64 = ((ctx.r[10].u32) >> ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	pc = 0x825053F4; continue 'dispatch;
            }
            0x825053F4 => {
    //   block [0x825053F4..0x82505448)
	// 825053F4: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 825053F8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825053FC: 57CB3032  slwi r11, r30, 6
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82505400: 409A0048  bne cr6, 0x82505448
	if !ctx.cr[6].eq {
	pc = 0x82505448; continue 'dispatch;
	}
	// 82505404: 815D0040  lwz r10, 0x40(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(64 as u32) ) } as u64;
	// 82505408: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8250540C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82505410: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82505414: 4198005C  blt cr6, 0x82505470
	if ctx.cr[6].lt {
	pc = 0x82505470; continue 'dispatch;
	}
	// 82505418: 817D0044  lwz r11, 0x44(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(68 as u32) ) } as u64;
	// 8250541C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82505420: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82505424: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82505428: 41980048  blt cr6, 0x82505470
	if ctx.cr[6].lt {
	pc = 0x82505470; continue 'dispatch;
	}
	// 8250542C: 817D004C  lwz r11, 0x4c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 82505430: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82505434: 419A00A8  beq cr6, 0x825054dc
	if ctx.cr[6].eq {
	pc = 0x825054DC; continue 'dispatch;
	}
	// 82505438: 3F608000  lis r27, -0x8000
	ctx.r[27].s64 = -2147483648;
	// 8250543C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82505440: 3BE0FFFF  li r31, -1
	ctx.r[31].s64 = -1;
	// 82505444: 4BFFFFB0  b 0x825053f4
	pc = 0x825053F4; continue 'dispatch;
            }
            0x82505448 => {
    //   block [0x82505448..0x82505470)
	// 82505448: 815D0048  lwz r10, 0x48(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 8250544C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82505450: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82505454: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82505458: 41980018  blt cr6, 0x82505470
	if ctx.cr[6].lt {
	pc = 0x82505470; continue 'dispatch;
	}
	// 8250545C: 817D004C  lwz r11, 0x4c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 82505460: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82505464: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82505468: 40980074  bge cr6, 0x825054dc
	if !ctx.cr[6].lt {
	pc = 0x825054DC; continue 'dispatch;
	}
	// 8250546C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82505470; continue 'dispatch;
            }
            0x82505470 => {
    //   block [0x82505470..0x825054D0)
	// 82505470: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82505474: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82505478: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250547C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82505480: 216B0020  subfic r11, r11, 0x20
	ctx.xer.ca = ctx.r[11].u32 <= 32 as u32;
	ctx.r[11].s64 = (32 as i64) - ctx.r[11].s64;
	// 82505484: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82505488: 7FCB5830  slw r11, r30, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[30].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 8250548C: 7D6BDB78  or r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[27].u64;
	// 82505490: 7D7CFB78  or r28, r11, r31
	ctx.r[28].u64 = ctx.r[11].u64 | ctx.r[31].u64;
	// 82505494: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82505498: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8250549C: 4E800421  bctrl
	ctx.lr = 0x825054A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825054A0: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 825054A4: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 825054A8: 409A0028  bne cr6, 0x825054d0
	if !ctx.cr[6].eq {
	pc = 0x825054D0; continue 'dispatch;
	}
	// 825054AC: 38C30040  addi r6, r3, 0x40
	ctx.r[6].s64 = ctx.r[3].s64 + 64;
	// 825054B0: C03AE098  lfs f1, -0x1f68(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-8040 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825054B4: 38A30030  addi r5, r3, 0x30
	ctx.r[5].s64 = ctx.r[3].s64 + 48;
	// 825054B8: 38830020  addi r4, r3, 0x20
	ctx.r[4].s64 = ctx.r[3].s64 + 32;
	// 825054BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825054C0: 48024C81  bl 0x8252a140
	ctx.lr = 0x825054C4;
	sub_8252A140(ctx, base);
	// 825054C4: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825054C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825054CC: 409AFF28  bne cr6, 0x825053f4
	if !ctx.cr[6].eq {
	pc = 0x825053F4; continue 'dispatch;
	}
            }
            0x825054D0 => {
    //   block [0x825054D0..0x825054DC)
	// 825054D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825054D4: 382102A0  addi r1, r1, 0x2a0
	ctx.r[1].s64 = ctx.r[1].s64 + 672;
	// 825054D8: 4802FC24  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            0x825054DC => {
    //   block [0x825054DC..0x825054E8)
	// 825054DC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825054E0: 382102A0  addi r1, r1, 0x2a0
	ctx.r[1].s64 = ctx.r[1].s64 + 672;
	// 825054E4: 4802FC18  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825054E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825054E8 size=960
    let mut pc: u32 = 0x825054E8;
    'dispatch: loop {
        match pc {
            0x825054E8 => {
    //   block [0x825054E8..0x82505544)
	// 825054E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825054EC: 4802FBC5  bl 0x825350b0
	ctx.lr = 0x825054F0;
	sub_82535080(ctx, base);
	// 825054F0: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825054F4: 38C3FFF0  addi r6, r3, -0x10
	ctx.r[6].s64 = ctx.r[3].s64 + -16;
	// 825054F8: 548B0000  rlwinm r11, r4, 0, 0, 0
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	// 825054FC: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82505500: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82505504: 5489007E  clrlwi r9, r4, 1
	ctx.r[9].u64 = ctx.r[4].u32 as u64 & 0x7FFFFFFFu64;
	// 82505508: 81660018  lwz r11, 0x18(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250550C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82505510: 210B0020  subfic r8, r11, 0x20
	ctx.xer.ca = ctx.r[11].u32 <= 32 as u32;
	ctx.r[8].s64 = (32 as i64) - ctx.r[11].s64;
	// 82505514: 7D4B5C30  srw r11, r10, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[10].u32) >> ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 82505518: 7D7B2038  and r27, r11, r4
	ctx.r[27].u64 = ctx.r[11].u64 & ctx.r[4].u64;
	// 8250551C: 7D2B4430  srw r11, r9, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[9].u32) >> ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 82505520: 409A0230  bne cr6, 0x82505750
	if !ctx.cr[6].eq {
	pc = 0x82505750; continue 'dispatch;
	}
	// 82505524: 81460054  lwz r10, 0x54(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(84 as u32) ) } as u64;
	// 82505528: 3921009F  addi r9, r1, 0x9f
	ctx.r[9].s64 = ctx.r[1].s64 + 159;
	// 8250552C: 3B800004  li r28, 4
	ctx.r[28].s64 = 4;
	// 82505530: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 82505534: 55270032  rlwinm r7, r9, 0, 0, 0x19
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82505538: 409A000C  bne cr6, 0x82505544
	if !ctx.cr[6].eq {
	pc = 0x82505544; continue 'dispatch;
	}
	// 8250553C: 38E60070  addi r7, r6, 0x70
	ctx.r[7].s64 = ctx.r[6].s64 + 112;
	// 82505540: 4800005C  b 0x8250559c
	pc = 0x8250559C; continue 'dispatch;
            }
            0x82505544 => {
    //   block [0x82505544..0x82505568)
	// 82505544: 81460050  lwz r10, 0x50(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(80 as u32) ) } as u64;
	// 82505548: 55683032  slwi r8, r11, 6
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8250554C: 55653032  slwi r5, r11, 6
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82505550: 7D685214  add r11, r8, r10
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82505554: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 82505558: 7D055850  subf r8, r5, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[5].s64;
	// 8250555C: 7D4A4050  subf r10, r10, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 82505560: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 82505564: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	pc = 0x82505568; continue 'dispatch;
            }
            0x82505568 => {
    //   block [0x82505568..0x8250559C)
	// 82505568: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250556C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82505570: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82505574: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82505578: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8250557C: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82505580: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82505584: 910AFFF8  stw r8, -8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8 as u32), ctx.r[8].u32 ) };
	// 82505588: 90AAFFFC  stw r5, -4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), ctx.r[5].u32 ) };
	// 8250558C: 908A0000  stw r4, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82505590: 906A0004  stw r3, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82505594: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 82505598: 4199FFD0  bgt cr6, 0x82505568
	if ctx.cr[6].gt {
	pc = 0x82505568; continue 'dispatch;
	}
	pc = 0x8250559C; continue 'dispatch;
            }
            0x8250559C => {
    //   block [0x8250559C..0x825055F0)
	// 8250559C: 89670039  lbz r11, 0x39(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(57 as u32) ) } as u64;
	// 825055A0: 81470034  lwz r10, 0x34(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(52 as u32) ) } as u64;
	// 825055A4: 7D680774  extsb r8, r11
	ctx.r[8].s64 = ctx.r[11].s8 as i64;
	// 825055A8: 81270030  lwz r9, 0x30(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) } as u64;
	// 825055AC: 7D6AD9D6  mullw r11, r10, r27
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * ctx.r[27].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825055B0: 88A70038  lbz r5, 0x38(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(56 as u32) ) } as u64;
	// 825055B4: 7D0AD838  and r10, r8, r27
	ctx.r[10].u64 = ctx.r[8].u64 & ctx.r[27].u64;
	// 825055B8: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825055BC: 69490001  xori r9, r10, 1
	ctx.r[9].u64 = ctx.r[10].u64 ^ 1;
	// 825055C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825055C4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825055C8: 2B050001  cmplwi cr6, r5, 1
	ctx.cr[6].compare_u32(ctx.r[5].u32, 1 as u32, &mut ctx.xer);
	// 825055CC: 7D4A0734  extsh r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	// 825055D0: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 825055D4: 409A001C  bne cr6, 0x825055f0
	if !ctx.cr[6].eq {
	pc = 0x825055F0; continue 'dispatch;
	}
	// 825055D8: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825055DC: A08B0000  lhz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825055E0: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825055E4: 7FCA5A2E  lhzx r30, r10, r11
	ctx.r[30].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825055E8: 7FA95A2E  lhzx r29, r9, r11
	ctx.r[29].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825055EC: 48000018  b 0x82505604
	pc = 0x82505604; continue 'dispatch;
            }
            0x825055F0 => {
    //   block [0x825055F0..0x82505604)
	// 825055F0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825055F4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825055F8: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825055FC: 7FCA582E  lwzx r30, r10, r11
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82505600: 7FA9582E  lwzx r29, r9, r11
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	pc = 0x82505604; continue 'dispatch;
            }
            0x82505604 => {
    //   block [0x82505604..0x82505668)
	// 82505604: 81070014  lwz r8, 0x14(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82505608: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8250560C: 81270018  lwz r9, 0x18(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) } as u64;
	// 82505610: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82505614: 419A0054  beq cr6, 0x82505668
	if ctx.cr[6].eq {
	pc = 0x82505668; continue 'dispatch;
	}
	// 82505618: 3D608282  lis r11, -0x7d7e
	ctx.r[11].s64 = -2105409536;
	// 8250561C: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 82505620: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82505624: 394A3134  addi r10, r10, 0x3134
	ctx.r[10].s64 = ctx.r[10].s64 + 12596;
	// 82505628: 3B400006  li r26, 6
	ctx.r[26].s64 = 6;
	// 8250562C: C00BD284  lfs f0, -0x2d7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82505630: 397F0050  addi r11, r31, 0x50
	ctx.r[11].s64 = ctx.r[31].s64 + 80;
	// 82505634: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82505638: 90BF0008  stw r5, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 8250563C: B07F0006  sth r3, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[3].u16 ) };
	// 82505640: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82505644: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82505648: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8250564C: B0BF0014  sth r5, 0x14(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[5].u16 ) };
	// 82505650: 9B5F0016  stb r26, 0x16(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(22 as u32), ctx.r[26].u8 ) };
	pc = 0x82505668; continue 'dispatch;
            }
            0x82505668 => {
    //   block [0x82505668..0x82505750)
	// 82505668: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 8250566C: 39670020  addi r11, r7, 0x20
	ctx.r[11].s64 = ctx.r[7].s64 + 32;
	// 82505670: 8946006C  lbz r10, 0x6c(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(108 as u32) ) } as u64;
	// 82505674: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 82505678: C00600B0  lfs f0, 0xb0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8250567C: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82505680: 9383000C  stw r28, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	pc = 0x82505750; continue 'dispatch;
            }
            0x82505750 => {
    //   block [0x82505750..0x825058A8)
	// 82505750: 81460058  lwz r10, 0x58(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(88 as u32) ) } as u64;
	// 82505754: 55673032  slwi r7, r11, 6
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82505758: 55663032  slwi r6, r11, 6
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 8250575C: 7D675214  add r11, r7, r10
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 82505760: 3921011F  addi r9, r1, 0x11f
	ctx.r[9].s64 = ctx.r[1].s64 + 287;
	// 82505764: 7CE65850  subf r7, r6, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	// 82505768: 55290032  rlwinm r9, r9, 0, 0, 0x19
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 8250576C: 7D4A3850  subf r10, r10, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[10].s64;
	// 82505770: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 82505774: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82505778: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8250577C: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82505780: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 82505784: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82505788: 90EAFFF8  stw r7, -8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8 as u32), ctx.r[7].u32 ) };
	// 8250578C: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82505790: 90EAFFFC  stw r7, -4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), ctx.r[7].u32 ) };
	// 82505794: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82505798: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 8250579C: 80EB000C  lwz r7, 0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825057A0: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 825057A4: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 825057A8: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 825057AC: 4199FFD0  bgt cr6, 0x8250577c
	if ctx.cr[6].gt {
	pc = 0x8250577C; continue 'dispatch;
	}
	// 825057B0: 89690018  lbz r11, 0x18(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 825057B4: 5768103A  slwi r8, r27, 2
	ctx.r[8].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825057B8: 81490010  lwz r10, 0x10(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 825057BC: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 825057C0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825057C4: 7FCA402E  lwzx r30, r10, r8
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 825057C8: 409A001C  bne cr6, 0x825057e4
	if !ctx.cr[6].eq {
	pc = 0x825057E4; continue 'dispatch;
	}
	// 825057CC: 89490019  lbz r10, 0x19(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(25 as u32) ) } as u64;
	// 825057D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825057D4: 409A0010  bne cr6, 0x825057e4
	if !ctx.cr[6].eq {
	pc = 0x825057E4; continue 'dispatch;
	}
	// 825057D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825057DC: 382101A0  addi r1, r1, 0x1a0
	ctx.r[1].s64 = ctx.r[1].s64 + 416;
	// 825057E0: 4802F920  b 0x82535100
	sub_825350D0(ctx, base);
	return;
	// 825057E4: 89490019  lbz r10, 0x19(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(25 as u32) ) } as u64;
	// 825057E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825057EC: 409A002C  bne cr6, 0x82505818
	if !ctx.cr[6].eq {
	pc = 0x82505818; continue 'dispatch;
	}
	// 825057F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825057F4: 419A0024  beq cr6, 0x82505818
	if ctx.cr[6].eq {
	pc = 0x82505818; continue 'dispatch;
	}
	// 825057F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825057FC: 419A0060  beq cr6, 0x8250585c
	if ctx.cr[6].eq {
	pc = 0x8250585C; continue 'dispatch;
	}
	// 82505800: 38A90030  addi r5, r9, 0x30
	ctx.r[5].s64 = ctx.r[9].s64 + 48;
	// 82505804: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82505808: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250580C: 48007C85  bl 0x8250d490
	ctx.lr = 0x82505810;
	sub_8250D490(ctx, base);
	// 82505810: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82505814: 4800004C  b 0x82505860
	pc = 0x82505860; continue 'dispatch;
	// 82505818: 39490030  addi r10, r9, 0x30
	ctx.r[10].s64 = ctx.r[9].s64 + 48;
	// 8250581C: 38890020  addi r4, r9, 0x20
	ctx.r[4].s64 = ctx.r[9].s64 + 32;
	// 82505820: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 82505824: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82505828: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 8250582C: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 82505830: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82505834: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82505838: 480A5DC9  bl 0x825ab600
	ctx.lr = 0x8250583C;
	sub_825AB600(ctx, base);
	// 8250583C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82505840: 419A001C  beq cr6, 0x8250585c
	if ctx.cr[6].eq {
	pc = 0x8250585C; continue 'dispatch;
	}
	// 82505844: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82505848: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8250584C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82505850: 4800A629  bl 0x8250fe78
	ctx.lr = 0x82505854;
	sub_8250FE78(ctx, base);
	// 82505854: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82505858: 48000008  b 0x82505860
	pc = 0x82505860; continue 'dispatch;
	// 8250585C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82505860: A17E0004  lhz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82505864: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82505868: 419A0034  beq cr6, 0x8250589c
	if ctx.cr[6].eq {
	pc = 0x8250589C; continue 'dispatch;
	}
	// 8250586C: A17E0006  lhz r11, 6(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 82505870: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82505874: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 82505878: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8250587C: B17E0006  sth r11, 6(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 82505880: 409A001C  bne cr6, 0x8250589c
	if !ctx.cr[6].eq {
	pc = 0x8250589C; continue 'dispatch;
	}
	// 82505884: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82505888: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8250588C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82505890: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82505894: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82505898: 4E800421  bctrl
	ctx.lr = 0x8250589C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250589C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825058A0: 382101A0  addi r1, r1, 0x1a0
	ctx.r[1].s64 = ctx.r[1].s64 + 416;
	// 825058A4: 4802F85C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825058A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825058A8 size=24
    let mut pc: u32 = 0x825058A8;
    'dispatch: loop {
        match pc {
            0x825058A8 => {
    //   block [0x825058A8..0x825058C0)
	// 825058A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825058AC: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825058B0: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 825058B4: 38AB0040  addi r5, r11, 0x40
	ctx.r[5].s64 = ctx.r[11].s64 + 64;
	// 825058B8: 388B0030  addi r4, r11, 0x30
	ctx.r[4].s64 = ctx.r[11].s64 + 48;
	// 825058BC: 4BFF7094  b 0x824fc950
	sub_824FC950(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825058C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825058C0 size=188
    let mut pc: u32 = 0x825058C0;
    'dispatch: loop {
        match pc {
            0x825058C0 => {
    //   block [0x825058C0..0x825058F4)
	// 825058C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825058C4: 4802F7F5  bl 0x825350b8
	ctx.lr = 0x825058C8;
	sub_82535080(ctx, base);
	// 825058C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825058CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825058D0: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 825058D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825058D8: 409A001C  bne cr6, 0x825058f4
	if !ctx.cr[6].eq {
	pc = 0x825058F4; continue 'dispatch;
	}
	// 825058DC: 387F0070  addi r3, r31, 0x70
	ctx.r[3].s64 = ctx.r[31].s64 + 112;
	// 825058E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825058E4: 907F0050  stw r3, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 825058E8: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825058EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825058F0: 4802F818  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x825058F4 => {
    //   block [0x825058F4..0x82505958)
	// 825058F4: 838D0000  lwz r28, 0(r13)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825058F8: 3BA00010  li r29, 0x10
	ctx.r[29].s64 = 16;
	// 825058FC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82505900: 38C00025  li r6, 0x25
	ctx.r[6].s64 = 37;
	// 82505904: 55653032  slwi r5, r11, 6
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82505908: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 8250590C: 7C7DE02E  lwzx r3, r29, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82505910: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82505914: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82505918: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250591C: 4E800421  bctrl
	ctx.lr = 0x82505920;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82505920: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82505924: 809F0050  lwz r4, 0x50(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82505928: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8250592C: 55653032  slwi r5, r11, 6
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82505930: 4BF649F9  bl 0x8246a328
	ctx.lr = 0x82505934;
	sub_8246A328(ctx, base);
	// 82505934: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82505938: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8250593C: 4099001C  ble cr6, 0x82505958
	if !ctx.cr[6].gt {
	pc = 0x82505958; continue 'dispatch;
	}
	// 82505940: 7C7DE02E  lwzx r3, r29, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82505944: 809F0050  lwz r4, 0x50(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82505948: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250594C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82505950: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82505954: 4E800421  bctrl
	ctx.lr = 0x82505958;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82505958 => {
    //   block [0x82505958..0x8250597C)
	// 82505958: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 8250595C: 93DF0050  stw r30, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82505960: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82505964: 556A3032  slwi r10, r11, 6
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82505968: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 8250596C: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82505970: 386AFFC0  addi r3, r10, -0x40
	ctx.r[3].s64 = ctx.r[10].s64 + -64;
	// 82505974: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82505978: 4802F790  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82505980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82505980 size=144
    let mut pc: u32 = 0x82505980;
    'dispatch: loop {
        match pc {
            0x82505980 => {
    //   block [0x82505980..0x82505A10)
	// 82505980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82505984: 4802F735  bl 0x825350b8
	ctx.lr = 0x82505988;
	sub_82535080(ctx, base);
	// 82505988: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250598C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82505990: 838D0000  lwz r28, 0(r13)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82505994: 3BA00010  li r29, 0x10
	ctx.r[29].s64 = 16;
	// 82505998: 38C00025  li r6, 0x25
	ctx.r[6].s64 = 37;
	// 8250599C: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 825059A0: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 825059A4: 7C7DE02E  lwzx r3, r29, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 825059A8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825059AC: 55653032  slwi r5, r11, 6
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 825059B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825059B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825059B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825059BC: 4E800421  bctrl
	ctx.lr = 0x825059C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825059C0: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 825059C4: 809F0058  lwz r4, 0x58(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 825059C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825059CC: 55653032  slwi r5, r11, 6
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 825059D0: 4BF64959  bl 0x8246a328
	ctx.lr = 0x825059D4;
	sub_8246A328(ctx, base);
	// 825059D4: 7C7DE02E  lwzx r3, r29, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 825059D8: 809F0058  lwz r4, 0x58(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 825059DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825059E0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825059E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825059E8: 4E800421  bctrl
	ctx.lr = 0x825059EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825059EC: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 825059F0: 93DF0058  stw r30, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 825059F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825059F8: 556A3032  slwi r10, r11, 6
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825059FC: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82505A00: 917F005C  stw r11, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82505A04: 386AFFC0  addi r3, r10, -0x40
	ctx.r[3].s64 = ctx.r[10].s64 + -64;
	// 82505A08: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82505A0C: 4802F6FC  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82505A10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82505A10 size=344
    let mut pc: u32 = 0x82505A10;
    'dispatch: loop {
        match pc {
            0x82505A10 => {
    //   block [0x82505A10..0x82505B68)
	// 82505A10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82505A14: 4802F6A5  bl 0x825350b8
	ctx.lr = 0x82505A18;
	sub_82535080(ctx, base);
	// 82505A18: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82505B68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82505B68 size=444
    let mut pc: u32 = 0x82505B68;
    'dispatch: loop {
        match pc {
            0x82505B68 => {
    //   block [0x82505B68..0x82505D24)
	// 82505B68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82505B6C: 4802F551  bl 0x825350bc
	ctx.lr = 0x82505B70;
	sub_82535080(ctx, base);
	// 82505B70: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82505D28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82505D28 size=8
    let mut pc: u32 = 0x82505D28;
    'dispatch: loop {
        match pc {
            0x82505D28 => {
    //   block [0x82505D28..0x82505D30)
	// 82505D28: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82505D2C: 48000004  b 0x82505d30
	sub_82505D30(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82505D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82505D30 size=100
    let mut pc: u32 = 0x82505D30;
    'dispatch: loop {
        match pc {
            0x82505D30 => {
    //   block [0x82505D30..0x82505D78)
	// 82505D30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82505D34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82505D38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82505D3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82505D40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82505D44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82505D48: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82505D4C: 4BFFF125  bl 0x82504e70
	ctx.lr = 0x82505D50;
	sub_82504E70(ctx, base);
	// 82505D50: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82505D54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82505D58: 419A0020  beq cr6, 0x82505d78
	if ctx.cr[6].eq {
	pc = 0x82505D78; continue 'dispatch;
	}
	// 82505D5C: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82505D60: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82505D64: 38C00027  li r6, 0x27
	ctx.r[6].s64 = 39;
	// 82505D68: A0BF0004  lhz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82505D6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82505D70: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82505D74: 4BF5E345  bl 0x824640b8
	ctx.lr = 0x82505D78;
	sub_824640B8(ctx, base);
	pc = 0x82505D78; continue 'dispatch;
            }
            0x82505D78 => {
    //   block [0x82505D78..0x82505D94)
	// 82505D78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82505D7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82505D80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82505D84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82505D88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82505D8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82505D90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82505D98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82505D98 size=180
    let mut pc: u32 = 0x82505D98;
    'dispatch: loop {
        match pc {
            0x82505D98 => {
    //   block [0x82505D98..0x82505E4C)
	// 82505D98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82505D9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82505DA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82505DA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82505DA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82505DAC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82505DB0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82505DB4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82505DB8: 388B4774  addi r4, r11, 0x4774
	ctx.r[4].s64 = ctx.r[11].s64 + 18292;
	// 82505DBC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82505DC0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82505DC4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82505DC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82505DCC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82505DD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82505DD4: 4E800421  bctrl
	ctx.lr = 0x82505DD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82505DD8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82505DDC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82505DE0: 80DE0034  lwz r6, 0x34(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 82505DE4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82505DE8: 388B476C  addi r4, r11, 0x476c
	ctx.r[4].s64 = ctx.r[11].s64 + 18284;
	// 82505DEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82505DF0: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82505DF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82505DF8: 4E800421  bctrl
	ctx.lr = 0x82505DFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82505DFC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82505E00: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82505E04: 80DE0010  lwz r6, 0x10(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82505E08: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82505E0C: 388B4764  addi r4, r11, 0x4764
	ctx.r[4].s64 = ctx.r[11].s64 + 18276;
	// 82505E10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82505E14: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82505E18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82505E1C: 4E800421  bctrl
	ctx.lr = 0x82505E20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82505E20: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82505E24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82505E28: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82505E2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82505E30: 4E800421  bctrl
	ctx.lr = 0x82505E34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82505E34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82505E38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82505E3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82505E40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82505E44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82505E48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82505E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82505E50 size=56
    let mut pc: u32 = 0x82505E50;
    'dispatch: loop {
        match pc {
            0x82505E50 => {
    //   block [0x82505E50..0x82505E88)
	// 82505E50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82505E54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82505E58: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82505E5C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82505E60: 80830010  lwz r4, 0x10(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82505E64: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82505E68: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 82505E6C: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 82505E70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82505E74: 480B1ABD  bl 0x825b7930
	ctx.lr = 0x82505E78;
	sub_825B7930(ctx, base);
	// 82505E78: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82505E7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82505E80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82505E84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82505E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82505E88 size=132
    let mut pc: u32 = 0x82505E88;
    'dispatch: loop {
        match pc {
            0x82505E88 => {
    //   block [0x82505E88..0x82505F0C)
	// 82505E88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82505E8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82505E90: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82505E94: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82505E98: 80830010  lwz r4, 0x10(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82505E9C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82505EA0: 39430020  addi r10, r3, 0x20
	ctx.r[10].s64 = ctx.r[3].s64 + 32;
	// 82505EA4: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82505EA8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82505F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82505F10 size=68
    let mut pc: u32 = 0x82505F10;
    'dispatch: loop {
        match pc {
            0x82505F10 => {
    //   block [0x82505F10..0x82505F54)
	// 82505F10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82505F14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82505F18: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82505F1C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82505F20: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82505F24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82505F28: 396B2D50  addi r11, r11, 0x2d50
	ctx.r[11].s64 = ctx.r[11].s64 + 11600;
	// 82505F2C: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 82505F30: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82505F34: 4BFF37BD  bl 0x824f96f0
	ctx.lr = 0x82505F38;
	sub_824F96F0(ctx, base);
	// 82505F38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82505F3C: 4BFF3B75  bl 0x824f9ab0
	ctx.lr = 0x82505F40;
	sub_824F9AB0(ctx, base);
	// 82505F40: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82505F44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82505F48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82505F4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82505F50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82505F58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82505F58 size=20
    let mut pc: u32 = 0x82505F58;
    'dispatch: loop {
        match pc {
            0x82505F58 => {
    //   block [0x82505F58..0x82505F6C)
	// 82505F58: 80630034  lwz r3, 0x34(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 82505F5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82505F60: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82505F64: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82505F68: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82505F70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82505F70 size=160
    let mut pc: u32 = 0x82505F70;
    'dispatch: loop {
        match pc {
            0x82505F70 => {
    //   block [0x82505F70..0x82505F98)
	// 82505F70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82505F74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82505F78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82505F7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82505F80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82505F84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82505F88: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82505F8C: 896B002C  lbz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82505F90: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82505F94: 409A000C  bne cr6, 0x82505fa0
	if !ctx.cr[6].eq {
	pc = 0x82505FA0; continue 'dispatch;
	}
	pc = 0x82505F98; continue 'dispatch;
            }
            0x82505F98 => {
    //   block [0x82505F98..0x82505FA0)
	// 82505F98: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82505F9C: 4800005C  b 0x82505ff8
	pc = 0x82505FF8; continue 'dispatch;
            }
            0x82505FA0 => {
    //   block [0x82505FA0..0x82505FF0)
	// 82505FA0: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82505FA4: 3BC5FFC0  addi r30, r5, -0x40
	ctx.r[30].s64 = ctx.r[5].s64 + -64;
	// 82505FA8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82505FAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82505FB0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82505FB4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82505FB8: 4E800421  bctrl
	ctx.lr = 0x82505FBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82505FBC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82505FC0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82505FC4: 4198FFD4  blt cr6, 0x82505f98
	if ctx.cr[6].lt {
	pc = 0x82505F98; continue 'dispatch;
	}
	// 82505FC8: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 82505FCC: 4199FFCC  bgt cr6, 0x82505f98
	if ctx.cr[6].gt {
	pc = 0x82505F98; continue 'dispatch;
	}
	// 82505FD0: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82505FD4: 393F0040  addi r9, r31, 0x40
	ctx.r[9].s64 = ctx.r[31].s64 + 64;
	// 82505FD8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82505FDC: 409A0014  bne cr6, 0x82505ff0
	if !ctx.cr[6].eq {
	pc = 0x82505FF0; continue 'dispatch;
	}
	// 82505FE0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82505FE4: 386B0040  addi r3, r11, 0x40
	ctx.r[3].s64 = ctx.r[11].s64 + 64;
	// 82505FE8: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 82505FEC: 4800000C  b 0x82505ff8
	pc = 0x82505FF8; continue 'dispatch;
            }
            0x82505FF0 => {
    //   block [0x82505FF0..0x82505FF8)
	// 82505FF0: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 82505FF4: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	pc = 0x82505FF8; continue 'dispatch;
            }
            0x82505FF8 => {
    //   block [0x82505FF8..0x82506010)
	// 82505FF8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82505FFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82506000: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82506004: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82506008: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8250600C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82506010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82506010 size=96
    let mut pc: u32 = 0x82506010;
    'dispatch: loop {
        match pc {
            0x82506010 => {
    //   block [0x82506010..0x8250604C)
	// 82506010: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82506014: 9083000C  stw r4, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 82506018: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8250601C: 90A30010  stw r5, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[5].u32 ) };
	// 82506020: 396B2D1C  addi r11, r11, 0x2d1c
	ctx.r[11].s64 = ctx.r[11].s64 + 11548;
	// 82506024: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82506028: B1430006  sth r10, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 8250602C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82506030: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82506034: A1650004  lhz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82506038: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8250603C: 419A0010  beq cr6, 0x8250604c
	if ctx.cr[6].eq {
	pc = 0x8250604C; continue 'dispatch;
	}
	// 82506040: A1650006  lhz r11, 6(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(6 as u32) ) } as u64;
	// 82506044: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82506048: B1650006  sth r11, 6(r5)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[5].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	pc = 0x8250604C; continue 'dispatch;
            }
            0x8250604C => {
    //   block [0x8250604C..0x82506070)
	// 8250604C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82506050: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82506070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82506070 size=152
    let mut pc: u32 = 0x82506070;
    'dispatch: loop {
        match pc {
            0x82506070 => {
    //   block [0x82506070..0x825060B0)
	// 82506070: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82506074: 90A30010  stw r5, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[5].u32 ) };
	// 82506078: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8250607C: 396B2D1C  addi r11, r11, 0x2d1c
	ctx.r[11].s64 = ctx.r[11].s64 + 11548;
	// 82506080: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82506084: 3900000B  li r8, 0xb
	ctx.r[8].s64 = 11;
	// 82506088: B1430006  sth r10, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 8250608C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82506090: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82506094: 9103000C  stw r8, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82506098: A1650004  lhz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250609C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825060A0: 419A0010  beq cr6, 0x825060b0
	if ctx.cr[6].eq {
	pc = 0x825060B0; continue 'dispatch;
	}
	// 825060A4: A1650006  lhz r11, 6(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(6 as u32) ) } as u64;
	// 825060A8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825060AC: B1650006  sth r11, 6(r5)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[5].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	pc = 0x825060B0; continue 'dispatch;
            }
            0x825060B0 => {
    //   block [0x825060B0..0x82506108)
	// 825060B0: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825060B4: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 825060B8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825060BC: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 825060C0: 396B2D50  addi r11, r11, 0x2d50
	ctx.r[11].s64 = ctx.r[11].s64 + 11600;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82506108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82506108 size=284
    let mut pc: u32 = 0x82506108;
    'dispatch: loop {
        match pc {
            0x82506108 => {
    //   block [0x82506108..0x82506158)
	// 82506108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250610C: 4802EFA9  bl 0x825350b4
	ctx.lr = 0x82506110;
	sub_82535080(ctx, base);
	// 82506110: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82506114: 836D0000  lwz r27, 0(r13)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82506118: 3B800014  li r28, 0x14
	ctx.r[28].s64 = 20;
	// 8250611C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82506120: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 82506124: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82506128: 7D7CD82E  lwzx r11, r28, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 8250612C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82506130: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82506134: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82506138: 40980020  bge cr6, 0x82506158
	if !ctx.cr[6].lt {
	pc = 0x82506158; continue 'dispatch;
	}
	// 8250613C: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 82506140: 39294780  addi r9, r9, 0x4780
	ctx.r[9].s64 = ctx.r[9].s64 + 18304;
	// 82506144: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82506148: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 8250614C: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 82506150: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82506154: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x82506158; continue 'dispatch;
            }
            0x82506158 => {
    //   block [0x82506158..0x82506224)
	// 82506158: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 8250615C: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 82506160: 394100CF  addi r10, r1, 0xcf
	ctx.r[10].s64 = ctx.r[1].s64 + 207;
	// 82506164: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82506168: 55460036  rlwinm r6, r10, 0, 0, 0x1b
	ctx.r[6].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8250616C: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82506170: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82506174: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82506228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82506228 size=228
    let mut pc: u32 = 0x82506228;
    'dispatch: loop {
        match pc {
            0x82506228 => {
    //   block [0x82506228..0x82506278)
	// 82506228: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250622C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82506230: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82506234: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82506238: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250623C: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82506240: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 82506244: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 82506248: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8250624C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82506250: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82506254: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82506258: 40980020  bge cr6, 0x82506278
	if !ctx.cr[6].lt {
	pc = 0x82506278; continue 'dispatch;
	}
	// 8250625C: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 82506260: 39294780  addi r9, r9, 0x4780
	ctx.r[9].s64 = ctx.r[9].s64 + 18304;
	// 82506264: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82506268: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 8250626C: 38EA000C  addi r7, r10, 0xc
	ctx.r[7].s64 = ctx.r[10].s64 + 12;
	// 82506270: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82506274: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	pc = 0x82506278; continue 'dispatch;
            }
            0x82506278 => {
    //   block [0x82506278..0x825062AC)
	// 82506278: 81630034  lwz r11, 0x34(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 8250627C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82506280: 81250008  lwz r9, 8(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 82506284: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82506288: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 8250628C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82506290: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82506294: 914100A0  stw r10, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 82506298: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 8250629C: 914100A4  stw r10, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[10].u32 ) };
	// 825062A0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825062A4: 409A0008  bne cr6, 0x825062ac
	if !ctx.cr[6].eq {
	pc = 0x825062AC; continue 'dispatch;
	}
	// 825062A8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x825062AC; continue 'dispatch;
            }
            0x825062AC => {
    //   block [0x825062AC..0x825062F4)
	// 825062AC: 80A30010  lwz r5, 0x10(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 825062B0: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 825062B4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825062B8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 825062BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825062C0: 480B2C71  bl 0x825b8f30
	ctx.lr = 0x825062C4;
	sub_825B8F30(ctx, base);
	// 825062C4: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825062C8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825062CC: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825062D0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825062D4: 40980020  bge cr6, 0x825062f4
	if !ctx.cr[6].lt {
	pc = 0x825062F4; continue 'dispatch;
	}
	// 825062D8: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 825062DC: 392974DC  addi r9, r9, 0x74dc
	ctx.r[9].s64 = ctx.r[9].s64 + 29916;
	// 825062E0: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825062E4: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 825062E8: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 825062EC: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825062F0: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x825062F4; continue 'dispatch;
            }
            0x825062F4 => {
    //   block [0x825062F4..0x8250630C)
	// 825062F4: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 825062F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825062FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82506300: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82506304: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82506308: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82506310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82506310 size=260
    let mut pc: u32 = 0x82506310;
    'dispatch: loop {
        match pc {
            0x82506310 => {
    //   block [0x82506310..0x82506414)
	// 82506310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82506314: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82506318: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8250631C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82506320: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82506324: 7CA82B78  mr r8, r5
	ctx.r[8].u64 = ctx.r[5].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82506448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82506448 size=92
    let mut pc: u32 = 0x82506448;
    'dispatch: loop {
        match pc {
            0x82506448 => {
    //   block [0x82506448..0x825064A4)
	// 82506448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250644C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82506450: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82506454: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82506458: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8250645C: 4800899D  bl 0x8250edf8
	ctx.lr = 0x82506460;
	sub_8250EDF8(ctx, base);
	// 82506460: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82506464: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 82506468: 396B47B4  addi r11, r11, 0x47b4
	ctx.r[11].s64 = ctx.r[11].s64 + 18356;
	// 8250646C: 394A4790  addi r10, r10, 0x4790
	ctx.r[10].s64 = ctx.r[10].s64 + 18320;
	// 82506470: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82506474: 3D008000  lis r8, -0x8000
	ctx.r[8].s64 = -2147483648;
	// 82506478: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250647C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82506480: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82506484: 913F0060  stw r9, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 82506488: 913F0064  stw r9, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 8250648C: 911F0068  stw r8, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[8].u32 ) };
	// 82506490: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82506494: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82506498: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8250649C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825064A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825064A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825064A8 size=204
    let mut pc: u32 = 0x825064A8;
    'dispatch: loop {
        match pc {
            0x825064A8 => {
    //   block [0x825064A8..0x825064E4)
	// 825064A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825064AC: 4802EC11  bl 0x825350bc
	ctx.lr = 0x825064B0;
	sub_82535080(ctx, base);
	// 825064B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825064B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825064B8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825064BC: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 825064C0: 396B47B4  addi r11, r11, 0x47b4
	ctx.r[11].s64 = ctx.r[11].s64 + 18356;
	// 825064C4: 394A4790  addi r10, r10, 0x4790
	ctx.r[10].s64 = ctx.r[10].s64 + 18320;
	// 825064C8: 813F0064  lwz r9, 0x64(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 825064CC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825064D0: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825064D4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825064D8: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 825064DC: 4099005C  ble cr6, 0x82506538
	if !ctx.cr[6].gt {
	pc = 0x82506538; continue 'dispatch;
	}
	// 825064E0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x825064E4; continue 'dispatch;
            }
            0x825064E4 => {
    //   block [0x825064E4..0x82506524)
	// 825064E4: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 825064E8: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825064EC: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825064F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825064F4: 419A0030  beq cr6, 0x82506524
	if ctx.cr[6].eq {
	pc = 0x82506524; continue 'dispatch;
	}
	// 825064F8: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 825064FC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82506500: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 82506504: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82506508: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 8250650C: 409A0018  bne cr6, 0x82506524
	if !ctx.cr[6].eq {
	pc = 0x82506524; continue 'dispatch;
	}
	// 82506510: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82506514: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82506518: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250651C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82506520: 4E800421  bctrl
	ctx.lr = 0x82506524;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82506524 => {
    //   block [0x82506524..0x82506538)
	// 82506524: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82506528: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 8250652C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82506530: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82506534: 4198FFB0  blt cr6, 0x825064e4
	if ctx.cr[6].lt {
	pc = 0x825064E4; continue 'dispatch;
	}
	pc = 0x82506538; continue 'dispatch;
            }
            0x82506538 => {
    //   block [0x82506538..0x82506564)
	// 82506538: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 8250653C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82506540: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82506544: 409A0020  bne cr6, 0x82506564
	if !ctx.cr[6].eq {
	pc = 0x82506564; continue 'dispatch;
	}
	// 82506548: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250654C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82506550: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 82506554: 809F0060  lwz r4, 0x60(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82506558: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 8250655C: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82506560: 4BF5DB59  bl 0x824640b8
	ctx.lr = 0x82506564;
	sub_824640B8(ctx, base);
	pc = 0x82506564; continue 'dispatch;
            }
            0x82506564 => {
    //   block [0x82506564..0x82506574)
	// 82506564: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82506568: 4BFF48E1  bl 0x824fae48
	ctx.lr = 0x8250656C;
	sub_824FAE48(ctx, base);
	// 8250656C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82506570: 4802EB9C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82506578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82506578 size=44
    let mut pc: u32 = 0x82506578;
    'dispatch: loop {
        match pc {
            0x82506578 => {
    //   block [0x82506578..0x825065A4)
	// 82506578: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8250657C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82506580: 396B47E0  addi r11, r11, 0x47e0
	ctx.r[11].s64 = ctx.r[11].s64 + 18400;
	// 82506584: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82506588: 3D008000  lis r8, -0x8000
	ctx.r[8].s64 = -2147483648;
	// 8250658C: B1230006  sth r9, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 82506590: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82506594: 91430044  stw r10, 0x44(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[10].u32 ) };
	// 82506598: 91430048  stw r10, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[10].u32 ) };
	// 8250659C: 9103004C  stw r8, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[8].u32 ) };
	// 825065A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825065A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825065A8 size=228
    let mut pc: u32 = 0x825065A8;
    'dispatch: loop {
        match pc {
            0x825065A8 => {
    //   block [0x825065A8..0x82506600)
	// 825065A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825065AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825065B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825065B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825065B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825065BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825065C0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825065C4: 480088E5  bl 0x8250eea8
	ctx.lr = 0x825065C8;
	sub_8250EEA8(ctx, base);
	// 825065C8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825065CC: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 825065D0: 396B47B4  addi r11, r11, 0x47b4
	ctx.r[11].s64 = ctx.r[11].s64 + 18356;
	// 825065D4: 394A4790  addi r10, r10, 0x4790
	ctx.r[10].s64 = ctx.r[10].s64 + 18320;
	// 825065D8: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825065DC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825065E0: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 825065E4: 419A008C  beq cr6, 0x82506670
	if ctx.cr[6].eq {
	pc = 0x82506670; continue 'dispatch;
	}
	// 825065E8: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 825065EC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825065F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825065F4: 4099007C  ble cr6, 0x82506670
	if !ctx.cr[6].gt {
	pc = 0x82506670; continue 'dispatch;
	}
	// 825065F8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825065FC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x82506600; continue 'dispatch;
            }
            0x82506600 => {
    //   block [0x82506600..0x8250662C)
	// 82506600: 815F0060  lwz r10, 0x60(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82506604: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82506608: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 8250660C: 7D48502E  lwzx r10, r8, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82506610: 88CB0010  lbz r6, 0x10(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82506614: 80AA0008  lwz r5, 8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82506618: 2B060001  cmplwi cr6, r6, 1
	ctx.cr[6].compare_u32(ctx.r[6].u32, 1 as u32, &mut ctx.xer);
	// 8250661C: 90AB0000  stw r5, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82506620: 409A000C  bne cr6, 0x8250662c
	if !ctx.cr[6].eq {
	pc = 0x8250662C; continue 'dispatch;
	}
	// 82506624: 80CA0014  lwz r6, 0x14(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82506628: 48000008  b 0x82506630
	pc = 0x82506630; continue 'dispatch;
            }
            0x8250662C => {
    //   block [0x8250662C..0x82506630)
	// 8250662C: 80CA0020  lwz r6, 0x20(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	pc = 0x82506630; continue 'dispatch;
            }
            0x82506630 => {
    //   block [0x82506630..0x82506648)
	// 82506630: 90CB000C  stw r6, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 82506634: 88CB0011  lbz r6, 0x11(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82506638: 2B060001  cmplwi cr6, r6, 1
	ctx.cr[6].compare_u32(ctx.r[6].u32, 1 as u32, &mut ctx.xer);
	// 8250663C: 409A000C  bne cr6, 0x82506648
	if !ctx.cr[6].eq {
	pc = 0x82506648; continue 'dispatch;
	}
	// 82506640: 80CA002C  lwz r6, 0x2c(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 82506644: 48000008  b 0x8250664c
	pc = 0x8250664C; continue 'dispatch;
            }
            0x82506648 => {
    //   block [0x82506648..0x8250664C)
	// 82506648: 80CA0044  lwz r6, 0x44(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	pc = 0x8250664C; continue 'dispatch;
            }
            0x8250664C => {
    //   block [0x8250664C..0x82506670)
	// 8250664C: 90CB0020  stw r6, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[6].u32 ) };
	// 82506650: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 82506654: 814A0038  lwz r10, 0x38(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 82506658: 39290038  addi r9, r9, 0x38
	ctx.r[9].s64 = ctx.r[9].s64 + 56;
	// 8250665C: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82506660: 914B0028  stw r10, 0x28(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82506664: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82506668: 7F075800  cmpw cr6, r7, r11
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8250666C: 4198FF94  blt cr6, 0x82506600
	if ctx.cr[6].lt {
	pc = 0x82506600; continue 'dispatch;
	}
	pc = 0x82506670; continue 'dispatch;
            }
            0x82506670 => {
    //   block [0x82506670..0x8250668C)
	// 82506670: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82506674: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82506678: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8250667C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82506680: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82506684: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82506688: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82506690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82506690 size=1880
    let mut pc: u32 = 0x82506690;
    'dispatch: loop {
        match pc {
            0x82506690 => {
    //   block [0x82506690..0x825066C8)
	// 82506690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82506694: 4802EA15  bl 0x825350a8
	ctx.lr = 0x82506698;
	sub_82535080(ctx, base);
	// 82506698: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250669C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825066A0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825066A4: 3BFD0034  addi r31, r29, 0x34
	ctx.r[31].s64 = ctx.r[29].s64 + 52;
	// 825066A8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825066AC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825066B0: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825066B4: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825066B8: 409A0010  bne cr6, 0x825066c8
	if !ctx.cr[6].eq {
	pc = 0x825066C8; continue 'dispatch;
	}
	// 825066BC: 38800038  li r4, 0x38
	ctx.r[4].s64 = 56;
	// 825066C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825066C4: 4BF67C8D  bl 0x8246e350
	ctx.lr = 0x825066C8;
	sub_8246E350(ctx, base);
	pc = 0x825066C8; continue 'dispatch;
            }
            0x825066C8 => {
    //   block [0x825066C8..0x8250678C)
	// 825066C8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825066CC: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825066D0: 810D0000  lwz r8, 0(r13)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825066D4: 38A00025  li r5, 0x25
	ctx.r[5].s64 = 37;
	// 825066D8: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 825066DC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825066E0: 1D6B0038  mulli r11, r11, 0x38
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 56 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825066E4: 90FF0004  stw r7, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 825066E8: 7C69402E  lwzx r3, r9, r8
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 825066EC: 38800050  li r4, 0x50
	ctx.r[4].s64 = 80;
	// 825066F0: 7F6B5214  add r27, r11, r10
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825066F4: 4BF5D945  bl 0x82464038
	ctx.lr = 0x825066F8;
	sub_82464038(ctx, base);
	// 825066F8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825066FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82506700: 394B47E0  addi r10, r11, 0x47e0
	ctx.r[10].s64 = ctx.r[11].s64 + 18400;
	// 82506704: 39200050  li r9, 0x50
	ctx.r[9].s64 = 80;
	// 82506708: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 8250670C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82506710: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82506714: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82506718: 3BBD0060  addi r29, r29, 0x60
	ctx.r[29].s64 = ctx.r[29].s64 + 96;
	// 8250671C: B13F0004  sth r9, 4(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u16 ) };
	// 82506720: B31F0006  sth r24, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[24].u16 ) };
	// 82506724: 935F0008  stw r26, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 82506728: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 8250672C: 935F000C  stw r26, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 82506730: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82506734: 935F0014  stw r26, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[26].u32 ) };
	// 82506738: 935F0018  stw r26, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[26].u32 ) };
	// 8250673C: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82506740: 935F0020  stw r26, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[26].u32 ) };
	// 82506744: 935F0024  stw r26, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[26].u32 ) };
	// 82506748: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 8250674C: 935F002C  stw r26, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[26].u32 ) };
	// 82506750: 935F0030  stw r26, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[26].u32 ) };
	// 82506754: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82506758: 935F0038  stw r26, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[26].u32 ) };
	// 8250675C: 935F003C  stw r26, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[26].u32 ) };
	// 82506760: 917F004C  stw r11, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82506764: 935F0044  stw r26, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[26].u32 ) };
	// 82506768: 935F0048  stw r26, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[26].u32 ) };
	// 8250676C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82506770: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82506774: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82506778: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8250677C: 409A0010  bne cr6, 0x8250678c
	if !ctx.cr[6].eq {
	pc = 0x8250678C; continue 'dispatch;
	}
	// 82506780: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82506784: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82506788: 4BF67BC9  bl 0x8246e350
	ctx.lr = 0x8250678C;
	sub_8246E350(ctx, base);
	pc = 0x8250678C; continue 'dispatch;
            }
            0x8250678C => {
    //   block [0x8250678C..0x825067F4)
	// 8250678C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82506790: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82506794: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82506798: 7FEB512E  stwx r31, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[31].u32) };
	// 8250679C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825067A0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825067A4: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825067A8: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825067AC: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825067B0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825067B4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825067B8: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825067BC: 832AFFFC  lwz r25, -4(r10)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) } as u64;
	// 825067C0: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825067C4: 3BF90008  addi r31, r25, 8
	ctx.r[31].s64 = ctx.r[25].s64 + 8;
	// 825067C8: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825067CC: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825067D0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825067D4: 7FAAE214  add r29, r10, r28
	ctx.r[29].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 825067D8: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825067DC: 7F0BE800  cmpw cr6, r11, r29
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[29].s32, &mut ctx.xer);
	// 825067E0: 40980024  bge cr6, 0x82506804
	if !ctx.cr[6].lt {
	pc = 0x82506804; continue 'dispatch;
	}
	// 825067E4: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825067E8: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825067EC: 41980008  blt cr6, 0x825067f4
	if ctx.cr[6].lt {
	pc = 0x825067F4; continue 'dispatch;
	}
	// 825067F0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x825067F4; continue 'dispatch;
            }
            0x825067F4 => {
    //   block [0x825067F4..0x82506804)
	// 825067F4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 825067F8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 825067FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82506800: 4BF67AC9  bl 0x8246e2c8
	ctx.lr = 0x82506804;
	sub_8246E2C8(ctx, base);
	pc = 0x82506804; continue 'dispatch;
            }
            0x82506804 => {
    //   block [0x82506804..0x82506828)
	// 82506804: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82506808: 578B103A  slwi r11, r28, 2
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8250680C: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82506810: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 82506814: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82506818: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8250681C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82506820: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82506824: 40990038  ble cr6, 0x8250685c
	if !ctx.cr[6].gt {
	pc = 0x8250685C; continue 'dispatch;
	}
	pc = 0x82506828; continue 'dispatch;
            }
            0x82506828 => {
    //   block [0x82506828..0x8250685C)
	// 82506828: C00A0000  lfs f0, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8250682C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82506830: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82506834: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82506838: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8250683C: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82506840: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82506844: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82506848: 80FE0008  lwz r7, 8(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250684C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82506850: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82506854: 7F093800  cmpw cr6, r9, r7
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82506858: 4198FFD0  blt cr6, 0x82506828
	if ctx.cr[6].lt {
	pc = 0x82506828; continue 'dispatch;
	}
	pc = 0x8250685C; continue 'dispatch;
            }
            0x8250685C => {
    //   block [0x8250685C..0x82506898)
	// 8250685C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82506860: 3940000C  li r10, 0xc
	ctx.r[10].s64 = 12;
	// 82506864: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82506868: 915B0004  stw r10, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8250686C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82506870: 917B0008  stw r11, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82506874: 897E0010  lbz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82506878: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8250687C: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82506880: 409A00F0  bne cr6, 0x82506970
	if !ctx.cr[6].eq {
	pc = 0x82506970; continue 'dispatch;
	}
	// 82506884: 556AF87E  srwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82506888: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 8250688C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82506890: 40990008  ble cr6, 0x82506898
	if !ctx.cr[6].gt {
	pc = 0x82506898; continue 'dispatch;
	}
	// 82506894: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	pc = 0x82506898; continue 'dispatch;
            }
            0x82506898 => {
    //   block [0x82506898..0x825068C0)
	// 82506898: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8250689C: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 825068A0: 917B0014  stw r11, 0x14(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 825068A4: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 825068A8: 419A0024  beq cr6, 0x825068cc
	if ctx.cr[6].eq {
	pc = 0x825068CC; continue 'dispatch;
	}
	// 825068AC: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 825068B0: 419A0010  beq cr6, 0x825068c0
	if ctx.cr[6].eq {
	pc = 0x825068C0; continue 'dispatch;
	}
	// 825068B4: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825068B8: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825068BC: 48000014  b 0x825068d0
	pc = 0x825068D0; continue 'dispatch;
            }
            0x825068C0 => {
    //   block [0x825068C0..0x825068CC)
	// 825068C0: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825068C4: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 825068C8: 48000008  b 0x825068d0
	pc = 0x825068D0; continue 'dispatch;
            }
            0x825068CC => {
    //   block [0x825068CC..0x825068D0)
	// 825068CC: 394B0002  addi r10, r11, 2
	ctx.r[10].s64 = ctx.r[11].s64 + 2;
	pc = 0x825068D0; continue 'dispatch;
            }
            0x825068D0 => {
    //   block [0x825068D0..0x825068FC)
	// 825068D0: 3BF90014  addi r31, r25, 0x14
	ctx.r[31].s64 = ctx.r[25].s64 + 20;
	// 825068D4: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825068D8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825068DC: 7FBC5214  add r29, r28, r10
	ctx.r[29].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 825068E0: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825068E4: 7F0BE800  cmpw cr6, r11, r29
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[29].s32, &mut ctx.xer);
	// 825068E8: 40980024  bge cr6, 0x8250690c
	if !ctx.cr[6].lt {
	pc = 0x8250690C; continue 'dispatch;
	}
	// 825068EC: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825068F0: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825068F4: 41980008  blt cr6, 0x825068fc
	if ctx.cr[6].lt {
	pc = 0x825068FC; continue 'dispatch;
	}
	// 825068F8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x825068FC; continue 'dispatch;
            }
            0x825068FC => {
    //   block [0x825068FC..0x8250690C)
	// 825068FC: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82506900: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82506904: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82506908: 4BF679C1  bl 0x8246e2c8
	ctx.lr = 0x8250690C;
	sub_8246E2C8(ctx, base);
	pc = 0x8250690C; continue 'dispatch;
            }
            0x8250690C => {
    //   block [0x8250690C..0x82506934)
	// 8250690C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82506910: 578B083C  slwi r11, r28, 1
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82506914: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82506918: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 8250691C: 811E001C  lwz r8, 0x1c(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82506920: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82506924: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82506928: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 8250692C: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82506930: 40990128  ble cr6, 0x82506a58
	if !ctx.cr[6].gt {
	pc = 0x82506A58; continue 'dispatch;
	}
	pc = 0x82506934; continue 'dispatch;
            }
            0x82506934 => {
    //   block [0x82506934..0x82506970)
	// 82506934: A10A0000  lhz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82506938: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8250693C: B10B0000  sth r8, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 82506940: A10A0002  lhz r8, 2(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 82506944: B10B0002  sth r8, 2(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[8].u16 ) };
	// 82506948: A10A0004  lhz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250694C: B10B0004  sth r8, 4(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u16 ) };
	// 82506950: 80FB0014  lwz r7, 0x14(r27)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 82506954: 811E0014  lwz r8, 0x14(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82506958: 80BE001C  lwz r5, 0x1c(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 8250695C: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 82506960: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82506964: 7F092800  cmpw cr6, r9, r5
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82506968: 4198FFCC  blt cr6, 0x82506934
	if ctx.cr[6].lt {
	pc = 0x82506934; continue 'dispatch;
	}
	// 8250696C: 480000EC  b 0x82506a58
	pc = 0x82506A58; continue 'dispatch;
            }
            0x82506970 => {
    //   block [0x82506970..0x82506984)
	// 82506970: 556AF0BE  srwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82506974: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 82506978: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 8250697C: 40990008  ble cr6, 0x82506984
	if !ctx.cr[6].gt {
	pc = 0x82506984; continue 'dispatch;
	}
	// 82506980: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	pc = 0x82506984; continue 'dispatch;
            }
            0x82506984 => {
    //   block [0x82506984..0x825069AC)
	// 82506984: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82506988: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 8250698C: 917B0014  stw r11, 0x14(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82506990: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82506994: 419A0024  beq cr6, 0x825069b8
	if ctx.cr[6].eq {
	pc = 0x825069B8; continue 'dispatch;
	}
	// 82506998: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 8250699C: 419A0010  beq cr6, 0x825069ac
	if ctx.cr[6].eq {
	pc = 0x825069AC; continue 'dispatch;
	}
	// 825069A0: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825069A4: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825069A8: 48000014  b 0x825069bc
	pc = 0x825069BC; continue 'dispatch;
            }
            0x825069AC => {
    //   block [0x825069AC..0x825069B8)
	// 825069AC: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825069B0: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 825069B4: 48000008  b 0x825069bc
	pc = 0x825069BC; continue 'dispatch;
            }
            0x825069B8 => {
    //   block [0x825069B8..0x825069BC)
	// 825069B8: 394B0002  addi r10, r11, 2
	ctx.r[10].s64 = ctx.r[11].s64 + 2;
	pc = 0x825069BC; continue 'dispatch;
            }
            0x825069BC => {
    //   block [0x825069BC..0x825069E8)
	// 825069BC: 3BF90020  addi r31, r25, 0x20
	ctx.r[31].s64 = ctx.r[25].s64 + 32;
	// 825069C0: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825069C4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825069C8: 7FBC5214  add r29, r28, r10
	ctx.r[29].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 825069CC: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825069D0: 7F0BE800  cmpw cr6, r11, r29
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[29].s32, &mut ctx.xer);
	// 825069D4: 40980024  bge cr6, 0x825069f8
	if !ctx.cr[6].lt {
	pc = 0x825069F8; continue 'dispatch;
	}
	// 825069D8: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825069DC: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825069E0: 41980008  blt cr6, 0x825069e8
	if ctx.cr[6].lt {
	pc = 0x825069E8; continue 'dispatch;
	}
	// 825069E4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x825069E8; continue 'dispatch;
            }
            0x825069E8 => {
    //   block [0x825069E8..0x825069F8)
	// 825069E8: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 825069EC: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 825069F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825069F4: 4BF678D5  bl 0x8246e2c8
	ctx.lr = 0x825069F8;
	sub_8246E2C8(ctx, base);
	pc = 0x825069F8; continue 'dispatch;
            }
            0x825069F8 => {
    //   block [0x825069F8..0x82506A20)
	// 825069F8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825069FC: 578B103A  slwi r11, r28, 2
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82506A00: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82506A04: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 82506A08: 811E001C  lwz r8, 0x1c(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82506A0C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82506A10: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82506A14: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82506A18: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82506A1C: 4099003C  ble cr6, 0x82506a58
	if !ctx.cr[6].gt {
	pc = 0x82506A58; continue 'dispatch;
	}
	pc = 0x82506A20; continue 'dispatch;
            }
            0x82506A20 => {
    //   block [0x82506A20..0x82506A58)
	// 82506A20: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82506A24: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82506A28: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82506A2C: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82506A30: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82506A34: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82506A38: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82506A3C: 80FB0014  lwz r7, 0x14(r27)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 82506A40: 811E0014  lwz r8, 0x14(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82506A44: 80BE001C  lwz r5, 0x1c(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82506A48: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 82506A4C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82506A50: 7F092800  cmpw cr6, r9, r5
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82506A54: 4198FFCC  blt cr6, 0x82506a20
	if ctx.cr[6].lt {
	pc = 0x82506A20; continue 'dispatch;
	}
	pc = 0x82506A58; continue 'dispatch;
            }
            0x82506A58 => {
    //   block [0x82506A58..0x82506AC4)
	// 82506A58: 897E0010  lbz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82506A5C: 997B0010  stb r11, 0x10(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(16 as u32), ctx.r[11].u8 ) };
	// 82506A60: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82506A64: 917B001C  stw r11, 0x1c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82506A68: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82506A6C: 90DB000C  stw r6, 0xc(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 82506A70: 917B0018  stw r11, 0x18(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82506A74: 897E0011  lbz r11, 0x11(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(17 as u32) ) } as u64;
	// 82506A78: 997B0011  stb r11, 0x11(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(17 as u32), ctx.r[11].u8 ) };
	// 82506A7C: 83BE0020  lwz r29, 0x20(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82506A80: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82506A84: 419A0210  beq cr6, 0x82506c94
	if ctx.cr[6].eq {
	pc = 0x82506C94; continue 'dispatch;
	}
	// 82506A88: 897E0011  lbz r11, 0x11(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(17 as u32) ) } as u64;
	// 82506A8C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82506A90: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82506A94: 409A00E0  bne cr6, 0x82506b74
	if !ctx.cr[6].eq {
	pc = 0x82506B74; continue 'dispatch;
	}
	// 82506A98: 3BF9002C  addi r31, r25, 0x2c
	ctx.r[31].s64 = ctx.r[25].s64 + 44;
	// 82506A9C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82506AA0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82506AA4: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82506AA8: 409A0050  bne cr6, 0x82506af8
	if !ctx.cr[6].eq {
	pc = 0x82506AF8; continue 'dispatch;
	}
	// 82506AAC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82506AB0: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82506AB4: 409A0010  bne cr6, 0x82506ac4
	if !ctx.cr[6].eq {
	pc = 0x82506AC4; continue 'dispatch;
	}
	// 82506AB8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82506ABC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82506AC0: 4BF67891  bl 0x8246e350
	ctx.lr = 0x82506AC4;
	sub_8246E350(ctx, base);
	pc = 0x82506AC4; continue 'dispatch;
            }
            0x82506AC4 => {
    //   block [0x82506AC4..0x82506AF8)
	// 82506AC4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82506AC8: 895D0000  lbz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82506ACC: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82506AD0: 7D4959AE  stbx r10, r9, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u8) };
	// 82506AD4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82506AD8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82506ADC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82506AE0: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82506AE4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82506AE8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82506AEC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82506AF0: 917B0020  stw r11, 0x20(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82506AF4: 48000168  b 0x82506c5c
	pc = 0x82506C5C; continue 'dispatch;
            }
            0x82506AF8 => {
    //   block [0x82506AF8..0x82506B1C)
	// 82506AF8: 815E001C  lwz r10, 0x1c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82506AFC: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82506B00: 7FBC5214  add r29, r28, r10
	ctx.r[29].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 82506B04: 7F0BE800  cmpw cr6, r11, r29
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82506B08: 40980024  bge cr6, 0x82506b2c
	if !ctx.cr[6].lt {
	pc = 0x82506B2C; continue 'dispatch;
	}
	// 82506B0C: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82506B10: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82506B14: 41980008  blt cr6, 0x82506b1c
	if ctx.cr[6].lt {
	pc = 0x82506B1C; continue 'dispatch;
	}
	// 82506B18: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82506B1C; continue 'dispatch;
            }
            0x82506B1C => {
    //   block [0x82506B1C..0x82506B2C)
	// 82506B1C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82506B20: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82506B24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82506B28: 4BF677A1  bl 0x8246e2c8
	ctx.lr = 0x82506B2C;
	sub_8246E2C8(ctx, base);
	pc = 0x82506B2C; continue 'dispatch;
            }
            0x82506B2C => {
    //   block [0x82506B2C..0x82506B50)
	// 82506B2C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82506B30: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82506B34: 7D3C5A14  add r9, r28, r11
	ctx.r[9].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82506B38: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82506B3C: 913B0020  stw r9, 0x20(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 82506B40: 811E001C  lwz r8, 0x1c(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82506B44: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82506B48: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82506B4C: 40990110  ble cr6, 0x82506c5c
	if !ctx.cr[6].gt {
	pc = 0x82506C5C; continue 'dispatch;
	}
	pc = 0x82506B50; continue 'dispatch;
            }
            0x82506B50 => {
    //   block [0x82506B50..0x82506B74)
	// 82506B50: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82506B54: 7D0B49AE  stbx r8, r11, r9
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[8].u8) };
	// 82506B58: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82506B5C: 811E0024  lwz r8, 0x24(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82506B60: 80FE001C  lwz r7, 0x1c(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82506B64: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82506B68: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82506B6C: 4198FFE4  blt cr6, 0x82506b50
	if ctx.cr[6].lt {
	pc = 0x82506B50; continue 'dispatch;
	}
	// 82506B70: 480000EC  b 0x82506c5c
	pc = 0x82506C5C; continue 'dispatch;
            }
            0x82506B74 => {
    //   block [0x82506B74..0x82506BA0)
	// 82506B74: 3BF90044  addi r31, r25, 0x44
	ctx.r[31].s64 = ctx.r[25].s64 + 68;
	// 82506B78: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82506B7C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82506B80: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82506B84: 409A0058  bne cr6, 0x82506bdc
	if !ctx.cr[6].eq {
	pc = 0x82506BDC; continue 'dispatch;
	}
	// 82506B88: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82506B8C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82506B90: 409A0010  bne cr6, 0x82506ba0
	if !ctx.cr[6].eq {
	pc = 0x82506BA0; continue 'dispatch;
	}
	// 82506B94: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82506B98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82506B9C: 4BF677B5  bl 0x8246e350
	ctx.lr = 0x82506BA0;
	sub_8246E350(ctx, base);
	pc = 0x82506BA0; continue 'dispatch;
            }
            0x82506BA0 => {
    //   block [0x82506BA0..0x82506BDC)
	// 82506BA0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82506BA4: A15D0000  lhz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82506BA8: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82506BAC: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82506BB0: 7D4B4B2E  sthx r10, r11, r9
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u16) };
	// 82506BB4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82506BB8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82506BBC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82506BC0: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82506BC4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82506BC8: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82506BCC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82506BD0: 396BFFFE  addi r11, r11, -2
	ctx.r[11].s64 = ctx.r[11].s64 + -2;
	// 82506BD4: 917B0020  stw r11, 0x20(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82506BD8: 48000084  b 0x82506c5c
	pc = 0x82506C5C; continue 'dispatch;
            }
            0x82506BDC => {
    //   block [0x82506BDC..0x82506C00)
	// 82506BDC: 815E001C  lwz r10, 0x1c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82506BE0: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82506BE4: 7FBC5214  add r29, r28, r10
	ctx.r[29].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 82506BE8: 7F0BE800  cmpw cr6, r11, r29
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82506BEC: 40980024  bge cr6, 0x82506c10
	if !ctx.cr[6].lt {
	pc = 0x82506C10; continue 'dispatch;
	}
	// 82506BF0: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82506BF4: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82506BF8: 41980008  blt cr6, 0x82506c00
	if ctx.cr[6].lt {
	pc = 0x82506C00; continue 'dispatch;
	}
	// 82506BFC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82506C00; continue 'dispatch;
            }
            0x82506C00 => {
    //   block [0x82506C00..0x82506C10)
	// 82506C00: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82506C04: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82506C08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82506C0C: 4BF676BD  bl 0x8246e2c8
	ctx.lr = 0x82506C10;
	sub_8246E2C8(ctx, base);
	pc = 0x82506C10; continue 'dispatch;
            }
            0x82506C10 => {
    //   block [0x82506C10..0x82506C38)
	// 82506C10: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82506C14: 578B083C  slwi r11, r28, 1
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82506C18: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82506C1C: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82506C20: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82506C24: 913B0020  stw r9, 0x20(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 82506C28: 811E001C  lwz r8, 0x1c(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82506C2C: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82506C30: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82506C34: 40990028  ble cr6, 0x82506c5c
	if !ctx.cr[6].gt {
	pc = 0x82506C5C; continue 'dispatch;
	}
	pc = 0x82506C38; continue 'dispatch;
            }
            0x82506C38 => {
    //   block [0x82506C38..0x82506C5C)
	// 82506C38: A10A0000  lhz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82506C3C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82506C40: B1090000  sth r8, 0(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 82506C44: 39290002  addi r9, r9, 2
	ctx.r[9].s64 = ctx.r[9].s64 + 2;
	// 82506C48: 811E0024  lwz r8, 0x24(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82506C4C: 80FE001C  lwz r7, 0x1c(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82506C50: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82506C54: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82506C58: 4198FFE0  blt cr6, 0x82506c38
	if ctx.cr[6].lt {
	pc = 0x82506C38; continue 'dispatch;
	}
	pc = 0x82506C5C; continue 'dispatch;
            }
            0x82506C5C => {
    //   block [0x82506C5C..0x82506C8C)
	// 82506C5C: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82506C60: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82506C64: 917B0024  stw r11, 0x24(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82506C68: 419A0034  beq cr6, 0x82506c9c
	if ctx.cr[6].eq {
	pc = 0x82506C9C; continue 'dispatch;
	}
	// 82506C6C: 897B0011  lbz r11, 0x11(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(17 as u32) ) } as u64;
	// 82506C70: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82506C74: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82506C78: 419A0014  beq cr6, 0x82506c8c
	if ctx.cr[6].eq {
	pc = 0x82506C8C; continue 'dispatch;
	}
	// 82506C7C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82506C80: 409A001C  bne cr6, 0x82506c9c
	if !ctx.cr[6].eq {
	pc = 0x82506C9C; continue 'dispatch;
	}
	// 82506C84: 917B0024  stw r11, 0x24(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82506C88: 48000014  b 0x82506c9c
	pc = 0x82506C9C; continue 'dispatch;
            }
            0x82506C8C => {
    //   block [0x82506C8C..0x82506C94)
	// 82506C8C: 931B0024  stw r24, 0x24(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(36 as u32), ctx.r[24].u32 ) };
	// 82506C90: 4800000C  b 0x82506c9c
	pc = 0x82506C9C; continue 'dispatch;
            }
            0x82506C94 => {
    //   block [0x82506C94..0x82506C9C)
	// 82506C94: 935B0020  stw r26, 0x20(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[26].u32 ) };
	// 82506C98: 935B0024  stw r26, 0x24(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(36 as u32), ctx.r[26].u32 ) };
	pc = 0x82506C9C; continue 'dispatch;
            }
            0x82506C9C => {
    //   block [0x82506C9C..0x82506CDC)
	// 82506C9C: 817B0020  lwz r11, 0x20(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) } as u64;
	// 82506CA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82506CA4: 419A011C  beq cr6, 0x82506dc0
	if ctx.cr[6].eq {
	pc = 0x82506DC0; continue 'dispatch;
	}
	// 82506CA8: 3BF90038  addi r31, r25, 0x38
	ctx.r[31].s64 = ctx.r[25].s64 + 56;
	// 82506CAC: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 82506CB0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82506CB4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82506CB8: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82506CBC: 409A0060  bne cr6, 0x82506d1c
	if !ctx.cr[6].eq {
	pc = 0x82506D1C; continue 'dispatch;
	}
	// 82506CC0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82506CC4: 83BE0028  lwz r29, 0x28(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 82506CC8: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82506CCC: 409A0010  bne cr6, 0x82506cdc
	if !ctx.cr[6].eq {
	pc = 0x82506CDC; continue 'dispatch;
	}
	// 82506CD0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82506CD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82506CD8: 4BF67679  bl 0x8246e350
	ctx.lr = 0x82506CDC;
	sub_8246E350(ctx, base);
	pc = 0x82506CDC; continue 'dispatch;
            }
            0x82506CDC => {
    //   block [0x82506CDC..0x82506D1C)
	// 82506CDC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82506CE0: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82506CE4: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82506CE8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82506CEC: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 82506CF0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82506CF4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82506CF8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82506CFC: 935B002C  stw r26, 0x2c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(44 as u32), ctx.r[26].u32 ) };
	// 82506D00: 931B0030  stw r24, 0x30(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(48 as u32), ctx.r[24].u32 ) };
	// 82506D04: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82506D08: 917B0028  stw r11, 0x28(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82506D0C: 817E0034  lwz r11, 0x34(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 82506D10: 917B0034  stw r11, 0x34(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82506D14: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82506D18: 4802E3E0  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            0x82506D1C => {
    //   block [0x82506D1C..0x82506D40)
	// 82506D1C: 815E0030  lwz r10, 0x30(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82506D20: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82506D24: 7FBC5214  add r29, r28, r10
	ctx.r[29].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 82506D28: 7F0BE800  cmpw cr6, r11, r29
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82506D2C: 40980024  bge cr6, 0x82506d50
	if !ctx.cr[6].lt {
	pc = 0x82506D50; continue 'dispatch;
	}
	// 82506D30: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82506D34: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82506D38: 41980008  blt cr6, 0x82506d40
	if ctx.cr[6].lt {
	pc = 0x82506D40; continue 'dispatch;
	}
	// 82506D3C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82506D40; continue 'dispatch;
            }
            0x82506D40 => {
    //   block [0x82506D40..0x82506D50)
	// 82506D40: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82506D44: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82506D48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82506D4C: 4BF6757D  bl 0x8246e2c8
	ctx.lr = 0x82506D50;
	sub_8246E2C8(ctx, base);
	pc = 0x82506D50; continue 'dispatch;
            }
            0x82506D50 => {
    //   block [0x82506D50..0x82506D74)
	// 82506D50: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82506D54: 578A103A  slwi r10, r28, 2
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82506D58: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82506D5C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82506D60: 811E0030  lwz r8, 0x30(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82506D64: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82506D68: 815E0028  lwz r10, 0x28(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 82506D6C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82506D70: 40990028  ble cr6, 0x82506d98
	if !ctx.cr[6].gt {
	pc = 0x82506D98; continue 'dispatch;
	}
	pc = 0x82506D74; continue 'dispatch;
            }
            0x82506D74 => {
    //   block [0x82506D74..0x82506D98)
	// 82506D74: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82506D78: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82506D7C: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82506D80: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82506D84: 811E002C  lwz r8, 0x2c(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 82506D88: 80FE0030  lwz r7, 0x30(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82506D8C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82506D90: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82506D94: 4198FFE0  blt cr6, 0x82506d74
	if ctx.cr[6].lt {
	pc = 0x82506D74; continue 'dispatch;
	}
	pc = 0x82506D98; continue 'dispatch;
            }
            0x82506D98 => {
    //   block [0x82506D98..0x82506DC0)
	// 82506D98: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82506D9C: 917B002C  stw r11, 0x2c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82506DA0: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82506DA4: 917B0030  stw r11, 0x30(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82506DA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82506DAC: 917B0028  stw r11, 0x28(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82506DB0: 817E0034  lwz r11, 0x34(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 82506DB4: 917B0034  stw r11, 0x34(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82506DB8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82506DBC: 4802E33C  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            0x82506DC0 => {
    //   block [0x82506DC0..0x82506DE8)
	// 82506DC0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82506DC4: 931B0030  stw r24, 0x30(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(48 as u32), ctx.r[24].u32 ) };
	// 82506DC8: 935B002C  stw r26, 0x2c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(44 as u32), ctx.r[26].u32 ) };
	// 82506DCC: 396B9F50  addi r11, r11, -0x60b0
	ctx.r[11].s64 = ctx.r[11].s64 + -24752;
	// 82506DD0: 917B0020  stw r11, 0x20(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82506DD4: 917B0028  stw r11, 0x28(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82506DD8: 817E0034  lwz r11, 0x34(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 82506DDC: 917B0034  stw r11, 0x34(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82506DE0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82506DE4: 4802E314  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82506DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82506DE8 size=348
    let mut pc: u32 = 0x82506DE8;
    'dispatch: loop {
        match pc {
            0x82506DE8 => {
    //   block [0x82506DE8..0x82506F44)
	// 82506DE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82506DEC: 4802E2CD  bl 0x825350b8
	ctx.lr = 0x82506DF0;
	sub_82535080(ctx, base);
	// 82506DF0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82506DF4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82506DF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82506DFC: 80BE0030  lwz r5, 0x30(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82506E00: C03E0050  lfs f1, 0x50(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82506E04: 48007FF5  bl 0x8250edf8
	ctx.lr = 0x82506E08;
	sub_8250EDF8(ctx, base);
	// 82506E08: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82506E0C: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 82506E10: 396B47B4  addi r11, r11, 0x47b4
	ctx.r[11].s64 = ctx.r[11].s64 + 18356;
	// 82506E14: 394A4790  addi r10, r10, 0x4790
	ctx.r[10].s64 = ctx.r[10].s64 + 18320;
	// 82506E18: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82506E1C: 3D008000  lis r8, -0x8000
	ctx.r[8].s64 = -2147483648;
	// 82506E20: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 82506E24: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82506E28: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82506E2C: 93BF0060  stw r29, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 82506E30: 93BF0064  stw r29, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82506E34: 911F0068  stw r8, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[8].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82506F50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82506F50 size=328
    let mut pc: u32 = 0x82506F50;
    'dispatch: loop {
        match pc {
            0x82506F50 => {
    //   block [0x82506F50..0x82506F9C)
	// 82506F50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82506F54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82506F58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82506F5C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82506F60: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82506F64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82506F68: 396B47E0  addi r11, r11, 0x47e0
	ctx.r[11].s64 = ctx.r[11].s64 + 18400;
	// 82506F6C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82506F70: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82506F74: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82506F78: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82506F7C: 409A0020  bne cr6, 0x82506f9c
	if !ctx.cr[6].eq {
	pc = 0x82506F9C; continue 'dispatch;
	}
	// 82506F80: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82506F84: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82506F88: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 82506F8C: 809F0044  lwz r4, 0x44(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82506F90: 5565087C  rlwinm r5, r11, 1, 1, 0x1e
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 82506F94: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82506F98: 4BF5D121  bl 0x824640b8
	ctx.lr = 0x82506F9C;
	sub_824640B8(ctx, base);
	pc = 0x82506F9C; continue 'dispatch;
            }
            0x82506F9C => {
    //   block [0x82506F9C..0x82506FC8)
	// 82506F9C: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82506FA0: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82506FA4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82506FA8: 409A0020  bne cr6, 0x82506fc8
	if !ctx.cr[6].eq {
	pc = 0x82506FC8; continue 'dispatch;
	}
	// 82506FAC: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82506FB0: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82506FB4: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 82506FB8: 809F0038  lwz r4, 0x38(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82506FBC: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82506FC0: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82506FC4: 4BF5D0F5  bl 0x824640b8
	ctx.lr = 0x82506FC8;
	sub_824640B8(ctx, base);
	pc = 0x82506FC8; continue 'dispatch;
            }
            0x82506FC8 => {
    //   block [0x82506FC8..0x82506FF4)
	// 82506FC8: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82506FCC: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82506FD0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82506FD4: 409A0020  bne cr6, 0x82506ff4
	if !ctx.cr[6].eq {
	pc = 0x82506FF4; continue 'dispatch;
	}
	// 82506FD8: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82506FDC: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82506FE0: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 82506FE4: 809F002C  lwz r4, 0x2c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82506FE8: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82506FEC: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82506FF0: 4BF5D0C9  bl 0x824640b8
	ctx.lr = 0x82506FF4;
	sub_824640B8(ctx, base);
	pc = 0x82506FF4; continue 'dispatch;
            }
            0x82506FF4 => {
    //   block [0x82506FF4..0x82507020)
	// 82506FF4: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82506FF8: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82506FFC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82507000: 409A0020  bne cr6, 0x82507020
	if !ctx.cr[6].eq {
	pc = 0x82507020; continue 'dispatch;
	}
	// 82507004: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82507008: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8250700C: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 82507010: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82507014: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82507018: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8250701C: 4BF5D09D  bl 0x824640b8
	ctx.lr = 0x82507020;
	sub_824640B8(ctx, base);
	pc = 0x82507020; continue 'dispatch;
            }
            0x82507020 => {
    //   block [0x82507020..0x8250704C)
	// 82507020: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82507024: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82507028: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8250702C: 409A0020  bne cr6, 0x8250704c
	if !ctx.cr[6].eq {
	pc = 0x8250704C; continue 'dispatch;
	}
	// 82507030: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82507034: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82507038: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 8250703C: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82507040: 5565087C  rlwinm r5, r11, 1, 1, 0x1e
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 82507044: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82507048: 4BF5D071  bl 0x824640b8
	ctx.lr = 0x8250704C;
	sub_824640B8(ctx, base);
	pc = 0x8250704C; continue 'dispatch;
            }
            0x8250704C => {
    //   block [0x8250704C..0x82507078)
	// 8250704C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82507050: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82507054: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82507058: 409A0020  bne cr6, 0x82507078
	if !ctx.cr[6].eq {
	pc = 0x82507078; continue 'dispatch;
	}
	// 8250705C: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82507060: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82507064: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 82507068: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250706C: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82507070: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82507074: 4BF5D045  bl 0x824640b8
	ctx.lr = 0x82507078;
	sub_824640B8(ctx, base);
	pc = 0x82507078; continue 'dispatch;
            }
            0x82507078 => {
    //   block [0x82507078..0x82507098)
	// 82507078: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8250707C: 396B6DD0  addi r11, r11, 0x6dd0
	ctx.r[11].s64 = ctx.r[11].s64 + 28112;
	// 82507080: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82507084: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82507088: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8250708C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82507090: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82507094: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82507098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82507098 size=100
    let mut pc: u32 = 0x82507098;
    'dispatch: loop {
        match pc {
            0x82507098 => {
    //   block [0x82507098..0x825070E0)
	// 82507098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250709C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825070A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825070A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825070A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825070AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825070B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825070B4: 4BFFFE9D  bl 0x82506f50
	ctx.lr = 0x825070B8;
	sub_82506F50(ctx, base);
	// 825070B8: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 825070BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825070C0: 419A0020  beq cr6, 0x825070e0
	if ctx.cr[6].eq {
	pc = 0x825070E0; continue 'dispatch;
	}
	// 825070C4: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825070C8: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 825070CC: 38C00025  li r6, 0x25
	ctx.r[6].s64 = 37;
	// 825070D0: A0BF0004  lhz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825070D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825070D8: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825070DC: 4BF5CFDD  bl 0x824640b8
	ctx.lr = 0x825070E0;
	sub_824640B8(ctx, base);
	pc = 0x825070E0; continue 'dispatch;
            }
            0x825070E0 => {
    //   block [0x825070E0..0x825070FC)
	// 825070E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825070E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825070E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825070EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825070F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825070F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825070F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82507100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82507100 size=100
    let mut pc: u32 = 0x82507100;
    'dispatch: loop {
        match pc {
            0x82507100 => {
    //   block [0x82507100..0x82507148)
	// 82507100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82507104: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82507108: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8250710C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82507110: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82507114: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82507118: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8250711C: 4BFFF38D  bl 0x825064a8
	ctx.lr = 0x82507120;
	sub_825064A8(ctx, base);
	// 82507120: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82507124: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82507128: 419A0020  beq cr6, 0x82507148
	if ctx.cr[6].eq {
	pc = 0x82507148; continue 'dispatch;
	}
	// 8250712C: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82507130: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82507134: 38C00027  li r6, 0x27
	ctx.r[6].s64 = 39;
	// 82507138: A0BF0004  lhz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250713C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82507140: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82507144: 4BF5CF75  bl 0x824640b8
	ctx.lr = 0x82507148;
	sub_824640B8(ctx, base);
	pc = 0x82507148; continue 'dispatch;
            }
            0x82507148 => {
    //   block [0x82507148..0x82507164)
	// 82507148: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250714C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82507150: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82507154: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82507158: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8250715C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82507160: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82507168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82507168 size=316
    let mut pc: u32 = 0x82507168;
    'dispatch: loop {
        match pc {
            0x82507168 => {
    //   block [0x82507168..0x82507238)
	// 82507168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250716C: 4802DF4D  bl 0x825350b8
	ctx.lr = 0x82507170;
	sub_82535080(ctx, base);
	// 82507170: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82507174: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82507178: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8250717C: 3D608283  lis r11, -0x7d7d
	ctx.r[11].s64 = -2105344000;
	// 82507180: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82507184: 3B8B2690  addi r28, r11, 0x2690
	ctx.r[28].s64 = ctx.r[11].s64 + 9872;
	// 82507188: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8250718C: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82507190: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82507194: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82507198: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250719C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825071A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825071A4: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 825071A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825071AC: 4E800421  bctrl
	ctx.lr = 0x825071B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825071B0: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 825071B4: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 825071B8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825071BC: 4099007C  ble cr6, 0x82507238
	if !ctx.cr[6].gt {
	pc = 0x82507238; continue 'dispatch;
	}
	// 825071C0: 3BA00010  li r29, 0x10
	ctx.r[29].s64 = 16;
	// 825071C4: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 825071C8: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 825071CC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825071D0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825071D4: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825071D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825071DC: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 825071E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825071E4: 4E800421  bctrl
	ctx.lr = 0x825071E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825071E8: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 825071EC: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 825071F0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 825071F4: 3BBD0010  addi r29, r29, 0x10
	ctx.r[29].s64 = ctx.r[29].s64 + 16;
            }
            0x82507238 => {
    //   block [0x82507238..0x825072A4)
	// 82507238: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825072A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825072A8 size=16
    let mut pc: u32 = 0x825072A8;
    'dispatch: loop {
        match pc {
            0x825072A8 => {
    //   block [0x825072A8..0x825072B8)
	// 825072A8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825072AC: 548A2036  slwi r10, r4, 4
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825072B0: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825072B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825072B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825072B8 size=20
    let mut pc: u32 = 0x825072B8;
    'dispatch: loop {
        match pc {
            0x825072B8 => {
    //   block [0x825072B8..0x825072CC)
	// 825072B8: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825072BC: 548B2036  slwi r11, r4, 4
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825072C0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825072C4: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825072C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825072D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825072D0 size=20
    let mut pc: u32 = 0x825072D0;
    'dispatch: loop {
        match pc {
            0x825072D0 => {
    //   block [0x825072D0..0x825072E4)
	// 825072D0: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 825072D4: 548B2036  slwi r11, r4, 4
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825072D8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825072DC: 90AB0004  stw r5, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 825072E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825072E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825072E8 size=192
    let mut pc: u32 = 0x825072E8;
    'dispatch: loop {
        match pc {
            0x825072E8 => {
    //   block [0x825072E8..0x82507314)
	// 825072E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825072EC: 4802DDC9  bl 0x825350b4
	ctx.lr = 0x825072F0;
	sub_82535080(ctx, base);
	// 825072F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825072F4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825072F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825072FC: 897C0000  lbz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82507300: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82507304: 419A001C  beq cr6, 0x82507320
	if ctx.cr[6].eq {
	pc = 0x82507320; continue 'dispatch;
	}
	// 82507308: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8250730C: 2F0B00FC  cmpwi cr6, r11, 0xfc
	ctx.cr[6].compare_i32(ctx.r[11].s32, 252, &mut ctx.xer);
	// 82507310: 40990010  ble cr6, 0x82507320
	if !ctx.cr[6].gt {
	pc = 0x82507320; continue 'dispatch;
	}
	pc = 0x82507314; continue 'dispatch;
            }
            0x82507314 => {
    //   block [0x82507314..0x82507320)
	// 82507314: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82507318: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8250731C: 4802DDE8  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            0x82507320 => {
    //   block [0x82507320..0x8250733C)
	// 82507320: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82507324: 2F0B0FFF  cmpwi cr6, r11, 0xfff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4095, &mut ctx.xer);
	// 82507328: 4098FFEC  bge cr6, 0x82507314
	if !ctx.cr[6].lt {
	pc = 0x82507314; continue 'dispatch;
	}
	// 8250732C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82507330: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82507334: 40990068  ble cr6, 0x8250739c
	if !ctx.cr[6].gt {
	pc = 0x8250739C; continue 'dispatch;
	}
	// 82507338: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x8250733C; continue 'dispatch;
            }
            0x8250733C => {
    //   block [0x8250733C..0x8250739C)
	// 8250733C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82507340: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 82507344: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82507348: 7FABF214  add r29, r11, r30
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 8250734C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82507350: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82507354: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82507358: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250735C: 4E800421  bctrl
	ctx.lr = 0x82507360;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82507360: 907D0008  stw r3, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82507364: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82507368: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8250736C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82507370: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82507374: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82507378: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 8250737C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82507380: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82507384: 419AFF90  beq cr6, 0x82507314
	if ctx.cr[6].eq {
	pc = 0x82507314; continue 'dispatch;
	}
	// 82507388: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8250738C: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82507390: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 82507394: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82507398: 4198FFA4  blt cr6, 0x8250733c
	if ctx.cr[6].lt {
	pc = 0x8250733C; continue 'dispatch;
	}
            }
            0x8250739C => {
    //   block [0x8250739C..0x825073A8)
	// 8250739C: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 825073A0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825073A4: 4802DD60  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825073A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825073A8 size=56
    let mut pc: u32 = 0x825073A8;
    'dispatch: loop {
        match pc {
            0x825073A8 => {
    //   block [0x825073A8..0x825073E0)
	// 825073A8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825073AC: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 825073B0: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 825073B4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825073B8: 396B2A44  addi r11, r11, 0x2a44
	ctx.r[11].s64 = ctx.r[11].s64 + 10820;
	// 825073BC: 394A4828  addi r10, r10, 0x4828
	ctx.r[10].s64 = ctx.r[10].s64 + 18472;
	// 825073C0: 39294804  addi r9, r9, 0x4804
	ctx.r[9].s64 = ctx.r[9].s64 + 18436;
	// 825073C4: 38E0000A  li r7, 0xa
	ctx.r[7].s64 = 10;
	// 825073C8: B1030006  sth r8, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[8].u16 ) };
	// 825073CC: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 825073D0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825073D4: 91230010  stw r9, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 825073D8: 90E3000C  stw r7, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 825073DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825073E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825073E0 size=220
    let mut pc: u32 = 0x825073E0;
    'dispatch: loop {
        match pc {
            0x825073E0 => {
    //   block [0x825073E0..0x8250741C)
	// 825073E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825073E4: 4802DCD9  bl 0x825350bc
	ctx.lr = 0x825073E8;
	sub_82535080(ctx, base);
	// 825073E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825073EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825073F0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825073F4: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 825073F8: 396B4828  addi r11, r11, 0x4828
	ctx.r[11].s64 = ctx.r[11].s64 + 18472;
	// 825073FC: 394A4804  addi r10, r10, 0x4804
	ctx.r[10].s64 = ctx.r[10].s64 + 18436;
	// 82507400: 813F001C  lwz r9, 0x1c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82507404: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82507408: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8250740C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82507410: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82507414: 4099005C  ble cr6, 0x82507470
	if !ctx.cr[6].gt {
	pc = 0x82507470; continue 'dispatch;
	}
	// 82507418: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x8250741C; continue 'dispatch;
            }
            0x8250741C => {
    //   block [0x8250741C..0x8250745C)
	// 8250741C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82507420: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82507424: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82507428: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8250742C: 419A0030  beq cr6, 0x8250745c
	if ctx.cr[6].eq {
	pc = 0x8250745C; continue 'dispatch;
	}
	// 82507430: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 82507434: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82507438: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 8250743C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82507440: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 82507444: 409A0018  bne cr6, 0x8250745c
	if !ctx.cr[6].eq {
	pc = 0x8250745C; continue 'dispatch;
	}
	// 82507448: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250744C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82507450: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82507454: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82507458: 4E800421  bctrl
	ctx.lr = 0x8250745C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8250745C => {
    //   block [0x8250745C..0x82507470)
	// 8250745C: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82507460: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82507464: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 82507468: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8250746C: 4198FFB0  blt cr6, 0x8250741c
	if ctx.cr[6].lt {
	pc = 0x8250741C; continue 'dispatch;
	}
	pc = 0x82507470; continue 'dispatch;
            }
            0x82507470 => {
    //   block [0x82507470..0x8250749C)
	// 82507470: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82507474: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82507478: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8250747C: 409A0020  bne cr6, 0x8250749c
	if !ctx.cr[6].eq {
	pc = 0x8250749C; continue 'dispatch;
	}
	// 82507480: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82507484: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82507488: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 8250748C: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82507490: 55652036  slwi r5, r11, 4
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82507494: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82507498: 4BF5CC21  bl 0x824640b8
	ctx.lr = 0x8250749C;
	sub_824640B8(ctx, base);
	pc = 0x8250749C; continue 'dispatch;
            }
            0x8250749C => {
    //   block [0x8250749C..0x825074BC)
	// 8250749C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825074A0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825074A4: 396B2A44  addi r11, r11, 0x2a44
	ctx.r[11].s64 = ctx.r[11].s64 + 10820;
	// 825074A8: 394A6DD0  addi r10, r10, 0x6dd0
	ctx.r[10].s64 = ctx.r[10].s64 + 28112;
	// 825074AC: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 825074B0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825074B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825074B8: 4802DC54  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825074C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825074C0 size=252
    let mut pc: u32 = 0x825074C0;
    'dispatch: loop {
        match pc {
            0x825074C0 => {
    //   block [0x825074C0..0x82507500)
	// 825074C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825074C4: 4802DBF1  bl 0x825350b4
	ctx.lr = 0x825074C8;
	sub_82535080(ctx, base);
	// 825074C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825074CC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825074D0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825074D4: 3BFB0018  addi r31, r27, 0x18
	ctx.r[31].s64 = ctx.r[27].s64 + 24;
	// 825074D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825074DC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825074E0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825074E4: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825074E8: 7F0BE800  cmpw cr6, r11, r29
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[29].s32, &mut ctx.xer);
	// 825074EC: 40980024  bge cr6, 0x82507510
	if !ctx.cr[6].lt {
	pc = 0x82507510; continue 'dispatch;
	}
	// 825074F0: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825074F4: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825074F8: 41980008  blt cr6, 0x82507500
	if ctx.cr[6].lt {
	pc = 0x82507500; continue 'dispatch;
	}
	// 825074FC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82507500; continue 'dispatch;
            }
            0x82507500 => {
    //   block [0x82507500..0x82507510)
	// 82507500: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 82507504: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82507508: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250750C: 4BF66DBD  bl 0x8246e2c8
	ctx.lr = 0x82507510;
	sub_8246E2C8(ctx, base);
	pc = 0x82507510; continue 'dispatch;
            }
            0x82507510 => {
    //   block [0x82507510..0x82507530)
	// 82507510: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82507514: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82507518: 40990094  ble cr6, 0x825075ac
	if !ctx.cr[6].gt {
	pc = 0x825075AC; continue 'dispatch;
	}
	// 8250751C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82507520: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82507524: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82507528: 7CBEE050  subf r5, r30, r28
	ctx.r[5].s64 = ctx.r[28].s64 - ctx.r[30].s64;
	// 8250752C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x82507530; continue 'dispatch;
            }
            0x82507530 => {
    //   block [0x82507530..0x82507554)
	// 82507530: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82507534: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82507538: 419A0060  beq cr6, 0x82507598
	if ctx.cr[6].eq {
	pc = 0x82507598; continue 'dispatch;
	}
	// 8250753C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82507540: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82507544: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 82507548: 419A000C  beq cr6, 0x82507554
	if ctx.cr[6].eq {
	pc = 0x82507554; continue 'dispatch;
	}
	// 8250754C: 7D25402E  lwzx r9, r5, r8
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82507550: 48000008  b 0x82507558
	pc = 0x82507558; continue 'dispatch;
            }
            0x82507554 => {
    //   block [0x82507554..0x82507558)
	// 82507554: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	pc = 0x82507558; continue 'dispatch;
            }
            0x82507558 => {
    //   block [0x82507558..0x82507580)
	// 82507558: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250755C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82507560: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82507564: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82507568: A12A0004  lhz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250756C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82507570: 419A0010  beq cr6, 0x82507580
	if ctx.cr[6].eq {
	pc = 0x82507580; continue 'dispatch;
	}
	// 82507574: A12A0006  lhz r9, 6(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 82507578: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8250757C: B12A0006  sth r9, 6(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	pc = 0x82507580; continue 'dispatch;
            }
            0x82507580 => {
    //   block [0x82507580..0x82507598)
	// 82507580: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82507584: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82507588: 93AA000C  stw r29, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 8250758C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82507590: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82507594: 90CA0008  stw r6, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	pc = 0x82507598; continue 'dispatch;
            }
            0x82507598 => {
    //   block [0x82507598..0x825075AC)
	// 82507598: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 8250759C: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 825075A0: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 825075A4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825075A8: 409AFF88  bne cr6, 0x82507530
	if !ctx.cr[6].eq {
	pc = 0x82507530; continue 'dispatch;
	}
	pc = 0x825075AC; continue 'dispatch;
            }
            0x825075AC => {
    //   block [0x825075AC..0x825075BC)
	// 825075AC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825075B0: 4BFFFBB9  bl 0x82507168
	ctx.lr = 0x825075B4;
	sub_82507168(ctx, base);
	// 825075B4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825075B8: 4802DB4C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825075C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825075C0 size=536
    let mut pc: u32 = 0x825075C0;
    'dispatch: loop {
        match pc {
            0x825075C0 => {
    //   block [0x825075C0..0x82507614)
	// 825075C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825075C4: 4802DAD9  bl 0x8253509c
	ctx.lr = 0x825075C8;
	sub_82535080(ctx, base);
	// 825075C8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825075CC: 82ED0000  lwz r23, 0(r13)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825075D0: 3B000014  li r24, 0x14
	ctx.r[24].s64 = 20;
	// 825075D4: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 825075D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825075DC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825075E0: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 825075E4: 7D78B82E  lwzx r11, r24, r23
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 825075E8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825075EC: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825075F0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825075F4: 40980020  bge cr6, 0x82507614
	if !ctx.cr[6].lt {
	pc = 0x82507614; continue 'dispatch;
	}
	// 825075F8: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 825075FC: 3929484C  addi r9, r9, 0x484c
	ctx.r[9].s64 = ctx.r[9].s64 + 18508;
	// 82507600: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82507604: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 82507608: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 8250760C: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82507610: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x82507614; continue 'dispatch;
            }
            0x82507614 => {
    //   block [0x82507614..0x8250764C)
	// 82507614: 817A0040  lwz r11, 0x40(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(64 as u32) ) } as u64;
	// 82507618: 3AC0FFFF  li r22, -1
	ctx.r[22].s64 = -1;
	// 8250761C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82507620: 7ED9B378  mr r25, r22
	ctx.r[25].u64 = ctx.r[22].u64;
	// 82507624: 917A0040  stw r11, 0x40(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82507628: 817C0024  lwz r11, 0x24(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 8250762C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82507630: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82507634: 409A0084  bne cr6, 0x825076b8
	if !ctx.cr[6].eq {
	pc = 0x825076B8; continue 'dispatch;
	}
	// 82507638: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8250763C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82507640: 40990128  ble cr6, 0x82507768
	if !ctx.cr[6].gt {
	pc = 0x82507768; continue 'dispatch;
	}
	// 82507644: 3B7F0010  addi r27, r31, 0x10
	ctx.r[27].s64 = ctx.r[31].s64 + 16;
	// 82507648: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x8250764C; continue 'dispatch;
            }
            0x8250764C => {
    //   block [0x8250764C..0x825076A0)
	// 8250764C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82507650: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82507654: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82507658: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250765C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82507660: 4E800421  bctrl
	ctx.lr = 0x82507664;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82507664: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82507668: 419A0038  beq cr6, 0x825076a0
	if ctx.cr[6].eq {
	pc = 0x825076A0; continue 'dispatch;
	}
	// 8250766C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82507670: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82507674: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82507678: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8250767C: 7C8BF02E  lwzx r4, r11, r30
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82507680: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82507684: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82507688: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250768C: 4E800421  bctrl
	ctx.lr = 0x82507690;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82507690: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82507694: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82507698: 419A0008  beq cr6, 0x825076a0
	if ctx.cr[6].eq {
	pc = 0x825076A0; continue 'dispatch;
	}
	// 8250769C: 7FB9EB78  mr r25, r29
	ctx.r[25].u64 = ctx.r[29].u64;
            }
            0x825076A0 => {
    //   block [0x825076A0..0x825076B8)
	// 825076A0: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 825076A4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 825076A8: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 825076AC: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825076B0: 4198FF9C  blt cr6, 0x8250764c
	if ctx.cr[6].lt {
	pc = 0x8250764C; continue 'dispatch;
	}
	// 825076B4: 480000B4  b 0x82507768
	pc = 0x82507768; continue 'dispatch;
            }
            0x825076B8 => {
    //   block [0x825076B8..0x825076CC)
	// 825076B8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825076BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825076C0: 409900A8  ble cr6, 0x82507768
	if !ctx.cr[6].gt {
	pc = 0x82507768; continue 'dispatch;
	}
	// 825076C4: 3B7F0010  addi r27, r31, 0x10
	ctx.r[27].s64 = ctx.r[31].s64 + 16;
	// 825076C8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x825076CC; continue 'dispatch;
            }
            0x825076CC => {
    //   block [0x825076CC..0x82507754)
	// 825076CC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825076D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825076D4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825076D8: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825076DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825076E0: 4E800421  bctrl
	ctx.lr = 0x825076E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825076E4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825076E8: 419A006C  beq cr6, 0x82507754
	if ctx.cr[6].eq {
	pc = 0x82507754; continue 'dispatch;
	}
	// 825076EC: 809C0024  lwz r4, 0x24(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 825076F0: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 825076F4: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 825076F8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 825076FC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82507700: 38610052  addi r3, r1, 0x52
	ctx.r[3].s64 = ctx.r[1].s64 + 82;
	// 82507704: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82507708: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250770C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82507710: 4E800421  bctrl
	ctx.lr = 0x82507714;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82507714: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82507718: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8250771C: 419A0038  beq cr6, 0x82507754
	if ctx.cr[6].eq {
	pc = 0x82507754; continue 'dispatch;
	}
	// 82507720: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82507724: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82507728: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8250772C: 38610051  addi r3, r1, 0x51
	ctx.r[3].s64 = ctx.r[1].s64 + 81;
	// 82507730: 7C8BE82E  lwzx r4, r11, r29
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82507734: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82507738: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 8250773C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82507740: 4E800421  bctrl
	ctx.lr = 0x82507744;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82507744: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82507748: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8250774C: 419A0008  beq cr6, 0x82507754
	if ctx.cr[6].eq {
	pc = 0x82507754; continue 'dispatch;
	}
	// 82507750: 7FD9F378  mr r25, r30
	ctx.r[25].u64 = ctx.r[30].u64;
            }
            0x82507754 => {
    //   block [0x82507754..0x82507768)
	// 82507754: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82507758: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 8250775C: 3BBD0010  addi r29, r29, 0x10
	ctx.r[29].s64 = ctx.r[29].s64 + 16;
	// 82507760: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82507764: 4198FF68  blt cr6, 0x825076cc
	if ctx.cr[6].lt {
	pc = 0x825076CC; continue 'dispatch;
	}
	pc = 0x82507768; continue 'dispatch;
            }
            0x82507768 => {
    //   block [0x82507768..0x82507788)
	// 82507768: 817A0040  lwz r11, 0x40(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(64 as u32) ) } as u64;
	// 8250776C: 2F19FFFF  cmpwi cr6, r25, -1
	ctx.cr[6].compare_i32(ctx.r[25].s32, -1, &mut ctx.xer);
	// 82507770: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82507774: 917A0040  stw r11, 0x40(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82507778: 419A0010  beq cr6, 0x82507788
	if ctx.cr[6].eq {
	pc = 0x82507788; continue 'dispatch;
	}
	// 8250777C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82507780: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82507784: 7F2BD12E  stwx r25, r11, r26
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32), ctx.r[25].u32) };
	pc = 0x82507788; continue 'dispatch;
            }
            0x82507788 => {
    //   block [0x82507788..0x825077B8)
	// 82507788: 7D58B82E  lwzx r10, r24, r23
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 8250778C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82507790: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82507794: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82507798: 40980020  bge cr6, 0x825077b8
	if !ctx.cr[6].lt {
	pc = 0x825077B8; continue 'dispatch;
	}
	// 8250779C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 825077A0: 392974DC  addi r9, r9, 0x74dc
	ctx.r[9].s64 = ctx.r[9].s64 + 29916;
	// 825077A4: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825077A8: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 825077AC: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 825077B0: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825077B4: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x825077B8; continue 'dispatch;
            }
            0x825077B8 => {
    //   block [0x825077B8..0x825077D8)
	// 825077B8: 7D79B050  subf r11, r25, r22
	ctx.r[11].s64 = ctx.r[22].s64 - ctx.r[25].s64;
	// 825077BC: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 825077C0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825077C4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825077C8: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 825077CC: 99750000  stb r11, 0(r21)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825077D0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825077D4: 4802D918  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825077D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825077D8 size=260
    let mut pc: u32 = 0x825077D8;
    'dispatch: loop {
        match pc {
            0x825077D8 => {
    //   block [0x825077D8..0x825078DC)
	// 825077D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825077DC: 4802D8D5  bl 0x825350b0
	ctx.lr = 0x825077E0;
	sub_82535080(ctx, base);
	// 825077E0: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 825077E4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825077E8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825077EC: 11BF038C  vspltisw v13, -1
	for i in 0..4 {
		ctx.v[13].u32[i] = 4294967295;
	}
	// 825077F0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825077F4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 825077F8: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 825077FC: 396B9F50  addi r11, r11, -0x60b0
	ctx.r[11].s64 = ctx.r[11].s64 + -24752;
	// 82507800: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82507804: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825078E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825078E0 size=1996
    let mut pc: u32 = 0x825078E0;
    'dispatch: loop {
        match pc {
            0x825078E0 => {
    //   block [0x825078E0..0x825080AC)
	// 825078E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825078E4: 4802D79D  bl 0x82535080
	ctx.lr = 0x825078E8;
	sub_82535080(ctx, base);
	// 825078E8: DBC1FF58  stfd f30, -0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.f[30].u64 ) };
	// 825078EC: DBE1FF60  stfd f31, -0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 825078F0: 3981FF50  addi r12, r1, -0xb0
	ctx.r[12].s64 = ctx.r[1].s64 + -176;
	// 825078F4: 48031AB1  bl 0x825393a4
	ctx.lr = 0x825078F8;
	sub_82539130(ctx, base);
	// 825078F8: 9421FC10  stwu r1, -0x3f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-1008 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825078FC: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825080B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825080B0 size=1004
    let mut pc: u32 = 0x825080B0;
    'dispatch: loop {
        match pc {
            0x825080B0 => {
    //   block [0x825080B0..0x8250849C)
	// 825080B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825080B4: 4802CFCD  bl 0x82535080
	ctx.lr = 0x825080B8;
	sub_82535080(ctx, base);
	// 825080B8: DBC1FF58  stfd f30, -0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.f[30].u64 ) };
	// 825080BC: DBE1FF60  stfd f31, -0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 825080C0: 9421FC90  stwu r1, -0x370(r1)
	ea = ctx.r[1].u32.wrapping_add(-880 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825080C4: 7D575378  mr r23, r10
	ctx.r[23].u64 = ctx.r[10].u64;
	// 825080C8: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 825080CC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825080D0: 7D3C4B78  mr r28, r9
	ctx.r[28].u64 = ctx.r[9].u64;
	// 825080D4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825080D8: 3B5C0010  addi r26, r28, 0x10
	ctx.r[26].s64 = ctx.r[28].s64 + 16;
	// 825080DC: 3A4B0010  addi r18, r11, 0x10
	ctx.r[18].s64 = ctx.r[11].s64 + 16;
	// 825080E0: C00A8CB4  lfs f0, -0x734c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-29516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825080E4: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 825080E8: D01C0000  stfs f0, 0(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825080EC: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825084A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825084A0 size=232
    let mut pc: u32 = 0x825084A0;
    'dispatch: loop {
        match pc {
            0x825084A0 => {
    //   block [0x825084A0..0x82508518)
	// 825084A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825084A4: 4802CC11  bl 0x825350b4
	ctx.lr = 0x825084A8;
	sub_82535080(ctx, base);
	// 825084A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825084AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825084B0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825084B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825084B8: 388B4870  addi r4, r11, 0x4870
	ctx.r[4].s64 = ctx.r[11].s64 + 18544;
	// 825084BC: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 825084C0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825084C4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825084C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825084CC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825084D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825084D4: 4E800421  bctrl
	ctx.lr = 0x825084D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825084D8: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 825084DC: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825084E0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825084E4: 409A0034  bne cr6, 0x82508518
	if !ctx.cr[6].eq {
	pc = 0x82508518; continue 'dispatch;
	}
	// 825084E8: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825084EC: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 825084F0: 80FF001C  lwz r7, 0x1c(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 825084F4: 55682036  slwi r8, r11, 4
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825084F8: 80DF0018  lwz r6, 0x18(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 825084FC: 388A4864  addi r4, r10, 0x4864
	ctx.r[4].s64 = ctx.r[10].s64 + 18532;
	// 82508500: 54E72036  slwi r7, r7, 4
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(4);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82508504: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82508508: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250850C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82508510: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82508514: 4E800421  bctrl
	ctx.lr = 0x82508518;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82508518 => {
    //   block [0x82508518..0x82508534)
	// 82508518: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8250851C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82508520: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82508524: 40990048  ble cr6, 0x8250856c
	if !ctx.cr[6].gt {
	pc = 0x8250856C; continue 'dispatch;
	}
	// 82508528: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8250852C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82508530: 3B6B485C  addi r27, r11, 0x485c
	ctx.r[27].s64 = ctx.r[11].s64 + 18524;
	pc = 0x82508534; continue 'dispatch;
            }
            0x82508534 => {
    //   block [0x82508534..0x8250856C)
	// 82508534: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82508538: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8250853C: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82508540: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82508544: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82508548: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8250854C: 7CCAE82E  lwzx r6, r10, r29
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82508550: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82508554: 4E800421  bctrl
	ctx.lr = 0x82508558;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82508558: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8250855C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82508560: 3BBD0010  addi r29, r29, 0x10
	ctx.r[29].s64 = ctx.r[29].s64 + 16;
	// 82508564: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82508568: 4198FFCC  blt cr6, 0x82508534
	if ctx.cr[6].lt {
	pc = 0x82508534; continue 'dispatch;
	}
            }
            0x8250856C => {
    //   block [0x8250856C..0x82508588)
	// 8250856C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82508570: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82508574: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82508578: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250857C: 4E800421  bctrl
	ctx.lr = 0x82508580;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82508580: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82508584: 4802CB80  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82508588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82508588 size=192
    let mut pc: u32 = 0x82508588;
    'dispatch: loop {
        match pc {
            0x82508588 => {
    //   block [0x82508588..0x825085F8)
	// 82508588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250858C: 4802CB31  bl 0x825350bc
	ctx.lr = 0x82508590;
	sub_82535080(ctx, base);
	// 82508590: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82508594: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82508598: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 8250859C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825085A0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825085A4: 48002D1D  bl 0x8250b2c0
	ctx.lr = 0x825085A8;
	sub_8250B2C0(ctx, base);
	// 825085A8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825085AC: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 825085B0: 396B4828  addi r11, r11, 0x4828
	ctx.r[11].s64 = ctx.r[11].s64 + 18472;
	// 825085B4: 3D008000  lis r8, -0x8000
	ctx.r[8].s64 = -2147483648;
	// 825085B8: 394A4804  addi r10, r10, 0x4804
	ctx.r[10].s64 = ctx.r[10].s64 + 18436;
	// 825085BC: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 825085C0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825085C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825085C8: 550B003E  slwi r11, r8, 0
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825085CC: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 825085D0: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 825085D4: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825085D8: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825085DC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 825085E0: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825085E4: 40980020  bge cr6, 0x82508604
	if !ctx.cr[6].lt {
	pc = 0x82508604; continue 'dispatch;
	}
	// 825085E8: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825085EC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 825085F0: 41990008  bgt cr6, 0x825085f8
	if ctx.cr[6].gt {
	pc = 0x825085F8; continue 'dispatch;
	}
	// 825085F4: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	pc = 0x825085F8; continue 'dispatch;
            }
            0x825085F8 => {
    //   block [0x825085F8..0x82508604)
	// 825085F8: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 825085FC: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82508600: 4BF65CC9  bl 0x8246e2c8
	ctx.lr = 0x82508604;
	sub_8246E2C8(ctx, base);
	pc = 0x82508604; continue 'dispatch;
            }
            0x82508604 => {
    //   block [0x82508604..0x82508630)
	// 82508604: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82508608: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8250860C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82508610: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82508614: 4BFFEEAD  bl 0x825074c0
	ctx.lr = 0x82508618;
	sub_825074C0(ctx, base);
	// 82508618: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250861C: 4BFFEB4D  bl 0x82507168
	ctx.lr = 0x82508620;
	sub_82507168(ctx, base);
	// 82508620: 397F0050  addi r11, r31, 0x50
	ctx.r[11].s64 = ctx.r[31].s64 + 80;
	// 82508624: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 82508628: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 8250862C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82508630; continue 'dispatch;
            }
            0x82508630 => {
    //   block [0x82508630..0x82508648)
	// 82508630: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82508634: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82508638: 4200FFF8  bdnz 0x82508630
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82508630; continue 'dispatch;
	}
	// 8250863C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82508640: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82508644: 4802CAC8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82508648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82508648 size=44
    let mut pc: u32 = 0x82508648;
    'dispatch: loop {
        match pc {
            0x82508648 => {
    //   block [0x82508648..0x82508674)
	// 82508648: 2B040100  cmplwi cr6, r4, 0x100
	ctx.cr[6].compare_u32(ctx.r[4].u32, 256 as u32, &mut ctx.xer);
	// 8250864C: 40980028  bge cr6, 0x82508674
	if !ctx.cr[6].lt {
		sub_82508674(ctx, base);
		return;
	}
	// 82508650: 548A06FE  clrlwi r10, r4, 0x1b
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x0000001Fu64;
	// 82508654: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82508658: 548BD97E  srwi r11, r4, 5
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shr(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8250865C: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82508660: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82508664: 7D6B182E  lwzx r11, r11, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82508668: 7D2A5030  slw r10, r9, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[9].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 8250866C: 7D435838  and r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 & ctx.r[11].u64;
	// 82508670: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82508674(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82508674 size=8
    let mut pc: u32 = 0x82508674;
    'dispatch: loop {
        match pc {
            0x82508674 => {
    //   block [0x82508674..0x8250867C)
	// 82508674: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82508678: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82508680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82508680 size=8
    let mut pc: u32 = 0x82508680;
    'dispatch: loop {
        match pc {
            0x82508680 => {
    //   block [0x82508680..0x82508688)
	// 82508680: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82508684: 48000024  b 0x825086a8
	sub_825086A8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82508688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82508688 size=28
    let mut pc: u32 = 0x82508688;
    'dispatch: loop {
        match pc {
            0x82508688 => {
    //   block [0x82508688..0x825086A4)
	// 82508688: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8250868C: 39640001  addi r11, r4, 1
	ctx.r[11].s64 = ctx.r[4].s64 + 1;
	// 82508690: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82508694: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82508698: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 8250869C: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 825086A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825086A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825086A8 size=100
    let mut pc: u32 = 0x825086A8;
    'dispatch: loop {
        match pc {
            0x825086A8 => {
    //   block [0x825086A8..0x825086F0)
	// 825086A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825086AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825086B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825086B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825086B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825086BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825086C0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825086C4: 4BFFED1D  bl 0x825073e0
	ctx.lr = 0x825086C8;
	sub_825073E0(ctx, base);
	// 825086C8: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 825086CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825086D0: 419A0020  beq cr6, 0x825086f0
	if ctx.cr[6].eq {
	pc = 0x825086F0; continue 'dispatch;
	}
	// 825086D4: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825086D8: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 825086DC: 38C00027  li r6, 0x27
	ctx.r[6].s64 = 39;
	// 825086E0: A0BF0004  lhz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825086E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825086E8: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825086EC: 4BF5B9CD  bl 0x824640b8
	ctx.lr = 0x825086F0;
	sub_824640B8(ctx, base);
	pc = 0x825086F0; continue 'dispatch;
            }
            0x825086F0 => {
    //   block [0x825086F0..0x8250870C)
	// 825086F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825086F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825086F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825086FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82508700: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82508704: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82508708: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82508740(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82508740 size=24
    let mut pc: u32 = 0x82508740;
    'dispatch: loop {
        match pc {
            0x82508740 => {
    //   block [0x82508740..0x82508758)
	// 82508740: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82508744: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82508748: 396B4880  addi r11, r11, 0x4880
	ctx.r[11].s64 = ctx.r[11].s64 + 18560;
	// 8250874C: B1430006  sth r10, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 82508750: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82508754: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82508758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82508758 size=104
    let mut pc: u32 = 0x82508758;
    'dispatch: loop {
        match pc {
            0x82508758 => {
    //   block [0x82508758..0x825087C0)
	// 82508758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250875C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82508760: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82508764: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82508768: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8250876C: 4BFFC29D  bl 0x82504a08
	ctx.lr = 0x82508770;
	sub_82504A08(ctx, base);
	// 82508770: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82508774: 3D008000  lis r8, -0x8000
	ctx.r[8].s64 = -2147483648;
	// 82508778: 394B48B4  addi r10, r11, 0x48b4
	ctx.r[10].s64 = ctx.r[11].s64 + 18612;
	// 8250877C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82508780: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82508784: 392B4890  addi r9, r11, 0x4890
	ctx.r[9].s64 = ctx.r[11].s64 + 18576;
	// 82508788: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8250878C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82508790: 913F0010  stw r9, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82508794: 917F00C0  stw r11, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82508798: 917F00C4  stw r11, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 8250879C: 911F00C8  stw r8, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[8].u32 ) };
	// 825087A0: 917F00CC  stw r11, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 825087A4: 917F00D0  stw r11, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 825087A8: 911F00D4  stw r8, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[8].u32 ) };
	// 825087AC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825087B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825087B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825087B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825087BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825087C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825087C0 size=512
    let mut pc: u32 = 0x825087C0;
    'dispatch: loop {
        match pc {
            0x825087C0 => {
    //   block [0x825087C0..0x825087FC)
	// 825087C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825087C4: 4802C8ED  bl 0x825350b0
	ctx.lr = 0x825087C8;
	sub_82535080(ctx, base);
	// 825087C8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825087CC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825087D0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825087D4: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 825087D8: 396B48B4  addi r11, r11, 0x48b4
	ctx.r[11].s64 = ctx.r[11].s64 + 18612;
	// 825087DC: 394A4890  addi r10, r10, 0x4890
	ctx.r[10].s64 = ctx.r[10].s64 + 18576;
	// 825087E0: 813D00C4  lwz r9, 0xc4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(196 as u32) ) } as u64;
	// 825087E4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825087E8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825087EC: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825087F0: 915D0010  stw r10, 0x10(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 825087F4: 4099005C  ble cr6, 0x82508850
	if !ctx.cr[6].gt {
	pc = 0x82508850; continue 'dispatch;
	}
	// 825087F8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x825087FC; continue 'dispatch;
            }
            0x825087FC => {
    //   block [0x825087FC..0x8250883C)
	// 825087FC: 817D00C0  lwz r11, 0xc0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(192 as u32) ) } as u64;
	// 82508800: 7C6BF82E  lwzx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82508804: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82508808: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8250880C: 419A0030  beq cr6, 0x8250883c
	if ctx.cr[6].eq {
	pc = 0x8250883C; continue 'dispatch;
	}
	// 82508810: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 82508814: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82508818: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 8250881C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82508820: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 82508824: 409A0018  bne cr6, 0x8250883c
	if !ctx.cr[6].eq {
	pc = 0x8250883C; continue 'dispatch;
	}
	// 82508828: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250882C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82508830: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82508834: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82508838: 4E800421  bctrl
	ctx.lr = 0x8250883C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8250883C => {
    //   block [0x8250883C..0x82508850)
	// 8250883C: 817D00C4  lwz r11, 0xc4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(196 as u32) ) } as u64;
	// 82508840: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82508844: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82508848: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8250884C: 4198FFB0  blt cr6, 0x825087fc
	if ctx.cr[6].lt {
	pc = 0x825087FC; continue 'dispatch;
	}
	pc = 0x82508850; continue 'dispatch;
            }
            0x82508850 => {
    //   block [0x82508850..0x82508864)
	// 82508850: 817D005C  lwz r11, 0x5c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(92 as u32) ) } as u64;
	// 82508854: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82508858: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8250885C: 4099008C  ble cr6, 0x825088e8
	if !ctx.cr[6].gt {
	pc = 0x825088E8; continue 'dispatch;
	}
	// 82508860: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	pc = 0x82508864; continue 'dispatch;
            }
            0x82508864 => {
    //   block [0x82508864..0x82508880)
	// 82508864: 817D0058  lwz r11, 0x58(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(88 as u32) ) } as u64;
	// 82508868: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8250886C: 7FFB5A14  add r31, r27, r11
	ctx.r[31].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 82508870: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82508874: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82508878: 4099005C  ble cr6, 0x825088d4
	if !ctx.cr[6].gt {
	pc = 0x825088D4; continue 'dispatch;
	}
	// 8250887C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82508880; continue 'dispatch;
            }
            0x82508880 => {
    //   block [0x82508880..0x825088C0)
	// 82508880: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82508884: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82508888: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250888C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82508890: 419A0030  beq cr6, 0x825088c0
	if ctx.cr[6].eq {
	pc = 0x825088C0; continue 'dispatch;
	}
	// 82508894: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 82508898: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8250889C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 825088A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825088A4: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 825088A8: 409A0018  bne cr6, 0x825088c0
	if !ctx.cr[6].eq {
	pc = 0x825088C0; continue 'dispatch;
	}
	// 825088AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825088B0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825088B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825088B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825088BC: 4E800421  bctrl
	ctx.lr = 0x825088C0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x825088C0 => {
    //   block [0x825088C0..0x825088D4)
	// 825088C0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 825088C4: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 825088C8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 825088CC: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825088D0: 4198FFB0  blt cr6, 0x82508880
	if ctx.cr[6].lt {
	pc = 0x82508880; continue 'dispatch;
	}
	pc = 0x825088D4; continue 'dispatch;
            }
            0x825088D4 => {
    //   block [0x825088D4..0x825088E8)
	// 825088D4: 817D005C  lwz r11, 0x5c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(92 as u32) ) } as u64;
	// 825088D8: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 825088DC: 3B7B0040  addi r27, r27, 0x40
	ctx.r[27].s64 = ctx.r[27].s64 + 64;
	// 825088E0: 7F1A5800  cmpw cr6, r26, r11
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825088E4: 4198FF80  blt cr6, 0x82508864
	if ctx.cr[6].lt {
	pc = 0x82508864; continue 'dispatch;
	}
	pc = 0x825088E8; continue 'dispatch;
            }
            0x825088E8 => {
    //   block [0x825088E8..0x82508904)
	// 825088E8: 817D00D0  lwz r11, 0xd0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(208 as u32) ) } as u64;
	// 825088EC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825088F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825088F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825088F8: 917D005C  stw r11, 0x5c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825088FC: 4099005C  ble cr6, 0x82508958
	if !ctx.cr[6].gt {
	pc = 0x82508958; continue 'dispatch;
	}
	// 82508900: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82508904; continue 'dispatch;
            }
            0x82508904 => {
    //   block [0x82508904..0x82508944)
	// 82508904: 817D00CC  lwz r11, 0xcc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(204 as u32) ) } as u64;
	// 82508908: 7C7F582E  lwzx r3, r31, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8250890C: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82508910: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82508914: 419A0030  beq cr6, 0x82508944
	if ctx.cr[6].eq {
	pc = 0x82508944; continue 'dispatch;
	}
	// 82508918: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 8250891C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82508920: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 82508924: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82508928: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 8250892C: 409A0018  bne cr6, 0x82508944
	if !ctx.cr[6].eq {
	pc = 0x82508944; continue 'dispatch;
	}
	// 82508930: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82508934: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82508938: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250893C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82508940: 4E800421  bctrl
	ctx.lr = 0x82508944;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82508944 => {
    //   block [0x82508944..0x82508958)
	// 82508944: 817D00D0  lwz r11, 0xd0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(208 as u32) ) } as u64;
	// 82508948: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 8250894C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82508950: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82508954: 4198FFB0  blt cr6, 0x82508904
	if ctx.cr[6].lt {
	pc = 0x82508904; continue 'dispatch;
	}
	pc = 0x82508958; continue 'dispatch;
            }
            0x82508958 => {
    //   block [0x82508958..0x82508984)
	// 82508958: 817D00D4  lwz r11, 0xd4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(212 as u32) ) } as u64;
	// 8250895C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82508960: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82508964: 409A0020  bne cr6, 0x82508984
	if !ctx.cr[6].eq {
	pc = 0x82508984; continue 'dispatch;
	}
	// 82508968: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250896C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82508970: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 82508974: 809D00CC  lwz r4, 0xcc(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(204 as u32) ) } as u64;
	// 82508978: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 8250897C: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82508980: 4BF5B739  bl 0x824640b8
	ctx.lr = 0x82508984;
	sub_824640B8(ctx, base);
	pc = 0x82508984; continue 'dispatch;
            }
            0x82508984 => {
    //   block [0x82508984..0x825089B0)
	// 82508984: 817D00C8  lwz r11, 0xc8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(200 as u32) ) } as u64;
	// 82508988: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8250898C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82508990: 409A0020  bne cr6, 0x825089b0
	if !ctx.cr[6].eq {
	pc = 0x825089B0; continue 'dispatch;
	}
	// 82508994: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82508998: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8250899C: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 825089A0: 809D00C0  lwz r4, 0xc0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(192 as u32) ) } as u64;
	// 825089A4: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 825089A8: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825089AC: 4BF5B70D  bl 0x824640b8
	ctx.lr = 0x825089B0;
	sub_824640B8(ctx, base);
	pc = 0x825089B0; continue 'dispatch;
            }
            0x825089B0 => {
    //   block [0x825089B0..0x825089C0)
	// 825089B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825089B4: 4BFFC4BD  bl 0x82504e70
	ctx.lr = 0x825089B8;
	sub_82504E70(ctx, base);
	// 825089B8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825089BC: 4802C744  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825089C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825089C0 size=24
    let mut pc: u32 = 0x825089C0;
    'dispatch: loop {
        match pc {
            0x825089C0 => {
    //   block [0x825089C0..0x825089D8)
	// 825089C0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825089C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825089C8: 396B48E4  addi r11, r11, 0x48e4
	ctx.r[11].s64 = ctx.r[11].s64 + 18660;
	// 825089CC: B1430006  sth r10, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 825089D0: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825089D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825089D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825089D8 size=396
    let mut pc: u32 = 0x825089D8;
    'dispatch: loop {
        match pc {
            0x825089D8 => {
    //   block [0x825089D8..0x82508A3C)
	// 825089D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825089DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825089E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825089E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825089E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825089EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825089F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825089F4: 4BFFC5ED  bl 0x82504fe0
	ctx.lr = 0x825089F8;
	sub_82504FE0(ctx, base);
	// 825089F8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825089FC: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 82508A00: 396B48B4  addi r11, r11, 0x48b4
	ctx.r[11].s64 = ctx.r[11].s64 + 18612;
	// 82508A04: 394A4890  addi r10, r10, 0x4890
	ctx.r[10].s64 = ctx.r[10].s64 + 18576;
	// 82508A08: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82508A0C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82508A10: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82508A14: 419A0134  beq cr6, 0x82508b48
	if ctx.cr[6].eq {
	pc = 0x82508B48; continue 'dispatch;
	}
	// 82508A18: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82508A1C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82508A20: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82508A24: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82508A28: 4099009C  ble cr6, 0x82508ac4
	if !ctx.cr[6].gt {
	pc = 0x82508AC4; continue 'dispatch;
	}
	// 82508A2C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82508A30: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82508A34: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82508A38: 38CB48E4  addi r6, r11, 0x48e4
	ctx.r[6].s64 = ctx.r[11].s64 + 18660;
	pc = 0x82508A3C; continue 'dispatch;
            }
            0x82508A3C => {
    //   block [0x82508A3C..0x82508A5C)
	// 82508A3C: 815F00C0  lwz r10, 0xc0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82508A40: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82508A44: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82508A48: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82508A4C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82508A50: 419A000C  beq cr6, 0x82508a5c
	if ctx.cr[6].eq {
	pc = 0x82508A5C; continue 'dispatch;
	}
	// 82508A54: B0AA0006  sth r5, 6(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(6 as u32), ctx.r[5].u16 ) };
	// 82508A58: 90CA0000  stw r6, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	pc = 0x82508A5C; continue 'dispatch;
            }
            0x82508A5C => {
    //   block [0x82508A5C..0x82508A80)
	// 82508A5C: 815F00C0  lwz r10, 0xc0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82508A60: 888B0038  lbz r4, 0x38(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82508A64: 2B040001  cmplwi cr6, r4, 1
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1 as u32, &mut ctx.xer);
	// 82508A68: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82508A6C: 808A0008  lwz r4, 8(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82508A70: 908B0014  stw r4, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[4].u32 ) };
	// 82508A74: 409A000C  bne cr6, 0x82508a80
	if !ctx.cr[6].eq {
	pc = 0x82508A80; continue 'dispatch;
	}
	// 82508A78: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82508A7C: 48000008  b 0x82508a84
	pc = 0x82508A84; continue 'dispatch;
            }
            0x82508A80 => {
    //   block [0x82508A80..0x82508A84)
	// 82508A80: 808A0020  lwz r4, 0x20(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	pc = 0x82508A84; continue 'dispatch;
            }
            0x82508A84 => {
    //   block [0x82508A84..0x82508A9C)
	// 82508A84: 908B0030  stw r4, 0x30(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[4].u32 ) };
	// 82508A88: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82508A8C: 2B040001  cmplwi cr6, r4, 1
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1 as u32, &mut ctx.xer);
	// 82508A90: 409A000C  bne cr6, 0x82508a9c
	if !ctx.cr[6].eq {
	pc = 0x82508A9C; continue 'dispatch;
	}
	// 82508A94: 808A002C  lwz r4, 0x2c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 82508A98: 48000008  b 0x82508aa0
	pc = 0x82508AA0; continue 'dispatch;
            }
            0x82508A9C => {
    //   block [0x82508A9C..0x82508AA0)
	// 82508A9C: 808A0044  lwz r4, 0x44(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	pc = 0x82508AA0; continue 'dispatch;
            }
            0x82508AA0 => {
    //   block [0x82508AA0..0x82508AC4)
	// 82508AA0: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82508AA4: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 82508AA8: 814A0038  lwz r10, 0x38(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 82508AAC: 39080040  addi r8, r8, 0x40
	ctx.r[8].s64 = ctx.r[8].s64 + 64;
	// 82508AB0: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82508AB4: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82508AB8: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82508ABC: 7F075800  cmpw cr6, r7, r11
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82508AC0: 4198FF7C  blt cr6, 0x82508a3c
	if ctx.cr[6].lt {
	pc = 0x82508A3C; continue 'dispatch;
	}
	pc = 0x82508AC4; continue 'dispatch;
            }
            0x82508AC4 => {
    //   block [0x82508AC4..0x82508AE4)
	// 82508AC4: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82508AC8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82508ACC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82508AD0: 40990078  ble cr6, 0x82508b48
	if !ctx.cr[6].gt {
	pc = 0x82508B48; continue 'dispatch;
	}
	// 82508AD4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82508AD8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82508ADC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82508AE0: 38CB4880  addi r6, r11, 0x4880
	ctx.r[6].s64 = ctx.r[11].s64 + 18560;
	pc = 0x82508AE4; continue 'dispatch;
            }
            0x82508AE4 => {
    //   block [0x82508AE4..0x82508B04)
	// 82508AE4: 809F00CC  lwz r4, 0xcc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82508AE8: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82508AEC: 7D485A14  add r10, r8, r11
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82508AF0: 7D69202E  lwzx r11, r9, r4
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 82508AF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82508AF8: 419A000C  beq cr6, 0x82508b04
	if ctx.cr[6].eq {
	pc = 0x82508B04; continue 'dispatch;
	}
	// 82508AFC: B0AB0006  sth r5, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[5].u16 ) };
	// 82508B00: 90CB0000  stw r6, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	pc = 0x82508B04; continue 'dispatch;
            }
            0x82508B04 => {
    //   block [0x82508B04..0x82508B20)
	// 82508B04: 817F00CC  lwz r11, 0xcc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82508B08: 888A0001  lbz r4, 1(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(1 as u32) ) } as u64;
	// 82508B0C: 2B040001  cmplwi cr6, r4, 1
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1 as u32, &mut ctx.xer);
	// 82508B10: 7D69582E  lwzx r11, r9, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82508B14: 409A000C  bne cr6, 0x82508b20
	if !ctx.cr[6].eq {
	pc = 0x82508B20; continue 'dispatch;
	}
	// 82508B18: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82508B1C: 48000008  b 0x82508b24
	pc = 0x82508B24; continue 'dispatch;
            }
            0x82508B20 => {
    //   block [0x82508B20..0x82508B24)
	// 82508B20: 808B002C  lwz r4, 0x2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	pc = 0x82508B24; continue 'dispatch;
            }
            0x82508B24 => {
    //   block [0x82508B24..0x82508B48)
	// 82508B24: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82508B28: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 82508B2C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82508B30: 39080040  addi r8, r8, 0x40
	ctx.r[8].s64 = ctx.r[8].s64 + 64;
	// 82508B34: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82508B38: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82508B3C: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82508B40: 7F075800  cmpw cr6, r7, r11
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82508B44: 4198FFA0  blt cr6, 0x82508ae4
	if ctx.cr[6].lt {
	pc = 0x82508AE4; continue 'dispatch;
	}
	pc = 0x82508B48; continue 'dispatch;
            }
            0x82508B48 => {
    //   block [0x82508B48..0x82508B64)
	// 82508B48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82508B4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82508B50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82508B54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82508B58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82508B5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82508B60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82508B68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82508B68 size=1940
    let mut pc: u32 = 0x82508B68;
    'dispatch: loop {
        match pc {
            0x82508B68 => {
    //   block [0x82508B68..0x825092FC)
	// 82508B68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82508B6C: 4802C531  bl 0x8253509c
	ctx.lr = 0x82508B70;
	sub_82535080(ctx, base);
	// 82508B70: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82508B74: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 82508B78: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82508B7C: 4BFFCD45  bl 0x825058c0
	ctx.lr = 0x82508B80;
	sub_825058C0(ctx, base);
	// 82508B80: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 82508B84: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82508B88: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 82508B8C: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 82508B90: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82509300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82509300 size=1268
    let mut pc: u32 = 0x82509300;
    'dispatch: loop {
        match pc {
            0x82509300 => {
    //   block [0x82509300..0x825093B0)
	// 82509300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82509304: 4802BD9D  bl 0x825350a0
	ctx.lr = 0x82509308;
	sub_82535080(ctx, base);
	// 82509308: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250930C: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 82509310: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82509314: 4BFFC66D  bl 0x82505980
	ctx.lr = 0x82509318;
	sub_82505980(ctx, base);
	// 82509318: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250931C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82509320: 38A00025  li r5, 0x25
	ctx.r[5].s64 = 37;
	// 82509324: 38800038  li r4, 0x38
	ctx.r[4].s64 = 56;
	// 82509328: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8250932C: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82509330: 4BF5AD09  bl 0x82464038
	ctx.lr = 0x82509334;
	sub_82464038(ctx, base);
	// 82509334: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82509338: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8250933C: 394B4880  addi r10, r11, 0x4880
	ctx.r[10].s64 = ctx.r[11].s64 + 18560;
	// 82509340: 39200038  li r9, 0x38
	ctx.r[9].s64 = 56;
	// 82509344: 3AE00001  li r23, 1
	ctx.r[23].s64 = 1;
	// 82509348: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 8250934C: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 82509350: 3BB600CC  addi r29, r22, 0xcc
	ctx.r[29].s64 = ctx.r[22].s64 + 204;
	// 82509354: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82509358: B13E0004  sth r9, 4(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u16 ) };
	// 8250935C: B2FE0006  sth r23, 6(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(6 as u32), ctx.r[23].u16 ) };
	// 82509360: 933E0008  stw r25, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 82509364: 917E0010  stw r11, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82509368: 933E000C  stw r25, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[25].u32 ) };
	// 8250936C: 917E001C  stw r11, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82509370: 933E0014  stw r25, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[25].u32 ) };
	// 82509374: 933E0018  stw r25, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[25].u32 ) };
	// 82509378: 917E0028  stw r11, 0x28(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 8250937C: 933E0020  stw r25, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[25].u32 ) };
	// 82509380: 933E0024  stw r25, 0x24(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), ctx.r[25].u32 ) };
	// 82509384: 917E0034  stw r11, 0x34(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82509388: 933E002C  stw r25, 0x2c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), ctx.r[25].u32 ) };
	// 8250938C: 933E0030  stw r25, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[25].u32 ) };
	// 82509390: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82509394: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82509398: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 8250939C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825093A0: 409A0010  bne cr6, 0x825093b0
	if !ctx.cr[6].eq {
	pc = 0x825093B0; continue 'dispatch;
	}
	// 825093A4: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 825093A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825093AC: 4BF64FA5  bl 0x8246e350
	ctx.lr = 0x825093B0;
	sub_8246E350(ctx, base);
	pc = 0x825093B0; continue 'dispatch;
            }
            0x825093B0 => {
    //   block [0x825093B0..0x825097F4)
	// 825093B0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825093B4: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 825093B8: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825093BC: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 825093C0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825093C4: 7F3ACB78  mr r26, r25
	ctx.r[26].u64 = ctx.r[25].u64;
	// 825093C8: 7FCB512E  stwx r30, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[30].u32) };
	// 825093CC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825093D0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825093D4: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825093D8: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825093DC: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825093E0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825093E4: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825093E8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825093EC: 830BFFFC  lwz r24, -4(r11)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 825093F0: 90FC0000  stw r7, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 825093F4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825093F8: 917C0004  stw r11, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825093FC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82509400: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82509404: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82509408: 917C000C  stw r11, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 8250940C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82509410: 917C0010  stw r11, 0x10(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82509414: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82509418: 917C0014  stw r11, 0x14(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 8250941C: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82509420: 997C0018  stb r11, 0x18(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 82509424: 897F0019  lbz r11, 0x19(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(25 as u32) ) } as u64;
	// 82509428: 997C0019  stb r11, 0x19(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825097F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825097F8 size=428
    let mut pc: u32 = 0x825097F8;
    'dispatch: loop {
        match pc {
            0x825097F8 => {
    //   block [0x825097F8..0x825099A4)
	// 825097F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825097FC: 4802B8B9  bl 0x825350b4
	ctx.lr = 0x82509800;
	sub_82535080(ctx, base);
	// 82509800: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82509804: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82509808: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8250980C: 80BE0018  lwz r5, 0x18(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82509810: C03E00B0  lfs f1, 0xb0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82509814: 4BFFB1F5  bl 0x82504a08
	ctx.lr = 0x82509818;
	sub_82504A08(ctx, base);
	// 82509818: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8250981C: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 82509820: 396B48B4  addi r11, r11, 0x48b4
	ctx.r[11].s64 = ctx.r[11].s64 + 18612;
	// 82509824: 394A4890  addi r10, r10, 0x4890
	ctx.r[10].s64 = ctx.r[10].s64 + 18576;
	// 82509828: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 8250982C: 3D208000  lis r9, -0x8000
	ctx.r[9].s64 = -2147483648;
	// 82509830: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 82509834: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82509838: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 8250983C: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82509840: 937F00C0  stw r27, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[27].u32 ) };
	// 82509844: 937F00C4  stw r27, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[27].u32 ) };
	// 82509848: 913F00C8  stw r9, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[9].u32 ) };
	// 8250984C: 937F00CC  stw r27, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[27].u32 ) };
	// 82509850: 937F00D0  stw r27, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[27].u32 ) };
	// 82509854: 913F00D4  stw r9, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[9].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825099A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825099A8 size=240
    let mut pc: u32 = 0x825099A8;
    'dispatch: loop {
        match pc {
            0x825099A8 => {
    //   block [0x825099A8..0x825099F4)
	// 825099A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825099AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825099B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825099B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825099B8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 825099BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825099C0: 396B4880  addi r11, r11, 0x4880
	ctx.r[11].s64 = ctx.r[11].s64 + 18560;
	// 825099C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825099C8: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 825099CC: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825099D0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825099D4: 409A0020  bne cr6, 0x825099f4
	if !ctx.cr[6].eq {
	pc = 0x825099F4; continue 'dispatch;
	}
	// 825099D8: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825099DC: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 825099E0: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 825099E4: 809F002C  lwz r4, 0x2c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 825099E8: 5565087C  rlwinm r5, r11, 1, 1, 0x1e
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 825099EC: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825099F0: 4BF5A6C9  bl 0x824640b8
	ctx.lr = 0x825099F4;
	sub_824640B8(ctx, base);
	pc = 0x825099F4; continue 'dispatch;
            }
            0x825099F4 => {
    //   block [0x825099F4..0x82509A20)
	// 825099F4: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 825099F8: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825099FC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82509A00: 409A0020  bne cr6, 0x82509a20
	if !ctx.cr[6].eq {
	pc = 0x82509A20; continue 'dispatch;
	}
	// 82509A04: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82509A08: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82509A0C: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 82509A10: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82509A14: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82509A18: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82509A1C: 4BF5A69D  bl 0x824640b8
	ctx.lr = 0x82509A20;
	sub_824640B8(ctx, base);
	pc = 0x82509A20; continue 'dispatch;
            }
            0x82509A20 => {
    //   block [0x82509A20..0x82509A4C)
	// 82509A20: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82509A24: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82509A28: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82509A2C: 409A0020  bne cr6, 0x82509a4c
	if !ctx.cr[6].eq {
	pc = 0x82509A4C; continue 'dispatch;
	}
	// 82509A30: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82509A34: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82509A38: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 82509A3C: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82509A40: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82509A44: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82509A48: 4BF5A671  bl 0x824640b8
	ctx.lr = 0x82509A4C;
	sub_824640B8(ctx, base);
	pc = 0x82509A4C; continue 'dispatch;
            }
            0x82509A4C => {
    //   block [0x82509A4C..0x82509A78)
	// 82509A4C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82509A50: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82509A54: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82509A58: 409A0020  bne cr6, 0x82509a78
	if !ctx.cr[6].eq {
	pc = 0x82509A78; continue 'dispatch;
	}
	// 82509A5C: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82509A60: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82509A64: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 82509A68: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82509A6C: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82509A70: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82509A74: 4BF5A645  bl 0x824640b8
	ctx.lr = 0x82509A78;
	sub_824640B8(ctx, base);
	pc = 0x82509A78; continue 'dispatch;
            }
            0x82509A78 => {
    //   block [0x82509A78..0x82509A98)
	// 82509A78: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82509A7C: 396B6DD0  addi r11, r11, 0x6dd0
	ctx.r[11].s64 = ctx.r[11].s64 + 28112;
	// 82509A80: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82509A84: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82509A88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82509A8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82509A90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82509A94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82509A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82509A98 size=100
    let mut pc: u32 = 0x82509A98;
    'dispatch: loop {
        match pc {
            0x82509A98 => {
    //   block [0x82509A98..0x82509AE0)
	// 82509A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82509A9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82509AA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82509AA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82509AA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82509AAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82509AB0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82509AB4: 4BFFFEF5  bl 0x825099a8
	ctx.lr = 0x82509AB8;
	sub_825099A8(ctx, base);
	// 82509AB8: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82509ABC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82509AC0: 419A0020  beq cr6, 0x82509ae0
	if ctx.cr[6].eq {
	pc = 0x82509AE0; continue 'dispatch;
	}
	// 82509AC4: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82509AC8: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82509ACC: 38C00025  li r6, 0x25
	ctx.r[6].s64 = 37;
	// 82509AD0: A0BF0004  lhz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82509AD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82509AD8: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82509ADC: 4BF5A5DD  bl 0x824640b8
	ctx.lr = 0x82509AE0;
	sub_824640B8(ctx, base);
	pc = 0x82509AE0; continue 'dispatch;
            }
            0x82509AE0 => {
    //   block [0x82509AE0..0x82509AFC)
	// 82509AE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82509AE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82509AE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82509AEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82509AF0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82509AF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82509AF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82509B08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82509B08 size=328
    let mut pc: u32 = 0x82509B08;
    'dispatch: loop {
        match pc {
            0x82509B08 => {
    //   block [0x82509B08..0x82509B54)
	// 82509B08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82509B0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82509B10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82509B14: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82509B18: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82509B1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82509B20: 396B48E4  addi r11, r11, 0x48e4
	ctx.r[11].s64 = ctx.r[11].s64 + 18660;
	// 82509B24: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82509B28: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82509B2C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82509B30: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82509B34: 409A0020  bne cr6, 0x82509b54
	if !ctx.cr[6].eq {
	pc = 0x82509B54; continue 'dispatch;
	}
	// 82509B38: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82509B3C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82509B40: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 82509B44: 809F0044  lwz r4, 0x44(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 82509B48: 5565087C  rlwinm r5, r11, 1, 1, 0x1e
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 82509B4C: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82509B50: 4BF5A569  bl 0x824640b8
	ctx.lr = 0x82509B54;
	sub_824640B8(ctx, base);
	pc = 0x82509B54; continue 'dispatch;
            }
            0x82509B54 => {
    //   block [0x82509B54..0x82509B80)
	// 82509B54: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82509B58: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82509B5C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82509B60: 409A0020  bne cr6, 0x82509b80
	if !ctx.cr[6].eq {
	pc = 0x82509B80; continue 'dispatch;
	}
	// 82509B64: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82509B68: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82509B6C: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 82509B70: 809F0038  lwz r4, 0x38(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82509B74: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82509B78: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82509B7C: 4BF5A53D  bl 0x824640b8
	ctx.lr = 0x82509B80;
	sub_824640B8(ctx, base);
	pc = 0x82509B80; continue 'dispatch;
            }
            0x82509B80 => {
    //   block [0x82509B80..0x82509BAC)
	// 82509B80: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82509B84: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82509B88: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82509B8C: 409A0020  bne cr6, 0x82509bac
	if !ctx.cr[6].eq {
	pc = 0x82509BAC; continue 'dispatch;
	}
	// 82509B90: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82509B94: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82509B98: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 82509B9C: 809F002C  lwz r4, 0x2c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82509BA0: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82509BA4: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82509BA8: 4BF5A511  bl 0x824640b8
	ctx.lr = 0x82509BAC;
	sub_824640B8(ctx, base);
	pc = 0x82509BAC; continue 'dispatch;
            }
            0x82509BAC => {
    //   block [0x82509BAC..0x82509BD8)
	// 82509BAC: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82509BB0: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82509BB4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82509BB8: 409A0020  bne cr6, 0x82509bd8
	if !ctx.cr[6].eq {
	pc = 0x82509BD8; continue 'dispatch;
	}
	// 82509BBC: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82509BC0: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82509BC4: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 82509BC8: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82509BCC: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82509BD0: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82509BD4: 4BF5A4E5  bl 0x824640b8
	ctx.lr = 0x82509BD8;
	sub_824640B8(ctx, base);
	pc = 0x82509BD8; continue 'dispatch;
            }
            0x82509BD8 => {
    //   block [0x82509BD8..0x82509C04)
	// 82509BD8: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82509BDC: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82509BE0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82509BE4: 409A0020  bne cr6, 0x82509c04
	if !ctx.cr[6].eq {
	pc = 0x82509C04; continue 'dispatch;
	}
	// 82509BE8: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82509BEC: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82509BF0: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 82509BF4: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82509BF8: 5565087C  rlwinm r5, r11, 1, 1, 0x1e
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 82509BFC: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82509C00: 4BF5A4B9  bl 0x824640b8
	ctx.lr = 0x82509C04;
	sub_824640B8(ctx, base);
	pc = 0x82509C04; continue 'dispatch;
            }
            0x82509C04 => {
    //   block [0x82509C04..0x82509C30)
	// 82509C04: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82509C08: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82509C0C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82509C10: 409A0020  bne cr6, 0x82509c30
	if !ctx.cr[6].eq {
	pc = 0x82509C30; continue 'dispatch;
	}
	// 82509C14: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82509C18: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82509C1C: 38C00017  li r6, 0x17
	ctx.r[6].s64 = 23;
	// 82509C20: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82509C24: 55652036  slwi r5, r11, 4
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82509C28: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82509C2C: 4BF5A48D  bl 0x824640b8
	ctx.lr = 0x82509C30;
	sub_824640B8(ctx, base);
	pc = 0x82509C30; continue 'dispatch;
            }
            0x82509C30 => {
    //   block [0x82509C30..0x82509C50)
	// 82509C30: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82509C34: 396B6DD0  addi r11, r11, 0x6dd0
	ctx.r[11].s64 = ctx.r[11].s64 + 28112;
	// 82509C38: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82509C3C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82509C40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82509C44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82509C48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82509C4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82509C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82509C50 size=100
    let mut pc: u32 = 0x82509C50;
    'dispatch: loop {
        match pc {
            0x82509C50 => {
    //   block [0x82509C50..0x82509C98)
	// 82509C50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82509C54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82509C58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82509C5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82509C60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82509C64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82509C68: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82509C6C: 4BFFFE9D  bl 0x82509b08
	ctx.lr = 0x82509C70;
	sub_82509B08(ctx, base);
	// 82509C70: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82509C74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82509C78: 419A0020  beq cr6, 0x82509c98
	if ctx.cr[6].eq {
	pc = 0x82509C98; continue 'dispatch;
	}
	// 82509C7C: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82509C80: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82509C84: 38C00025  li r6, 0x25
	ctx.r[6].s64 = 37;
	// 82509C88: A0BF0004  lhz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82509C8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82509C90: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82509C94: 4BF5A425  bl 0x824640b8
	ctx.lr = 0x82509C98;
	sub_824640B8(ctx, base);
	pc = 0x82509C98; continue 'dispatch;
            }
            0x82509C98 => {
    //   block [0x82509C98..0x82509CB4)
	// 82509C98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82509C9C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82509CA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82509CA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82509CA8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82509CAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82509CB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82509CB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82509CB8 size=100
    let mut pc: u32 = 0x82509CB8;
    'dispatch: loop {
        match pc {
            0x82509CB8 => {
    //   block [0x82509CB8..0x82509D00)
	// 82509CB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82509CBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82509CC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82509CC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82509CC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82509CCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82509CD0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82509CD4: 4BFFEAED  bl 0x825087c0
	ctx.lr = 0x82509CD8;
	sub_825087C0(ctx, base);
	// 82509CD8: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82509CDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82509CE0: 419A0020  beq cr6, 0x82509d00
	if ctx.cr[6].eq {
	pc = 0x82509D00; continue 'dispatch;
	}
	// 82509CE4: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82509CE8: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82509CEC: 38C00027  li r6, 0x27
	ctx.r[6].s64 = 39;
	// 82509CF0: A0BF0004  lhz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82509CF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82509CF8: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82509CFC: 4BF5A3BD  bl 0x824640b8
	ctx.lr = 0x82509D00;
	sub_824640B8(ctx, base);
	pc = 0x82509D00; continue 'dispatch;
            }
            0x82509D00 => {
    //   block [0x82509D00..0x82509D1C)
	// 82509D00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82509D04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82509D08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82509D0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82509D10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82509D14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82509D18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82509D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82509D20 size=144
    let mut pc: u32 = 0x82509D20;
    'dispatch: loop {
        match pc {
            0x82509D20 => {
    //   block [0x82509D20..0x82509DB0)
	// 82509D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82509D24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82509D28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82509D2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82509D30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82509D34: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82509D38: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82509D3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82509D40: 388B48F0  addi r4, r11, 0x48f0
	ctx.r[4].s64 = ctx.r[11].s64 + 18672;
	// 82509D44: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82509D48: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82509D4C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82509D50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82509D54: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82509D58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82509D5C: 4E800421  bctrl
	ctx.lr = 0x82509D60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82509D60: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82509D64: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82509D68: 80DE0018  lwz r6, 0x18(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82509D6C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82509D70: 388B485C  addi r4, r11, 0x485c
	ctx.r[4].s64 = ctx.r[11].s64 + 18524;
	// 82509D74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82509D78: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82509D7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82509D80: 4E800421  bctrl
	ctx.lr = 0x82509D84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82509D84: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82509D88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82509D8C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82509D90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82509D94: 4E800421  bctrl
	ctx.lr = 0x82509D98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82509D98: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82509D9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82509DA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82509DA4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82509DA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82509DAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82509DB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82509DB0 size=8
    let mut pc: u32 = 0x82509DB0;
    'dispatch: loop {
        match pc {
            0x82509DB0 => {
    //   block [0x82509DB0..0x82509DB8)
	// 82509DB0: 38630014  addi r3, r3, 0x14
	ctx.r[3].s64 = ctx.r[3].s64 + 20;
	// 82509DB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82509DB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82509DB8 size=132
    let mut pc: u32 = 0x82509DB8;
    'dispatch: loop {
        match pc {
            0x82509DB8 => {
    //   block [0x82509DB8..0x82509E14)
	// 82509DB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82509DBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82509DC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82509DC4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82509DC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82509DCC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82509DD0: 396B30EC  addi r11, r11, 0x30ec
	ctx.r[11].s64 = ctx.r[11].s64 + 12524;
	// 82509DD4: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82509DD8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82509DDC: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82509DE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82509DE4: 419A0030  beq cr6, 0x82509e14
	if ctx.cr[6].eq {
	pc = 0x82509E14; continue 'dispatch;
	}
	// 82509DE8: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 82509DEC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82509DF0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 82509DF4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82509DF8: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 82509DFC: 409A0018  bne cr6, 0x82509e14
	if !ctx.cr[6].eq {
	pc = 0x82509E14; continue 'dispatch;
	}
	// 82509E00: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82509E04: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82509E08: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82509E0C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82509E10: 4E800421  bctrl
	ctx.lr = 0x82509E14;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82509E14 => {
    //   block [0x82509E14..0x82509E3C)
	// 82509E14: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 82509E18: 4BFEF8D9  bl 0x824f96f0
	ctx.lr = 0x82509E1C;
	sub_824F96F0(ctx, base);
	// 82509E1C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82509E20: 396B6DD0  addi r11, r11, 0x6dd0
	ctx.r[11].s64 = ctx.r[11].s64 + 28112;
	// 82509E24: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82509E28: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82509E2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82509E30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82509E34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82509E38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82509E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82509E40 size=20
    let mut pc: u32 = 0x82509E40;
    'dispatch: loop {
        match pc {
            0x82509E40 => {
    //   block [0x82509E40..0x82509E54)
	// 82509E40: 80630010  lwz r3, 0x10(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82509E44: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82509E48: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82509E4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82509E50: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82509E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82509E58 size=112
    let mut pc: u32 = 0x82509E58;
    'dispatch: loop {
        match pc {
            0x82509E58 => {
    //   block [0x82509E58..0x82509EA8)
	// 82509E58: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 82509E5C: 90830010  stw r4, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[4].u32 ) };
	// 82509E60: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 82509E64: 396B30EC  addi r11, r11, 0x30ec
	ctx.r[11].s64 = ctx.r[11].s64 + 12524;
	// 82509E68: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82509E6C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82509E70: 38E0001A  li r7, 0x1a
	ctx.r[7].s64 = 26;
	// 82509E74: 394A2A68  addi r10, r10, 0x2a68
	ctx.r[10].s64 = ctx.r[10].s64 + 10856;
	// 82509E78: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82509E7C: B1230006  sth r9, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 82509E80: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82509E84: 90E3000C  stw r7, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82509E88: 91430014  stw r10, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82509E8C: 90A30018  stw r5, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[5].u32 ) };
	// 82509E90: A1650004  lhz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82509E94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82509E98: 419A0010  beq cr6, 0x82509ea8
	if ctx.cr[6].eq {
	pc = 0x82509EA8; continue 'dispatch;
	}
	// 82509E9C: A1650006  lhz r11, 6(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(6 as u32) ) } as u64;
	// 82509EA0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82509EA4: B1650006  sth r11, 6(r5)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[5].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	pc = 0x82509EA8; continue 'dispatch;
            }
            0x82509EA8 => {
    //   block [0x82509EA8..0x82509EC8)
	// 82509EA8: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82509EAC: A14B0004  lhz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82509EB0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82509EB4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82509EB8: A14B0006  lhz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 82509EBC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82509EC0: B14B0006  sth r10, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 82509EC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82509EC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82509EC8 size=216
    let mut pc: u32 = 0x82509EC8;
    'dispatch: loop {
        match pc {
            0x82509EC8 => {
    //   block [0x82509EC8..0x82509F14)
	// 82509EC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82509ECC: 4802B1ED  bl 0x825350b8
	ctx.lr = 0x82509ED0;
	sub_82535080(ctx, base);
	// 82509ED0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82509ED4: 838D0000  lwz r28, 0(r13)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82509ED8: 3BA00014  li r29, 0x14
	ctx.r[29].s64 = 20;
	// 82509EDC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82509EE0: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82509EE4: 7D7DE02E  lwzx r11, r29, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82509EE8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82509EEC: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82509EF0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82509EF4: 40980020  bge cr6, 0x82509f14
	if !ctx.cr[6].lt {
	pc = 0x82509F14; continue 'dispatch;
	}
	// 82509EF8: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 82509EFC: 392948F8  addi r9, r9, 0x48f8
	ctx.r[9].s64 = ctx.r[9].s64 + 18680;
	// 82509F00: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82509F04: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 82509F08: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 82509F0C: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82509F10: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x82509F14; continue 'dispatch;
            }
            0x82509F14 => {
    //   block [0x82509F14..0x82509F64)
	// 82509F14: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82509F18: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82509F1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82509F20: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82509F24: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82509F28: 80840018  lwz r4, 0x18(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82509F2C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82509F30: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82509F34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82509F38: 4E800421  bctrl
	ctx.lr = 0x82509F3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82509F3C: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82509F40: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82509F44: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82509F48: 895E0000  lbz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82509F4C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82509F50: 419A0014  beq cr6, 0x82509f64
	if ctx.cr[6].eq {
	pc = 0x82509F64; continue 'dispatch;
	}
	// 82509F54: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82509F58: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82509F5C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82509F60: 7D4BF92E  stwx r10, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[10].u32) };
            }
            0x82509F64 => {
    //   block [0x82509F64..0x82509F94)
	// 82509F64: 7D5DE02E  lwzx r10, r29, r28
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82509F68: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82509F6C: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82509F70: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82509F74: 40980020  bge cr6, 0x82509f94
	if !ctx.cr[6].lt {
	pc = 0x82509F94; continue 'dispatch;
	}
	// 82509F78: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82509F7C: 392974DC  addi r9, r9, 0x74dc
	ctx.r[9].s64 = ctx.r[9].s64 + 29916;
	// 82509F80: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82509F84: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 82509F88: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 82509F8C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82509F90: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x82509F94; continue 'dispatch;
            }
            0x82509F94 => {
    //   block [0x82509F94..0x82509FA0)
	// 82509F94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82509F98: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82509F9C: 4802B16C  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82509FA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82509FA0 size=196
    let mut pc: u32 = 0x82509FA0;
    'dispatch: loop {
        match pc {
            0x82509FA0 => {
    //   block [0x82509FA0..0x82509FEC)
	// 82509FA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82509FA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82509FA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82509FAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82509FB0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82509FB4: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82509FB8: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 82509FBC: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82509FC0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82509FC4: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82509FC8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82509FCC: 40980020  bge cr6, 0x82509fec
	if !ctx.cr[6].lt {
	pc = 0x82509FEC; continue 'dispatch;
	}
	// 82509FD0: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 82509FD4: 392948F8  addi r9, r9, 0x48f8
	ctx.r[9].s64 = ctx.r[9].s64 + 18680;
	// 82509FD8: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82509FDC: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 82509FE0: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 82509FE4: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82509FE8: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x82509FEC; continue 'dispatch;
            }
            0x82509FEC => {
    //   block [0x82509FEC..0x8250A04C)
	// 82509FEC: 81650008  lwz r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 82509FF0: 80630018  lwz r3, 0x18(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82509FF4: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 82509FF8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82509FFC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8250A000: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8250A004: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 8250A008: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8250A00C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250A010: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8250A014: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250A018: 4E800421  bctrl
	ctx.lr = 0x8250A01C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250A01C: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8250A020: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250A024: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8250A028: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8250A02C: 40980020  bge cr6, 0x8250a04c
	if !ctx.cr[6].lt {
	pc = 0x8250A04C; continue 'dispatch;
	}
	// 8250A030: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 8250A034: 392974DC  addi r9, r9, 0x74dc
	ctx.r[9].s64 = ctx.r[9].s64 + 29916;
	// 8250A038: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8250A03C: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 8250A040: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 8250A044: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8250A048: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
            }
            0x8250A04C => {
    //   block [0x8250A04C..0x8250A064)
	// 8250A04C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8250A050: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8250A054: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8250A058: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8250A05C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8250A060: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250A068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8250A068 size=96
    let mut pc: u32 = 0x8250A068;
    'dispatch: loop {
        match pc {
            0x8250A068 => {
    //   block [0x8250A068..0x8250A0C8)
	// 8250A068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250A06C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8250A070: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8250A074: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250A078: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8250A07C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8250A080: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8250A084: 388B4904  addi r4, r11, 0x4904
	ctx.r[4].s64 = ctx.r[11].s64 + 18692;
	// 8250A088: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8250A08C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250A090: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250A094: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250A098: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250A09C: 4E800421  bctrl
	ctx.lr = 0x8250A0A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250A0A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250A0A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250A0A8: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250A0AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250A0B0: 4E800421  bctrl
	ctx.lr = 0x8250A0B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250A0B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8250A0B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8250A0BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8250A0C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8250A0C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250A0C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8250A0C8 size=28
    let mut pc: u32 = 0x8250A0C8;
    'dispatch: loop {
        match pc {
            0x8250A0C8 => {
    //   block [0x8250A0C8..0x8250A0E4)
	// 8250A0C8: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8250A0CC: 546A043E  clrlwi r10, r3, 0x10
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 8250A0D0: 7D645A14  add r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 8250A0D4: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 8250A0D8: 7D4B5C30  srw r11, r10, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[10].u32) >> ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 8250A0DC: 556306FE  clrlwi r3, r11, 0x1b
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8250A0E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250A0E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8250A0E8 size=20
    let mut pc: u32 = 0x8250A0E8;
    'dispatch: loop {
        match pc {
            0x8250A0E8 => {
    //   block [0x8250A0E8..0x8250A0FC)
	// 8250A0E8: 89630017  lbz r11, 0x17(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(23 as u32) ) } as u64;
	// 8250A0EC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8250A0F0: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8250A0F4: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8250A0F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250A100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8250A100 size=16
    let mut pc: u32 = 0x8250A100;
    'dispatch: loop {
        match pc {
            0x8250A100 => {
    //   block [0x8250A100..0x8250A110)
	// 8250A100: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250A110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8250A110 size=72
    let mut pc: u32 = 0x8250A110;
    'dispatch: loop {
        match pc {
            0x8250A110 => {
    //   block [0x8250A110..0x8250A158)
	// 8250A110: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8250A114: 39630030  addi r11, r3, 0x30
	ctx.r[11].s64 = ctx.r[3].s64 + 48;
	// 8250A118: 3921FFF0  addi r9, r1, -0x10
	ctx.r[9].s64 = ctx.r[1].s64 + -16;
	// 8250A11C: C00A2128  lfs f0, 0x2128(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8488 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8250A120: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250A158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8250A158 size=108
    let mut pc: u32 = 0x8250A158;
    'dispatch: loop {
        match pc {
            0x8250A158 => {
    //   block [0x8250A158..0x8250A1C4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250A1C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8250A1C8 size=224
    let mut pc: u32 = 0x8250A1C8;
    'dispatch: loop {
        match pc {
            0x8250A1C8 => {
    //   block [0x8250A1C8..0x8250A2A8)
	// 8250A1C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250A1CC: 4802AEF1  bl 0x825350bc
	ctx.lr = 0x8250A1D0;
	sub_82535080(ctx, base);
	// 8250A1D0: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250A2A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8250A2A8 size=180
    let mut pc: u32 = 0x8250A2A8;
    'dispatch: loop {
        match pc {
            0x8250A2A8 => {
    //   block [0x8250A2A8..0x8250A35C)
	// 8250A2A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8250A2AC: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 8250A2B0: 390B0020  addi r8, r11, 0x20
	ctx.r[8].s64 = ctx.r[11].s64 + 32;
	// 8250A2B4: 38EB0030  addi r7, r11, 0x30
	ctx.r[7].s64 = ctx.r[11].s64 + 48;
	// 8250A2B8: 39430010  addi r10, r3, 0x10
	ctx.r[10].s64 = ctx.r[3].s64 + 16;
	// 8250A2BC: 38CB0040  addi r6, r11, 0x40
	ctx.r[6].s64 = ctx.r[11].s64 + 64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250A360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8250A360 size=208
    let mut pc: u32 = 0x8250A360;
    'dispatch: loop {
        match pc {
            0x8250A360 => {
    //   block [0x8250A360..0x8250A430)
	// 8250A360: 39630020  addi r11, r3, 0x20
	ctx.r[11].s64 = ctx.r[3].s64 + 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250A430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8250A430 size=124
    let mut pc: u32 = 0x8250A430;
    'dispatch: loop {
        match pc {
            0x8250A430 => {
    //   block [0x8250A430..0x8250A4AC)
	// 8250A430: 3965FFFF  addi r11, r5, -1
	ctx.r[11].s64 = ctx.r[5].s64 + -1;
	// 8250A434: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8250A438: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 8250A43C: 3D408282  lis r10, -0x7d7e
	ctx.r[10].s64 = -2105409536;
	// 8250A440: 38E30050  addi r7, r3, 0x50
	ctx.r[7].s64 = ctx.r[3].s64 + 80;
	// 8250A444: 392AD3D0  addi r9, r10, -0x2c30
	ctx.r[9].s64 = ctx.r[10].s64 + -11312;
	// 8250A448: 3D408282  lis r10, -0x7d7e
	ctx.r[10].s64 = -2105409536;
	// 8250A44C: 390AD3FC  addi r8, r10, -0x2c04
	ctx.r[8].s64 = ctx.r[10].s64 + -11268;
	// 8250A450: A1440000  lhz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250A454: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8250A458: 554A103E  rotlwi r10, r10, 2
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 8250A45C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8250A460: 7D4A402E  lwzx r10, r10, r8
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 8250A464: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 8250A468: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250A4B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8250A4B0 size=1296
    let mut pc: u32 = 0x8250A4B0;
    'dispatch: loop {
        match pc {
            0x8250A4B0 => {
    //   block [0x8250A4B0..0x8250A9C0)
	// 8250A4B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250A4B4: 4802ABF5  bl 0x825350a8
	ctx.lr = 0x8250A4B8;
	sub_82535080(ctx, base);
	// 8250A4B8: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 8250A4BC: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250A9C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8250A9C0 size=724
    let mut pc: u32 = 0x8250A9C0;
    'dispatch: loop {
        match pc {
            0x8250A9C0 => {
    //   block [0x8250A9C0..0x8250AA04)
	// 8250A9C0: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 8250A9C4: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 8250A9C8: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250A9CC: 39600014  li r11, 0x14
	ctx.r[11].s64 = 20;
	// 8250A9D0: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8250A9D4: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250A9D8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250A9DC: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8250A9E0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8250A9E4: 40980020  bge cr6, 0x8250aa04
	if !ctx.cr[6].lt {
	pc = 0x8250AA04; continue 'dispatch;
	}
	// 8250A9E8: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 8250A9EC: 39294914  addi r9, r9, 0x4914
	ctx.r[9].s64 = ctx.r[9].s64 + 18708;
	// 8250A9F0: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8250A9F4: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 8250A9F8: 38EA000C  addi r7, r10, 0xc
	ctx.r[7].s64 = ctx.r[10].s64 + 12;
	// 8250A9FC: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8250AA00: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	pc = 0x8250AA04; continue 'dispatch;
            }
            0x8250AA04 => {
    //   block [0x8250AA04..0x8250AC94)
	// 8250AA04: 39640020  addi r11, r4, 0x20
	ctx.r[11].s64 = ctx.r[4].s64 + 32;
	// 8250AA08: 39440030  addi r10, r4, 0x30
	ctx.r[10].s64 = ctx.r[4].s64 + 48;
	// 8250AA0C: 39240040  addi r9, r4, 0x40
	ctx.r[9].s64 = ctx.r[4].s64 + 64;
	// 8250AA10: 38E1FFD0  addi r7, r1, -0x30
	ctx.r[7].s64 = ctx.r[1].s64 + -48;
	// 8250AA14: 3881FFD4  addi r4, r1, -0x2c
	ctx.r[4].s64 = ctx.r[1].s64 + -44;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250AC98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8250AC98 size=96
    let mut pc: u32 = 0x8250AC98;
    'dispatch: loop {
        match pc {
            0x8250AC98 => {
    //   block [0x8250AC98..0x8250ACF8)
	// 8250AC98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250AC9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8250ACA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8250ACA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250ACA8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8250ACAC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8250ACB0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8250ACB4: 388B4924  addi r4, r11, 0x4924
	ctx.r[4].s64 = ctx.r[11].s64 + 18724;
	// 8250ACB8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8250ACBC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250ACC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250ACC4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250ACC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250ACCC: 4E800421  bctrl
	ctx.lr = 0x8250ACD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250ACD0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250ACD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250ACD8: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250ACDC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250ACE0: 4E800421  bctrl
	ctx.lr = 0x8250ACE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250ACE4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8250ACE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8250ACEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8250ACF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8250ACF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250ACF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8250ACF8 size=172
    let mut pc: u32 = 0x8250ACF8;
    'dispatch: loop {
        match pc {
            0x8250ACF8 => {
    //   block [0x8250ACF8..0x8250AD8C)
	// 8250ACF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250ACFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8250AD00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8250AD04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8250AD08: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250AD0C: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 8250AD10: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250AD14: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 8250AD18: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8250AD1C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 8250AD20: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8250AD24: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 8250AD28: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8250AD2C: C01F0004  lfs f0, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8250AD30: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 8250AD34: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8250AD38: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 8250AD3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8250AD40: 914100A0  stw r10, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 8250AD44: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 8250AD48: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 8250AD4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250AD50: 4E800421  bctrl
	ctx.lr = 0x8250AD54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250AD54: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8250AD58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8250AD5C: 419A0030  beq cr6, 0x8250ad8c
	if ctx.cr[6].eq {
	pc = 0x8250AD8C; continue 'dispatch;
	}
	// 8250AD60: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8250AD64: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250AD68: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8250AD6C: 480A0E6D  bl 0x825abbd8
	ctx.lr = 0x8250AD70;
	sub_825ABBD8(ctx, base);
	// 8250AD70: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250AD74: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8250AD78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8250AD7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250AD80: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250AD84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250AD88: 4E800421  bctrl
	ctx.lr = 0x8250AD8C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8250AD8C => {
    //   block [0x8250AD8C..0x8250ADA4)
	// 8250AD8C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 8250AD90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8250AD94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8250AD98: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8250AD9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8250ADA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250ADA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8250ADA8 size=360
    let mut pc: u32 = 0x8250ADA8;
    'dispatch: loop {
        match pc {
            0x8250ADA8 => {
    //   block [0x8250ADA8..0x8250AF10)
	// 8250ADA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250ADAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8250ADB0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250ADB4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8250ADB8: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 8250ADBC: 392B0010  addi r9, r11, 0x10
	ctx.r[9].s64 = ctx.r[11].s64 + 16;
	// 8250ADC0: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 8250ADC4: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 8250ADC8: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250AF10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8250AF10 size=104
    let mut pc: u32 = 0x8250AF10;
    'dispatch: loop {
        match pc {
            0x8250AF10 => {
    //   block [0x8250AF10..0x8250AF78)
	// 8250AF10: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250AF14: 7CAA2B78  mr r10, r5
	ctx.r[10].u64 = ctx.r[5].u64;
	// 8250AF18: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250AF1C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 8250AF20: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8250AF24: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 8250AF28: 39030010  addi r8, r3, 0x10
	ctx.r[8].s64 = ctx.r[3].s64 + 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250AF78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8250AF78 size=176
    let mut pc: u32 = 0x8250AF78;
    'dispatch: loop {
        match pc {
            0x8250AF78 => {
    //   block [0x8250AF78..0x8250B028)
	// 8250AF78: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 8250AF7C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8250AF80: 3901FFF0  addi r8, r1, -0x10
	ctx.r[8].s64 = ctx.r[1].s64 + -16;
	// 8250AF84: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 8250AF88: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8250AF8C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8250AF90: C00ABFFC  lfs f0, -0x4004(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8250AF94: 392931C4  addi r9, r9, 0x31c4
	ctx.r[9].s64 = ctx.r[9].s64 + 12740;
	// 8250AF98: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 8250AF9C: 3BE0001B  li r31, 0x1b
	ctx.r[31].s64 = 27;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250B028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8250B028 size=108
    let mut pc: u32 = 0x8250B028;
    'dispatch: loop {
        match pc {
            0x8250B028 => {
    //   block [0x8250B028..0x8250B094)
	// 8250B028: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8250B02C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8250B030: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8250B034: 3900001B  li r8, 0x1b
	ctx.r[8].s64 = 27;
	// 8250B038: 396B31C4  addi r11, r11, 0x31c4
	ctx.r[11].s64 = ctx.r[11].s64 + 12740;
	// 8250B03C: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 8250B040: B1430006  sth r10, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 8250B044: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 8250B048: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8250B04C: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 8250B050: 9103000C  stw r8, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 8250B054: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 8250B058: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250B098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8250B098 size=24
    let mut pc: u32 = 0x8250B098;
    'dispatch: loop {
        match pc {
            0x8250B098 => {
    //   block [0x8250B098..0x8250B0B0)
	// 8250B098: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8250B09C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 8250B0A0: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 8250B0A4: 38AB0020  addi r5, r11, 0x20
	ctx.r[5].s64 = ctx.r[11].s64 + 32;
	// 8250B0A8: 388B0030  addi r4, r11, 0x30
	ctx.r[4].s64 = ctx.r[11].s64 + 48;
	// 8250B0AC: 4BFF18A4  b 0x824fc950
	sub_824FC950(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250B0B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8250B0B0 size=408
    let mut pc: u32 = 0x8250B0B0;
    'dispatch: loop {
        match pc {
            0x8250B0B0 => {
    //   block [0x8250B0B0..0x8250B0F0)
	// 8250B0B0: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 8250B0B4: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250B0B8: 39600014  li r11, 0x14
	ctx.r[11].s64 = 20;
	// 8250B0BC: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8250B0C0: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250B0C4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250B0C8: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8250B0CC: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 8250B0D0: 40980020  bge cr6, 0x8250b0f0
	if !ctx.cr[6].lt {
	pc = 0x8250B0F0; continue 'dispatch;
	}
	// 8250B0D4: 3D008206  lis r8, -0x7dfa
	ctx.r[8].s64 = -2113536000;
	// 8250B0D8: 39084930  addi r8, r8, 0x4930
	ctx.r[8].s64 = ctx.r[8].s64 + 18736;
	// 8250B0DC: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8250B0E0: 7D0C42E6  mftb r8, 0x10c
	ctx.r[8].u64 = crate::rt::rdtsc_u64();
	// 8250B0E4: 38EA000C  addi r7, r10, 0xc
	ctx.r[7].s64 = ctx.r[10].s64 + 12;
	// 8250B0E8: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 8250B0EC: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	pc = 0x8250B0F0; continue 'dispatch;
            }
            0x8250B0F0 => {
    //   block [0x8250B0F0..0x8250B248)
	// 8250B0F0: 39440010  addi r10, r4, 0x10
	ctx.r[10].s64 = ctx.r[4].s64 + 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250B248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8250B248 size=20
    let mut pc: u32 = 0x8250B248;
    'dispatch: loop {
        match pc {
            0x8250B248 => {
    //   block [0x8250B248..0x8250B25C)
	// 8250B248: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8250B24C: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 8250B250: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 8250B254: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8250B258: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250B260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8250B260 size=96
    let mut pc: u32 = 0x8250B260;
    'dispatch: loop {
        match pc {
            0x8250B260 => {
    //   block [0x8250B260..0x8250B2C0)
	// 8250B260: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250B264: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8250B268: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8250B26C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250B270: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8250B274: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8250B278: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8250B27C: 388B493C  addi r4, r11, 0x493c
	ctx.r[4].s64 = ctx.r[11].s64 + 18748;
	// 8250B280: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8250B284: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250B288: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250B28C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250B290: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250B294: 4E800421  bctrl
	ctx.lr = 0x8250B298;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250B298: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250B29C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250B2A0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250B2A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250B2A8: 4E800421  bctrl
	ctx.lr = 0x8250B2AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250B2AC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8250B2B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8250B2B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8250B2B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8250B2BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250B2C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8250B2C0 size=64
    let mut pc: u32 = 0x8250B2C0;
    'dispatch: loop {
        match pc {
            0x8250B2C0 => {
    //   block [0x8250B2C0..0x8250B300)
	// 8250B2C0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8250B2C4: 9083000C  stw r4, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 8250B2C8: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 8250B2CC: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 8250B2D0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8250B2D4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8250B2D8: 396B2A44  addi r11, r11, 0x2a44
	ctx.r[11].s64 = ctx.r[11].s64 + 10820;
	// 8250B2DC: 394A3260  addi r10, r10, 0x3260
	ctx.r[10].s64 = ctx.r[10].s64 + 12896;
	// 8250B2E0: 3929323C  addi r9, r9, 0x323c
	ctx.r[9].s64 = ctx.r[9].s64 + 12860;
	// 8250B2E4: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 8250B2E8: B0E30006  sth r7, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[7].u16 ) };
	// 8250B2EC: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 8250B2F0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8250B2F4: 91230010  stw r9, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 8250B2F8: 99030014  stb r8, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[8].u8 ) };
	// 8250B2FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250B300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8250B300 size=560
    let mut pc: u32 = 0x8250B300;
    'dispatch: loop {
        match pc {
            0x8250B300 => {
    //   block [0x8250B300..0x8250B354)
	// 8250B300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250B304: 48029D9D  bl 0x825350a0
	ctx.lr = 0x8250B308;
	sub_82535080(ctx, base);
	// 8250B308: 9421FD40  stwu r1, -0x2c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-704 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250B30C: 830D0000  lwz r24, 0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250B310: 3B200014  li r25, 0x14
	ctx.r[25].s64 = 20;
	// 8250B314: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 8250B318: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 8250B31C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8250B320: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 8250B324: 7D79C02E  lwzx r11, r25, r24
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 8250B328: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250B32C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8250B330: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8250B334: 40980020  bge cr6, 0x8250b354
	if !ctx.cr[6].lt {
	pc = 0x8250B354; continue 'dispatch;
	}
	// 8250B338: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 8250B33C: 39294948  addi r9, r9, 0x4948
	ctx.r[9].s64 = ctx.r[9].s64 + 18760;
	// 8250B340: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8250B344: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 8250B348: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 8250B34C: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8250B350: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x8250B354; continue 'dispatch;
            }
            0x8250B354 => {
    //   block [0x8250B354..0x8250B398)
	// 8250B354: 817C0040  lwz r11, 0x40(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) } as u64;
	// 8250B358: 3AE0FFFF  li r23, -1
	ctx.r[23].s64 = -1;
	// 8250B35C: 3BDB0010  addi r30, r27, 0x10
	ctx.r[30].s64 = ctx.r[27].s64 + 16;
	// 8250B360: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8250B364: 7EFABB78  mr r26, r23
	ctx.r[26].u64 = ctx.r[23].u64;
	// 8250B368: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8250B36C: 917C0040  stw r11, 0x40(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 8250B370: 817D0024  lwz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 8250B374: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8250B378: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 8250B37C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250B380: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250B384: 409A0088  bne cr6, 0x8250b40c
	if !ctx.cr[6].eq {
	pc = 0x8250B40C; continue 'dispatch;
	}
	// 8250B388: 4E800421  bctrl
	ctx.lr = 0x8250B38C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250B38C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8250B390: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 8250B394: 419A012C  beq cr6, 0x8250b4c0
	if ctx.cr[6].eq {
	pc = 0x8250B4C0; continue 'dispatch;
	}
            }
            0x8250B398 => {
    //   block [0x8250B398..0x8250B3E4)
	// 8250B398: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250B39C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8250B3A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8250B3A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8250B3A8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8250B3AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250B3B0: 4E800421  bctrl
	ctx.lr = 0x8250B3B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250B3B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8250B3B8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 8250B3BC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8250B3C0: 38610051  addi r3, r1, 0x51
	ctx.r[3].s64 = ctx.r[1].s64 + 81;
	// 8250B3C4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250B3C8: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 8250B3CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250B3D0: 4E800421  bctrl
	ctx.lr = 0x8250B3D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250B3D4: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 8250B3D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8250B3DC: 419A0008  beq cr6, 0x8250b3e4
	if ctx.cr[6].eq {
	pc = 0x8250B3E4; continue 'dispatch;
	}
	// 8250B3E0: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
            }
            0x8250B3E4 => {
    //   block [0x8250B3E4..0x8250B40C)
	// 8250B3E4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250B3E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8250B3EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8250B3F0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8250B3F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250B3F8: 4E800421  bctrl
	ctx.lr = 0x8250B3FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250B3FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8250B400: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 8250B404: 409AFF94  bne cr6, 0x8250b398
	if !ctx.cr[6].eq {
	pc = 0x8250B398; continue 'dispatch;
	}
	// 8250B408: 480000B8  b 0x8250b4c0
	pc = 0x8250B4C0; continue 'dispatch;
            }
            0x8250B40C => {
    //   block [0x8250B40C..0x8250B41C)
	// 8250B40C: 4E800421  bctrl
	ctx.lr = 0x8250B410;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250B410: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8250B414: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 8250B418: 419A00A8  beq cr6, 0x8250b4c0
	if ctx.cr[6].eq {
	pc = 0x8250B4C0; continue 'dispatch;
	}
            }
            0x8250B41C => {
    //   block [0x8250B41C..0x8250B49C)
	// 8250B41C: 809D0024  lwz r4, 0x24(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 8250B420: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 8250B424: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8250B428: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 8250B42C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8250B430: 38610052  addi r3, r1, 0x52
	ctx.r[3].s64 = ctx.r[1].s64 + 82;
	// 8250B434: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250B438: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250B43C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250B440: 4E800421  bctrl
	ctx.lr = 0x8250B444;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250B444: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250B448: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8250B44C: 419A0050  beq cr6, 0x8250b49c
	if ctx.cr[6].eq {
	pc = 0x8250B49C; continue 'dispatch;
	}
	// 8250B450: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250B454: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8250B458: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8250B45C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8250B460: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8250B464: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250B468: 4E800421  bctrl
	ctx.lr = 0x8250B46C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250B46C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8250B470: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 8250B474: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8250B478: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8250B47C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250B480: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 8250B484: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250B488: 4E800421  bctrl
	ctx.lr = 0x8250B48C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250B48C: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8250B490: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8250B494: 419A0008  beq cr6, 0x8250b49c
	if ctx.cr[6].eq {
	pc = 0x8250B49C; continue 'dispatch;
	}
	// 8250B498: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
            }
            0x8250B49C => {
    //   block [0x8250B49C..0x8250B4C0)
	// 8250B49C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250B4A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8250B4A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8250B4A8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8250B4AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250B4B0: 4E800421  bctrl
	ctx.lr = 0x8250B4B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250B4B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8250B4B8: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 8250B4BC: 409AFF60  bne cr6, 0x8250b41c
	if !ctx.cr[6].eq {
	pc = 0x8250B41C; continue 'dispatch;
	}
            }
            0x8250B4C0 => {
    //   block [0x8250B4C0..0x8250B4E0)
	// 8250B4C0: 817C0040  lwz r11, 0x40(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) } as u64;
	// 8250B4C4: 2F1AFFFF  cmpwi cr6, r26, -1
	ctx.cr[6].compare_i32(ctx.r[26].s32, -1, &mut ctx.xer);
	// 8250B4C8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8250B4CC: 917C0040  stw r11, 0x40(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 8250B4D0: 419A0010  beq cr6, 0x8250b4e0
	if ctx.cr[6].eq {
	pc = 0x8250B4E0; continue 'dispatch;
	}
	// 8250B4D4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8250B4D8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8250B4DC: 7F4BE12E  stwx r26, r11, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32), ctx.r[26].u32) };
	pc = 0x8250B4E0; continue 'dispatch;
            }
            0x8250B4E0 => {
    //   block [0x8250B4E0..0x8250B510)
	// 8250B4E0: 7D59C02E  lwzx r10, r25, r24
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 8250B4E4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250B4E8: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 8250B4EC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8250B4F0: 40980020  bge cr6, 0x8250b510
	if !ctx.cr[6].lt {
	pc = 0x8250B510; continue 'dispatch;
	}
	// 8250B4F4: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 8250B4F8: 392974DC  addi r9, r9, 0x74dc
	ctx.r[9].s64 = ctx.r[9].s64 + 29916;
	// 8250B4FC: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8250B500: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 8250B504: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 8250B508: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8250B50C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x8250B510; continue 'dispatch;
            }
            0x8250B510 => {
    //   block [0x8250B510..0x8250B530)
	// 8250B510: 7D7AB850  subf r11, r26, r23
	ctx.r[11].s64 = ctx.r[23].s64 - ctx.r[26].s64;
	// 8250B514: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 8250B518: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8250B51C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8250B520: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 8250B524: 99760000  stb r11, 0(r22)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[22].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 8250B528: 382102C0  addi r1, r1, 0x2c0
	ctx.r[1].s64 = ctx.r[1].s64 + 704;
	// 8250B52C: 48029BC4  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250B530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8250B530 size=368
    let mut pc: u32 = 0x8250B530;
    'dispatch: loop {
        match pc {
            0x8250B530 => {
    //   block [0x8250B530..0x8250B588)
	// 8250B530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250B534: 48029B79  bl 0x825350ac
	ctx.lr = 0x8250B538;
	sub_82535080(ctx, base);
	// 8250B538: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 8250B53C: 9421FD40  stwu r1, -0x2c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-704 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250B540: 832D0000  lwz r25, 0(r13)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250B544: 3B400014  li r26, 0x14
	ctx.r[26].s64 = 20;
	// 8250B548: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 8250B54C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8250B550: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 8250B554: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 8250B558: 7D5AC82E  lwzx r10, r26, r25
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 8250B55C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250B560: 810A000C  lwz r8, 0xc(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 8250B564: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 8250B568: 40980020  bge cr6, 0x8250b588
	if !ctx.cr[6].lt {
	pc = 0x8250B588; continue 'dispatch;
	}
	// 8250B56C: 3D008206  lis r8, -0x7dfa
	ctx.r[8].s64 = -2113536000;
	// 8250B570: 39084958  addi r8, r8, 0x4958
	ctx.r[8].s64 = ctx.r[8].s64 + 18776;
	// 8250B574: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8250B578: 7D0C42E6  mftb r8, 0x10c
	ctx.r[8].u64 = crate::rt::rdtsc_u64();
	// 8250B57C: 38EB000C  addi r7, r11, 0xc
	ctx.r[7].s64 = ctx.r[11].s64 + 12;
	// 8250B580: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 8250B584: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	pc = 0x8250B588; continue 'dispatch;
            }
            0x8250B588 => {
    //   block [0x8250B588..0x8250B6A0)
	// 8250B588: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8250B58C: 3B9D0010  addi r28, r29, 0x10
	ctx.r[28].s64 = ctx.r[29].s64 + 16;
	// 8250B590: 3BC90010  addi r30, r9, 0x10
	ctx.r[30].s64 = ctx.r[9].s64 + 16;
	// 8250B594: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8250B598: C00B8CB4  lfs f0, -0x734c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8250B59C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8250B5A0: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250B6A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8250B6A0 size=276
    let mut pc: u32 = 0x8250B6A0;
    'dispatch: loop {
        match pc {
            0x8250B6A0 => {
    //   block [0x8250B6A0..0x8250B6EC)
	// 8250B6A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250B6A4: 48029A11  bl 0x825350b4
	ctx.lr = 0x8250B6A8;
	sub_82535080(ctx, base);
	// 8250B6A8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8250B6AC: 9421FD70  stwu r1, -0x290(r1)
	ea = ctx.r[1].u32.wrapping_add(-656 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250B6B0: 836D0000  lwz r27, 0(r13)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250B6B4: 3B800014  li r28, 0x14
	ctx.r[28].s64 = 20;
	// 8250B6B8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8250B6BC: 7D5CD82E  lwzx r10, r28, r27
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 8250B6C0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250B6C4: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 8250B6C8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8250B6CC: 40980020  bge cr6, 0x8250b6ec
	if !ctx.cr[6].lt {
	pc = 0x8250B6EC; continue 'dispatch;
	}
	// 8250B6D0: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 8250B6D4: 39294978  addi r9, r9, 0x4978
	ctx.r[9].s64 = ctx.r[9].s64 + 18808;
	// 8250B6D8: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8250B6DC: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 8250B6E0: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 8250B6E4: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8250B6E8: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x8250B6EC; continue 'dispatch;
            }
            0x8250B6EC => {
    //   block [0x8250B6EC..0x8250B718)
	// 8250B6EC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8250B6F0: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 8250B6F4: 3BC30010  addi r30, r3, 0x10
	ctx.r[30].s64 = ctx.r[3].s64 + 16;
	// 8250B6F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8250B6FC: C3EB0DA0  lfs f31, 0xda0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3488 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8250B700: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250B704: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250B708: 4E800421  bctrl
	ctx.lr = 0x8250B70C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250B70C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8250B710: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 8250B714: 419A0060  beq cr6, 0x8250b774
	if ctx.cr[6].eq {
	pc = 0x8250B774; continue 'dispatch;
	}
            }
            0x8250B718 => {
    //   block [0x8250B718..0x8250B774)
	// 8250B718: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250B71C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8250B720: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8250B724: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8250B728: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8250B72C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250B730: 4E800421  bctrl
	ctx.lr = 0x8250B734;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250B734: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250B738: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8250B73C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8250B740: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250B744: 4E800421  bctrl
	ctx.lr = 0x8250B748;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250B748: EC1F0828  fsubs f0, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 8250B74C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250B750: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8250B754: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8250B758: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8250B75C: FFE00FEE  fsel f31, f0, f31, f1
	ctx.f[31].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[31].f64 } else { ctx.f[1].f64 };
	// 8250B760: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250B764: 4E800421  bctrl
	ctx.lr = 0x8250B768;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250B768: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8250B76C: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 8250B770: 409AFFA8  bne cr6, 0x8250b718
	if !ctx.cr[6].eq {
	pc = 0x8250B718; continue 'dispatch;
	}
            }
            0x8250B774 => {
    //   block [0x8250B774..0x8250B7A4)
	// 8250B774: 7D5CD82E  lwzx r10, r28, r27
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 8250B778: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250B77C: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 8250B780: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8250B784: 40980020  bge cr6, 0x8250b7a4
	if !ctx.cr[6].lt {
	pc = 0x8250B7A4; continue 'dispatch;
	}
	// 8250B788: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 8250B78C: 392974DC  addi r9, r9, 0x74dc
	ctx.r[9].s64 = ctx.r[9].s64 + 29916;
	// 8250B790: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8250B794: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 8250B798: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 8250B79C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8250B7A0: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x8250B7A4; continue 'dispatch;
            }
            0x8250B7A4 => {
    //   block [0x8250B7A4..0x8250B7B4)
	// 8250B7A4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8250B7A8: 38210290  addi r1, r1, 0x290
	ctx.r[1].s64 = ctx.r[1].s64 + 656;
	// 8250B7AC: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 8250B7B0: 48029954  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250B7B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8250B7B8 size=484
    let mut pc: u32 = 0x8250B7B8;
    'dispatch: loop {
        match pc {
            0x8250B7B8 => {
    //   block [0x8250B7B8..0x8250B80C)
	// 8250B7B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250B7BC: 480298ED  bl 0x825350a8
	ctx.lr = 0x8250B7C0;
	sub_82535080(ctx, base);
	// 8250B7C0: 9421FD30  stwu r1, -0x2d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-720 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250B7C4: 830D0000  lwz r24, 0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250B7C8: 3B200014  li r25, 0x14
	ctx.r[25].s64 = 20;
	// 8250B7CC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8250B7D0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8250B7D4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 8250B7D8: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 8250B7DC: 7D79C02E  lwzx r11, r25, r24
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 8250B7E0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250B7E4: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8250B7E8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8250B7EC: 40980020  bge cr6, 0x8250b80c
	if !ctx.cr[6].lt {
	pc = 0x8250B80C; continue 'dispatch;
	}
	// 8250B7F0: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 8250B7F4: 39294948  addi r9, r9, 0x4948
	ctx.r[9].s64 = ctx.r[9].s64 + 18760;
	// 8250B7F8: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8250B7FC: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 8250B800: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 8250B804: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8250B808: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x8250B80C; continue 'dispatch;
            }
            0x8250B80C => {
    //   block [0x8250B80C..0x8250B83C)
	// 8250B80C: 817D0024  lwz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 8250B810: 3BDB0010  addi r30, r27, 0x10
	ctx.r[30].s64 = ctx.r[27].s64 + 16;
	// 8250B814: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8250B818: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 8250B81C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8250B820: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250B824: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250B828: 409A0088  bne cr6, 0x8250b8b0
	if !ctx.cr[6].eq {
	pc = 0x8250B8B0; continue 'dispatch;
	}
	// 8250B82C: 4E800421  bctrl
	ctx.lr = 0x8250B830;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250B830: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8250B834: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 8250B838: 419A012C  beq cr6, 0x8250b964
	if ctx.cr[6].eq {
	pc = 0x8250B964; continue 'dispatch;
	}
            }
            0x8250B83C => {
    //   block [0x8250B83C..0x8250B8B0)
	// 8250B83C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250B840: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 8250B844: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8250B848: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8250B84C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8250B850: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250B854: 4E800421  bctrl
	ctx.lr = 0x8250B858;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250B858: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250B85C: 9381006C  stw r28, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 8250B860: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 8250B864: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 8250B868: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8250B86C: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 8250B870: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8250B874: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 8250B878: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250B87C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8250B880: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250B884: 4E800421  bctrl
	ctx.lr = 0x8250B888;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250B888: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250B88C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8250B890: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8250B894: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8250B898: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250B89C: 4E800421  bctrl
	ctx.lr = 0x8250B8A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250B8A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8250B8A4: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 8250B8A8: 409AFF94  bne cr6, 0x8250b83c
	if !ctx.cr[6].eq {
	pc = 0x8250B83C; continue 'dispatch;
	}
	// 8250B8AC: 480000B8  b 0x8250b964
	pc = 0x8250B964; continue 'dispatch;
            }
            0x8250B8B0 => {
    //   block [0x8250B8B0..0x8250B8C0)
	// 8250B8B0: 4E800421  bctrl
	ctx.lr = 0x8250B8B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250B8B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8250B8B8: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 8250B8BC: 419A00A8  beq cr6, 0x8250b964
	if ctx.cr[6].eq {
	pc = 0x8250B964; continue 'dispatch;
	}
            }
            0x8250B8C0 => {
    //   block [0x8250B8C0..0x8250B940)
	// 8250B8C0: 809D0024  lwz r4, 0x24(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 8250B8C4: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 8250B8C8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8250B8CC: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 8250B8D0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8250B8D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8250B8D8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250B8DC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250B8E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250B8E4: 4E800421  bctrl
	ctx.lr = 0x8250B8E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250B8E8: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250B8EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8250B8F0: 419A0050  beq cr6, 0x8250b940
	if ctx.cr[6].eq {
	pc = 0x8250B940; continue 'dispatch;
	}
	// 8250B8F4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250B8F8: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 8250B8FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8250B900: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8250B904: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8250B908: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250B90C: 4E800421  bctrl
	ctx.lr = 0x8250B910;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250B910: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250B914: 9381007C  stw r28, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[28].u32 ) };
	// 8250B918: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 8250B91C: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 8250B920: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 8250B924: 90610070  stw r3, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[3].u32 ) };
	// 8250B928: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8250B92C: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 8250B930: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250B934: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8250B938: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250B93C: 4E800421  bctrl
	ctx.lr = 0x8250B940;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8250B940 => {
    //   block [0x8250B940..0x8250B964)
	// 8250B940: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250B944: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8250B948: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8250B94C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8250B950: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250B954: 4E800421  bctrl
	ctx.lr = 0x8250B958;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250B958: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8250B95C: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 8250B960: 409AFF60  bne cr6, 0x8250b8c0
	if !ctx.cr[6].eq {
	pc = 0x8250B8C0; continue 'dispatch;
	}
            }
            0x8250B964 => {
    //   block [0x8250B964..0x8250B994)
	// 8250B964: 7D59C02E  lwzx r10, r25, r24
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 8250B968: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250B96C: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 8250B970: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8250B974: 40980020  bge cr6, 0x8250b994
	if !ctx.cr[6].lt {
	pc = 0x8250B994; continue 'dispatch;
	}
	// 8250B978: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 8250B97C: 392974DC  addi r9, r9, 0x74dc
	ctx.r[9].s64 = ctx.r[9].s64 + 29916;
	// 8250B980: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8250B984: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 8250B988: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 8250B98C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8250B990: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x8250B994; continue 'dispatch;
            }
            0x8250B994 => {
    //   block [0x8250B994..0x8250B99C)
	// 8250B994: 382102D0  addi r1, r1, 0x2d0
	ctx.r[1].s64 = ctx.r[1].s64 + 720;
	// 8250B998: 48029760  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250B9A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8250B9A0 size=8
    let mut pc: u32 = 0x8250B9A0;
    'dispatch: loop {
        match pc {
            0x8250B9A0 => {
    //   block [0x8250B9A0..0x8250B9A8)
	// 8250B9A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8250B9A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250B9A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8250B9A8 size=20
    let mut pc: u32 = 0x8250B9A8;
    'dispatch: loop {
        match pc {
            0x8250B9A8 => {
    //   block [0x8250B9A8..0x8250B9BC)
	// 8250B9A8: 548B07FE  clrlwi r11, r4, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 8250B9AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8250B9B0: 409A000C  bne cr6, 0x8250b9bc
	if !ctx.cr[6].eq {
		sub_8250B9BC(ctx, base);
		return;
	}
	// 8250B9B4: 60830001  ori r3, r4, 1
	ctx.r[3].u64 = ctx.r[4].u64 | 1;
	// 8250B9B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250B9BC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8250B9BC size=64
    let mut pc: u32 = 0x8250B9BC;
    'dispatch: loop {
        match pc {
            0x8250B9BC => {
    //   block [0x8250B9BC..0x8250B9FC)
	// 8250B9BC: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250B9C0: 548AFC7E  rlwinm r10, r4, 0x1f, 0x11, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 8250B9C4: 548B843E  srwi r11, r4, 0x10
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shr(16);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8250B9C8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8250B9CC: 81090010  lwz r8, 0x10(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 8250B9D0: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 8250B9D4: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 8250B9D8: 409A0024  bne cr6, 0x8250b9fc
	if !ctx.cr[6].eq {
		sub_8250B9FC(ctx, base);
		return;
	}
	// 8250B9DC: 81290014  lwz r9, 0x14(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 8250B9E0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8250B9E4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8250B9E8: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 8250B9EC: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 8250B9F0: 409A000C  bne cr6, 0x8250b9fc
	if !ctx.cr[6].eq {
		sub_8250B9FC(ctx, base);
		return;
	}
	// 8250B9F4: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 8250B9F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250B9FC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8250B9FC size=16
    let mut pc: u32 = 0x8250B9FC;
    'dispatch: loop {
        match pc {
            0x8250B9FC => {
    //   block [0x8250B9FC..0x8250BA0C)
	// 8250B9FC: 556B7820  slwi r11, r11, 0xf
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(15);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8250BA00: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8250BA04: 5563083C  slwi r3, r11, 1
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 8250BA08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250BA10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8250BA10 size=144
    let mut pc: u32 = 0x8250BA10;
    'dispatch: loop {
        match pc {
            0x8250BA10 => {
    //   block [0x8250BA10..0x8250BA78)
	// 8250BA10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250BA14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8250BA18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8250BA1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8250BA20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250BA24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8250BA28: 3BC5FFDC  addi r30, r5, -0x24
	ctx.r[30].s64 = ctx.r[5].s64 + -36;
	// 8250BA2C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8250BA30: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250BA34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250BA38: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250BA3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250BA40: 4E800421  bctrl
	ctx.lr = 0x8250BA44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250BA44: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8250BA48: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8250BA4C: 41980038  blt cr6, 0x8250ba84
	if ctx.cr[6].lt {
	pc = 0x8250BA84; continue 'dispatch;
	}
	// 8250BA50: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 8250BA54: 41990030  bgt cr6, 0x8250ba84
	if ctx.cr[6].gt {
	pc = 0x8250BA84; continue 'dispatch;
	}
	// 8250BA58: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250BA5C: 393F0024  addi r9, r31, 0x24
	ctx.r[9].s64 = ctx.r[31].s64 + 36;
	// 8250BA60: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8250BA64: 409A0014  bne cr6, 0x8250ba78
	if !ctx.cr[6].eq {
	pc = 0x8250BA78; continue 'dispatch;
	}
	// 8250BA68: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8250BA6C: 386B0024  addi r3, r11, 0x24
	ctx.r[3].s64 = ctx.r[11].s64 + 36;
	// 8250BA70: 915F001C  stw r10, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 8250BA74: 48000014  b 0x8250ba88
	pc = 0x8250BA88; continue 'dispatch;
            }
            0x8250BA78 => {
    //   block [0x8250BA78..0x8250BA84)
	// 8250BA78: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 8250BA7C: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 8250BA80: 48000008  b 0x8250ba88
	pc = 0x8250BA88; continue 'dispatch;
            }
            0x8250BA84 => {
    //   block [0x8250BA84..0x8250BA88)
	// 8250BA84: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x8250BA88; continue 'dispatch;
            }
            0x8250BA88 => {
    //   block [0x8250BA88..0x8250BAA0)
	// 8250BA88: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8250BA8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8250BA90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8250BA94: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8250BA98: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8250BA9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250BAA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8250BAA0 size=8
    let mut pc: u32 = 0x8250BAA0;
    'dispatch: loop {
        match pc {
            0x8250BAA0 => {
    //   block [0x8250BAA0..0x8250BAA8)
	// 8250BAA0: 80630018  lwz r3, 0x18(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250BAA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250BAA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8250BAA8 size=132
    let mut pc: u32 = 0x8250BAA8;
    'dispatch: loop {
        match pc {
            0x8250BAA8 => {
    //   block [0x8250BAA8..0x8250BB10)
	// 8250BAA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250BAAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8250BAB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8250BAB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8250BAB8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8250BABC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250BAC0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8250BAC4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8250BAC8: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8250BACC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8250BAD0: 4BFFF7F1  bl 0x8250b2c0
	ctx.lr = 0x8250BAD4;
	sub_8250B2C0(ctx, base);
	// 8250BAD4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8250BAD8: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 8250BADC: D3FF0020  stfs f31, 0x20(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8250BAE0: 396B32AC  addi r11, r11, 0x32ac
	ctx.r[11].s64 = ctx.r[11].s64 + 12972;
	// 8250BAE4: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 8250BAE8: 394A3288  addi r10, r10, 0x3288
	ctx.r[10].s64 = ctx.r[10].s64 + 12936;
	// 8250BAEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250BAF0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8250BAF4: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8250BAF8: A17E0004  lhz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250BAFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8250BB00: 419A0010  beq cr6, 0x8250bb10
	if ctx.cr[6].eq {
	pc = 0x8250BB10; continue 'dispatch;
	}
	// 8250BB04: A17E0006  lhz r11, 6(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 8250BB08: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8250BB0C: B17E0006  sth r11, 6(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	pc = 0x8250BB10; continue 'dispatch;
            }
            0x8250BB10 => {
    //   block [0x8250BB10..0x8250BB2C)
	// 8250BB10: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8250BB14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8250BB18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8250BB1C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8250BB20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8250BB24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8250BB28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250BB30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8250BB30 size=148
    let mut pc: u32 = 0x8250BB30;
    'dispatch: loop {
        match pc {
            0x8250BB30 => {
    //   block [0x8250BB30..0x8250BB98)
	// 8250BB30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250BB34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8250BB38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8250BB3C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250BB40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8250BB44: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8250BB48: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 8250BB4C: 396B32AC  addi r11, r11, 0x32ac
	ctx.r[11].s64 = ctx.r[11].s64 + 12972;
	// 8250BB50: 394A3288  addi r10, r10, 0x3288
	ctx.r[10].s64 = ctx.r[10].s64 + 12936;
	// 8250BB54: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250BB58: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8250BB5C: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8250BB60: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250BB64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8250BB68: 419A0030  beq cr6, 0x8250bb98
	if ctx.cr[6].eq {
	pc = 0x8250BB98; continue 'dispatch;
	}
	// 8250BB6C: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 8250BB70: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8250BB74: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 8250BB78: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8250BB7C: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 8250BB80: 409A0018  bne cr6, 0x8250bb98
	if !ctx.cr[6].eq {
	pc = 0x8250BB98; continue 'dispatch;
	}
	// 8250BB84: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250BB88: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8250BB8C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250BB90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250BB94: 4E800421  bctrl
	ctx.lr = 0x8250BB98;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8250BB98 => {
    //   block [0x8250BB98..0x8250BBC4)
	// 8250BB98: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8250BB9C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8250BBA0: 396B2A44  addi r11, r11, 0x2a44
	ctx.r[11].s64 = ctx.r[11].s64 + 10820;
	// 8250BBA4: 394A6DD0  addi r10, r10, 0x6dd0
	ctx.r[10].s64 = ctx.r[10].s64 + 28112;
	// 8250BBA8: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 8250BBAC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8250BBB0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8250BBB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8250BBB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8250BBBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8250BBC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250BBC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8250BBC8 size=32
    let mut pc: u32 = 0x8250BBC8;
    'dispatch: loop {
        match pc {
            0x8250BBC8 => {
    //   block [0x8250BBC8..0x8250BBE8)
	// 8250BBC8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8250BBCC: 806B0018  lwz r3, 0x18(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250BBD0: C00B0020  lfs f0, 0x20(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8250BBD4: EC20082A  fadds f1, f0, f1
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 8250BBD8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250BBDC: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 8250BBE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250BBE4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250BBE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8250BBE8 size=612
    let mut pc: u32 = 0x8250BBE8;
    'dispatch: loop {
        match pc {
            0x8250BBE8 => {
    //   block [0x8250BBE8..0x8250BC70)
	// 8250BBE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250BBEC: 480294C1  bl 0x825350ac
	ctx.lr = 0x8250BBF0;
	sub_82535080(ctx, base);
	// 8250BBF0: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 8250BBF4: 4802A3F5  bl 0x82535fe8
	ctx.lr = 0x8250BBF8;
	sub_82535FB0(ctx, base);
	// 8250BBF8: 3981FFA0  addi r12, r1, -0x60
	ctx.r[12].s64 = ctx.r[1].s64 + -96;
	// 8250BBFC: 4802D7A9  bl 0x825393a4
	ctx.lr = 0x8250BC00;
	sub_82539130(ctx, base);
	// 8250BC00: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250BC04: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 8250BC08: 83E30008  lwz r31, 8(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250BC0C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 8250BC10: 573DFC7E  rlwinm r29, r25, 0x1f, 0x11, 0x1f
	ctx.r[29].u64 = ctx.r[25].u32 as u64 & 0x00000001u64;
	// 8250BC14: 573C843E  srwi r28, r25, 0x10
	ctx.r[28].u32 = ctx.r[25].u32.wrapping_shr(16);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 8250BC18: 419A0058  beq cr6, 0x8250bc70
	if ctx.cr[6].eq {
	pc = 0x8250BC70; continue 'dispatch;
	}
	// 8250BC1C: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 8250BC20: C0030010  lfs f0, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8250BC24: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 8250BC28: D0050010  stfs f0, 0x10(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8250BC2C: 392A3134  addi r9, r10, 0x3134
	ctx.r[9].s64 = ctx.r[10].s64 + 12596;
	// 8250BC30: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8250BC34: 38E00004  li r7, 4
	ctx.r[7].s64 = 4;
	// 8250BC38: 38C00006  li r6, 6
	ctx.r[6].s64 = 6;
	// 8250BC3C: 39650050  addi r11, r5, 0x50
	ctx.r[11].s64 = ctx.r[5].s64 + 80;
	// 8250BC40: B1050006  sth r8, 6(r5)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[5].u32.wrapping_add(6 as u32), ctx.r[8].u16 ) };
	// 8250BC44: 91250000  stw r9, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8250BC48: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 8250BC4C: 91450008  stw r10, 8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8250BC50: 90E5000C  stw r7, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 8250BC54: B1450014  sth r10, 0x14(r5)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[5].u32.wrapping_add(20 as u32), ctx.r[10].u16 ) };
	// 8250BC58: 98C50016  stb r6, 0x16(r5)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[5].u32.wrapping_add(22 as u32), ctx.r[6].u8 ) };
	pc = 0x8250BC70; continue 'dispatch;
            }
            0x8250BC70 => {
    //   block [0x8250BC70..0x8250BE4C)
	// 8250BC70: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 8250BC74: 7FAB07B4  extsw r11, r29
	ctx.r[11].s64 = ctx.r[29].s32 as i64;
	// 8250BC78: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250BC7C: 3BDF0020  addi r30, r31, 0x20
	ctx.r[30].s64 = ctx.r[31].s64 + 32;
	// 8250BC80: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8250BC84: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8250BC88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250BC8C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8250BC90: 816A002C  lwz r11, 0x2c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 8250BC94: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8250BC98: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8250BC9C: FFC00018  frsp f30, f0
	ctx.f[30].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8250BCA0: D3C10060  stfs f30, 0x60(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8250BCA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250BCA8: 4E800421  bctrl
	ctx.lr = 0x8250BCAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250BCAC: 7F8A07B4  extsw r10, r28
	ctx.r[10].s64 = ctx.r[28].s32 as i64;
	// 8250BCB0: D0210064  stfs f1, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8250BCB4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250BE50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8250BE50 size=8
    let mut pc: u32 = 0x8250BE50;
    'dispatch: loop {
        match pc {
            0x8250BE50 => {
    //   block [0x8250BE50..0x8250BE58)
	// 8250BE50: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8250BE54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250BE58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8250BE58 size=100
    let mut pc: u32 = 0x8250BE58;
    'dispatch: loop {
        match pc {
            0x8250BE58 => {
    //   block [0x8250BE58..0x8250BEBC)
	// 8250BE58: 3D600842  lis r11, 0x842
	ctx.r[11].s64 = 138543104;
	// 8250BE5C: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250BE60: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 8250BE64: 61691085  ori r9, r11, 0x1085
	ctx.r[9].u64 = ctx.r[11].u64 | 4229;
	// 8250BE68: 3960001F  li r11, 0x1f
	ctx.r[11].s64 = 31;
	// 8250BE6C: 7D665B96  divwu r11, r6, r11
	ctx.r[11].u32 = ctx.r[6].u32 / ctx.r[11].u32;
	// 8250BE70: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8250BE74: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8250BE78: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8250BE7C: 7CEB282E  lwzx r7, r11, r5
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 8250BE80: 7D664816  mulhwu r11, r6, r9
	ctx.r[11].u64 = ((ctx.r[6].u32 as u64 * ctx.r[9].u32 as u64) >> 32);
	// 8250BE84: 7D4B3050  subf r10, r11, r6
	ctx.r[10].s64 = ctx.r[6].s64 - ctx.r[11].s64;
	// 8250BE88: 554AF87E  srwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8250BE8C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8250BE90: 556BE13E  srwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8250BE94: 556A2834  slwi r10, r11, 5
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8250BE98: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8250BE9C: 7D6B3050  subf r11, r11, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[11].s64;
	// 8250BEA0: 7D0B5830  slw r11, r8, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[8].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 8250BEA4: 7D6B3838  and r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[7].u64;
	// 8250BEA8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8250BEAC: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8250BEB0: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 8250BEB4: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 8250BEB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250BEC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8250BEC0 size=144
    let mut pc: u32 = 0x8250BEC0;
    'dispatch: loop {
        match pc {
            0x8250BEC0 => {
    //   block [0x8250BEC0..0x8250BF24)
	// 8250BEC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250BEC4: 480291F9  bl 0x825350bc
	ctx.lr = 0x8250BEC8;
	sub_82535080(ctx, base);
	// 8250BEC8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8250BECC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250BED0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8250BED4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8250BED8: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8250BEDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8250BEE0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8250BEE4: 4BFFF3DD  bl 0x8250b2c0
	ctx.lr = 0x8250BEE8;
	sub_8250B2C0(ctx, base);
	// 8250BEE8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8250BEEC: D3FF0020  stfs f31, 0x20(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8250BEF0: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 8250BEF4: 93BF0018  stw r29, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 8250BEF8: 396B3340  addi r11, r11, 0x3340
	ctx.r[11].s64 = ctx.r[11].s64 + 13120;
	// 8250BEFC: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 8250BF00: 394A331C  addi r10, r10, 0x331c
	ctx.r[10].s64 = ctx.r[10].s64 + 13084;
	// 8250BF04: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8250BF08: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8250BF0C: A17E0004  lhz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250BF10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8250BF14: 419A0010  beq cr6, 0x8250bf24
	if ctx.cr[6].eq {
	pc = 0x8250BF24; continue 'dispatch;
	}
	// 8250BF18: A17E0006  lhz r11, 6(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 8250BF1C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8250BF20: B17E0006  sth r11, 6(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	pc = 0x8250BF24; continue 'dispatch;
            }
            0x8250BF24 => {
    //   block [0x8250BF24..0x8250BF44)
	// 8250BF24: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250BF28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250BF2C: A14B0004  lhz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250BF30: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8250BF34: 419A0010  beq cr6, 0x8250bf44
	if ctx.cr[6].eq {
	pc = 0x8250BF44; continue 'dispatch;
	}
	// 8250BF38: A14B0006  lhz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 8250BF3C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8250BF40: B14B0006  sth r10, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	pc = 0x8250BF44; continue 'dispatch;
            }
            0x8250BF44 => {
    //   block [0x8250BF44..0x8250BF50)
	// 8250BF44: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8250BF48: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8250BF4C: 480291C0  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250BF50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8250BF50 size=208
    let mut pc: u32 = 0x8250BF50;
    'dispatch: loop {
        match pc {
            0x8250BF50 => {
    //   block [0x8250BF50..0x8250BFB8)
	// 8250BF50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250BF54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8250BF58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8250BF5C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250BF60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8250BF64: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8250BF68: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 8250BF6C: 396B3340  addi r11, r11, 0x3340
	ctx.r[11].s64 = ctx.r[11].s64 + 13120;
	// 8250BF70: 394A331C  addi r10, r10, 0x331c
	ctx.r[10].s64 = ctx.r[10].s64 + 13084;
	// 8250BF74: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8250BF78: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8250BF7C: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8250BF80: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250BF84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8250BF88: 419A0030  beq cr6, 0x8250bfb8
	if ctx.cr[6].eq {
	pc = 0x8250BFB8; continue 'dispatch;
	}
	// 8250BF8C: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 8250BF90: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8250BF94: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 8250BF98: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8250BF9C: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 8250BFA0: 409A0018  bne cr6, 0x8250bfb8
	if !ctx.cr[6].eq {
	pc = 0x8250BFB8; continue 'dispatch;
	}
	// 8250BFA4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250BFA8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8250BFAC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250BFB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250BFB4: 4E800421  bctrl
	ctx.lr = 0x8250BFB8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8250BFB8 => {
    //   block [0x8250BFB8..0x8250BFF4)
	// 8250BFB8: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250BFBC: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250BFC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8250BFC4: 419A0030  beq cr6, 0x8250bff4
	if ctx.cr[6].eq {
	pc = 0x8250BFF4; continue 'dispatch;
	}
	// 8250BFC8: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 8250BFCC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8250BFD0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 8250BFD4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8250BFD8: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 8250BFDC: 409A0018  bne cr6, 0x8250bff4
	if !ctx.cr[6].eq {
	pc = 0x8250BFF4; continue 'dispatch;
	}
	// 8250BFE0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250BFE4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8250BFE8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250BFEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250BFF0: 4E800421  bctrl
	ctx.lr = 0x8250BFF4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8250BFF4 => {
    //   block [0x8250BFF4..0x8250C020)
	// 8250BFF4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8250BFF8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8250BFFC: 396B2A44  addi r11, r11, 0x2a44
	ctx.r[11].s64 = ctx.r[11].s64 + 10820;
	// 8250C000: 394A6DD0  addi r10, r10, 0x6dd0
	ctx.r[10].s64 = ctx.r[10].s64 + 28112;
	// 8250C004: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 8250C008: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8250C00C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8250C010: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8250C014: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8250C018: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8250C01C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250C020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8250C020 size=36
    let mut pc: u32 = 0x8250C020;
    'dispatch: loop {
        match pc {
            0x8250C020 => {
    //   block [0x8250C020..0x8250C044)
	// 8250C020: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250C024: 38640001  addi r3, r4, 1
	ctx.r[3].s64 = ctx.r[4].s64 + 1;
	// 8250C028: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 8250C02C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250C030: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8250C034: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8250C038: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 8250C03C: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 8250C040: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250C048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8250C048 size=704
    let mut pc: u32 = 0x8250C048;
    'dispatch: loop {
        match pc {
            0x8250C048 => {
    //   block [0x8250C048..0x8250C080)
	// 8250C048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250C04C: 48029049  bl 0x82535094
	ctx.lr = 0x8250C050;
	sub_82535080(ctx, base);
	// 8250C050: 9421FD40  stwu r1, -0x2c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-704 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250C054: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8250C058: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 8250C05C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8250C060: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 8250C064: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8250C068: 419A0018  beq cr6, 0x8250c080
	if ctx.cr[6].eq {
	pc = 0x8250C080; continue 'dispatch;
	}
	// 8250C06C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8250C070: C0380010  lfs f1, 0x10(r24)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8250C074: 4801E32D  bl 0x8252a3a0
	ctx.lr = 0x8250C078;
	sub_8252A3A0(ctx, base);
	// 8250C078: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8250C07C: 48000008  b 0x8250c084
	pc = 0x8250C084; continue 'dispatch;
            }
            0x8250C080 => {
    //   block [0x8250C080..0x8250C084)
	// 8250C080: 7EBFAB78  mr r31, r21
	ctx.r[31].u64 = ctx.r[21].u64;
	pc = 0x8250C084; continue 'dispatch;
            }
            0x8250C084 => {
    //   block [0x8250C084..0x8250C190)
	// 8250C084: 8178000C  lwz r11, 0xc(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) } as u64;
	// 8250C088: 395E003B  addi r10, r30, 0x3b
	ctx.r[10].s64 = ctx.r[30].s64 + 59;
	// 8250C08C: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 8250C090: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250C094: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250C098: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8250C09C: 409801DC  bge cr6, 0x8250c278
	if !ctx.cr[6].lt {
	pc = 0x8250C278; continue 'dispatch;
	}
	// 8250C0A0: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250C0A4: 57A9103A  slwi r9, r29, 2
	ctx.r[9].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8250C0A8: 55590036  rlwinm r25, r10, 0, 0, 0x1b
	ctx.r[25].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8250C0AC: 810B0014  lwz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8250C0B0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250C0B4: 7D68482E  lwzx r11, r8, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8250C0B8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8250C0BC: 7FCB5214  add r30, r11, r10
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8250C0C0: 395E0004  addi r10, r30, 4
	ctx.r[10].s64 = ctx.r[30].s64 + 4;
	// 8250C0C4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250C0C8: 933F0018  stw r25, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[25].u32 ) };
	// 8250C0CC: 92BF001C  stw r21, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[21].u32 ) };
	// 8250C0D0: 915F0024  stw r10, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 8250C0D4: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 8250C0D8: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8250C0DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8250C0E0: 4099021C  ble cr6, 0x8250c2fc
	if !ctx.cr[6].gt {
	pc = 0x8250C2FC; continue 'dispatch;
	}
	// 8250C0E4: 3D600842  lis r11, 0x842
	ctx.r[11].s64 = 138543104;
	// 8250C0E8: 7EB7AB78  mr r23, r21
	ctx.r[23].u64 = ctx.r[21].u64;
	// 8250C0EC: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	// 8250C0F0: 617C1085  ori r28, r11, 0x1085
	ctx.r[28].u64 = ctx.r[11].u64 | 4229;
	// 8250C0F4: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 8250C0F8: 3B60001F  li r27, 0x1f
	ctx.r[27].s64 = 31;
	// 8250C0FC: 3AC00020  li r22, 0x20
	ctx.r[22].s64 = 32;
	// 8250C100: 3A600030  li r19, 0x30
	ctx.r[19].s64 = 48;
	// 8250C104: 3A800040  li r20, 0x40
	ctx.r[20].s64 = 64;
	// 8250C108: 8178000C  lwz r11, 0xc(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) } as u64;
	// 8250C10C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8250C110: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 8250C114: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 8250C118: 7C8AB82E  lwzx r4, r10, r23
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 8250C11C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250C120: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8250C124: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250C128: 4E800421  bctrl
	ctx.lr = 0x8250C12C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250C12C: 397DFFFE  addi r11, r29, -2
	ctx.r[11].s64 = ctx.r[29].s64 + -2;
	// 8250C130: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250C134: 7D4BDB96  divwu r10, r11, r27
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[27].u32;
	// 8250C138: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 8250C13C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8250C140: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8250C144: 7D0AF02E  lwzx r8, r10, r30
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8250C148: 7D4BE016  mulhwu r10, r11, r28
	ctx.r[10].u64 = ((ctx.r[11].u32 as u64 * ctx.r[28].u32 as u64) >> 32);
	// 8250C14C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8250C150: 5529F87E  srwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8250C154: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 8250C158: 554AE13E  srwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8250C15C: 55492834  slwi r9, r10, 5
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8250C160: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 8250C164: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8250C168: 7F4B5830  slw r11, r26, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[26].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 8250C16C: 7D6B4038  and r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[8].u64;
	// 8250C170: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8250C174: 419A001C  beq cr6, 0x8250c190
	if ctx.cr[6].eq {
	pc = 0x8250C190; continue 'dispatch;
	}
            }
            0x8250C190 => {
    //   block [0x8250C190..0x8250C278)
	// 8250C190: 397DFFFF  addi r11, r29, -1
	ctx.r[11].s64 = ctx.r[29].s64 + -1;
	// 8250C194: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250C198: 7D4BDB96  divwu r10, r11, r27
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[27].u32;
	// 8250C19C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 8250C1A0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8250C1A4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8250C1A8: 7D0AF02E  lwzx r8, r10, r30
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8250C1AC: 7D4BE016  mulhwu r10, r11, r28
	ctx.r[10].u64 = ((ctx.r[11].u32 as u64 * ctx.r[28].u32 as u64) >> 32);
	// 8250C1B0: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8250C1B4: 5529F87E  srwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8250C1B8: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 8250C1BC: 554AE13E  srwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8250C1C0: 55492834  slwi r9, r10, 5
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8250C1C4: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 8250C1C8: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8250C1CC: 7F4B5830  slw r11, r26, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[26].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 8250C1D0: 7D6B4038  and r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[8].u64;
	// 8250C1D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8250C1D8: 419A001C  beq cr6, 0x8250c1f4
	if ctx.cr[6].eq {
	pc = 0x8250C1F4; continue 'dispatch;
	}
	pc = 0x8250C278; continue 'dispatch;
            }
            0x8250C278 => {
    //   block [0x8250C278..0x8250C2FC)
	// 8250C278: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8250C27C: 555E0036  rlwinm r30, r10, 0, 0, 0x1b
	ctx.r[30].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8250C280: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 8250C284: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8250C288: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 8250C28C: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250C290: 810B0018  lwz r8, 0x18(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250C294: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 8250C298: 7D68E850  subf r11, r8, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[8].s64;
	// 8250C29C: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 8250C2A0: 913F001C  stw r9, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 8250C2A4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8250C2A8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8250C2AC: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 8250C2B0: 8178000C  lwz r11, 0xc(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) } as u64;
	// 8250C2B4: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 8250C2B8: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 8250C2BC: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250C2C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250C2C4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8250C2C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250C2CC: 4E800421  bctrl
	ctx.lr = 0x8250C2D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250C2D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8250C2D4: 3AC00020  li r22, 0x20
	ctx.r[22].s64 = 32;
	// 8250C2D8: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 8250C2DC: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8250C2E0: 39000040  li r8, 0x40
	ctx.r[8].s64 = 64;
            }
            0x8250C2FC => {
    //   block [0x8250C2FC..0x8250C308)
	// 8250C2FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250C300: 382102C0  addi r1, r1, 0x2c0
	ctx.r[1].s64 = ctx.r[1].s64 + 704;
	// 8250C304: 48028DE0  b 0x825350e4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250C308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8250C308 size=96
    let mut pc: u32 = 0x8250C308;
    'dispatch: loop {
        match pc {
            0x8250C308 => {
    //   block [0x8250C308..0x8250C33C)
	// 8250C308: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250C30C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250C310: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8250C314: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250C318: 40980024  bge cr6, 0x8250c33c
	if !ctx.cr[6].lt {
	pc = 0x8250C33C; continue 'dispatch;
	}
	// 8250C31C: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8250C320: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8250C324: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250C328: 7D69502E  lwzx r11, r9, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8250C32C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8250C330: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8250C334: 7C8B402E  lwzx r4, r11, r8
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 8250C338: 48000018  b 0x8250c350
	pc = 0x8250C350; continue 'dispatch;
            }
            0x8250C33C => {
    //   block [0x8250C33C..0x8250C350)
	// 8250C33C: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250C340: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 8250C344: 7D4A2050  subf r10, r10, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[10].s64;
	// 8250C348: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8250C34C: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	pc = 0x8250C350; continue 'dispatch;
            }
            0x8250C350 => {
    //   block [0x8250C350..0x8250C368)
	// 8250C350: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8250C354: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 8250C358: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250C35C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8250C360: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250C364: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250C368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8250C368 size=296
    let mut pc: u32 = 0x8250C368;
    'dispatch: loop {
        match pc {
            0x8250C368 => {
    //   block [0x8250C368..0x8250C490)
	// 8250C368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250C36C: 48028D49  bl 0x825350b4
	ctx.lr = 0x8250C370;
	sub_82535080(ctx, base);
	// 8250C370: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8250C374: 9421FD40  stwu r1, -0x2c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-704 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250C378: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8250C37C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8250C380: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 8250C384: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8250C388: 3B9D0010  addi r28, r29, 0x10
	ctx.r[28].s64 = ctx.r[29].s64 + 16;
	// 8250C38C: 3BCB0010  addi r30, r11, 0x10
	ctx.r[30].s64 = ctx.r[11].s64 + 16;
	// 8250C390: C00A8CB4  lfs f0, -0x734c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-29516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8250C394: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8250C398: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8250C39C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 8250C3A0: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8250C3A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8250C3A8: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8250C3AC: C1AA1FF8  lfs f13, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8250C3B0: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 8250C3B4: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8250C3B8: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8250C3BC: C00A0DA0  lfs f0, 0xda0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3488 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8250C3C0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8250C3C4: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8250C3C8: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8250C3CC: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250C490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8250C490 size=220
    let mut pc: u32 = 0x8250C490;
    'dispatch: loop {
        match pc {
            0x8250C490 => {
    //   block [0x8250C490..0x8250C4D0)
	// 8250C490: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250C494: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8250C498: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250C49C: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250C4A0: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 8250C4A4: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 8250C4A8: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8250C4AC: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250C4B0: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 8250C4B4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8250C4B8: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8250C4BC: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250C4C0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250C4C4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8250C4C8: 40990058  ble cr6, 0x8250c520
	if !ctx.cr[6].gt {
	pc = 0x8250C520; continue 'dispatch;
	}
	// 8250C4CC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x8250C4D0; continue 'dispatch;
            }
            0x8250C4D0 => {
    //   block [0x8250C4D0..0x8250C504)
	// 8250C4D0: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250C4D4: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250C4D8: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 8250C4DC: 80CB0014  lwz r6, 0x14(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8250C4E0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250C4E4: 7CC6482E  lwzx r6, r6, r9
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8250C4E8: 54C6103A  slwi r6, r6, 2
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 8250C4EC: 7D66582E  lwzx r11, r6, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8250C4F0: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 8250C4F4: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8250C4F8: 91040000  stw r8, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8250C4FC: 40990008  ble cr6, 0x8250c504
	if !ctx.cr[6].gt {
	pc = 0x8250C504; continue 'dispatch;
	}
	// 8250C500: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x8250C504; continue 'dispatch;
            }
            0x8250C504 => {
    //   block [0x8250C504..0x8250C520)
	// 8250C504: 9164000C  stw r11, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 8250C508: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 8250C50C: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250C510: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 8250C514: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250C518: 7F075800  cmpw cr6, r7, r11
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8250C51C: 4198FFB4  blt cr6, 0x8250c4d0
	if ctx.cr[6].lt {
	pc = 0x8250C4D0; continue 'dispatch;
	}
	pc = 0x8250C520; continue 'dispatch;
            }
            0x8250C520 => {
    //   block [0x8250C520..0x8250C56C)
	// 8250C520: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250C524: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250C528: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 8250C52C: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250C530: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250C534: F921FFF0  std r9, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u64 ) };
	// 8250C538: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8250C53C: 7D6A07B4  extsw r10, r11
	ctx.r[10].s64 = ctx.r[11].s32 as i64;
	// 8250C540: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8250C544: C801FFF0  lfd f0, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8250C548: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 8250C54C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8250C550: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8250C554: C9A1FFF0  lfd f13, -0x10(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8250C558: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8250C55C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8250C560: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 8250C564: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8250C568: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250C570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8250C570 size=320
    let mut pc: u32 = 0x8250C570;
    'dispatch: loop {
        match pc {
            0x8250C570 => {
    //   block [0x8250C570..0x8250C5F0)
	// 8250C570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250C574: 48028B49  bl 0x825350bc
	ctx.lr = 0x8250C578;
	sub_82535080(ctx, base);
	// 8250C578: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250C57C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8250C580: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8250C584: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8250C588: 388B49D4  addi r4, r11, 0x49d4
	ctx.r[4].s64 = ctx.r[11].s64 + 18900;
	// 8250C58C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 8250C590: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250C594: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8250C598: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250C59C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250C5A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250C5A4: 4E800421  bctrl
	ctx.lr = 0x8250C5A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250C5A8: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250C5AC: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 8250C5B0: 55490000  rlwinm r9, r10, 0, 0, 0
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8250C5B4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8250C5B8: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 8250C5BC: 3BA949CC  addi r29, r9, 0x49cc
	ctx.r[29].s64 = ctx.r[9].s64 + 18892;
	// 8250C5C0: 409A0030  bne cr6, 0x8250c5f0
	if !ctx.cr[6].eq {
	pc = 0x8250C5F0; continue 'dispatch;
	}
	// 8250C5C4: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250C5C8: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8250C5CC: 80EB0018  lwz r7, 0x18(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250C5D0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8250C5D4: 80CB0014  lwz r6, 0x14(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8250C5D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8250C5DC: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 8250C5E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250C5E4: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250C5E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250C5EC: 4E800421  bctrl
	ctx.lr = 0x8250C5F0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8250C5F0 => {
    //   block [0x8250C5F0..0x8250C630)
	// 8250C5F0: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250C5F4: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8250C5F8: 55490000  rlwinm r9, r10, 0, 0, 0
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8250C5FC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8250C600: 409A0030  bne cr6, 0x8250c630
	if !ctx.cr[6].eq {
	pc = 0x8250C630; continue 'dispatch;
	}
	// 8250C604: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250C608: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8250C60C: 80EB0024  lwz r7, 0x24(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 8250C610: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8250C614: 80CB0020  lwz r6, 0x20(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 8250C618: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8250C61C: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 8250C620: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250C624: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250C628: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250C62C: 4E800421  bctrl
	ctx.lr = 0x8250C630;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8250C630 => {
    //   block [0x8250C630..0x8250C670)
	// 8250C630: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250C634: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8250C638: 55490000  rlwinm r9, r10, 0, 0, 0
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8250C63C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8250C640: 409A0030  bne cr6, 0x8250c670
	if !ctx.cr[6].eq {
	pc = 0x8250C670; continue 'dispatch;
	}
	// 8250C644: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250C648: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8250C64C: 80EB000C  lwz r7, 0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8250C650: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8250C654: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250C658: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8250C65C: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 8250C660: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250C664: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250C668: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250C66C: 4E800421  bctrl
	ctx.lr = 0x8250C670;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8250C670 => {
    //   block [0x8250C670..0x8250C6B0)
	// 8250C670: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250C674: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8250C678: 80DE001C  lwz r6, 0x1c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 8250C67C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8250C680: 388B49C0  addi r4, r11, 0x49c0
	ctx.r[4].s64 = ctx.r[11].s64 + 18880;
	// 8250C684: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250C688: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 8250C68C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250C690: 4E800421  bctrl
	ctx.lr = 0x8250C694;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250C694: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250C698: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250C69C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250C6A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250C6A4: 4E800421  bctrl
	ctx.lr = 0x8250C6A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250C6A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8250C6AC: 48028A60  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250C6B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8250C6B0 size=4
    let mut pc: u32 = 0x8250C6B0;
    'dispatch: loop {
        match pc {
            0x8250C6B0 => {
    //   block [0x8250C6B0..0x8250C6B4)
	// 8250C6B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250C6B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8250C6B8 size=12
    let mut pc: u32 = 0x8250C6B8;
    'dispatch: loop {
        match pc {
            0x8250C6B8 => {
    //   block [0x8250C6B8..0x8250C6C4)
	// 8250C6B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8250C6BC: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 8250C6C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250C6C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8250C6C8 size=364
    let mut pc: u32 = 0x8250C6C8;
    'dispatch: loop {
        match pc {
            0x8250C6C8 => {
    //   block [0x8250C6C8..0x8250C748)
	// 8250C6C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250C6CC: 480289E1  bl 0x825350ac
	ctx.lr = 0x8250C6D0;
	sub_82535080(ctx, base);
	// 8250C6D0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250C6D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8250C6D8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8250C6DC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8250C6E0: 39000017  li r8, 0x17
	ctx.r[8].s64 = 23;
	// 8250C6E4: 394B35A8  addi r10, r11, 0x35a8
	ctx.r[10].s64 = ctx.r[11].s64 + 13736;
	// 8250C6E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8250C6EC: B13E0006  sth r9, 6(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 8250C6F0: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 8250C6F4: 3D208000  lis r9, -0x8000
	ctx.r[9].s64 = -2147483648;
	// 8250C6F8: 911E000C  stw r8, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 8250C6FC: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 8250C700: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8250C704: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8250C708: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8250C70C: 3B3E001C  addi r25, r30, 0x1c
	ctx.r[25].s64 = ctx.r[30].s64 + 28;
	// 8250C710: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8250C714: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8250C718: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8250C71C: D03E001C  stfs f1, 0x1c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8250C720: 835F0004  lwz r26, 4(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250C724: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250C728: 7F9ADA14  add r28, r26, r27
	ctx.r[28].u64 = ctx.r[26].u64 + ctx.r[27].u64;
	// 8250C72C: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 8250C730: 7F0BE000  cmpw cr6, r11, r28
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[28].s32, &mut ctx.xer);
	// 8250C734: 40980024  bge cr6, 0x8250c758
	if !ctx.cr[6].lt {
	pc = 0x8250C758; continue 'dispatch;
	}
	// 8250C738: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8250C73C: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8250C740: 41980008  blt cr6, 0x8250c748
	if ctx.cr[6].lt {
	pc = 0x8250C748; continue 'dispatch;
	}
	// 8250C744: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x8250C748; continue 'dispatch;
            }
            0x8250C748 => {
    //   block [0x8250C748..0x8250C758)
	// 8250C748: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 8250C74C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 8250C750: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250C754: 4BF61B75  bl 0x8246e2c8
	ctx.lr = 0x8250C758;
	sub_8246E2C8(ctx, base);
	pc = 0x8250C758; continue 'dispatch;
            }
            0x8250C758 => {
    //   block [0x8250C758..0x8250C828)
	// 8250C758: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250C75C: 395BFFFF  addi r10, r27, -1
	ctx.r[10].s64 = ctx.r[27].s64 + -1;
	// 8250C760: 574B2834  slwi r11, r26, 5
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8250C764: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 8250C768: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8250C76C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 8250C770: 419800B8  blt cr6, 0x8250c828
	if ctx.cr[6].lt {
	pc = 0x8250C828; continue 'dispatch;
	}
	// 8250C774: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8250C778: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 8250C77C: C0091850  lfs f0, 0x1850(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(6224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8250C828; continue 'dispatch;
            }
            0x8250C828 => {
    //   block [0x8250C828..0x8250C834)
	// 8250C828: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8250C82C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 8250C830: 480288CC  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250C838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8250C838 size=172
    let mut pc: u32 = 0x8250C838;
    'dispatch: loop {
        match pc {
            0x8250C838 => {
    //   block [0x8250C838..0x8250C8B8)
	// 8250C838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250C83C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8250C840: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8250C844: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8250C848: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250C84C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8250C850: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8250C854: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8250C858: 388B4A08  addi r4, r11, 0x4a08
	ctx.r[4].s64 = ctx.r[11].s64 + 18952;
	// 8250C85C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 8250C860: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250C864: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8250C868: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250C86C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250C870: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250C874: 4E800421  bctrl
	ctx.lr = 0x8250C878;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250C878: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250C87C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8250C880: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8250C884: 409A0034  bne cr6, 0x8250c8b8
	if !ctx.cr[6].eq {
	pc = 0x8250C8B8; continue 'dispatch;
	}
	// 8250C888: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250C88C: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 8250C890: 80FE0014  lwz r7, 0x14(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 8250C894: 55682834  slwi r8, r11, 5
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8250C898: 80DE0010  lwz r6, 0x10(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 8250C89C: 388A4A00  addi r4, r10, 0x4a00
	ctx.r[4].s64 = ctx.r[10].s64 + 18944;
	// 8250C8A0: 54E72834  slwi r7, r7, 5
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(5);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 8250C8A4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8250C8A8: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250C8AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250C8B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250C8B4: 4E800421  bctrl
	ctx.lr = 0x8250C8B8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8250C8B8 => {
    //   block [0x8250C8B8..0x8250C8E4)
	// 8250C8B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250C8BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250C8C0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250C8C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250C8C8: 4E800421  bctrl
	ctx.lr = 0x8250C8CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250C8CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8250C8D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8250C8D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8250C8D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8250C8DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8250C8E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250C8E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8250C8E8 size=476
    let mut pc: u32 = 0x8250C8E8;
    'dispatch: loop {
        match pc {
            0x8250C8E8 => {
    //   block [0x8250C8E8..0x8250C938)
	// 8250C8E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250C8EC: 480287C1  bl 0x825350ac
	ctx.lr = 0x8250C8F0;
	sub_82535080(ctx, base);
	// 8250C8F0: 9421FD20  stwu r1, -0x2e0(r1)
	ea = ctx.r[1].u32.wrapping_add(-736 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250C8F4: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
	// 8250C8F8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8250C8FC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8250C900: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 8250C904: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 8250C908: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8250C90C: 83BE0014  lwz r29, 0x14(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 8250C910: 2F1D0010  cmpwi cr6, r29, 0x10
	ctx.cr[6].compare_i32(ctx.r[29].s32, 16, &mut ctx.xer);
	// 8250C914: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 8250C918: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 8250C91C: 616B0010  ori r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u64 | 16;
	// 8250C920: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 8250C924: 40990020  ble cr6, 0x8250c944
	if !ctx.cr[6].gt {
	pc = 0x8250C944; continue 'dispatch;
	}
	// 8250C928: 2F1D0020  cmpwi cr6, r29, 0x20
	ctx.cr[6].compare_i32(ctx.r[29].s32, 32, &mut ctx.xer);
	// 8250C92C: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 8250C930: 41980008  blt cr6, 0x8250c938
	if ctx.cr[6].lt {
	pc = 0x8250C938; continue 'dispatch;
	}
	// 8250C934: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	pc = 0x8250C938; continue 'dispatch;
            }
            0x8250C938 => {
    //   block [0x8250C938..0x8250C944)
	// 8250C938: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 8250C93C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8250C940: 4BF61989  bl 0x8246e2c8
	ctx.lr = 0x8250C944;
	sub_8246E2C8(ctx, base);
	pc = 0x8250C944; continue 'dispatch;
            }
            0x8250C944 => {
    //   block [0x8250C944..0x8250CAC4)
	// 8250C944: 391F0030  addi r8, r31, 0x30
	ctx.r[8].s64 = ctx.r[31].s64 + 48;
	// 8250C948: 93A10094  stw r29, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[29].u32 ) };
	// 8250C94C: EBBF0000  ld r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 8250C950: 395F0010  addi r10, r31, 0x10
	ctx.r[10].s64 = ctx.r[31].s64 + 16;
	// 8250C954: 393F0020  addi r9, r31, 0x20
	ctx.r[9].s64 = ctx.r[31].s64 + 32;
	// 8250C958: EBFF0008  ld r31, 8(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	// 8250C95C: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 8250C960: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 8250C964: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8250C968: 83DE0010  lwz r30, 0x10(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 8250C96C: EB280000  ld r25, 0(r8)
	ctx.r[25].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 8250C970: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 8250C974: E9080008  ld r8, 8(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	// 8250C978: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8250C97C: EB6A0000  ld r27, 0(r10)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 8250C980: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8250C984: FBA70000  std r29, 0(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u64 ) };
	// 8250C988: FBE70008  std r31, 8(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[31].u64 ) };
	// 8250C98C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8250C990: FB240000  std r25, 0(r4)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[25].u64 ) };
	// 8250C994: F9040008  std r8, 8(r4)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	// 8250C998: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 8250C99C: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 8250C9A0: 55632036  slwi r3, r11, 4
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 8250C9A4: FB660000  std r27, 0(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[27].u64 ) };
	// 8250C9A8: EB490000  ld r26, 0(r9)
	ctx.r[26].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 8250C9AC: E9290008  ld r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250CAC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8250CAC8 size=124
    let mut pc: u32 = 0x8250CAC8;
    'dispatch: loop {
        match pc {
            0x8250CAC8 => {
    //   block [0x8250CAC8..0x8250CB04)
	// 8250CAC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250CACC: 480285E5  bl 0x825350b0
	ctx.lr = 0x8250CAD0;
	sub_82535080(ctx, base);
	// 8250CAD0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250CAD4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8250CAD8: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 8250CADC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8250CAE0: 815D0028  lwz r10, 0x28(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 8250CAE4: 98BD0040  stb r5, 0x40(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(64 as u32), ctx.r[5].u8 ) };
	// 8250CAE8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8250CAEC: 40990048  ble cr6, 0x8250cb34
	if !ctx.cr[6].gt {
	pc = 0x8250CB34; continue 'dispatch;
	}
	// 8250CAF0: 3965FFFB  addi r11, r5, -5
	ctx.r[11].s64 = ctx.r[5].s64 + -5;
	// 8250CAF4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8250CAF8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8250CAFC: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8250CB00: 697B0001  xori r27, r11, 1
	ctx.r[27].u64 = ctx.r[11].u64 ^ 1;
	pc = 0x8250CB04; continue 'dispatch;
            }
            0x8250CB04 => {
    //   block [0x8250CB04..0x8250CB34)
	// 8250CB04: 817D0024  lwz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 8250CB08: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 8250CB0C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8250CB10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250CB14: 7F9E5A14  add r28, r30, r11
	ctx.r[28].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 8250CB18: 4801D2D9  bl 0x82529df0
	ctx.lr = 0x8250CB1C;
	sub_82529DF0(ctx, base);
	// 8250CB1C: B07C000C  sth r3, 0xc(r28)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[3].u16 ) };
	// 8250CB20: 817D0028  lwz r11, 0x28(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 8250CB24: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 8250CB28: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 8250CB2C: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8250CB30: 4198FFD4  blt cr6, 0x8250cb04
	if ctx.cr[6].lt {
	pc = 0x8250CB04; continue 'dispatch;
	}
	pc = 0x8250CB34; continue 'dispatch;
            }
            0x8250CB34 => {
    //   block [0x8250CB34..0x8250CB44)
	// 8250CB34: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8250CB38: 997D0014  stb r11, 0x14(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 8250CB3C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8250CB40: 480285C0  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250CB48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8250CB48 size=268
    let mut pc: u32 = 0x8250CB48;
    'dispatch: loop {
        match pc {
            0x8250CB48 => {
    //   block [0x8250CB48..0x8250CC54)
	// 8250CB48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250CB4C: 48028565  bl 0x825350b0
	ctx.lr = 0x8250CB50;
	sub_82535080(ctx, base);
	// 8250CB50: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 8250CB54: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250CB58: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8250CB5C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8250CB60: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 8250CB64: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8250CB68: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 8250CB6C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 8250CB70: C00B8CB4  lfs f0, -0x734c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8250CB74: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8250CB78: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8250CB7C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8250CB80: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8250CB84: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8250CB88: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8250CB8C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8250CB90: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8250CB94: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8250CB98: C00B0DA0  lfs f0, 0xda0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3488 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8250CB9C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8250CBA0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8250CBA4: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8250CBA8: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250CC58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8250CC58 size=156
    let mut pc: u32 = 0x8250CC58;
    'dispatch: loop {
        match pc {
            0x8250CC58 => {
    //   block [0x8250CC58..0x8250CC80)
	// 8250CC58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250CC5C: 4802845D  bl 0x825350b8
	ctx.lr = 0x8250CC60;
	sub_82535080(ctx, base);
	// 8250CC60: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250CC64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8250CC68: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8250CC6C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250CC70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8250CC74: 40990068  ble cr6, 0x8250ccdc
	if !ctx.cr[6].gt {
	pc = 0x8250CCDC; continue 'dispatch;
	}
	// 8250CC78: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8250CC7C: 3FA08282  lis r29, -0x7d7e
	ctx.r[29].s64 = -2105409536;
	pc = 0x8250CC80; continue 'dispatch;
            }
            0x8250CC80 => {
    //   block [0x8250CC80..0x8250CCDC)
	// 8250CC80: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8250CC84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8250CC88: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250CC8C: C03DE098  lfs f1, -0x1f68(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8040 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8250CC90: 7D5E5214  add r10, r30, r10
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 8250CC94: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250CC98: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250CC9C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250CCA0: 55282036  slwi r8, r9, 4
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8250CCA4: 54E92036  slwi r9, r7, 4
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8250CCA8: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8250CCAC: 7CC85A14  add r6, r8, r11
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 8250CCB0: 7CA95A14  add r5, r9, r11
	ctx.r[5].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 8250CCB4: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8250CCB8: 4801D489  bl 0x8252a140
	ctx.lr = 0x8250CCBC;
	sub_8252A140(ctx, base);
	// 8250CCBC: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250CCC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8250CCC4: 419A0024  beq cr6, 0x8250cce8
	if ctx.cr[6].eq {
	pc = 0x8250CCE8; continue 'dispatch;
	}
	// 8250CCC8: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250CCCC: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 8250CCD0: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 8250CCD4: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8250CCD8: 4198FFA8  blt cr6, 0x8250cc80
	if ctx.cr[6].lt {
	pc = 0x8250CC80; continue 'dispatch;
	}
	pc = 0x8250CCDC; continue 'dispatch;
            }
            0x8250CCDC => {
    //   block [0x8250CCDC..0x8250CCE8)
	// 8250CCDC: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 8250CCE0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8250CCE4: 48028424  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x8250CCE8 => {
    //   block [0x8250CCE8..0x8250CCF4)
	// 8250CCE8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8250CCEC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8250CCF0: 48028418  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250CCF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8250CCF8 size=156
    let mut pc: u32 = 0x8250CCF8;
    'dispatch: loop {
        match pc {
            0x8250CCF8 => {
    //   block [0x8250CCF8..0x8250CD20)
	// 8250CCF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250CCFC: 480283BD  bl 0x825350b8
	ctx.lr = 0x8250CD00;
	sub_82535080(ctx, base);
	// 8250CD00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250CD04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8250CD08: 3B840001  addi r28, r4, 1
	ctx.r[28].s64 = ctx.r[4].s64 + 1;
	// 8250CD0C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250CD10: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8250CD14: 40980068  bge cr6, 0x8250cd7c
	if !ctx.cr[6].lt {
	pc = 0x8250CD7C; continue 'dispatch;
	}
	// 8250CD18: 579E2036  slwi r30, r28, 4
	ctx.r[30].u32 = ctx.r[28].u32.wrapping_shl(4);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 8250CD1C: 3FA08282  lis r29, -0x7d7e
	ctx.r[29].s64 = -2105409536;
	pc = 0x8250CD20; continue 'dispatch;
            }
            0x8250CD20 => {
    //   block [0x8250CD20..0x8250CD7C)
	// 8250CD20: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8250CD24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8250CD28: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250CD2C: C03DE098  lfs f1, -0x1f68(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8040 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8250CD30: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 8250CD34: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250CD38: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250CD3C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250CD40: 55282036  slwi r8, r9, 4
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8250CD44: 54E92036  slwi r9, r7, 4
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8250CD48: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8250CD4C: 7CC85A14  add r6, r8, r11
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 8250CD50: 7CA95A14  add r5, r9, r11
	ctx.r[5].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 8250CD54: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8250CD58: 4801D3E9  bl 0x8252a140
	ctx.lr = 0x8250CD5C;
	sub_8252A140(ctx, base);
	// 8250CD5C: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250CD60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8250CD64: 419A0024  beq cr6, 0x8250cd88
	if ctx.cr[6].eq {
	pc = 0x8250CD88; continue 'dispatch;
	}
	// 8250CD68: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250CD6C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 8250CD70: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 8250CD74: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8250CD78: 4198FFA8  blt cr6, 0x8250cd20
	if ctx.cr[6].lt {
	pc = 0x8250CD20; continue 'dispatch;
	}
	pc = 0x8250CD7C; continue 'dispatch;
            }
            0x8250CD7C => {
    //   block [0x8250CD7C..0x8250CD88)
	// 8250CD7C: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 8250CD80: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8250CD84: 48028384  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x8250CD88 => {
    //   block [0x8250CD88..0x8250CD94)
	// 8250CD88: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8250CD8C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8250CD90: 48028378  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250CD98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8250CD98 size=144
    let mut pc: u32 = 0x8250CD98;
    'dispatch: loop {
        match pc {
            0x8250CD98 => {
    //   block [0x8250CD98..0x8250CE28)
	// 8250CD98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250CD9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8250CDA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8250CDA4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8250CDA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250CDAC: 38800016  li r4, 0x16
	ctx.r[4].s64 = 22;
	// 8250CDB0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8250CDB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8250CDB8: 4BFFE509  bl 0x8250b2c0
	ctx.lr = 0x8250CDBC;
	sub_8250B2C0(ctx, base);
	// 8250CDBC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8250CDC0: 3D408000  lis r10, -0x8000
	ctx.r[10].s64 = -2147483648;
	// 8250CDC4: 392B3670  addi r9, r11, 0x3670
	ctx.r[9].s64 = ctx.r[11].s64 + 13936;
	// 8250CDC8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8250CDCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250CDD0: 390B364C  addi r8, r11, 0x364c
	ctx.r[8].s64 = ctx.r[11].s64 + 13900;
	// 8250CDD4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8250CDD8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8250CDDC: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 8250CDE0: 911F0010  stw r8, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 8250CDE4: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 8250CDE8: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 8250CDEC: 915F0020  stw r10, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 8250CDF0: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 8250CDF4: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 8250CDF8: 915F002C  stw r10, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 8250CDFC: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 8250CE00: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 8250CE04: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 8250CE08: D3FF003C  stfs f31, 0x3c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 8250CE0C: 993F0040  stb r9, 0x40(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[9].u8 ) };
	// 8250CE10: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8250CE14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8250CE18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8250CE1C: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8250CE20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8250CE24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250CE28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8250CE28 size=224
    let mut pc: u32 = 0x8250CE28;
    'dispatch: loop {
        match pc {
            0x8250CE28 => {
    //   block [0x8250CE28..0x8250CE9C)
	// 8250CE28: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 8250CE2C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8250CE30: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 8250CE34: 419A0068  beq cr6, 0x8250ce9c
	if ctx.cr[6].eq {
	pc = 0x8250CE9C; continue 'dispatch;
	}
	// 8250CE38: 80EB0014  lwz r7, 0x14(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8250CE3C: 54882036  slwi r8, r4, 4
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8250CE40: 892B0030  lbz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8250CE44: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8250CE48: 7CE83A14  add r7, r8, r7
	ctx.r[7].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 8250CE4C: C00B002C  lfs f0, 0x2c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8250CE50: 3D008206  lis r8, -0x7dfa
	ctx.r[8].s64 = -2113536000;
	// 8250CE54: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8250CE58: 39083134  addi r8, r8, 0x3134
	ctx.r[8].s64 = ctx.r[8].s64 + 12596;
	// 8250CE5C: 3BE00004  li r31, 4
	ctx.r[31].s64 = 4;
	// 8250CE60: A0E7000C  lhz r7, 0xc(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 8250CE64: 39450050  addi r10, r5, 0x50
	ctx.r[10].s64 = ctx.r[5].s64 + 80;
	// 8250CE68: B0650006  sth r3, 6(r5)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[5].u32.wrapping_add(6 as u32), ctx.r[3].u16 ) };
	// 8250CE6C: D0050010  stfs f0, 0x10(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8250CE70: 90C50008  stw r6, 8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 8250CE74: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 8250CE78: 91050000  stw r8, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8250CE7C: 93E5000C  stw r31, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8250CE80: 99250016  stb r9, 0x16(r5)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[5].u32.wrapping_add(22 as u32), ctx.r[9].u8 ) };
	// 8250CE84: B0E50014  sth r7, 0x14(r5)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[5].u32.wrapping_add(20 as u32), ctx.r[7].u16 ) };
	pc = 0x8250CE9C; continue 'dispatch;
            }
            0x8250CE9C => {
    //   block [0x8250CE9C..0x8250CF08)
	// 8250CE9C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8250CEA0: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8250CEA4: 548A2036  slwi r10, r4, 4
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8250CEA8: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250CEAC: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 8250CEB0: 38C00030  li r6, 0x30
	ctx.r[6].s64 = 48;
	// 8250CEB4: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 8250CEB8: 7D2A482E  lwzx r9, r10, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8250CEBC: 55292036  slwi r9, r9, 4
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250CF08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8250CF08 size=296
    let mut pc: u32 = 0x8250CF08;
    'dispatch: loop {
        match pc {
            0x8250CF08 => {
    //   block [0x8250CF08..0x8250CF88)
	// 8250CF08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250CF0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8250CF10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8250CF14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8250CF18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250CF1C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8250CF20: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8250CF24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8250CF28: 388B4A38  addi r4, r11, 0x4a38
	ctx.r[4].s64 = ctx.r[11].s64 + 19000;
	// 8250CF2C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 8250CF30: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250CF34: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8250CF38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8250CF3C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250CF40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250CF44: 4E800421  bctrl
	ctx.lr = 0x8250CF48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250CF48: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8250CF4C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8250CF50: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8250CF54: 409A0034  bne cr6, 0x8250cf88
	if !ctx.cr[6].eq {
	pc = 0x8250CF88; continue 'dispatch;
	}
	// 8250CF58: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250CF5C: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 8250CF60: 80FF001C  lwz r7, 0x1c(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8250CF64: 55682036  slwi r8, r11, 4
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8250CF68: 80DF0018  lwz r6, 0x18(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250CF6C: 388A4A2C  addi r4, r10, 0x4a2c
	ctx.r[4].s64 = ctx.r[10].s64 + 18988;
	// 8250CF70: 54E72036  slwi r7, r7, 4
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(4);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 8250CF74: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8250CF78: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250CF7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8250CF80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250CF84: 4E800421  bctrl
	ctx.lr = 0x8250CF88;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8250CF88 => {
    //   block [0x8250CF88..0x8250CFC8)
	// 8250CF88: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 8250CF8C: 554B0000  rlwinm r11, r10, 0, 0, 0
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8250CF90: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8250CF94: 409A0034  bne cr6, 0x8250cfc8
	if !ctx.cr[6].eq {
	pc = 0x8250CFC8; continue 'dispatch;
	}
	// 8250CF98: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250CF9C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8250CFA0: 80FF0028  lwz r7, 0x28(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 8250CFA4: 55482036  slwi r8, r10, 4
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8250CFA8: 388B4A20  addi r4, r11, 0x4a20
	ctx.r[4].s64 = ctx.r[11].s64 + 18976;
	// 8250CFAC: 80DF0024  lwz r6, 0x24(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 8250CFB0: 54E72036  slwi r7, r7, 4
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(4);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 8250CFB4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8250CFB8: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250CFBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8250CFC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250CFC4: 4E800421  bctrl
	ctx.lr = 0x8250CFC8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8250CFC8 => {
    //   block [0x8250CFC8..0x8250D004)
	// 8250CFC8: 815F0038  lwz r10, 0x38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 8250CFCC: 554B0000  rlwinm r11, r10, 0, 0, 0
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8250CFD0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8250CFD4: 409A0030  bne cr6, 0x8250d004
	if !ctx.cr[6].eq {
	pc = 0x8250D004; continue 'dispatch;
	}
	// 8250CFD8: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250CFDC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8250CFE0: 80FF0034  lwz r7, 0x34(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 8250CFE4: 554800BE  clrlwi r8, r10, 2
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 8250CFE8: 388B4A14  addi r4, r11, 0x4a14
	ctx.r[4].s64 = ctx.r[11].s64 + 18964;
	// 8250CFEC: 80DF0030  lwz r6, 0x30(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8250CFF0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8250CFF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8250CFF8: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 8250CFFC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250D000: 4E800421  bctrl
	ctx.lr = 0x8250D004;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8250D004 => {
    //   block [0x8250D004..0x8250D030)
	// 8250D004: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250D008: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8250D00C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250D010: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250D014: 4E800421  bctrl
	ctx.lr = 0x8250D018;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250D018: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8250D01C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8250D020: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8250D024: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8250D028: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8250D02C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250D030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8250D030 size=144
    let mut pc: u32 = 0x8250D030;
    'dispatch: loop {
        match pc {
            0x8250D030 => {
    //   block [0x8250D030..0x8250D070)
	// 8250D030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250D034: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8250D038: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8250D03C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8250D040: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250D044: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8250D048: 3BC5FFD0  addi r30, r5, -0x30
	ctx.r[30].s64 = ctx.r[5].s64 + -48;
	// 8250D04C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8250D050: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250D054: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250D058: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250D05C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250D060: 4E800421  bctrl
	ctx.lr = 0x8250D064;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250D064: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8250D068: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8250D06C: 4098000C  bge cr6, 0x8250d078
	if !ctx.cr[6].lt {
	pc = 0x8250D078; continue 'dispatch;
	}
            }
            0x8250D070 => {
    //   block [0x8250D070..0x8250D078)
	// 8250D070: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 8250D074: 48000034  b 0x8250d0a8
	pc = 0x8250D0A8; continue 'dispatch;
            }
            0x8250D078 => {
    //   block [0x8250D078..0x8250D0A0)
	// 8250D078: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 8250D07C: 4199FFF4  bgt cr6, 0x8250d070
	if ctx.cr[6].gt {
	pc = 0x8250D070; continue 'dispatch;
	}
	// 8250D080: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250D084: 393F0030  addi r9, r31, 0x30
	ctx.r[9].s64 = ctx.r[31].s64 + 48;
	// 8250D088: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8250D08C: 409A0014  bne cr6, 0x8250d0a0
	if !ctx.cr[6].eq {
	pc = 0x8250D0A0; continue 'dispatch;
	}
	// 8250D090: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8250D094: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 8250D098: 915F001C  stw r10, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 8250D09C: 4800000C  b 0x8250d0a8
	pc = 0x8250D0A8; continue 'dispatch;
            }
            0x8250D0A0 => {
    //   block [0x8250D0A0..0x8250D0A8)
	// 8250D0A0: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 8250D0A4: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	pc = 0x8250D0A8; continue 'dispatch;
            }
            0x8250D0A8 => {
    //   block [0x8250D0A8..0x8250D0C0)
	// 8250D0A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8250D0AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8250D0B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8250D0B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8250D0B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8250D0BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250D0C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8250D0C0 size=20
    let mut pc: u32 = 0x8250D0C0;
    'dispatch: loop {
        match pc {
            0x8250D0C0 => {
    //   block [0x8250D0C0..0x8250D0D4)
	// 8250D0C0: 80630018  lwz r3, 0x18(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250D0C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250D0C8: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 8250D0CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250D0D0: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250D0D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8250D0D8 size=144
    let mut pc: u32 = 0x8250D0D8;
    'dispatch: loop {
        match pc {
            0x8250D0D8 => {
    //   block [0x8250D0D8..0x8250D168)
	// 8250D0D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250D0DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8250D0E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8250D0E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8250D0E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250D0EC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8250D0F0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8250D0F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8250D0F8: 388B4A44  addi r4, r11, 0x4a44
	ctx.r[4].s64 = ctx.r[11].s64 + 19012;
	// 8250D0FC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 8250D100: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250D104: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8250D108: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250D10C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250D110: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250D114: 4E800421  bctrl
	ctx.lr = 0x8250D118;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250D118: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250D11C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8250D120: 80DE0018  lwz r6, 0x18(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250D124: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8250D128: 388B485C  addi r4, r11, 0x485c
	ctx.r[4].s64 = ctx.r[11].s64 + 18524;
	// 8250D12C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250D130: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 8250D134: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250D138: 4E800421  bctrl
	ctx.lr = 0x8250D13C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250D13C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250D140: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8250D144: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250D148: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250D14C: 4E800421  bctrl
	ctx.lr = 0x8250D150;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250D150: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8250D154: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8250D158: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8250D15C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8250D160: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8250D164: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250D168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8250D168 size=8
    let mut pc: u32 = 0x8250D168;
    'dispatch: loop {
        match pc {
            0x8250D168 => {
    //   block [0x8250D168..0x8250D170)
	// 8250D168: 38630014  addi r3, r3, 0x14
	ctx.r[3].s64 = ctx.r[3].s64 + 20;
	// 8250D16C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250D170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8250D170 size=104
    let mut pc: u32 = 0x8250D170;
    'dispatch: loop {
        match pc {
            0x8250D170 => {
    //   block [0x8250D170..0x8250D1D8)
	// 8250D170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250D174: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8250D178: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8250D17C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8250D180: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250D184: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8250D188: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8250D18C: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250D190: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250D194: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8250D198: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250D19C: 4E800421  bctrl
	ctx.lr = 0x8250D1A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250D1A0: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250D1D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8250D1D8 size=164
    let mut pc: u32 = 0x8250D1D8;
    'dispatch: loop {
        match pc {
            0x8250D1D8 => {
    //   block [0x8250D1D8..0x8250D1F4)
	// 8250D1D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250D1DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8250D1E0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250D1E4: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 8250D1E8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 8250D1EC: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 8250D1F0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x8250D1F4; continue 'dispatch;
            }
            0x8250D1F4 => {
    //   block [0x8250D1F4..0x8250D27C)
	// 8250D1F4: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 8250D1F8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8250D1FC: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 8250D200: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8250D204: 4200FFF0  bdnz 0x8250d1f4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8250D1F4; continue 'dispatch;
	}
	// 8250D208: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250D280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8250D280 size=92
    let mut pc: u32 = 0x8250D280;
    'dispatch: loop {
        match pc {
            0x8250D280 => {
    //   block [0x8250D280..0x8250D2DC)
	// 8250D280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250D284: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8250D288: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8250D28C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8250D290: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250D294: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8250D298: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 8250D29C: 807E0018  lwz r3, 0x18(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250D2A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250D2A4: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8250D2A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250D2AC: 4E800421  bctrl
	ctx.lr = 0x8250D2B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250D2B0: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250D2E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8250D2E0 size=104
    let mut pc: u32 = 0x8250D2E0;
    'dispatch: loop {
        match pc {
            0x8250D2E0 => {
    //   block [0x8250D2E0..0x8250D340)
	// 8250D2E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250D2E4: 48027DD9  bl 0x825350bc
	ctx.lr = 0x8250D2E8;
	sub_82535080(ctx, base);
	// 8250D2E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250D2EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8250D2F0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 8250D2F4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 8250D2F8: 807E0018  lwz r3, 0x18(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250D2FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250D300: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 8250D304: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250D308: 4E800421  bctrl
	ctx.lr = 0x8250D30C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250D30C: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8250D310: 40990030  ble cr6, 0x8250d340
	if !ctx.cr[6].gt {
	pc = 0x8250D340; continue 'dispatch;
	}
	// 8250D314: 393E0020  addi r9, r30, 0x20
	ctx.r[9].s64 = ctx.r[30].s64 + 32;
	// 8250D318: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 8250D31C: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
            }
            0x8250D340 => {
    //   block [0x8250D340..0x8250D348)
	// 8250D340: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8250D344: 48027DC8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250D348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8250D348 size=92
    let mut pc: u32 = 0x8250D348;
    'dispatch: loop {
        match pc {
            0x8250D348 => {
    //   block [0x8250D348..0x8250D3A4)
	// 8250D348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250D34C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8250D350: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8250D354: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8250D358: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250D35C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8250D360: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8250D364: 807E0018  lwz r3, 0x18(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250D368: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250D36C: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 8250D370: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250D374: 4E800421  bctrl
	ctx.lr = 0x8250D378;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250D378: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250D3A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8250D3A8 size=92
    let mut pc: u32 = 0x8250D3A8;
    'dispatch: loop {
        match pc {
            0x8250D3A8 => {
    //   block [0x8250D3A8..0x8250D404)
	// 8250D3A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250D3AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8250D3B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8250D3B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8250D3B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250D3BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8250D3C0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8250D3C4: 807E0018  lwz r3, 0x18(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250D3C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250D3CC: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 8250D3D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250D3D4: 4E800421  bctrl
	ctx.lr = 0x8250D3D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250D3D8: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250D408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8250D408 size=136
    let mut pc: u32 = 0x8250D408;
    'dispatch: loop {
        match pc {
            0x8250D408 => {
    //   block [0x8250D408..0x8250D484)
	// 8250D408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250D40C: 48027CAD  bl 0x825350b8
	ctx.lr = 0x8250D410;
	sub_82535080(ctx, base);
	// 8250D410: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250D414: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8250D418: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 8250D41C: 807D0018  lwz r3, 0x18(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250D420: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250D424: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8250D428: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250D42C: 4E800421  bctrl
	ctx.lr = 0x8250D430;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250D430: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250D434: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8250D438: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8250D43C: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 8250D440: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250D444: 816A0024  lwz r11, 0x24(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 8250D448: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250D44C: 4E800421  bctrl
	ctx.lr = 0x8250D450;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250D450: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8250D454: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8250D458: 4099002C  ble cr6, 0x8250d484
	if !ctx.cr[6].gt {
	pc = 0x8250D484; continue 'dispatch;
	}
	// 8250D45C: 395D0020  addi r10, r29, 0x20
	ctx.r[10].s64 = ctx.r[29].s64 + 32;
            }
            0x8250D484 => {
    //   block [0x8250D484..0x8250D490)
	// 8250D484: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8250D488: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8250D48C: 48027C7C  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250D490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8250D490 size=116
    let mut pc: u32 = 0x8250D490;
    'dispatch: loop {
        match pc {
            0x8250D490 => {
    //   block [0x8250D490..0x8250D4E4)
	// 8250D490: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 8250D494: C0040010  lfs f0, 0x10(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8250D498: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 8250D49C: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8250D4A0: 396B36E4  addi r11, r11, 0x36e4
	ctx.r[11].s64 = ctx.r[11].s64 + 14052;
	// 8250D4A4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 8250D4A8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8250D4AC: 38E0000C  li r7, 0xc
	ctx.r[7].s64 = 12;
	// 8250D4B0: 394A2A68  addi r10, r10, 0x2a68
	ctx.r[10].s64 = ctx.r[10].s64 + 10856;
	// 8250D4B4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8250D4B8: B1030006  sth r8, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[8].u16 ) };
	// 8250D4BC: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 8250D4C0: 90E3000C  stw r7, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 8250D4C4: 91430014  stw r10, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 8250D4C8: 90830018  stw r4, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[4].u32 ) };
	// 8250D4CC: A1640004  lhz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250D4D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8250D4D4: 419A0010  beq cr6, 0x8250d4e4
	if ctx.cr[6].eq {
	pc = 0x8250D4E4; continue 'dispatch;
	}
	// 8250D4D8: A1640006  lhz r11, 6(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(6 as u32) ) } as u64;
	// 8250D4DC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8250D4E0: B1640006  sth r11, 6(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	pc = 0x8250D4E4; continue 'dispatch;
            }
            0x8250D4E4 => {
    //   block [0x8250D4E4..0x8250D504)
	// 8250D4E4: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250D508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8250D508 size=132
    let mut pc: u32 = 0x8250D508;
    'dispatch: loop {
        match pc {
            0x8250D508 => {
    //   block [0x8250D508..0x8250D58C)
	// 8250D508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250D50C: 48027BB1  bl 0x825350bc
	ctx.lr = 0x8250D510;
	sub_82535080(ctx, base);
	// 8250D510: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250D514: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8250D518: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8250D51C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 8250D520: 807D0018  lwz r3, 0x18(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 8250D524: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250D528: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 8250D52C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8250D530: 4E800421  bctrl
	ctx.lr = 0x8250D534;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8250D534: 395D0020  addi r10, r29, 0x20
	ctx.r[10].s64 = ctx.r[29].s64 + 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250D590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8250D590 size=304
    let mut pc: u32 = 0x8250D590;
    'dispatch: loop {
        match pc {
            0x8250D590 => {
    //   block [0x8250D590..0x8250D5E0)
	// 8250D590: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8250D594: 48027B25  bl 0x825350b8
	ctx.lr = 0x8250D598;
	sub_82535080(ctx, base);
	// 8250D598: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8250D59C: 838D0000  lwz r28, 0(r13)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 8250D5A0: 3BA00014  li r29, 0x14
	ctx.r[29].s64 = 20;
	// 8250D5A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8250D5A8: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 8250D5AC: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 8250D5B0: 7D7DE02E  lwzx r11, r29, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 8250D5B4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8250D5B8: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8250D5BC: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 8250D5C0: 40980020  bge cr6, 0x8250d5e0
	if !ctx.cr[6].lt {
	pc = 0x8250D5E0; continue 'dispatch;
	}
	// 8250D5C4: 3D008206  lis r8, -0x7dfa
	ctx.r[8].s64 = -2113536000;
	// 8250D5C8: 39084A54  addi r8, r8, 0x4a54
	ctx.r[8].s64 = ctx.r[8].s64 + 19028;
	// 8250D5CC: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8250D5D0: 7D0C42E6  mftb r8, 0x10c
	ctx.r[8].u64 = crate::rt::rdtsc_u64();
	// 8250D5D4: 38EA000C  addi r7, r10, 0xc
	ctx.r[7].s64 = ctx.r[10].s64 + 12;
	// 8250D5D8: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 8250D5DC: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	pc = 0x8250D5E0; continue 'dispatch;
            }
            0x8250D5E0 => {
    //   block [0x8250D5E0..0x8250D5F0)
	// 8250D5E0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8250D5E4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 8250D5E8: 39000006  li r8, 6
	ctx.r[8].s64 = 6;
	// 8250D5EC: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x8250D5F0; continue 'dispatch;
            }
            0x8250D5F0 => {
    //   block [0x8250D5F0..0x8250D6C0)
	// 8250D5F0: E90B0000  ld r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 8250D5F4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8250D5F8: F90A0000  std r8, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 8250D5FC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8250D600: 4200FFF0  bdnz 0x8250d5f0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8250D5F0; continue 'dispatch;
	}
	// 8250D604: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 8250D608: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8250D6C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8250D6C8 size=8
    let mut pc: u32 = 0x8250D6C8;
    'dispatch: loop {
        match pc {
            0x8250D6C8 => {
    //   block [0x8250D6C8..0x8250D6D0)
	// 8250D6C8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8250D6CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


